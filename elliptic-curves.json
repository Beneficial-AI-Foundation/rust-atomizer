[
  {
    "identifier": "0.14.0_pre.8 schnorr/tagged_hash",
    "statement_type": "function",
    "deps": [],
    "body": "fn tagged_hash(tag: &[u8]) -> Sha256 {\n    let tag_hash = Sha256::digest(tag);\n    let mut digest = Sha256::new();\n    digest.update(tag_hash);\n    digest.update(tag_hash);\n    digest\n}",
    "display_name": "tagged_hash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 decode_pkcs8_private_key_from_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_private_key_from_pem() {\n    let secret_key = PKCS8_PRIVATE_KEY_PEM.parse::<p256::SecretKey>().unwrap();\n\n    // Ensure key parses equivalently to DER\n    let der_key = p256::SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    assert_eq!(secret_key.to_bytes(), der_key.to_bytes());\n}",
    "display_name": "decode_pkcs8_private_key_from_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/pkcs8.rs",
    "relative_path": "p256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/is_zero",
      "0.14.0_pre.1 field/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
      "0.14.0_pre.1 field/scalar/impl/Scalar/exp_vartime"
    ],
    "body": "    pub fn invert(&self) -> Self {\n        Self::conditional_select(\n            &self.exp_vartime(&[\n                0x2378c292ab5844f1,\n                0x216cc2728dc58f55,\n                0xc44edb49aed63690,\n                0xffffffff7cca23e9,\n                0xffffffffffffffff,\n                0xffffffffffffffff,\n                0x3fffffffffffffff,\n            ]),\n            &Self::ZERO,\n            self.is_zero(),\n        )\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p384_u1,\n    arg1: fiat_p384_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_p384_u1 = ((x1 >> 64) as fiat_p384_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p384_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/is_zero"
    ],
    "body": "    pub fn is_zero(&self) -> Choice {\n        self.0.is_zero()\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/square",
      "0.14.0_pre.1 field/scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        let ss = self.pow([\n            0x48de30a4aad6113d,\n            0x085b309ca37163d5,\n            0x7113b6d26bb58da4,\n            0xffffffffdf3288fa,\n            0xffffffffffffffff,\n            0xffffffffffffffff,\n            0x0fffffffffffffff,\n        ]);\n        CtOption::new(ss, ss.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/&FieldElement/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> FieldElement {\n        -*self\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/TryFrom, ed448::pkcs8::BitStringRef>>/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(public_key: pkcs8::spki::SubjectPublicKeyInfoRef<'_>) -> pkcs8::spki::Result<Self> {\n        PublicKeyBytes::try_from(public_key)?.try_into()\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> FieldBytes {\n        self.secret_key.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/add_modulus_correction",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_modulus_correction(&self, x: u64) -> Self {\n        // add (2^256 - modulus) * x to the first limb\n        let t0 = self.0[0] + x * 0x1000003D1u64;\n\n        // Propagate excess bits up the limbs\n        let t1 = self.0[1] + (t0 >> 52);\n        let t0 = t0 & 0xFFFFFFFFFFFFFu64;\n\n        let t2 = self.0[2] + (t1 >> 52);\n        let t1 = t1 & 0xFFFFFFFFFFFFFu64;\n\n        let t3 = self.0[3] + (t2 >> 52);\n        let t2 = t2 & 0xFFFFFFFFFFFFFu64;\n\n        let t4 = self.0[4] + (t3 >> 52);\n        let t3 = t3 & 0xFFFFFFFFFFFFFu64;\n\n        Self([t0, t1, t2, t3, t4])\n    }",
    "display_name": "add_modulus_correction",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_y() -> Scalar {\n    Scalar::from_repr(\n        [\n            0x67, 0xe2, 0xf6, 0x80, 0x71, 0xed, 0x82, 0x81, 0xe8, 0xae, 0xd6, 0xbc, 0xf1, 0xc5,\n            0x20, 0x7c, 0x5e, 0x63, 0x37, 0x22, 0xd9, 0x20, 0xaf, 0xd6, 0xae, 0x22, 0xd0, 0x6e,\n            0xeb, 0x80, 0x35, 0xe3,\n        ]\n        .into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_scalar_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_sm2_scalar_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Sub>/sub",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub(self, other: AffinePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::sub_mixed(&self, &other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/invert"
    ],
    "body": "    pub(crate) fn add(&self, other: &AffinePoint) -> AffinePoint {\n        let y_numerator = self.y * other.y + self.x * other.x;\n        let y_denominator =\n            FieldElement::ONE - FieldElement::TWISTED_D * self.x * other.x * self.y * other.y;\n\n        let x_numerator = self.x * other.y + self.y * other.x;\n        let x_denominator =\n            FieldElement::ONE + FieldElement::TWISTED_D * self.x * other.x * self.y * other.y;\n\n        let x = x_numerator * x_denominator.invert();\n        let y = y_numerator * y_denominator.invert();\n        AffinePoint { x, y }\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_opp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_carry_opp(\n    out1: &mut fiat_p521_tight_field_element,\n    arg1: &fiat_p521_tight_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (0x7fffffffffffffe - (arg1[0]));\n    let x2: u64 = ((((x1 >> 58) as fiat_p521_u1) as u64) + (0x7fffffffffffffe - (arg1[1])));\n    let x3: u64 = ((((x2 >> 58) as fiat_p521_u1) as u64) + (0x7fffffffffffffe - (arg1[2])));\n    let x4: u64 = ((((x3 >> 58) as fiat_p521_u1) as u64) + (0x7fffffffffffffe - (arg1[3])));\n    let x5: u64 = ((((x4 >> 58) as fiat_p521_u1) as u64) + (0x7fffffffffffffe - (arg1[4])));\n    let x6: u64 = ((((x5 >> 58) as fiat_p521_u1) as u64) + (0x7fffffffffffffe - (arg1[5])));\n    let x7: u64 = ((((x6 >> 58) as fiat_p521_u1) as u64) + (0x7fffffffffffffe - (arg1[6])));\n    let x8: u64 = ((((x7 >> 58) as fiat_p521_u1) as u64) + (0x7fffffffffffffe - (arg1[7])));\n    let x9: u64 = ((((x8 >> 58) as fiat_p521_u1) as u64) + (0x3fffffffffffffe - (arg1[8])));\n    let x10: u64 = ((x1 & 0x3ffffffffffffff) + (((x9 >> 57) as fiat_p521_u1) as u64));\n    let x11: u64 = ((((x10 >> 58) as fiat_p521_u1) as u64) + (x2 & 0x3ffffffffffffff));\n    let x12: u64 = (x10 & 0x3ffffffffffffff);\n    let x13: u64 = (x11 & 0x3ffffffffffffff);\n    let x14: u64 = ((((x11 >> 58) as fiat_p521_u1) as u64) + (x3 & 0x3ffffffffffffff));\n    let x15: u64 = (x4 & 0x3ffffffffffffff);\n    let x16: u64 = (x5 & 0x3ffffffffffffff);\n    let x17: u64 = (x6 & 0x3ffffffffffffff);\n    let x18: u64 = (x7 & 0x3ffffffffffffff);\n    let x19: u64 = (x8 & 0x3ffffffffffffff);\n    let x20: u64 = (x9 & 0x1ffffffffffffff);\n    out1[0] = x12;\n    out1[1] = x13;\n    out1[2] = x14;\n    out1[3] = x15;\n    out1[4] = x16;\n    out1[5] = x17;\n    out1[6] = x18;\n    out1[7] = x19;\n    out1[8] = x20;\n}",
    "display_name": "fiat_p521_carry_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p384_opp(\n    out1: &mut fiat_p384_montgomery_domain_field_element,\n    arg1: &fiat_p384_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x9, &mut x10, x8, (0x0 as u64), (arg1[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x11, &mut x12, x10, (0x0 as u64), (arg1[5]));\n    let mut x13: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x13, x12, (0x0 as u64), 0xffffffffffffffff);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x14, &mut x15, 0x0, x1, (x13 & 0xffffffff));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x16, &mut x17, x15, x3, (x13 & 0xffffffff00000000));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x18, &mut x19, x17, x5, (x13 & 0xfffffffffffffffe));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x20, &mut x21, x19, x7, x13);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x22, &mut x23, x21, x9, x13);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x24, &mut x25, x23, x11, x13);\n    out1[0] = x14;\n    out1[1] = x16;\n    out1[2] = x18;\n    out1[3] = x20;\n    out1[4] = x22;\n    out1[5] = x24;\n}",
    "display_name": "fiat_p384_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &CompressedEdwardsY) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_sm2_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre bench_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre bench_point_mul"
    ],
    "body": "fn bench_point(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"point operations\");\n    bench_point_mul(&mut group);\n    group.finish();\n}",
    "display_name": "bench_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "affine/impl/&AffinePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/From>/from"
    ],
    "body": "    fn mul(self, scalar: S) -> ProjectivePoint<C> {\n        ProjectivePoint::<C>::from(self) * scalar\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_cmovznz_u64(\n    out1: &mut u64,\n    arg1: fiat_sm2_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: fiat_sm2_scalar_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_sm2_scalar_i2) - (x1 as fiat_sm2_scalar_i2))\n        as fiat_sm2_scalar_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_sm2_scalar_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/subtract_modulus_approximation",
    "statement_type": "function",
    "deps": [],
    "body": "    fn subtract_modulus_approximation(&self) -> (Self, u64) {\n        let x = self.0[4] >> 48;\n        let t4 = self.0[4] & 0x0FFFFFFFFFFFFu64; // equivalent to self -= 2^256 * x\n        (Self([self.0[0], self.0[1], self.0[2], self.0[3], t4]), x)\n    }",
    "display_name": "subtract_modulus_approximation",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/Radix16Decomposition/new",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero"
    ],
    "body": "    fn new(x: &Scalar) -> Self {\n        debug_assert!((x >> (4 * (D - 1))).is_zero().unwrap_u8() == 1);\n\n        // The resulting decomposition can be negative, so, despite the limit on `x`,\n        // we need an additional byte to store the carry.\n        let mut output = [0i8; D];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        let bytes = x.to_bytes();\n        for i in 0..(D - 1) / 2 {\n            output[2 * i] = (bytes[31 - i] & 0xf) as i8;\n            output[2 * i + 1] = ((bytes[31 - i] >> 4) & 0xf) as i8;\n        }\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..(D - 1) {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n\n        Self(output)\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/FromOkm/from_okm",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_okm(data: &Array<u8, Self::Length>) -> Self {\n        const SEMI_WIDE_MODULUS: NonZero<U704> = NonZero::<U704>::new_unwrap(U704::from_be_hex(\n            \"0000000000000000000000000000000000000000000000000000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n        ));\n        let mut tmp = Array::<u8, U88>::default();\n        tmp[4..].copy_from_slice(&data[..]);\n\n        let mut num = U704::from_be_slice(&tmp[..]);\n        num %= SEMI_WIDE_MODULUS;\n\n        let bytes =\n            <[u8; 56]>::try_from(&num.to_le_bytes()[..56]).expect(\"slice is the wrong length\");\n        FieldElement(ConstMontyType::new(&U448::from_le_slice(&bytes)))\n    }",
    "display_name": "from_okm",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqn"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        // p mod 4 = 3 -> compute sqrt(x) using x^((p+1)/4) =\n        // x^9850501549098619803069760025035903451269934817616361666987073351061430442874217582261816522064734500465401743278080\n        let t1 = *self;\n        let t10 = t1.square();\n        let t11 = t1 * t10;\n        let t110 = t11.square();\n        let t111 = t1 * t110;\n        let t111000 = t111.sqn(3);\n        let t111111 = t111 * t111000;\n        let t1111110 = t111111.square();\n        let t1111111 = t1 * t1111110;\n        let x12 = t1111110.sqn(5) * t111111;\n        let x24 = x12.sqn(12) * x12;\n        let x31 = x24.sqn(7) * t1111111;\n        let x32 = x31.square() * t1;\n        let x63 = x32.sqn(31) * x31;\n        let x126 = x63.sqn(63) * x63;\n        let x252 = x126.sqn(126) * x126;\n        let x255 = x252.sqn(3) * t111;\n        let x = ((x255.sqn(33) * x32).sqn(64) * t1).sqn(30);\n        CtOption::new(x, x.square().ct_eq(&t1))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/NonIdentity>/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(point: ProjectivePoint<C>) -> Result<Self> {\n        NonIdentity::new(point).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/test_isogeny",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/double",
      "0.14.0_pre.1 curve/edwards/extended/tests/hex_to_field",
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_twisted",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_untwisted"
    ],
    "body": "    fn test_isogeny() {\n        let x = hex_to_field(\n            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa955555555555555555555555555555555555555555555555555555555\",\n        );\n        let y = hex_to_field(\n            \"ae05e9634ad7048db359d6205086c2b0036ed7a035884dd7b7e36d728ad8c4b80d6565833a2a3098bbbcb2bed1cda06bdaeafbcdea9386ed\",\n        );\n        let a = AffinePoint { x, y }.to_edwards();\n        let twist_a = a.to_twisted().to_untwisted();\n        assert!(twist_a == a.double().double())\n    }",
    "display_name": "test_isogeny",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Group/try_from_rng",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> core::result::Result<Self, R::Error> {\n        Ok(Self::GENERATOR * <Scalar<C> as Field>::try_from_rng(rng)?)\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_square(\n    out1: &mut fiat_sm2_scalar_montgomery_domain_field_element,\n    arg1: &fiat_sm2_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x5, &mut x6, x4, (arg1[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x7, &mut x8, x4, (arg1[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x9, &mut x10, x4, (arg1[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x11, &mut x12, x4, (arg1[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x20, &mut x21, x11, 0x327f9e8872350975);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x22, &mut x23, x20, 0xfffffffeffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x26, &mut x27, x20, 0x7203df6b21c6052b);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x28, &mut x29, x20, 0x53bbf40939d54123);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x30, &mut x31, 0x0, x29, x26);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x27, x24);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x25, x22);\n    let x36: u64 = ((x35 as u64) + x23);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x37, &mut x38, 0x0, x11, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x13, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x15, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x43, &mut x44, x42, x17, x34);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x45, &mut x46, x44, x19, x36);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x47, &mut x48, x1, (arg1[3]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x49, &mut x50, x1, (arg1[2]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x51, &mut x52, x1, (arg1[1]));\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x53, &mut x54, x1, (arg1[0]));\n    let mut x55: u64 = 0;\n    let mut x56: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x55, &mut x56, 0x0, x54, x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x52, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x50, x47);\n    let x61: u64 = ((x60 as u64) + x48);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x45, x59);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x70, &mut x71, x69, (x46 as u64), x61);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x72, &mut x73, x62, 0x327f9e8872350975);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x74, &mut x75, x72, 0xfffffffeffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x78, &mut x79, x72, 0x7203df6b21c6052b);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x80, &mut x81, x72, 0x53bbf40939d54123);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x82, &mut x83, 0x0, x81, x78);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x79, x76);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x77, x74);\n    let x88: u64 = ((x87 as u64) + x75);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x89, &mut x90, 0x0, x62, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x91, &mut x92, x90, x64, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x93, &mut x94, x92, x66, x84);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x95, &mut x96, x94, x68, x86);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x97, &mut x98, x96, x70, x88);\n    let x99: u64 = ((x98 as u64) + (x71 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x100, &mut x101, x2, (arg1[3]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x102, &mut x103, x2, (arg1[2]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x104, &mut x105, x2, (arg1[1]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x106, &mut x107, x2, (arg1[0]));\n    let mut x108: u64 = 0;\n    let mut x109: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x107, x104);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x105, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x103, x100);\n    let x114: u64 = ((x113 as u64) + x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x115, &mut x116, 0x0, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x121, &mut x122, x120, x97, x112);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x123, &mut x124, x122, x99, x114);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x125, &mut x126, x115, 0x327f9e8872350975);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x127, &mut x128, x125, 0xfffffffeffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x129, &mut x130, x125, 0xffffffffffffffff);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x131, &mut x132, x125, 0x7203df6b21c6052b);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x133, &mut x134, x125, 0x53bbf40939d54123);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let x141: u64 = ((x140 as u64) + x128);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x142, &mut x143, 0x0, x115, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x144, &mut x145, x143, x117, x135);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x146, &mut x147, x145, x119, x137);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x148, &mut x149, x147, x121, x139);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x150, &mut x151, x149, x123, x141);\n    let x152: u64 = ((x151 as u64) + (x124 as u64));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x153, &mut x154, x3, (arg1[3]));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x155, &mut x156, x3, (arg1[2]));\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x157, &mut x158, x3, (arg1[1]));\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x159, &mut x160, x3, (arg1[0]));\n    let mut x161: u64 = 0;\n    let mut x162: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x161, &mut x162, 0x0, x160, x157);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x163, &mut x164, x162, x158, x155);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x165, &mut x166, x164, x156, x153);\n    let x167: u64 = ((x166 as u64) + x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x168, &mut x169, 0x0, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x148, x163);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x150, x165);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x152, x167);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x178, &mut x179, x168, 0x327f9e8872350975);\n    let mut x180: u64 = 0;\n    let mut x181: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x180, &mut x181, x178, 0xfffffffeffffffff);\n    let mut x182: u64 = 0;\n    let mut x183: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x182, &mut x183, x178, 0xffffffffffffffff);\n    let mut x184: u64 = 0;\n    let mut x185: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x184, &mut x185, x178, 0x7203df6b21c6052b);\n    let mut x186: u64 = 0;\n    let mut x187: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x186, &mut x187, x178, 0x53bbf40939d54123);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x188, &mut x189, 0x0, x187, x184);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x190, &mut x191, x189, x185, x182);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x183, x180);\n    let x194: u64 = ((x193 as u64) + x181);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x195, &mut x196, 0x0, x168, x186);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x197, &mut x198, x196, x170, x188);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x172, x190);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x174, x192);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x176, x194);\n    let x205: u64 = ((x204 as u64) + (x177 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x206, &mut x207, 0x0, x197, 0x53bbf40939d54123);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x208, &mut x209, x207, x199, 0x7203df6b21c6052b);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x210, &mut x211, x209, x201, 0xffffffffffffffff);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x212, &mut x213, x211, x203, 0xfffffffeffffffff);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x214, &mut x215, x213, x205, (0x0 as u64));\n    let mut x216: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x216, x215, x206, x197);\n    let mut x217: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x217, x215, x208, x199);\n    let mut x218: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x218, x215, x210, x201);\n    let mut x219: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x219, x215, x212, x203);\n    out1[0] = x216;\n    out1[1] = x217;\n    out1[2] = x218;\n    out1[3] = x219;\n}",
    "display_name": "fiat_sm2_scalar_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl//u8; 56//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/compress"
    ],
    "body": "    fn from(point: DecafPoint) -> DecafPointBytes {\n        point.compress().0\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/Curve/to_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_affine"
    ],
    "body": "    fn to_affine(&self) -> Self::AffineRepr {\n        DecafAffinePoint(self.0.to_affine())\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 test_scalar_y"
    ],
    "body": "fn bench_scalar_mul<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"mul\", |b| b.iter(|| x * y));\n}",
    "display_name": "bench_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 bench_high_level",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_point_lincomb",
      "0.14.0_pre.8 bench_point_mul_by_generator",
      "0.14.0_pre.8 bench_point_mul"
    ],
    "body": "fn bench_high_level(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"high-level operations\");\n    bench_point_mul(&mut group);\n    bench_point_mul_by_generator(&mut group);\n    bench_point_lincomb(&mut group);\n    group.finish();\n}",
    "display_name": "bench_high_level",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/invert_unchecked",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_canonical",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_hex",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64"
    ],
    "body": "    fn is_high(&self) -> Choice {\n        const MODULUS_SHR1: Uint = NistP224::ORDER.shr_vartime(1);\n        self.to_canonical().ct_gt(&MODULUS_SHR1)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_canonical",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_from_montgomery"
    ],
    "body": "    pub const fn to_canonical(self) -> U576 {\n        let mut out = fiat_p521_scalar_non_montgomery_domain_field_element([0; 9]);\n        fiat_p521_scalar_from_montgomery(&mut out, &self.0);\n        U576::from_words(out.0)\n    }",
    "display_name": "to_canonical",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize()\n    }",
    "display_name": "zeroize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/bigint::Uint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/bigint::Uint/From/from"
    ],
    "body": "    fn from(scalar: Scalar) -> U576 {\n        U576::from(&scalar)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/From/from"
    ],
    "body": "    fn from(tight: FieldElement) -> LooseFieldElement {\n        LooseFieldElement::from(&tight)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/rfc6979",
    "statement_type": "function",
    "deps": [],
    "body": "    fn rfc6979() {\n        let x = hex!(\n            \"6b9d3dad2e1b8c1c05b19875b6659f4de23c3b667bf297ba9aa47740787137d896d5724e4c70a825f872c9ea60d2edf5\"\n        );\n        let signer = SigningKey::from_bytes(&x.into()).unwrap();\n        let signature: Signature = signer.sign(b\"sample\");\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"94edbb92a5ecb8aad4736e56c691916b3f88140666ce9fa73d64c4ea95ad133c81a648152e44acf96e36dd1e80fabe46\n                99ef4aeb15f178cea1fe40db2603138f130e740a19624526203b6351d0a3a94fa329c145786e679e7b82c71a38628ac8\"\n            )\n        );\n\n        let signature: Signature = signer.sign(b\"test\");\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"8203b63d3c853e8d77227fb377bcf7b7b772e97892a80f36ab775d509d7a5feb0542a7f0812998da8f1dd3ca3cf023db\n                ddd0760448d42d8a43af45af836fce4de8be06b485e9b61b827c2f13173923e06a739f040649a667bf3b828246baa5a5\"\n            )\n        );\n    }",
    "display_name": "rfc6979",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/ecdsa.rs",
    "relative_path": "p384/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/negation",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate"
    ],
    "body": "    fn negation() {\n        let two = FieldElement::ONE.double();\n        let neg_two = two.negate(2);\n        assert_eq!((two + &neg_two).normalize(), FieldElement::ZERO);\n        assert_eq!(neg_two.negate(3).normalize(), two.normalize());\n    }",
    "display_name": "negation",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize_weak"
    ],
    "body": "    fn neg(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            x: self.x,\n            y: self.y.negate(1).normalize_weak(),\n            z: self.z,\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/pow_vartime"
    ],
    "body": "    const fn invert_unchecked(&self) -> Self {\n        // We need to find b such that b * a ≡ 1 mod p. As we are in a prime\n        // field, we can apply Fermat's Little Theorem:\n        //\n        //    a^p         ≡ a mod p\n        //    a^(p-1)     ≡ 1 mod p\n        //    a^(p-2) * a ≡ 1 mod p\n        //\n        // Thus inversion can be implemented with a single exponentiation.\n        //\n        // This is `n - 2`, so the top right two digits are `4f` instead of `51`.\n        self.pow_vartime(&[\n            0xf3b9_cac2_fc63_254f,\n            0xbce6_faad_a717_9e84,\n            0xffff_ffff_ffff_ffff,\n            0xffff_ffff_0000_0000,\n        ])\n    }",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p224_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 5],\n    out3: &mut [u64; 5],\n    out4: &mut [u64; 4],\n    out5: &mut [u64; 4],\n    arg1: u64,\n    arg2: &[u64; 5],\n    arg3: &[u64; 5],\n    arg4: &[u64; 4],\n    arg5: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_p224_u1 =\n        (((x1 >> 63) as fiat_p224_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_p224_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x12, &mut x13, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x14, &mut x15, x13, (0x0 as u64), (!(arg2[1])));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), (!(arg2[2])));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), (!(arg2[3])));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), (!(arg2[4])));\n    let mut x22: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x22, x3, (arg3[0]), x12);\n    let mut x23: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x23, x3, (arg3[1]), x14);\n    let mut x24: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x24, x3, (arg3[2]), x16);\n    let mut x25: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x25, x3, (arg3[3]), x18);\n    let mut x26: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x26, x3, (arg3[4]), x20);\n    let mut x27: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x27, x3, (arg4[0]), (arg5[0]));\n    let mut x28: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x28, x3, (arg4[1]), (arg5[1]));\n    let mut x29: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x29, x3, (arg4[2]), (arg5[2]));\n    let mut x30: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x30, x3, (arg4[3]), (arg5[3]));\n    let mut x31: u64 = 0;\n    let mut x32: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x31, &mut x32, 0x0, x27, x27);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x33, &mut x34, x32, x28, x28);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x35, &mut x36, x34, x29, x29);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x37, &mut x38, x36, x30, x30);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x39, &mut x40, 0x0, x31, (0x1 as u64));\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x41, &mut x42, x40, x33, 0xffffffff00000000);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x43, &mut x44, x42, x35, 0xffffffffffffffff);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x45, &mut x46, x44, x37, 0xffffffff);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x47, &mut x48, x46, (x38 as u64), (0x0 as u64));\n    let x49: u64 = (arg4[3]);\n    let x50: u64 = (arg4[2]);\n    let x51: u64 = (arg4[1]);\n    let x52: u64 = (arg4[0]);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x53, &mut x54, 0x0, (0x0 as u64), x52);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x55, &mut x56, x54, (0x0 as u64), x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x57, &mut x58, x56, (0x0 as u64), x50);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x59, &mut x60, x58, (0x0 as u64), x49);\n    let mut x61: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x61, x60, (0x0 as u64), 0xffffffffffffffff);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x62,\n        &mut x63,\n        0x0,\n        x53,\n        (((x61 & (0x1 as u64)) as fiat_p224_u1) as u64),\n    );\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x64, &mut x65, x63, x55, (x61 & 0xffffffff00000000));\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x66, &mut x67, x65, x57, x61);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x68, &mut x69, x67, x59, (x61 & 0xffffffff));\n    let mut x70: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x70, x3, (arg5[0]), x62);\n    let mut x71: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x71, x3, (arg5[1]), x64);\n    let mut x72: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x72, x3, (arg5[2]), x66);\n    let mut x73: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x73, x3, (arg5[3]), x68);\n    let x74: fiat_p224_u1 = ((x22 & (0x1 as u64)) as fiat_p224_u1);\n    let mut x75: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x75, x74, (0x0 as u64), x7);\n    let mut x76: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x76, x74, (0x0 as u64), x8);\n    let mut x77: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x77, x74, (0x0 as u64), x9);\n    let mut x78: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x78, x74, (0x0 as u64), x10);\n    let mut x79: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x79, x74, (0x0 as u64), x11);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x80, &mut x81, 0x0, x22, x75);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x82, &mut x83, x81, x23, x76);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x84, &mut x85, x83, x24, x77);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x86, &mut x87, x85, x25, x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x88, &mut x89, x87, x26, x79);\n    let mut x90: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x90, x74, (0x0 as u64), x27);\n    let mut x91: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x91, x74, (0x0 as u64), x28);\n    let mut x92: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x92, x74, (0x0 as u64), x29);\n    let mut x93: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x93, x74, (0x0 as u64), x30);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x94, &mut x95, 0x0, x70, x90);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x96, &mut x97, x95, x71, x91);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x98, &mut x99, x97, x72, x92);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x100, &mut x101, x99, x73, x93);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x102, &mut x103, 0x0, x94, (0x1 as u64));\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x104, &mut x105, x103, x96, 0xffffffff00000000);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x106, &mut x107, x105, x98, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x108, &mut x109, x107, x100, 0xffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x110, &mut x111, x109, (x101 as u64), (0x0 as u64));\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x112, &mut x113, 0x0, x6, (0x1 as u64));\n    let x114: u64 = ((x80 >> 1) | ((x82 << 63) & 0xffffffffffffffff));\n    let x115: u64 = ((x82 >> 1) | ((x84 << 63) & 0xffffffffffffffff));\n    let x116: u64 = ((x84 >> 1) | ((x86 << 63) & 0xffffffffffffffff));\n    let x117: u64 = ((x86 >> 1) | ((x88 << 63) & 0xffffffffffffffff));\n    let x118: u64 = ((x88 & 0x8000000000000000) | (x88 >> 1));\n    let mut x119: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x119, x48, x39, x31);\n    let mut x120: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x120, x48, x41, x33);\n    let mut x121: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x121, x48, x43, x35);\n    let mut x122: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x122, x48, x45, x37);\n    let mut x123: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x123, x111, x102, x94);\n    let mut x124: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x124, x111, x104, x96);\n    let mut x125: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x125, x111, x106, x98);\n    let mut x126: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x126, x111, x108, x100);\n    *out1 = x112;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out3[0] = x114;\n    out3[1] = x115;\n    out3[2] = x116;\n    out3[3] = x117;\n    out3[4] = x118;\n    out4[0] = x119;\n    out4[1] = x120;\n    out4[2] = x121;\n    out4[3] = x122;\n    out5[0] = x123;\n    out5[1] = x124;\n    out5[2] = x125;\n    out5[3] = x126;\n}",
    "display_name": "fiat_p224_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: FieldElement) {\n        *self = *self + other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_y",
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_sub<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"sub\", |b| b.iter(|| black_box(x) - black_box(y)));\n}",
    "display_name": "bench_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/eq_affine"
    ],
    "body": "    fn eq(&self, other: &AffinePoint) -> bool {\n        self.eq_affine(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_basic_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_basic_mul() {\n        let ten = Scalar::from(10u8);\n        let five = Scalar::from(5u8);\n\n        assert_eq!(ten * five, Scalar::from(50u8))\n    }",
    "display_name": "test_basic_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: &DecafPointBytes) -> Result<Self, Self::Error> {\n        Self::try_from(*bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/distid",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn distid(&self) -> &DistId {\n        self.distid.as_str()\n    }",
    "display_name": "distid",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: Scalar) {\n        *self = *self * scalar;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/random",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self {\n            inner: NonZeroScalar::random(rng).into(),\n        }\n    }",
    "display_name": "random",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 invert_and_invert_vartime_are_equivalent",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert_vartime",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert_and_invert_vartime_are_equivalent(w in scalar()) {\n        let inv: Option<Scalar> = w.invert().into();\n        let inv_vartime: Option<Scalar> = w.invert_vartime().into();\n        prop_assert_eq!(inv, inv_vartime);\n    }",
    "display_name": "invert_and_invert_vartime_are_equivalent",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/scalar.rs",
    "relative_path": "p256/tests/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/multiply"
    ],
    "body": "    fn mul(self, rhs: LooseFieldElement) -> FieldElement {\n        Self::multiply(&self, &rhs)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "affine/impl/AffinePoint/ToCompactEncodedPoint/to_compact_encoded_point",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/to_compact"
    ],
    "body": "    fn to_compact_encoded_point(&self) -> CtOption<EncodedPoint<C>> {\n        let point = self.to_compact();\n\n        let mut bytes = CompressedPoint::<C>::default();\n        bytes[0] = sec1::Tag::Compact.into();\n        bytes[1..].copy_from_slice(&point.x.to_repr());\n\n        let encoded = EncodedPoint::<C>::from_bytes(bytes);\n        let is_some = point.y.ct_eq(&self.y);\n        CtOption::new(encoded.unwrap_or_default(), is_some)\n    }",
    "display_name": "to_compact_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/new_with_mode",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn new_with_mode(public_key: PublicKey, mode: Mode) -> Self {\n        Self { public_key, mode }\n    }",
    "display_name": "new_with_mode",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/as_limbs"
    ],
    "body": "    fn eq(&self, rhs: &Self) -> bool {\n        self.as_limbs().ct_eq(rhs.as_limbs()).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/invert_unchecked",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_hex",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_canonical"
    ],
    "body": "    fn is_high(&self) -> Choice {\n        const MODULUS_SHR1: U192 = NistP192::ORDER.shr_vartime(1);\n        self.to_canonical().ct_gt(&MODULUS_SHR1)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p192_from_montgomery(\n    out1: &mut fiat_p192_non_montgomery_domain_field_element,\n    arg1: &fiat_p192_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_p192_mulx_u64(&mut x2, &mut x3, x1, 0xffffffffffffffff);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p192_mulx_u64(&mut x4, &mut x5, x1, 0xfffffffffffffffe);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p192_mulx_u64(&mut x6, &mut x7, x1, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x8, &mut x9, 0x0, x7, x4);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x10, &mut x11, x9, x5, x2);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x12, &mut x13, 0x0, x1, x6);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x14, &mut x15, x13, (0x0 as u64), x8);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), x10);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), ((x11 as u64) + x3));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x20, &mut x21, 0x0, x14, (arg1[1]));\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x22, &mut x23, x21, x16, (0x0 as u64));\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x24, &mut x25, x23, x18, (0x0 as u64));\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p192_mulx_u64(&mut x26, &mut x27, x20, 0xffffffffffffffff);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_p192_mulx_u64(&mut x28, &mut x29, x20, 0xfffffffffffffffe);\n    let mut x30: u64 = 0;\n    let mut x31: u64 = 0;\n    fiat_p192_mulx_u64(&mut x30, &mut x31, x20, 0xffffffffffffffff);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x32, &mut x33, 0x0, x31, x28);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x34, &mut x35, x33, x29, x26);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x36, &mut x37, 0x0, x20, x30);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x38, &mut x39, x37, x22, x32);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x40, &mut x41, x39, x24, x34);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(\n        &mut x42,\n        &mut x43,\n        x41,\n        ((x25 as u64) + (x19 as u64)),\n        ((x35 as u64) + x27),\n    );\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x44, &mut x45, 0x0, x38, (arg1[2]));\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x46, &mut x47, x45, x40, (0x0 as u64));\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x48, &mut x49, x47, x42, (0x0 as u64));\n    let mut x50: u64 = 0;\n    let mut x51: u64 = 0;\n    fiat_p192_mulx_u64(&mut x50, &mut x51, x44, 0xffffffffffffffff);\n    let mut x52: u64 = 0;\n    let mut x53: u64 = 0;\n    fiat_p192_mulx_u64(&mut x52, &mut x53, x44, 0xfffffffffffffffe);\n    let mut x54: u64 = 0;\n    let mut x55: u64 = 0;\n    fiat_p192_mulx_u64(&mut x54, &mut x55, x44, 0xffffffffffffffff);\n    let mut x56: u64 = 0;\n    let mut x57: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x56, &mut x57, 0x0, x55, x52);\n    let mut x58: u64 = 0;\n    let mut x59: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x58, &mut x59, x57, x53, x50);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x60, &mut x61, 0x0, x44, x54);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x62, &mut x63, x61, x46, x56);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x64, &mut x65, x63, x48, x58);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(\n        &mut x66,\n        &mut x67,\n        x65,\n        ((x49 as u64) + (x43 as u64)),\n        ((x59 as u64) + x51),\n    );\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x68, &mut x69, 0x0, x62, 0xffffffffffffffff);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x70, &mut x71, x69, x64, 0xfffffffffffffffe);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x72, &mut x73, x71, x66, 0xffffffffffffffff);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x74, &mut x75, x73, (x67 as u64), (0x0 as u64));\n    let mut x76: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x76, x75, x68, x62);\n    let mut x77: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x77, x75, x70, x64);\n    let mut x78: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x78, x75, x72, x66);\n    out1[0] = x76;\n    out1[1] = x77;\n    out1[2] = x78;\n}",
    "display_name": "fiat_p192_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub(self, other: &ProjectivePoint) -> ProjectivePoint {\n        ProjectivePoint::sub(&self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/next_k",
    "statement_type": "function",
    "deps": [],
    "body": "fn next_k<R: TryCryptoRng + ?Sized>(rng: &mut R, bit_length: u32) -> Result<U256> {\n    loop {\n        let k = U256::try_random_bits(rng, bit_length).map_err(|_| Error)?;\n        if !bool::from(k.is_zero()) && k < Sm2::ORDER {\n            return Ok(k);\n        }\n    }\n}",
    "display_name": "next_k",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/generate_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/try_from_rng"
    ],
    "body": "    pub fn generate_vartime<R: TryCryptoRng + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        Self::try_from_rng(rng)\n    }",
    "display_name": "generate_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/pow_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/wycheproof/run",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 ecdsa/tests/wycheproof/run_test"
    ],
    "body": "            fn run(data: &[u8], p1363_sig: bool) {\n                for (i, row) in Blob5Iterator::new(data).unwrap().enumerate() {\n                    let [wx, wy, msg, sig, status] = row.unwrap();\n                    let pass = match status[0] {\n                        0 => false,\n                        1 => true,\n                        _ => panic!(\"invalid value for pass flag\"),\n                    };\n                    if let Some(desc) = run_test(wx, wy, msg, sig, pass, p1363_sig) {\n                        panic!(\n                            \"\\n\\\n                                     Failed test №{}: {}\\n\\\n                                     wx:\\t{:?}\\n\\\n                                     wy:\\t{:?}\\n\\\n                                     msg:\\t{:?}\\n\\\n                                     sig:\\t{:?}\\n\\\n                                     pass:\\t{}\\n\",\n                            i,\n                            desc,\n                            hex::encode(wx),\n                            hex::encode(wy),\n                            hex::encode(msg),\n                            hex::encode(sig),\n                            pass,\n                        );\n                    }\n                }\n            }",
    "display_name": "run",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/ecdsa.rs",
    "relative_path": "k256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/is_identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn is_identity(&self) -> Choice {\n        Choice::from(self.infinity)\n    }",
    "display_name": "is_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre encode_pkcs8_public_key_to_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/EncodePublicKey/to_public_key_der"
    ],
    "body": "fn encode_pkcs8_public_key_to_der() {\n    let original_public_key = PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    let reencoded_public_key = original_public_key.to_public_key_der().unwrap();\n    assert_eq!(reencoded_public_key.as_ref(), &PKCS8_PUBLIC_KEY_DER[..]);\n}",
    "display_name": "encode_pkcs8_public_key_to_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/pkcs8.rs",
    "relative_path": "bign256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: &Scalar) {\n        *self = *self + other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Product/product",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul"
    ],
    "body": "    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Mul::mul).unwrap_or(Self::ONE)\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/From>/from"
    ],
    "body": "    fn from(public_key: &PublicKey<C>) -> AffinePoint<C> {\n        AffinePoint::from(*public_key)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_normalized",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/from_bytes"
    ],
    "body": "    pub fn from_bytes(bytes: &FieldBytes) -> CtOption<Self> {\n        let value = FieldElementUnsafeImpl::from_bytes(bytes);\n        CtOption::map(value, |x| Self::new_normalized(&x))\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: Scalar) {\n        *self = *self + other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_mulx_u64"
    ],
    "body": "pub const fn fiat_p224_to_montgomery(\n    out1: &mut fiat_p224_montgomery_domain_field_element,\n    arg1: &fiat_p224_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_p224_mulx_u64(&mut x5, &mut x6, x4, 0xffffffff);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p224_mulx_u64(&mut x7, &mut x8, x4, 0xfffffffe00000000);\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p224_mulx_u64(&mut x9, &mut x10, x4, 0xffffffff00000000);\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p224_mulx_u64(&mut x11, &mut x12, x4, 0xffffffff00000001);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_p224_mulx_u64(&mut x19, &mut x20, x11, 0xffffffffffffffff);\n    let mut x21: u64 = 0;\n    let mut x22: u64 = 0;\n    fiat_p224_mulx_u64(&mut x21, &mut x22, x19, 0xffffffff);\n    let mut x23: u64 = 0;\n    let mut x24: u64 = 0;\n    fiat_p224_mulx_u64(&mut x23, &mut x24, x19, 0xffffffffffffffff);\n    let mut x25: u64 = 0;\n    let mut x26: u64 = 0;\n    fiat_p224_mulx_u64(&mut x25, &mut x26, x19, 0xffffffff00000000);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x27, &mut x28, 0x0, x26, x23);\n    let mut x29: u64 = 0;\n    let mut x30: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x29, &mut x30, x28, x24, x21);\n    let mut x31: u64 = 0;\n    let mut x32: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x31, &mut x32, 0x0, x11, x19);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x33, &mut x34, x32, x13, x25);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x35, &mut x36, x34, x15, x27);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x37, &mut x38, x36, x17, x29);\n    let mut x39: u64 = 0;\n    let mut x40: u64 = 0;\n    fiat_p224_mulx_u64(&mut x39, &mut x40, x1, 0xffffffff);\n    let mut x41: u64 = 0;\n    let mut x42: u64 = 0;\n    fiat_p224_mulx_u64(&mut x41, &mut x42, x1, 0xfffffffe00000000);\n    let mut x43: u64 = 0;\n    let mut x44: u64 = 0;\n    fiat_p224_mulx_u64(&mut x43, &mut x44, x1, 0xffffffff00000000);\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_p224_mulx_u64(&mut x45, &mut x46, x1, 0xffffffff00000001);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x47, &mut x48, 0x0, x46, x43);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x49, &mut x50, x48, x44, x41);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x51, &mut x52, x50, x42, x39);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x53, &mut x54, 0x0, x33, x45);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x55, &mut x56, x54, x35, x47);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x57, &mut x58, x56, x37, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x59,\n        &mut x60,\n        x58,\n        (((x38 as u64) + ((x18 as u64) + x6)) + ((x30 as u64) + x22)),\n        x51,\n    );\n    let mut x61: u64 = 0;\n    let mut x62: u64 = 0;\n    fiat_p224_mulx_u64(&mut x61, &mut x62, x53, 0xffffffffffffffff);\n    let mut x63: u64 = 0;\n    let mut x64: u64 = 0;\n    fiat_p224_mulx_u64(&mut x63, &mut x64, x61, 0xffffffff);\n    let mut x65: u64 = 0;\n    let mut x66: u64 = 0;\n    fiat_p224_mulx_u64(&mut x65, &mut x66, x61, 0xffffffffffffffff);\n    let mut x67: u64 = 0;\n    let mut x68: u64 = 0;\n    fiat_p224_mulx_u64(&mut x67, &mut x68, x61, 0xffffffff00000000);\n    let mut x69: u64 = 0;\n    let mut x70: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x69, &mut x70, 0x0, x68, x65);\n    let mut x71: u64 = 0;\n    let mut x72: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x71, &mut x72, x70, x66, x63);\n    let mut x73: u64 = 0;\n    let mut x74: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x73, &mut x74, 0x0, x53, x61);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x75, &mut x76, x74, x55, x67);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x77, &mut x78, x76, x57, x69);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x79, &mut x80, x78, x59, x71);\n    let mut x81: u64 = 0;\n    let mut x82: u64 = 0;\n    fiat_p224_mulx_u64(&mut x81, &mut x82, x2, 0xffffffff);\n    let mut x83: u64 = 0;\n    let mut x84: u64 = 0;\n    fiat_p224_mulx_u64(&mut x83, &mut x84, x2, 0xfffffffe00000000);\n    let mut x85: u64 = 0;\n    let mut x86: u64 = 0;\n    fiat_p224_mulx_u64(&mut x85, &mut x86, x2, 0xffffffff00000000);\n    let mut x87: u64 = 0;\n    let mut x88: u64 = 0;\n    fiat_p224_mulx_u64(&mut x87, &mut x88, x2, 0xffffffff00000001);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x89, &mut x90, 0x0, x88, x85);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x91, &mut x92, x90, x86, x83);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x93, &mut x94, x92, x84, x81);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x95, &mut x96, 0x0, x75, x87);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x97, &mut x98, x96, x77, x89);\n    let mut x99: u64 = 0;\n    let mut x100: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x99, &mut x100, x98, x79, x91);\n    let mut x101: u64 = 0;\n    let mut x102: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x101,\n        &mut x102,\n        x100,\n        (((x80 as u64) + ((x60 as u64) + ((x52 as u64) + x40))) + ((x72 as u64) + x64)),\n        x93,\n    );\n    let mut x103: u64 = 0;\n    let mut x104: u64 = 0;\n    fiat_p224_mulx_u64(&mut x103, &mut x104, x95, 0xffffffffffffffff);\n    let mut x105: u64 = 0;\n    let mut x106: u64 = 0;\n    fiat_p224_mulx_u64(&mut x105, &mut x106, x103, 0xffffffff);\n    let mut x107: u64 = 0;\n    let mut x108: u64 = 0;\n    fiat_p224_mulx_u64(&mut x107, &mut x108, x103, 0xffffffffffffffff);\n    let mut x109: u64 = 0;\n    let mut x110: u64 = 0;\n    fiat_p224_mulx_u64(&mut x109, &mut x110, x103, 0xffffffff00000000);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x111, &mut x112, 0x0, x110, x107);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x113, &mut x114, x112, x108, x105);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x115, &mut x116, 0x0, x95, x103);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x117, &mut x118, x116, x97, x109);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x119, &mut x120, x118, x99, x111);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x121, &mut x122, x120, x101, x113);\n    let mut x123: u64 = 0;\n    let mut x124: u64 = 0;\n    fiat_p224_mulx_u64(&mut x123, &mut x124, x3, 0xffffffff);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_p224_mulx_u64(&mut x125, &mut x126, x3, 0xfffffffe00000000);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_p224_mulx_u64(&mut x127, &mut x128, x3, 0xffffffff00000000);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_p224_mulx_u64(&mut x129, &mut x130, x3, 0xffffffff00000001);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x131, &mut x132, 0x0, x130, x127);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x133, &mut x134, x132, x128, x125);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x135, &mut x136, x134, x126, x123);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x137, &mut x138, 0x0, x117, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x139, &mut x140, x138, x119, x131);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x141, &mut x142, x140, x121, x133);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x143,\n        &mut x144,\n        x142,\n        (((x122 as u64) + ((x102 as u64) + ((x94 as u64) + x82))) + ((x114 as u64) + x106)),\n        x135,\n    );\n    let mut x145: u64 = 0;\n    let mut x146: u64 = 0;\n    fiat_p224_mulx_u64(&mut x145, &mut x146, x137, 0xffffffffffffffff);\n    let mut x147: u64 = 0;\n    let mut x148: u64 = 0;\n    fiat_p224_mulx_u64(&mut x147, &mut x148, x145, 0xffffffff);\n    let mut x149: u64 = 0;\n    let mut x150: u64 = 0;\n    fiat_p224_mulx_u64(&mut x149, &mut x150, x145, 0xffffffffffffffff);\n    let mut x151: u64 = 0;\n    let mut x152: u64 = 0;\n    fiat_p224_mulx_u64(&mut x151, &mut x152, x145, 0xffffffff00000000);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x153, &mut x154, 0x0, x152, x149);\n    let mut x155: u64 = 0;\n    let mut x156: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x155, &mut x156, x154, x150, x147);\n    let mut x157: u64 = 0;\n    let mut x158: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x157, &mut x158, 0x0, x137, x145);\n    let mut x159: u64 = 0;\n    let mut x160: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x159, &mut x160, x158, x139, x151);\n    let mut x161: u64 = 0;\n    let mut x162: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x161, &mut x162, x160, x141, x153);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x163, &mut x164, x162, x143, x155);\n    let x165: u64 =\n        (((x164 as u64) + ((x144 as u64) + ((x136 as u64) + x124))) + ((x156 as u64) + x148));\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x166, &mut x167, 0x0, x159, (0x1 as u64));\n    let mut x168: u64 = 0;\n    let mut x169: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x168, &mut x169, x167, x161, 0xffffffff00000000);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x170, &mut x171, x169, x163, 0xffffffffffffffff);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x172, &mut x173, x171, x165, 0xffffffff);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x174, &mut x175, x173, (0x0 as u64), (0x0 as u64));\n    let mut x176: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x176, x175, x166, x159);\n    let mut x177: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x177, x175, x168, x161);\n    let mut x178: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x178, x175, x170, x163);\n    let mut x179: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x179, x175, x172, x165);\n    out1[0] = x176;\n    out1[1] = x177;\n    out1[2] = x178;\n    out1[3] = x179;\n}",
    "display_name": "fiat_p224_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_from_bytes(out1: &mut [u64; 4], arg1: &[u8; 32]) {\n    let x1: u64 = (((arg1[31]) as u64) << 56);\n    let x2: u64 = (((arg1[30]) as u64) << 48);\n    let x3: u64 = (((arg1[29]) as u64) << 40);\n    let x4: u64 = (((arg1[28]) as u64) << 32);\n    let x5: u64 = (((arg1[27]) as u64) << 24);\n    let x6: u64 = (((arg1[26]) as u64) << 16);\n    let x7: u64 = (((arg1[25]) as u64) << 8);\n    let x8: u8 = (arg1[24]);\n    let x9: u64 = (((arg1[23]) as u64) << 56);\n    let x10: u64 = (((arg1[22]) as u64) << 48);\n    let x11: u64 = (((arg1[21]) as u64) << 40);\n    let x12: u64 = (((arg1[20]) as u64) << 32);\n    let x13: u64 = (((arg1[19]) as u64) << 24);\n    let x14: u64 = (((arg1[18]) as u64) << 16);\n    let x15: u64 = (((arg1[17]) as u64) << 8);\n    let x16: u8 = (arg1[16]);\n    let x17: u64 = (((arg1[15]) as u64) << 56);\n    let x18: u64 = (((arg1[14]) as u64) << 48);\n    let x19: u64 = (((arg1[13]) as u64) << 40);\n    let x20: u64 = (((arg1[12]) as u64) << 32);\n    let x21: u64 = (((arg1[11]) as u64) << 24);\n    let x22: u64 = (((arg1[10]) as u64) << 16);\n    let x23: u64 = (((arg1[9]) as u64) << 8);\n    let x24: u8 = (arg1[8]);\n    let x25: u64 = (((arg1[7]) as u64) << 56);\n    let x26: u64 = (((arg1[6]) as u64) << 48);\n    let x27: u64 = (((arg1[5]) as u64) << 40);\n    let x28: u64 = (((arg1[4]) as u64) << 32);\n    let x29: u64 = (((arg1[3]) as u64) << 24);\n    let x30: u64 = (((arg1[2]) as u64) << 16);\n    let x31: u64 = (((arg1[1]) as u64) << 8);\n    let x32: u8 = (arg1[0]);\n    let x33: u64 = (x31 + (x32 as u64));\n    let x34: u64 = (x30 + x33);\n    let x35: u64 = (x29 + x34);\n    let x36: u64 = (x28 + x35);\n    let x37: u64 = (x27 + x36);\n    let x38: u64 = (x26 + x37);\n    let x39: u64 = (x25 + x38);\n    let x40: u64 = (x23 + (x24 as u64));\n    let x41: u64 = (x22 + x40);\n    let x42: u64 = (x21 + x41);\n    let x43: u64 = (x20 + x42);\n    let x44: u64 = (x19 + x43);\n    let x45: u64 = (x18 + x44);\n    let x46: u64 = (x17 + x45);\n    let x47: u64 = (x15 + (x16 as u64));\n    let x48: u64 = (x14 + x47);\n    let x49: u64 = (x13 + x48);\n    let x50: u64 = (x12 + x49);\n    let x51: u64 = (x11 + x50);\n    let x52: u64 = (x10 + x51);\n    let x53: u64 = (x9 + x52);\n    let x54: u64 = (x7 + (x8 as u64));\n    let x55: u64 = (x6 + x54);\n    let x56: u64 = (x5 + x55);\n    let x57: u64 = (x4 + x56);\n    let x58: u64 = (x3 + x57);\n    let x59: u64 = (x2 + x58);\n    let x60: u64 = (x1 + x59);\n    out1[0] = x39;\n    out1[1] = x46;\n    out1[2] = x53;\n    out1[3] = x60;\n}",
    "display_name": "fiat_bign256_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/from_slice",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/from_nonzero_scalar"
    ],
    "body": "    pub fn from_slice(slice: &[u8]) -> Result<Self> {\n        let secret_scalar = NonZeroScalar::try_from(slice).map_err(|_| Error)?;\n        Self::from_nonzero_scalar(secret_scalar)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "    pub const fn square(&self) -> Self {\n        // Schoolbook multiplication.\n        self.multiply(self)\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/one_is_multiplicative_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul"
    ],
    "body": "    fn one_is_multiplicative_identity() {\n        let one = FieldElement::ONE;\n        assert_eq!(one.mul(&one), one);\n    }",
    "display_name": "one_is_multiplicative_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/addition"
    ],
    "body": "    pub const fn double(&self) -> Self {\n        self.addition(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_sm2_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: &DecafPointBytes) -> Result<Self, Self::Error> {\n        Self::try_from(*bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "affine/impl/AffinePoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_field_element_invert",
      "0.14.0_pre.8 bench_field_element_mul",
      "0.14.0_pre.8 bench_field_element_sqrt",
      "0.14.0_pre.8 bench_field_element_square"
    ],
    "body": "fn bench_field_element(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"field element operations\");\n    bench_field_element_mul(&mut group);\n    bench_field_element_square(&mut group);\n    bench_field_element_invert(&mut group);\n    bench_field_element_sqrt(&mut group);\n    group.finish();\n}",
    "display_name": "bench_field_element",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/field.rs",
    "relative_path": "p256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/mul"
    ],
    "body": "    fn mul_assign(&mut self, rhs: Scalar) {\n        *self = Scalar::mul(self, &rhs);\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint"
    ],
    "body": "        fn reduce<T: Reduce<U512, Bytes = WideBytes>>(slice: &[u8]) -> T {\n            let mut bytes = WideBytes::default();\n            bytes[(64 - slice.len())..].copy_from_slice(slice);\n            T::reduce_bytes(&bytes)\n        }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/square",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/pow_vartime"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        let w = &[\n            0xc27ba528ab8b8547,\n            0xffffe2d45c171e07,\n            0xffffffffffffffff,\n            0x1fffffff,\n        ];\n        let t = Self::from_u64(2).pow_vartime(w);\n        let a1 = self.pow_vartime(w);\n        let a0 = (a1.square() * self).square();\n        let b = t * a1;\n        let ab = self * &b;\n        let i = Self::from_u64(2) * ab * b;\n        let x = ab * (i - Self::ONE);\n        CtOption::new(x, !a0.ct_eq(&-Self::ONE))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/&ProjectivePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub(self, other: &AffinePoint) -> ProjectivePoint {\n        ProjectivePoint::sub_mixed(self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Field/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/square"
    ],
    "body": "    fn square(&self) -> Self {\n        self.square()\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_square(\n    out1: &mut fiat_p192_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p192_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[0]);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x4, &mut x5, x3, (arg1[2]));\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x6, &mut x7, x3, (arg1[1]));\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x8, &mut x9, x3, (arg1[0]));\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x9, x6);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x7, x4);\n    let x14: u64 = ((x13 as u64) + x5);\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x15, &mut x16, x8, 0x882672070ddbcf2f);\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x17, &mut x18, x15, 0xffffffffffffffff);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x19, &mut x20, x15, 0xffffffff99def836);\n    let mut x21: u64 = 0;\n    let mut x22: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x21, &mut x22, x15, 0x146bc9b1b4d22831);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x23, &mut x24, 0x0, x22, x19);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x25, &mut x26, x24, x20, x17);\n    let x27: u64 = ((x26 as u64) + x18);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x28, &mut x29, 0x0, x8, x21);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x10, x23);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x12, x25);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x14, x27);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x36, &mut x37, x1, (arg1[2]));\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x38, &mut x39, x1, (arg1[1]));\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x40, &mut x41, x1, (arg1[0]));\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x42, &mut x43, 0x0, x41, x38);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x44, &mut x45, x43, x39, x36);\n    let x46: u64 = ((x45 as u64) + x37);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x47, &mut x48, 0x0, x30, x40);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x49, &mut x50, x48, x32, x42);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x51, &mut x52, x50, x34, x44);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x53, &mut x54, x52, (x35 as u64), x46);\n    let mut x55: u64 = 0;\n    let mut x56: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x55, &mut x56, x47, 0x882672070ddbcf2f);\n    let mut x57: u64 = 0;\n    let mut x58: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x57, &mut x58, x55, 0xffffffffffffffff);\n    let mut x59: u64 = 0;\n    let mut x60: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x59, &mut x60, x55, 0xffffffff99def836);\n    let mut x61: u64 = 0;\n    let mut x62: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x61, &mut x62, x55, 0x146bc9b1b4d22831);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x63, &mut x64, 0x0, x62, x59);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x65, &mut x66, x64, x60, x57);\n    let x67: u64 = ((x66 as u64) + x58);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x68, &mut x69, 0x0, x47, x61);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x70, &mut x71, x69, x49, x63);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x72, &mut x73, x71, x51, x65);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x74, &mut x75, x73, x53, x67);\n    let x76: u64 = ((x75 as u64) + (x54 as u64));\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x77, &mut x78, x2, (arg1[2]));\n    let mut x79: u64 = 0;\n    let mut x80: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x79, &mut x80, x2, (arg1[1]));\n    let mut x81: u64 = 0;\n    let mut x82: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x81, &mut x82, x2, (arg1[0]));\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x83, &mut x84, 0x0, x82, x79);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x85, &mut x86, x84, x80, x77);\n    let x87: u64 = ((x86 as u64) + x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x88, &mut x89, 0x0, x70, x81);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x72, x83);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x92, &mut x93, x91, x74, x85);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x76, x87);\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x96, &mut x97, x88, 0x882672070ddbcf2f);\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x98, &mut x99, x96, 0xffffffffffffffff);\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x100, &mut x101, x96, 0xffffffff99def836);\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x102, &mut x103, x96, 0x146bc9b1b4d22831);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x104, &mut x105, 0x0, x103, x100);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x106, &mut x107, x105, x101, x98);\n    let x108: u64 = ((x107 as u64) + x99);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x109, &mut x110, 0x0, x88, x102);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x111, &mut x112, x110, x90, x104);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x113, &mut x114, x112, x92, x106);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x115, &mut x116, x114, x94, x108);\n    let x117: u64 = ((x116 as u64) + (x95 as u64));\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x118, &mut x119, 0x0, x111, 0x146bc9b1b4d22831);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x120, &mut x121, x119, x113, 0xffffffff99def836);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x122, &mut x123, x121, x115, 0xffffffffffffffff);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x124, &mut x125, x123, x117, (0x0 as u64));\n    let mut x126: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x126, x125, x118, x111);\n    let mut x127: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x127, x125, x120, x113);\n    let mut x128: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x128, x125, x122, x115);\n    out1[0] = x126;\n    out1[1] = x127;\n    out1[2] = x128;\n}",
    "display_name": "fiat_p192_scalar_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/tests/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/sqrt",
      "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes"
    ],
    "body": "    fn sqrt() {\n        let nine = FieldElement::from_bytes(&[\n            0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        ]);\n        let three = FieldElement::from_bytes(&[\n            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        ]);\n        assert_eq!(three, nine.sqrt());\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/mul_inner"
    ],
    "body": "    pub fn mul(&self, rhs: &Self) -> Self {\n        self.mul_inner(rhs)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/elliptic_curve::array::Array::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn from(scalar: &Scalar) -> Self {\n        scalar.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(a: u16) -> Self {\n        Scalar(U448::from_u16(a))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre test_signature_tampering",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre create_test_signing_key",
      "0.14.0_pre dsa/impl/Signature/to_bytes",
      "0.14.0_pre dsa/signing/impl/SigningKey/verifying_key",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/Verifier/verify",
      "0.14.0_pre dsa/impl/Signature/from_bytes"
    ],
    "body": "fn test_signature_tampering() {\n    let sk = create_test_signing_key();\n    let msg = b\"test message\";\n    let sig = sk.sign(msg);\n    let mut tampered_sig = sig.to_bytes();\n\n    // Modify each byte of signature\n    for i in 0..64 {\n        tampered_sig[i] ^= 1;\n        let invalid_sig = Signature::from_bytes(&tampered_sig).unwrap();\n        assert!(sk.verifying_key().verify(msg, &invalid_sig).is_err());\n        tampered_sig[i] ^= 1; // Restore\n    }\n}",
    "display_name": "test_signature_tampering",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/dsa_extended.rs",
    "relative_path": "sm2/tests/dsa_extended.rs",
    "file_name": "dsa_extended.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 test_scalar_y"
    ],
    "body": "fn bench_scalar_mul<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"mul\", |b| b.iter(|| x * y));\n}",
    "display_name": "bench_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/Signer/try_sign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/signing/impl/SigningKey/MultipartSigner/try_multipart_sign"
    ],
    "body": "    fn try_sign(&self, msg: &[u8]) -> Result<Signature> {\n        self.try_multipart_sign(&[msg])\n    }",
    "display_name": "try_sign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/EphemeralSecret/random",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self {\n            scalar: NonZeroScalar::random(rng),\n        }\n    }",
    "display_name": "random",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/&ProjectivePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add(self, other: &ProjectivePoint) -> ProjectivePoint {\n        ProjectivePoint::add(self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, scalar: &Scalar) -> DecafPoint {\n        &self * scalar\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre decode_pkcs8_private_key_from_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_private_key_from_pem() {\n    let secret_key = PKCS8_PRIVATE_KEY_PEM.parse::<sm2::SecretKey>().unwrap();\n\n    // Ensure key parses equivalently to DER\n    let der_key = sm2::SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    assert_eq!(secret_key.to_bytes(), der_key.to_bytes());\n}",
    "display_name": "decode_pkcs8_private_key_from_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 test_field_element_y",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_field_element_y() -> FieldElement {\n    FieldElement::from_bytes(\n        &[\n            0x67, 0xe2, 0xf6, 0x80, 0x71, 0xed, 0x82, 0x81, 0xe8, 0xae, 0xd6, 0xbc, 0xf1, 0xc5,\n            0x20, 0x7c, 0x5e, 0x63, 0x37, 0x22, 0xd9, 0x20, 0xaf, 0xd6, 0xae, 0x22, 0xd0, 0x6e,\n            0xeb, 0x80, 0x35, 0xe3,\n        ]\n        .into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_field_element_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(k: u128) -> Self {\n        Self(k.into())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: DecafPoint) {\n        *self = *self + other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_to_bytes(out1: &mut [u8; 32], arg1: &[u64; 4]) {\n    let x1: u64 = (arg1[3]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[1]);\n    let x4: u64 = (arg1[0]);\n    let x5: u8 = ((x4 & (0xff as u64)) as u8);\n    let x6: u64 = (x4 >> 8);\n    let x7: u8 = ((x6 & (0xff as u64)) as u8);\n    let x8: u64 = (x6 >> 8);\n    let x9: u8 = ((x8 & (0xff as u64)) as u8);\n    let x10: u64 = (x8 >> 8);\n    let x11: u8 = ((x10 & (0xff as u64)) as u8);\n    let x12: u64 = (x10 >> 8);\n    let x13: u8 = ((x12 & (0xff as u64)) as u8);\n    let x14: u64 = (x12 >> 8);\n    let x15: u8 = ((x14 & (0xff as u64)) as u8);\n    let x16: u64 = (x14 >> 8);\n    let x17: u8 = ((x16 & (0xff as u64)) as u8);\n    let x18: u8 = ((x16 >> 8) as u8);\n    let x19: u8 = ((x3 & (0xff as u64)) as u8);\n    let x20: u64 = (x3 >> 8);\n    let x21: u8 = ((x20 & (0xff as u64)) as u8);\n    let x22: u64 = (x20 >> 8);\n    let x23: u8 = ((x22 & (0xff as u64)) as u8);\n    let x24: u64 = (x22 >> 8);\n    let x25: u8 = ((x24 & (0xff as u64)) as u8);\n    let x26: u64 = (x24 >> 8);\n    let x27: u8 = ((x26 & (0xff as u64)) as u8);\n    let x28: u64 = (x26 >> 8);\n    let x29: u8 = ((x28 & (0xff as u64)) as u8);\n    let x30: u64 = (x28 >> 8);\n    let x31: u8 = ((x30 & (0xff as u64)) as u8);\n    let x32: u8 = ((x30 >> 8) as u8);\n    let x33: u8 = ((x2 & (0xff as u64)) as u8);\n    let x34: u64 = (x2 >> 8);\n    let x35: u8 = ((x34 & (0xff as u64)) as u8);\n    let x36: u64 = (x34 >> 8);\n    let x37: u8 = ((x36 & (0xff as u64)) as u8);\n    let x38: u64 = (x36 >> 8);\n    let x39: u8 = ((x38 & (0xff as u64)) as u8);\n    let x40: u64 = (x38 >> 8);\n    let x41: u8 = ((x40 & (0xff as u64)) as u8);\n    let x42: u64 = (x40 >> 8);\n    let x43: u8 = ((x42 & (0xff as u64)) as u8);\n    let x44: u64 = (x42 >> 8);\n    let x45: u8 = ((x44 & (0xff as u64)) as u8);\n    let x46: u8 = ((x44 >> 8) as u8);\n    let x47: u8 = ((x1 & (0xff as u64)) as u8);\n    let x48: u64 = (x1 >> 8);\n    let x49: u8 = ((x48 & (0xff as u64)) as u8);\n    let x50: u64 = (x48 >> 8);\n    let x51: u8 = ((x50 & (0xff as u64)) as u8);\n    let x52: u64 = (x50 >> 8);\n    let x53: u8 = ((x52 & (0xff as u64)) as u8);\n    let x54: u64 = (x52 >> 8);\n    let x55: u8 = ((x54 & (0xff as u64)) as u8);\n    let x56: u64 = (x54 >> 8);\n    let x57: u8 = ((x56 & (0xff as u64)) as u8);\n    let x58: u64 = (x56 >> 8);\n    let x59: u8 = ((x58 & (0xff as u64)) as u8);\n    let x60: u8 = ((x58 >> 8) as u8);\n    out1[0] = x5;\n    out1[1] = x7;\n    out1[2] = x9;\n    out1[3] = x11;\n    out1[4] = x13;\n    out1[5] = x15;\n    out1[6] = x17;\n    out1[7] = x18;\n    out1[8] = x19;\n    out1[9] = x21;\n    out1[10] = x23;\n    out1[11] = x25;\n    out1[12] = x27;\n    out1[13] = x29;\n    out1[14] = x31;\n    out1[15] = x32;\n    out1[16] = x33;\n    out1[17] = x35;\n    out1[18] = x37;\n    out1[19] = x39;\n    out1[20] = x41;\n    out1[21] = x43;\n    out1[22] = x45;\n    out1[23] = x46;\n    out1[24] = x47;\n    out1[25] = x49;\n    out1[26] = x51;\n    out1[27] = x53;\n    out1[28] = x55;\n    out1[29] = x57;\n    out1[30] = x59;\n    out1[31] = x60;\n}",
    "display_name": "fiat_bign256_scalar_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_from_montgomery(\n    out1: &mut fiat_p224_scalar_non_montgomery_domain_field_element,\n    arg1: &fiat_p224_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x2, &mut x3, x1, 0xd6e242706a1fc2eb);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x4, &mut x5, x2, 0xffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x6, &mut x7, x2, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x8, &mut x9, x2, 0xffff16a2e0b8f03e);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x10, &mut x11, x2, 0x13dd29455c5c2a3d);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x12, &mut x13, 0x0, x11, x8);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x9, x6);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, x4);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x18, &mut x19, 0x0, x1, x10);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), x12);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x22, &mut x23, x21, (0x0 as u64), x14);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x24, &mut x25, x23, (0x0 as u64), x16);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x26, &mut x27, 0x0, x20, (arg1[1]));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x28, &mut x29, x27, x22, (0x0 as u64));\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x24, (0x0 as u64));\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x32, &mut x33, x26, 0xd6e242706a1fc2eb);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x34, &mut x35, x32, 0xffffffff);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x36, &mut x37, x32, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x38, &mut x39, x32, 0xffff16a2e0b8f03e);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x40, &mut x41, x32, 0x13dd29455c5c2a3d);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x42, &mut x43, 0x0, x41, x38);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x44, &mut x45, x43, x39, x36);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x46, &mut x47, x45, x37, x34);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x48, &mut x49, 0x0, x26, x40);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x50, &mut x51, x49, x28, x42);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x52, &mut x53, x51, x30, x44);\n    let mut x54: u64 = 0;\n    let mut x55: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(\n        &mut x54,\n        &mut x55,\n        x53,\n        ((x31 as u64) + ((x25 as u64) + ((x17 as u64) + x5))),\n        x46,\n    );\n    let mut x56: u64 = 0;\n    let mut x57: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x56, &mut x57, 0x0, x50, (arg1[2]));\n    let mut x58: u64 = 0;\n    let mut x59: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x58, &mut x59, x57, x52, (0x0 as u64));\n    let mut x60: u64 = 0;\n    let mut x61: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x60, &mut x61, x59, x54, (0x0 as u64));\n    let mut x62: u64 = 0;\n    let mut x63: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x62, &mut x63, x56, 0xd6e242706a1fc2eb);\n    let mut x64: u64 = 0;\n    let mut x65: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x64, &mut x65, x62, 0xffffffff);\n    let mut x66: u64 = 0;\n    let mut x67: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x66, &mut x67, x62, 0xffffffffffffffff);\n    let mut x68: u64 = 0;\n    let mut x69: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x68, &mut x69, x62, 0xffff16a2e0b8f03e);\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x70, &mut x71, x62, 0x13dd29455c5c2a3d);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x72, &mut x73, 0x0, x71, x68);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x74, &mut x75, x73, x69, x66);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x76, &mut x77, x75, x67, x64);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x78, &mut x79, 0x0, x56, x70);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x80, &mut x81, x79, x58, x72);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x60, x74);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(\n        &mut x84,\n        &mut x85,\n        x83,\n        ((x61 as u64) + ((x55 as u64) + ((x47 as u64) + x35))),\n        x76,\n    );\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x86, &mut x87, 0x0, x80, (arg1[3]));\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x82, (0x0 as u64));\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x84, (0x0 as u64));\n    let mut x92: u64 = 0;\n    let mut x93: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x92, &mut x93, x86, 0xd6e242706a1fc2eb);\n    let mut x94: u64 = 0;\n    let mut x95: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x94, &mut x95, x92, 0xffffffff);\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x96, &mut x97, x92, 0xffffffffffffffff);\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x98, &mut x99, x92, 0xffff16a2e0b8f03e);\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x100, &mut x101, x92, 0x13dd29455c5c2a3d);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x102, &mut x103, 0x0, x101, x98);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x104, &mut x105, x103, x99, x96);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x106, &mut x107, x105, x97, x94);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x86, x100);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x88, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x90, x104);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(\n        &mut x114,\n        &mut x115,\n        x113,\n        ((x91 as u64) + ((x85 as u64) + ((x77 as u64) + x65))),\n        x106,\n    );\n    let x116: u64 = ((x115 as u64) + ((x107 as u64) + x95));\n    let mut x117: u64 = 0;\n    let mut x118: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x117, &mut x118, 0x0, x110, 0x13dd29455c5c2a3d);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x119, &mut x120, x118, x112, 0xffff16a2e0b8f03e);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x121, &mut x122, x120, x114, 0xffffffffffffffff);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x123, &mut x124, x122, x116, 0xffffffff);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x125, &mut x126, x124, (0x0 as u64), (0x0 as u64));\n    let mut x127: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x127, x126, x117, x110);\n    let mut x128: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x128, x126, x119, x112);\n    let mut x129: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x129, x126, x121, x114);\n    let mut x130: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x130, x126, x123, x116);\n    out1[0] = x127;\n    out1[1] = x128;\n    out1[2] = x129;\n    out1[3] = x130;\n}",
    "display_name": "fiat_p224_scalar_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_square(\n    out1: &mut fiat_p224_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p224_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x5, &mut x6, x4, (arg1[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x7, &mut x8, x4, (arg1[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x9, &mut x10, x4, (arg1[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x11, &mut x12, x4, (arg1[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x20, &mut x21, x11, 0xd6e242706a1fc2eb);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x22, &mut x23, x20, 0xffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x26, &mut x27, x20, 0xffff16a2e0b8f03e);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x28, &mut x29, x20, 0x13dd29455c5c2a3d);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x30, &mut x31, 0x0, x29, x26);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x27, x24);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x25, x22);\n    let x36: u64 = ((x35 as u64) + x23);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x37, &mut x38, 0x0, x11, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x13, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x15, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x43, &mut x44, x42, x17, x34);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x45, &mut x46, x44, x19, x36);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x47, &mut x48, x1, (arg1[3]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x49, &mut x50, x1, (arg1[2]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x51, &mut x52, x1, (arg1[1]));\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x53, &mut x54, x1, (arg1[0]));\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x55, &mut x56, 0x0, x54, x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x52, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x50, x47);\n    let x61: u64 = ((x60 as u64) + x48);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x45, x59);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x70, &mut x71, x69, (x46 as u64), x61);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x72, &mut x73, x62, 0xd6e242706a1fc2eb);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x74, &mut x75, x72, 0xffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x78, &mut x79, x72, 0xffff16a2e0b8f03e);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x80, &mut x81, x72, 0x13dd29455c5c2a3d);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x82, &mut x83, 0x0, x81, x78);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x79, x76);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x77, x74);\n    let x88: u64 = ((x87 as u64) + x75);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x89, &mut x90, 0x0, x62, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x91, &mut x92, x90, x64, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x93, &mut x94, x92, x66, x84);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x95, &mut x96, x94, x68, x86);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x97, &mut x98, x96, x70, x88);\n    let x99: u64 = ((x98 as u64) + (x71 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x100, &mut x101, x2, (arg1[3]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x102, &mut x103, x2, (arg1[2]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x104, &mut x105, x2, (arg1[1]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x106, &mut x107, x2, (arg1[0]));\n    let mut x108: u64 = 0;\n    let mut x109: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x107, x104);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x105, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x103, x100);\n    let x114: u64 = ((x113 as u64) + x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x115, &mut x116, 0x0, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x121, &mut x122, x120, x97, x112);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x123, &mut x124, x122, x99, x114);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x125, &mut x126, x115, 0xd6e242706a1fc2eb);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x127, &mut x128, x125, 0xffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x129, &mut x130, x125, 0xffffffffffffffff);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x131, &mut x132, x125, 0xffff16a2e0b8f03e);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x133, &mut x134, x125, 0x13dd29455c5c2a3d);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let x141: u64 = ((x140 as u64) + x128);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x142, &mut x143, 0x0, x115, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x144, &mut x145, x143, x117, x135);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x146, &mut x147, x145, x119, x137);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x148, &mut x149, x147, x121, x139);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x150, &mut x151, x149, x123, x141);\n    let x152: u64 = ((x151 as u64) + (x124 as u64));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x153, &mut x154, x3, (arg1[3]));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x155, &mut x156, x3, (arg1[2]));\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x157, &mut x158, x3, (arg1[1]));\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x159, &mut x160, x3, (arg1[0]));\n    let mut x161: u64 = 0;\n    let mut x162: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x161, &mut x162, 0x0, x160, x157);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x163, &mut x164, x162, x158, x155);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x165, &mut x166, x164, x156, x153);\n    let x167: u64 = ((x166 as u64) + x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x168, &mut x169, 0x0, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x148, x163);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x150, x165);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x152, x167);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x178, &mut x179, x168, 0xd6e242706a1fc2eb);\n    let mut x180: u64 = 0;\n    let mut x181: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x180, &mut x181, x178, 0xffffffff);\n    let mut x182: u64 = 0;\n    let mut x183: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x182, &mut x183, x178, 0xffffffffffffffff);\n    let mut x184: u64 = 0;\n    let mut x185: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x184, &mut x185, x178, 0xffff16a2e0b8f03e);\n    let mut x186: u64 = 0;\n    let mut x187: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x186, &mut x187, x178, 0x13dd29455c5c2a3d);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x188, &mut x189, 0x0, x187, x184);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x190, &mut x191, x189, x185, x182);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x183, x180);\n    let x194: u64 = ((x193 as u64) + x181);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x195, &mut x196, 0x0, x168, x186);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x197, &mut x198, x196, x170, x188);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x172, x190);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x174, x192);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x176, x194);\n    let x205: u64 = ((x204 as u64) + (x177 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x206, &mut x207, 0x0, x197, 0x13dd29455c5c2a3d);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x208, &mut x209, x207, x199, 0xffff16a2e0b8f03e);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x210, &mut x211, x209, x201, 0xffffffffffffffff);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x212, &mut x213, x211, x203, 0xffffffff);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x214, &mut x215, x213, x205, (0x0 as u64));\n    let mut x216: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x216, x215, x206, x197);\n    let mut x217: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x217, x215, x208, x199);\n    let mut x218: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x218, x215, x210, x201);\n    let mut x219: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x219, x215, x212, x203);\n    out1[0] = x216;\n    out1[1] = x217;\n    out1[2] = x218;\n    out1[3] = x219;\n}",
    "display_name": "fiat_p224_scalar_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Scalar(0x{:X})\", &self.0)\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/is_identity",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn from(p: AffinePoint) -> Self {\n        let projective = ProjectivePoint {\n            x: p.x,\n            y: p.y,\n            z: FieldElement::ONE,\n        };\n        Self::conditional_select(&projective, &Self::IDENTITY, p.is_identity())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_raw",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_inner"
    ],
    "body": "    pub fn sign_raw(&self, m: &[u8]) -> Result<InnerSignature, SigningError> {\n        self.sign_inner(0, &[], m)\n    }",
    "display_name": "sign_raw",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/expanded.rs",
    "relative_path": "ed448-goldilocks/src/sign/expanded.rs",
    "file_name": "expanded.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn double(&self) -> Self {\n        self.add(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/Signer/try_sign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/MultipartSigner/try_multipart_sign"
    ],
    "body": "    fn try_sign(&self, msg: &[u8]) -> Result<Signature> {\n        self.try_multipart_sign(&[msg])\n    }",
    "display_name": "try_sign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_odd",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_even"
    ],
    "body": "    fn invert_vartime(&self) -> CtOption<Self> {\n        let mut u = *self;\n        let mut v = Self(MODULUS);\n        let mut A = Self::ONE;\n        let mut C = Self::ZERO;\n\n        while !bool::from(u.is_zero()) {\n            // u-loop\n            while bool::from(u.is_even()) {\n                u >>= 1;\n\n                let was_odd: bool = A.is_odd().into();\n                A >>= 1;\n\n                if was_odd {\n                    A += FRAC_MODULUS_2;\n                    A += Self::ONE;\n                }\n            }\n\n            // v-loop\n            while bool::from(v.is_even()) {\n                v >>= 1;\n\n                let was_odd: bool = C.is_odd().into();\n                C >>= 1;\n\n                if was_odd {\n                    C += FRAC_MODULUS_2;\n                    C += Self::ONE;\n                }\n            }\n\n            // sub-step\n            if u >= v {\n                u -= &v;\n                A -= &C;\n            } else {\n                v -= &u;\n                C -= &A;\n            }\n        }\n\n        CtOption::new(C, !self.is_zero())\n    }",
    "display_name": "invert_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_even",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn try_from(public_key: PublicKey) -> Result<VerifyingKey> {\n        if public_key.as_affine().y.normalize().is_even().into() {\n            Ok(Self { inner: public_key })\n        } else {\n            Err(Error::new())\n        }\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 test_field_element_y",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_field_element_y() -> FieldElement {\n    black_box(FieldElement::from_bytes(\n        hex!(\"0184902e515982bb225b8c84f245e61b327c08e94d41c07d0b4101a963e02fe52f6a9f33e8b1de2394e0cb74c40790b4e489b5500e6804cabed0fe8c192443d4027b\").as_ref()\n    )\n    .unwrap())\n}",
    "display_name": "test_field_element_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/field.rs",
    "relative_path": "p521/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "    fn mul_assign(&mut self, rhs: Scalar) {\n        *self = Scalar::multiply(self, &rhs);\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Add/add"
    ],
    "body": "    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Add::add).unwrap_or(Self::ZERO)\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_bytes() {\n        assert_eq!(\n            FieldElement::from_bytes(&FieldBytes::default()).unwrap(),\n            FieldElement::ZERO\n        );\n        assert_eq!(\n            FieldElement::from_bytes(\n                &[\n                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                    0, 0, 0, 0, 0, 1\n                ]\n                .into()\n            )\n            .unwrap(),\n            FieldElement::ONE\n        );\n        assert!(bool::from(\n            FieldElement::from_bytes(&[0xff; 32].into()).is_none()\n        ));\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        let XZ = self.X * other.Z;\n        let ZX = self.Z * other.X;\n\n        let YZ = self.Y * other.Z;\n        let ZY = self.Z * other.Y;\n\n        XZ.ct_eq(&ZX) & YZ.ct_eq(&ZY)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/From>/from"
    ],
    "body": "    fn from(p: &AffinePoint<C>) -> Self {\n        Self::from(*p)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Sum>/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = &'a ProjectivePoint<C>>>(iter: I) -> Self {\n        iter.cloned().sum()\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_opp"
    ],
    "body": "    pub const fn neg(&self) -> Self {\n        let mut out = fiat_p521_tight_field_element([0; 9]);\n        fiat_p521_carry_opp(&mut out, &self.0);\n        Self(out)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn from_bytes_unchecked(bytes: &[u8; 32]) -> Self {\n        let w0 = (bytes[31] as u64)\n            | ((bytes[30] as u64) << 8)\n            | ((bytes[29] as u64) << 16)\n            | ((bytes[28] as u64) << 24)\n            | ((bytes[27] as u64) << 32)\n            | ((bytes[26] as u64) << 40)\n            | (((bytes[25] & 0xFu8) as u64) << 48);\n\n        let w1 = ((bytes[25] >> 4) as u64)\n            | ((bytes[24] as u64) << 4)\n            | ((bytes[23] as u64) << 12)\n            | ((bytes[22] as u64) << 20)\n            | ((bytes[21] as u64) << 28)\n            | ((bytes[20] as u64) << 36)\n            | ((bytes[19] as u64) << 44);\n\n        let w2 = (bytes[18] as u64)\n            | ((bytes[17] as u64) << 8)\n            | ((bytes[16] as u64) << 16)\n            | ((bytes[15] as u64) << 24)\n            | ((bytes[14] as u64) << 32)\n            | ((bytes[13] as u64) << 40)\n            | (((bytes[12] & 0xFu8) as u64) << 48);\n\n        let w3 = ((bytes[12] >> 4) as u64)\n            | ((bytes[11] as u64) << 4)\n            | ((bytes[10] as u64) << 12)\n            | ((bytes[9] as u64) << 20)\n            | ((bytes[8] as u64) << 28)\n            | ((bytes[7] as u64) << 36)\n            | ((bytes[6] as u64) << 44);\n\n        let w4 = (bytes[5] as u64)\n            | ((bytes[4] as u64) << 8)\n            | ((bytes[3] as u64) << 16)\n            | ((bytes[2] as u64) << 24)\n            | ((bytes[1] as u64) << 32)\n            | ((bytes[0] as u64) << 40);\n\n        Self([w0, w1, w2, w3, w4])\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub(self, other: Scalar) -> Scalar {\n        Scalar::sub(&self, &other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_roundtrip_to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "        fn fuzzy_roundtrip_to_bytes(a in scalar()) {\n            let a_back = Scalar::from_repr(a.to_bytes()).unwrap();\n            assert_eq!(a, a_back);\n        }",
    "display_name": "fuzzy_roundtrip_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add"
    ],
    "body": "    fn add(self, rhs: &FieldElement) -> FieldElement {\n        Self::add(&self, rhs)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/ProjectiveMontgomeryPoint/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn identity() -> ProjectiveMontgomeryPoint {\n        ProjectiveMontgomeryPoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_cmovznz_u64(\n    out1: &mut u64,\n    arg1: fiat_bign256_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: fiat_bign256_scalar_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_bign256_scalar_i2) - (x1 as fiat_bign256_scalar_i2))\n        as fiat_bign256_scalar_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_bign256_scalar_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/reduce_nonzero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero",
      "0.14.0_pre.8 arithmetic/scalar/impl/bigint::Uint/From/from",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero_bytes"
    ],
    "body": "    fn reduce_nonzero() {\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero_bytes(&Array::default())),\n            U576::ONE,\n        );\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero(U576::ONE)),\n            U576::from_u8(2),\n        );\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero(U576::from_u8(2))),\n            U576::from_u8(3),\n        );\n\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero(NistP521::ORDER)),\n            U576::from_u8(2),\n        );\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero(\n                NistP521::ORDER.wrapping_sub(&U576::from_u8(1))\n            )),\n            U576::ONE,\n        );\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero(\n                NistP521::ORDER.wrapping_sub(&U576::from_u8(2))\n            )),\n            NistP521::ORDER.wrapping_sub(&U576::ONE),\n        );\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero(\n                NistP521::ORDER.wrapping_sub(&U576::from_u8(3))\n            )),\n            NistP521::ORDER.wrapping_sub(&U576::from_u8(2)),\n        );\n\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero(\n                NistP521::ORDER.wrapping_add(&U576::ONE)\n            )),\n            U576::from_u8(3),\n        );\n        assert_eq!(\n            U576::from(Scalar::reduce_nonzero(\n                NistP521::ORDER.wrapping_add(&U576::from_u8(2))\n            )),\n            U576::from_u8(4),\n        );\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/add_result_within_256_bits",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from"
    ],
    "body": "    fn add_result_within_256_bits() {\n        // A regression for a bug where reduction was not applied\n        // when the unreduced result of addition was in the range `[modulus, 2^256)`.\n        let t = 1.to_biguint().unwrap() << 255;\n        let one = 1.to_biguint().unwrap();\n\n        let a = Scalar::from(&t - &one);\n        let b = Scalar::from(&t);\n        let res = a + b;\n\n        let m = Scalar::modulus_as_biguint();\n        let res_ref = Scalar::from((&t + &t - &one) % &m);\n\n        assert_eq!(res, res_ref);\n    }",
    "display_name": "add_result_within_256_bits",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/test/test_vectors_lib_decaf",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/decompress",
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/compress"
    ],
    "body": "    fn test_vectors_lib_decaf() {\n        // Testing small multiples of basepoint. Taken from reference implementation.\n        let compressed = [\n            // Taken from libdecaf, where they were computed using SAGE script\n            CompressedDecaf([\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ]),\n            CompressedDecaf([\n                102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102,\n                102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 51, 51, 51, 51, 51, 51,\n                51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,\n                51,\n            ]),\n            CompressedDecaf([\n                200, 152, 235, 79, 135, 249, 124, 86, 76, 111, 214, 31, 199, 228, 150, 137, 49, 74,\n                31, 129, 142, 200, 94, 235, 59, 213, 81, 74, 200, 22, 211, 135, 120, 246, 158, 243,\n                71, 168, 159, 202, 129, 126, 102, 222, 253, 237, 206, 23, 140, 124, 199, 9, 178,\n                17, 110, 117,\n            ]),\n            CompressedDecaf([\n                160, 192, 155, 242, 186, 114, 8, 253, 160, 244, 191, 227, 208, 245, 178, 154, 84,\n                48, 18, 48, 109, 67, 131, 27, 90, 220, 111, 231, 248, 89, 111, 163, 8, 118, 61,\n                177, 84, 104, 50, 59, 17, 207, 110, 74, 235, 140, 24, 254, 68, 103, 143, 68, 84,\n                90, 105, 188,\n            ]),\n            CompressedDecaf([\n                180, 111, 24, 54, 170, 40, 124, 10, 90, 86, 83, 240, 236, 94, 249, 233, 3, 244, 54,\n                226, 28, 21, 112, 194, 154, 217, 229, 245, 150, 218, 151, 238, 175, 23, 21, 10,\n                227, 11, 203, 49, 116, 208, 75, 194, 215, 18, 200, 199, 120, 157, 124, 180, 253,\n                161, 56, 244,\n            ]),\n            CompressedDecaf([\n                28, 91, 190, 207, 71, 65, 223, 170, 231, 157, 183, 45, 250, 206, 0, 234, 170, 197,\n                2, 194, 6, 9, 52, 182, 234, 174, 202, 106, 32, 189, 61, 169, 224, 190, 135, 119,\n                247, 208, 32, 51, 209, 177, 88, 132, 35, 34, 129, 164, 31, 199, 248, 14, 237, 4,\n                175, 94,\n            ]),\n            CompressedDecaf([\n                134, 255, 1, 130, 212, 15, 127, 158, 219, 120, 98, 81, 88, 33, 189, 103, 191, 214,\n                22, 90, 60, 68, 222, 149, 215, 223, 121, 184, 119, 156, 207, 100, 96, 227, 198,\n                139, 112, 193, 106, 170, 40, 15, 45, 123, 63, 34, 215, 69, 185, 122, 137, 144, 108,\n                252, 71, 108,\n            ]),\n            CompressedDecaf([\n                80, 43, 203, 104, 66, 235, 6, 240, 228, 144, 50, 186, 232, 124, 85, 76, 3, 29, 109,\n                77, 45, 118, 148, 239, 191, 156, 70, 141, 72, 34, 12, 80, 248, 202, 40, 132, 51,\n                100, 215, 12, 238, 146, 214, 254, 36, 110, 97, 68, 143, 157, 185, 128, 139, 59, 36,\n                8,\n            ]),\n            CompressedDecaf([\n                12, 152, 16, 241, 226, 235, 211, 137, 202, 167, 137, 55, 77, 120, 0, 121, 116, 239,\n                77, 23, 34, 115, 22, 244, 14, 87, 139, 51, 104, 39, 218, 63, 107, 72, 42, 71, 148,\n                235, 106, 57, 117, 185, 113, 181, 225, 56, 143, 82, 233, 30, 162, 241, 188, 176,\n                249, 18,\n            ]),\n            CompressedDecaf([\n                32, 212, 29, 133, 161, 141, 86, 87, 162, 150, 64, 50, 21, 99, 187, 208, 76, 47,\n                251, 208, 163, 122, 123, 164, 58, 79, 125, 38, 60, 226, 111, 175, 78, 31, 116, 249,\n                244, 181, 144, 198, 146, 41, 174, 87, 31, 227, 127, 166, 57, 181, 184, 235, 72,\n                189, 154, 85,\n            ]),\n            CompressedDecaf([\n                230, 180, 184, 244, 8, 199, 1, 13, 6, 1, 231, 237, 160, 195, 9, 161, 164, 39, 32,\n                214, 208, 107, 87, 89, 253, 196, 225, 239, 226, 45, 7, 109, 108, 68, 212, 47, 80,\n                141, 103, 190, 70, 41, 20, 210, 139, 142, 220, 227, 46, 112, 148, 48, 81, 100, 175,\n                23,\n            ]),\n            CompressedDecaf([\n                190, 136, 187, 184, 108, 89, 193, 61, 142, 157, 9, 171, 152, 16, 95, 105, 194, 209,\n                221, 19, 77, 188, 211, 176, 134, 54, 88, 245, 49, 89, 219, 100, 192, 225, 57, 209,\n                128, 243, 200, 155, 130, 150, 208, 174, 50, 68, 25, 192, 111, 168, 127, 199, 218,\n                175, 52, 193,\n            ]),\n            CompressedDecaf([\n                164, 86, 249, 54, 151, 105, 232, 240, 137, 2, 18, 74, 3, 20, 199, 160, 101, 55,\n                160, 110, 50, 65, 31, 79, 147, 65, 89, 80, 161, 123, 173, 250, 116, 66, 182, 33,\n                116, 52, 163, 160, 94, 244, 91, 229, 241, 11, 215, 178, 239, 142, 160, 12, 67, 30,\n                222, 197,\n            ]),\n            CompressedDecaf([\n                24, 110, 69, 44, 68, 102, 170, 67, 131, 180, 192, 2, 16, 213, 46, 121, 34, 219,\n                249, 119, 30, 139, 71, 226, 41, 169, 183, 183, 60, 141, 16, 253, 126, 240, 182,\n                228, 21, 48, 249, 31, 36, 163, 237, 154, 183, 31, 163, 139, 152, 178, 254, 71, 70,\n                213, 29, 104,\n            ]),\n            CompressedDecaf([\n                74, 231, 253, 202, 233, 69, 63, 25, 90, 142, 173, 92, 190, 26, 123, 150, 153, 103,\n                59, 82, 196, 10, 178, 121, 39, 70, 72, 135, 190, 83, 35, 127, 127, 58, 33, 185, 56,\n                212, 13, 14, 201, 225, 91, 29, 81, 48, 177, 63, 254, 216, 19, 115, 165, 62, 43, 67,\n            ]),\n            CompressedDecaf([\n                132, 25, 129, 195, 191, 238, 195, 246, 12, 254, 202, 117, 217, 216, 220, 23, 244,\n                108, 240, 16, 111, 36, 34, 181, 154, 236, 88, 10, 88, 243, 66, 39, 46, 58, 94, 87,\n                90, 5, 93, 219, 5, 19, 144, 197, 76, 36, 198, 236, 177, 224, 172, 235, 7, 95, 96,\n                86,\n            ]),\n        ];\n        let mut point = DecafPoint::IDENTITY;\n        let generator = DecafPoint::GENERATOR;\n        for compressed_point in compressed.iter() {\n            assert_eq!(&point.compress(), compressed_point);\n            point += generator;\n            let decompressed_point = compressed_point.decompress();\n            assert_eq!(decompressed_point.is_some().unwrap_u8(), 1u8);\n        }\n    }",
    "display_name": "test_vectors_lib_decaf",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/scalar_mul/variable_base/test/test_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_untwisted",
      "0.14.0_pre.1 curve/scalar_mul/double_and_add/double_and_add",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/scalar_mul",
      "0.14.0_pre.1 curve/scalar_mul/variable_base/variable_base"
    ],
    "body": "    fn test_scalar_mul() {\n        // XXX: In the future use known multiples from Sage in bytes form?\n        let twisted_point = TWISTED_EDWARDS_BASE_POINT;\n        let scalar = Scalar(U448::from_be_hex(\n            \"05ca185aee2e1b73def437f63c003777083f83043fe5bf1aab454c66b64629d1de8026c1307f665ead0b70151533427ce128ae786ee372b7\",\n        ));\n\n        let got = variable_base(&twisted_point, &scalar);\n\n        let got2 = double_and_add(&twisted_point, &scalar);\n        assert_eq!(got, got2);\n\n        // Lets see if this is conserved over the isogenies\n        let edwards_point = twisted_point.to_untwisted();\n        let got_untwisted_point = edwards_point.scalar_mul(&scalar);\n        let expected_untwisted_point = got.to_untwisted();\n        assert_eq!(got_untwisted_point, expected_untwisted_point);\n    }",
    "display_name": "test_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/scalar_mul/variable_base.rs",
    "relative_path": "ed448-goldilocks/src/curve/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn invert() {\n        assert!(bool::from(FieldElement::ZERO.invert().is_none()));\n\n        let one = FieldElement::ONE;\n        assert_eq!(one.invert().unwrap().normalize(), one);\n\n        let two = one + &one;\n        let inv_two = two.invert().unwrap();\n        assert_eq!((two * &inv_two).normalize(), one);\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/encrypt"
    ],
    "body": "    pub fn encrypt_digest<R: TryCryptoRng + ?Sized, D>(\n        &self,\n        rng: &mut R,\n        msg: &[u8],\n    ) -> Result<Vec<u8>>\n    where\n        D: 'static + Digest + DynDigest + Send + Sync,\n    {\n        let mut digest = D::new();\n        encrypt(rng, &self.public_key, self.mode, &mut digest, msg)\n    }",
    "display_name": "encrypt_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_canonical",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_hex",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/invert_unchecked"
    ],
    "body": "    fn is_high(&self) -> Choice {\n        const MODULUS_SHR1: U256 = Sm2::ORDER.shr_vartime(1);\n        self.to_canonical().ct_gt(&MODULUS_SHR1)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffineNielsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            td: FieldElement::conditional_select(&a.td, &b.td, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/test_is_torsion_free",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_torsion_free",
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    fn test_is_torsion_free() {\n        assert_eq!(EdwardsPoint::GENERATOR.is_torsion_free().unwrap_u8(), 1u8);\n        assert_eq!(EdwardsPoint::IDENTITY.is_torsion_free().unwrap_u8(), 1u8);\n\n        let bytes = hex!(\n            \"13b6714c7a5f53101bbec88f2f17cd30f42e37fae363a5474efb4197ed6005df5861ae178a0c2c16ad378b7befed0d0904b7ced35e9f674180\"\n        );\n        let compressed = CompressedEdwardsY(bytes);\n        let decompressed = compressed.decompress();\n        assert_eq!(decompressed.is_none().unwrap_u8(), 1u8);\n    }",
    "display_name": "test_is_torsion_free",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 benches",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_point",
      "0.14.0_pre.8 bench_field_element",
      "0.14.0_pre.8 bench_scalar"
    ],
    "body": "criterion_group!(benches, bench_field_element);\ncriterion_main!(benches);",
    "display_name": "benches",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/field.rs",
    "relative_path": "p256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/square"
    ],
    "body": "    pub fn square(&self) -> Self {\n        Self(self.0.square())\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_negate<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"negate\", |b| b.iter(|| -x));\n}",
    "display_name": "bench_scalar_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_canonical",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/to_canonical"
    ],
    "body": "    pub(crate) const fn to_canonical(self) -> U256 {\n        field_impl::to_canonical(self.0)\n    }",
    "display_name": "to_canonical",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/fuzzy_sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/tests/field_element",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/From/from",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "        fn fuzzy_sqrt(\n            a in field_element()\n        ) {\n            let m = FieldElement::modulus_as_biguint();\n            let a_bi = a.to_biguint().unwrap();\n            let sqr_bi = (&a_bi * &a_bi) % &m;\n            let sqr = FieldElement::from(&sqr_bi);\n\n            let res_ref1 = a;\n            let possible_sqrt = (&m - &a_bi) % &m;\n            let res_ref2 = FieldElement::from(&possible_sqrt);\n            let res_test = sqr.sqrt().unwrap().normalize();\n            // FIXME: is there a rule which square root is returned?\n            assert!(res_test == res_ref1 || res_test == res_ref2);\n        }",
    "display_name": "fuzzy_sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/GroupEncoding/to_bytes",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/to_affine",
      "affine/impl/AffinePoint/GroupEncoding/to_bytes"
    ],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        self.to_affine().to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint"
    ],
    "body": "    pub fn from_bytes(repr: &FieldBytes) -> CtOption<Self> {\n        let uint = <U576 as FieldBytesEncoding<NistP521>>::decode_field_bytes(repr);\n        Self::from_uint(uint)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 7],\n    out3: &mut [u64; 7],\n    out4: &mut [u64; 6],\n    out5: &mut [u64; 6],\n    arg1: u64,\n    arg2: &[u64; 7],\n    arg3: &[u64; 7],\n    arg4: &[u64; 6],\n    arg5: &[u64; 6],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_p384_scalar_u1 =\n        (((x1 >> 63) as fiat_p384_scalar_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_p384_scalar_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x12, x3, (arg2[5]), (arg3[5]));\n    let mut x13: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x13, x3, (arg2[6]), (arg3[6]));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x14, &mut x15, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), (!(arg2[1])));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), (!(arg2[2])));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), (!(arg2[3])));\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x22, &mut x23, x21, (0x0 as u64), (!(arg2[4])));\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x24, &mut x25, x23, (0x0 as u64), (!(arg2[5])));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x26, &mut x27, x25, (0x0 as u64), (!(arg2[6])));\n    let mut x28: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x28, x3, (arg3[0]), x14);\n    let mut x29: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x29, x3, (arg3[1]), x16);\n    let mut x30: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x30, x3, (arg3[2]), x18);\n    let mut x31: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x31, x3, (arg3[3]), x20);\n    let mut x32: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x32, x3, (arg3[4]), x22);\n    let mut x33: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x33, x3, (arg3[5]), x24);\n    let mut x34: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x34, x3, (arg3[6]), x26);\n    let mut x35: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x35, x3, (arg4[0]), (arg5[0]));\n    let mut x36: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x36, x3, (arg4[1]), (arg5[1]));\n    let mut x37: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x37, x3, (arg4[2]), (arg5[2]));\n    let mut x38: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x38, x3, (arg4[3]), (arg5[3]));\n    let mut x39: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x39, x3, (arg4[4]), (arg5[4]));\n    let mut x40: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x40, x3, (arg4[5]), (arg5[5]));\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x41, &mut x42, 0x0, x35, x35);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x43, &mut x44, x42, x36, x36);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x45, &mut x46, x44, x37, x37);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x47, &mut x48, x46, x38, x38);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x49, &mut x50, x48, x39, x39);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x51, &mut x52, x50, x40, x40);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x53, &mut x54, 0x0, x41, 0xecec196accc52973);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x55, &mut x56, x54, x43, 0x581a0db248b0a77a);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x57, &mut x58, x56, x45, 0xc7634d81f4372ddf);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x59, &mut x60, x58, x47, 0xffffffffffffffff);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x61, &mut x62, x60, x49, 0xffffffffffffffff);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x63, &mut x64, x62, x51, 0xffffffffffffffff);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x65, &mut x66, x64, (x52 as u64), (0x0 as u64));\n    let x67: u64 = (arg4[5]);\n    let x68: u64 = (arg4[4]);\n    let x69: u64 = (arg4[3]);\n    let x70: u64 = (arg4[2]);\n    let x71: u64 = (arg4[1]);\n    let x72: u64 = (arg4[0]);\n    let mut x73: u64 = 0;\n    let mut x74: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x73, &mut x74, 0x0, (0x0 as u64), x72);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x75, &mut x76, x74, (0x0 as u64), x71);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x77, &mut x78, x76, (0x0 as u64), x70);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x79, &mut x80, x78, (0x0 as u64), x69);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x81, &mut x82, x80, (0x0 as u64), x68);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x83, &mut x84, x82, (0x0 as u64), x67);\n    let mut x85: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x85, x84, (0x0 as u64), 0xffffffffffffffff);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x86, &mut x87, 0x0, x73, (x85 & 0xecec196accc52973));\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x75, (x85 & 0x581a0db248b0a77a));\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x77, (x85 & 0xc7634d81f4372ddf));\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x92, &mut x93, x91, x79, x85);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x81, x85);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x83, x85);\n    let mut x98: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x98, x3, (arg5[0]), x86);\n    let mut x99: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x99, x3, (arg5[1]), x88);\n    let mut x100: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x100, x3, (arg5[2]), x90);\n    let mut x101: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x101, x3, (arg5[3]), x92);\n    let mut x102: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x102, x3, (arg5[4]), x94);\n    let mut x103: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x103, x3, (arg5[5]), x96);\n    let x104: fiat_p384_scalar_u1 = ((x28 & (0x1 as u64)) as fiat_p384_scalar_u1);\n    let mut x105: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x105, x104, (0x0 as u64), x7);\n    let mut x106: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x106, x104, (0x0 as u64), x8);\n    let mut x107: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x107, x104, (0x0 as u64), x9);\n    let mut x108: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x108, x104, (0x0 as u64), x10);\n    let mut x109: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x109, x104, (0x0 as u64), x11);\n    let mut x110: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x110, x104, (0x0 as u64), x12);\n    let mut x111: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x111, x104, (0x0 as u64), x13);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x112, &mut x113, 0x0, x28, x105);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x114, &mut x115, x113, x29, x106);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x116, &mut x117, x115, x30, x107);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x118, &mut x119, x117, x31, x108);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x120, &mut x121, x119, x32, x109);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x33, x110);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x124, &mut x125, x123, x34, x111);\n    let mut x126: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x126, x104, (0x0 as u64), x35);\n    let mut x127: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x127, x104, (0x0 as u64), x36);\n    let mut x128: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x128, x104, (0x0 as u64), x37);\n    let mut x129: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x129, x104, (0x0 as u64), x38);\n    let mut x130: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x130, x104, (0x0 as u64), x39);\n    let mut x131: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x131, x104, (0x0 as u64), x40);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x132, &mut x133, 0x0, x98, x126);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x134, &mut x135, x133, x99, x127);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x136, &mut x137, x135, x100, x128);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x138, &mut x139, x137, x101, x129);\n    let mut x140: u64 = 0;\n    let mut x141: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x140, &mut x141, x139, x102, x130);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x142, &mut x143, x141, x103, x131);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x144, &mut x145, 0x0, x132, 0xecec196accc52973);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x146, &mut x147, x145, x134, 0x581a0db248b0a77a);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x148, &mut x149, x147, x136, 0xc7634d81f4372ddf);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x150, &mut x151, x149, x138, 0xffffffffffffffff);\n    let mut x152: u64 = 0;\n    let mut x153: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x152, &mut x153, x151, x140, 0xffffffffffffffff);\n    let mut x154: u64 = 0;\n    let mut x155: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x154, &mut x155, x153, x142, 0xffffffffffffffff);\n    let mut x156: u64 = 0;\n    let mut x157: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x156, &mut x157, x155, (x143 as u64), (0x0 as u64));\n    let mut x158: u64 = 0;\n    let mut x159: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x158, &mut x159, 0x0, x6, (0x1 as u64));\n    let x160: u64 = ((x112 >> 1) | ((x114 << 63) & 0xffffffffffffffff));\n    let x161: u64 = ((x114 >> 1) | ((x116 << 63) & 0xffffffffffffffff));\n    let x162: u64 = ((x116 >> 1) | ((x118 << 63) & 0xffffffffffffffff));\n    let x163: u64 = ((x118 >> 1) | ((x120 << 63) & 0xffffffffffffffff));\n    let x164: u64 = ((x120 >> 1) | ((x122 << 63) & 0xffffffffffffffff));\n    let x165: u64 = ((x122 >> 1) | ((x124 << 63) & 0xffffffffffffffff));\n    let x166: u64 = ((x124 & 0x8000000000000000) | (x124 >> 1));\n    let mut x167: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x167, x66, x53, x41);\n    let mut x168: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x168, x66, x55, x43);\n    let mut x169: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x169, x66, x57, x45);\n    let mut x170: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x170, x66, x59, x47);\n    let mut x171: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x171, x66, x61, x49);\n    let mut x172: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x172, x66, x63, x51);\n    let mut x173: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x173, x157, x144, x132);\n    let mut x174: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x174, x157, x146, x134);\n    let mut x175: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x175, x157, x148, x136);\n    let mut x176: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x176, x157, x150, x138);\n    let mut x177: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x177, x157, x152, x140);\n    let mut x178: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x178, x157, x154, x142);\n    *out1 = x158;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out2[5] = x12;\n    out2[6] = x13;\n    out3[0] = x160;\n    out3[1] = x161;\n    out3[2] = x162;\n    out3[3] = x163;\n    out3[4] = x164;\n    out3[5] = x165;\n    out3[6] = x166;\n    out4[0] = x167;\n    out4[1] = x168;\n    out4[2] = x169;\n    out4[3] = x170;\n    out4[4] = x171;\n    out4[5] = x172;\n    out5[0] = x173;\n    out5[1] = x174;\n    out5[2] = x175;\n    out5[3] = x176;\n    out5[4] = x177;\n    out5[5] = x178;\n}",
    "display_name": "fiat_p384_scalar_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/generate_biased",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/generate_biased",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero"
    ],
    "body": "    fn generate_biased() {\n        let a = Scalar::generate_biased(&mut OsRng.unwrap_mut());\n        // just to make sure `a` is not optimized out by the compiler\n        assert_eq!((a - &a).is_zero().unwrap_u8(), 1);\n    }",
    "display_name": "generate_biased",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: &Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(bytes.as_slice())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(point: PointBytes) -> Self {\n        Self(point)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre reject_invalid_signature",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/from_bytes",
      "0.14.0_pre ecdsa/signing/impl/SigningKey/verifying_key",
      "0.14.0_pre ecdsa/impl/Signature/to_bytes",
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/Verifier/verify",
      "0.14.0_pre signing_key"
    ],
    "body": "    fn reject_invalid_signature(sk in signing_key(), byte in 0usize..32, bit in 0usize..8) {\n        let mut signature_bytes = sk.sign(MSG).to_bytes();\n\n        // tweak signature to make it invalid\n        signature_bytes[byte] ^= 1 << bit;\n\n        let signature = Signature::from_bytes(&signature_bytes).unwrap();\n        prop_assert!(sk.verifying_key().verify(MSG, &signature).is_err());\n    }",
    "display_name": "reject_invalid_signature",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/dsa.rs",
    "relative_path": "bign256/tests/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/mul"
    ],
    "body": "    fn mul_assign(&mut self, rhs: Scalar) {\n        *self = mul(self, &rhs);\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/scalar_hash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032",
      "0.14.0_pre.1 field/scalar/impl/Scalar/hash"
    ],
    "body": "    fn scalar_hash() {\n        let msg = b\"hello world\";\n        let dst = b\"edwards448_XOF:SHAKE256_ELL2_RO_\";\n        let res =\n            Scalar::hash::<elliptic_curve::hash2curve::ExpandMsgXof<sha3::Shake256>>(msg, dst);\n        let expected: [u8; 57] = hex_literal::hex!(\n            \"2d32a08f09b88275cc5f437e625696b18de718ed94559e17e4d64aafd143a8527705132178b5ce7395ea6214735387398a35913656b4951300\"\n        );\n        assert_eq!(res.to_bytes_rfc_8032(), Array::from(expected));\n    }",
    "display_name": "scalar_hash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize_weak",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/mul_single"
    ],
    "body": "    pub fn double(&self) -> ProjectivePoint {\n        // We implement the complete addition formula from Renes-Costello-Batina 2015\n        // (https://eprint.iacr.org/2015/1060 Algorithm 9).\n\n        let yy = self.y.square();\n        let zz = self.z.square();\n        let xy2 = (self.x * &self.y).double();\n\n        let bzz = &zz.mul_single(CURVE_EQUATION_B_SINGLE);\n        let bzz3 = (bzz.double() + bzz).normalize_weak();\n        let bzz9 = (bzz3.double() + &bzz3).normalize_weak();\n\n        let yy_m_bzz9 = yy + &bzz9.negate(1);\n        let yy_p_bzz3 = yy + &bzz3;\n\n        let yy_zz = yy * &zz;\n        let yy_zz8 = yy_zz.double().double().double();\n        let t = (yy_zz8.double() + &yy_zz8)\n            .normalize_weak()\n            .mul_single(CURVE_EQUATION_B_SINGLE);\n\n        ProjectivePoint {\n            x: xy2 * &yy_m_bzz9,\n            y: ((yy_m_bzz9 * &yy_p_bzz3) + &t).normalize_weak(),\n            z: ((yy * &self.y) * &self.z)\n                .double()\n                .double()\n                .double()\n                .normalize_weak(),\n        }\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: &Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(value.as_slice())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/as_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    pub fn as_bytes(&self) -> &PointBytes {\n        self.compressed.as_bytes()\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl//u8; 56//From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(compressed: CompressedDecaf) -> DecafPointBytes {\n        compressed.0\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/to_affine",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/to_affine_internal"
    ],
    "body": "    pub fn to_affine(&self) -> AffinePoint<C> {\n        <C::FieldElement as Field>::invert(&self.z)\n            .map(|zinv| self.to_affine_internal(zinv))\n            .unwrap_or(AffinePoint::IDENTITY)\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize_weak"
    ],
    "body": "    fn neg(self) -> Self::Output {\n        AffinePoint {\n            x: self.x,\n            y: self.y.negate(1).normalize_weak(),\n            infinity: self.infinity,\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_negate<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"negate\", |b| b.iter(|| -x));\n}",
    "display_name": "bench_scalar_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/primeorder::array::Array::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn from(scalar: &Scalar) -> Self {\n        scalar.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_u64",
      "0.14.0_pre arithmetic/field/impl/FieldElement/invert_unchecked",
      "0.14.0_pre arithmetic/field/impl/FieldElement/pow_vartime",
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_hex",
      "0.14.0_pre arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        // Because p ≡ 3 mod 4 for SM2's base field modulus, sqrt can be done with only one\n        // exponentiation via the computation of self^((p + 1) // 4) (mod p).\n        let sqrt = self.pow_vartime(&[\n            0x4000000000000000,\n            0xffffffffc0000000,\n            0xffffffffffffffff,\n            0x3fffffffbfffffff,\n        ]);\n        CtOption::new(sqrt, sqrt.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/from_scalars",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/TryFrom/try_from"
    ],
    "body": "    pub fn from_scalars(s0: impl Into<FieldBytes>, s1: impl Into<FieldBytes>) -> Result<Self> {\n        let s0 = &mut s0.into()[16..];\n        let mut s1 = s1.into();\n\n        s0.reverse();\n        s1.reverse();\n\n        let mut s: Array<u8, U48> = Default::default();\n        s[..Self::BYTE_SIZE / 3].copy_from_slice(s0);\n        s[Self::BYTE_SIZE / 3..Self::BYTE_SIZE].copy_from_slice(&s1);\n\n        Self::try_from(s.as_slice())\n    }",
    "display_name": "from_scalars",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqn",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        let sqrt = self.sqn(519);\n        CtOption::new(sqrt, sqrt.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &fiat_p521_tight_field_element {\n        &self.0\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_invert<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"invert\", |b| b.iter(|| black_box(x).invert()));\n}",
    "display_name": "bench_field_element_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/muladd_fast",
    "statement_type": "function",
    "deps": [],
    "body": "fn muladd_fast(a: u64, b: u64, c0: u64, c1: u64) -> (u64, u64) {\n    let t = (a as u128) * (b as u128);\n    let th = (t >> 64) as u64; // at most 0xFFFFFFFFFFFFFFFE\n    let tl = t as u64;\n\n    let (new_c0, carry0) = c0.overflowing_add(tl);\n    let new_th = th.wrapping_add(carry0 as u64); // at most 0xFFFFFFFFFFFFFFFF\n    let new_c1 = c1 + new_th;\n\n    (new_c0, new_c1)\n}",
    "display_name": "muladd_fast",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/sqrt_ratio",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq",
      "0.14.0_pre.1 field/element/impl/FieldElement/inverse_square_root"
    ],
    "body": "    pub(crate) fn sqrt_ratio(u: &FieldElement, v: &FieldElement) -> (FieldElement, Choice) {\n        // Compute sqrt(1/(uv))\n        let x = *u * v;\n        let (inv_sqrt_x, is_res) = x.inverse_square_root();\n        // Return u * sqrt(1/(uv)) == sqrt(u/v). However, since this trick only works\n        // for u != 0, check for that case explicitly (when u == 0 then inv_sqrt_x\n        // will be zero, which is what we want, but is_res will be 0)\n        let zero_u = u.ct_eq(&FieldElement::ZERO);\n        (inv_sqrt_x * u, zero_u | is_res)\n    }",
    "display_name": "sqrt_ratio",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/to_canonical",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_canonical",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/sub_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended"
    ],
    "body": "    pub fn sub(&self, other: &DecafPoint) -> DecafPoint {\n        DecafPoint(self.0.to_extensible().sub_extended(&other.0).to_extended())\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add(self, other: &Scalar) -> Scalar {\n        Scalar::add(&self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes"
    ],
    "body": "    fn scalar()(bytes in any::<[u8; 32]>()) -> Scalar {\n        <Scalar as Reduce<U256>>::reduce_bytes(&bytes.into())\n    }",
    "display_name": "scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/scalar.rs",
    "relative_path": "p256/tests/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: C::FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: C::FieldElement::conditional_select(&a.y, &b.y, choice),\n            z: C::FieldElement::conditional_select(&a.z, &b.z, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/DigestVerifier/verify_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/PrehashVerifier/verify_prehash"
    ],
    "body": "    fn verify_digest(&self, digest: D, signature: &Signature) -> Result<()> {\n        self.verify_prehash(digest.finalize_fixed().as_slice(), signature)\n    }",
    "display_name": "verify_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_negate<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"negate\", |b| b.iter(|| -black_box(x)));\n}",
    "display_name": "bench_scalar_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/to_bytes"
    ],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"sm2::dsa::Signature(\")?;\n\n        for byte in self.to_bytes() {\n            write!(f, \"{:02X}\", byte)?;\n        }\n\n        write!(f, \")\")\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn identity() -> ProjectivePoint {\n        Self::IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 impl/primefield::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        self.to_be_byte_array()\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/lib.rs",
    "relative_path": "p384/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/scalar_mul/window/wnaf/impl/LookupTable/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_projective_niels",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_projective_niels",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible"
    ],
    "body": "    fn from(point: &ExtendedPoint) -> LookupTable {\n        let P = point.to_extensible();\n\n        let mut table = [P.to_projective_niels(); 8];\n\n        for i in 1..8 {\n            table[i] = P.add_projective_niels(&table[i - 1]).to_projective_niels();\n        }\n\n        LookupTable(table)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/scalar_mul/window/wnaf.rs",
    "relative_path": "ed448-goldilocks/src/curve/scalar_mul/window/wnaf.rs",
    "file_name": "wnaf.rs",
    "parent_folder": "window"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/DynSignatureAlgorithmIdentifier/signature_algorithm_identifier",
    "statement_type": "function",
    "deps": [],
    "body": "    fn signature_algorithm_identifier(\n        &self,\n    ) -> pkcs8::spki::Result<pkcs8::spki::AlgorithmIdentifierOwned> {\n        // See https://datatracker.ietf.org/doc/html/rfc8410 for id-Ed448\n        Ok(pkcs8::spki::AlgorithmIdentifier {\n            oid: super::ALGORITHM_OID,\n            parameters: None,\n        })\n    }",
    "display_name": "signature_algorithm_identifier",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Group/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/hash_with_defaults"
    ],
    "body": "    fn try_from_rng<R>(rng: &mut R) -> Result<Self, R::Error>\n    where\n        R: TryRngCore + ?Sized,\n    {\n        let mut bytes = [0u8; 32];\n        rng.try_fill_bytes(&mut bytes)?;\n        Ok(Self::hash_with_defaults(&bytes))\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_divstep_precomp(out1: &mut [u64; 3]) {\n    out1[0] = 0xffffffffffe00000;\n    out1[1] = 0xffffffffffefffff;\n    out1[2] = 0x1fffff;\n}",
    "display_name": "fiat_p192_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        U256::from_be_byte_array(*field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/lib.rs",
    "relative_path": "bign256/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/identity"
    ],
    "body": "    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/projective.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/sign_raw",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/tagged_hash",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/as_affine",
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/to_bytes",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/PrehashVerifier/verify_prehash",
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/From>/from",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 schnorr/verifying/impl/AffinePoint/From/from"
    ],
    "body": "    pub fn sign_raw(&self, msg: &[u8], aux_rand: &[u8; 32]) -> Result<Signature> {\n        let mut t = tagged_hash(AUX_TAG).chain_update(aux_rand).finalize();\n\n        for (a, b) in t.iter_mut().zip(self.secret_key.to_bytes().iter()) {\n            *a ^= b\n        }\n\n        let rand = tagged_hash(NONCE_TAG)\n            .chain_update(t)\n            .chain_update(self.verifying_key.as_affine().x.to_bytes())\n            .chain_update(msg)\n            .finalize();\n\n        let k = NonZeroScalar::try_from(&*rand)\n            .map(Self::from)\n            .map_err(|_| Error::new())?;\n\n        let secret_key = k.secret_key;\n        let verifying_point = AffinePoint::from(k.verifying_key);\n        let r = verifying_point.x.normalize();\n\n        let e = <Scalar as Reduce<U256>>::reduce_bytes(\n            &tagged_hash(CHALLENGE_TAG)\n                .chain_update(r.to_bytes())\n                .chain_update(self.verifying_key.to_bytes())\n                .chain_update(msg)\n                .finalize(),\n        );\n\n        let s = *secret_key + e * *self.secret_key;\n        let s = Option::from(NonZeroScalar::new(s)).ok_or_else(Error::new)?;\n        let sig = Signature { r, s };\n\n        #[cfg(debug_assertions)]\n        self.verifying_key.verify_prehash(msg, &sig)?;\n\n        Ok(sig)\n    }",
    "display_name": "sign_raw",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double"
    ],
    "body": "    fn double(&self) -> Self {\n        self.double()\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/Drop/drop",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        self.secret.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from_uint_unchecked(uint: Self::Uint) -> Self {\n        Self::from_uint_unchecked(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_p224_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_nonzero(out1: &mut u64, arg1: &[u64; 6]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | ((arg1[2]) | ((arg1[3]) | ((arg1[4]) | (arg1[5]))))));\n    *out1 = x1;\n}",
    "display_name": "fiat_p384_scalar_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&DecafPoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/scalar_mul/double_and_add/double_and_add"
    ],
    "body": "    fn mul(self, scalar: &Scalar) -> DecafPoint {\n        // XXX: We can do better than double and add\n        DecafPoint(double_and_add(&self.0, scalar))\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p192_selectznz(\n    out1: &mut [u64; 3],\n    arg1: fiat_p192_u1,\n    arg2: &[u64; 3],\n    arg3: &[u64; 3],\n) {\n    let mut x1: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n}",
    "display_name": "fiat_p192_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_nonzero(out1: &mut u64, arg1: &[u64; 4]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | ((arg1[2]) | (arg1[3]))));\n    *out1 = x1;\n}",
    "display_name": "fiat_sm2_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/Ed448/MapToCurve/map_to_subgroup",
    "statement_type": "function",
    "deps": [],
    "body": "    fn map_to_subgroup(point: EdwardsPoint) -> EdwardsPoint {\n        point\n    }",
    "display_name": "map_to_subgroup",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_y() -> Scalar {\n    Scalar::from_repr(\n        hex!(\"0f56db78ca460b055c500064824bed999a25aaf48ebb519ac201537b85479813\").into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_scalar_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/decompose_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/mul_shift_vartime"
    ],
    "body": "fn decompose_scalar(k: &Scalar) -> (Scalar, Scalar) {\n    // these _vartime calls are constant time since the shift amount is constant\n    let c1 = WideScalar::mul_shift_vartime(k, &G1, 384) * MINUS_B1;\n    let c2 = WideScalar::mul_shift_vartime(k, &G2, 384) * MINUS_B2;\n    let r2 = c1 + c2;\n    let r1 = k + r2 * MINUS_LAMBDA;\n\n    (r1, r2)\n}",
    "display_name": "decompose_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_sqrt<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"sqrt\", |b| b.iter(|| black_box(x).sqrt()));\n}",
    "display_name": "bench_field_element_sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/FromEncodedPoint/from_encoded_point",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "projective/impl/ProjectivePoint/From>/from"
    ],
    "body": "    fn from_encoded_point(p: &EncodedPoint<C>) -> CtOption<Self> {\n        AffinePoint::<C>::from_encoded_point(p).map(Self::from)\n    }",
    "display_name": "from_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/non_zero_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "        fn non_zero_scalar()(bytes in any::<[u8; 48]>()) -> NonZeroScalar {\n            NonZeroScalar::reduce_nonzero_bytes(&bytes.into())\n        }",
    "display_name": "non_zero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/batch_normalize_generic",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ConditionallySelectable/conditional_select",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine_internal",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero"
    ],
    "body": "fn batch_normalize_generic<P, Z, I, O>(points: &P, mut zs: Z, out: &mut O)\nwhere\n    FieldElement: BatchInvert<Z, Output = CtOption<I>>,\n    P: AsRef<[ProjectivePoint]> + ?Sized,\n    Z: AsMut<[FieldElement]>,\n    I: AsRef<[FieldElement]>,\n    O: AsMut<[AffinePoint]> + ?Sized,\n{\n    let points = points.as_ref();\n    let out = out.as_mut();\n\n    for i in 0..points.len() {\n        // Even a single zero value will fail inversion for the entire batch.\n        // Put a dummy value (above `FieldElement::ONE`) so inversion succeeds\n        // and treat that case specially later-on.\n        zs.as_mut()[i].conditional_assign(&points[i].z, !points[i].z.normalizes_to_zero());\n    }\n\n    // This is safe to unwrap since we assured that all elements are non-zero\n    let zs_inverses = <FieldElement as BatchInvert<Z>>::batch_invert(zs)\n        .expect(\"all elements should be non-zero\");\n\n    for i in 0..out.len() {\n        // If the `z` coordinate is non-zero, we can use it to invert;\n        // otherwise it defaults to the `IDENTITY` value.\n        out[i] = AffinePoint::conditional_select(\n            &points[i].to_affine_internal(zs_inverses.as_ref()[i]),\n            &AffinePoint::IDENTITY,\n            points[i].z.normalizes_to_zero(),\n        );\n    }\n}",
    "display_name": "batch_normalize_generic",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/map_to_curve_elligator2",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/invert",
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select",
      "0.14.0_pre.1 field/element/impl/FieldElement/is_square",
      "0.14.0_pre.1 field/element/impl/FieldElement/sqrt",
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative",
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub(crate) fn map_to_curve_elligator2(&self) -> AffinePoint {\n        let mut t1 = self.square(); // 1.   t1 = u^2\n        t1 *= Self::Z; // 2.   t1 = Z * t1              // Z * u^2\n        let e1 = t1.ct_eq(&Self::MINUS_ONE); // 3.   e1 = t1 == -1            // exceptional case: Z * u^2 == -1\n        t1.conditional_assign(&Self::ZERO, e1); // 4.   t1 = CMOV(t1, 0, e1)     // if t1 == -1, set t1 = 0\n        let mut x1 = t1 + Self::ONE; // 5.   x1 = t1 + 1\n        x1 = x1.invert(); // 6.   x1 = inv0(x1)\n        x1 *= -Self::J; // 7.   x1 = -A * x1             // x1 = -A / (1 + Z * u^2)\n        let mut gx1 = x1 + Self::J; // 8.  gx1 = x1 + A\n        gx1 *= x1; // 9.  gx1 = gx1 * x1\n        gx1 += Self::ONE; // 10. gx1 = gx1 + B\n        gx1 *= x1; // 11. gx1 = gx1 * x1            // gx1 = x1^3 + A * x1^2 + B * x1\n        let x2 = -x1 - Self::J; // 12.  x2 = -x1 - A\n        let gx2 = t1 * gx1; // 13. gx2 = t1 * gx1\n        let e2 = gx1.is_square(); // 14.  e2 = is_square(gx1)\n        let x = Self::conditional_select(&x2, &x1, e2); // 15.   x = CMOV(x2, x1, e2)    // If is_square(gx1), x = x1, else x = x2\n        let y2 = Self::conditional_select(&gx2, &gx1, e2); // 16.  y2 = CMOV(gx2, gx1, e2)  // If is_square(gx1), y2 = gx1, else y2 = gx2\n        let mut y = y2.sqrt(); // 17.   y = sqrt(y2)\n        let e3 = y.is_negative(); // 18.  e3 = sgn0(y) == 1\n        y.conditional_negate(e2 ^ e3); //       y = CMOV(-y, y, e2 xor e3)\n        AffinePoint { x, y }\n    }",
    "display_name": "map_to_curve_elligator2",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/torque",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn torque(&self) -> ExtendedPoint {\n        ExtendedPoint {\n            X: -self.X,\n            Y: -self.Y,\n            Z: self.Z,\n            T: self.T,\n        }\n    }",
    "display_name": "torque",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/from_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/new"
    ],
    "body": "    pub fn from_affine(affine: AffinePoint) -> Result<Self> {\n        let public_key = PublicKey::from_affine(affine).map_err(|_| Error)?;\n        Ok(Self::new(public_key))\n    }",
    "display_name": "from_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.secret_scalar.ct_eq(&other.secret_scalar)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "primefield::field_op!(Scalar, Mul, mul, multiply);\nelliptic_curve::scalar_impls!(NistP521, Scalar);\n\nimpl AddAssign<Scalar> for Scalar {\n    #[inline]\n    fn add_assign(&mut self, other: Scalar) {\n        *self = *self + other;\n    }\n}",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/MultipartSigner/try_multipart_sign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/signing/impl/SigningKey/PrehashSigner/sign_prehash",
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/hash_msg"
    ],
    "body": "    fn try_multipart_sign(&self, msg: &[&[u8]]) -> Result<Signature> {\n        // 1. Set 𝐻 ← ℎ(𝑋).\n        let hash = self.verifying_key.hash_msg(msg);\n        self.sign_prehash(&hash)\n    }",
    "display_name": "try_multipart_sign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/add"
    ],
    "body": "    pub fn double(&self) -> Self {\n        self.add(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p192_add(\n    out1: &mut fiat_p192_montgomery_domain_field_element,\n    arg1: &fiat_p192_montgomery_domain_field_element,\n    arg2: &fiat_p192_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x7, &mut x8, 0x0, x1, 0xffffffffffffffff);\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x9, &mut x10, x8, x3, 0xfffffffffffffffe);\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x11, &mut x12, x10, x5, 0xffffffffffffffff);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x13, &mut x14, x12, (x6 as u64), (0x0 as u64));\n    let mut x15: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x15, x14, x7, x1);\n    let mut x16: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x16, x14, x9, x3);\n    let mut x17: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x17, x14, x11, x5);\n    out1[0] = x15;\n    out1[1] = x16;\n    out1[2] = x17;\n}",
    "display_name": "fiat_p192_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/DecompactPoint/decompact"
    ],
    "body": "    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {\n        let field_bytes = FieldBytes::try_from(bytes).map_err(|_| Error::new())?;\n        let maybe_affine_point = AffinePoint::decompact(&field_bytes);\n        let affine_point = Option::from(maybe_affine_point).ok_or_else(Error::new)?;\n        PublicKey::from_affine(affine_point)\n            .map_err(|_| Error::new())?\n            .try_into()\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 test_scalar_y"
    ],
    "body": "fn bench_scalar_mul<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"mul\", |b| b.iter(|| x * y));\n}",
    "display_name": "bench_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/&FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/mul"
    ],
    "body": "    fn mul(self, other: &FieldElement) -> FieldElement {\n        FieldElement(self.0.mul(&(other.0)))\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [],
    "body": "    fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        let mut acc = Scalar::ONE;\n        for s in iter {\n            acc *= s;\n        }\n        acc\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/elliptic_curve::PublicKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/AffinePoint/From/from"
    ],
    "body": "    fn try_from(point: &ProjectivePoint) -> Result<PublicKey> {\n        AffinePoint::from(point).try_into()\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/endomorphism",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn endomorphism(&self) -> Self {\n        Self {\n            x: self.x * &ENDOMORPHISM_BETA,\n            y: self.y,\n            z: self.z,\n        }\n    }",
    "display_name": "endomorphism",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint_unchecked"
    ],
    "body": "    pub fn from_uint(uint: U576) -> CtOption<Self> {\n        let is_some = uint.ct_lt(&MODULUS);\n        CtOption::new(Self::from_uint_unchecked(uint), is_some)\n    }",
    "display_name": "from_uint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sub"
    ],
    "body": "    fn sub(self, rhs: &FieldElement) -> FieldElement {\n        Self::sub(&self, rhs)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_carry(\n    out1: &mut fiat_p521_tight_field_element,\n    arg1: &fiat_p521_loose_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let x2: u64 = ((x1 >> 58) + (arg1[1]));\n    let x3: u64 = ((x2 >> 58) + (arg1[2]));\n    let x4: u64 = ((x3 >> 58) + (arg1[3]));\n    let x5: u64 = ((x4 >> 58) + (arg1[4]));\n    let x6: u64 = ((x5 >> 58) + (arg1[5]));\n    let x7: u64 = ((x6 >> 58) + (arg1[6]));\n    let x8: u64 = ((x7 >> 58) + (arg1[7]));\n    let x9: u64 = ((x8 >> 58) + (arg1[8]));\n    let x10: u64 = ((x1 & 0x3ffffffffffffff) + (x9 >> 57));\n    let x11: u64 = ((((x10 >> 58) as fiat_p521_u1) as u64) + (x2 & 0x3ffffffffffffff));\n    let x12: u64 = (x10 & 0x3ffffffffffffff);\n    let x13: u64 = (x11 & 0x3ffffffffffffff);\n    let x14: u64 = ((((x11 >> 58) as fiat_p521_u1) as u64) + (x3 & 0x3ffffffffffffff));\n    let x15: u64 = (x4 & 0x3ffffffffffffff);\n    let x16: u64 = (x5 & 0x3ffffffffffffff);\n    let x17: u64 = (x6 & 0x3ffffffffffffff);\n    let x18: u64 = (x7 & 0x3ffffffffffffff);\n    let x19: u64 = (x8 & 0x3ffffffffffffff);\n    let x20: u64 = (x9 & 0x1ffffffffffffff);\n    out1[0] = x12;\n    out1[1] = x13;\n    out1[2] = x14;\n    out1[3] = x15;\n    out1[4] = x16;\n    out1[5] = x17;\n    out1[6] = x18;\n    out1[7] = x19;\n    out1[8] = x20;\n}",
    "display_name": "fiat_p521_carry",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/from_wide_bytes_reduced",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint"
    ],
    "body": "    fn from_wide_bytes_reduced() {\n        let m = Scalar::modulus_as_biguint();\n\n        fn reduce<T: Reduce<U512, Bytes = WideBytes>>(slice: &[u8]) -> T {\n            let mut bytes = WideBytes::default();\n            bytes[(64 - slice.len())..].copy_from_slice(slice);\n            T::reduce_bytes(&bytes)\n        }\n\n        // Regular reduction\n\n        let s = reduce::<Scalar>(&[0xffu8; 64]).to_biguint().unwrap();\n        assert!(s < m);\n\n        let s = reduce::<Scalar>(&[0u8; 64]).to_biguint().unwrap();\n        assert!(s.is_zero());\n\n        let s = reduce::<Scalar>(&ORDER.to_be_byte_array())\n            .to_biguint()\n            .unwrap();\n        assert!(s.is_zero());\n\n        // Reduction to a non-zero scalar\n\n        let s = reduce::<NonZeroScalar>(&[0xffu8; 64]).to_biguint().unwrap();\n        assert!(s < m);\n\n        let s = reduce::<NonZeroScalar>(&[0u8; 64]).to_biguint().unwrap();\n        assert!(s < m);\n        assert!(!s.is_zero());\n\n        let s = reduce::<NonZeroScalar>(&ORDER.to_be_byte_array())\n            .to_biguint()\n            .unwrap();\n        assert!(s < m);\n        assert!(!s.is_zero());\n\n        let s = reduce::<NonZeroScalar>(&(ORDER.wrapping_sub(&U256::ONE)).to_be_byte_array())\n            .to_biguint()\n            .unwrap();\n        assert!(s < m);\n        assert!(!s.is_zero());\n    }",
    "display_name": "from_wide_bytes_reduced",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        write!(\n            f,\n            \"{{ X: {}, Y: {}, Z: {}, T: {} }}\",\n            self.0.X, self.0.Y, self.0.Z, self.0.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/DecompactPoint/decompact",
      "affine/impl/AffinePoint/DecompressPoint/decompress"
    ],
    "body": "    fn from_encoded_point(encoded_point: &EncodedPoint<C>) -> CtOption<Self> {\n        match encoded_point.coordinates() {\n            sec1::Coordinates::Identity => CtOption::new(Self::IDENTITY, 1.into()),\n            sec1::Coordinates::Compact { x } => Self::decompact(x),\n            sec1::Coordinates::Compressed { x, y_is_odd } => {\n                Self::decompress(x, Choice::from(y_is_odd as u8))\n            }\n            sec1::Coordinates::Uncompressed { x, y } => {\n                C::FieldElement::from_repr(*y).and_then(|y| {\n                    C::FieldElement::from_repr(*x).and_then(|x| {\n                        let lhs = y * &y;\n                        let rhs = x * &x * &x + &(C::EQUATION_A * &x) + &C::EQUATION_B;\n                        CtOption::new(Self { x, y, infinity: 0 }, lhs.ct_eq(&rhs))\n                    })\n                })\n            }\n        }\n    }",
    "display_name": "from_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/pow_vartime"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        // Because p ≡ 3 mod 4, sqrt can be done with only one\n        // exponentiation via the computation of self^((p + 1) // 4) (mod p).\n        let sqrt = self.pow_vartime(&[\n            0x1f96afe6498f5982,\n            0xf65723b5837ed37f,\n            0xffffffffffffffff,\n            0x3fffffffffffffff,\n        ]);\n        CtOption::new(sqrt, (sqrt * sqrt).ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre sign_and_verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/signing/impl/SigningKey/verifying_key",
      "0.14.0_pre signing_key",
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/Verifier/verify"
    ],
    "body": "    fn sign_and_verify(sk in signing_key()) {\n        let signature = sk.sign(MSG);\n        prop_assert!(sk.verifying_key().verify(MSG, &signature).is_ok());\n    }",
    "display_name": "sign_and_verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/dsa.rs",
    "relative_path": "bign256/tests/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul"
    ],
    "body": "    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Mul::mul).unwrap_or(Self::ONE)\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/from_slice",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/from_bytes"
    ],
    "body": "    pub fn from_slice(slice: &[u8]) -> Result<Self> {\n        if slice.len() == <BignP256 as elliptic_curve::Curve>::FieldBytesSize::USIZE {\n            #[allow(deprecated)]\n            Self::from_bytes(FieldBytes::from_slice(slice))\n        } else if (Self::MIN_SIZE..<BignP256 as elliptic_curve::Curve>::FieldBytesSize::USIZE)\n            .contains(&slice.len())\n        {\n            let mut bytes = Zeroizing::new(FieldBytes::default());\n            let offset = <BignP256 as elliptic_curve::Curve>::FieldBytesSize::USIZE\n                .saturating_sub(slice.len());\n            bytes[offset..].copy_from_slice(slice);\n            Self::from_bytes(&bytes)\n        } else {\n            Err(Error)\n        }\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_square"
    ],
    "body": "    pub const fn square(&self) -> Self {\n        let mut out = fiat_p521_scalar_montgomery_domain_field_element([0; 9]);\n        fiat_p521_scalar_square(&mut out, &self.0);\n        Self(out)\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 56];\n        for (i, byte) in bytes.iter_mut().enumerate() {\n            *byte = u8::conditional_select(&a.0[i], &b.0[i], choice);\n        }\n        Self(bytes)\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SigningKey\")\n            .field(\"verifying_key\", &self.secret.public_key)\n            .finish_non_exhaustive()\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_edwards(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T: self.x * self.y,\n        }\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/ToBigUint/to_biguint",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/dev/bytes_to_biguint",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "        fn to_biguint(&self) -> Option<BigUint> {\n            Some(bytes_to_biguint(self.to_bytes().as_ref()))\n        }",
    "display_name": "to_biguint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_bytes() {\n        assert_eq!(FieldElement::ZERO.to_bytes(), FieldBytes::default());\n        assert_eq!(\n            FieldElement::ONE.to_bytes(),\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 1\n            ]\n        );\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/dev/biguint_to_bytes",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "        fn from(x: &BigUint) -> Self {\n            let bytes = biguint_to_bytes(x);\n            Self::from_bytes(&bytes.into()).unwrap()\n        }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/Drop/drop",
    "statement_type": "function",
    "deps": [],
    "body": "    fn drop(&mut self) {\n        self.secret_key.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/CofactorGroup/clear_cofactor",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/Group/double"
    ],
    "body": "    fn clear_cofactor(&self) -> Self::Subgroup {\n        self.double().double()\n    }",
    "display_name": "clear_cofactor",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_mulx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p384_from_montgomery(\n    out1: &mut fiat_p384_non_montgomery_domain_field_element,\n    arg1: &fiat_p384_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_p384_mulx_u64(&mut x2, &mut x3, x1, 0x100000001);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p384_mulx_u64(&mut x4, &mut x5, x2, 0xffffffffffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p384_mulx_u64(&mut x6, &mut x7, x2, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p384_mulx_u64(&mut x8, &mut x9, x2, 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_p384_mulx_u64(&mut x10, &mut x11, x2, 0xfffffffffffffffe);\n    let mut x12: u64 = 0;\n    let mut x13: u64 = 0;\n    fiat_p384_mulx_u64(&mut x12, &mut x13, x2, 0xffffffff00000000);\n    let mut x14: u64 = 0;\n    let mut x15: u64 = 0;\n    fiat_p384_mulx_u64(&mut x14, &mut x15, x2, 0xffffffff);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x16, &mut x17, 0x0, x15, x12);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x18, &mut x19, x17, x13, x10);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x20, &mut x21, x19, x11, x8);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x22, &mut x23, x21, x9, x6);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x24, &mut x25, x23, x7, x4);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x26, &mut x27, 0x0, x1, x14);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x28, &mut x29, x27, (0x0 as u64), x16);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x30, &mut x31, x29, (0x0 as u64), x18);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x32, &mut x33, x31, (0x0 as u64), x20);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x34, &mut x35, x33, (0x0 as u64), x22);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x36, &mut x37, x35, (0x0 as u64), x24);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x38, &mut x39, x37, (0x0 as u64), ((x25 as u64) + x5));\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x40, &mut x41, 0x0, x28, (arg1[1]));\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x42, &mut x43, x41, x30, (0x0 as u64));\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x44, &mut x45, x43, x32, (0x0 as u64));\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x46, &mut x47, x45, x34, (0x0 as u64));\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x48, &mut x49, x47, x36, (0x0 as u64));\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x50, &mut x51, x49, x38, (0x0 as u64));\n    let mut x52: u64 = 0;\n    let mut x53: u64 = 0;\n    fiat_p384_mulx_u64(&mut x52, &mut x53, x40, 0x100000001);\n    let mut x54: u64 = 0;\n    let mut x55: u64 = 0;\n    fiat_p384_mulx_u64(&mut x54, &mut x55, x52, 0xffffffffffffffff);\n    let mut x56: u64 = 0;\n    let mut x57: u64 = 0;\n    fiat_p384_mulx_u64(&mut x56, &mut x57, x52, 0xffffffffffffffff);\n    let mut x58: u64 = 0;\n    let mut x59: u64 = 0;\n    fiat_p384_mulx_u64(&mut x58, &mut x59, x52, 0xffffffffffffffff);\n    let mut x60: u64 = 0;\n    let mut x61: u64 = 0;\n    fiat_p384_mulx_u64(&mut x60, &mut x61, x52, 0xfffffffffffffffe);\n    let mut x62: u64 = 0;\n    let mut x63: u64 = 0;\n    fiat_p384_mulx_u64(&mut x62, &mut x63, x52, 0xffffffff00000000);\n    let mut x64: u64 = 0;\n    let mut x65: u64 = 0;\n    fiat_p384_mulx_u64(&mut x64, &mut x65, x52, 0xffffffff);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x66, &mut x67, 0x0, x65, x62);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x68, &mut x69, x67, x63, x60);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x70, &mut x71, x69, x61, x58);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x72, &mut x73, x71, x59, x56);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x74, &mut x75, x73, x57, x54);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x76, &mut x77, 0x0, x40, x64);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x78, &mut x79, x77, x42, x66);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x80, &mut x81, x79, x44, x68);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x82, &mut x83, x81, x46, x70);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x84, &mut x85, x83, x48, x72);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x86, &mut x87, x85, x50, x74);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x88,\n        &mut x89,\n        x87,\n        ((x51 as u64) + (x39 as u64)),\n        ((x75 as u64) + x55),\n    );\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x90, &mut x91, 0x0, x78, (arg1[2]));\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x92, &mut x93, x91, x80, (0x0 as u64));\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x94, &mut x95, x93, x82, (0x0 as u64));\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x96, &mut x97, x95, x84, (0x0 as u64));\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x98, &mut x99, x97, x86, (0x0 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x100, &mut x101, x99, x88, (0x0 as u64));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p384_mulx_u64(&mut x102, &mut x103, x90, 0x100000001);\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_p384_mulx_u64(&mut x104, &mut x105, x102, 0xffffffffffffffff);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p384_mulx_u64(&mut x106, &mut x107, x102, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p384_mulx_u64(&mut x108, &mut x109, x102, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p384_mulx_u64(&mut x110, &mut x111, x102, 0xfffffffffffffffe);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p384_mulx_u64(&mut x112, &mut x113, x102, 0xffffffff00000000);\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p384_mulx_u64(&mut x114, &mut x115, x102, 0xffffffff);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x116, &mut x117, 0x0, x115, x112);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x118, &mut x119, x117, x113, x110);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x120, &mut x121, x119, x111, x108);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x122, &mut x123, x121, x109, x106);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x124, &mut x125, x123, x107, x104);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x126, &mut x127, 0x0, x90, x114);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x128, &mut x129, x127, x92, x116);\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x130, &mut x131, x129, x94, x118);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x132, &mut x133, x131, x96, x120);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x134, &mut x135, x133, x98, x122);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x136, &mut x137, x135, x100, x124);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x138,\n        &mut x139,\n        x137,\n        ((x101 as u64) + (x89 as u64)),\n        ((x125 as u64) + x105),\n    );\n    let mut x140: u64 = 0;\n    let mut x141: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x140, &mut x141, 0x0, x128, (arg1[3]));\n    let mut x142: u64 = 0;\n    let mut x143: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x142, &mut x143, x141, x130, (0x0 as u64));\n    let mut x144: u64 = 0;\n    let mut x145: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x144, &mut x145, x143, x132, (0x0 as u64));\n    let mut x146: u64 = 0;\n    let mut x147: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x146, &mut x147, x145, x134, (0x0 as u64));\n    let mut x148: u64 = 0;\n    let mut x149: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x148, &mut x149, x147, x136, (0x0 as u64));\n    let mut x150: u64 = 0;\n    let mut x151: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x150, &mut x151, x149, x138, (0x0 as u64));\n    let mut x152: u64 = 0;\n    let mut x153: u64 = 0;\n    fiat_p384_mulx_u64(&mut x152, &mut x153, x140, 0x100000001);\n    let mut x154: u64 = 0;\n    let mut x155: u64 = 0;\n    fiat_p384_mulx_u64(&mut x154, &mut x155, x152, 0xffffffffffffffff);\n    let mut x156: u64 = 0;\n    let mut x157: u64 = 0;\n    fiat_p384_mulx_u64(&mut x156, &mut x157, x152, 0xffffffffffffffff);\n    let mut x158: u64 = 0;\n    let mut x159: u64 = 0;\n    fiat_p384_mulx_u64(&mut x158, &mut x159, x152, 0xffffffffffffffff);\n    let mut x160: u64 = 0;\n    let mut x161: u64 = 0;\n    fiat_p384_mulx_u64(&mut x160, &mut x161, x152, 0xfffffffffffffffe);\n    let mut x162: u64 = 0;\n    let mut x163: u64 = 0;\n    fiat_p384_mulx_u64(&mut x162, &mut x163, x152, 0xffffffff00000000);\n    let mut x164: u64 = 0;\n    let mut x165: u64 = 0;\n    fiat_p384_mulx_u64(&mut x164, &mut x165, x152, 0xffffffff);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x166, &mut x167, 0x0, x165, x162);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x168, &mut x169, x167, x163, x160);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x170, &mut x171, x169, x161, x158);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x172, &mut x173, x171, x159, x156);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x174, &mut x175, x173, x157, x154);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x176, &mut x177, 0x0, x140, x164);\n    let mut x178: u64 = 0;\n    let mut x179: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x178, &mut x179, x177, x142, x166);\n    let mut x180: u64 = 0;\n    let mut x181: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x180, &mut x181, x179, x144, x168);\n    let mut x182: u64 = 0;\n    let mut x183: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x182, &mut x183, x181, x146, x170);\n    let mut x184: u64 = 0;\n    let mut x185: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x184, &mut x185, x183, x148, x172);\n    let mut x186: u64 = 0;\n    let mut x187: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x186, &mut x187, x185, x150, x174);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x188,\n        &mut x189,\n        x187,\n        ((x151 as u64) + (x139 as u64)),\n        ((x175 as u64) + x155),\n    );\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x190, &mut x191, 0x0, x178, (arg1[4]));\n    let mut x192: u64 = 0;\n    let mut x193: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x192, &mut x193, x191, x180, (0x0 as u64));\n    let mut x194: u64 = 0;\n    let mut x195: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x194, &mut x195, x193, x182, (0x0 as u64));\n    let mut x196: u64 = 0;\n    let mut x197: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x196, &mut x197, x195, x184, (0x0 as u64));\n    let mut x198: u64 = 0;\n    let mut x199: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x198, &mut x199, x197, x186, (0x0 as u64));\n    let mut x200: u64 = 0;\n    let mut x201: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x200, &mut x201, x199, x188, (0x0 as u64));\n    let mut x202: u64 = 0;\n    let mut x203: u64 = 0;\n    fiat_p384_mulx_u64(&mut x202, &mut x203, x190, 0x100000001);\n    let mut x204: u64 = 0;\n    let mut x205: u64 = 0;\n    fiat_p384_mulx_u64(&mut x204, &mut x205, x202, 0xffffffffffffffff);\n    let mut x206: u64 = 0;\n    let mut x207: u64 = 0;\n    fiat_p384_mulx_u64(&mut x206, &mut x207, x202, 0xffffffffffffffff);\n    let mut x208: u64 = 0;\n    let mut x209: u64 = 0;\n    fiat_p384_mulx_u64(&mut x208, &mut x209, x202, 0xffffffffffffffff);\n    let mut x210: u64 = 0;\n    let mut x211: u64 = 0;\n    fiat_p384_mulx_u64(&mut x210, &mut x211, x202, 0xfffffffffffffffe);\n    let mut x212: u64 = 0;\n    let mut x213: u64 = 0;\n    fiat_p384_mulx_u64(&mut x212, &mut x213, x202, 0xffffffff00000000);\n    let mut x214: u64 = 0;\n    let mut x215: u64 = 0;\n    fiat_p384_mulx_u64(&mut x214, &mut x215, x202, 0xffffffff);\n    let mut x216: u64 = 0;\n    let mut x217: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x216, &mut x217, 0x0, x215, x212);\n    let mut x218: u64 = 0;\n    let mut x219: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x218, &mut x219, x217, x213, x210);\n    let mut x220: u64 = 0;\n    let mut x221: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x220, &mut x221, x219, x211, x208);\n    let mut x222: u64 = 0;\n    let mut x223: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x222, &mut x223, x221, x209, x206);\n    let mut x224: u64 = 0;\n    let mut x225: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x224, &mut x225, x223, x207, x204);\n    let mut x226: u64 = 0;\n    let mut x227: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x226, &mut x227, 0x0, x190, x214);\n    let mut x228: u64 = 0;\n    let mut x229: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x228, &mut x229, x227, x192, x216);\n    let mut x230: u64 = 0;\n    let mut x231: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x230, &mut x231, x229, x194, x218);\n    let mut x232: u64 = 0;\n    let mut x233: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x232, &mut x233, x231, x196, x220);\n    let mut x234: u64 = 0;\n    let mut x235: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x234, &mut x235, x233, x198, x222);\n    let mut x236: u64 = 0;\n    let mut x237: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x236, &mut x237, x235, x200, x224);\n    let mut x238: u64 = 0;\n    let mut x239: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x238,\n        &mut x239,\n        x237,\n        ((x201 as u64) + (x189 as u64)),\n        ((x225 as u64) + x205),\n    );\n    let mut x240: u64 = 0;\n    let mut x241: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x240, &mut x241, 0x0, x228, (arg1[5]));\n    let mut x242: u64 = 0;\n    let mut x243: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x242, &mut x243, x241, x230, (0x0 as u64));\n    let mut x244: u64 = 0;\n    let mut x245: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x244, &mut x245, x243, x232, (0x0 as u64));\n    let mut x246: u64 = 0;\n    let mut x247: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x246, &mut x247, x245, x234, (0x0 as u64));\n    let mut x248: u64 = 0;\n    let mut x249: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x248, &mut x249, x247, x236, (0x0 as u64));\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x250, &mut x251, x249, x238, (0x0 as u64));\n    let mut x252: u64 = 0;\n    let mut x253: u64 = 0;\n    fiat_p384_mulx_u64(&mut x252, &mut x253, x240, 0x100000001);\n    let mut x254: u64 = 0;\n    let mut x255: u64 = 0;\n    fiat_p384_mulx_u64(&mut x254, &mut x255, x252, 0xffffffffffffffff);\n    let mut x256: u64 = 0;\n    let mut x257: u64 = 0;\n    fiat_p384_mulx_u64(&mut x256, &mut x257, x252, 0xffffffffffffffff);\n    let mut x258: u64 = 0;\n    let mut x259: u64 = 0;\n    fiat_p384_mulx_u64(&mut x258, &mut x259, x252, 0xffffffffffffffff);\n    let mut x260: u64 = 0;\n    let mut x261: u64 = 0;\n    fiat_p384_mulx_u64(&mut x260, &mut x261, x252, 0xfffffffffffffffe);\n    let mut x262: u64 = 0;\n    let mut x263: u64 = 0;\n    fiat_p384_mulx_u64(&mut x262, &mut x263, x252, 0xffffffff00000000);\n    let mut x264: u64 = 0;\n    let mut x265: u64 = 0;\n    fiat_p384_mulx_u64(&mut x264, &mut x265, x252, 0xffffffff);\n    let mut x266: u64 = 0;\n    let mut x267: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x266, &mut x267, 0x0, x265, x262);\n    let mut x268: u64 = 0;\n    let mut x269: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x268, &mut x269, x267, x263, x260);\n    let mut x270: u64 = 0;\n    let mut x271: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x270, &mut x271, x269, x261, x258);\n    let mut x272: u64 = 0;\n    let mut x273: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x272, &mut x273, x271, x259, x256);\n    let mut x274: u64 = 0;\n    let mut x275: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x274, &mut x275, x273, x257, x254);\n    let mut x276: u64 = 0;\n    let mut x277: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x276, &mut x277, 0x0, x240, x264);\n    let mut x278: u64 = 0;\n    let mut x279: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x278, &mut x279, x277, x242, x266);\n    let mut x280: u64 = 0;\n    let mut x281: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x280, &mut x281, x279, x244, x268);\n    let mut x282: u64 = 0;\n    let mut x283: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x282, &mut x283, x281, x246, x270);\n    let mut x284: u64 = 0;\n    let mut x285: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x284, &mut x285, x283, x248, x272);\n    let mut x286: u64 = 0;\n    let mut x287: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x286, &mut x287, x285, x250, x274);\n    let mut x288: u64 = 0;\n    let mut x289: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x288,\n        &mut x289,\n        x287,\n        ((x251 as u64) + (x239 as u64)),\n        ((x275 as u64) + x255),\n    );\n    let mut x290: u64 = 0;\n    let mut x291: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x290, &mut x291, 0x0, x278, 0xffffffff);\n    let mut x292: u64 = 0;\n    let mut x293: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x292, &mut x293, x291, x280, 0xffffffff00000000);\n    let mut x294: u64 = 0;\n    let mut x295: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x294, &mut x295, x293, x282, 0xfffffffffffffffe);\n    let mut x296: u64 = 0;\n    let mut x297: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x296, &mut x297, x295, x284, 0xffffffffffffffff);\n    let mut x298: u64 = 0;\n    let mut x299: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x298, &mut x299, x297, x286, 0xffffffffffffffff);\n    let mut x300: u64 = 0;\n    let mut x301: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x300, &mut x301, x299, x288, 0xffffffffffffffff);\n    let mut x302: u64 = 0;\n    let mut x303: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x302, &mut x303, x301, (x289 as u64), (0x0 as u64));\n    let mut x304: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x304, x303, x290, x278);\n    let mut x305: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x305, x303, x292, x280);\n    let mut x306: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x306, x303, x294, x282);\n    let mut x307: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x307, x303, x296, x284);\n    let mut x308: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x308, x303, x298, x286);\n    let mut x309: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x309, x303, x300, x288);\n    out1[0] = x304;\n    out1[1] = x305;\n    out1[2] = x306;\n    out1[3] = x307;\n    out1[4] = x308;\n    out1[5] = x309;\n}",
    "display_name": "fiat_p384_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {\n        let bytes =\n            <PointBytes>::try_from(value).map_err(|_| \"Invalid length, expected 57 bytes\")?;\n        Self::try_from(bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt_der_digest"
    ],
    "body": "    pub fn encrypt_der<R: TryCryptoRng + ?Sized>(\n        &self,\n        rng: &mut R,\n        msg: &[u8],\n    ) -> Result<Vec<u8>> {\n        self.encrypt_der_digest::<R, Sm3>(rng, msg)\n    }",
    "display_name": "encrypt_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decode_field_bytes(field_bytes: &Ed448FieldBytes) -> Self {\n        U448::from_le_slice(field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/lib.rs",
    "relative_path": "ed448-goldilocks/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/field/impl/FieldElement/pow_vartime"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        // Because p ≡ 3 mod 4, sqrt can be done with only one\n        // exponentiation via the computation of self^((p + 1) // 4) (mod p).\n        let sqrt = self.pow_vartime(&[\n            0xffffffffffffffd1,\n            0xffffffffffffffff,\n            0xffffffffffffffff,\n            0x3fffffffffffffff,\n        ]);\n        CtOption::new(sqrt, (sqrt * sqrt).ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn sqrt(&self) -> FieldElement {\n        const SQRT_EXP: U448 = U448::from_be_hex(\n            \"3fffffffffffffffffffffffffffffffffffffffffffffffffffffffc0000000000000000000000000000000000000000000000000000000\",\n        );\n        Self(self.0.pow(&SQRT_EXP))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &AffinePoint) {\n        *self -= rhs.to_edwards();\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/primeorder::array::Array::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn from(scalar: Scalar) -> Self {\n        scalar.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/barrett_reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/q1_times_mu_shift_five",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/subtract_n_if_necessary",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/q3_times_n_keep_five",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/sub_inner_five"
    ],
    "body": "pub(super) const fn barrett_reduce(lo: U256, hi: U256) -> U256 {\n    let lo = lo.as_limbs();\n    let hi = hi.as_limbs();\n    let a0 = lo[0];\n    let a1 = lo[1];\n    let a2 = lo[2];\n    let a3 = lo[3];\n    let a4 = hi[0];\n    let a5 = hi[1];\n    let a6 = hi[2];\n    let a7 = hi[3];\n    let q1 = [a3, a4, a5, a6, a7];\n    let q3 = q1_times_mu_shift_five(&q1);\n\n    let r1 = [a0, a1, a2, a3, a4];\n    let r2 = q3_times_n_keep_five(&q3);\n    let r = sub_inner_five(r1, r2);\n\n    // Result is in range (0, 3*n - 1),\n    // and 90% of the time, no subtraction will be needed.\n    let r = subtract_n_if_necessary(r);\n    U256::new([r[0], r[1], r[2], r[3]])\n}",
    "display_name": "barrett_reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar/scalar64.rs",
    "relative_path": "p256/src/arithmetic/scalar/scalar64.rs",
    "file_name": "scalar64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/square",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/from_slice"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Signature> {\n        Signature::from_slice(bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/Group/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/from_uniform_bytes"
    ],
    "body": "    fn try_from_rng<R>(rng: &mut R) -> Result<Self, R::Error>\n    where\n        R: TryRngCore + ?Sized,\n    {\n        let mut uniform_bytes = [0u8; 112];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n        Ok(Self::from_uniform_bytes(&uniform_bytes))\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(p: NonIdentity<EdwardsPoint>) -> Self {\n        p.to_point()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Curve/to_affine",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn to_affine(&self) -> AffinePoint<C> {\n        ProjectivePoint::to_affine(self)\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> Scalar {\n        Scalar::ZERO - self\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/LowerHex/fmt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032"
    ],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {\n        let tmp = self.to_bytes_rfc_8032();\n        for &b in tmp.iter() {\n            write!(f, \"{:02x}\", b)?;\n        }\n        Ok(())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_add(\n    out1: &mut fiat_bign256_scalar_montgomery_domain_field_element,\n    arg1: &fiat_bign256_scalar_montgomery_domain_field_element,\n    arg2: &fiat_bign256_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x9, &mut x10, 0x0, x1, 0x7e5abf99263d6607);\n    let mut x11: u64 = 0;\n    let mut x12: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x11, &mut x12, x10, x3, 0xd95c8ed60dfb4dfc);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x13, &mut x14, x12, x5, 0xffffffffffffffff);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x15, &mut x16, x14, x7, 0xffffffffffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x17, &mut x18, x16, (x8 as u64), (0x0 as u64));\n    let mut x19: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x19, x18, x9, x1);\n    let mut x20: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x20, x18, x11, x3);\n    let mut x21: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x21, x18, x13, x5);\n    let mut x22: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x22, x18, x15, x7);\n    out1[0] = x19;\n    out1[1] = x20;\n    out1[2] = x21;\n    out1[3] = x22;\n}",
    "display_name": "fiat_bign256_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Add/add"
    ],
    "body": "    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Add::add).unwrap_or(Self::ZERO)\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_sub",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_carry_sub(\n    out1: &mut fiat_p521_tight_field_element,\n    arg1: &fiat_p521_tight_field_element,\n    arg2: &fiat_p521_tight_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = ((0x7fffffffffffffe + (arg1[0])) - (arg2[0]));\n    let x2: u64 = ((x1 >> 58) + ((0x7fffffffffffffe + (arg1[1])) - (arg2[1])));\n    let x3: u64 = ((x2 >> 58) + ((0x7fffffffffffffe + (arg1[2])) - (arg2[2])));\n    let x4: u64 = ((x3 >> 58) + ((0x7fffffffffffffe + (arg1[3])) - (arg2[3])));\n    let x5: u64 = ((x4 >> 58) + ((0x7fffffffffffffe + (arg1[4])) - (arg2[4])));\n    let x6: u64 = ((x5 >> 58) + ((0x7fffffffffffffe + (arg1[5])) - (arg2[5])));\n    let x7: u64 = ((x6 >> 58) + ((0x7fffffffffffffe + (arg1[6])) - (arg2[6])));\n    let x8: u64 = ((x7 >> 58) + ((0x7fffffffffffffe + (arg1[7])) - (arg2[7])));\n    let x9: u64 = ((x8 >> 58) + ((0x3fffffffffffffe + (arg1[8])) - (arg2[8])));\n    let x10: u64 = ((x1 & 0x3ffffffffffffff) + (x9 >> 57));\n    let x11: u64 = ((((x10 >> 58) as fiat_p521_u1) as u64) + (x2 & 0x3ffffffffffffff));\n    let x12: u64 = (x10 & 0x3ffffffffffffff);\n    let x13: u64 = (x11 & 0x3ffffffffffffff);\n    let x14: u64 = ((((x11 >> 58) as fiat_p521_u1) as u64) + (x3 & 0x3ffffffffffffff));\n    let x15: u64 = (x4 & 0x3ffffffffffffff);\n    let x16: u64 = (x5 & 0x3ffffffffffffff);\n    let x17: u64 = (x6 & 0x3ffffffffffffff);\n    let x18: u64 = (x7 & 0x3ffffffffffffff);\n    let x19: u64 = (x8 & 0x3ffffffffffffff);\n    let x20: u64 = (x9 & 0x1ffffffffffffff);\n    out1[0] = x12;\n    out1[1] = x13;\n    out1[2] = x14;\n    out1[3] = x15;\n    out1[4] = x16;\n    out1[5] = x17;\n    out1[6] = x18;\n    out1[7] = x19;\n    out1[8] = x20;\n}",
    "display_name": "fiat_p521_carry_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p192_scalar_u1,\n    arg1: fiat_p192_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_p192_scalar_u1 = ((x1 >> 64) as fiat_p192_scalar_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p192_scalar_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: &Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(&bytes[..])\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/Signer/try_sign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_raw"
    ],
    "body": "    fn try_sign(&self, msg: &[u8]) -> Result<Signature, Error> {\n        let sig = self.secret.sign_raw(msg)?;\n        Ok(sig.into())\n    }",
    "display_name": "try_sign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Array, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::consts::B0>, ell",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032"
    ],
    "body": "    fn from(scalar: &Scalar) -> ScalarBytes {\n        scalar.to_bytes_rfc_8032()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes(bytes: &[u8; 56]) -> Self {\n        Self(ConstMontyType::new(&U448::from_le_slice(bytes)))\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/Context/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_ctx"
    ],
    "body": "    fn verify(&self, msg: &[u8], signature: &Signature) -> Result<(), Error> {\n        self.key.verify_ctx(signature, self.value, msg)\n    }",
    "display_name": "verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_canonical"
    ],
    "body": "    fn is_high(&self) -> Choice {\n        const MODULUS_SHR1: U256 = BignP256::ORDER.shr_vartime(1);\n        self.to_canonical().ct_gt(&MODULUS_SHR1)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Shr/shr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime"
    ],
    "body": "    fn shr(self, rhs: usize) -> Self::Output {\n        self.shr_vartime(rhs as u32)\n    }",
    "display_name": "shr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_z",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_scalar_z() -> FieldBytes {\n    [\n        0xe3, 0x35, 0x80, 0xeb, 0x6e, 0xd0, 0x22, 0xae, 0xd6, 0xaf, 0x20, 0xd9, 0x22, 0x37, 0x63,\n        0x5e, 0x7c, 0x20, 0xc5, 0xf1, 0xbc, 0xd6, 0xae, 0xe8, 0x81, 0x82, 0xed, 0x71, 0x80, 0xf6,\n        0xe2, 0x67,\n    ]\n    .into()\n}",
    "display_name": "test_scalar_z",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/ecdsa.rs",
    "relative_path": "k256/benches/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/from_slice",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/from_nonzero_scalar"
    ],
    "body": "    pub fn from_slice(distid: &DistId, slice: &[u8]) -> Result<Self> {\n        let secret_scalar = NonZeroScalar::try_from(slice).map_err(|_| Error::new())?;\n        Self::from_nonzero_scalar(distid, secret_scalar)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/&Scalar/Shr/shr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/ShrAssign/shr_assign"
    ],
    "body": "    fn shr(self, rhs: usize) -> Self::Output {\n        let mut cp = *self;\n        cp.shr_assign(rhs);\n        cp\n    }",
    "display_name": "shr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/GroupEncoding/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/GroupEncoding/from_bytes"
    ],
    "body": "    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // No unchecked conversion possible for compressed points\n        Self::from_bytes(bytes)\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/from_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/new"
    ],
    "body": "    pub fn from_affine(distid: &DistId, affine: AffinePoint) -> Result<Self> {\n        let public_key = PublicKey::from_affine(affine).map_err(|_| Error::new())?;\n        Self::new(distid, public_key)\n    }",
    "display_name": "from_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&EdwardsPoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/negate",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/add"
    ],
    "body": "    fn sub(self, other: &EdwardsPoint) -> EdwardsPoint {\n        self.add(&other.negate())\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes"
    ],
    "body": "    fn scalar()(bytes in any::<[u8; 32]>()) -> Scalar {\n        <Scalar as Reduce<U256>>::reduce_bytes(&bytes.into())\n    }",
    "display_name": "scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/scalar.rs",
    "relative_path": "bign256/tests/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Double/double",
    "statement_type": "function",
    "deps": [
      "point_arithmetic/sealed/PointArithmetic/double"
    ],
    "body": "    fn double(&self) -> Self {\n        C::PointArithmetic::double(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [],
    "body": "    fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        iter.copied().product()\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/AddAssign>/add_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add_assign(&mut self, rhs: AffinePoint<C>) {\n        *self = ProjectivePoint::add_mixed(self, &rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre test_field_element_y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "fn test_field_element_y() -> FieldElement {\n    FieldElement::from_bytes(\n        &hex!(\"ce4014c68811f9a21a1fdb2c0e6113e06db7ca93b7404e78dc7ccd5ca89a4ca9\").into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_field_element_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/field.rs",
    "relative_path": "bign256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/multiply",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/montgomery_reduce"
    ],
    "body": "    pub const fn multiply(&self, rhs: &Self) -> Self {\n        let (lo, hi): (U256, U256) = self.0.widening_mul(&rhs.0);\n        Self(field_impl::montgomery_reduce(lo, hi))\n    }",
    "display_name": "multiply",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/tests/from_okm_curve448",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/FromOkm/from_okm",
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes"
    ],
    "body": "    fn from_okm_curve448() {\n        const DST: &[u8] = b\"QUUX-V01-CS02-with-curve448_XOF:SHAKE256_ELL2_RO_\";\n        const MSGS: &[(&[u8], [u8; 56], [u8; 56])] = &[\n            (b\"\", hex!(\"c704c7b3d3b36614cf3eedd0324fe6fe7d1402c50efd16cff89ff63f50938506280d3843478c08e24f7842f4e3ef45f6e3c4897f9d976148\"), hex!(\"c25427dc97fff7a5ad0a78654e2c6c27b1c1127b5b53c7950cd1fd6edd2703646b25f341e73deedfebf022d1d3cecd02b93b4d585ead3ed7\")),\n            (b\"abc\", hex!(\"2dd95593dfee26fe0d218d3d9a0a23d9e1a262fd1d0b602483d08415213e75e2db3c69b0a5bc89e71bcefc8c723d2b6a0cf263f02ad2aa70\"), hex!(\"272e4c79a1290cc6d2bc4f4f9d31bf7fbe956ca303c04518f117d77c0e9d850796fc3e1e2bcb9c75e8eaaded5e150333cae9931868047c9d\")),\n            (b\"abcdef0123456789\", hex!(\"6aab71a38391639f27e49eae8b1cb6b7172a1f478190ece293957e7cdb2391e7cc1c4261970d9c1bbf9c3915438f74fbd7eb5cd4d4d17ace\"), hex!(\"c80b8380ca47a3bcbf76caa75cef0e09f3d270d5ee8f676cde11aedf41aaca6741bd81a86232bd336ccb42efad39f06542bc06a67b65909e\")),\n            (b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\", hex!(\"cb5c27e51f9c18ee8ffdb6be230f4eb4f2c2481963b2293484f08da2241c1ff59f80978e6defe9d70e34abba2fcbe12dc3a1eb2c5d3d2e4a\"), hex!(\"c895e8afecec5466e126fa70fc4aa784b8009063afb10e3ee06a9b22318256aa8693b0c85b955cf2d6540b8ed71e729af1b8d5ca3b116cd7\")),\n            (b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", hex!(\"8cba93a007bb2c801b1769e026b1fa1640b14a34cf3029db3c7fd6392745d6fec0f7870b5071d6da4402cedbbde28ae4e50ab30e1049a238\"), hex!(\"4223746145069e4b8a981acc3404259d1a2c3ecfed5d864798a89d45f81a2c59e2d40eb1d5f0fe11478cbb2bb30246dd388cb932ad7bb330\")),\n        ];\n\n        for (msg, expected_u0, expected_u1) in MSGS {\n            let mut expander = <ExpandMsgXof<Shake256> as ExpandMsg<U32>>::expand_message(\n                &[msg],\n                &[DST],\n                (84 * 2).try_into().unwrap(),\n            )\n            .unwrap();\n            let mut data = Array::<u8, U84>::default();\n            expander.fill_bytes(&mut data);\n            let u0 = FieldElement::from_okm(&data);\n            let mut e_u0 = *expected_u0;\n            e_u0.reverse();\n            let mut e_u1 = *expected_u1;\n            e_u1.reverse();\n            assert_eq!(u0.to_bytes(), e_u0);\n            expander.fill_bytes(&mut data);\n            let u1 = FieldElement::from_okm(&data);\n            assert_eq!(u1.to_bytes(), e_u1);\n        }\n    }",
    "display_name": "from_okm_curve448",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: &Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(bytes.as_slice())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/pow2k",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    fn pow2k(&self, k: usize) -> Self {\n        let mut x = *self;\n        for _j in 0..k {\n            x = x.square();\n        }\n        x\n    }",
    "display_name": "pow2k",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_weak_normalized",
    "statement_type": "function",
    "deps": [],
    "body": "    const fn new_weak_normalized(value: &FieldElementUnsafeImpl) -> Self {\n        Self {\n            value: *value,\n            magnitude: 1,\n            normalized: false,\n        }\n    }",
    "display_name": "new_weak_normalized",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/tests/get_constants",
    "statement_type": "function",
    "deps": [],
    "body": "    fn get_constants() {\n        let m1 = -FieldElement::ONE;\n        assert_eq!(m1, FieldElement::MINUS_ONE);\n    }",
    "display_name": "get_constants",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Group/generator",
    "statement_type": "function",
    "deps": [],
    "body": "    fn generator() -> Self {\n        Self::GENERATOR\n    }",
    "display_name": "generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/PublicKey/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdh/impl/EphemeralSecret/public_key"
    ],
    "body": "    fn from(ephemeral_secret: &EphemeralSecret) -> Self {\n        ephemeral_secret.public_key()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/neg"
    ],
    "body": "    fn neg(self) -> ProjectivePoint {\n        ProjectivePoint::neg(&self)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 test_field_element_y",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_field_element_y() -> FieldElement {\n    FieldElement::from_bytes(\n        &hex!(\"37257906a8223866eda0743c519616a76a758ae58aee81c5fd35fbf3a855b7754a36d4a0672df95d6c44a81cf7620c2d\").into()\n    )\n    .unwrap()\n}",
    "display_name": "test_field_element_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/field.rs",
    "relative_path": "p384/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/as_scalar_primitive",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_scalar_primitive(&self) -> &ScalarPrimitive {\n        &self.inner\n    }",
    "display_name": "as_scalar_primitive",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(public_key: PublicKey<C>) -> AffinePoint<C> {\n        *public_key.as_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/multiply",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_mul"
    ],
    "body": "    pub const fn multiply(&self, rhs: &Self) -> FieldElement {\n        let mut out = fiat_p521_tight_field_element([0; 9]);\n        fiat_p521_carry_mul(&mut out, &self.0, &rhs.0);\n        FieldElement(out)\n    }",
    "display_name": "multiply",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/is_identity"
    ],
    "body": "    fn to_encoded_point(&self, compress: bool) -> EncodedPoint {\n        EncodedPoint::conditional_select(\n            &EncodedPoint::from_affine_coordinates(\n                &self.x.to_bytes(),\n                &self.y.to_bytes(),\n                compress,\n            ),\n            &EncodedPoint::identity(),\n            self.is_identity(),\n        )\n    }",
    "display_name": "to_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.0.ct_eq(&(other.0))\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/CofactorGroup/into_subgroup",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/CofactorGroup/clear_cofactor",
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/CofactorGroup/is_torsion_free"
    ],
    "body": "    fn into_subgroup(self) -> CtOption<Self::Subgroup> {\n        CtOption::new(self.clear_cofactor(), self.is_torsion_free())\n    }",
    "display_name": "into_subgroup",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, point: AffinePoint) -> DecafPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_bign256_scalar_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_bign256_u1,\n    arg1: fiat_bign256_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_bign256_i1 = ((x1 >> 64) as fiat_bign256_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_bign256_i2) - (x2 as fiat_bign256_i2)) as fiat_bign256_u1);\n}",
    "display_name": "fiat_bign256_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes"
    ],
    "body": "    pub fn x(&self) -> [u8; 56] {\n        self.x.to_bytes()\n    }",
    "display_name": "x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(InnerAffinePoint {\n            x: FieldElement::conditional_select(&a.0.x, &b.0.x, choice),\n            y: FieldElement::conditional_select(&a.0.y, &b.0.y, choice),\n        })\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/to_affine_internal",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(super) fn to_affine_internal(self, zinv: C::FieldElement) -> AffinePoint<C> {\n        AffinePoint {\n            x: self.x * &zinv,\n            y: self.y * &zinv,\n            infinity: 0,\n        }\n    }",
    "display_name": "to_affine_internal",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_p224_scalar_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn reduce(w: U256) -> Self {\n        let (r, underflow) = w.borrowing_sub(&BignP256::ORDER, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self::from_uint_unchecked(U256::conditional_select(&w, &r, !underflow))\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint"
    ],
    "body": "    fn try_from(w: U576) -> Result<Self> {\n        Option::from(Self::from_uint(w)).ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre test_scalar_x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_x() -> Scalar {\n    Scalar::from_repr(\n        hex!(\"519b423d715f8b581f4fa8ee59f4771a5b44c8130b4e3eacca54a56dda72b464\").into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_scalar_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/Reduce>/reduce",
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    fn reduce_bytes(bytes: &Self::Bytes) -> Self {\n        Self::from_bytes_mod_order_wide(bytes)\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/FromEncodedPoint/from_encoded_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From/from"
    ],
    "body": "    fn from_encoded_point(p: &EncodedPoint) -> CtOption<Self> {\n        AffinePoint::from_encoded_point(p).map(ProjectivePoint::from)\n    }",
    "display_name": "from_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_square<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"square\", |b| b.iter(|| x.square()));\n}",
    "display_name": "bench_field_element_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/field.rs",
    "relative_path": "p256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(self) -> FieldBytes {\n        let mut ret = FieldBytes::default();\n        ret[0] = (self.0[4] >> 40) as u8;\n        ret[1] = (self.0[4] >> 32) as u8;\n        ret[2] = (self.0[4] >> 24) as u8;\n        ret[3] = (self.0[4] >> 16) as u8;\n        ret[4] = (self.0[4] >> 8) as u8;\n        ret[5] = self.0[4] as u8;\n        ret[6] = (self.0[3] >> 44) as u8;\n        ret[7] = (self.0[3] >> 36) as u8;\n        ret[8] = (self.0[3] >> 28) as u8;\n        ret[9] = (self.0[3] >> 20) as u8;\n        ret[10] = (self.0[3] >> 12) as u8;\n        ret[11] = (self.0[3] >> 4) as u8;\n        ret[12] = ((self.0[2] >> 48) as u8 & 0xFu8) | ((self.0[3] as u8 & 0xFu8) << 4);\n        ret[13] = (self.0[2] >> 40) as u8;\n        ret[14] = (self.0[2] >> 32) as u8;\n        ret[15] = (self.0[2] >> 24) as u8;\n        ret[16] = (self.0[2] >> 16) as u8;\n        ret[17] = (self.0[2] >> 8) as u8;\n        ret[18] = self.0[2] as u8;\n        ret[19] = (self.0[1] >> 44) as u8;\n        ret[20] = (self.0[1] >> 36) as u8;\n        ret[21] = (self.0[1] >> 28) as u8;\n        ret[22] = (self.0[1] >> 20) as u8;\n        ret[23] = (self.0[1] >> 12) as u8;\n        ret[24] = (self.0[1] >> 4) as u8;\n        ret[25] = ((self.0[0] >> 48) as u8 & 0xFu8) | ((self.0[1] as u8 & 0xFu8) << 4);\n        ret[26] = (self.0[0] >> 40) as u8;\n        ret[27] = (self.0[0] >> 32) as u8;\n        ret[28] = (self.0[0] >> 24) as u8;\n        ret[29] = (self.0[0] >> 16) as u8;\n        ret[30] = (self.0[0] >> 8) as u8;\n        ret[31] = self.0[0] as u8;\n        ret\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/Hash/hash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.compressed.as_bytes().hash(state);\n    }",
    "display_name": "hash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/mul"
    ],
    "body": "    fn mul_assign(&mut self, scalar: S) {\n        *self = ProjectivePoint::mul(self, scalar.borrow());\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/TryFrom::FieldBytesSize>>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    fn try_from(point: &EncodedPoint) -> Result<AffinePoint> {\n        Option::from(AffinePoint::from_encoded_point(point)).ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/as_affine",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_affine(&self) -> &AffinePoint {\n        self.public_key.as_affine()\n    }",
    "display_name": "as_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre bench_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre bench_scalar_mul",
      "0.14.0_pre bench_scalar_invert",
      "0.14.0_pre bench_scalar_sub",
      "0.14.0_pre bench_scalar_add",
      "0.14.0_pre bench_scalar_negate"
    ],
    "body": "fn bench_scalar(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"scalar operations\");\n    bench_scalar_sub(&mut group);\n    bench_scalar_add(&mut group);\n    bench_scalar_mul(&mut group);\n    bench_scalar_negate(&mut group);\n    bench_scalar_invert(&mut group);\n    group.finish();\n}",
    "display_name": "bench_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> FieldBytes {\n        self.secret_scalar.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/LinearCombination/lincomb",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/Radix16Decomposition/Default/default",
      "0.14.0_pre.8 arithmetic/mul/lincomb",
      "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/Default/default"
    ],
    "body": "    fn lincomb(points_and_scalars: &[(ProjectivePoint, Scalar); N]) -> Self {\n        let mut tables = [(LookupTable::default(), LookupTable::default()); N];\n        let mut digits = [(\n            Radix16Decomposition::<33>::default(),\n            Radix16Decomposition::<33>::default(),\n        ); N];\n\n        lincomb(points_and_scalars, &mut tables, &mut digits)\n    }",
    "display_name": "lincomb",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn reduce_nonzero(w: U576) -> Self {\n        const ORDER_MINUS_ONE: U576 = NistP521::ORDER.wrapping_sub(&U576::ONE);\n        let (r, underflow) = w.borrowing_sub(&ORDER_MINUS_ONE, bigint::Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (bigint::Limb::BITS - 1)) as u8);\n        Self::from_uint_unchecked(\n            U576::conditional_select(&w, &r, !underflow).wrapping_add(&U576::ONE),\n        )\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/mul_inner",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_inner(&self, rhs: &Self) -> Self {\n        /*\n        `square()` is just `mul()` with equal arguments. Rust compiler is smart enough\n        to do all the necessary optimizations for this case, but it needs to have this information\n        inside a function. If a function is just *called* with the same arguments,\n        this information cannot be used, so the function must be inlined while using the same arguments.\n\n        Now `mul()` is quite long and therefore expensive to inline. So we have an inner (inlined)\n        function, that is used inside `mul()` and `square()`, and when it is used with the same\n        arguments in `square()`, compiler is able to use that fact after inlining.\n        */\n\n        let a0 = self.0[0] as u128;\n        let a1 = self.0[1] as u128;\n        let a2 = self.0[2] as u128;\n        let a3 = self.0[3] as u128;\n        let a4 = self.0[4] as u128;\n        let b0 = rhs.0[0] as u128;\n        let b1 = rhs.0[1] as u128;\n        let b2 = rhs.0[2] as u128;\n        let b3 = rhs.0[3] as u128;\n        let b4 = rhs.0[4] as u128;\n        let m = 0xFFFFFFFFFFFFFu128;\n        let r = 0x1000003D10u128;\n\n        debug_assert!(a0 >> 56 == 0);\n        debug_assert!(a1 >> 56 == 0);\n        debug_assert!(a2 >> 56 == 0);\n        debug_assert!(a3 >> 56 == 0);\n        debug_assert!(a4 >> 52 == 0);\n\n        debug_assert!(b0 >> 56 == 0);\n        debug_assert!(b1 >> 56 == 0);\n        debug_assert!(b2 >> 56 == 0);\n        debug_assert!(b3 >> 56 == 0);\n        debug_assert!(b4 >> 52 == 0);\n\n        // [... a b c] is a shorthand for ... + a<<104 + b<<52 + c<<0 mod n.\n        // for 0 <= x <= 4, px is a shorthand for sum(a[i]*b[x-i], i=0..x).\n        // for 4 <= x <= 8, px is a shorthand for sum(a[i]*b[x-i], i=(x-4)..4)\n        // Note that [x 0 0 0 0 0] = [x*r].\n\n        let mut d = a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;\n        debug_assert!(d >> 114 == 0);\n        // [d 0 0 0] = [p3 0 0 0]\n        let mut c = a4 * b4;\n        debug_assert!(c >> 112 == 0);\n        // [c 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0]\n        d += (c & m) * r;\n        c >>= 52;\n        debug_assert!(d >> 115 == 0);\n        debug_assert!(c >> 60 == 0);\n        let c64 = c as u64;\n        // [c 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0]\n        let t3 = (d & m) as u64;\n        d >>= 52;\n        debug_assert!(t3 >> 52 == 0);\n        debug_assert!(d >> 63 == 0);\n        let d64 = d as u64;\n        // [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0]\n\n        d = d64 as u128 + a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;\n        debug_assert!(d >> 115 == 0);\n        // [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0]\n        d += c64 as u128 * r;\n        debug_assert!(d >> 116 == 0);\n        // [d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0]\n        let t4 = (d & m) as u64;\n        d >>= 52;\n        debug_assert!(t4 >> 52 == 0);\n        debug_assert!(d >> 64 == 0);\n        let d64 = d as u64;\n        // [d t4 t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0]\n        let tx = t4 >> 48;\n        let t4 = t4 & ((m as u64) >> 4);\n        debug_assert!(tx >> 4 == 0);\n        debug_assert!(t4 >> 48 == 0);\n        // [d t4+(tx<<48) t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0]\n\n        c = a0 * b0;\n        debug_assert!(c >> 112 == 0);\n        // [d t4+(tx<<48) t3 0 0 c] = [p8 0 0 0 p4 p3 0 0 p0]\n        d = d64 as u128 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1;\n        debug_assert!(d >> 115 == 0);\n        // [d t4+(tx<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0]\n        let u0 = (d & m) as u64;\n        d >>= 52;\n        debug_assert!(u0 >> 52 == 0);\n        debug_assert!(d >> 63 == 0);\n        let d64 = d as u64;\n        // [d u0 t4+(tx<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0]\n        // [d 0 t4+(tx<<48)+(u0<<52) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0]\n        let u0 = (u0 << 4) | tx;\n        debug_assert!(u0 >> 56 == 0);\n        // [d 0 t4+(u0<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0]\n        c += u0 as u128 * ((r as u64) >> 4) as u128;\n        debug_assert!(c >> 115 == 0);\n        // [d 0 t4 t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0]\n        let r0 = (c & m) as u64;\n        c >>= 52;\n        debug_assert!(r0 >> 52 == 0);\n        debug_assert!(c >> 61 == 0);\n        let c64 = c as u64;\n        // [d 0 t4 t3 0 c r0] = [p8 0 0 p5 p4 p3 0 0 p0]\n\n        c = c64 as u128 + a0 * b1 + a1 * b0;\n        debug_assert!(c >> 114 == 0);\n        // [d 0 t4 t3 0 c r0] = [p8 0 0 p5 p4 p3 0 p1 p0]\n        d = d64 as u128 + a2 * b4 + a3 * b3 + a4 * b2;\n        debug_assert!(d >> 114 == 0);\n        // [d 0 t4 t3 0 c r0] = [p8 0 p6 p5 p4 p3 0 p1 p0]\n        c += (d & m) * r;\n        d >>= 52;\n        debug_assert!(c >> 115 == 0);\n        debug_assert!(d >> 62 == 0);\n        let d64 = d as u64;\n        // [d 0 0 t4 t3 0 c r0] = [p8 0 p6 p5 p4 p3 0 p1 p0]\n        let r1 = (c & m) as u64;\n        c >>= 52;\n        debug_assert!(r1 >> 52 == 0);\n        debug_assert!(c >> 63 == 0);\n        let c64 = c as u64;\n        // [d 0 0 t4 t3 c r1 r0] = [p8 0 p6 p5 p4 p3 0 p1 p0]\n\n        c = c64 as u128 + a0 * b2 + a1 * b1 + a2 * b0;\n        debug_assert!(c >> 114 == 0);\n        // [d 0 0 t4 t3 c r1 r0] = [p8 0 p6 p5 p4 p3 p2 p1 p0]\n        d = d64 as u128 + a3 * b4 + a4 * b3;\n        debug_assert!(d >> 114 == 0);\n        // [d 0 0 t4 t3 c t1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0]\n        c += (d & m) * r;\n        d >>= 52;\n        debug_assert!(c >> 115 == 0);\n        debug_assert!(d >> 62 == 0);\n        let d64 = d as u64;\n        // [d 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0]\n\n        // [d 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0]\n        let r2 = (c & m) as u64;\n        c >>= 52;\n        debug_assert!(r2 >> 52 == 0);\n        debug_assert!(c >> 63 == 0);\n        let c64 = c as u64;\n        // [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0]\n        c = c64 as u128 + (d64 as u128) * r + t3 as u128;\n        debug_assert!(c >> 100 == 0);\n        // [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0]\n        let r3 = (c & m) as u64;\n        c >>= 52;\n        debug_assert!(r3 >> 52 == 0);\n        debug_assert!(c >> 48 == 0);\n        let c64 = c as u64;\n        // [t4+c r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0]\n        c = c64 as u128 + t4 as u128;\n        debug_assert!(c >> 49 == 0);\n        // [c r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0]\n        let r4 = c as u64;\n        debug_assert!(r4 >> 49 == 0);\n        // [r4 r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0]\n\n        Self([r0, r1, r2, r3, r4])\n    }",
    "display_name": "mul_inner",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/decompress"
    ],
    "body": "    fn try_from(bytes: DecafPointBytes) -> Result<Self, Self::Error> {\n        let pt = CompressedDecaf(bytes);\n        Option::<DecafPoint>::from(pt.decompress()).ok_or(\"Invalid point encoding\")\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsGeneric/PointArithmetic/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(lhs: &ProjectivePoint<C>, rhs: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        let b3 = C::FieldElement::from(3) * C::EQUATION_B;\n\n        let t0 = lhs.x * rhs.x; // 1\n        let t1 = lhs.y * rhs.y; // 2\n        let t2 = lhs.z * rhs.z; // 3\n        let t3 = lhs.x + lhs.y; // 4\n        let t4 = rhs.x + rhs.y; // 5\n        let t3 = t3 * t4; // 6\n        let t4 = t0 + t1; // 7\n        let t3 = t3 - t4; // 8\n        let t4 = lhs.x + lhs.z; // 9\n        let t5 = rhs.x + rhs.z; // 10\n        let t4 = t4 * t5; // 11\n        let t5 = t0 + t2; // 12\n        let t4 = t4 - t5; // 13\n        let t5 = lhs.y + lhs.z; // 14\n        let x3 = rhs.y + rhs.z; // 15\n        let t5 = t5 * x3; // 16\n        let x3 = t1 + t2; // 17\n        let t5 = t5 - x3; // 18\n        let z3 = C::EQUATION_A * t4; // 19\n        let x3 = b3 * t2; // 20\n        let z3 = x3 + z3; // 21\n        let x3 = t1 - z3; // 22\n        let z3 = t1 + z3; // 23\n        let y3 = x3 * z3; // 24\n        let t1 = t0 + t0; // 25\n        let t1 = t1 + t0; // 26\n        let t2 = C::EQUATION_A * t2; // 27\n        let t4 = b3 * t4; // 28\n        let t1 = t1 + t2; // 29\n        let t2 = t0 - t2; // 30\n        let t2 = C::EQUATION_A * t2; // 31\n        let t4 = t4 + t2; // 32\n        let t0 = t1 * t4; // 33\n        let y3 = y3 + t0; // 34\n        let t0 = t5 * t4; // 35\n        let x3 = t3 * x3; // 36\n        let x3 = x3 - t0; // 37\n        let t0 = t3 * t1; // 38\n        let z3 = t5 * z3; // 39\n        let z3 = z3 + t0; // 40\n\n        ProjectivePoint {\n            x: x3,\n            y: y3,\n            z: z3,\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/TryFrom::FieldBytesSize>>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/TryFrom::FieldBytesSize>>/try_from"
    ],
    "body": "    fn try_from(point: EncodedPoint) -> Result<AffinePoint> {\n        AffinePoint::try_from(&point)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add_loose",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_add"
    ],
    "body": "    pub const fn add_loose(&self, rhs: &Self) -> LooseFieldElement {\n        let mut out = fiat_p521_loose_field_element([0; 9]);\n        fiat_p521_add(&mut out, &self.0, &rhs.0);\n        LooseFieldElement(out)\n    }",
    "display_name": "add_loose",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/derive_base_points",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/tests/hex_to_field",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_twisted",
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/double"
    ],
    "body": "    fn derive_base_points() {\n        use crate::{GOLDILOCKS_BASE_POINT, TWISTED_EDWARDS_BASE_POINT};\n\n        // This was the original basepoint which had order 2q;\n        let old_x = hex_to_field(\n            \"4F1970C66BED0DED221D15A622BF36DA9E146570470F1767EA6DE324A3D3A46412AE1AF72AB66511433B80E18B00938E2626A82BC70CC05E\",\n        );\n        let old_y = hex_to_field(\n            \"693F46716EB6BC248876203756C9C7624BEA73736CA3984087789C1E05A0C2D73AD3FF1CE67C39C4FDBD132C4ED7C8AD9808795BF230FA14\",\n        );\n        let old_bp = AffinePoint { x: old_x, y: old_y }.to_edwards();\n\n        // This is the new basepoint, that is in the ed448 paper\n        let new_x = hex_to_field(\n            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa955555555555555555555555555555555555555555555555555555555\",\n        );\n        let new_y = hex_to_field(\n            \"ae05e9634ad7048db359d6205086c2b0036ed7a035884dd7b7e36d728ad8c4b80d6565833a2a3098bbbcb2bed1cda06bdaeafbcdea9386ed\",\n        );\n        let new_bp = AffinePoint { x: new_x, y: new_y }.to_edwards();\n\n        // Doubling the old basepoint, should give us the new basepoint\n        assert_eq!(old_bp.double(), new_bp);\n\n        // XXX: Unfortunately, the test vectors in libdecaf currently use the old basepoint.\n        // We need to update this. But for now, I use the old basepoint so that I can check against libdecaf\n\n        assert_eq!(GOLDILOCKS_BASE_POINT, old_bp);\n\n        // The Twisted basepoint can be derived by using the isogeny\n        assert_eq!(old_bp.to_twisted(), TWISTED_EDWARDS_BASE_POINT)\n    }",
    "display_name": "derive_base_points",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/from_u64"
    ],
    "body": "    fn from(k: u64) -> Self {\n        Self(FieldElementImpl::from_u64(k))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/tests/verify_constants",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn verify_constants() {\n        assert_eq!(CURVE_EQUATION_B.to_bytes(), CURVE_EQUATION_B_BYTES);\n    }",
    "display_name": "verify_constants",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic.rs",
    "relative_path": "k256/src/arithmetic.rs",
    "file_name": "arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        U192::from_be_byte_array(*field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/lib.rs",
    "relative_path": "p192/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/AsRef>/as_ref",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/as_affine"
    ],
    "body": "    fn as_ref(&self) -> &AffinePoint {\n        self.as_affine()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_from_wide_bytes_reduced",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint"
    ],
    "body": "        fn fuzzy_from_wide_bytes_reduced(bytes_hi in any::<[u8; 32]>(), bytes_lo in any::<[u8; 32]>()) {\n            let m = Scalar::modulus_as_biguint();\n            let mut bytes = [0u8; 64];\n            bytes[0..32].clone_from_slice(&bytes_hi);\n            bytes[32..64].clone_from_slice(&bytes_lo);\n            let s = <Scalar as Reduce<U512>>::reduce(U512::from_be_slice(&bytes));\n            let s_bu = s.to_biguint().unwrap();\n            assert!(s_bu < m);\n        }",
    "display_name": "fuzzy_from_wide_bytes_reduced",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/from_bytes_unchecked",
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_normalized"
    ],
    "body": "    pub(crate) const fn from_bytes_unchecked(bytes: &[u8; 32]) -> Self {\n        let value = FieldElementUnsafeImpl::from_bytes_unchecked(bytes);\n        Self::new_normalized(&value)\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/PublicKeyBytes/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/to_bytes"
    ],
    "body": "    fn from(key: VerifyingKey) -> Self {\n        Self(key.compressed.to_bytes())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add(self, other: &Scalar) -> Scalar {\n        Scalar::add(self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/bits",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    pub fn bits(&self) -> [bool; 448] {\n        let mut bits = [false; 448];\n        let mut i = 0;\n        // We have 56 limbs, each 8 bits\n        // First we iterate each limb\n        for limb in self.to_bytes().iter() {\n            // Then we iterate each bit in the limb\n            for j in 0..8 {\n                bits[i] = limb & (1 << j) != 0;\n                i += 1;\n            }\n        }\n\n        // XXX :We are doing LSB first\n        bits\n    }",
    "display_name": "bits",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/to_encoded_point",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    pub fn to_encoded_point(&self) -> EncodedPoint {\n        self.point.to_encoded_point(false)\n    }",
    "display_name": "to_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/sub_inner"
    ],
    "body": "pub(super) const fn add(a: U256, b: U256) -> U256 {\n    let a = a.as_limbs();\n    let b = b.as_limbs();\n\n    // Bit 256 of p is set, so addition can result in five words.\n    let (w0, carry) = a[0].carrying_add(b[0], Limb::ZERO);\n    let (w1, carry) = a[1].carrying_add(b[1], carry);\n    let (w2, carry) = a[2].carrying_add(b[2], carry);\n    let (w3, w4) = a[3].carrying_add(b[3], carry);\n    // let (w0, carry) = carrying_add(a[0], b[0], 0);\n    // let (w1, carry) = carrying_add(a[1], b[1], carry);\n    // let (w2, carry) = carrying_add(a[2], b[2], carry);\n    // let (w3, w4) = carrying_add(a[3], b[3], carry);\n\n    // Attempt to subtract the modulus, to ensure the result is in the field\n    let modulus = MODULUS.as_limbs();\n\n    let (result, _) = sub_inner(\n        [w0, w1, w2, w3, w4],\n        [modulus[0], modulus[1], modulus[2], modulus[3], Limb::ZERO],\n    );\n    U256::new([result[0], result[1], result[2], result[3]])\n}",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field/field64.rs",
    "relative_path": "p256/src/arithmetic/field/field64.rs",
    "file_name": "field64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/precompute_gen_lookup_table",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/From/from",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/double",
      "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/Default/default"
    ],
    "body": "fn precompute_gen_lookup_table() -> [LookupTable; 33] {\n    let mut generator = ProjectivePoint::GENERATOR;\n    let mut res = [LookupTable::default(); 33];\n\n    for i in 0..33 {\n        res[i] = LookupTable::from(&generator);\n        // We are storing tables spaced by two radix steps,\n        // to decrease the size of the precomputed data.\n        for _ in 0..8 {\n            generator = generator.double();\n        }\n    }\n    res\n}",
    "display_name": "precompute_gen_lookup_table",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Add/add"
    ],
    "body": "    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Add::add).unwrap_or(Self::ZERO)\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_p224_scalar_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from"
    ],
    "body": "        fn fuzzy_sub(a in scalar(), b in scalar()) {\n            let a_bi = a.to_biguint().unwrap();\n            let b_bi = b.to_biguint().unwrap();\n\n            let m = Scalar::modulus_as_biguint();\n            let res_bi = (&m + &a_bi - &b_bi) % &m;\n            let res_ref = Scalar::from(&res_bi);\n            let res_test = a.sub(&b);\n\n            assert_eq!(res_ref, res_test);\n        }",
    "display_name": "fuzzy_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ShrAssign/shr_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_hex",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_u64",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert_unchecked"
    ],
    "body": "    fn shr_assign(&mut self, rhs: usize) {\n        *self = *self >> rhs;\n    }",
    "display_name": "shr_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/&FieldElement/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add"
    ],
    "body": "    fn add(self, rhs: &FieldElement) -> FieldElement {\n        FieldElement::add(self, rhs)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/Group/generator",
    "statement_type": "function",
    "deps": [],
    "body": "    fn generator() -> Self {\n        Self::GENERATOR\n    }",
    "display_name": "generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint"
    ],
    "body": "    fn try_from(w: U192) -> Result<Self> {\n        Option::from(Self::from_uint(w)).ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        self.invert()\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/repeated_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn repeated_mul() {\n        let mut r = FieldElement::ONE;\n        let two = r + &r;\n        for i in 0..DBL_TEST_VECTORS.len() {\n            assert_eq!(r.normalize().to_bytes(), DBL_TEST_VECTORS[i]);\n            r = r * &two;\n        }\n    }",
    "display_name": "repeated_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqn",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert_unchecked",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_hex",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_u64"
    ],
    "body": "    fn sqn(&self, n: usize) -> Self {\n        let mut x = *self;\n        for _ in 0..n {\n            x = x.square();\n        }\n        x\n    }",
    "display_name": "sqn",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/s0_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn s0_bytes(&self) -> FieldBytes {\n        self.s0.to_bytes()\n    }",
    "display_name": "s0_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Group/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub(self, other: ProjectivePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::sub(&self, &other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/multiply",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqn"
    ],
    "body": "    const fn invert_unchecked(&self) -> Self {\n        // We need to find b such that b * a ≡ 1 mod p. As we are in a prime\n        // field, we can apply Fermat's Little Theorem:\n        //\n        //    a^p         ≡ a mod p\n        //    a^(p-1)     ≡ 1 mod p\n        //    a^(p-2) * a ≡ 1 mod p\n        //\n        // Thus inversion can be implemented with a single exponentiation.\n        let t111 = self.multiply(&self.multiply(&self.square()).square());\n        let t111111 = t111.multiply(&t111.sqn(3));\n        let x15 = t111111.sqn(6).multiply(&t111111).sqn(3).multiply(&t111);\n        let x16 = x15.square().multiply(self);\n        let i53 = x16.sqn(16).multiply(&x16).sqn(15);\n        let x47 = x15.multiply(&i53);\n        x47.multiply(&i53.sqn(17).multiply(self).sqn(143).multiply(&x47).sqn(47))\n            .sqn(2)\n            .multiply(self)\n    }",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&DecafPoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/negate"
    ],
    "body": "    fn neg(self) -> DecafPoint {\n        DecafPoint(self.0.negate())\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "point_arithmetic/sealed/PointArithmetic/add_mixed",
    "statement_type": "function",
    "deps": [],
    "body": "        fn add_mixed(lhs: &ProjectivePoint<C>, rhs: &AffinePoint<C>) -> ProjectivePoint<C>;\n\n        /// Returns `point + point`\n        fn double(point: &ProjectivePoint<C>) -> ProjectivePoint<C>;\n    }\n}\n\n/// Allow crate-local visibility\npub(crate) use sealed::PointArithmetic;\n\n/// The 𝒂-coefficient of the short Weierstrass equation does not have specific\n/// properties which allow for an optimized implementation.\npub struct EquationAIsGeneric {}\n",
    "display_name": "add_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_canonical"
    ],
    "body": "    fn is_high(&self) -> Choice {\n        const MODULUS_SHR1: U576 = NistP521::ORDER.shr_vartime(1);\n        self.to_canonical().ct_gt(&MODULUS_SHR1)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/CofactorGroup/is_torsion_free",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn is_torsion_free(&self) -> Choice {\n        (self * BASEPOINT_ORDER).ct_eq(&Self::IDENTITY)\n    }",
    "display_name": "is_torsion_free",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/multiply",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/relax",
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/multiply"
    ],
    "body": "    pub const fn multiply(&self, rhs: &Self) -> Self {\n        self.relax().multiply(&rhs.relax())\n    }",
    "display_name": "multiply",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/split",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/impl/Signature/r",
      "0.14.0_pre.8 schnorr/impl/Signature/s"
    ],
    "body": "    fn split(&self) -> (&FieldElement, &NonZeroScalar) {\n        (self.r(), self.s())\n    }",
    "display_name": "split",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [],
    "body": "    fn reduce(w: U256) -> Self {\n        let (r, underflow) = w.borrowing_sub(&NistP256::ORDER, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self(U256::conditional_select(&w, &r, !underflow))\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/from_seed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress"
    ],
    "body": "    pub fn from_seed(seed: &SecretKey) -> Self {\n        let mut reader = Shake256::default().chain(seed).finalize_xof();\n        let mut bytes = WideScalarBytes::default();\n        reader.read(&mut bytes);\n        let mut scalar_bytes = ScalarBytes::default();\n        scalar_bytes.copy_from_slice(&bytes[..SECRET_KEY_LENGTH]);\n\n        // The two least significant bits of the first byte are cleared\n        // All eight most significant bits of the last byte are cleared\n        // with the highest bit of the second byte set.\n        scalar_bytes[0] &= 0xFC;\n        scalar_bytes[56] = 0;\n        scalar_bytes[55] |= 0x80;\n\n        let scalar = Scalar::from_bytes_mod_order(&scalar_bytes);\n\n        let mut hash_prefix = ScalarBytes::default();\n        hash_prefix.copy_from_slice(&bytes[SECRET_KEY_LENGTH..]);\n\n        let point = EdwardsPoint::GENERATOR * scalar;\n        let public_key = VerifyingKey {\n            compressed: point.compress(),\n            point,\n        };\n\n        Self {\n            seed: *seed,\n            scalar,\n            public_key,\n            hash_prefix,\n        }\n    }",
    "display_name": "from_seed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/expanded.rs",
    "relative_path": "ed448-goldilocks/src/sign/expanded.rs",
    "file_name": "expanded.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 curve/scalar_mul/variable_base/test/test_simple_scalar_mul_identities",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extensible",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/double",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
      "0.14.0_pre.1 curve/scalar_mul/variable_base/variable_base",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible"
    ],
    "body": "    fn test_simple_scalar_mul_identities() {\n        let x = TWISTED_EDWARDS_BASE_POINT;\n\n        // Test that 1 * P = P\n        let exp = variable_base(&x, &Scalar::from(1u8));\n        assert!(x == exp);\n        // Test that 2 * (P + P) = 4 * P\n        let x_ext = x.to_extensible();\n        let expected_two_x = x_ext.add_extensible(&x_ext).double();\n        let got = variable_base(&x, &Scalar::from(4u8));\n        assert!(expected_two_x.to_extended() == got);\n    }",
    "display_name": "test_simple_scalar_mul_identities",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/scalar_mul/variable_base.rs",
    "relative_path": "ed448-goldilocks/src/curve/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/pow_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "    pub const fn pow_vartime(&self, exp: &[u64]) -> Self {\n        let mut res = Self::ONE;\n\n        let mut i = exp.len();\n        while i > 0 {\n            i -= 1;\n\n            let mut j = 64;\n            while j > 0 {\n                j -= 1;\n                res = res.square();\n\n                if ((exp[i] >> j) & 1) == 1 {\n                    res = res.multiply(self);\n                }\n            }\n        }\n\n        res\n    }",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/AddAssign>/add_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add_assign(&mut self, rhs: &AffinePoint<C>) {\n        *self = ProjectivePoint::add_mixed(self, rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/elliptic_curve::PublicKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(affine_point: AffinePoint) -> Result<PublicKey> {\n        PublicKey::from_affine(affine_point)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/neg"
    ],
    "body": "    fn neg(self) -> ProjectivePoint<C> {\n        ProjectivePoint::neg(&self)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/from_bytes"
    ],
    "body": "    fn try_from(signature: SignatureBytes) -> Result<Signature> {\n        Signature::from_bytes(&signature)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/tests/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/impl/Signature/TryFrom/try_from"
    ],
    "body": "    fn try_from() {\n        // Pass an invalid signature (shorter than Self::BYTES / 2) and make sure\n        // it does not panic, but return Err\n        let invalid_signature = [111; 24];\n        assert!(Signature::try_from(&invalid_signature[..]).is_err());\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    fn from(mut secret_key: NonZeroScalar) -> SigningKey {\n        let odd = (ProjectivePoint::GENERATOR * *secret_key)\n            .to_affine()\n            .y\n            .normalize()\n            .is_odd();\n\n        secret_key.conditional_assign(&-secret_key, odd);\n\n        let verifying_key = VerifyingKey {\n            inner: PublicKey::from_secret_scalar(&secret_key),\n        };\n\n        SigningKey {\n            secret_key,\n            verifying_key,\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/SignatureBitStringEncoding/to_bitstring",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/to_vec"
    ],
    "body": "    fn to_bitstring(&self) -> der::Result<der::asn1::BitString> {\n        der::asn1::BitString::new(0, self.to_vec())\n    }",
    "display_name": "to_bitstring",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_x() -> Scalar {\n    Scalar::from_repr(\n        [\n            0xbb, 0x48, 0x8a, 0xef, 0x41, 0x6a, 0x41, 0xd7, 0x68, 0x0d, 0x1c, 0xf0, 0x1d, 0x70,\n            0xf5, 0x9b, 0x60, 0xd7, 0xf5, 0xf7, 0x7e, 0x30, 0xe7, 0x8b, 0x8b, 0xf9, 0xd2, 0xd8,\n            0x82, 0xf1, 0x56, 0xa6,\n        ]\n        .into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_scalar_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, rhs: &Scalar) {\n        *self = *self + rhs\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Curve/to_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine"
    ],
    "body": "    fn to_affine(&self) -> AffinePoint {\n        self.to_affine()\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/ops/impl/&DecafPoint/Neg/neg"
    ],
    "body": "    fn neg(self) -> DecafPoint {\n        (&self).neg()\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Shr/shr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime"
    ],
    "body": "    fn shr(self, rhs: usize) -> Self::Output {\n        self.shr_vartime(rhs as u32)\n    }",
    "display_name": "shr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_divstep_precomp(out1: &mut [u64; 4]) {\n    out1[0] = 0x1aa32707b351756d;\n    out1[1] = 0xabdd671e2a62fa;\n    out1[2] = 0x49280d7dd4009a81;\n    out1[3] = 0xd730336ee6bb86e8;\n}",
    "display_name": "fiat_sm2_scalar_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/new",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn new(public_key: PublicKey) -> Result<Self> {\n        Ok(Self { public_key })\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(value: &CompressedEdwardsY) -> Self {\n        value.0.to_vec()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/ProjectiveMontgomeryPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(\n        a: &ProjectiveMontgomeryPoint,\n        b: &ProjectiveMontgomeryPoint,\n        choice: Choice,\n    ) -> ProjectiveMontgomeryPoint {\n        ProjectiveMontgomeryPoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "affine/impl/AffinePoint/to_compact",
    "statement_type": "function",
    "deps": [],
    "body": "    fn to_compact(self) -> Self {\n        let neg_self = -self;\n        let choice = C::Uint::decode_field_bytes(&self.y.to_repr())\n            .ct_gt(&C::Uint::decode_field_bytes(&neg_self.y.to_repr()));\n\n        Self {\n            x: self.x,\n            y: C::FieldElement::conditional_select(&self.y, &neg_self.y, choice),\n            infinity: self.infinity,\n        }\n    }",
    "display_name": "to_compact",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce_impl"
    ],
    "body": "    pub(super) fn reduce(&self) -> Scalar {\n        self.reduce_impl(false)\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p384_add(\n    out1: &mut fiat_p384_montgomery_domain_field_element,\n    arg1: &fiat_p384_montgomery_domain_field_element,\n    arg2: &fiat_p384_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x9, &mut x10, x8, (arg1[4]), (arg2[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x11, &mut x12, x10, (arg1[5]), (arg2[5]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x13, &mut x14, 0x0, x1, 0xffffffff);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x15, &mut x16, x14, x3, 0xffffffff00000000);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x17, &mut x18, x16, x5, 0xfffffffffffffffe);\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x19, &mut x20, x18, x7, 0xffffffffffffffff);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x21, &mut x22, x20, x9, 0xffffffffffffffff);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x23, &mut x24, x22, x11, 0xffffffffffffffff);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x25, &mut x26, x24, (x12 as u64), (0x0 as u64));\n    let mut x27: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x27, x26, x13, x1);\n    let mut x28: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x28, x26, x15, x3);\n    let mut x29: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x29, x26, x17, x5);\n    let mut x30: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x30, x26, x19, x7);\n    let mut x31: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x31, x26, x21, x9);\n    let mut x32: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x32, x26, x23, x11);\n    out1[0] = x27;\n    out1[1] = x28;\n    out1[2] = x29;\n    out1[3] = x30;\n    out1[4] = x31;\n    out1[5] = x32;\n}",
    "display_name": "fiat_p384_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ExtendedPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/as_nonzero_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_nonzero_scalar(&self) -> &NonZeroScalar {\n        &self.secret_scalar\n    }",
    "display_name": "as_nonzero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/negate",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint"
    ],
    "body": "    pub fn modulus_as_biguint() -> BigUint {\n        Self::ONE.negate().to_biguint().unwrap() + 1.to_biguint().unwrap()\n    }",
    "display_name": "modulus_as_biguint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(a: u128) -> Self {\n        Scalar(U448::from_u128(a))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_opp(\n    out1: &mut fiat_p192_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p192_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x7, x6, (0x0 as u64), 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x8, &mut x9, 0x0, x1, (x7 & 0x146bc9b1b4d22831));\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x10, &mut x11, x9, x3, (x7 & 0xffffffff99def836));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x5, x7);\n    out1[0] = x8;\n    out1[1] = x10;\n    out1[2] = x12;\n}",
    "display_name": "fiat_p192_scalar_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        self.0[..].fmt(formatter)\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/from_sec1_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/new"
    ],
    "body": "    pub fn from_sec1_bytes(bytes: &[u8]) -> Result<Self> {\n        let public_key = PublicKey::from_sec1_bytes(bytes).map_err(|_| Error)?;\n        Ok(Self::new(public_key))\n    }",
    "display_name": "from_sec1_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/signing/impl/SigningKey/from_slice"
    ],
    "body": "    pub fn from_bytes(bytes: &FieldBytes) -> Result<Self> {\n        Self::from_slice(bytes)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/new",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre distid/hash_z"
    ],
    "body": "    pub fn new(distid: &DistId, public_key: PublicKey) -> Result<Self> {\n        let identity_hash = hash_z(distid, &public_key).map_err(|_| Error::new())?;\n\n        Ok(Self {\n            identity_hash,\n            public_key,\n            #[cfg(feature = \"alloc\")]\n            distid: distid.into(),\n        })\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/to_bytes",
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/normalize"
    ],
    "body": "    pub fn to_bytes(self) -> FieldBytes {\n        self.0.normalize().to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_divstep_precomp(out1: &mut [u64; 4]) {\n    out1[0] = 0x7ffffffe800001;\n    out1[1] = 0xff7fffff00800000;\n    out1[2] = 0xffffff;\n    out1[3] = 0xff800000;\n}",
    "display_name": "fiat_p224_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: AffinePoint) -> ProjectivePoint {\n        rhs * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/GroupEncoding/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        let mut value = [0u8; 57];\n        value.copy_from_slice(bytes);\n        CompressedEdwardsY(value).decompress()\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre decode_pkcs8_public_key_from_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_public_key_from_pem() {\n    let public_key = PKCS8_PUBLIC_KEY_PEM.parse::<PublicKey>().unwrap();\n\n    // Ensure key parses equivalently to DER\n    let der_key = PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    assert_eq!(public_key, der_key);\n}",
    "display_name": "decode_pkcs8_public_key_from_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/pkcs8.rs",
    "relative_path": "bign256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_twisted"
    ],
    "body": "    fn from(point: EdwardsPoint) -> Self {\n        Self(point.to_twisted())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsZero/PointArithmetic/double",
    "statement_type": "function",
    "deps": [],
    "body": "    fn double(point: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        debug_assert_eq!(\n            C::EQUATION_A,\n            C::FieldElement::ZERO,\n            \"this implementation is only valid for C::EQUATION_A = 0\"\n        );\n\n        let b3 = C::EQUATION_B * C::FieldElement::from(3);\n\n        let t0 = point.y.square(); // 1\n        let z3 = t0.double(); // 2\n        let z3 = z3.double(); // 3\n        let z3 = z3.double(); // 4\n        let t1 = point.y * point.z; // 5\n        let t2 = point.z.square(); // 6\n        let t2 = b3 * t2; // 7\n        let x3 = t2 * z3; // 8\n        let y3 = t0 + t2; // 9\n        let z3 = t1 * z3; // 10\n        let t1 = t2.double(); // 11\n        let t2 = t1 + t2; // 12\n        let t0 = t0 - t2; // 13\n        let y3 = t0 * y3; // 14\n        let y3 = x3 + y3; // 15\n        let t1 = point.x * point.y; // 16\n        let x3 = t0 * t1; // 17\n        let x3 = x3.double(); // 18\n\n        ProjectivePoint {\n            x: x3,\n            y: y3,\n            z: z3,\n        }\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafAffinePoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/Curve/to_affine",
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &DecafPoint) {\n        *self = (DecafPoint(self.0.to_extended()) - rhs).to_affine();\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes_mod_order(input: &ScalarBytes) -> Scalar {\n        let value = U448::from_le_slice(&input[..56]);\n        Self(value.rem_vartime(&NZ_ORDER))\n    }",
    "display_name": "from_bytes_mod_order",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    fn square(&self) -> Self {\n        self.square()\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(\n        a: &FieldElement5x52,\n        b: &FieldElement5x52,\n        choice: Choice,\n    ) -> FieldElement5x52 {\n        FieldElement5x52([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.value.zeroize();\n        self.magnitude.zeroize();\n        self.normalized.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended"
    ],
    "body": "    fn from(point: DecafAffinePoint) -> Self {\n        Self(point.0.to_extended())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/TryFrom>/try_from"
    ],
    "body": "    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(&value)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre decode_pkcs8_private_key_from_der",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_private_key_from_der() {\n    let secret_key = sm2::SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let expected_scalar = hex!(\"4BB8DF505722299592CBED4283B354A13FF5D3FEEB3A0660C5BDF3C87C559499\");\n    assert_eq!(secret_key.to_bytes().as_slice(), &expected_scalar[..]);\n\n    #[cfg(feature = \"arithmetic\")]\n    assert_eq!(\n        secret_key.public_key().to_encoded_point(false).as_bytes(),\n        &SEC1_PUBLIC_KEY[..]\n    );\n}",
    "display_name": "decode_pkcs8_private_key_from_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/new"
    ],
    "body": "    fn from(value: PublicKey) -> Self {\n        Self::new(value)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/from_bytes"
    ],
    "body": "    fn try_from(signature: &SignatureBytes) -> Result<Signature> {\n        Signature::from_bytes(signature)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre decrypt_verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/new",
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt"
    ],
    "body": "fn decrypt_verify() {\n    assert_eq!(\n        DecryptingKey::new(\n            NonZeroScalar::<Sm2>::try_from(PRIVATE_KEY.as_ref() as &[u8])\n                .unwrap()\n                .into()\n        )\n        .decrypt(&CIPHER)\n        .unwrap(),\n        MSG\n    );\n}",
    "display_name": "decrypt_verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2pke.rs",
    "relative_path": "sm2/tests/sm2pke.rs",
    "file_name": "sm2pke.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/RandomizedSigner/try_sign_with_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/RandomizedMultipartSigner/try_multipart_sign_with_rng"
    ],
    "body": "    fn try_sign_with_rng<R: TryCryptoRng + ?Sized>(\n        &self,\n        rng: &mut R,\n        msg: &[u8],\n    ) -> Result<Signature> {\n        self.try_multipart_sign_with_rng(rng, &[msg])\n    }",
    "display_name": "try_sign_with_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/add"
    ],
    "body": "    fn add(self, other: &FieldElement) -> FieldElement {\n        FieldElement(self.0.add(&(other.0)))\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Invert/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/invert",
      "0.14.0_pre.1 field/scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        CtOption::new(self.invert(), !self.ct_eq(&Self::ZERO))\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre decrypting_key",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/from_nonzero_scalar",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes"
    ],
    "body": "    fn decrypting_key()(bytes in any::<[u8; 32]>()) -> DecryptingKey {\n        loop {\n            let scalar = <Scalar as Reduce<U256>>::reduce_bytes(&bytes.into());\n            if let Some(scalar) = Option::from(NonZeroScalar::new(scalar)) {\n                return DecryptingKey::from_nonzero_scalar(scalar).unwrap();\n            }\n        }\n    }",
    "display_name": "decrypting_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2pke.rs",
    "relative_path": "sm2/tests/sm2pke.rs",
    "file_name": "sm2pke.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/AffinePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine"
    ],
    "body": "    fn from(value: EdwardsPoint) -> Self {\n        value.to_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/TryFrom, OctetStringRef, der::asn1::BitStringRef>>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/from_slice"
    ],
    "body": "    fn try_from(private_key_info: pkcs8::PrivateKeyInfoRef<'_>) -> pkcs8::Result<Self> {\n        private_key_info\n            .algorithm\n            .assert_oids(ALGORITHM_OID, BignP256::OID)?;\n        Self::from_slice(private_key_info.private_key.as_bytes())\n            .map_err(|_| pkcs8::Error::KeyMalformed)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &DecafPoint) -> Choice {\n        (self.0.X * other.0.Y).ct_eq(&(self.0.Y * other.0.X))\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_add(\n    out1: &mut fiat_p521_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p521_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p521_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x9, &mut x10, x8, (arg1[4]), (arg2[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x11, &mut x12, x10, (arg1[5]), (arg2[5]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x13, &mut x14, x12, (arg1[6]), (arg2[6]));\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x15, &mut x16, x14, (arg1[7]), (arg2[7]));\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x17, &mut x18, x16, (arg1[8]), (arg2[8]));\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x19, &mut x20, 0x0, x1, 0xbb6fb71e91386409);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x21, &mut x22, x20, x3, 0x3bb5c9b8899c47ae);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x23, &mut x24, x22, x5, 0x7fcc0148f709a5d0);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x25, &mut x26, x24, x7, 0x51868783bf2f966b);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x27, &mut x28, x26, x9, 0xfffffffffffffffa);\n    let mut x29: u64 = 0;\n    let mut x30: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x29, &mut x30, x28, x11, 0xffffffffffffffff);\n    let mut x31: u64 = 0;\n    let mut x32: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x31, &mut x32, x30, x13, 0xffffffffffffffff);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x33, &mut x34, x32, x15, 0xffffffffffffffff);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x35, &mut x36, x34, x17, 0x1ff);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x37, &mut x38, x36, (x18 as u64), (0x0 as u64));\n    let mut x39: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x39, x38, x19, x1);\n    let mut x40: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x40, x38, x21, x3);\n    let mut x41: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x41, x38, x23, x5);\n    let mut x42: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x42, x38, x25, x7);\n    let mut x43: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x43, x38, x27, x9);\n    let mut x44: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x44, x38, x29, x11);\n    let mut x45: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x45, x38, x31, x13);\n    let mut x46: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x46, x38, x33, x15);\n    let mut x47: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x47, x38, x35, x17);\n    out1[0] = x39;\n    out1[1] = x40;\n    out1[2] = x41;\n    out1[3] = x42;\n    out1[4] = x43;\n    out1[5] = x44;\n    out1[6] = x45;\n    out1[7] = x46;\n    out1[8] = x47;\n}",
    "display_name": "fiat_p521_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 noncompatible_is_none",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToCompactEncodedPoint/to_compact_encoded_point"
    ],
    "body": "fn noncompatible_is_none() {\n    use elliptic_curve::array::Array;\n    let noncompactable_secret = Array::from([\n        175, 232, 180, 255, 91, 106, 124, 191, 224, 31, 177, 208, 236, 127, 191, 169, 201, 217, 75,\n        141, 184, 175, 120, 85, 171, 8, 54, 57, 33, 177, 83, 211,\n    ]);\n    let public_key = p256::SecretKey::from_bytes(&noncompactable_secret)\n        .unwrap()\n        .public_key();\n    let is_compactable = public_key\n        .as_affine()\n        .to_compact_encoded_point()\n        .is_some()\n        .unwrap_u8();\n    assert_eq!(is_compactable, 0);\n}",
    "display_name": "noncompatible_is_none",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/mul"
    ],
    "body": "    pub fn square(&self) -> Self {\n        self.mul(self)\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/from_nonzero_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/from_secret_scalar",
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/new"
    ],
    "body": "    pub fn from_nonzero_scalar(secret_scalar: NonZeroScalar) -> Result<Self> {\n        let public_key = PublicKey::from_secret_scalar(&secret_scalar);\n        let verifying_key = VerifyingKey::new(public_key)?;\n        Ok(Self {\n            secret_scalar,\n            verifying_key,\n        })\n    }",
    "display_name": "from_nonzero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: PublicKeyBytes) -> Result<Self, Self::Error> {\n        VerifyingKey::try_from(&value)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_set_one(out1: &mut fiat_p384_scalar_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0x1313e695333ad68d;\n    out1[1] = 0xa7e5f24db74f5885;\n    out1[2] = 0x389cb27e0bc8d220;\n    out1[3] = (0x0 as u64);\n    out1[4] = (0x0 as u64);\n    out1[5] = (0x0 as u64);\n}",
    "display_name": "fiat_p384_scalar_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "affine/impl/AffinePoint/PrimeCurveAffine/to_curve",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/From>/from"
    ],
    "body": "    fn to_curve(&self) -> ProjectivePoint<C> {\n        ProjectivePoint::from(*self)\n    }",
    "display_name": "to_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 uncompressed_to_compressed",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "fn uncompressed_to_compressed() {\n    let encoded = EncodedPoint::from_bytes(UNCOMPRESSED_BASEPOINT).unwrap();\n\n    let res = AffinePoint::from_encoded_point(&encoded)\n        .unwrap()\n        .to_encoded_point(true);\n\n    assert_eq!(res.as_bytes(), COMPRESSED_BASEPOINT);\n}",
    "display_name": "uncompressed_to_compressed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/is_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub fn is_identity(&self) -> Choice {\n        self.ct_eq(&DecafPoint::IDENTITY)\n    }",
    "display_name": "is_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Group/double",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/Double/double"
    ],
    "body": "    fn double(&self) -> Self {\n        Double::double(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/Context/DigestSigner/try_sign_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_prehashed"
    ],
    "body": "    fn try_sign_digest(&self, digest: D) -> Result<Signature, Error> {\n        let mut prehashed_message = [0u8; 64];\n        prehashed_message.copy_from_slice(digest.finalize().as_slice());\n        let sig = self\n            .key\n            .secret\n            .sign_prehashed(self.value, &prehashed_message)?;\n        Ok(sig.into())\n    }",
    "display_name": "try_sign_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/to_canonical",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/montgomery_reduce"
    ],
    "body": "pub(super) const fn to_canonical(a: U256) -> U256 {\n    montgomery_reduce(a, U256::ZERO)\n}",
    "display_name": "to_canonical",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field/field64.rs",
    "relative_path": "p256/src/arithmetic/field/field64.rs",
    "file_name": "field64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.7.0_pre t1/impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [
      "0.7.0_pre encode_field_bytes"
    ],
    "body": "    fn encode_field_bytes(&self) -> crate::r1::FieldBytes {\n        crate::encode_field_bytes(self)\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp256/src/t1.rs",
    "relative_path": "bp256/src/t1.rs",
    "file_name": "t1.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/distid",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/distid"
    ],
    "body": "    pub fn distid(&self) -> &DistId {\n        self.verifying_key.distid()\n    }",
    "display_name": "distid",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_addcarryx_u57",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_subborrowx_u58",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_addcarryx_u58",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_subborrowx_u57"
    ],
    "body": "pub const fn fiat_p521_to_bytes(out1: &mut [u8; 66], arg1: &fiat_p521_tight_field_element) {\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u58(&mut x1, &mut x2, 0x0, (arg1[0]), 0x3ffffffffffffff);\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u58(&mut x3, &mut x4, x2, (arg1[1]), 0x3ffffffffffffff);\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u58(&mut x5, &mut x6, x4, (arg1[2]), 0x3ffffffffffffff);\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u58(&mut x7, &mut x8, x6, (arg1[3]), 0x3ffffffffffffff);\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u58(&mut x9, &mut x10, x8, (arg1[4]), 0x3ffffffffffffff);\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u58(&mut x11, &mut x12, x10, (arg1[5]), 0x3ffffffffffffff);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u58(&mut x13, &mut x14, x12, (arg1[6]), 0x3ffffffffffffff);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u58(&mut x15, &mut x16, x14, (arg1[7]), 0x3ffffffffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p521_u1 = 0;\n    fiat_p521_subborrowx_u57(&mut x17, &mut x18, x16, (arg1[8]), 0x1ffffffffffffff);\n    let mut x19: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x19, x18, (0x0 as u64), 0xffffffffffffffff);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u58(&mut x20, &mut x21, 0x0, x1, (x19 & 0x3ffffffffffffff));\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u58(&mut x22, &mut x23, x21, x3, (x19 & 0x3ffffffffffffff));\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u58(&mut x24, &mut x25, x23, x5, (x19 & 0x3ffffffffffffff));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u58(&mut x26, &mut x27, x25, x7, (x19 & 0x3ffffffffffffff));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u58(&mut x28, &mut x29, x27, x9, (x19 & 0x3ffffffffffffff));\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u58(&mut x30, &mut x31, x29, x11, (x19 & 0x3ffffffffffffff));\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u58(&mut x32, &mut x33, x31, x13, (x19 & 0x3ffffffffffffff));\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u58(&mut x34, &mut x35, x33, x15, (x19 & 0x3ffffffffffffff));\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p521_u1 = 0;\n    fiat_p521_addcarryx_u57(&mut x36, &mut x37, x35, x17, (x19 & 0x1ffffffffffffff));\n    let x38: u64 = (x34 << 6);\n    let x39: u64 = (x32 << 4);\n    let x40: u64 = (x30 << 2);\n    let x41: u64 = (x26 << 6);\n    let x42: u64 = (x24 << 4);\n    let x43: u64 = (x22 << 2);\n    let x44: u8 = ((x20 & (0xff as u64)) as u8);\n    let x45: u64 = (x20 >> 8);\n    let x46: u8 = ((x45 & (0xff as u64)) as u8);\n    let x47: u64 = (x45 >> 8);\n    let x48: u8 = ((x47 & (0xff as u64)) as u8);\n    let x49: u64 = (x47 >> 8);\n    let x50: u8 = ((x49 & (0xff as u64)) as u8);\n    let x51: u64 = (x49 >> 8);\n    let x52: u8 = ((x51 & (0xff as u64)) as u8);\n    let x53: u64 = (x51 >> 8);\n    let x54: u8 = ((x53 & (0xff as u64)) as u8);\n    let x55: u64 = (x53 >> 8);\n    let x56: u8 = ((x55 & (0xff as u64)) as u8);\n    let x57: u8 = ((x55 >> 8) as u8);\n    let x58: u64 = (x43 + (x57 as u64));\n    let x59: u8 = ((x58 & (0xff as u64)) as u8);\n    let x60: u64 = (x58 >> 8);\n    let x61: u8 = ((x60 & (0xff as u64)) as u8);\n    let x62: u64 = (x60 >> 8);\n    let x63: u8 = ((x62 & (0xff as u64)) as u8);\n    let x64: u64 = (x62 >> 8);\n    let x65: u8 = ((x64 & (0xff as u64)) as u8);\n    let x66: u64 = (x64 >> 8);\n    let x67: u8 = ((x66 & (0xff as u64)) as u8);\n    let x68: u64 = (x66 >> 8);\n    let x69: u8 = ((x68 & (0xff as u64)) as u8);\n    let x70: u64 = (x68 >> 8);\n    let x71: u8 = ((x70 & (0xff as u64)) as u8);\n    let x72: u8 = ((x70 >> 8) as u8);\n    let x73: u64 = (x42 + (x72 as u64));\n    let x74: u8 = ((x73 & (0xff as u64)) as u8);\n    let x75: u64 = (x73 >> 8);\n    let x76: u8 = ((x75 & (0xff as u64)) as u8);\n    let x77: u64 = (x75 >> 8);\n    let x78: u8 = ((x77 & (0xff as u64)) as u8);\n    let x79: u64 = (x77 >> 8);\n    let x80: u8 = ((x79 & (0xff as u64)) as u8);\n    let x81: u64 = (x79 >> 8);\n    let x82: u8 = ((x81 & (0xff as u64)) as u8);\n    let x83: u64 = (x81 >> 8);\n    let x84: u8 = ((x83 & (0xff as u64)) as u8);\n    let x85: u64 = (x83 >> 8);\n    let x86: u8 = ((x85 & (0xff as u64)) as u8);\n    let x87: u8 = ((x85 >> 8) as u8);\n    let x88: u64 = (x41 + (x87 as u64));\n    let x89: u8 = ((x88 & (0xff as u64)) as u8);\n    let x90: u64 = (x88 >> 8);\n    let x91: u8 = ((x90 & (0xff as u64)) as u8);\n    let x92: u64 = (x90 >> 8);\n    let x93: u8 = ((x92 & (0xff as u64)) as u8);\n    let x94: u64 = (x92 >> 8);\n    let x95: u8 = ((x94 & (0xff as u64)) as u8);\n    let x96: u64 = (x94 >> 8);\n    let x97: u8 = ((x96 & (0xff as u64)) as u8);\n    let x98: u64 = (x96 >> 8);\n    let x99: u8 = ((x98 & (0xff as u64)) as u8);\n    let x100: u64 = (x98 >> 8);\n    let x101: u8 = ((x100 & (0xff as u64)) as u8);\n    let x102: u8 = ((x100 >> 8) as u8);\n    let x103: u8 = ((x28 & (0xff as u64)) as u8);\n    let x104: u64 = (x28 >> 8);\n    let x105: u8 = ((x104 & (0xff as u64)) as u8);\n    let x106: u64 = (x104 >> 8);\n    let x107: u8 = ((x106 & (0xff as u64)) as u8);\n    let x108: u64 = (x106 >> 8);\n    let x109: u8 = ((x108 & (0xff as u64)) as u8);\n    let x110: u64 = (x108 >> 8);\n    let x111: u8 = ((x110 & (0xff as u64)) as u8);\n    let x112: u64 = (x110 >> 8);\n    let x113: u8 = ((x112 & (0xff as u64)) as u8);\n    let x114: u64 = (x112 >> 8);\n    let x115: u8 = ((x114 & (0xff as u64)) as u8);\n    let x116: u8 = ((x114 >> 8) as u8);\n    let x117: u64 = (x40 + (x116 as u64));\n    let x118: u8 = ((x117 & (0xff as u64)) as u8);\n    let x119: u64 = (x117 >> 8);\n    let x120: u8 = ((x119 & (0xff as u64)) as u8);\n    let x121: u64 = (x119 >> 8);\n    let x122: u8 = ((x121 & (0xff as u64)) as u8);\n    let x123: u64 = (x121 >> 8);\n    let x124: u8 = ((x123 & (0xff as u64)) as u8);\n    let x125: u64 = (x123 >> 8);\n    let x126: u8 = ((x125 & (0xff as u64)) as u8);\n    let x127: u64 = (x125 >> 8);\n    let x128: u8 = ((x127 & (0xff as u64)) as u8);\n    let x129: u64 = (x127 >> 8);\n    let x130: u8 = ((x129 & (0xff as u64)) as u8);\n    let x131: u8 = ((x129 >> 8) as u8);\n    let x132: u64 = (x39 + (x131 as u64));\n    let x133: u8 = ((x132 & (0xff as u64)) as u8);\n    let x134: u64 = (x132 >> 8);\n    let x135: u8 = ((x134 & (0xff as u64)) as u8);\n    let x136: u64 = (x134 >> 8);\n    let x137: u8 = ((x136 & (0xff as u64)) as u8);\n    let x138: u64 = (x136 >> 8);\n    let x139: u8 = ((x138 & (0xff as u64)) as u8);\n    let x140: u64 = (x138 >> 8);\n    let x141: u8 = ((x140 & (0xff as u64)) as u8);\n    let x142: u64 = (x140 >> 8);\n    let x143: u8 = ((x142 & (0xff as u64)) as u8);\n    let x144: u64 = (x142 >> 8);\n    let x145: u8 = ((x144 & (0xff as u64)) as u8);\n    let x146: u8 = ((x144 >> 8) as u8);\n    let x147: u64 = (x38 + (x146 as u64));\n    let x148: u8 = ((x147 & (0xff as u64)) as u8);\n    let x149: u64 = (x147 >> 8);\n    let x150: u8 = ((x149 & (0xff as u64)) as u8);\n    let x151: u64 = (x149 >> 8);\n    let x152: u8 = ((x151 & (0xff as u64)) as u8);\n    let x153: u64 = (x151 >> 8);\n    let x154: u8 = ((x153 & (0xff as u64)) as u8);\n    let x155: u64 = (x153 >> 8);\n    let x156: u8 = ((x155 & (0xff as u64)) as u8);\n    let x157: u64 = (x155 >> 8);\n    let x158: u8 = ((x157 & (0xff as u64)) as u8);\n    let x159: u64 = (x157 >> 8);\n    let x160: u8 = ((x159 & (0xff as u64)) as u8);\n    let x161: u8 = ((x159 >> 8) as u8);\n    let x162: u8 = ((x36 & (0xff as u64)) as u8);\n    let x163: u64 = (x36 >> 8);\n    let x164: u8 = ((x163 & (0xff as u64)) as u8);\n    let x165: u64 = (x163 >> 8);\n    let x166: u8 = ((x165 & (0xff as u64)) as u8);\n    let x167: u64 = (x165 >> 8);\n    let x168: u8 = ((x167 & (0xff as u64)) as u8);\n    let x169: u64 = (x167 >> 8);\n    let x170: u8 = ((x169 & (0xff as u64)) as u8);\n    let x171: u64 = (x169 >> 8);\n    let x172: u8 = ((x171 & (0xff as u64)) as u8);\n    let x173: u64 = (x171 >> 8);\n    let x174: u8 = ((x173 & (0xff as u64)) as u8);\n    let x175: fiat_p521_u1 = ((x173 >> 8) as fiat_p521_u1);\n    out1[0] = x44;\n    out1[1] = x46;\n    out1[2] = x48;\n    out1[3] = x50;\n    out1[4] = x52;\n    out1[5] = x54;\n    out1[6] = x56;\n    out1[7] = x59;\n    out1[8] = x61;\n    out1[9] = x63;\n    out1[10] = x65;\n    out1[11] = x67;\n    out1[12] = x69;\n    out1[13] = x71;\n    out1[14] = x74;\n    out1[15] = x76;\n    out1[16] = x78;\n    out1[17] = x80;\n    out1[18] = x82;\n    out1[19] = x84;\n    out1[20] = x86;\n    out1[21] = x89;\n    out1[22] = x91;\n    out1[23] = x93;\n    out1[24] = x95;\n    out1[25] = x97;\n    out1[26] = x99;\n    out1[27] = x101;\n    out1[28] = x102;\n    out1[29] = x103;\n    out1[30] = x105;\n    out1[31] = x107;\n    out1[32] = x109;\n    out1[33] = x111;\n    out1[34] = x113;\n    out1[35] = x115;\n    out1[36] = x118;\n    out1[37] = x120;\n    out1[38] = x122;\n    out1[39] = x124;\n    out1[40] = x126;\n    out1[41] = x128;\n    out1[42] = x130;\n    out1[43] = x133;\n    out1[44] = x135;\n    out1[45] = x137;\n    out1[46] = x139;\n    out1[47] = x141;\n    out1[48] = x143;\n    out1[49] = x145;\n    out1[50] = x148;\n    out1[51] = x150;\n    out1[52] = x152;\n    out1[53] = x154;\n    out1[54] = x156;\n    out1[55] = x158;\n    out1[56] = x160;\n    out1[57] = x161;\n    out1[58] = x162;\n    out1[59] = x164;\n    out1[60] = x166;\n    out1[61] = x168;\n    out1[62] = x170;\n    out1[63] = x172;\n    out1[64] = x174;\n    out1[65] = (x175 as u8);\n}",
    "display_name": "fiat_p521_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/DynSignatureAlgorithmIdentifier/signature_algorithm_identifier",
    "statement_type": "function",
    "deps": [],
    "body": "    fn signature_algorithm_identifier(\n        &self,\n    ) -> pkcs8::spki::Result<pkcs8::spki::AlgorithmIdentifierOwned> {\n        // From https://datatracker.ietf.org/doc/html/rfc8410\n        Ok(pkcs8::spki::AlgorithmIdentifierOwned {\n            oid: super::ALGORITHM_OID,\n            parameters: None,\n        })\n    }",
    "display_name": "signature_algorithm_identifier",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsMinusThree/PointArithmetic/double",
    "statement_type": "function",
    "deps": [],
    "body": "    fn double(point: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        debug_assert_eq!(\n            C::EQUATION_A,\n            -C::FieldElement::from(3),\n            \"this implementation is only valid for C::EQUATION_A = -3\"\n        );\n\n        let xx = point.x.square(); // 1\n        let yy = point.y.square(); // 2\n        let zz = point.z.square(); // 3\n        let xy2 = (point.x * point.y).double(); // 4, 5\n        let xz2 = (point.x * point.z).double(); // 6, 7\n\n        let bzz_part = (C::EQUATION_B * zz) - xz2; // 8, 9\n        let bzz3_part = bzz_part.double() + bzz_part; // 10, 11\n        let yy_m_bzz3 = yy - bzz3_part; // 12\n        let yy_p_bzz3 = yy + bzz3_part; // 13\n        let y_frag = yy_p_bzz3 * yy_m_bzz3; // 14\n        let x_frag = yy_m_bzz3 * xy2; // 15\n\n        let zz3 = zz.double() + zz; // 16, 17\n        let bxz2_part = (C::EQUATION_B * xz2) - (zz3 + xx); // 18, 19, 20\n        let bxz6_part = bxz2_part.double() + bxz2_part; // 21, 22\n        let xx3_m_zz3 = xx.double() + xx - zz3; // 23, 24, 25\n\n        let y = y_frag + (xx3_m_zz3 * bxz6_part); // 26, 27\n        let yz2 = (point.y * point.z).double(); // 28, 29\n        let x = x_frag - (bxz6_part * yz2); // 30, 31\n        let z = (yz2 * yy).double().double(); // 32, 33, 34\n\n        ProjectivePoint { x, y, z }\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/AffineCoordinates/x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn x(&self) -> FieldBytes {\n        self.x.to_bytes()\n    }",
    "display_name": "x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        // 1. It's debug only, so it shouldn't present a security risk\n        // 2. Being normalized does is independent from the field element value;\n        //    elements must be normalized explicitly.\n        let new_normalized = if bool::from(choice) {\n            b.normalized\n        } else {\n            a.normalized\n        };\n        Self {\n            value: FieldElementUnsafeImpl::conditional_select(&(a.value), &(b.value), choice),\n            magnitude: u32::conditional_select(&(a.magnitude), &(b.magnitude), choice),\n            normalized: new_normalized,\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.0.x.ct_eq(&other.0.x) & self.0.y.ct_eq(&other.0.y)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/is_low_order",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_low_order(&self) -> bool {\n        (*self == LOW_A) || (*self == LOW_B) || (*self == LOW_C)\n    }",
    "display_name": "is_low_order",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "affine/impl/AffinePoint/PrimeCurveAffine/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> AffinePoint<C> {\n        Self::IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/pow_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/pow_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/AffinePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/as_affine"
    ],
    "body": "    fn from(vk: VerifyingKey) -> AffinePoint {\n        *vk.as_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_equals",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_equals() {\n        let a = Scalar::from(5u8);\n        let b = Scalar::from(5u8);\n        let c = Scalar::from(10u8);\n        assert_eq!(a, b);\n        assert_ne!(a, c);\n    }",
    "display_name": "test_equals",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add(self, other: ProjectivePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::add(&self, &other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 ristretto/points/impl/CompressedRistretto/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/ristretto/points.rs",
    "relative_path": "ed448-goldilocks/src/ristretto/points.rs",
    "file_name": "points.rs",
    "parent_folder": "ristretto"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/impl/fiat_p384_scalar_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_serialise",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes",
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    fn test_serialise() {\n        let scalar = Scalar(U448::from_be_hex(\n            \"0d79f6e375d3395ed9a6c4c3c49a1433fd7c58aa38363f74e9ab2c22a22347d79988f8e01e8a309f862a9f1052fcd042b9b1ed7115598f62\",\n        ));\n        let got = Scalar::from_bytes(&scalar.to_bytes());\n        assert_eq!(scalar, got)\n    }",
    "display_name": "test_serialise",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_zero(&self) -> Choice {\n        self.0.is_zero()\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/to_canonical",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_canonical",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/exp_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/multiply",
      "0.14.0_pre.1 field/scalar/impl/Scalar/square"
    ],
    "body": "    pub const fn exp_vartime(&self, exp: &[u64]) -> Self {\n        let mut res = Self::ONE;\n\n        let mut i = exp.len();\n        while i > 0 {\n            i -= 1;\n\n            let mut j = 64;\n            while j > 0 {\n                j -= 1;\n                res = res.square();\n\n                if ((exp[i] >> j) & 1) == 1 {\n                    res = res.multiply(self);\n                }\n            }\n        }\n\n        res\n    }",
    "display_name": "exp_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/hash_msg",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn hash_msg(&self, msg: &[&[u8]]) -> Hash {\n        let mut hasher = BeltHash::new();\n        msg.iter().for_each(|slice| hasher.update(slice));\n        hasher.finalize_fixed()\n    }",
    "display_name": "hash_msg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> Self::Repr {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extensible",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended"
    ],
    "body": "    pub fn add_extensible(&self, other: &ExtensiblePoint) -> ExtensiblePoint {\n        self.add_extended(&other.to_extended())\n    }",
    "display_name": "add_extensible",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        self.to_be_byte_array()\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/lib.rs",
    "relative_path": "p192/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::ZERO\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/RandomizedMultipartSigner/try_multipart_sign_with_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/RandomizedDigestSigner/try_sign_digest_with_rng"
    ],
    "body": "    fn try_multipart_sign_with_rng<R: TryCryptoRng + ?Sized>(\n        &self,\n        rng: &mut R,\n        msg: &[&[u8]],\n    ) -> Result<Signature> {\n        let mut digest = Sha256::new();\n        msg.iter().for_each(|slice| digest.update(slice));\n        self.try_sign_digest_with_rng(rng, digest)\n    }",
    "display_name": "try_multipart_sign_with_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_opp(\n    out1: &mut fiat_sm2_scalar_montgomery_domain_field_element,\n    arg1: &fiat_sm2_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, (x9 & 0x53bbf40939d54123));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0x7203df6b21c6052b));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, (x9 & 0xfffffffeffffffff));\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_sm2_scalar_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &SigningKey) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.secret_scalar.ct_eq(&other.secret_scalar)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add_assign(&mut self, rhs: &Scalar) {\n        *self = Scalar::add(self, rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/From>/from"
    ],
    "body": "    fn from(public_key: &PublicKey) -> ProjectivePoint {\n        AffinePoint::from(public_key).into()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: Box<[u8]>) -> Result<Self, Self::Error> {\n        Self::try_from(value.as_ref())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/mul_inner"
    ],
    "body": "    pub fn square(&self) -> Self {\n        self.mul_inner(self)\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_point_mul"
    ],
    "body": "fn bench_point(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"point operations\");\n    bench_point_mul(&mut group);\n    group.finish();\n}",
    "display_name": "bench_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn as_bytes(&self) -> &PointBytes {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:x}\", self.0.retrieve())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> FieldElement {\n        Self(self.0.neg())\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "    fn mul(self, other: Scalar) -> Scalar {\n        Scalar::multiply(&self, &other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Field/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
      "0.14.0_pre.1 field/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        CtOption::new(self.invert(), !self.ct_eq(&Self::ZERO))\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/UpperHex/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        write!(\n            f,\n            \"{{ X: {:X}, Y: {:X}, Z: {:X}, T: {:X} }}\",\n            self.X, self.Y, self.Z, self.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/from_ec_secret",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From>/from",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn from_ec_secret() {\n        let scalar = Scalar::ONE;\n        let secret = SecretKey::from_bytes(&scalar.to_bytes()).unwrap();\n        let rederived_scalar = Scalar::from(&secret);\n        assert_eq!(scalar.0, rederived_scalar.0);\n    }",
    "display_name": "from_ec_secret",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/NonIdentity/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(affine_point: AffinePoint) -> Result<Self> {\n        NonIdentity::new(affine_point).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/recovery/ethereum_end_to_end_example",
    "statement_type": "function",
    "deps": [],
    "body": "        fn ethereum_end_to_end_example() {\n            let signing_key = SigningKey::from_bytes(\n                &hex!(\"4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\").into(),\n            )\n            .unwrap();\n\n            let msg = hex!(\n                \"e9808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca0080018080\"\n            );\n            let digest = Keccak256::new_with_prefix(msg);\n\n            let (sig, recid) = signing_key.sign_digest_recoverable(digest.clone()).unwrap();\n            assert_eq!(\n                sig.to_bytes().as_slice(),\n                &hex!(\n                    \"c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68\"\n                )\n            );\n            assert_eq!(recid, RecoveryId::from_byte(0).unwrap());\n\n            let verifying_key =\n                VerifyingKey::recover_from_digest(digest.clone(), &sig, recid).unwrap();\n\n            assert_eq!(signing_key.verifying_key(), &verifying_key);\n            assert!(verifying_key.verify_digest(digest, &sig).is_ok());\n        }",
    "display_name": "ethereum_end_to_end_example",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/ecdsa.rs",
    "relative_path": "k256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_divstep_precomp(out1: &mut [u64; 4]) {\n    out1[0] = 0x7ea454d3127f51fe;\n    out1[1] = 0x4802b1d5546a7f1;\n    out1[2] = 0xab83282b495d722c;\n    out1[3] = 0xdb33014c12f2d964;\n}",
    "display_name": "fiat_bign256_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    fn square(&self) -> Self {\n        self.square()\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/impl/Cipher/EncodeValue/value_len",
    "statement_type": "function",
    "deps": [],
    "body": "    fn value_len(&self) -> elliptic_curve::pkcs8::der::Result<Length> {\n        UintRef::new(&self.x.to_be_bytes())?.encoded_len()?\n            + UintRef::new(&self.y.to_be_bytes())?.encoded_len()?\n            + OctetStringRef::new(self.digest)?.encoded_len()?\n            + OctetStringRef::new(self.cipher)?.encoded_len()?\n    }",
    "display_name": "value_len",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke.rs",
    "relative_path": "sm2/src/pke.rs",
    "file_name": "pke.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/tests/test_lincomb",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/LinearCombination/lincomb"
    ],
    "body": "    fn test_lincomb() {\n        let x = ProjectivePoint::random(&mut OsRng.unwrap_mut());\n        let y = ProjectivePoint::random(&mut OsRng.unwrap_mut());\n        let k = Scalar::random(&mut OsRng.unwrap_mut());\n        let l = Scalar::random(&mut OsRng.unwrap_mut());\n\n        let reference = x * k + y * l;\n        let test = ProjectivePoint::lincomb(&[(x, k), (y, l)]);\n        assert_eq!(reference, test);\n    }",
    "display_name": "test_lincomb",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_p192_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(a: u32) -> Scalar {\n        Scalar(U448::from_u32(a))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/two_inv_constant",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn two_inv_constant() {\n        assert_eq!(Scalar::from(2u32) * Scalar::TWO_INV, Scalar::ONE);\n    }",
    "display_name": "two_inv_constant",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "affine/impl/AffinePoint/AffineCoordinates/x",
    "statement_type": "function",
    "deps": [],
    "body": "    fn x(&self) -> FieldBytes<C> {\n        self.x.to_repr()\n    }",
    "display_name": "x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_mulx_u64"
    ],
    "body": "pub const fn fiat_p192_mul(\n    out1: &mut fiat_p192_montgomery_domain_field_element,\n    arg1: &fiat_p192_montgomery_domain_field_element,\n    arg2: &fiat_p192_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[0]);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p192_mulx_u64(&mut x4, &mut x5, x3, (arg2[2]));\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p192_mulx_u64(&mut x6, &mut x7, x3, (arg2[1]));\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p192_mulx_u64(&mut x8, &mut x9, x3, (arg2[0]));\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x10, &mut x11, 0x0, x9, x6);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x12, &mut x13, x11, x7, x4);\n    let x14: u64 = ((x13 as u64) + x5);\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p192_mulx_u64(&mut x15, &mut x16, x8, 0xffffffffffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p192_mulx_u64(&mut x17, &mut x18, x8, 0xfffffffffffffffe);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_p192_mulx_u64(&mut x19, &mut x20, x8, 0xffffffffffffffff);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x21, &mut x22, 0x0, x20, x17);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x23, &mut x24, x22, x18, x15);\n    let x25: u64 = ((x24 as u64) + x16);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x26, &mut x27, 0x0, x8, x19);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x28, &mut x29, x27, x10, x21);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x30, &mut x31, x29, x12, x23);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x32, &mut x33, x31, x14, x25);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p192_mulx_u64(&mut x34, &mut x35, x1, (arg2[2]));\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p192_mulx_u64(&mut x36, &mut x37, x1, (arg2[1]));\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p192_mulx_u64(&mut x38, &mut x39, x1, (arg2[0]));\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x40, &mut x41, 0x0, x39, x36);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x42, &mut x43, x41, x37, x34);\n    let x44: u64 = ((x43 as u64) + x35);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x45, &mut x46, 0x0, x28, x38);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x47, &mut x48, x46, x30, x40);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x49, &mut x50, x48, x32, x42);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x51, &mut x52, x50, (x33 as u64), x44);\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_p192_mulx_u64(&mut x53, &mut x54, x45, 0xffffffffffffffff);\n    let mut x55: u64 = 0;\n    let mut x56: u64 = 0;\n    fiat_p192_mulx_u64(&mut x55, &mut x56, x45, 0xfffffffffffffffe);\n    let mut x57: u64 = 0;\n    let mut x58: u64 = 0;\n    fiat_p192_mulx_u64(&mut x57, &mut x58, x45, 0xffffffffffffffff);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x59, &mut x60, 0x0, x58, x55);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x61, &mut x62, x60, x56, x53);\n    let x63: u64 = ((x62 as u64) + x54);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x64, &mut x65, 0x0, x45, x57);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x66, &mut x67, x65, x47, x59);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x68, &mut x69, x67, x49, x61);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x70, &mut x71, x69, x51, x63);\n    let x72: u64 = ((x71 as u64) + (x52 as u64));\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_p192_mulx_u64(&mut x73, &mut x74, x2, (arg2[2]));\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_p192_mulx_u64(&mut x75, &mut x76, x2, (arg2[1]));\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p192_mulx_u64(&mut x77, &mut x78, x2, (arg2[0]));\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x79, &mut x80, 0x0, x78, x75);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x81, &mut x82, x80, x76, x73);\n    let x83: u64 = ((x82 as u64) + x74);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x84, &mut x85, 0x0, x66, x77);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x86, &mut x87, x85, x68, x79);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x88, &mut x89, x87, x70, x81);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x90, &mut x91, x89, x72, x83);\n    let mut x92: u64 = 0;\n    let mut x93: u64 = 0;\n    fiat_p192_mulx_u64(&mut x92, &mut x93, x84, 0xffffffffffffffff);\n    let mut x94: u64 = 0;\n    let mut x95: u64 = 0;\n    fiat_p192_mulx_u64(&mut x94, &mut x95, x84, 0xfffffffffffffffe);\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_p192_mulx_u64(&mut x96, &mut x97, x84, 0xffffffffffffffff);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x98, &mut x99, 0x0, x97, x94);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x100, &mut x101, x99, x95, x92);\n    let x102: u64 = ((x101 as u64) + x93);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x103, &mut x104, 0x0, x84, x96);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x105, &mut x106, x104, x86, x98);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x107, &mut x108, x106, x88, x100);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x109, &mut x110, x108, x90, x102);\n    let x111: u64 = ((x110 as u64) + (x91 as u64));\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x112, &mut x113, 0x0, x105, 0xffffffffffffffff);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x114, &mut x115, x113, x107, 0xfffffffffffffffe);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x116, &mut x117, x115, x109, 0xffffffffffffffff);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x118, &mut x119, x117, x111, (0x0 as u64));\n    let mut x120: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x120, x119, x112, x105);\n    let mut x121: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x121, x119, x114, x107);\n    let mut x122: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x122, x119, x116, x109);\n    out1[0] = x120;\n    out1[1] = x121;\n    out1[2] = x122;\n}",
    "display_name": "fiat_p192_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt_der_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/encrypt"
    ],
    "body": "    pub fn encrypt_der_digest<R: TryCryptoRng + ?Sized, D>(\n        &self,\n        rng: &mut R,\n        msg: &[u8],\n    ) -> Result<Vec<u8>>\n    where\n        D: 'static + Digest + DynDigest + Send + Sync,\n    {\n        let mut digest = D::new();\n        let cipher = encrypt(rng, &self.public_key, self.mode, &mut digest, msg)?;\n        let digest_size = digest.output_size();\n        let (_, cipher) = cipher.split_at(1);\n        let (x, cipher) = cipher.split_at(32);\n        let (y, cipher) = cipher.split_at(32);\n        let (digest, cipher) = match self.mode {\n            Mode::C1C2C3 => {\n                let (cipher, digest) = cipher.split_at(cipher.len() - digest_size);\n                (digest, cipher)\n            }\n            Mode::C1C3C2 => cipher.split_at(digest_size),\n        };\n        Ok(Cipher {\n            x: Uint::from_be_slice(x),\n            y: Uint::from_be_slice(y),\n            digest,\n            cipher,\n        }\n        .to_der()\n        .map_err(elliptic_curve::pkcs8::Error::from)?)\n    }",
    "display_name": "encrypt_der_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl//u8; 57//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl//u8; 57//From/from"
    ],
    "body": "    fn from(value: &EdwardsPoint) -> Self {\n        Self::from(*value)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/AffinePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/eq_affine"
    ],
    "body": "    fn eq(&self, other: &ProjectivePoint) -> bool {\n        other.eq_affine(self).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/UpperHex/fmt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032"
    ],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {\n        let tmp = self.to_bytes_rfc_8032();\n        for &b in tmp.iter() {\n            write!(f, \"{:02X}\", b)?;\n        }\n        Ok(())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_canonical_bytes"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {\n        if bytes.len() != 57 {\n            return Err(\"invalid byte length\");\n        }\n        let scalar_bytes = ScalarBytes::try_from(bytes).expect(\"invalid scalar bytes\");\n        Option::<Scalar>::from(Scalar::from_canonical_bytes(&scalar_bytes))\n            .ok_or(\"scalar was not canonically encoded\")\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/elliptic_curve::NonZeroScalar/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/to_nonzero_scalar"
    ],
    "body": "    fn from(secret_key: SecretKey) -> NonZeroScalar {\n        secret_key.to_nonzero_scalar()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/multiply"
    ],
    "body": "    fn mul(self, rhs: &LooseFieldElement) -> FieldElement {\n        Self::multiply(&self, rhs)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: FieldElement) {\n        *self = *self - other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_bign256_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/UpperHex/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:X}\", self.0.retrieve())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/to_decaf",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended"
    ],
    "body": "    pub fn to_decaf(&self) -> DecafPoint {\n        DecafPoint(self.0.to_extended())\n    }",
    "display_name": "to_decaf",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_to_bytes(out1: &mut [u8; 32], arg1: &[u64; 4]) {\n    let x1: u64 = (arg1[3]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[1]);\n    let x4: u64 = (arg1[0]);\n    let x5: u8 = ((x4 & (0xff as u64)) as u8);\n    let x6: u64 = (x4 >> 8);\n    let x7: u8 = ((x6 & (0xff as u64)) as u8);\n    let x8: u64 = (x6 >> 8);\n    let x9: u8 = ((x8 & (0xff as u64)) as u8);\n    let x10: u64 = (x8 >> 8);\n    let x11: u8 = ((x10 & (0xff as u64)) as u8);\n    let x12: u64 = (x10 >> 8);\n    let x13: u8 = ((x12 & (0xff as u64)) as u8);\n    let x14: u64 = (x12 >> 8);\n    let x15: u8 = ((x14 & (0xff as u64)) as u8);\n    let x16: u64 = (x14 >> 8);\n    let x17: u8 = ((x16 & (0xff as u64)) as u8);\n    let x18: u8 = ((x16 >> 8) as u8);\n    let x19: u8 = ((x3 & (0xff as u64)) as u8);\n    let x20: u64 = (x3 >> 8);\n    let x21: u8 = ((x20 & (0xff as u64)) as u8);\n    let x22: u64 = (x20 >> 8);\n    let x23: u8 = ((x22 & (0xff as u64)) as u8);\n    let x24: u64 = (x22 >> 8);\n    let x25: u8 = ((x24 & (0xff as u64)) as u8);\n    let x26: u64 = (x24 >> 8);\n    let x27: u8 = ((x26 & (0xff as u64)) as u8);\n    let x28: u64 = (x26 >> 8);\n    let x29: u8 = ((x28 & (0xff as u64)) as u8);\n    let x30: u64 = (x28 >> 8);\n    let x31: u8 = ((x30 & (0xff as u64)) as u8);\n    let x32: u8 = ((x30 >> 8) as u8);\n    let x33: u8 = ((x2 & (0xff as u64)) as u8);\n    let x34: u64 = (x2 >> 8);\n    let x35: u8 = ((x34 & (0xff as u64)) as u8);\n    let x36: u64 = (x34 >> 8);\n    let x37: u8 = ((x36 & (0xff as u64)) as u8);\n    let x38: u64 = (x36 >> 8);\n    let x39: u8 = ((x38 & (0xff as u64)) as u8);\n    let x40: u64 = (x38 >> 8);\n    let x41: u8 = ((x40 & (0xff as u64)) as u8);\n    let x42: u64 = (x40 >> 8);\n    let x43: u8 = ((x42 & (0xff as u64)) as u8);\n    let x44: u64 = (x42 >> 8);\n    let x45: u8 = ((x44 & (0xff as u64)) as u8);\n    let x46: u8 = ((x44 >> 8) as u8);\n    let x47: u8 = ((x1 & (0xff as u64)) as u8);\n    let x48: u64 = (x1 >> 8);\n    let x49: u8 = ((x48 & (0xff as u64)) as u8);\n    let x50: u64 = (x48 >> 8);\n    let x51: u8 = ((x50 & (0xff as u64)) as u8);\n    let x52: u64 = (x50 >> 8);\n    let x53: u8 = ((x52 & (0xff as u64)) as u8);\n    let x54: u64 = (x52 >> 8);\n    let x55: u8 = ((x54 & (0xff as u64)) as u8);\n    let x56: u64 = (x54 >> 8);\n    let x57: u8 = ((x56 & (0xff as u64)) as u8);\n    let x58: u64 = (x56 >> 8);\n    let x59: u8 = ((x58 & (0xff as u64)) as u8);\n    let x60: u8 = ((x58 >> 8) as u8);\n    out1[0] = x5;\n    out1[1] = x7;\n    out1[2] = x9;\n    out1[3] = x11;\n    out1[4] = x13;\n    out1[5] = x15;\n    out1[6] = x17;\n    out1[7] = x18;\n    out1[8] = x19;\n    out1[9] = x21;\n    out1[10] = x23;\n    out1[11] = x25;\n    out1[12] = x27;\n    out1[13] = x29;\n    out1[14] = x31;\n    out1[15] = x32;\n    out1[16] = x33;\n    out1[17] = x35;\n    out1[18] = x37;\n    out1[19] = x39;\n    out1[20] = x41;\n    out1[21] = x43;\n    out1[22] = x45;\n    out1[23] = x46;\n    out1[24] = x47;\n    out1[25] = x49;\n    out1[26] = x51;\n    out1[27] = x53;\n    out1[28] = x55;\n    out1[29] = x57;\n    out1[30] = x59;\n    out1[31] = x60;\n}",
    "display_name": "fiat_sm2_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/root_of_unity_constant",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn root_of_unity_constant() {\n        // ROOT_OF_UNITY^{2^s} mod m == 1\n        assert_eq!(\n            FieldElement::ROOT_OF_UNITY\n                .pow_vartime([1u64 << FieldElement::S, 0, 0, 0])\n                .normalize(),\n            FieldElement::ONE\n        );\n\n        // MULTIPLICATIVE_GENERATOR^{t} mod m == ROOT_OF_UNITY\n        assert_eq!(\n            FieldElement::MULTIPLICATIVE_GENERATOR\n                .pow_vartime(T)\n                .normalize(),\n            FieldElement::ROOT_OF_UNITY\n        )\n    }",
    "display_name": "root_of_unity_constant",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/differential_add_and_double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square"
    ],
    "body": "fn differential_add_and_double(\n    P: &mut ProjectiveMontgomeryPoint,\n    Q: &mut ProjectiveMontgomeryPoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = P.U + P.W;\n    let t1 = P.U - P.W;\n    let t2 = Q.U + Q.W;\n    let t3 = Q.U - Q.W;\n\n    let t4 = t0.square(); // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square(); // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = t4 - t5; // 4 U_P W_P\n\n    let t7 = t0 * t3; // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = t1 * t2; // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9 = t7 + t8; // 2 (U_P U_Q - W_P W_Q)\n    let t10 = t7 - t8; // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 = t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n    let t13 = FieldElement::A_PLUS_TWO_OVER_FOUR * t6; // (A + 2) U_P U_Q\n\n    let t14 = t4 * t5; // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = t13 + t5; // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = t6 * t15; // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n    let t17 = *affine_PmQ * t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11; // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14; // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16; // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18; // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17; // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}",
    "display_name": "differential_add_and_double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom>/try_from"
    ],
    "body": "    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(&value)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/test_is_on_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_on_curve",
      "0.14.0_pre.1 curve/edwards/extended/tests/hex_to_field"
    ],
    "body": "    fn test_is_on_curve() {\n        let x = hex_to_field(\n            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa955555555555555555555555555555555555555555555555555555555\",\n        );\n        let y = hex_to_field(\n            \"ae05e9634ad7048db359d6205086c2b0036ed7a035884dd7b7e36d728ad8c4b80d6565833a2a3098bbbcb2bed1cda06bdaeafbcdea9386ed\",\n        );\n        let generated = AffinePoint { x, y }.to_edwards();\n        assert_eq!(generated.is_on_curve().unwrap_u8(), 1u8);\n    }",
    "display_name": "test_is_on_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.7.0_pre t1/impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [
      "0.7.0_pre encode_field_bytes"
    ],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        crate::encode_field_bytes(self)\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp384/src/t1.rs",
    "relative_path": "bp384/src/t1.rs",
    "file_name": "t1.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn bench_point_mul<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let p = ProjectivePoint::GENERATOR;\n    let m = hex!(\"AA5E28D6A97A2479A65527F7290311A3624D4CC0FA1578598EE3C2613BF99522\");\n    let s = Scalar::from_repr(m.into()).unwrap();\n    group.bench_function(\"point-scalar mul\", |b| {\n        b.iter(|| black_box(p) * black_box(s))\n    });\n}",
    "display_name": "bench_point_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_sm2_scalar_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/with_context",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn with_context<'k, 'v>(&'k self, context: &'v [u8]) -> Context<'k, 'v, Self> {\n        Context {\n            key: self,\n            value: context,\n        }\n    }",
    "display_name": "with_context",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_mulx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_square(\n    out1: &mut fiat_p384_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p384_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[0]);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x7, &mut x8, x6, (arg1[5]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x9, &mut x10, x6, (arg1[4]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x11, &mut x12, x6, (arg1[3]));\n    let mut x13: u64 = 0;\n    let mut x14: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x13, &mut x14, x6, (arg1[2]));\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x15, &mut x16, x6, (arg1[1]));\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x17, &mut x18, x6, (arg1[0]));\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x19, &mut x20, 0x0, x18, x15);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x21, &mut x22, x20, x16, x13);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x23, &mut x24, x22, x14, x11);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x25, &mut x26, x24, x12, x9);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x27, &mut x28, x26, x10, x7);\n    let x29: u64 = ((x28 as u64) + x8);\n    let mut x30: u64 = 0;\n    let mut x31: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x30, &mut x31, x17, 0x6ed46089e88fdc45);\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x32, &mut x33, x30, 0xffffffffffffffff);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x34, &mut x35, x30, 0xffffffffffffffff);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x36, &mut x37, x30, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x38, &mut x39, x30, 0xc7634d81f4372ddf);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x40, &mut x41, x30, 0x581a0db248b0a77a);\n    let mut x42: u64 = 0;\n    let mut x43: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x42, &mut x43, x30, 0xecec196accc52973);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x44, &mut x45, 0x0, x43, x40);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x46, &mut x47, x45, x41, x38);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x48, &mut x49, x47, x39, x36);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x50, &mut x51, x49, x37, x34);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x52, &mut x53, x51, x35, x32);\n    let x54: u64 = ((x53 as u64) + x33);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x55, &mut x56, 0x0, x17, x42);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x19, x44);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x21, x46);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x61, &mut x62, x60, x23, x48);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x63, &mut x64, x62, x25, x50);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x65, &mut x66, x64, x27, x52);\n    let mut x67: u64 = 0;\n    let mut x68: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x67, &mut x68, x66, x29, x54);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x69, &mut x70, x1, (arg1[5]));\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x71, &mut x72, x1, (arg1[4]));\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x73, &mut x74, x1, (arg1[3]));\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x75, &mut x76, x1, (arg1[2]));\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x77, &mut x78, x1, (arg1[1]));\n    let mut x79: u64 = 0;\n    let mut x80: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x79, &mut x80, x1, (arg1[0]));\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x81, &mut x82, 0x0, x80, x77);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x83, &mut x84, x82, x78, x75);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x85, &mut x86, x84, x76, x73);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x87, &mut x88, x86, x74, x71);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x89, &mut x90, x88, x72, x69);\n    let x91: u64 = ((x90 as u64) + x70);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x92, &mut x93, 0x0, x57, x79);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x59, x81);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x61, x83);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x63, x85);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x65, x87);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x102, &mut x103, x101, x67, x89);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x104, &mut x105, x103, (x68 as u64), x91);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x106, &mut x107, x92, 0x6ed46089e88fdc45);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x108, &mut x109, x106, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x110, &mut x111, x106, 0xffffffffffffffff);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x112, &mut x113, x106, 0xffffffffffffffff);\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x114, &mut x115, x106, 0xc7634d81f4372ddf);\n    let mut x116: u64 = 0;\n    let mut x117: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x116, &mut x117, x106, 0x581a0db248b0a77a);\n    let mut x118: u64 = 0;\n    let mut x119: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x118, &mut x119, x106, 0xecec196accc52973);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x120, &mut x121, 0x0, x119, x116);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x117, x114);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x124, &mut x125, x123, x115, x112);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x126, &mut x127, x125, x113, x110);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x128, &mut x129, x127, x111, x108);\n    let x130: u64 = ((x129 as u64) + x109);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x131, &mut x132, 0x0, x92, x118);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x133, &mut x134, x132, x94, x120);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x135, &mut x136, x134, x96, x122);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x98, x124);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x100, x126);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x141, &mut x142, x140, x102, x128);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x143, &mut x144, x142, x104, x130);\n    let x145: u64 = ((x144 as u64) + (x105 as u64));\n    let mut x146: u64 = 0;\n    let mut x147: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x146, &mut x147, x2, (arg1[5]));\n    let mut x148: u64 = 0;\n    let mut x149: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x148, &mut x149, x2, (arg1[4]));\n    let mut x150: u64 = 0;\n    let mut x151: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x150, &mut x151, x2, (arg1[3]));\n    let mut x152: u64 = 0;\n    let mut x153: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x152, &mut x153, x2, (arg1[2]));\n    let mut x154: u64 = 0;\n    let mut x155: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x154, &mut x155, x2, (arg1[1]));\n    let mut x156: u64 = 0;\n    let mut x157: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x156, &mut x157, x2, (arg1[0]));\n    let mut x158: u64 = 0;\n    let mut x159: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x158, &mut x159, 0x0, x157, x154);\n    let mut x160: u64 = 0;\n    let mut x161: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x160, &mut x161, x159, x155, x152);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x162, &mut x163, x161, x153, x150);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x164, &mut x165, x163, x151, x148);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x166, &mut x167, x165, x149, x146);\n    let x168: u64 = ((x167 as u64) + x147);\n    let mut x169: u64 = 0;\n    let mut x170: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x169, &mut x170, 0x0, x133, x156);\n    let mut x171: u64 = 0;\n    let mut x172: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x171, &mut x172, x170, x135, x158);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x173, &mut x174, x172, x137, x160);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x175, &mut x176, x174, x139, x162);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x177, &mut x178, x176, x141, x164);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x179, &mut x180, x178, x143, x166);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x181, &mut x182, x180, x145, x168);\n    let mut x183: u64 = 0;\n    let mut x184: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x183, &mut x184, x169, 0x6ed46089e88fdc45);\n    let mut x185: u64 = 0;\n    let mut x186: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x185, &mut x186, x183, 0xffffffffffffffff);\n    let mut x187: u64 = 0;\n    let mut x188: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x187, &mut x188, x183, 0xffffffffffffffff);\n    let mut x189: u64 = 0;\n    let mut x190: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x189, &mut x190, x183, 0xffffffffffffffff);\n    let mut x191: u64 = 0;\n    let mut x192: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x191, &mut x192, x183, 0xc7634d81f4372ddf);\n    let mut x193: u64 = 0;\n    let mut x194: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x193, &mut x194, x183, 0x581a0db248b0a77a);\n    let mut x195: u64 = 0;\n    let mut x196: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x195, &mut x196, x183, 0xecec196accc52973);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x197, &mut x198, 0x0, x196, x193);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x194, x191);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x192, x189);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x190, x187);\n    let mut x205: u64 = 0;\n    let mut x206: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x205, &mut x206, x204, x188, x185);\n    let x207: u64 = ((x206 as u64) + x186);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x208, &mut x209, 0x0, x169, x195);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x210, &mut x211, x209, x171, x197);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x212, &mut x213, x211, x173, x199);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x214, &mut x215, x213, x175, x201);\n    let mut x216: u64 = 0;\n    let mut x217: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x216, &mut x217, x215, x177, x203);\n    let mut x218: u64 = 0;\n    let mut x219: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x218, &mut x219, x217, x179, x205);\n    let mut x220: u64 = 0;\n    let mut x221: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x220, &mut x221, x219, x181, x207);\n    let x222: u64 = ((x221 as u64) + (x182 as u64));\n    let mut x223: u64 = 0;\n    let mut x224: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x223, &mut x224, x3, (arg1[5]));\n    let mut x225: u64 = 0;\n    let mut x226: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x225, &mut x226, x3, (arg1[4]));\n    let mut x227: u64 = 0;\n    let mut x228: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x227, &mut x228, x3, (arg1[3]));\n    let mut x229: u64 = 0;\n    let mut x230: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x229, &mut x230, x3, (arg1[2]));\n    let mut x231: u64 = 0;\n    let mut x232: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x231, &mut x232, x3, (arg1[1]));\n    let mut x233: u64 = 0;\n    let mut x234: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x233, &mut x234, x3, (arg1[0]));\n    let mut x235: u64 = 0;\n    let mut x236: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x235, &mut x236, 0x0, x234, x231);\n    let mut x237: u64 = 0;\n    let mut x238: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x237, &mut x238, x236, x232, x229);\n    let mut x239: u64 = 0;\n    let mut x240: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x239, &mut x240, x238, x230, x227);\n    let mut x241: u64 = 0;\n    let mut x242: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x241, &mut x242, x240, x228, x225);\n    let mut x243: u64 = 0;\n    let mut x244: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x243, &mut x244, x242, x226, x223);\n    let x245: u64 = ((x244 as u64) + x224);\n    let mut x246: u64 = 0;\n    let mut x247: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x246, &mut x247, 0x0, x210, x233);\n    let mut x248: u64 = 0;\n    let mut x249: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x248, &mut x249, x247, x212, x235);\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x250, &mut x251, x249, x214, x237);\n    let mut x252: u64 = 0;\n    let mut x253: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x252, &mut x253, x251, x216, x239);\n    let mut x254: u64 = 0;\n    let mut x255: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x254, &mut x255, x253, x218, x241);\n    let mut x256: u64 = 0;\n    let mut x257: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x256, &mut x257, x255, x220, x243);\n    let mut x258: u64 = 0;\n    let mut x259: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x258, &mut x259, x257, x222, x245);\n    let mut x260: u64 = 0;\n    let mut x261: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x260, &mut x261, x246, 0x6ed46089e88fdc45);\n    let mut x262: u64 = 0;\n    let mut x263: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x262, &mut x263, x260, 0xffffffffffffffff);\n    let mut x264: u64 = 0;\n    let mut x265: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x264, &mut x265, x260, 0xffffffffffffffff);\n    let mut x266: u64 = 0;\n    let mut x267: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x266, &mut x267, x260, 0xffffffffffffffff);\n    let mut x268: u64 = 0;\n    let mut x269: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x268, &mut x269, x260, 0xc7634d81f4372ddf);\n    let mut x270: u64 = 0;\n    let mut x271: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x270, &mut x271, x260, 0x581a0db248b0a77a);\n    let mut x272: u64 = 0;\n    let mut x273: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x272, &mut x273, x260, 0xecec196accc52973);\n    let mut x274: u64 = 0;\n    let mut x275: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x274, &mut x275, 0x0, x273, x270);\n    let mut x276: u64 = 0;\n    let mut x277: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x276, &mut x277, x275, x271, x268);\n    let mut x278: u64 = 0;\n    let mut x279: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x278, &mut x279, x277, x269, x266);\n    let mut x280: u64 = 0;\n    let mut x281: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x280, &mut x281, x279, x267, x264);\n    let mut x282: u64 = 0;\n    let mut x283: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x282, &mut x283, x281, x265, x262);\n    let x284: u64 = ((x283 as u64) + x263);\n    let mut x285: u64 = 0;\n    let mut x286: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x285, &mut x286, 0x0, x246, x272);\n    let mut x287: u64 = 0;\n    let mut x288: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x287, &mut x288, x286, x248, x274);\n    let mut x289: u64 = 0;\n    let mut x290: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x289, &mut x290, x288, x250, x276);\n    let mut x291: u64 = 0;\n    let mut x292: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x291, &mut x292, x290, x252, x278);\n    let mut x293: u64 = 0;\n    let mut x294: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x293, &mut x294, x292, x254, x280);\n    let mut x295: u64 = 0;\n    let mut x296: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x295, &mut x296, x294, x256, x282);\n    let mut x297: u64 = 0;\n    let mut x298: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x297, &mut x298, x296, x258, x284);\n    let x299: u64 = ((x298 as u64) + (x259 as u64));\n    let mut x300: u64 = 0;\n    let mut x301: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x300, &mut x301, x4, (arg1[5]));\n    let mut x302: u64 = 0;\n    let mut x303: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x302, &mut x303, x4, (arg1[4]));\n    let mut x304: u64 = 0;\n    let mut x305: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x304, &mut x305, x4, (arg1[3]));\n    let mut x306: u64 = 0;\n    let mut x307: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x306, &mut x307, x4, (arg1[2]));\n    let mut x308: u64 = 0;\n    let mut x309: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x308, &mut x309, x4, (arg1[1]));\n    let mut x310: u64 = 0;\n    let mut x311: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x310, &mut x311, x4, (arg1[0]));\n    let mut x312: u64 = 0;\n    let mut x313: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x312, &mut x313, 0x0, x311, x308);\n    let mut x314: u64 = 0;\n    let mut x315: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x314, &mut x315, x313, x309, x306);\n    let mut x316: u64 = 0;\n    let mut x317: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x316, &mut x317, x315, x307, x304);\n    let mut x318: u64 = 0;\n    let mut x319: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x318, &mut x319, x317, x305, x302);\n    let mut x320: u64 = 0;\n    let mut x321: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x320, &mut x321, x319, x303, x300);\n    let x322: u64 = ((x321 as u64) + x301);\n    let mut x323: u64 = 0;\n    let mut x324: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x323, &mut x324, 0x0, x287, x310);\n    let mut x325: u64 = 0;\n    let mut x326: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x325, &mut x326, x324, x289, x312);\n    let mut x327: u64 = 0;\n    let mut x328: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x327, &mut x328, x326, x291, x314);\n    let mut x329: u64 = 0;\n    let mut x330: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x329, &mut x330, x328, x293, x316);\n    let mut x331: u64 = 0;\n    let mut x332: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x331, &mut x332, x330, x295, x318);\n    let mut x333: u64 = 0;\n    let mut x334: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x333, &mut x334, x332, x297, x320);\n    let mut x335: u64 = 0;\n    let mut x336: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x335, &mut x336, x334, x299, x322);\n    let mut x337: u64 = 0;\n    let mut x338: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x337, &mut x338, x323, 0x6ed46089e88fdc45);\n    let mut x339: u64 = 0;\n    let mut x340: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x339, &mut x340, x337, 0xffffffffffffffff);\n    let mut x341: u64 = 0;\n    let mut x342: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x341, &mut x342, x337, 0xffffffffffffffff);\n    let mut x343: u64 = 0;\n    let mut x344: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x343, &mut x344, x337, 0xffffffffffffffff);\n    let mut x345: u64 = 0;\n    let mut x346: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x345, &mut x346, x337, 0xc7634d81f4372ddf);\n    let mut x347: u64 = 0;\n    let mut x348: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x347, &mut x348, x337, 0x581a0db248b0a77a);\n    let mut x349: u64 = 0;\n    let mut x350: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x349, &mut x350, x337, 0xecec196accc52973);\n    let mut x351: u64 = 0;\n    let mut x352: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x351, &mut x352, 0x0, x350, x347);\n    let mut x353: u64 = 0;\n    let mut x354: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x353, &mut x354, x352, x348, x345);\n    let mut x355: u64 = 0;\n    let mut x356: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x355, &mut x356, x354, x346, x343);\n    let mut x357: u64 = 0;\n    let mut x358: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x357, &mut x358, x356, x344, x341);\n    let mut x359: u64 = 0;\n    let mut x360: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x359, &mut x360, x358, x342, x339);\n    let x361: u64 = ((x360 as u64) + x340);\n    let mut x362: u64 = 0;\n    let mut x363: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x362, &mut x363, 0x0, x323, x349);\n    let mut x364: u64 = 0;\n    let mut x365: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x364, &mut x365, x363, x325, x351);\n    let mut x366: u64 = 0;\n    let mut x367: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x366, &mut x367, x365, x327, x353);\n    let mut x368: u64 = 0;\n    let mut x369: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x368, &mut x369, x367, x329, x355);\n    let mut x370: u64 = 0;\n    let mut x371: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x370, &mut x371, x369, x331, x357);\n    let mut x372: u64 = 0;\n    let mut x373: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x372, &mut x373, x371, x333, x359);\n    let mut x374: u64 = 0;\n    let mut x375: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x374, &mut x375, x373, x335, x361);\n    let x376: u64 = ((x375 as u64) + (x336 as u64));\n    let mut x377: u64 = 0;\n    let mut x378: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x377, &mut x378, x5, (arg1[5]));\n    let mut x379: u64 = 0;\n    let mut x380: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x379, &mut x380, x5, (arg1[4]));\n    let mut x381: u64 = 0;\n    let mut x382: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x381, &mut x382, x5, (arg1[3]));\n    let mut x383: u64 = 0;\n    let mut x384: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x383, &mut x384, x5, (arg1[2]));\n    let mut x385: u64 = 0;\n    let mut x386: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x385, &mut x386, x5, (arg1[1]));\n    let mut x387: u64 = 0;\n    let mut x388: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x387, &mut x388, x5, (arg1[0]));\n    let mut x389: u64 = 0;\n    let mut x390: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x389, &mut x390, 0x0, x388, x385);\n    let mut x391: u64 = 0;\n    let mut x392: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x391, &mut x392, x390, x386, x383);\n    let mut x393: u64 = 0;\n    let mut x394: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x393, &mut x394, x392, x384, x381);\n    let mut x395: u64 = 0;\n    let mut x396: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x395, &mut x396, x394, x382, x379);\n    let mut x397: u64 = 0;\n    let mut x398: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x397, &mut x398, x396, x380, x377);\n    let x399: u64 = ((x398 as u64) + x378);\n    let mut x400: u64 = 0;\n    let mut x401: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x400, &mut x401, 0x0, x364, x387);\n    let mut x402: u64 = 0;\n    let mut x403: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x402, &mut x403, x401, x366, x389);\n    let mut x404: u64 = 0;\n    let mut x405: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x404, &mut x405, x403, x368, x391);\n    let mut x406: u64 = 0;\n    let mut x407: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x406, &mut x407, x405, x370, x393);\n    let mut x408: u64 = 0;\n    let mut x409: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x408, &mut x409, x407, x372, x395);\n    let mut x410: u64 = 0;\n    let mut x411: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x410, &mut x411, x409, x374, x397);\n    let mut x412: u64 = 0;\n    let mut x413: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x412, &mut x413, x411, x376, x399);\n    let mut x414: u64 = 0;\n    let mut x415: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x414, &mut x415, x400, 0x6ed46089e88fdc45);\n    let mut x416: u64 = 0;\n    let mut x417: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x416, &mut x417, x414, 0xffffffffffffffff);\n    let mut x418: u64 = 0;\n    let mut x419: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x418, &mut x419, x414, 0xffffffffffffffff);\n    let mut x420: u64 = 0;\n    let mut x421: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x420, &mut x421, x414, 0xffffffffffffffff);\n    let mut x422: u64 = 0;\n    let mut x423: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x422, &mut x423, x414, 0xc7634d81f4372ddf);\n    let mut x424: u64 = 0;\n    let mut x425: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x424, &mut x425, x414, 0x581a0db248b0a77a);\n    let mut x426: u64 = 0;\n    let mut x427: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x426, &mut x427, x414, 0xecec196accc52973);\n    let mut x428: u64 = 0;\n    let mut x429: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x428, &mut x429, 0x0, x427, x424);\n    let mut x430: u64 = 0;\n    let mut x431: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x430, &mut x431, x429, x425, x422);\n    let mut x432: u64 = 0;\n    let mut x433: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x432, &mut x433, x431, x423, x420);\n    let mut x434: u64 = 0;\n    let mut x435: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x434, &mut x435, x433, x421, x418);\n    let mut x436: u64 = 0;\n    let mut x437: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x436, &mut x437, x435, x419, x416);\n    let x438: u64 = ((x437 as u64) + x417);\n    let mut x439: u64 = 0;\n    let mut x440: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x439, &mut x440, 0x0, x400, x426);\n    let mut x441: u64 = 0;\n    let mut x442: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x441, &mut x442, x440, x402, x428);\n    let mut x443: u64 = 0;\n    let mut x444: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x443, &mut x444, x442, x404, x430);\n    let mut x445: u64 = 0;\n    let mut x446: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x445, &mut x446, x444, x406, x432);\n    let mut x447: u64 = 0;\n    let mut x448: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x447, &mut x448, x446, x408, x434);\n    let mut x449: u64 = 0;\n    let mut x450: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x449, &mut x450, x448, x410, x436);\n    let mut x451: u64 = 0;\n    let mut x452: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x451, &mut x452, x450, x412, x438);\n    let x453: u64 = ((x452 as u64) + (x413 as u64));\n    let mut x454: u64 = 0;\n    let mut x455: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x454, &mut x455, 0x0, x441, 0xecec196accc52973);\n    let mut x456: u64 = 0;\n    let mut x457: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x456, &mut x457, x455, x443, 0x581a0db248b0a77a);\n    let mut x458: u64 = 0;\n    let mut x459: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x458, &mut x459, x457, x445, 0xc7634d81f4372ddf);\n    let mut x460: u64 = 0;\n    let mut x461: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x460, &mut x461, x459, x447, 0xffffffffffffffff);\n    let mut x462: u64 = 0;\n    let mut x463: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x462, &mut x463, x461, x449, 0xffffffffffffffff);\n    let mut x464: u64 = 0;\n    let mut x465: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x464, &mut x465, x463, x451, 0xffffffffffffffff);\n    let mut x466: u64 = 0;\n    let mut x467: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x466, &mut x467, x465, x453, (0x0 as u64));\n    let mut x468: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x468, x467, x454, x441);\n    let mut x469: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x469, x467, x456, x443);\n    let mut x470: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x470, x467, x458, x445);\n    let mut x471: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x471, x467, x460, x447);\n    let mut x472: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x472, x467, x462, x449);\n    let mut x473: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x473, x467, x464, x451);\n    out1[0] = x468;\n    out1[1] = x469;\n    out1[2] = x470;\n    out1[3] = x471;\n    out1[4] = x472;\n    out1[5] = x473;\n}",
    "display_name": "fiat_p384_scalar_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_y",
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_add<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"add\", |b| b.iter(|| x + y));\n}",
    "display_name": "bench_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/prehash_signer_verification_with_sha384",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    fn prehash_signer_verification_with_sha384() {\n        // The following test vector adapted from the FIPS 186-4 ECDSA test vectors\n        // (P-256, SHA-384, from `SigGen.txt` in `186-4ecdsatestvectors.zip`)\n        // <https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/digital-signatures>\n        let verifier = VerifyingKey::from_affine(\n            AffinePoint::from_encoded_point(&EncodedPoint::from_affine_coordinates(\n                &hex!(\"e0e7b99bc62d8dd67883e39ed9fa0657789c5ff556cc1fd8dd1e2a55e9e3f243\").into(),\n                &hex!(\"63fbfd0232b95578075c903a4dbf85ad58f8350516e1ec89b0ee1f5e1362da69\").into(),\n                false,\n            ))\n            .unwrap(),\n        )\n        .unwrap();\n        let signature = Signature::from_scalars(\n            hex!(\"f5087878e212b703578f5c66f434883f3ef414dc23e2e8d8ab6a8d159ed5ad83\"),\n            hex!(\"306b4c6c20213707982dffbb30fba99b96e792163dd59dbe606e734328dd7c8a\"),\n        )\n        .unwrap();\n        let result = verifier.verify_prehash(\n            &hex!(\"d9c83b92fa0979f4a5ddbd8dd22ab9377801c3c31bf50f932ace0d2146e2574da0d5552dbed4b18836280e9f94558ea6\"),\n            &signature,\n        );\n        assert!(result.is_ok());\n    }",
    "display_name": "prehash_signer_verification_with_sha384",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/ecdsa.rs",
    "relative_path": "p256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_selectznz(\n    out1: &mut [u64; 3],\n    arg1: fiat_p192_scalar_u1,\n    arg2: &[u64; 3],\n    arg3: &[u64; 3],\n) {\n    let mut x1: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n}",
    "display_name": "fiat_p192_scalar_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/&ProjectivePoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/neg"
    ],
    "body": "    fn neg(self) -> ProjectivePoint {\n        ProjectivePoint::neg(self)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/fiat_p384_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        let inner = U256::from_be_byte_array(bytes);\n        CtOption::new(Self(inner), inner.ct_lt(&NistP256::ORDER))\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from(n: u64) -> Scalar {\n        Self::from_uint_unchecked(U576::from(n))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_slice",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    pub fn from_slice(slice: &[u8]) -> Result<Self> {\n        let field_bytes = FieldBytes::try_from(slice).map_err(|_| Error)?;\n        Self::from_bytes(&field_bytes).into_option().ok_or(Error)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(k: u32) -> Self {\n        Scalar(k.into())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint"
    ],
    "body": "    fn try_from(w: U256) -> Result<Self> {\n        Option::from(Self::from_uint(w)).ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, rhs: &Scalar) {\n        *self = *self - rhs\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x",
      "0.14.0_pre.8 test_field_element_y"
    ],
    "body": "fn bench_field_element_mul<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    let y = test_field_element_y();\n    group.bench_function(\"mul\", |b| b.iter(|| &x * &y));\n}",
    "display_name": "bench_field_element_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/field.rs",
    "relative_path": "p384/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_p224_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_sub(\n    out1: &mut fiat_p192_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p192_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p192_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x7, x6, (0x0 as u64), 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x8, &mut x9, 0x0, x1, (x7 & 0x146bc9b1b4d22831));\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x10, &mut x11, x9, x3, (x7 & 0xffffffff99def836));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x5, x7);\n    out1[0] = x8;\n    out1[1] = x10;\n    out1[2] = x12;\n}",
    "display_name": "fiat_p192_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/Group/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_sub"
    ],
    "body": "    pub const fn sub(&self, rhs: &Self) -> Self {\n        let mut out = fiat_p521_scalar_montgomery_domain_field_element([0; 9]);\n        fiat_p521_scalar_sub(&mut out, &self.0, &rhs.0);\n        Self(out)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_set_one(out1: &mut fiat_p224_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0xffffffff00000000;\n    out1[1] = 0xffffffffffffffff;\n    out1[2] = (0x0 as u64);\n    out1[3] = (0x0 as u64);\n}",
    "display_name": "fiat_p224_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "primefield::field_op!(Scalar, Sub, sub, sub);\nprimefield::field_op!(Scalar, Mul, mul, multiply);\nelliptic_curve::scalar_impls!(NistP521, Scalar);\n\nimpl AddAssign<Scalar> for Scalar {\n    #[inline]\n    fn add_assign(&mut self, other: Scalar) {\n        *self = *self + other;\n    }\n}",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add(self, other: AffinePoint) -> ProjectivePoint {\n        ProjectivePoint::add_mixed(&self, &other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/FromOkm/from_okm",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_okm(data: &Array<u8, Self::Length>) -> Self {\n        const SEMI_WIDE_MODULUS: NonZero<U704> = NonZero::<U704>::new_unwrap(U704::from_be_hex(\n            \"00000000000000000000000000000000000000000000000000000000000000003fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3\",\n        ));\n        let mut tmp = Array::<u8, U88>::default();\n        tmp[4..].copy_from_slice(&data[..]);\n\n        let mut num = U704::from_be_slice(&tmp[..]);\n        num %= SEMI_WIDE_MODULUS;\n        let mut words = [0; U448::LIMBS];\n        words.copy_from_slice(&num.to_words()[..U448::LIMBS]);\n        Scalar(U448::from_words(words))\n    }",
    "display_name": "from_okm",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(affine: NonIdentity<AffinePoint>) -> Self {\n        affine.to_point()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_from_bytes(out1: &mut [u64; 6], arg1: &[u8; 48]) {\n    let x1: u64 = (((arg1[47]) as u64) << 56);\n    let x2: u64 = (((arg1[46]) as u64) << 48);\n    let x3: u64 = (((arg1[45]) as u64) << 40);\n    let x4: u64 = (((arg1[44]) as u64) << 32);\n    let x5: u64 = (((arg1[43]) as u64) << 24);\n    let x6: u64 = (((arg1[42]) as u64) << 16);\n    let x7: u64 = (((arg1[41]) as u64) << 8);\n    let x8: u8 = (arg1[40]);\n    let x9: u64 = (((arg1[39]) as u64) << 56);\n    let x10: u64 = (((arg1[38]) as u64) << 48);\n    let x11: u64 = (((arg1[37]) as u64) << 40);\n    let x12: u64 = (((arg1[36]) as u64) << 32);\n    let x13: u64 = (((arg1[35]) as u64) << 24);\n    let x14: u64 = (((arg1[34]) as u64) << 16);\n    let x15: u64 = (((arg1[33]) as u64) << 8);\n    let x16: u8 = (arg1[32]);\n    let x17: u64 = (((arg1[31]) as u64) << 56);\n    let x18: u64 = (((arg1[30]) as u64) << 48);\n    let x19: u64 = (((arg1[29]) as u64) << 40);\n    let x20: u64 = (((arg1[28]) as u64) << 32);\n    let x21: u64 = (((arg1[27]) as u64) << 24);\n    let x22: u64 = (((arg1[26]) as u64) << 16);\n    let x23: u64 = (((arg1[25]) as u64) << 8);\n    let x24: u8 = (arg1[24]);\n    let x25: u64 = (((arg1[23]) as u64) << 56);\n    let x26: u64 = (((arg1[22]) as u64) << 48);\n    let x27: u64 = (((arg1[21]) as u64) << 40);\n    let x28: u64 = (((arg1[20]) as u64) << 32);\n    let x29: u64 = (((arg1[19]) as u64) << 24);\n    let x30: u64 = (((arg1[18]) as u64) << 16);\n    let x31: u64 = (((arg1[17]) as u64) << 8);\n    let x32: u8 = (arg1[16]);\n    let x33: u64 = (((arg1[15]) as u64) << 56);\n    let x34: u64 = (((arg1[14]) as u64) << 48);\n    let x35: u64 = (((arg1[13]) as u64) << 40);\n    let x36: u64 = (((arg1[12]) as u64) << 32);\n    let x37: u64 = (((arg1[11]) as u64) << 24);\n    let x38: u64 = (((arg1[10]) as u64) << 16);\n    let x39: u64 = (((arg1[9]) as u64) << 8);\n    let x40: u8 = (arg1[8]);\n    let x41: u64 = (((arg1[7]) as u64) << 56);\n    let x42: u64 = (((arg1[6]) as u64) << 48);\n    let x43: u64 = (((arg1[5]) as u64) << 40);\n    let x44: u64 = (((arg1[4]) as u64) << 32);\n    let x45: u64 = (((arg1[3]) as u64) << 24);\n    let x46: u64 = (((arg1[2]) as u64) << 16);\n    let x47: u64 = (((arg1[1]) as u64) << 8);\n    let x48: u8 = (arg1[0]);\n    let x49: u64 = (x47 + (x48 as u64));\n    let x50: u64 = (x46 + x49);\n    let x51: u64 = (x45 + x50);\n    let x52: u64 = (x44 + x51);\n    let x53: u64 = (x43 + x52);\n    let x54: u64 = (x42 + x53);\n    let x55: u64 = (x41 + x54);\n    let x56: u64 = (x39 + (x40 as u64));\n    let x57: u64 = (x38 + x56);\n    let x58: u64 = (x37 + x57);\n    let x59: u64 = (x36 + x58);\n    let x60: u64 = (x35 + x59);\n    let x61: u64 = (x34 + x60);\n    let x62: u64 = (x33 + x61);\n    let x63: u64 = (x31 + (x32 as u64));\n    let x64: u64 = (x30 + x63);\n    let x65: u64 = (x29 + x64);\n    let x66: u64 = (x28 + x65);\n    let x67: u64 = (x27 + x66);\n    let x68: u64 = (x26 + x67);\n    let x69: u64 = (x25 + x68);\n    let x70: u64 = (x23 + (x24 as u64));\n    let x71: u64 = (x22 + x70);\n    let x72: u64 = (x21 + x71);\n    let x73: u64 = (x20 + x72);\n    let x74: u64 = (x19 + x73);\n    let x75: u64 = (x18 + x74);\n    let x76: u64 = (x17 + x75);\n    let x77: u64 = (x15 + (x16 as u64));\n    let x78: u64 = (x14 + x77);\n    let x79: u64 = (x13 + x78);\n    let x80: u64 = (x12 + x79);\n    let x81: u64 = (x11 + x80);\n    let x82: u64 = (x10 + x81);\n    let x83: u64 = (x9 + x82);\n    let x84: u64 = (x7 + (x8 as u64));\n    let x85: u64 = (x6 + x84);\n    let x86: u64 = (x5 + x85);\n    let x87: u64 = (x4 + x86);\n    let x88: u64 = (x3 + x87);\n    let x89: u64 = (x2 + x88);\n    let x90: u64 = (x1 + x89);\n    out1[0] = x55;\n    out1[1] = x62;\n    out1[2] = x69;\n    out1[3] = x76;\n    out1[4] = x83;\n    out1[5] = x90;\n}",
    "display_name": "fiat_p384_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/&FieldElement/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, other: &FieldElement) -> FieldElement {\n        FieldElement(self.0.add(&other.0))\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre test_scalar_y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_y() -> Scalar {\n    Scalar::from_repr(\n        hex!(\"0f56db78ca460b055c500064824bed999a25aaf48ebb519ac201537b85479813\").into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_scalar_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        for b in &self.0[..] {\n            write!(f, \"{:02x}\", b)?;\n        }\n        Ok(())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/test/test_edwards_ristretto_operations",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/decompress",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/double",
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/compress"
    ],
    "body": "    fn test_edwards_ristretto_operations() {\n        // Basic test that if P1 + P2 = P3\n        // Then Decaf(P1) + Decaf(P2) = Decaf(P3)\n\n        let P = TWISTED_EDWARDS_BASE_POINT;\n\n        let P2 = P.double();\n        let P3 = P2.to_extensible().add_extended(&P).to_extended();\n\n        // Encode and decode to make them Decaf points\n        let Decaf_P = DecafPoint(P).compress().decompress().unwrap();\n        let Decaf_P2 = DecafPoint(P2).compress().decompress().unwrap();\n        let expected_Decaf_P3 = DecafPoint(P3).compress().decompress().unwrap();\n\n        // Adding the DecafPoint should be the same as adding the Edwards points and encoding the result as Decaf\n        let Decaf_P3 = Decaf_P + Decaf_P2;\n\n        assert_eq!(Decaf_P3, expected_Decaf_P3);\n    }",
    "display_name": "test_edwards_ristretto_operations",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_canonical",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_canonical",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add_assign(&mut self, rhs: &ProjectivePoint) {\n        *self = ProjectivePoint::add(self, rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p192_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 4],\n    out3: &mut [u64; 4],\n    out4: &mut [u64; 3],\n    out5: &mut [u64; 3],\n    arg1: u64,\n    arg2: &[u64; 4],\n    arg3: &[u64; 4],\n    arg4: &[u64; 3],\n    arg5: &[u64; 3],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_p192_u1 =\n        (((x1 >> 63) as fiat_p192_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_p192_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x11, &mut x12, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x13, &mut x14, x12, (0x0 as u64), (!(arg2[1])));\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x15, &mut x16, x14, (0x0 as u64), (!(arg2[2])));\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x17, &mut x18, x16, (0x0 as u64), (!(arg2[3])));\n    let mut x19: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x19, x3, (arg3[0]), x11);\n    let mut x20: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x20, x3, (arg3[1]), x13);\n    let mut x21: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x21, x3, (arg3[2]), x15);\n    let mut x22: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x22, x3, (arg3[3]), x17);\n    let mut x23: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x23, x3, (arg4[0]), (arg5[0]));\n    let mut x24: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x24, x3, (arg4[1]), (arg5[1]));\n    let mut x25: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x25, x3, (arg4[2]), (arg5[2]));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x26, &mut x27, 0x0, x23, x23);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x28, &mut x29, x27, x24, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x30, &mut x31, x29, x25, x25);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x32, &mut x33, 0x0, x26, 0xffffffffffffffff);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x34, &mut x35, x33, x28, 0xfffffffffffffffe);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x36, &mut x37, x35, x30, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x38, &mut x39, x37, (x31 as u64), (0x0 as u64));\n    let x40: u64 = (arg4[2]);\n    let x41: u64 = (arg4[1]);\n    let x42: u64 = (arg4[0]);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x43, &mut x44, 0x0, (0x0 as u64), x42);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x45, &mut x46, x44, (0x0 as u64), x41);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x47, &mut x48, x46, (0x0 as u64), x40);\n    let mut x49: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x49, x48, (0x0 as u64), 0xffffffffffffffff);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x50, &mut x51, 0x0, x43, x49);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x52, &mut x53, x51, x45, (x49 & 0xfffffffffffffffe));\n    let mut x54: u64 = 0;\n    let mut x55: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x54, &mut x55, x53, x47, x49);\n    let mut x56: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x56, x3, (arg5[0]), x50);\n    let mut x57: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x57, x3, (arg5[1]), x52);\n    let mut x58: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x58, x3, (arg5[2]), x54);\n    let x59: fiat_p192_u1 = ((x19 & (0x1 as u64)) as fiat_p192_u1);\n    let mut x60: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x60, x59, (0x0 as u64), x7);\n    let mut x61: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x61, x59, (0x0 as u64), x8);\n    let mut x62: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x62, x59, (0x0 as u64), x9);\n    let mut x63: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x63, x59, (0x0 as u64), x10);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x64, &mut x65, 0x0, x19, x60);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x66, &mut x67, x65, x20, x61);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x68, &mut x69, x67, x21, x62);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x70, &mut x71, x69, x22, x63);\n    let mut x72: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x72, x59, (0x0 as u64), x23);\n    let mut x73: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x73, x59, (0x0 as u64), x24);\n    let mut x74: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x74, x59, (0x0 as u64), x25);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x75, &mut x76, 0x0, x56, x72);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x77, &mut x78, x76, x57, x73);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x79, &mut x80, x78, x58, x74);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x81, &mut x82, 0x0, x75, 0xffffffffffffffff);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x83, &mut x84, x82, x77, 0xfffffffffffffffe);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x85, &mut x86, x84, x79, 0xffffffffffffffff);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x87, &mut x88, x86, (x80 as u64), (0x0 as u64));\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x89, &mut x90, 0x0, x6, (0x1 as u64));\n    let x91: u64 = ((x64 >> 1) | ((x66 << 63) & 0xffffffffffffffff));\n    let x92: u64 = ((x66 >> 1) | ((x68 << 63) & 0xffffffffffffffff));\n    let x93: u64 = ((x68 >> 1) | ((x70 << 63) & 0xffffffffffffffff));\n    let x94: u64 = ((x70 & 0x8000000000000000) | (x70 >> 1));\n    let mut x95: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x95, x39, x32, x26);\n    let mut x96: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x96, x39, x34, x28);\n    let mut x97: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x97, x39, x36, x30);\n    let mut x98: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x98, x88, x81, x75);\n    let mut x99: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x99, x88, x83, x77);\n    let mut x100: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x100, x88, x85, x79);\n    *out1 = x89;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out3[0] = x91;\n    out3[1] = x92;\n    out3[2] = x93;\n    out3[3] = x94;\n    out4[0] = x95;\n    out4[1] = x96;\n    out4[2] = x97;\n    out5[0] = x98;\n    out5[1] = x99;\n    out5[2] = x100;\n}",
    "display_name": "fiat_p192_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "fn bench_scalar_invert<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"invert\", |b| b.iter(|| x.invert()));\n}",
    "display_name": "bench_scalar_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p521_scalar_u1,\n    arg1: fiat_p521_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_p521_scalar_u1 = ((x1 >> 64) as fiat_p521_scalar_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p521_scalar_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from_uint_unchecked(uint: Self::Uint) -> Self {\n        Self::from_uint_unchecked(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/ProjectiveMontgomeryPoint/to_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/invert",
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes"
    ],
    "body": "    pub fn to_affine(&self) -> MontgomeryPoint {\n        let x = self.U * self.W.invert();\n        MontgomeryPoint(x.to_bytes())\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/from_slice"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Signature> {\n        Signature::from_slice(bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_field_bytes(&self) -> Decaf448FieldBytes {\n        let mut data = Decaf448FieldBytes::default();\n        data.copy_from_slice(&self.to_le_byte_array()[..]);\n        data\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/lib.rs",
    "relative_path": "ed448-goldilocks/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/zero_is_additive_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add"
    ],
    "body": "    fn zero_is_additive_identity() {\n        let zero = FieldElement::ZERO;\n        let one = FieldElement::ONE;\n        assert_eq!(zero.add(&zero), zero);\n        assert_eq!(one.add(&zero), one);\n    }",
    "display_name": "zero_is_additive_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/sqrt_ratio",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sqrt_ratio(num: &Self, div: &Self) -> (Choice, Self) {\n        ff::helpers::sqrt_ratio_generic(num, div)\n    }",
    "display_name": "sqrt_ratio",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/pow_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_sm2_u1,\n    arg1: fiat_sm2_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_sm2_i1 = ((x1 >> 64) as fiat_sm2_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_sm2_i2) - (x2 as fiat_sm2_i2)) as fiat_sm2_u1);\n}",
    "display_name": "fiat_sm2_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p384_scalar_u1,\n    arg1: fiat_p384_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_p384_scalar_u1 = ((x1 >> 64) as fiat_p384_scalar_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p384_scalar_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/impl/Signature/to_bytes"
    ],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:?}\", self.to_bytes())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/KeypairBytes/EncodePrivateKey/to_pkcs8_der",
    "statement_type": "function",
    "deps": [],
    "body": "    fn to_pkcs8_der(&self) -> pkcs8::Result<pkcs8::SecretDocument> {\n        let verifying_key = self.verifying_key.as_ref();\n        let public_key = verifying_key\n            .map(|k| pkcs8::der::asn1::BitStringRef::from_bytes(k))\n            .transpose()?;\n        let private_key = pkcs8::der::asn1::OctetStringRef::new(self.secret_key.as_ref())?;\n\n        let private_key_info = pkcs8::PrivateKeyInfoRef {\n            algorithm: super::ALGORITHM_ID,\n            private_key,\n            public_key,\n        };\n        let result = pkcs8::SecretDocument::encode_msg(&private_key_info)?;\n\n        Ok(result)\n    }",
    "display_name": "to_pkcs8_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/hash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/add",
      "0.14.0_pre.1 field/element/impl/FieldElement/map_to_curve_decaf448",
      "0.14.0_pre.1 field/element/impl/FieldElement/FromOkm/from_okm"
    ],
    "body": "    pub fn hash<X>(msg: &[u8], dst: &[u8]) -> Self\n    where\n        X: ExpandMsg<U32>,\n    {\n        type RandomLen = U84;\n        let dst = [dst];\n        let mut random_bytes = Array::<u8, RandomLen>::default();\n        let mut expander = X::expand_message(\n            &[msg],\n            &dst,\n            core::num::NonZero::new(RandomLen::U16 * 2)\n                .expect(\"invariant violation: random is non zero length\"),\n        )\n        .expect(\"bad dst\");\n        expander.fill_bytes(&mut random_bytes);\n        let u0 = FieldElement::from_okm(&random_bytes);\n        expander.fill_bytes(&mut random_bytes);\n        let u1 = FieldElement::from_okm(&random_bytes);\n\n        let q0 = u0.map_to_curve_decaf448();\n        let q1 = u1.map_to_curve_decaf448();\n        Self(q0.add(&q1))\n    }",
    "display_name": "hash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.secret_scalar.ct_eq(&other.secret_scalar)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::ZERO\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "fn bench_scalar_invert<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"invert\", |b| b.iter(|| x.invert()));\n}",
    "display_name": "bench_scalar_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/sqrt",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn sqrt() {\n        for &n in &[1u64, 4, 9, 16, 25, 36, 49, 64] {\n            let scalar = Scalar::from(n);\n            let sqrt = scalar.sqrt().unwrap();\n            assert_eq!(sqrt.square(), scalar);\n        }\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_mulx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p384_to_montgomery(\n    out1: &mut fiat_p384_montgomery_domain_field_element,\n    arg1: &fiat_p384_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[0]);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p384_mulx_u64(&mut x7, &mut x8, x6, 0x200000000);\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p384_mulx_u64(&mut x9, &mut x10, x6, 0xfffffffe00000000);\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p384_mulx_u64(&mut x11, &mut x12, x6, 0x200000000);\n    let mut x13: u64 = 0;\n    let mut x14: u64 = 0;\n    fiat_p384_mulx_u64(&mut x13, &mut x14, x6, 0xfffffffe00000001);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x15, &mut x16, 0x0, x14, x11);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x17, &mut x18, x16, x12, x9);\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x19, &mut x20, x18, x10, x7);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x21, &mut x22, x20, x8, x6);\n    let mut x23: u64 = 0;\n    let mut x24: u64 = 0;\n    fiat_p384_mulx_u64(&mut x23, &mut x24, x13, 0x100000001);\n    let mut x25: u64 = 0;\n    let mut x26: u64 = 0;\n    fiat_p384_mulx_u64(&mut x25, &mut x26, x23, 0xffffffffffffffff);\n    let mut x27: u64 = 0;\n    let mut x28: u64 = 0;\n    fiat_p384_mulx_u64(&mut x27, &mut x28, x23, 0xffffffffffffffff);\n    let mut x29: u64 = 0;\n    let mut x30: u64 = 0;\n    fiat_p384_mulx_u64(&mut x29, &mut x30, x23, 0xffffffffffffffff);\n    let mut x31: u64 = 0;\n    let mut x32: u64 = 0;\n    fiat_p384_mulx_u64(&mut x31, &mut x32, x23, 0xfffffffffffffffe);\n    let mut x33: u64 = 0;\n    let mut x34: u64 = 0;\n    fiat_p384_mulx_u64(&mut x33, &mut x34, x23, 0xffffffff00000000);\n    let mut x35: u64 = 0;\n    let mut x36: u64 = 0;\n    fiat_p384_mulx_u64(&mut x35, &mut x36, x23, 0xffffffff);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x37, &mut x38, 0x0, x36, x33);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x39, &mut x40, x38, x34, x31);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x41, &mut x42, x40, x32, x29);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x43, &mut x44, x42, x30, x27);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x45, &mut x46, x44, x28, x25);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x47, &mut x48, 0x0, x13, x35);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x49, &mut x50, x48, x15, x37);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x51, &mut x52, x50, x17, x39);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x53, &mut x54, x52, x19, x41);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x55, &mut x56, x54, x21, x43);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x57, &mut x58, x56, (x22 as u64), x45);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x59, &mut x60, x58, (0x0 as u64), ((x46 as u64) + x26));\n    let mut x61: u64 = 0;\n    let mut x62: u64 = 0;\n    fiat_p384_mulx_u64(&mut x61, &mut x62, x1, 0x200000000);\n    let mut x63: u64 = 0;\n    let mut x64: u64 = 0;\n    fiat_p384_mulx_u64(&mut x63, &mut x64, x1, 0xfffffffe00000000);\n    let mut x65: u64 = 0;\n    let mut x66: u64 = 0;\n    fiat_p384_mulx_u64(&mut x65, &mut x66, x1, 0x200000000);\n    let mut x67: u64 = 0;\n    let mut x68: u64 = 0;\n    fiat_p384_mulx_u64(&mut x67, &mut x68, x1, 0xfffffffe00000001);\n    let mut x69: u64 = 0;\n    let mut x70: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x69, &mut x70, 0x0, x68, x65);\n    let mut x71: u64 = 0;\n    let mut x72: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x71, &mut x72, x70, x66, x63);\n    let mut x73: u64 = 0;\n    let mut x74: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x73, &mut x74, x72, x64, x61);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x75, &mut x76, x74, x62, x1);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x77, &mut x78, 0x0, x49, x67);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x79, &mut x80, x78, x51, x69);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x81, &mut x82, x80, x53, x71);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x83, &mut x84, x82, x55, x73);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x85, &mut x86, x84, x57, x75);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x87, &mut x88, x86, x59, (x76 as u64));\n    let mut x89: u64 = 0;\n    let mut x90: u64 = 0;\n    fiat_p384_mulx_u64(&mut x89, &mut x90, x77, 0x100000001);\n    let mut x91: u64 = 0;\n    let mut x92: u64 = 0;\n    fiat_p384_mulx_u64(&mut x91, &mut x92, x89, 0xffffffffffffffff);\n    let mut x93: u64 = 0;\n    let mut x94: u64 = 0;\n    fiat_p384_mulx_u64(&mut x93, &mut x94, x89, 0xffffffffffffffff);\n    let mut x95: u64 = 0;\n    let mut x96: u64 = 0;\n    fiat_p384_mulx_u64(&mut x95, &mut x96, x89, 0xffffffffffffffff);\n    let mut x97: u64 = 0;\n    let mut x98: u64 = 0;\n    fiat_p384_mulx_u64(&mut x97, &mut x98, x89, 0xfffffffffffffffe);\n    let mut x99: u64 = 0;\n    let mut x100: u64 = 0;\n    fiat_p384_mulx_u64(&mut x99, &mut x100, x89, 0xffffffff00000000);\n    let mut x101: u64 = 0;\n    let mut x102: u64 = 0;\n    fiat_p384_mulx_u64(&mut x101, &mut x102, x89, 0xffffffff);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x103, &mut x104, 0x0, x102, x99);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x105, &mut x106, x104, x100, x97);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x107, &mut x108, x106, x98, x95);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x109, &mut x110, x108, x96, x93);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x111, &mut x112, x110, x94, x91);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x113, &mut x114, 0x0, x77, x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x115, &mut x116, x114, x79, x103);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x117, &mut x118, x116, x81, x105);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x119, &mut x120, x118, x83, x107);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x121, &mut x122, x120, x85, x109);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x123, &mut x124, x122, x87, x111);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x125,\n        &mut x126,\n        x124,\n        ((x88 as u64) + (x60 as u64)),\n        ((x112 as u64) + x92),\n    );\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_p384_mulx_u64(&mut x127, &mut x128, x2, 0x200000000);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_p384_mulx_u64(&mut x129, &mut x130, x2, 0xfffffffe00000000);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_p384_mulx_u64(&mut x131, &mut x132, x2, 0x200000000);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_p384_mulx_u64(&mut x133, &mut x134, x2, 0xfffffffe00000001);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x141, &mut x142, x140, x128, x2);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x143, &mut x144, 0x0, x115, x133);\n    let mut x145: u64 = 0;\n    let mut x146: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x145, &mut x146, x144, x117, x135);\n    let mut x147: u64 = 0;\n    let mut x148: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x147, &mut x148, x146, x119, x137);\n    let mut x149: u64 = 0;\n    let mut x150: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x149, &mut x150, x148, x121, x139);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x151, &mut x152, x150, x123, x141);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x153, &mut x154, x152, x125, (x142 as u64));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_p384_mulx_u64(&mut x155, &mut x156, x143, 0x100000001);\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_p384_mulx_u64(&mut x157, &mut x158, x155, 0xffffffffffffffff);\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_p384_mulx_u64(&mut x159, &mut x160, x155, 0xffffffffffffffff);\n    let mut x161: u64 = 0;\n    let mut x162: u64 = 0;\n    fiat_p384_mulx_u64(&mut x161, &mut x162, x155, 0xffffffffffffffff);\n    let mut x163: u64 = 0;\n    let mut x164: u64 = 0;\n    fiat_p384_mulx_u64(&mut x163, &mut x164, x155, 0xfffffffffffffffe);\n    let mut x165: u64 = 0;\n    let mut x166: u64 = 0;\n    fiat_p384_mulx_u64(&mut x165, &mut x166, x155, 0xffffffff00000000);\n    let mut x167: u64 = 0;\n    let mut x168: u64 = 0;\n    fiat_p384_mulx_u64(&mut x167, &mut x168, x155, 0xffffffff);\n    let mut x169: u64 = 0;\n    let mut x170: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x169, &mut x170, 0x0, x168, x165);\n    let mut x171: u64 = 0;\n    let mut x172: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x171, &mut x172, x170, x166, x163);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x173, &mut x174, x172, x164, x161);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x175, &mut x176, x174, x162, x159);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x177, &mut x178, x176, x160, x157);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x179, &mut x180, 0x0, x143, x167);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x181, &mut x182, x180, x145, x169);\n    let mut x183: u64 = 0;\n    let mut x184: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x183, &mut x184, x182, x147, x171);\n    let mut x185: u64 = 0;\n    let mut x186: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x185, &mut x186, x184, x149, x173);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x187, &mut x188, x186, x151, x175);\n    let mut x189: u64 = 0;\n    let mut x190: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x189, &mut x190, x188, x153, x177);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x191,\n        &mut x192,\n        x190,\n        ((x154 as u64) + (x126 as u64)),\n        ((x178 as u64) + x158),\n    );\n    let mut x193: u64 = 0;\n    let mut x194: u64 = 0;\n    fiat_p384_mulx_u64(&mut x193, &mut x194, x3, 0x200000000);\n    let mut x195: u64 = 0;\n    let mut x196: u64 = 0;\n    fiat_p384_mulx_u64(&mut x195, &mut x196, x3, 0xfffffffe00000000);\n    let mut x197: u64 = 0;\n    let mut x198: u64 = 0;\n    fiat_p384_mulx_u64(&mut x197, &mut x198, x3, 0x200000000);\n    let mut x199: u64 = 0;\n    let mut x200: u64 = 0;\n    fiat_p384_mulx_u64(&mut x199, &mut x200, x3, 0xfffffffe00000001);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x201, &mut x202, 0x0, x200, x197);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x203, &mut x204, x202, x198, x195);\n    let mut x205: u64 = 0;\n    let mut x206: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x205, &mut x206, x204, x196, x193);\n    let mut x207: u64 = 0;\n    let mut x208: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x207, &mut x208, x206, x194, x3);\n    let mut x209: u64 = 0;\n    let mut x210: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x209, &mut x210, 0x0, x181, x199);\n    let mut x211: u64 = 0;\n    let mut x212: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x211, &mut x212, x210, x183, x201);\n    let mut x213: u64 = 0;\n    let mut x214: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x213, &mut x214, x212, x185, x203);\n    let mut x215: u64 = 0;\n    let mut x216: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x215, &mut x216, x214, x187, x205);\n    let mut x217: u64 = 0;\n    let mut x218: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x217, &mut x218, x216, x189, x207);\n    let mut x219: u64 = 0;\n    let mut x220: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x219, &mut x220, x218, x191, (x208 as u64));\n    let mut x221: u64 = 0;\n    let mut x222: u64 = 0;\n    fiat_p384_mulx_u64(&mut x221, &mut x222, x209, 0x100000001);\n    let mut x223: u64 = 0;\n    let mut x224: u64 = 0;\n    fiat_p384_mulx_u64(&mut x223, &mut x224, x221, 0xffffffffffffffff);\n    let mut x225: u64 = 0;\n    let mut x226: u64 = 0;\n    fiat_p384_mulx_u64(&mut x225, &mut x226, x221, 0xffffffffffffffff);\n    let mut x227: u64 = 0;\n    let mut x228: u64 = 0;\n    fiat_p384_mulx_u64(&mut x227, &mut x228, x221, 0xffffffffffffffff);\n    let mut x229: u64 = 0;\n    let mut x230: u64 = 0;\n    fiat_p384_mulx_u64(&mut x229, &mut x230, x221, 0xfffffffffffffffe);\n    let mut x231: u64 = 0;\n    let mut x232: u64 = 0;\n    fiat_p384_mulx_u64(&mut x231, &mut x232, x221, 0xffffffff00000000);\n    let mut x233: u64 = 0;\n    let mut x234: u64 = 0;\n    fiat_p384_mulx_u64(&mut x233, &mut x234, x221, 0xffffffff);\n    let mut x235: u64 = 0;\n    let mut x236: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x235, &mut x236, 0x0, x234, x231);\n    let mut x237: u64 = 0;\n    let mut x238: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x237, &mut x238, x236, x232, x229);\n    let mut x239: u64 = 0;\n    let mut x240: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x239, &mut x240, x238, x230, x227);\n    let mut x241: u64 = 0;\n    let mut x242: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x241, &mut x242, x240, x228, x225);\n    let mut x243: u64 = 0;\n    let mut x244: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x243, &mut x244, x242, x226, x223);\n    let mut x245: u64 = 0;\n    let mut x246: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x245, &mut x246, 0x0, x209, x233);\n    let mut x247: u64 = 0;\n    let mut x248: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x247, &mut x248, x246, x211, x235);\n    let mut x249: u64 = 0;\n    let mut x250: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x249, &mut x250, x248, x213, x237);\n    let mut x251: u64 = 0;\n    let mut x252: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x251, &mut x252, x250, x215, x239);\n    let mut x253: u64 = 0;\n    let mut x254: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x253, &mut x254, x252, x217, x241);\n    let mut x255: u64 = 0;\n    let mut x256: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x255, &mut x256, x254, x219, x243);\n    let mut x257: u64 = 0;\n    let mut x258: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x257,\n        &mut x258,\n        x256,\n        ((x220 as u64) + (x192 as u64)),\n        ((x244 as u64) + x224),\n    );\n    let mut x259: u64 = 0;\n    let mut x260: u64 = 0;\n    fiat_p384_mulx_u64(&mut x259, &mut x260, x4, 0x200000000);\n    let mut x261: u64 = 0;\n    let mut x262: u64 = 0;\n    fiat_p384_mulx_u64(&mut x261, &mut x262, x4, 0xfffffffe00000000);\n    let mut x263: u64 = 0;\n    let mut x264: u64 = 0;\n    fiat_p384_mulx_u64(&mut x263, &mut x264, x4, 0x200000000);\n    let mut x265: u64 = 0;\n    let mut x266: u64 = 0;\n    fiat_p384_mulx_u64(&mut x265, &mut x266, x4, 0xfffffffe00000001);\n    let mut x267: u64 = 0;\n    let mut x268: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x267, &mut x268, 0x0, x266, x263);\n    let mut x269: u64 = 0;\n    let mut x270: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x269, &mut x270, x268, x264, x261);\n    let mut x271: u64 = 0;\n    let mut x272: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x271, &mut x272, x270, x262, x259);\n    let mut x273: u64 = 0;\n    let mut x274: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x273, &mut x274, x272, x260, x4);\n    let mut x275: u64 = 0;\n    let mut x276: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x275, &mut x276, 0x0, x247, x265);\n    let mut x277: u64 = 0;\n    let mut x278: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x277, &mut x278, x276, x249, x267);\n    let mut x279: u64 = 0;\n    let mut x280: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x279, &mut x280, x278, x251, x269);\n    let mut x281: u64 = 0;\n    let mut x282: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x281, &mut x282, x280, x253, x271);\n    let mut x283: u64 = 0;\n    let mut x284: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x283, &mut x284, x282, x255, x273);\n    let mut x285: u64 = 0;\n    let mut x286: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x285, &mut x286, x284, x257, (x274 as u64));\n    let mut x287: u64 = 0;\n    let mut x288: u64 = 0;\n    fiat_p384_mulx_u64(&mut x287, &mut x288, x275, 0x100000001);\n    let mut x289: u64 = 0;\n    let mut x290: u64 = 0;\n    fiat_p384_mulx_u64(&mut x289, &mut x290, x287, 0xffffffffffffffff);\n    let mut x291: u64 = 0;\n    let mut x292: u64 = 0;\n    fiat_p384_mulx_u64(&mut x291, &mut x292, x287, 0xffffffffffffffff);\n    let mut x293: u64 = 0;\n    let mut x294: u64 = 0;\n    fiat_p384_mulx_u64(&mut x293, &mut x294, x287, 0xffffffffffffffff);\n    let mut x295: u64 = 0;\n    let mut x296: u64 = 0;\n    fiat_p384_mulx_u64(&mut x295, &mut x296, x287, 0xfffffffffffffffe);\n    let mut x297: u64 = 0;\n    let mut x298: u64 = 0;\n    fiat_p384_mulx_u64(&mut x297, &mut x298, x287, 0xffffffff00000000);\n    let mut x299: u64 = 0;\n    let mut x300: u64 = 0;\n    fiat_p384_mulx_u64(&mut x299, &mut x300, x287, 0xffffffff);\n    let mut x301: u64 = 0;\n    let mut x302: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x301, &mut x302, 0x0, x300, x297);\n    let mut x303: u64 = 0;\n    let mut x304: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x303, &mut x304, x302, x298, x295);\n    let mut x305: u64 = 0;\n    let mut x306: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x305, &mut x306, x304, x296, x293);\n    let mut x307: u64 = 0;\n    let mut x308: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x307, &mut x308, x306, x294, x291);\n    let mut x309: u64 = 0;\n    let mut x310: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x309, &mut x310, x308, x292, x289);\n    let mut x311: u64 = 0;\n    let mut x312: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x311, &mut x312, 0x0, x275, x299);\n    let mut x313: u64 = 0;\n    let mut x314: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x313, &mut x314, x312, x277, x301);\n    let mut x315: u64 = 0;\n    let mut x316: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x315, &mut x316, x314, x279, x303);\n    let mut x317: u64 = 0;\n    let mut x318: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x317, &mut x318, x316, x281, x305);\n    let mut x319: u64 = 0;\n    let mut x320: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x319, &mut x320, x318, x283, x307);\n    let mut x321: u64 = 0;\n    let mut x322: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x321, &mut x322, x320, x285, x309);\n    let mut x323: u64 = 0;\n    let mut x324: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x323,\n        &mut x324,\n        x322,\n        ((x286 as u64) + (x258 as u64)),\n        ((x310 as u64) + x290),\n    );\n    let mut x325: u64 = 0;\n    let mut x326: u64 = 0;\n    fiat_p384_mulx_u64(&mut x325, &mut x326, x5, 0x200000000);\n    let mut x327: u64 = 0;\n    let mut x328: u64 = 0;\n    fiat_p384_mulx_u64(&mut x327, &mut x328, x5, 0xfffffffe00000000);\n    let mut x329: u64 = 0;\n    let mut x330: u64 = 0;\n    fiat_p384_mulx_u64(&mut x329, &mut x330, x5, 0x200000000);\n    let mut x331: u64 = 0;\n    let mut x332: u64 = 0;\n    fiat_p384_mulx_u64(&mut x331, &mut x332, x5, 0xfffffffe00000001);\n    let mut x333: u64 = 0;\n    let mut x334: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x333, &mut x334, 0x0, x332, x329);\n    let mut x335: u64 = 0;\n    let mut x336: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x335, &mut x336, x334, x330, x327);\n    let mut x337: u64 = 0;\n    let mut x338: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x337, &mut x338, x336, x328, x325);\n    let mut x339: u64 = 0;\n    let mut x340: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x339, &mut x340, x338, x326, x5);\n    let mut x341: u64 = 0;\n    let mut x342: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x341, &mut x342, 0x0, x313, x331);\n    let mut x343: u64 = 0;\n    let mut x344: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x343, &mut x344, x342, x315, x333);\n    let mut x345: u64 = 0;\n    let mut x346: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x345, &mut x346, x344, x317, x335);\n    let mut x347: u64 = 0;\n    let mut x348: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x347, &mut x348, x346, x319, x337);\n    let mut x349: u64 = 0;\n    let mut x350: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x349, &mut x350, x348, x321, x339);\n    let mut x351: u64 = 0;\n    let mut x352: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x351, &mut x352, x350, x323, (x340 as u64));\n    let mut x353: u64 = 0;\n    let mut x354: u64 = 0;\n    fiat_p384_mulx_u64(&mut x353, &mut x354, x341, 0x100000001);\n    let mut x355: u64 = 0;\n    let mut x356: u64 = 0;\n    fiat_p384_mulx_u64(&mut x355, &mut x356, x353, 0xffffffffffffffff);\n    let mut x357: u64 = 0;\n    let mut x358: u64 = 0;\n    fiat_p384_mulx_u64(&mut x357, &mut x358, x353, 0xffffffffffffffff);\n    let mut x359: u64 = 0;\n    let mut x360: u64 = 0;\n    fiat_p384_mulx_u64(&mut x359, &mut x360, x353, 0xffffffffffffffff);\n    let mut x361: u64 = 0;\n    let mut x362: u64 = 0;\n    fiat_p384_mulx_u64(&mut x361, &mut x362, x353, 0xfffffffffffffffe);\n    let mut x363: u64 = 0;\n    let mut x364: u64 = 0;\n    fiat_p384_mulx_u64(&mut x363, &mut x364, x353, 0xffffffff00000000);\n    let mut x365: u64 = 0;\n    let mut x366: u64 = 0;\n    fiat_p384_mulx_u64(&mut x365, &mut x366, x353, 0xffffffff);\n    let mut x367: u64 = 0;\n    let mut x368: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x367, &mut x368, 0x0, x366, x363);\n    let mut x369: u64 = 0;\n    let mut x370: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x369, &mut x370, x368, x364, x361);\n    let mut x371: u64 = 0;\n    let mut x372: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x371, &mut x372, x370, x362, x359);\n    let mut x373: u64 = 0;\n    let mut x374: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x373, &mut x374, x372, x360, x357);\n    let mut x375: u64 = 0;\n    let mut x376: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x375, &mut x376, x374, x358, x355);\n    let mut x377: u64 = 0;\n    let mut x378: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x377, &mut x378, 0x0, x341, x365);\n    let mut x379: u64 = 0;\n    let mut x380: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x379, &mut x380, x378, x343, x367);\n    let mut x381: u64 = 0;\n    let mut x382: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x381, &mut x382, x380, x345, x369);\n    let mut x383: u64 = 0;\n    let mut x384: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x383, &mut x384, x382, x347, x371);\n    let mut x385: u64 = 0;\n    let mut x386: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x385, &mut x386, x384, x349, x373);\n    let mut x387: u64 = 0;\n    let mut x388: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x387, &mut x388, x386, x351, x375);\n    let mut x389: u64 = 0;\n    let mut x390: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(\n        &mut x389,\n        &mut x390,\n        x388,\n        ((x352 as u64) + (x324 as u64)),\n        ((x376 as u64) + x356),\n    );\n    let mut x391: u64 = 0;\n    let mut x392: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x391, &mut x392, 0x0, x379, 0xffffffff);\n    let mut x393: u64 = 0;\n    let mut x394: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x393, &mut x394, x392, x381, 0xffffffff00000000);\n    let mut x395: u64 = 0;\n    let mut x396: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x395, &mut x396, x394, x383, 0xfffffffffffffffe);\n    let mut x397: u64 = 0;\n    let mut x398: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x397, &mut x398, x396, x385, 0xffffffffffffffff);\n    let mut x399: u64 = 0;\n    let mut x400: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x399, &mut x400, x398, x387, 0xffffffffffffffff);\n    let mut x401: u64 = 0;\n    let mut x402: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x401, &mut x402, x400, x389, 0xffffffffffffffff);\n    let mut x403: u64 = 0;\n    let mut x404: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x403, &mut x404, x402, (x390 as u64), (0x0 as u64));\n    let mut x405: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x405, x404, x391, x379);\n    let mut x406: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x406, x404, x393, x381);\n    let mut x407: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x407, x404, x395, x383);\n    let mut x408: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x408, x404, x397, x385);\n    let mut x409: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x409, x404, x399, x387);\n    let mut x410: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x410, x404, x401, x389);\n    out1[0] = x405;\n    out1[1] = x406;\n    out1[2] = x407;\n    out1[3] = x408;\n    out1[4] = x409;\n    out1[5] = x410;\n}",
    "display_name": "fiat_p384_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/batch_normalize_slice",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/BatchNormalize/batch_normalize",
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/mul_by_generator",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Curve/batch_normalize"
    ],
    "body": "    fn batch_normalize_slice() {\n        let k: Scalar = Scalar::random(&mut OsRng.unwrap_mut());\n        let l: Scalar = Scalar::random(&mut OsRng.unwrap_mut());\n        let g = ProjectivePoint::mul_by_generator(&k);\n        let h = ProjectivePoint::mul_by_generator(&l);\n\n        let expected = vec![g.to_affine(), h.to_affine()];\n        let scalars = vec![g, h];\n        let mut res: Vec<_> =\n            <ProjectivePoint as BatchNormalize<_>>::batch_normalize(scalars.as_slice());\n        assert_eq!(res, expected);\n\n        <ProjectivePoint as CurveGroup>::batch_normalize(&[g, h], res.as_mut());\n        assert_eq!(res.to_vec(), expected);\n\n        let expected = vec![g.to_affine(), AffinePoint::IDENTITY];\n        let scalars = vec![g, ProjectivePoint::IDENTITY];\n        res = <ProjectivePoint as BatchNormalize<_>>::batch_normalize(scalars.as_slice());\n\n        assert_eq!(res, expected);\n\n        <ProjectivePoint as CurveGroup>::batch_normalize(\n            &[g, ProjectivePoint::IDENTITY],\n            res.as_mut(),\n        );\n        assert_eq!(res.to_vec(), expected);\n    }",
    "display_name": "batch_normalize_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/is_odd",
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_u64",
      "0.14.0_pre arithmetic/field/impl/FieldElement/invert_unchecked",
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_hex"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/s1",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    pub fn s1(&self) -> NonZeroScalar {\n        let mut s1 = self.s1.to_bytes();\n        s1.reverse();\n        NonZeroScalar::new(Scalar::from_bytes(&s1).unwrap()).unwrap()\n    }",
    "display_name": "s1",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/GroupEncoding/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/decompress"
    ],
    "body": "    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        let pt = CompressedDecaf(*(bytes.as_ref()));\n        pt.decompress()\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_sub(\n    out1: &mut fiat_p384_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p384_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p384_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x9, &mut x10, x8, (arg1[4]), (arg2[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x11, &mut x12, x10, (arg1[5]), (arg2[5]));\n    let mut x13: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x13, x12, (0x0 as u64), 0xffffffffffffffff);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x14, &mut x15, 0x0, x1, (x13 & 0xecec196accc52973));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x3, (x13 & 0x581a0db248b0a77a));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x18, &mut x19, x17, x5, (x13 & 0xc7634d81f4372ddf));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x20, &mut x21, x19, x7, x13);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x22, &mut x23, x21, x9, x13);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x24, &mut x25, x23, x11, x13);\n    out1[0] = x14;\n    out1[1] = x16;\n    out1[2] = x18;\n    out1[3] = x20;\n    out1[4] = x22;\n    out1[5] = x24;\n}",
    "display_name": "fiat_p384_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt_der_digest"
    ],
    "body": "    pub fn decrypt_der(&self, ciphertext: &[u8]) -> Result<Vec<u8>> {\n        self.decrypt_der_digest::<Sm3>(ciphertext)\n    }",
    "display_name": "decrypt_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/hash_msg",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn hash_msg(&self, msg: &[&[u8]]) -> Hash {\n        let mut hasher = Sm3::new_with_prefix(self.identity_hash);\n        msg.iter().for_each(|slice| hasher.update(slice));\n        hasher.finalize()\n    }",
    "display_name": "hash_msg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut out = [0; 9];\n        let a = &a.0;\n        let b = &b.0;\n\n        for i in 0..out.len() {\n            out[i] = u64::conditional_select(&a[i], &b[i], choice);\n        }\n\n        Self(fiat_p521_tight_field_element(out))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/impl/fiat_p521_scalar_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/is_zero",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_zero(&self) -> Choice {\n        self.0.is_zero()\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/tests/test_is_on_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/is_on_curve"
    ],
    "body": "    fn test_is_on_curve() {\n        // The twisted edwards basepoint should be on the curve\n        // twisted edwards curve\n        assert_eq!(TWISTED_EDWARDS_BASE_POINT.is_on_curve().unwrap_u8(), 1u8);\n\n        // The goldilocks basepoint should not be\n        let invalid_point = ExtendedPoint {\n            X: GOLDILOCKS_BASE_POINT.X,\n            Y: GOLDILOCKS_BASE_POINT.Y,\n            Z: GOLDILOCKS_BASE_POINT.Z,\n            T: GOLDILOCKS_BASE_POINT.T,\n        };\n        assert_eq!(invalid_point.is_on_curve().unwrap_u8(), 0u8);\n    }",
    "display_name": "test_is_on_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/From::AffinePoint>>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/From::AffinePoint>>/from"
    ],
    "body": "    fn from(value: NonIdentity<AffinePoint<BignP256>>) -> Self {\n        Self::from(&value)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre pke/impl/Cipher/EncodeValue/encode_value",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_value(&self, writer: &mut impl Writer) -> elliptic_curve::pkcs8::der::Result<()> {\n        UintRef::new(&self.x.to_be_bytes())?.encode(writer)?;\n        UintRef::new(&self.y.to_be_bytes())?.encode(writer)?;\n        OctetStringRef::new(self.digest)?.encode(writer)?;\n        OctetStringRef::new(self.cipher)?.encode(writer)?;\n        Ok(())\n    }",
    "display_name": "encode_value",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke.rs",
    "relative_path": "sm2/src/pke.rs",
    "file_name": "pke.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/normalizes_to_zero"
    ],
    "body": "    pub fn normalizes_to_zero(&self) -> Choice {\n        self.0.normalizes_to_zero()\n    }",
    "display_name": "normalizes_to_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/batch_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert",
      "0.14.0_pre.8 arithmetic/scalar/tests/non_zero_scalar"
    ],
    "body": "        fn batch_invert(\n            a in non_zero_scalar(),\n            b in non_zero_scalar(),\n            c in non_zero_scalar(),\n            d in non_zero_scalar(),\n            e in non_zero_scalar(),\n        ) {\n            let scalars: [Scalar; 5] = [*a, *b, *c, *d, *e];\n\n            let inverted_scalars = Scalar::batch_invert(scalars).unwrap();\n\n            for (scalar, inverted_scalar) in scalars.into_iter().zip(inverted_scalars) {\n                assert_eq!(inverted_scalar, scalar.invert().unwrap());\n            }\n        }",
    "display_name": "batch_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_bign256_scalar_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/pow_vartime",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn sqrt(&self) -> CtOption<Self> {\n        // Note: `pow_vartime` is constant-time with respect to `self`\n        let w = self.pow_vartime(&[\n            0x279dce5617e3192a,\n            0xfde737d56d38bcf4,\n            0x07ffffffffffffff,\n            0x07fffffff8000000,\n        ]);\n\n        let mut v = Self::S;\n        let mut x = *self * w;\n        let mut b = x * w;\n        let mut z = Self::ROOT_OF_UNITY;\n\n        for max_v in (1..=Self::S).rev() {\n            let mut k = 1;\n            let mut tmp = b.square();\n            let mut j_less_than_v = Choice::from(1);\n\n            for j in 2..max_v {\n                let tmp_is_one = tmp.ct_eq(&Self::ONE);\n                let squared = Self::conditional_select(&tmp, &z, tmp_is_one).square();\n                tmp = Self::conditional_select(&squared, &tmp, tmp_is_one);\n                let new_z = Self::conditional_select(&z, &squared, tmp_is_one);\n                j_less_than_v &= !j.ct_eq(&v);\n                k = u32::conditional_select(&j, &k, tmp_is_one);\n                z = Self::conditional_select(&z, &new_z, j_less_than_v);\n            }\n\n            let result = x * z;\n            x = Self::conditional_select(&result, &x, b.ct_eq(&Self::ONE));\n            z = z.square();\n            b *= z;\n            v = k;\n        }\n\n        CtOption::new(x, x.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p192_scalar_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_odd(&self) -> Choice {\n        (self.0[0] as u8 & 1).into()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/mul",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/Double/double",
      "projective/impl/ProjectivePoint/Add>/add",
      "projective/impl/ProjectivePoint/Default/default"
    ],
    "body": "    fn mul(&self, k: &Scalar<C>) -> Self\n    where\n        Self: Double,\n    {\n        let k = Into::<C::Uint>::into(*k).to_le_byte_array();\n\n        let mut pc = [Self::default(); 16];\n        pc[0] = Self::IDENTITY;\n        pc[1] = *self;\n\n        for i in 2..16 {\n            pc[i] = if i % 2 == 0 {\n                Double::double(&pc[i / 2])\n            } else {\n                pc[i - 1].add(self)\n            };\n        }\n\n        let mut q = Self::IDENTITY;\n        let mut pos = (<Scalar<C> as PrimeField>::NUM_BITS.div_ceil(8) * 8) as usize - 4;\n\n        loop {\n            let slot = (k[pos >> 3] >> (pos & 7)) & 0xf;\n\n            let mut t = ProjectivePoint::IDENTITY;\n\n            for i in 1..16 {\n                t.conditional_assign(\n                    &pc[i],\n                    Choice::from(((slot as usize ^ i).wrapping_sub(1) >> 8) as u8 & 1),\n                );\n            }\n\n            q = q.add(&t);\n\n            if pos == 0 {\n                break;\n            }\n\n            q = Double::double(&Double::double(&Double::double(&Double::double(&q))));\n            pos -= 4;\n        }\n\n        q\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/projective_identity_addition",
    "statement_type": "function",
    "deps": [],
    "body": "    fn projective_identity_addition() {\n        let identity = ProjectivePoint::IDENTITY;\n        let generator = ProjectivePoint::GENERATOR;\n\n        assert_eq!(identity + &generator, generator);\n        assert_eq!(generator + &identity, generator);\n    }",
    "display_name": "projective_identity_addition",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine_internal",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/new"
    ],
    "body": "    pub(super) fn to_affine_internal(self, zinv: FieldElement) -> AffinePoint {\n        let x = self.x * &zinv;\n        let y = self.y * &zinv;\n        AffinePoint::new(x.normalize(), y.normalize())\n    }",
    "display_name": "to_affine_internal",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/from_bytes"
    ],
    "body": "    fn try_from(value: &PublicKeyBytes) -> Result<Self, Self::Error> {\n        VerifyingKey::from_bytes(&value.0).map_err(|_| pkcs8::spki::Error::KeyMalformed)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "affine/impl/AffinePoint/DecompressPoint/decompress",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decompress(x_bytes: &FieldBytes<C>, y_is_odd: Choice) -> CtOption<Self> {\n        C::FieldElement::from_repr(*x_bytes).and_then(|x| {\n            let alpha = x * &x * &x + &(C::EQUATION_A * &x) + &C::EQUATION_B;\n            let beta = alpha.sqrt();\n\n            beta.map(|beta| {\n                let y = C::FieldElement::conditional_select(\n                    &-beta,\n                    &beta,\n                    beta.is_odd().ct_eq(&y_is_odd),\n                );\n\n                Self { x, y, infinity: 0 }\n            })\n        })\n    }",
    "display_name": "decompress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre encode_pkcs8_public_key_to_der",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_public_key_to_der() {\n    let original_public_key =\n        sm2::PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    let reencoded_public_key = original_public_key.to_public_key_der().unwrap();\n    assert_eq!(reencoded_public_key.as_ref(), &PKCS8_PUBLIC_KEY_DER[..]);\n}",
    "display_name": "encode_pkcs8_public_key_to_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "affine/impl/AffinePoint/GroupEncoding/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/GroupEncoding/from_bytes"
    ],
    "body": "    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // No unchecked conversion possible for compressed points\n        Self::from_bytes(bytes)\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/CofactorGroup/clear_cofactor",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/double"
    ],
    "body": "    fn clear_cofactor(&self) -> Self::Subgroup {\n        self.double().double()\n    }",
    "display_name": "clear_cofactor",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl//u8; 57//From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(value: CompressedEdwardsY) -> Self {\n        value.0\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/from_uniform_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes",
      "0.14.0_pre.1 field/element/impl/FieldElement/map_to_curve_decaf448",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/add"
    ],
    "body": "    pub fn from_uniform_bytes(bytes: &[u8; 112]) -> Self {\n        let lo: [u8; 56] = (&bytes[..56])\n            .try_into()\n            .expect(\"how does the slice have an incorrect length\");\n        let hi: [u8; 56] = (&bytes[56..])\n            .try_into()\n            .expect(\"how does the slice have an incorrect length\");\n\n        let u0 = FieldElement::from_bytes(&lo);\n        let u1 = FieldElement::from_bytes(&hi);\n        let q0 = u0.map_to_curve_decaf448();\n        let q1 = u1.map_to_curve_decaf448();\n        Self(q0.add(&q1))\n    }",
    "display_name": "from_uniform_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Shr/shr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime"
    ],
    "body": "    fn shr(self, rhs: usize) -> Self::Output {\n        self.shr_vartime(rhs as u32)\n    }",
    "display_name": "shr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_point_mul"
    ],
    "body": "fn bench_point(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"point operations\");\n    bench_point_mul(&mut group);\n    group.finish();\n}",
    "display_name": "bench_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Group/generator",
    "statement_type": "function",
    "deps": [],
    "body": "    fn generator() -> Self {\n        Self::GENERATOR\n    }",
    "display_name": "generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_mulx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_mul(\n    out1: &mut fiat_p384_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p384_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p384_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[0]);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x7, &mut x8, x6, (arg2[5]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x9, &mut x10, x6, (arg2[4]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x11, &mut x12, x6, (arg2[3]));\n    let mut x13: u64 = 0;\n    let mut x14: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x13, &mut x14, x6, (arg2[2]));\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x15, &mut x16, x6, (arg2[1]));\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x17, &mut x18, x6, (arg2[0]));\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x19, &mut x20, 0x0, x18, x15);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x21, &mut x22, x20, x16, x13);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x23, &mut x24, x22, x14, x11);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x25, &mut x26, x24, x12, x9);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x27, &mut x28, x26, x10, x7);\n    let x29: u64 = ((x28 as u64) + x8);\n    let mut x30: u64 = 0;\n    let mut x31: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x30, &mut x31, x17, 0x6ed46089e88fdc45);\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x32, &mut x33, x30, 0xffffffffffffffff);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x34, &mut x35, x30, 0xffffffffffffffff);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x36, &mut x37, x30, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x38, &mut x39, x30, 0xc7634d81f4372ddf);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x40, &mut x41, x30, 0x581a0db248b0a77a);\n    let mut x42: u64 = 0;\n    let mut x43: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x42, &mut x43, x30, 0xecec196accc52973);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x44, &mut x45, 0x0, x43, x40);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x46, &mut x47, x45, x41, x38);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x48, &mut x49, x47, x39, x36);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x50, &mut x51, x49, x37, x34);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x52, &mut x53, x51, x35, x32);\n    let x54: u64 = ((x53 as u64) + x33);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x55, &mut x56, 0x0, x17, x42);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x19, x44);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x21, x46);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x61, &mut x62, x60, x23, x48);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x63, &mut x64, x62, x25, x50);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x65, &mut x66, x64, x27, x52);\n    let mut x67: u64 = 0;\n    let mut x68: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x67, &mut x68, x66, x29, x54);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x69, &mut x70, x1, (arg2[5]));\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x71, &mut x72, x1, (arg2[4]));\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x73, &mut x74, x1, (arg2[3]));\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x75, &mut x76, x1, (arg2[2]));\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x77, &mut x78, x1, (arg2[1]));\n    let mut x79: u64 = 0;\n    let mut x80: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x79, &mut x80, x1, (arg2[0]));\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x81, &mut x82, 0x0, x80, x77);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x83, &mut x84, x82, x78, x75);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x85, &mut x86, x84, x76, x73);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x87, &mut x88, x86, x74, x71);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x89, &mut x90, x88, x72, x69);\n    let x91: u64 = ((x90 as u64) + x70);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x92, &mut x93, 0x0, x57, x79);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x59, x81);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x61, x83);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x63, x85);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x65, x87);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x102, &mut x103, x101, x67, x89);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x104, &mut x105, x103, (x68 as u64), x91);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x106, &mut x107, x92, 0x6ed46089e88fdc45);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x108, &mut x109, x106, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x110, &mut x111, x106, 0xffffffffffffffff);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x112, &mut x113, x106, 0xffffffffffffffff);\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x114, &mut x115, x106, 0xc7634d81f4372ddf);\n    let mut x116: u64 = 0;\n    let mut x117: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x116, &mut x117, x106, 0x581a0db248b0a77a);\n    let mut x118: u64 = 0;\n    let mut x119: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x118, &mut x119, x106, 0xecec196accc52973);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x120, &mut x121, 0x0, x119, x116);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x117, x114);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x124, &mut x125, x123, x115, x112);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x126, &mut x127, x125, x113, x110);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x128, &mut x129, x127, x111, x108);\n    let x130: u64 = ((x129 as u64) + x109);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x131, &mut x132, 0x0, x92, x118);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x133, &mut x134, x132, x94, x120);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x135, &mut x136, x134, x96, x122);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x98, x124);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x100, x126);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x141, &mut x142, x140, x102, x128);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x143, &mut x144, x142, x104, x130);\n    let x145: u64 = ((x144 as u64) + (x105 as u64));\n    let mut x146: u64 = 0;\n    let mut x147: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x146, &mut x147, x2, (arg2[5]));\n    let mut x148: u64 = 0;\n    let mut x149: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x148, &mut x149, x2, (arg2[4]));\n    let mut x150: u64 = 0;\n    let mut x151: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x150, &mut x151, x2, (arg2[3]));\n    let mut x152: u64 = 0;\n    let mut x153: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x152, &mut x153, x2, (arg2[2]));\n    let mut x154: u64 = 0;\n    let mut x155: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x154, &mut x155, x2, (arg2[1]));\n    let mut x156: u64 = 0;\n    let mut x157: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x156, &mut x157, x2, (arg2[0]));\n    let mut x158: u64 = 0;\n    let mut x159: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x158, &mut x159, 0x0, x157, x154);\n    let mut x160: u64 = 0;\n    let mut x161: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x160, &mut x161, x159, x155, x152);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x162, &mut x163, x161, x153, x150);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x164, &mut x165, x163, x151, x148);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x166, &mut x167, x165, x149, x146);\n    let x168: u64 = ((x167 as u64) + x147);\n    let mut x169: u64 = 0;\n    let mut x170: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x169, &mut x170, 0x0, x133, x156);\n    let mut x171: u64 = 0;\n    let mut x172: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x171, &mut x172, x170, x135, x158);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x173, &mut x174, x172, x137, x160);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x175, &mut x176, x174, x139, x162);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x177, &mut x178, x176, x141, x164);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x179, &mut x180, x178, x143, x166);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x181, &mut x182, x180, x145, x168);\n    let mut x183: u64 = 0;\n    let mut x184: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x183, &mut x184, x169, 0x6ed46089e88fdc45);\n    let mut x185: u64 = 0;\n    let mut x186: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x185, &mut x186, x183, 0xffffffffffffffff);\n    let mut x187: u64 = 0;\n    let mut x188: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x187, &mut x188, x183, 0xffffffffffffffff);\n    let mut x189: u64 = 0;\n    let mut x190: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x189, &mut x190, x183, 0xffffffffffffffff);\n    let mut x191: u64 = 0;\n    let mut x192: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x191, &mut x192, x183, 0xc7634d81f4372ddf);\n    let mut x193: u64 = 0;\n    let mut x194: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x193, &mut x194, x183, 0x581a0db248b0a77a);\n    let mut x195: u64 = 0;\n    let mut x196: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x195, &mut x196, x183, 0xecec196accc52973);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x197, &mut x198, 0x0, x196, x193);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x194, x191);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x192, x189);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x190, x187);\n    let mut x205: u64 = 0;\n    let mut x206: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x205, &mut x206, x204, x188, x185);\n    let x207: u64 = ((x206 as u64) + x186);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x208, &mut x209, 0x0, x169, x195);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x210, &mut x211, x209, x171, x197);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x212, &mut x213, x211, x173, x199);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x214, &mut x215, x213, x175, x201);\n    let mut x216: u64 = 0;\n    let mut x217: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x216, &mut x217, x215, x177, x203);\n    let mut x218: u64 = 0;\n    let mut x219: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x218, &mut x219, x217, x179, x205);\n    let mut x220: u64 = 0;\n    let mut x221: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x220, &mut x221, x219, x181, x207);\n    let x222: u64 = ((x221 as u64) + (x182 as u64));\n    let mut x223: u64 = 0;\n    let mut x224: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x223, &mut x224, x3, (arg2[5]));\n    let mut x225: u64 = 0;\n    let mut x226: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x225, &mut x226, x3, (arg2[4]));\n    let mut x227: u64 = 0;\n    let mut x228: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x227, &mut x228, x3, (arg2[3]));\n    let mut x229: u64 = 0;\n    let mut x230: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x229, &mut x230, x3, (arg2[2]));\n    let mut x231: u64 = 0;\n    let mut x232: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x231, &mut x232, x3, (arg2[1]));\n    let mut x233: u64 = 0;\n    let mut x234: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x233, &mut x234, x3, (arg2[0]));\n    let mut x235: u64 = 0;\n    let mut x236: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x235, &mut x236, 0x0, x234, x231);\n    let mut x237: u64 = 0;\n    let mut x238: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x237, &mut x238, x236, x232, x229);\n    let mut x239: u64 = 0;\n    let mut x240: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x239, &mut x240, x238, x230, x227);\n    let mut x241: u64 = 0;\n    let mut x242: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x241, &mut x242, x240, x228, x225);\n    let mut x243: u64 = 0;\n    let mut x244: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x243, &mut x244, x242, x226, x223);\n    let x245: u64 = ((x244 as u64) + x224);\n    let mut x246: u64 = 0;\n    let mut x247: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x246, &mut x247, 0x0, x210, x233);\n    let mut x248: u64 = 0;\n    let mut x249: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x248, &mut x249, x247, x212, x235);\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x250, &mut x251, x249, x214, x237);\n    let mut x252: u64 = 0;\n    let mut x253: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x252, &mut x253, x251, x216, x239);\n    let mut x254: u64 = 0;\n    let mut x255: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x254, &mut x255, x253, x218, x241);\n    let mut x256: u64 = 0;\n    let mut x257: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x256, &mut x257, x255, x220, x243);\n    let mut x258: u64 = 0;\n    let mut x259: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x258, &mut x259, x257, x222, x245);\n    let mut x260: u64 = 0;\n    let mut x261: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x260, &mut x261, x246, 0x6ed46089e88fdc45);\n    let mut x262: u64 = 0;\n    let mut x263: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x262, &mut x263, x260, 0xffffffffffffffff);\n    let mut x264: u64 = 0;\n    let mut x265: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x264, &mut x265, x260, 0xffffffffffffffff);\n    let mut x266: u64 = 0;\n    let mut x267: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x266, &mut x267, x260, 0xffffffffffffffff);\n    let mut x268: u64 = 0;\n    let mut x269: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x268, &mut x269, x260, 0xc7634d81f4372ddf);\n    let mut x270: u64 = 0;\n    let mut x271: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x270, &mut x271, x260, 0x581a0db248b0a77a);\n    let mut x272: u64 = 0;\n    let mut x273: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x272, &mut x273, x260, 0xecec196accc52973);\n    let mut x274: u64 = 0;\n    let mut x275: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x274, &mut x275, 0x0, x273, x270);\n    let mut x276: u64 = 0;\n    let mut x277: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x276, &mut x277, x275, x271, x268);\n    let mut x278: u64 = 0;\n    let mut x279: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x278, &mut x279, x277, x269, x266);\n    let mut x280: u64 = 0;\n    let mut x281: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x280, &mut x281, x279, x267, x264);\n    let mut x282: u64 = 0;\n    let mut x283: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x282, &mut x283, x281, x265, x262);\n    let x284: u64 = ((x283 as u64) + x263);\n    let mut x285: u64 = 0;\n    let mut x286: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x285, &mut x286, 0x0, x246, x272);\n    let mut x287: u64 = 0;\n    let mut x288: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x287, &mut x288, x286, x248, x274);\n    let mut x289: u64 = 0;\n    let mut x290: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x289, &mut x290, x288, x250, x276);\n    let mut x291: u64 = 0;\n    let mut x292: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x291, &mut x292, x290, x252, x278);\n    let mut x293: u64 = 0;\n    let mut x294: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x293, &mut x294, x292, x254, x280);\n    let mut x295: u64 = 0;\n    let mut x296: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x295, &mut x296, x294, x256, x282);\n    let mut x297: u64 = 0;\n    let mut x298: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x297, &mut x298, x296, x258, x284);\n    let x299: u64 = ((x298 as u64) + (x259 as u64));\n    let mut x300: u64 = 0;\n    let mut x301: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x300, &mut x301, x4, (arg2[5]));\n    let mut x302: u64 = 0;\n    let mut x303: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x302, &mut x303, x4, (arg2[4]));\n    let mut x304: u64 = 0;\n    let mut x305: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x304, &mut x305, x4, (arg2[3]));\n    let mut x306: u64 = 0;\n    let mut x307: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x306, &mut x307, x4, (arg2[2]));\n    let mut x308: u64 = 0;\n    let mut x309: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x308, &mut x309, x4, (arg2[1]));\n    let mut x310: u64 = 0;\n    let mut x311: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x310, &mut x311, x4, (arg2[0]));\n    let mut x312: u64 = 0;\n    let mut x313: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x312, &mut x313, 0x0, x311, x308);\n    let mut x314: u64 = 0;\n    let mut x315: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x314, &mut x315, x313, x309, x306);\n    let mut x316: u64 = 0;\n    let mut x317: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x316, &mut x317, x315, x307, x304);\n    let mut x318: u64 = 0;\n    let mut x319: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x318, &mut x319, x317, x305, x302);\n    let mut x320: u64 = 0;\n    let mut x321: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x320, &mut x321, x319, x303, x300);\n    let x322: u64 = ((x321 as u64) + x301);\n    let mut x323: u64 = 0;\n    let mut x324: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x323, &mut x324, 0x0, x287, x310);\n    let mut x325: u64 = 0;\n    let mut x326: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x325, &mut x326, x324, x289, x312);\n    let mut x327: u64 = 0;\n    let mut x328: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x327, &mut x328, x326, x291, x314);\n    let mut x329: u64 = 0;\n    let mut x330: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x329, &mut x330, x328, x293, x316);\n    let mut x331: u64 = 0;\n    let mut x332: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x331, &mut x332, x330, x295, x318);\n    let mut x333: u64 = 0;\n    let mut x334: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x333, &mut x334, x332, x297, x320);\n    let mut x335: u64 = 0;\n    let mut x336: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x335, &mut x336, x334, x299, x322);\n    let mut x337: u64 = 0;\n    let mut x338: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x337, &mut x338, x323, 0x6ed46089e88fdc45);\n    let mut x339: u64 = 0;\n    let mut x340: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x339, &mut x340, x337, 0xffffffffffffffff);\n    let mut x341: u64 = 0;\n    let mut x342: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x341, &mut x342, x337, 0xffffffffffffffff);\n    let mut x343: u64 = 0;\n    let mut x344: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x343, &mut x344, x337, 0xffffffffffffffff);\n    let mut x345: u64 = 0;\n    let mut x346: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x345, &mut x346, x337, 0xc7634d81f4372ddf);\n    let mut x347: u64 = 0;\n    let mut x348: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x347, &mut x348, x337, 0x581a0db248b0a77a);\n    let mut x349: u64 = 0;\n    let mut x350: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x349, &mut x350, x337, 0xecec196accc52973);\n    let mut x351: u64 = 0;\n    let mut x352: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x351, &mut x352, 0x0, x350, x347);\n    let mut x353: u64 = 0;\n    let mut x354: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x353, &mut x354, x352, x348, x345);\n    let mut x355: u64 = 0;\n    let mut x356: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x355, &mut x356, x354, x346, x343);\n    let mut x357: u64 = 0;\n    let mut x358: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x357, &mut x358, x356, x344, x341);\n    let mut x359: u64 = 0;\n    let mut x360: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x359, &mut x360, x358, x342, x339);\n    let x361: u64 = ((x360 as u64) + x340);\n    let mut x362: u64 = 0;\n    let mut x363: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x362, &mut x363, 0x0, x323, x349);\n    let mut x364: u64 = 0;\n    let mut x365: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x364, &mut x365, x363, x325, x351);\n    let mut x366: u64 = 0;\n    let mut x367: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x366, &mut x367, x365, x327, x353);\n    let mut x368: u64 = 0;\n    let mut x369: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x368, &mut x369, x367, x329, x355);\n    let mut x370: u64 = 0;\n    let mut x371: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x370, &mut x371, x369, x331, x357);\n    let mut x372: u64 = 0;\n    let mut x373: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x372, &mut x373, x371, x333, x359);\n    let mut x374: u64 = 0;\n    let mut x375: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x374, &mut x375, x373, x335, x361);\n    let x376: u64 = ((x375 as u64) + (x336 as u64));\n    let mut x377: u64 = 0;\n    let mut x378: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x377, &mut x378, x5, (arg2[5]));\n    let mut x379: u64 = 0;\n    let mut x380: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x379, &mut x380, x5, (arg2[4]));\n    let mut x381: u64 = 0;\n    let mut x382: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x381, &mut x382, x5, (arg2[3]));\n    let mut x383: u64 = 0;\n    let mut x384: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x383, &mut x384, x5, (arg2[2]));\n    let mut x385: u64 = 0;\n    let mut x386: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x385, &mut x386, x5, (arg2[1]));\n    let mut x387: u64 = 0;\n    let mut x388: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x387, &mut x388, x5, (arg2[0]));\n    let mut x389: u64 = 0;\n    let mut x390: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x389, &mut x390, 0x0, x388, x385);\n    let mut x391: u64 = 0;\n    let mut x392: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x391, &mut x392, x390, x386, x383);\n    let mut x393: u64 = 0;\n    let mut x394: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x393, &mut x394, x392, x384, x381);\n    let mut x395: u64 = 0;\n    let mut x396: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x395, &mut x396, x394, x382, x379);\n    let mut x397: u64 = 0;\n    let mut x398: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x397, &mut x398, x396, x380, x377);\n    let x399: u64 = ((x398 as u64) + x378);\n    let mut x400: u64 = 0;\n    let mut x401: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x400, &mut x401, 0x0, x364, x387);\n    let mut x402: u64 = 0;\n    let mut x403: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x402, &mut x403, x401, x366, x389);\n    let mut x404: u64 = 0;\n    let mut x405: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x404, &mut x405, x403, x368, x391);\n    let mut x406: u64 = 0;\n    let mut x407: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x406, &mut x407, x405, x370, x393);\n    let mut x408: u64 = 0;\n    let mut x409: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x408, &mut x409, x407, x372, x395);\n    let mut x410: u64 = 0;\n    let mut x411: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x410, &mut x411, x409, x374, x397);\n    let mut x412: u64 = 0;\n    let mut x413: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x412, &mut x413, x411, x376, x399);\n    let mut x414: u64 = 0;\n    let mut x415: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x414, &mut x415, x400, 0x6ed46089e88fdc45);\n    let mut x416: u64 = 0;\n    let mut x417: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x416, &mut x417, x414, 0xffffffffffffffff);\n    let mut x418: u64 = 0;\n    let mut x419: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x418, &mut x419, x414, 0xffffffffffffffff);\n    let mut x420: u64 = 0;\n    let mut x421: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x420, &mut x421, x414, 0xffffffffffffffff);\n    let mut x422: u64 = 0;\n    let mut x423: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x422, &mut x423, x414, 0xc7634d81f4372ddf);\n    let mut x424: u64 = 0;\n    let mut x425: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x424, &mut x425, x414, 0x581a0db248b0a77a);\n    let mut x426: u64 = 0;\n    let mut x427: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x426, &mut x427, x414, 0xecec196accc52973);\n    let mut x428: u64 = 0;\n    let mut x429: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x428, &mut x429, 0x0, x427, x424);\n    let mut x430: u64 = 0;\n    let mut x431: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x430, &mut x431, x429, x425, x422);\n    let mut x432: u64 = 0;\n    let mut x433: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x432, &mut x433, x431, x423, x420);\n    let mut x434: u64 = 0;\n    let mut x435: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x434, &mut x435, x433, x421, x418);\n    let mut x436: u64 = 0;\n    let mut x437: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x436, &mut x437, x435, x419, x416);\n    let x438: u64 = ((x437 as u64) + x417);\n    let mut x439: u64 = 0;\n    let mut x440: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x439, &mut x440, 0x0, x400, x426);\n    let mut x441: u64 = 0;\n    let mut x442: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x441, &mut x442, x440, x402, x428);\n    let mut x443: u64 = 0;\n    let mut x444: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x443, &mut x444, x442, x404, x430);\n    let mut x445: u64 = 0;\n    let mut x446: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x445, &mut x446, x444, x406, x432);\n    let mut x447: u64 = 0;\n    let mut x448: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x447, &mut x448, x446, x408, x434);\n    let mut x449: u64 = 0;\n    let mut x450: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x449, &mut x450, x448, x410, x436);\n    let mut x451: u64 = 0;\n    let mut x452: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x451, &mut x452, x450, x412, x438);\n    let x453: u64 = ((x452 as u64) + (x413 as u64));\n    let mut x454: u64 = 0;\n    let mut x455: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x454, &mut x455, 0x0, x441, 0xecec196accc52973);\n    let mut x456: u64 = 0;\n    let mut x457: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x456, &mut x457, x455, x443, 0x581a0db248b0a77a);\n    let mut x458: u64 = 0;\n    let mut x459: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x458, &mut x459, x457, x445, 0xc7634d81f4372ddf);\n    let mut x460: u64 = 0;\n    let mut x461: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x460, &mut x461, x459, x447, 0xffffffffffffffff);\n    let mut x462: u64 = 0;\n    let mut x463: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x462, &mut x463, x461, x449, 0xffffffffffffffff);\n    let mut x464: u64 = 0;\n    let mut x465: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x464, &mut x465, x463, x451, 0xffffffffffffffff);\n    let mut x466: u64 = 0;\n    let mut x467: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x466, &mut x467, x465, x453, (0x0 as u64));\n    let mut x468: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x468, x467, x454, x441);\n    let mut x469: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x469, x467, x456, x443);\n    let mut x470: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x470, x467, x458, x445);\n    let mut x471: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x471, x467, x460, x447);\n    let mut x472: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x472, x467, x462, x449);\n    let mut x473: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x473, x467, x464, x451);\n    out1[0] = x468;\n    out1[1] = x469;\n    out1[2] = x470;\n    out1[3] = x471;\n    out1[4] = x472;\n    out1[5] = x473;\n}",
    "display_name": "fiat_p384_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Field/sqrt_ratio",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sqrt_ratio(num: &Self, div: &Self) -> (Choice, Self) {\n        helpers::sqrt_ratio_generic(num, div)\n    }",
    "display_name": "sqrt_ratio",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Group/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/try_from_rng"
    ],
    "body": "    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> core::result::Result<Self, R::Error> {\n        Ok(Self::GENERATOR * Scalar::try_from_rng(rng)?)\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 identity_encoding",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/is_identity",
      "affine/impl/AffinePoint/GroupEncoding/to_bytes",
      "affine/impl/AffinePoint/GroupEncoding/from_bytes"
    ],
    "body": "fn identity_encoding() {\n    // This is technically an invalid SEC1 encoding, but is preferable to panicking.\n    assert_eq!([0; 33], AffinePoint::IDENTITY.to_bytes().as_slice());\n    assert!(bool::from(\n        AffinePoint::from_bytes(&AffinePoint::IDENTITY.to_bytes())\n            .unwrap()\n            .is_identity()\n    ))\n}",
    "display_name": "identity_encoding",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Invert/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        self.invert()\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre bench_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_scalar_x",
      "0.14.0_pre test_scalar_y"
    ],
    "body": "fn bench_scalar_mul<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"mul\", |b| b.iter(|| x * y));\n}",
    "display_name": "bench_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/eq_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/is_identity",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Group/is_identity",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Add/add",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero"
    ],
    "body": "    pub fn eq_affine(&self, other: &AffinePoint) -> Choice {\n        // For understanding of this algorithm see Projective equality comment. It's the same except\n        // that we know z = 1 for rhs and we have to check identity as a separate case.\n        let both_identity = self.is_identity() & other.is_identity();\n        let rhs_identity = other.is_identity();\n        let rhs_x = &other.x * &self.z;\n        let x_eq = rhs_x.negate(1).add(&self.x).normalizes_to_zero();\n\n        let rhs_y = &other.y * &self.z;\n        let y_eq = rhs_y.negate(1).add(&self.y).normalizes_to_zero();\n\n        both_identity | (!rhs_identity & x_eq & y_eq)\n    }",
    "display_name": "eq_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = &'a FieldElement>>(iter: I) -> Self {\n        iter.copied().sum()\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/impl/Signature/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress",
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032"
    ],
    "body": "    fn from(inner: InnerSignature) -> Self {\n        let mut s = [0u8; SECRET_KEY_LENGTH];\n        s.copy_from_slice(&inner.s.to_bytes_rfc_8032());\n        Self::from_components(inner.r.compress(), s)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign.rs",
    "relative_path": "ed448-goldilocks/src/sign.rs",
    "file_name": "sign.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/projective_equality",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/Neg/neg",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Neg/neg"
    ],
    "body": "    fn projective_equality() {\n        use core::ops::Neg;\n        assert_ne!(ProjectivePoint::GENERATOR, ProjectivePoint::IDENTITY);\n        assert_ne!(ProjectivePoint::IDENTITY, ProjectivePoint::GENERATOR);\n        assert_eq!(ProjectivePoint::IDENTITY, ProjectivePoint::IDENTITY);\n        assert_eq!(ProjectivePoint::IDENTITY.neg(), ProjectivePoint::IDENTITY);\n        assert_eq!(ProjectivePoint::GENERATOR, ProjectivePoint::GENERATOR);\n        assert_ne!(ProjectivePoint::GENERATOR, ProjectivePoint::GENERATOR.neg());\n\n        assert_ne!(ProjectivePoint::GENERATOR, AffinePoint::IDENTITY);\n        assert_ne!(ProjectivePoint::IDENTITY, AffinePoint::GENERATOR);\n        assert_eq!(ProjectivePoint::IDENTITY, AffinePoint::IDENTITY);\n        assert_eq!(ProjectivePoint::IDENTITY.neg(), AffinePoint::IDENTITY);\n        assert_eq!(ProjectivePoint::GENERATOR, AffinePoint::GENERATOR);\n        assert_ne!(ProjectivePoint::GENERATOR.neg(), AffinePoint::GENERATOR);\n        assert_eq!(\n            ProjectivePoint::GENERATOR.neg(),\n            AffinePoint::GENERATOR.neg()\n        );\n    }",
    "display_name": "projective_equality",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/multiply",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqn",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    const fn invert_unchecked(&self) -> Self {\n        // Adapted from addchain: github.com/mmcloughlin/addchain\n        let z = self.square();\n        let z = self.multiply(&z);\n        let t0 = z.sqn(2);\n        let z = z.multiply(&t0);\n        let t0 = z.sqn(4);\n        let z = z.multiply(&t0);\n        let t0 = z.sqn(8);\n        let z = z.multiply(&t0);\n        let t0 = z.sqn(16);\n        let z = z.multiply(&t0);\n        let t0 = z.sqn(32);\n        let z = z.multiply(&t0);\n        let t0 = z.square();\n        let t0 = self.multiply(&t0);\n        let t0 = t0.sqn(64);\n        let z = z.multiply(&t0);\n        let t0 = z.square();\n        let t0 = self.multiply(&t0);\n        let t0 = t0.sqn(129);\n        let z = z.multiply(&t0);\n        let t0 = z.square();\n        let t0 = self.multiply(&t0);\n        let t0 = t0.sqn(259);\n        let z = z.multiply(&t0);\n        let z = z.sqn(2);\n        self.multiply(&z)\n    }",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre bench_scalar_negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_scalar_x"
    ],
    "body": "fn bench_scalar_negate<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"negate\", |b| b.iter(|| -x));\n}",
    "display_name": "bench_scalar_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/sec1::EncodedPoint::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn from(value: PublicKey) -> Self {\n        value.point.to_encoded_point(false)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/pow_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/pow_vartime",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    fn pow_vartime() {\n        let one = FieldElement::ONE;\n        let two = one + &one;\n        let four = two.square();\n        assert_eq!(two.pow_vartime(&[2, 0, 0, 0]), four);\n    }",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 compressed_to_uncompressed",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "fn compressed_to_uncompressed() {\n    let encoded = EncodedPoint::from_bytes(COMPRESSED_BASEPOINT).unwrap();\n\n    let res = AffinePoint::from_encoded_point(&encoded)\n        .unwrap()\n        .to_encoded_point(false);\n\n    assert_eq!(res.as_bytes(), UNCOMPRESSED_BASEPOINT);\n}",
    "display_name": "compressed_to_uncompressed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/pow_vartime",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/square"
    ],
    "body": "    fn sqrt(&self) -> CtOption<Self> {\n        // w = self^((t - 1) // 2)\n        // Note: `pow_vartime` is constant-time with respect to `self`\n        let w = self.pow_vartime(&[0xb0a35e4d8da69141, 0xfffffffffccef7c1, 0x07ffffffffffffff]);\n\n        let mut v = Self::S;\n        let mut x = *self * w;\n        let mut b = x * w;\n        let mut z = Self::ROOT_OF_UNITY;\n\n        for max_v in (1..=Self::S).rev() {\n            let mut k = 1;\n            let mut tmp = b.square();\n            let mut j_less_than_v = Choice::from(1);\n\n            for j in 2..max_v {\n                let tmp_is_one = tmp.ct_eq(&Self::ONE);\n                let squared = Self::conditional_select(&tmp, &z, tmp_is_one).square();\n                tmp = Self::conditional_select(&squared, &tmp, tmp_is_one);\n                let new_z = Self::conditional_select(&z, &squared, tmp_is_one);\n                j_less_than_v &= !j.ct_eq(&v);\n                k = u32::conditional_select(&j, &k, tmp_is_one);\n                z = Self::conditional_select(&z, &new_z, j_less_than_v);\n            }\n\n            let result = x * z;\n            x = Self::conditional_select(&result, &x, b.ct_eq(&Self::ONE));\n            z = z.square();\n            b *= z;\n            v = k;\n        }\n\n        CtOption::new(x, x.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_rshift",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from",
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint"
    ],
    "body": "        fn fuzzy_rshift(a in scalar(), b in 0usize..512) {\n            let a_bi = a.to_biguint().unwrap();\n\n            let res_bi = &a_bi >> b;\n            let res_ref = Scalar::from(&res_bi);\n            let res_test = a >> b;\n\n            assert_eq!(res_ref, res_test);\n        }",
    "display_name": "fuzzy_rshift",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/tests/test_negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/negate",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended"
    ],
    "body": "    fn test_negate() {\n        let a = TWISTED_EDWARDS_BASE_POINT;\n        let neg_a = a.negate();\n\n        assert!(a.to_extensible().add_extended(&neg_a) == ExtensiblePoint::IDENTITY);\n    }",
    "display_name": "test_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/Context/DigestVerifier/verify_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_inner"
    ],
    "body": "    fn verify_digest(&self, digest: D, signature: &Signature) -> Result<(), Error> {\n        let mut prehashed_message = [0u8; 64];\n        prehashed_message.copy_from_slice(digest.finalize().as_slice());\n        self.key\n            .verify_inner(signature, 1, self.value, &prehashed_message)\n    }",
    "display_name": "verify_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 test_field_element_x",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_field_element_x() -> FieldElement {\n    FieldElement::from_bytes(\n        &hex!(\"c2b47944fb5de342d03285880177ca5f7d0f2fcad7678cce4229d6e1932fcac11bfc3c3e97d942a3c56bf34123013dbf\").into()\n    )\n    .unwrap()\n}",
    "display_name": "test_field_element_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/field.rs",
    "relative_path": "p384/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_add"
    ],
    "body": "    pub const fn add(&self, rhs: &Self) -> Self {\n        let mut out = fiat_p521_tight_field_element([0; 9]);\n        fiat_p521_carry_add(&mut out, &self.0, &rhs.0);\n        Self(out)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/BatchNormalize/>/batch_normalize",
    "statement_type": "function",
    "deps": [
      "projective/batch_normalize_generic"
    ],
    "body": "    fn batch_normalize(points: &[Self]) -> Vec<<Self as CurveGroup>::AffineRepr> {\n        let mut zs = vec![C::FieldElement::ONE; points.len()];\n        let mut affine_points = vec![AffinePoint::IDENTITY; points.len()];\n        batch_normalize_generic(points, zs.as_mut_slice(), &mut affine_points);\n        affine_points\n    }",
    "display_name": "batch_normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/is_identity",
      "projective/impl/ProjectivePoint/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn from(p: AffinePoint<C>) -> Self {\n        let projective = ProjectivePoint {\n            x: p.x,\n            y: p.y,\n            z: C::FieldElement::ONE,\n        };\n        Self::conditional_select(&projective, &Self::IDENTITY, p.is_identity())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/PrehashVerifier/verify_prehash",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/hash_msg"
    ],
    "body": "    fn multipart_verify(&self, msg: &[&[u8]], signature: &Signature) -> Result<()> {\n        // B3: set M'~=ZA || M'\n        let hash = self.hash_msg(msg);\n        self.verify_prehash(&hash, signature)\n    }",
    "display_name": "multipart_verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "    fn reduce_bytes(bytes: &WideBytes) -> Self {\n        Self::reduce(U512::from_be_byte_array(*bytes))\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/decompress",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/inverse_square_root",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/is_on_curve",
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative",
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes",
      "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes"
    ],
    "body": "    pub fn decompress(&self) -> CtOption<DecafPoint> {\n        let s = FieldElement::from_bytes(&self.0);\n        //XX: Check for canonical encoding and sign,\n        // Copied this check from Dalek: The From_bytes function does not throw an error, if the bytes exceed the prime.\n        // However, to_bytes reduces the Field element before serialising\n        // So we can use to_bytes -> from_bytes and if the representations are the same, then the element was already in reduced form\n        let s_bytes_check = s.to_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(&self.0);\n        let s_is_negative = s.is_negative();\n        // if s_encoding_is_canonical.unwrap_u8() == 0u8 || s.is_negative().unwrap_u8() == 1u8 {\n        //     return None;\n        // }\n\n        let ss = s.square();\n        let u1 = FieldElement::ONE - ss;\n        let u2 = FieldElement::ONE + ss;\n        let u1_sqr = u1.square();\n\n        let v = ss * (FieldElement::NEG_FOUR_TIMES_TWISTED_D) + u1_sqr; // XXX: constantify please\n\n        let (I, ok) = (v * u1_sqr).inverse_square_root();\n\n        let Dx = I * u1;\n        let Dxs = (s + s) * Dx;\n\n        let mut X = (Dxs * I) * v;\n        let k = Dxs * FieldElement::DECAF_FACTOR;\n        X.conditional_negate(k.is_negative());\n\n        let Y = Dx * u2;\n        let Z = FieldElement::ONE;\n        let T = X * Y;\n        let pt = ExtendedPoint { X, Y, Z, T };\n\n        CtOption::new(\n            DecafPoint(pt),\n            ok & pt.is_on_curve() & s_encoding_is_canonical & !s_is_negative,\n        )\n    }",
    "display_name": "decompress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        self.to_be_byte_array()\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/lib.rs",
    "relative_path": "bign256/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsMinusThree/PointArithmetic/add_mixed",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/is_identity"
    ],
    "body": "    fn add_mixed(lhs: &ProjectivePoint<C>, rhs: &AffinePoint<C>) -> ProjectivePoint<C> {\n        debug_assert_eq!(\n            C::EQUATION_A,\n            -C::FieldElement::from(3),\n            \"this implementation is only valid for C::EQUATION_A = -3\"\n        );\n\n        let xx = lhs.x * rhs.x; // 1\n        let yy = lhs.y * rhs.y; // 2\n        let xy_pairs = ((lhs.x + lhs.y) * (rhs.x + rhs.y)) - (xx + yy); // 3, 4, 5, 6, 7\n        let yz_pairs = (rhs.y * lhs.z) + lhs.y; // 8, 9 (t4)\n        let xz_pairs = (rhs.x * lhs.z) + lhs.x; // 10, 11 (y3)\n\n        let bz_part = xz_pairs - (C::EQUATION_B * lhs.z); // 12, 13\n        let bz3_part = bz_part.double() + bz_part; // 14, 15\n        let yy_m_bzz3 = yy - bz3_part; // 16\n        let yy_p_bzz3 = yy + bz3_part; // 17\n\n        let z3 = lhs.z.double() + lhs.z; // 19, 20\n        let bxz_part = (C::EQUATION_B * xz_pairs) - (z3 + xx); // 18, 21, 22\n        let bxz3_part = bxz_part.double() + bxz_part; // 23, 24\n        let xx3_m_zz3 = xx.double() + xx - z3; // 25, 26, 27\n\n        let mut ret = ProjectivePoint {\n            x: (yy_p_bzz3 * xy_pairs) - (yz_pairs * bxz3_part), // 28, 32, 33\n            y: (yy_p_bzz3 * yy_m_bzz3) + (xx3_m_zz3 * bxz3_part), // 29, 30, 31\n            z: (yy_m_bzz3 * yz_pairs) + (xy_pairs * xx3_m_zz3), // 34, 35, 36\n        };\n        ret.conditional_assign(lhs, rhs.is_identity());\n        ret\n    }",
    "display_name": "add_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/elliptic_curve::PublicKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/AffinePoint/From/from"
    ],
    "body": "    fn try_from(point: ProjectivePoint) -> Result<PublicKey> {\n        AffinePoint::from(point).try_into()\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_basic_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_basic_sub() {\n        let ten = Scalar::from(10u8);\n        let five = Scalar::from(5u8);\n        assert_eq!(ten - five, Scalar::from(5u8))\n    }",
    "display_name": "test_basic_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/ScalarPrimitive/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: &Scalar) -> ScalarPrimitive<Secp256k1> {\n        ScalarPrimitive::new(scalar.0).unwrap()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/square",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn neg(&self) -> Self {\n        Self {\n            x: self.x,\n            y: -self.y,\n            z: self.z,\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(&bytes[..])\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: &'b Scalar) {\n        let result = *self * scalar;\n        *self = result;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/KeypairBytes/TryFrom, ed448::pkcs8::OctetStringRef, ed448::pkcs8::BitStringRef>>/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(value: pkcs8::PrivateKeyInfoRef<'_>) -> Result<Self, Self::Error> {\n        if value.algorithm.oid != super::ALGORITHM_OID {\n            return Err(pkcs8::Error::KeyMalformed);\n        }\n        if value.private_key.as_bytes().len() != SECRET_KEY_LENGTH {\n            return Err(pkcs8::Error::KeyMalformed);\n        }\n        let mut secret_key = [0u8; SECRET_KEY_LENGTH];\n        secret_key.copy_from_slice(value.private_key.as_bytes());\n        let verifying_key = if let Some(public_key) = value.public_key {\n            if public_key.has_unused_bits() {\n                return Err(pkcs8::Error::KeyMalformed);\n            }\n            let public_key = public_key.raw_bytes();\n            if public_key.len() != PUBLIC_KEY_LENGTH {\n                return Err(pkcs8::Error::KeyMalformed);\n            }\n            let mut bytes = [0u8; PUBLIC_KEY_LENGTH];\n            bytes.copy_from_slice(public_key);\n            Some(bytes)\n        } else {\n            None\n        };\n        Ok(KeypairBytes {\n            secret_key,\n            verifying_key,\n        })\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/from_bytes"
    ],
    "body": "    pub fn from_bytes(bytes: &FieldBytes) -> CtOption<Self> {\n        FieldElementImpl::from_bytes(bytes).map(Self)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_from_montgomery(\n    out1: &mut fiat_bign256_scalar_non_montgomery_domain_field_element,\n    arg1: &fiat_bign256_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x2, &mut x3, x1, 0x8d64dbd30858d849);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x4, &mut x5, x2, 0xffffffffffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x6, &mut x7, x2, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x8, &mut x9, x2, 0xd95c8ed60dfb4dfc);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x10, &mut x11, x2, 0x7e5abf99263d6607);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x12, &mut x13, 0x0, x11, x8);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x9, x6);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, x4);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x18, &mut x19, 0x0, x1, x10);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), x12);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x22, &mut x23, x21, (0x0 as u64), x14);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x24, &mut x25, x23, (0x0 as u64), x16);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x26, &mut x27, x25, (0x0 as u64), ((x17 as u64) + x5));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x28, &mut x29, 0x0, x20, (arg1[1]));\n    let mut x30: u64 = 0;\n    let mut x31: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x22, (0x0 as u64));\n    let mut x32: u64 = 0;\n    let mut x33: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x24, (0x0 as u64));\n    let mut x34: u64 = 0;\n    let mut x35: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x26, (0x0 as u64));\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x36, &mut x37, x28, 0x8d64dbd30858d849);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x38, &mut x39, x36, 0xffffffffffffffff);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x40, &mut x41, x36, 0xffffffffffffffff);\n    let mut x42: u64 = 0;\n    let mut x43: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x42, &mut x43, x36, 0xd95c8ed60dfb4dfc);\n    let mut x44: u64 = 0;\n    let mut x45: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x44, &mut x45, x36, 0x7e5abf99263d6607);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x46, &mut x47, 0x0, x45, x42);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x48, &mut x49, x47, x43, x40);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x50, &mut x51, x49, x41, x38);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x52, &mut x53, 0x0, x28, x44);\n    let mut x54: u64 = 0;\n    let mut x55: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x54, &mut x55, x53, x30, x46);\n    let mut x56: u64 = 0;\n    let mut x57: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x56, &mut x57, x55, x32, x48);\n    let mut x58: u64 = 0;\n    let mut x59: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x58, &mut x59, x57, x34, x50);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(\n        &mut x60,\n        &mut x61,\n        x59,\n        ((x35 as u64) + (x27 as u64)),\n        ((x51 as u64) + x39),\n    );\n    let mut x62: u64 = 0;\n    let mut x63: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x54, (arg1[2]));\n    let mut x64: u64 = 0;\n    let mut x65: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x56, (0x0 as u64));\n    let mut x66: u64 = 0;\n    let mut x67: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x58, (0x0 as u64));\n    let mut x68: u64 = 0;\n    let mut x69: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x60, (0x0 as u64));\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x70, &mut x71, x62, 0x8d64dbd30858d849);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x72, &mut x73, x70, 0xffffffffffffffff);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x74, &mut x75, x70, 0xffffffffffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x76, &mut x77, x70, 0xd95c8ed60dfb4dfc);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x78, &mut x79, x70, 0x7e5abf99263d6607);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x80, &mut x81, 0x0, x79, x76);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x77, x74);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x75, x72);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x86, &mut x87, 0x0, x62, x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x64, x80);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x66, x82);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x92, &mut x93, x91, x68, x84);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(\n        &mut x94,\n        &mut x95,\n        x93,\n        ((x69 as u64) + (x61 as u64)),\n        ((x85 as u64) + x73),\n    );\n    let mut x96: u64 = 0;\n    let mut x97: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x96, &mut x97, 0x0, x88, (arg1[3]));\n    let mut x98: u64 = 0;\n    let mut x99: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x90, (0x0 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x92, (0x0 as u64));\n    let mut x102: u64 = 0;\n    let mut x103: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x102, &mut x103, x101, x94, (0x0 as u64));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x104, &mut x105, x96, 0x8d64dbd30858d849);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x106, &mut x107, x104, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x108, &mut x109, x104, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x110, &mut x111, x104, 0xd95c8ed60dfb4dfc);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x112, &mut x113, x104, 0x7e5abf99263d6607);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x114, &mut x115, 0x0, x113, x110);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x116, &mut x117, x115, x111, x108);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x118, &mut x119, x117, x109, x106);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x120, &mut x121, 0x0, x96, x112);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x98, x114);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x124, &mut x125, x123, x100, x116);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x126, &mut x127, x125, x102, x118);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(\n        &mut x128,\n        &mut x129,\n        x127,\n        ((x103 as u64) + (x95 as u64)),\n        ((x119 as u64) + x107),\n    );\n    let mut x130: u64 = 0;\n    let mut x131: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x130, &mut x131, 0x0, x122, 0x7e5abf99263d6607);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x132, &mut x133, x131, x124, 0xd95c8ed60dfb4dfc);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x134, &mut x135, x133, x126, 0xffffffffffffffff);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x136, &mut x137, x135, x128, 0xffffffffffffffff);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x138, &mut x139, x137, (x129 as u64), (0x0 as u64));\n    let mut x140: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x140, x139, x130, x122);\n    let mut x141: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x141, x139, x132, x124);\n    let mut x142: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x142, x139, x134, x126);\n    let mut x143: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x143, x139, x136, x128);\n    out1[0] = x140;\n    out1[1] = x141;\n    out1[2] = x142;\n    out1[3] = x143;\n}",
    "display_name": "fiat_bign256_scalar_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    fn mul(self, rhs: &AffinePoint) -> EdwardsPoint {\n        rhs.to_edwards() * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::ZERO\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &PointBytes {\n        &self.0\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_bign256_scalar_u1,\n    arg1: fiat_bign256_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_bign256_scalar_u1 = ((x1 >> 64) as fiat_bign256_scalar_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_bign256_scalar_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x",
      "0.14.0_pre.8 test_field_element_y"
    ],
    "body": "fn bench_field_element_mul<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    let y = test_field_element_y();\n    group.bench_function(\"mul\", |b| b.iter(|| &x * &y));\n}",
    "display_name": "bench_field_element_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/field.rs",
    "relative_path": "p521/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(k: u32) -> Self {\n        Self(k.into())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/primeorder::array::Array::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/to_repr"
    ],
    "body": "    fn from(scalar: &Scalar) -> Self {\n        scalar.to_repr()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/from_u64",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_normalized",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/from_u64"
    ],
    "body": "    pub(crate) const fn from_u64(val: u64) -> Self {\n        Self::new_normalized(&FieldElementUnsafeImpl::from_u64(val))\n    }",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_hex",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_u64",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
      "0.14.0_pre.8 arithmetic/field/impl/&FieldElement/Mul/mul",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqn",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert_unchecked"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        // We need to find alpha such that alpha^2 = beta mod p. For secp256r1,\n        // p ≡ 3 mod 4. By Euler's Criterion, beta^(p-1)/2 ≡ 1 mod p. So:\n        //\n        //     alpha^2 = beta beta^((p - 1) / 2) mod p ≡ beta^((p + 1) / 2) mod p\n        //     alpha = ± beta^((p + 1) / 4) mod p\n        //\n        // Thus sqrt can be implemented with a single exponentiation.\n\n        let t11 = self.mul(&self.square());\n        let t1111 = t11.mul(&t11.sqn(2));\n        let t11111111 = t1111.mul(t1111.sqn(4));\n        let x16 = t11111111.sqn(8).mul(t11111111);\n        let sqrt = x16\n            .sqn(16)\n            .mul(x16)\n            .sqn(32)\n            .mul(self)\n            .sqn(96)\n            .mul(self)\n            .sqn(94);\n\n        CtOption::new(\n            sqrt,\n            (&sqrt * &sqrt).ct_eq(self), // Only return Some if it's the square root.\n        )\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/wycheproof/wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "        ecdsa_core::new_wycheproof_test!(wycheproof, \"wycheproof\", NistP256);\n    }\n}",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/ecdsa.rs",
    "relative_path": "p256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/as_limbs",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/into_limbs"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut ret = Self::ZERO.into_limbs();\n        let a = a.as_limbs();\n        let b = b.as_limbs();\n\n        for i in 0..ret.len() {\n            ret[i] = u64::conditional_select(&a[i], &b[i], choice);\n        }\n\n        Self(fiat_p521_scalar_montgomery_domain_field_element(ret))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/as_limbs"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.as_limbs().ct_eq(other.as_limbs())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &Scalar) {\n        *self = Scalar::sub(self, rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/add",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn add(&self, rhs: &Self) -> Self {\n        Self([\n            self.0[0] + rhs.0[0],\n            self.0[1] + rhs.0[1],\n            self.0[2] + rhs.0[2],\n            self.0[3] + rhs.0[3],\n            self.0[4] + rhs.0[4],\n        ])\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_p192_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/tests/test_montgomery_edwards",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_montgomery",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/scalar_mul"
    ],
    "body": "    fn test_montgomery_edwards() {\n        let scalar = Scalar::from(200u32);\n        use crate::GOLDILOCKS_BASE_POINT as bp;\n\n        // Montgomery scalar mul\n        let montgomery_bp = bp.to_montgomery();\n        let montgomery_res = &montgomery_bp * &scalar;\n\n        // Goldilocks scalar mul\n        let goldilocks_point = bp.scalar_mul(&scalar);\n        assert_eq!(goldilocks_point.to_montgomery(), montgomery_res);\n    }",
    "display_name": "test_montgomery_edwards",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/pow2k"
    ],
    "body": "    pub fn invert(&self) -> CtOption<Self> {\n        // Using an addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#secp256k1_scalar_inversion\n        let x_1 = *self;\n        let x_10 = self.pow2k(1);\n        let x_11 = x_10.mul(&x_1);\n        let x_101 = x_10.mul(&x_11);\n        let x_111 = x_10.mul(&x_101);\n        let x_1001 = x_10.mul(&x_111);\n        let x_1011 = x_10.mul(&x_1001);\n        let x_1101 = x_10.mul(&x_1011);\n\n        let x6 = x_1101.pow2k(2).mul(&x_1011);\n        let x8 = x6.pow2k(2).mul(&x_11);\n        let x14 = x8.pow2k(6).mul(&x6);\n        let x28 = x14.pow2k(14).mul(&x14);\n        let x56 = x28.pow2k(28).mul(&x28);\n\n        #[rustfmt::skip]\n            let res = x56\n            .pow2k(56).mul(&x56)\n            .pow2k(14).mul(&x14)\n            .pow2k(3).mul(&x_101)\n            .pow2k(4).mul(&x_111)\n            .pow2k(4).mul(&x_101)\n            .pow2k(5).mul(&x_1011)\n            .pow2k(4).mul(&x_1011)\n            .pow2k(4).mul(&x_111)\n            .pow2k(5).mul(&x_111)\n            .pow2k(6).mul(&x_1101)\n            .pow2k(4).mul(&x_101)\n            .pow2k(3).mul(&x_111)\n            .pow2k(5).mul(&x_1001)\n            .pow2k(6).mul(&x_101)\n            .pow2k(10).mul(&x_111)\n            .pow2k(4).mul(&x_111)\n            .pow2k(9).mul(&x8)\n            .pow2k(5).mul(&x_1001)\n            .pow2k(6).mul(&x_1011)\n            .pow2k(4).mul(&x_1101)\n            .pow2k(5).mul(&x_11)\n            .pow2k(6).mul(&x_1101)\n            .pow2k(10).mul(&x_1101)\n            .pow2k(4).mul(&x_1001)\n            .pow2k(6).mul(&x_1)\n            .pow2k(8).mul(&x6);\n\n        CtOption::new(res, !self.is_zero())\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/scalar_mul/window/wnaf/impl/LookupTable/select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/identity"
    ],
    "body": "    pub fn select(&self, index: u32) -> ProjectiveNielsPoint {\n        let mut result = ProjectiveNielsPoint::identity();\n\n        for i in 1..9 {\n            let swap = index.ct_eq(&(i as u32));\n            result.conditional_assign(&self.0[i - 1], swap);\n        }\n        result\n    }",
    "display_name": "select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/scalar_mul/window/wnaf.rs",
    "relative_path": "ed448-goldilocks/src/curve/scalar_mul/window/wnaf.rs",
    "file_name": "wnaf.rs",
    "parent_folder": "window"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&EdwardsPoint/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, other: &AffinePoint) -> EdwardsPoint {\n        *self + *other\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: &FieldElement) {\n        *self = *self + *other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "projective/impl/&ProjectivePoint/Mul::Scalar>/mul",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/mul"
    ],
    "body": "    fn mul(self, scalar: &Scalar<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::mul(self, scalar)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "affine/impl/AffinePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: C::FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: C::FieldElement::conditional_select(&a.y, &b.y, choice),\n            infinity: u8::conditional_select(&a.infinity, &b.infinity, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extensible"
    ],
    "body": "    pub(crate) fn to_extended(self) -> ExtendedPoint {\n        self.to_extensible().to_extended()\n    }",
    "display_name": "to_extended",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [],
    "body": "    fn reduce(bytes: U896) -> Self {\n        let (r, underflow) = bytes.borrowing_sub(&WIDE_ORDER, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self(U896::conditional_select(&bytes, &r, !underflow).split().1)\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/impl/Signature/from_bytes"
    ],
    "body": "    fn try_from(signature: &SignatureBytes) -> Result<Signature> {\n        Signature::from_bytes(signature)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/from_bytes",
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/new"
    ],
    "body": "    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {\n        let public_key = PublicKey::from_bytes(bytes).map_err(|_| Error::new())?;\n        Self::new(public_key)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/decrypt",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
      "0.14.0_pre pke/kdf",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce",
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "projective/impl/ProjectivePoint/Group/is_identity",
      "projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "fn decrypt(\n    secret_scalar: &Scalar,\n    mode: Mode,\n    hasher: &mut dyn DynDigest,\n    cipher: &[u8],\n) -> Result<Vec<u8>> {\n    let q = U256::from_be_hex(FieldElement::MODULUS);\n    let c1_len = q.bits().div_ceil(8) * 2 + 1;\n\n    // B1: get 𝐶1 from 𝐶\n    let (c1, c) = cipher.split_at(c1_len as usize);\n    let encoded_c1 = EncodedPoint::from_bytes(c1).map_err(Error::from)?;\n\n    // verify that point c1 satisfies the elliptic curve\n    let mut c1_point = AffinePoint::from_encoded_point(&encoded_c1).unwrap();\n\n    // B2: compute point 𝑆 = [ℎ]𝐶1\n    let s = c1_point * Scalar::reduce(U256::from_u32(FieldElement::S));\n    if s.is_identity().into() {\n        return Err(Error);\n    }\n\n    // B3: compute [𝑑𝐵]𝐶1 = (𝑥2, 𝑦2)\n    c1_point = (c1_point * secret_scalar).to_affine();\n    let digest_size = hasher.output_size();\n    let (c2, c3) = match mode {\n        Mode::C1C3C2 => {\n            let (c3, c2) = c.split_at(digest_size);\n            (c2, c3)\n        }\n        Mode::C1C2C3 => c.split_at(c.len() - digest_size),\n    };\n\n    // B4: compute 𝑡 = 𝐾𝐷𝐹(𝑥2 ∥ 𝑦2, 𝑘𝑙𝑒𝑛)\n    // B5: get 𝐶2 from 𝐶 and compute 𝑀′ = 𝐶2 ⊕ t\n    let mut c2 = c2.to_owned();\n    kdf(hasher, c1_point, &mut c2)?;\n\n    // compute 𝑢 = 𝐻𝑎𝑠ℎ(𝑥2 ∥ 𝑀′∥ 𝑦2).\n    let mut u = vec![0u8; digest_size];\n    let encode_point = c1_point.to_encoded_point(false);\n    hasher.update(encode_point.x().ok_or(Error)?);\n    hasher.update(&c2);\n    hasher.update(encode_point.y().ok_or(Error)?);\n    hasher.finalize_into_reset(&mut u).map_err(|_e| Error)?;\n    let checked = u\n        .iter()\n        .zip(c3)\n        .fold(0, |mut check, (&c3_byte, &c3checked_byte)| {\n            check |= c3_byte ^ c3checked_byte;\n            check\n        });\n\n    // If 𝑢 ≠ 𝐶3, output “ERROR” and exit\n    if checked != 0 {\n        return Err(Error);\n    }\n\n    // B7: output the plaintext 𝑀′.\n    Ok(c2.to_vec())\n}",
    "display_name": "decrypt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_selectznz(\n    out1: &mut [u64; 6],\n    arg1: fiat_p384_scalar_u1,\n    arg2: &[u64; 6],\n    arg3: &[u64; 6],\n) {\n    let mut x1: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    let mut x5: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x5, arg1, (arg2[4]), (arg3[4]));\n    let mut x6: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x6, arg1, (arg2[5]), (arg3[5]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n    out1[4] = x5;\n    out1[5] = x6;\n}",
    "display_name": "fiat_p384_scalar_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "    fn reduce_bytes(bytes: &FieldBytes) -> Self {\n        let w = <Uint as FieldBytesEncoding<NistP224>>::decode_field_bytes(bytes);\n        Self::reduce(w)\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/fuzzy_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/tests/field_element",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_zero",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/modulus_as_biguint"
    ],
    "body": "        fn fuzzy_invert(\n            a in field_element()\n        ) {\n            let a = if bool::from(a.is_zero()) { FieldElement::ONE } else { a };\n            let a_bi = a.to_biguint().unwrap();\n            let inv = a.invert().unwrap().normalize();\n            let inv_bi = inv.to_biguint().unwrap();\n            let m = FieldElement::modulus_as_biguint();\n            assert_eq!((&inv_bi * &a_bi) % &m, 1.to_biguint().unwrap());\n        }",
    "display_name": "fuzzy_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/GroupEncoding/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/compress"
    ],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        DecafPointRepr::from(self.compress().0)\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 10],\n    out3: &mut [u64; 10],\n    out4: &mut [u64; 9],\n    out5: &mut [u64; 9],\n    arg1: u64,\n    arg2: &[u64; 10],\n    arg3: &[u64; 10],\n    arg4: &[u64; 9],\n    arg5: &[u64; 9],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_p521_scalar_u1 =\n        (((x1 >> 63) as fiat_p521_scalar_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_p521_scalar_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x12, x3, (arg2[5]), (arg3[5]));\n    let mut x13: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x13, x3, (arg2[6]), (arg3[6]));\n    let mut x14: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x14, x3, (arg2[7]), (arg3[7]));\n    let mut x15: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x15, x3, (arg2[8]), (arg3[8]));\n    let mut x16: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x16, x3, (arg2[9]), (arg3[9]));\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x17, &mut x18, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x19, &mut x20, x18, (0x0 as u64), (!(arg2[1])));\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x21, &mut x22, x20, (0x0 as u64), (!(arg2[2])));\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x23, &mut x24, x22, (0x0 as u64), (!(arg2[3])));\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x25, &mut x26, x24, (0x0 as u64), (!(arg2[4])));\n    let mut x27: u64 = 0;\n    let mut x28: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x27, &mut x28, x26, (0x0 as u64), (!(arg2[5])));\n    let mut x29: u64 = 0;\n    let mut x30: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x29, &mut x30, x28, (0x0 as u64), (!(arg2[6])));\n    let mut x31: u64 = 0;\n    let mut x32: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x31, &mut x32, x30, (0x0 as u64), (!(arg2[7])));\n    let mut x33: u64 = 0;\n    let mut x34: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x33, &mut x34, x32, (0x0 as u64), (!(arg2[8])));\n    let mut x35: u64 = 0;\n    let mut x36: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x35, &mut x36, x34, (0x0 as u64), (!(arg2[9])));\n    let mut x37: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x37, x3, (arg3[0]), x17);\n    let mut x38: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x38, x3, (arg3[1]), x19);\n    let mut x39: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x39, x3, (arg3[2]), x21);\n    let mut x40: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x40, x3, (arg3[3]), x23);\n    let mut x41: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x41, x3, (arg3[4]), x25);\n    let mut x42: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x42, x3, (arg3[5]), x27);\n    let mut x43: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x43, x3, (arg3[6]), x29);\n    let mut x44: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x44, x3, (arg3[7]), x31);\n    let mut x45: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x45, x3, (arg3[8]), x33);\n    let mut x46: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x46, x3, (arg3[9]), x35);\n    let mut x47: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x47, x3, (arg4[0]), (arg5[0]));\n    let mut x48: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x48, x3, (arg4[1]), (arg5[1]));\n    let mut x49: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x49, x3, (arg4[2]), (arg5[2]));\n    let mut x50: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x50, x3, (arg4[3]), (arg5[3]));\n    let mut x51: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x51, x3, (arg4[4]), (arg5[4]));\n    let mut x52: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x52, x3, (arg4[5]), (arg5[5]));\n    let mut x53: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x53, x3, (arg4[6]), (arg5[6]));\n    let mut x54: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x54, x3, (arg4[7]), (arg5[7]));\n    let mut x55: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x55, x3, (arg4[8]), (arg5[8]));\n    let mut x56: u64 = 0;\n    let mut x57: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x56, &mut x57, 0x0, x47, x47);\n    let mut x58: u64 = 0;\n    let mut x59: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x58, &mut x59, x57, x48, x48);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x60, &mut x61, x59, x49, x49);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x62, &mut x63, x61, x50, x50);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x51, x51);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x52, x52);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x53, x53);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x70, &mut x71, x69, x54, x54);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x72, &mut x73, x71, x55, x55);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x74, &mut x75, 0x0, x56, 0xbb6fb71e91386409);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x76, &mut x77, x75, x58, 0x3bb5c9b8899c47ae);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x78, &mut x79, x77, x60, 0x7fcc0148f709a5d0);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x80, &mut x81, x79, x62, 0x51868783bf2f966b);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x82, &mut x83, x81, x64, 0xfffffffffffffffa);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x84, &mut x85, x83, x66, 0xffffffffffffffff);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x86, &mut x87, x85, x68, 0xffffffffffffffff);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x88, &mut x89, x87, x70, 0xffffffffffffffff);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x90, &mut x91, x89, x72, 0x1ff);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x92, &mut x93, x91, (x73 as u64), (0x0 as u64));\n    let x94: u64 = (arg4[8]);\n    let x95: u64 = (arg4[7]);\n    let x96: u64 = (arg4[6]);\n    let x97: u64 = (arg4[5]);\n    let x98: u64 = (arg4[4]);\n    let x99: u64 = (arg4[3]);\n    let x100: u64 = (arg4[2]);\n    let x101: u64 = (arg4[1]);\n    let x102: u64 = (arg4[0]);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x103, &mut x104, 0x0, (0x0 as u64), x102);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x105, &mut x106, x104, (0x0 as u64), x101);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x107, &mut x108, x106, (0x0 as u64), x100);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x109, &mut x110, x108, (0x0 as u64), x99);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x111, &mut x112, x110, (0x0 as u64), x98);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x113, &mut x114, x112, (0x0 as u64), x97);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x115, &mut x116, x114, (0x0 as u64), x96);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x117, &mut x118, x116, (0x0 as u64), x95);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x119, &mut x120, x118, (0x0 as u64), x94);\n    let mut x121: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x121, x120, (0x0 as u64), 0xffffffffffffffff);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x122, &mut x123, 0x0, x103, (x121 & 0xbb6fb71e91386409));\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x124,\n        &mut x125,\n        x123,\n        x105,\n        (x121 & 0x3bb5c9b8899c47ae),\n    );\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x126,\n        &mut x127,\n        x125,\n        x107,\n        (x121 & 0x7fcc0148f709a5d0),\n    );\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x128,\n        &mut x129,\n        x127,\n        x109,\n        (x121 & 0x51868783bf2f966b),\n    );\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x130,\n        &mut x131,\n        x129,\n        x111,\n        (x121 & 0xfffffffffffffffa),\n    );\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x132, &mut x133, x131, x113, x121);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x134, &mut x135, x133, x115, x121);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x136, &mut x137, x135, x117, x121);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x138, &mut x139, x137, x119, (x121 & 0x1ff));\n    let mut x140: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x140, x3, (arg5[0]), x122);\n    let mut x141: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x141, x3, (arg5[1]), x124);\n    let mut x142: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x142, x3, (arg5[2]), x126);\n    let mut x143: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x143, x3, (arg5[3]), x128);\n    let mut x144: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x144, x3, (arg5[4]), x130);\n    let mut x145: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x145, x3, (arg5[5]), x132);\n    let mut x146: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x146, x3, (arg5[6]), x134);\n    let mut x147: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x147, x3, (arg5[7]), x136);\n    let mut x148: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x148, x3, (arg5[8]), x138);\n    let x149: fiat_p521_scalar_u1 = ((x37 & (0x1 as u64)) as fiat_p521_scalar_u1);\n    let mut x150: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x150, x149, (0x0 as u64), x7);\n    let mut x151: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x151, x149, (0x0 as u64), x8);\n    let mut x152: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x152, x149, (0x0 as u64), x9);\n    let mut x153: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x153, x149, (0x0 as u64), x10);\n    let mut x154: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x154, x149, (0x0 as u64), x11);\n    let mut x155: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x155, x149, (0x0 as u64), x12);\n    let mut x156: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x156, x149, (0x0 as u64), x13);\n    let mut x157: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x157, x149, (0x0 as u64), x14);\n    let mut x158: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x158, x149, (0x0 as u64), x15);\n    let mut x159: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x159, x149, (0x0 as u64), x16);\n    let mut x160: u64 = 0;\n    let mut x161: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x160, &mut x161, 0x0, x37, x150);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x162, &mut x163, x161, x38, x151);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x164, &mut x165, x163, x39, x152);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x166, &mut x167, x165, x40, x153);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x168, &mut x169, x167, x41, x154);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x42, x155);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x43, x156);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x44, x157);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x45, x158);\n    let mut x178: u64 = 0;\n    let mut x179: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x178, &mut x179, x177, x46, x159);\n    let mut x180: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x180, x149, (0x0 as u64), x47);\n    let mut x181: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x181, x149, (0x0 as u64), x48);\n    let mut x182: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x182, x149, (0x0 as u64), x49);\n    let mut x183: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x183, x149, (0x0 as u64), x50);\n    let mut x184: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x184, x149, (0x0 as u64), x51);\n    let mut x185: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x185, x149, (0x0 as u64), x52);\n    let mut x186: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x186, x149, (0x0 as u64), x53);\n    let mut x187: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x187, x149, (0x0 as u64), x54);\n    let mut x188: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x188, x149, (0x0 as u64), x55);\n    let mut x189: u64 = 0;\n    let mut x190: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x189, &mut x190, 0x0, x140, x180);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x191, &mut x192, x190, x141, x181);\n    let mut x193: u64 = 0;\n    let mut x194: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x193, &mut x194, x192, x142, x182);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x195, &mut x196, x194, x143, x183);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x197, &mut x198, x196, x144, x184);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x145, x185);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x146, x186);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x147, x187);\n    let mut x205: u64 = 0;\n    let mut x206: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x205, &mut x206, x204, x148, x188);\n    let mut x207: u64 = 0;\n    let mut x208: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x207, &mut x208, 0x0, x189, 0xbb6fb71e91386409);\n    let mut x209: u64 = 0;\n    let mut x210: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x209, &mut x210, x208, x191, 0x3bb5c9b8899c47ae);\n    let mut x211: u64 = 0;\n    let mut x212: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x211, &mut x212, x210, x193, 0x7fcc0148f709a5d0);\n    let mut x213: u64 = 0;\n    let mut x214: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x213, &mut x214, x212, x195, 0x51868783bf2f966b);\n    let mut x215: u64 = 0;\n    let mut x216: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x215, &mut x216, x214, x197, 0xfffffffffffffffa);\n    let mut x217: u64 = 0;\n    let mut x218: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x217, &mut x218, x216, x199, 0xffffffffffffffff);\n    let mut x219: u64 = 0;\n    let mut x220: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x219, &mut x220, x218, x201, 0xffffffffffffffff);\n    let mut x221: u64 = 0;\n    let mut x222: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x221, &mut x222, x220, x203, 0xffffffffffffffff);\n    let mut x223: u64 = 0;\n    let mut x224: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x223, &mut x224, x222, x205, 0x1ff);\n    let mut x225: u64 = 0;\n    let mut x226: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x225, &mut x226, x224, (x206 as u64), (0x0 as u64));\n    let mut x227: u64 = 0;\n    let mut x228: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x227, &mut x228, 0x0, x6, (0x1 as u64));\n    let x229: u64 = ((x160 >> 1) | ((x162 << 63) & 0xffffffffffffffff));\n    let x230: u64 = ((x162 >> 1) | ((x164 << 63) & 0xffffffffffffffff));\n    let x231: u64 = ((x164 >> 1) | ((x166 << 63) & 0xffffffffffffffff));\n    let x232: u64 = ((x166 >> 1) | ((x168 << 63) & 0xffffffffffffffff));\n    let x233: u64 = ((x168 >> 1) | ((x170 << 63) & 0xffffffffffffffff));\n    let x234: u64 = ((x170 >> 1) | ((x172 << 63) & 0xffffffffffffffff));\n    let x235: u64 = ((x172 >> 1) | ((x174 << 63) & 0xffffffffffffffff));\n    let x236: u64 = ((x174 >> 1) | ((x176 << 63) & 0xffffffffffffffff));\n    let x237: u64 = ((x176 >> 1) | ((x178 << 63) & 0xffffffffffffffff));\n    let x238: u64 = ((x178 & 0x8000000000000000) | (x178 >> 1));\n    let mut x239: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x239, x93, x74, x56);\n    let mut x240: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x240, x93, x76, x58);\n    let mut x241: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x241, x93, x78, x60);\n    let mut x242: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x242, x93, x80, x62);\n    let mut x243: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x243, x93, x82, x64);\n    let mut x244: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x244, x93, x84, x66);\n    let mut x245: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x245, x93, x86, x68);\n    let mut x246: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x246, x93, x88, x70);\n    let mut x247: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x247, x93, x90, x72);\n    let mut x248: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x248, x226, x207, x189);\n    let mut x249: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x249, x226, x209, x191);\n    let mut x250: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x250, x226, x211, x193);\n    let mut x251: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x251, x226, x213, x195);\n    let mut x252: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x252, x226, x215, x197);\n    let mut x253: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x253, x226, x217, x199);\n    let mut x254: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x254, x226, x219, x201);\n    let mut x255: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x255, x226, x221, x203);\n    let mut x256: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x256, x226, x223, x205);\n    *out1 = x227;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out2[5] = x12;\n    out2[6] = x13;\n    out2[7] = x14;\n    out2[8] = x15;\n    out2[9] = x16;\n    out3[0] = x229;\n    out3[1] = x230;\n    out3[2] = x231;\n    out3[3] = x232;\n    out3[4] = x233;\n    out3[5] = x234;\n    out3[6] = x235;\n    out3[7] = x236;\n    out3[8] = x237;\n    out3[9] = x238;\n    out4[0] = x239;\n    out4[1] = x240;\n    out4[2] = x241;\n    out4[3] = x242;\n    out4[4] = x243;\n    out4[5] = x244;\n    out4[6] = x245;\n    out4[7] = x246;\n    out4[8] = x247;\n    out5[0] = x248;\n    out5[1] = x249;\n    out5[2] = x250;\n    out5[3] = x251;\n    out5[4] = x252;\n    out5[5] = x253;\n    out5[6] = x254;\n    out5[7] = x255;\n    out5[8] = x256;\n}",
    "display_name": "fiat_p521_scalar_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/FieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/loose/impl/FieldElement/From/from"
    ],
    "body": "    fn from(loose: LooseFieldElement) -> FieldElement {\n        FieldElement::from(&loose)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/mul"
    ],
    "body": "    fn mul(self, other: Scalar) -> Scalar {\n        Scalar::mul(&self, &other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, rhs: &Scalar) {\n        *self = *self * rhs\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible"
    ],
    "body": "    pub fn add(&self, other: &DecafPoint) -> DecafPoint {\n        DecafPoint(self.0.to_extensible().add_extended(&other.0).to_extended())\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/AsRef::AffinePoint>/as_ref",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/as_affine"
    ],
    "body": "    fn as_ref(&self) -> &AffinePoint<BignP256> {\n        self.as_affine()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/max_magnitude",
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/add"
    ],
    "body": "    pub fn add(&self, rhs: &Self) -> Self {\n        let new_magnitude = self.magnitude + rhs.magnitude;\n        debug_assert!(new_magnitude <= FieldElementUnsafeImpl::max_magnitude());\n        Self::new(&(self.value.add(&(rhs.value))), new_magnitude)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p521_scalar_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint_unchecked"
    ],
    "body": "    fn from(n: u32) -> FieldElement {\n        Self::from_uint_unchecked(U576::from(n))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_cmovznz_u64(out1: &mut u64, arg1: fiat_p224_u1, arg2: u64, arg3: u64) {\n    let x1: fiat_p224_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_p224_i2) - (x1 as fiat_p224_i2)) as fiat_p224_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_p224_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_ctx",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_inner"
    ],
    "body": "    pub fn verify_ctx(self, sig: &Signature, ctx: &[u8], message: &[u8]) -> Result<(), Error> {\n        self.verify_inner(sig, 0, ctx, message)\n    }",
    "display_name": "verify_ctx",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Group/is_identity",
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    pub fn from_bytes(bytes: &PointBytes) -> Result<Self, Error> {\n        let compressed = CompressedEdwardsY(*bytes);\n        let point = Option::<EdwardsPoint>::from(compressed.decompress())\n            .ok_or(SigningError::InvalidPublicKeyBytes)?;\n        if point.is_identity().into() {\n            return Err(SigningError::InvalidPublicKeyBytes.into());\n        }\n        Ok(Self { compressed, point })\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/with_context",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn with_context<'k, 'v>(&'k self, context: &'v [u8]) -> Context<'k, 'v, Self> {\n        Context {\n            key: self,\n            value: context,\n        }\n    }",
    "display_name": "with_context",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/random",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/from_uniform_bytes"
    ],
    "body": "    pub fn random(mut rng: impl CryptoRng) -> Self {\n        let mut uniform_bytes = [0u8; 112];\n        rng.fill_bytes(&mut uniform_bytes);\n        Self::from_uniform_bytes(&uniform_bytes)\n    }",
    "display_name": "random",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/CofactorGroup/into_subgroup",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/CofactorGroup/clear_cofactor",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_torsion_free"
    ],
    "body": "    fn into_subgroup(self) -> CtOption<Self::Subgroup> {\n        CtOption::new(self.clear_cofactor(), self.is_torsion_free())\n    }",
    "display_name": "into_subgroup",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre bench_field_element_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_field_element_x"
    ],
    "body": "fn bench_field_element_invert<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"invert\", |b| b.iter(|| x.invert()));\n}",
    "display_name": "bench_field_element_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/field.rs",
    "relative_path": "bign256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p521_scalar_u1,\n    arg1: fiat_p521_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_p521_scalar_i1 = ((x1 >> 64) as fiat_p521_scalar_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p521_scalar_i2) - (x2 as fiat_p521_scalar_i2)) as fiat_p521_scalar_u1);\n}",
    "display_name": "fiat_p521_scalar_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add"
    ],
    "body": "    pub const fn double(&self) -> Self {\n        self.add(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/to_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From/from"
    ],
    "body": "    fn to_curve(&self) -> ProjectivePoint {\n        ProjectivePoint::from(*self)\n    }",
    "display_name": "to_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> PointBytes {\n        self.compressed.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_normalize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_normalize<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"normalize\", |b| b.iter(|| black_box(x).normalize()));\n}",
    "display_name": "bench_field_element_normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/Drop/drop",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        self.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/expanded.rs",
    "relative_path": "ed448-goldilocks/src/sign/expanded.rs",
    "file_name": "expanded.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "affine/impl/AffinePoint/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(point: EncodedPoint<C>) -> Result<AffinePoint<C>> {\n        AffinePoint::try_from(&point)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p192_opp(\n    out1: &mut fiat_p192_montgomery_domain_field_element,\n    arg1: &fiat_p192_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x7, x6, (0x0 as u64), 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x8, &mut x9, 0x0, x1, x7);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x10, &mut x11, x9, x3, (x7 & 0xfffffffffffffffe));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x12, &mut x13, x11, x5, x7);\n    out1[0] = x8;\n    out1[1] = x10;\n    out1[2] = x12;\n}",
    "display_name": "fiat_p192_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/prehash_signer_signing_with_sha384",
    "statement_type": "function",
    "deps": [],
    "body": "    fn prehash_signer_signing_with_sha384() {\n        let x = hex!(\"c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\");\n        let signer = SigningKey::from_bytes(&x.into()).unwrap();\n        let digest = sha2::Sha384::digest(b\"test\");\n        let signature: Signature = signer.sign_prehash(&digest).unwrap();\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"ebde85f1539af67e70dd7a8a6afeeb332aa7f08f01ebb6ab6e04e2a62d2fef75\n                 871af45800daddf55619b005a601a7a84f544260f1d2625b2ef5aa7a4f4dd76f\"\n            )\n        );\n    }",
    "display_name": "prehash_signer_signing_with_sha384",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/ecdsa.rs",
    "relative_path": "p256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/tests/bip340_ext_sign_vectors",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/from_bytes",
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/sign_raw",
      "0.14.0_pre.8 schnorr/impl/Signature/to_bytes"
    ],
    "body": "    fn bip340_ext_sign_vectors() {\n        // Test indexes 15-18 from https://github.com/bitcoin/bips/blob/master/bip-0340/test-vectors.csv\n        //\n        // These tests all use the same key and aux\n        let sk = SigningKey::from_bytes(&hex!(\n            \"0340034003400340034003400340034003400340034003400340034003400340\"\n        ))\n        .unwrap();\n\n        let aux_rand = [0u8; 32];\n\n        struct Bip340ExtTest {\n            index: usize,\n            msg: alloc::vec::Vec<u8>,\n            signature: [u8; 64],\n        }\n\n        let bip340_ext_sign_vectors = [\n            Bip340ExtTest {\n                index: 15,\n                msg: vec![],\n                signature: hex!(\n                    \"71535DB165ECD9FBBC046E5FFAEA61186BB6AD436732FCCC25291A55895464CF\n                    6069CE26BF03466228F19A3A62DB8A649F2D560FAC652827D1AF0574E427AB63\"\n                ),\n            },\n            Bip340ExtTest {\n                index: 16,\n                msg: hex!(\"11\").to_vec(),\n                signature: hex!(\n                    \"08A20A0AFEF64124649232E0693C583AB1B9934AE63B4C3511F3AE1134C6A303EA3173BFEA6683BD101FA5AA5DBC1996FE7CACFC5A577D33EC14564CEC2BACBF\"\n                ),\n            },\n            Bip340ExtTest {\n                index: 17,\n                msg: hex!(\"0102030405060708090A0B0C0D0E0F1011\").to_vec(),\n                signature: hex!(\n                    \"5130F39A4059B43BC7CAC09A19ECE52B5D8699D1A71E3C52DA9AFDB6B50AC370C4A482B77BF960F8681540E25B6771ECE1E5A37FD80E5A51897C5566A97EA5A5\"\n                ),\n            },\n            Bip340ExtTest {\n                index: 18,\n                msg: vec![0x99; 100],\n                signature: hex!(\n                    \"403B12B0D8555A344175EA7EC746566303321E5DBFA8BE6F091635163ECA79A8585ED3E3170807E7C03B720FC54C7B23897FCBA0E9D0B4A06894CFD249F22367\"\n                ),\n            },\n        ];\n\n        for vector in bip340_ext_sign_vectors {\n            let sig = sk.sign_raw(&vector.msg, &aux_rand).unwrap_or_else(|_| {\n                panic!(\n                    \"low-level Schnorr signing failure for index {}\",\n                    vector.index\n                )\n            });\n\n            assert_eq!(\n                vector.signature,\n                sig.to_bytes(),\n                \"wrong signature for index {}\",\n                vector.index\n            );\n        }\n    }",
    "display_name": "bip340_ext_sign_vectors",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/generator",
    "statement_type": "function",
    "deps": [],
    "body": "    fn generator() -> Self {\n        Self::GENERATOR\n    }",
    "display_name": "generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 test_scalar_y"
    ],
    "body": "fn bench_scalar_add<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"add\", |b| b.iter(|| black_box(x) + black_box(y)));\n}",
    "display_name": "bench_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero"
    ],
    "body": "    fn reduce_nonzero_bytes(bytes: &FieldBytes) -> Self {\n        let w = <U576 as FieldBytesEncoding<NistP521>>::decode_field_bytes(bytes);\n        Self::reduce_nonzero(w)\n    }",
    "display_name": "reduce_nonzero_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/multiply",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn multiply(&self, rhs: &Self) -> Self {\n        let wide_value = self.0.widening_mul(&rhs.0);\n        Self(U448::rem_wide_vartime(wide_value, &NZ_ORDER))\n    }",
    "display_name": "multiply",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre verify_test_vector",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/from_bytes",
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/Verifier/verify",
      "0.14.0_pre ecdsa/impl/Signature/TryFrom/try_from"
    ],
    "body": "fn verify_test_vector() {\n    let vk = VerifyingKey::from_bytes(&PUBLIC_KEY).unwrap();\n    let sig = Signature::try_from(&SIG).unwrap();\n    assert!(vk.verify(MSG, &sig).is_ok());\n}",
    "display_name": "verify_test_vector",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/dsa.rs",
    "relative_path": "bign256/tests/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Group/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {\n        let compressed =\n            <DecafPointBytes>::try_from(bytes).map_err(|_| \"bytes is not the correct length\")?;\n        Self::try_from(compressed)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_x() -> Scalar {\n    black_box(Scalar::from_repr(\n        hex!(\"01d7bb864c5b5ecae019296cf9b5c63a166f5f1113942819b1933d889a96d12245777a99428f93de4fc9a18d709bf91889d7f8dddd522b4c364aeae13c983e9fae46\").into()\n    ).unwrap())\n}",
    "display_name": "test_scalar_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add(self, other: &Scalar) -> Scalar {\n        Scalar::add(self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/compress",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/inverse_square_root",
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes",
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative"
    ],
    "body": "    pub fn compress(&self) -> CompressedDecaf {\n        let X = self.0.X;\n        // let Y = self.0.Y;\n        let Z = self.0.Z;\n        let T = self.0.T;\n\n        let XX_TT = (X + T) * (X - T);\n\n        let (isr, _) = (X.square() * XX_TT * FieldElement::NEG_EDWARDS_D).inverse_square_root();\n        let mut ratio = isr * XX_TT;\n        let altx = ratio * FieldElement::DECAF_FACTOR; // Sign choice\n        ratio.conditional_negate(altx.is_negative());\n        let k = ratio * Z - T;\n\n        let mut s = k * FieldElement::NEG_EDWARDS_D * isr * X;\n        s.conditional_negate(s.is_negative());\n\n        CompressedDecaf(s.to_bytes())\n    }",
    "display_name": "compress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/decompress"
    ],
    "body": "    fn try_from(bytes: DecafPointBytes) -> Result<Self, Self::Error> {\n        let pt = CompressedDecaf(bytes);\n        let _ = Option::<DecafPoint>::from(pt.decompress()).ok_or(\"Invalid point encoding\")?;\n        Ok(pt)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/LowerHex/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        write!(\n            f,\n            \"{{ X: {:x}, Y: {:x}, Z: {:x}, T: {:x} }}\",\n            self.X, self.Y, self.Z, self.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/LowerHex/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        write!(\n            f,\n            \"{{ X: {:x}, Y: {:x}, Z: {:x}, T: {:x} }}\",\n            self.0.X, self.0.Y, self.0.Z, self.0.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/into_limbs",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn into_limbs(self) -> [u64; 9] {\n        self.0.0\n    }",
    "display_name": "into_limbs",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        Scalar::invert(self)\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(ConstMontyType::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_mul(\n    out1: &mut fiat_p192_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p192_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p192_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[0]);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x4, &mut x5, x3, (arg2[2]));\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x6, &mut x7, x3, (arg2[1]));\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x8, &mut x9, x3, (arg2[0]));\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x9, x6);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x7, x4);\n    let x14: u64 = ((x13 as u64) + x5);\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x15, &mut x16, x8, 0x882672070ddbcf2f);\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x17, &mut x18, x15, 0xffffffffffffffff);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x19, &mut x20, x15, 0xffffffff99def836);\n    let mut x21: u64 = 0;\n    let mut x22: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x21, &mut x22, x15, 0x146bc9b1b4d22831);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x23, &mut x24, 0x0, x22, x19);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x25, &mut x26, x24, x20, x17);\n    let x27: u64 = ((x26 as u64) + x18);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x28, &mut x29, 0x0, x8, x21);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x10, x23);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x12, x25);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x14, x27);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x36, &mut x37, x1, (arg2[2]));\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x38, &mut x39, x1, (arg2[1]));\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x40, &mut x41, x1, (arg2[0]));\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x42, &mut x43, 0x0, x41, x38);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x44, &mut x45, x43, x39, x36);\n    let x46: u64 = ((x45 as u64) + x37);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x47, &mut x48, 0x0, x30, x40);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x49, &mut x50, x48, x32, x42);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x51, &mut x52, x50, x34, x44);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x53, &mut x54, x52, (x35 as u64), x46);\n    let mut x55: u64 = 0;\n    let mut x56: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x55, &mut x56, x47, 0x882672070ddbcf2f);\n    let mut x57: u64 = 0;\n    let mut x58: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x57, &mut x58, x55, 0xffffffffffffffff);\n    let mut x59: u64 = 0;\n    let mut x60: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x59, &mut x60, x55, 0xffffffff99def836);\n    let mut x61: u64 = 0;\n    let mut x62: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x61, &mut x62, x55, 0x146bc9b1b4d22831);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x63, &mut x64, 0x0, x62, x59);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x65, &mut x66, x64, x60, x57);\n    let x67: u64 = ((x66 as u64) + x58);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x68, &mut x69, 0x0, x47, x61);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x70, &mut x71, x69, x49, x63);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x72, &mut x73, x71, x51, x65);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x74, &mut x75, x73, x53, x67);\n    let x76: u64 = ((x75 as u64) + (x54 as u64));\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x77, &mut x78, x2, (arg2[2]));\n    let mut x79: u64 = 0;\n    let mut x80: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x79, &mut x80, x2, (arg2[1]));\n    let mut x81: u64 = 0;\n    let mut x82: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x81, &mut x82, x2, (arg2[0]));\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x83, &mut x84, 0x0, x82, x79);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x85, &mut x86, x84, x80, x77);\n    let x87: u64 = ((x86 as u64) + x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x88, &mut x89, 0x0, x70, x81);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x72, x83);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x92, &mut x93, x91, x74, x85);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x76, x87);\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x96, &mut x97, x88, 0x882672070ddbcf2f);\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x98, &mut x99, x96, 0xffffffffffffffff);\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x100, &mut x101, x96, 0xffffffff99def836);\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x102, &mut x103, x96, 0x146bc9b1b4d22831);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x104, &mut x105, 0x0, x103, x100);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x106, &mut x107, x105, x101, x98);\n    let x108: u64 = ((x107 as u64) + x99);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x109, &mut x110, 0x0, x88, x102);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x111, &mut x112, x110, x90, x104);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x113, &mut x114, x112, x92, x106);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x115, &mut x116, x114, x94, x108);\n    let x117: u64 = ((x116 as u64) + (x95 as u64));\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x118, &mut x119, 0x0, x111, 0x146bc9b1b4d22831);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x120, &mut x121, x119, x113, 0xffffffff99def836);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x122, &mut x123, x121, x115, 0xffffffffffffffff);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x124, &mut x125, x123, x117, (0x0 as u64));\n    let mut x126: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x126, x125, x118, x111);\n    let mut x127: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x127, x125, x120, x113);\n    let mut x128: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x128, x125, x122, x115);\n    out1[0] = x126;\n    out1[1] = x127;\n    out1[2] = x128;\n}",
    "display_name": "fiat_p192_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: FieldElement) {\n        *self = *self - other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/relax",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_relax"
    ],
    "body": "    pub const fn relax(&self) -> LooseFieldElement {\n        let mut out = fiat_p521_loose_field_element([0; 9]);\n        fiat_p521_relax(&mut out, &self.0);\n        LooseFieldElement(out)\n    }",
    "display_name": "relax",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/DecompactPoint/decompact",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/DecompressPoint/decompress",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/new",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero"
    ],
    "body": "    fn from_encoded_point(encoded_point: &EncodedPoint) -> CtOption<Self> {\n        match encoded_point.coordinates() {\n            sec1::Coordinates::Identity => CtOption::new(Self::IDENTITY, 1.into()),\n            sec1::Coordinates::Compact { x } => Self::decompact(x),\n            sec1::Coordinates::Compressed { x, y_is_odd } => {\n                AffinePoint::decompress(x, Choice::from(y_is_odd as u8))\n            }\n            sec1::Coordinates::Uncompressed { x, y } => {\n                let x = FieldElement::from_bytes(x);\n                let y = FieldElement::from_bytes(y);\n\n                x.and_then(|x| {\n                    y.and_then(|y| {\n                        // Check that the point is on the curve\n                        let lhs = (y * &y).negate(1);\n                        let rhs = x * &x * &x + &CURVE_EQUATION_B;\n                        let point = Self::new(x, y);\n                        CtOption::new(point, (lhs + &rhs).normalizes_to_zero())\n                    })\n                })\n            }\n        }\n    }",
    "display_name": "from_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_set_one(out1: &mut fiat_bign256_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0xbd;\n    out1[1] = (0x0 as u64);\n    out1[2] = (0x0 as u64);\n    out1[3] = (0x0 as u64);\n}",
    "display_name": "fiat_bign256_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/add_then_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sub"
    ],
    "body": "        fn add_then_sub(\n            a0 in ANY,\n            a1 in ANY,\n            a2 in ANY,\n            b0 in ANY,\n            b1 in ANY,\n            b2 in ANY,\n        ) {\n            let a = FieldElement(U256::from_words([a0, a1, a2, 0]));\n            let b = FieldElement(U256::from_words([b0, b1, b2, 0]));\n            assert_eq!(a.add(&b).sub(&a), b);\n        }",
    "display_name": "add_then_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/PartialEq/eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        (self.r == other.r) && (self.s.ct_eq(&other.s).into())\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/AffinePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine"
    ],
    "body": "    fn from(value: &EdwardsPoint) -> Self {\n        value.to_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Shr/shr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime"
    ],
    "body": "    fn shr(self, rhs: usize) -> Self::Output {\n        self.shr_vartime(rhs as u32)\n    }",
    "display_name": "shr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/dev/bytes_to_biguint",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn bytes_to_biguint(bytes: &[u8; 32]) -> BigUint {\n    bytes\n        .iter()\n        .enumerate()\n        .map(|(i, w)| w.to_biguint().unwrap() << ((31 - i) * 8))\n        .sum()\n}",
    "display_name": "bytes_to_biguint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/dev.rs",
    "relative_path": "k256/src/arithmetic/dev.rs",
    "file_name": "dev.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_set_one(out1: &mut fiat_p521_scalar_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0xfb80000000000000;\n    out1[1] = 0x28a2482470b763cd;\n    out1[2] = 0x17e2251b23bb31dc;\n    out1[3] = 0xca4019ff5b847b2d;\n    out1[4] = 0x2d73cbc3e206834;\n    out1[5] = (0x0 as u64);\n    out1[6] = (0x0 as u64);\n    out1[7] = (0x0 as u64);\n    out1[8] = (0x0 as u64);\n}",
    "display_name": "fiat_p521_scalar_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl//u8; _//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/impl/Signature/to_bytes"
    ],
    "body": "    fn from(signature: &Signature) -> SignatureBytes {\n        signature.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_divstep_precomp(out1: &mut [u64; 6]) {\n    out1[0] = 0x49589ae0e6045b6a;\n    out1[1] = 0x3c9a5352870040ed;\n    out1[2] = 0xdacb097e977dc242;\n    out1[3] = 0xb5ab30a6d1ecbe36;\n    out1[4] = 0x97d7a1081f959973;\n    out1[5] = 0x2ba012f8d27192bc;\n}",
    "display_name": "fiat_p384_scalar_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_mulx_u64"
    ],
    "body": "pub const fn fiat_sm2_to_montgomery(\n    out1: &mut fiat_sm2_montgomery_domain_field_element,\n    arg1: &fiat_sm2_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x5, &mut x6, x4, 0x400000002);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x7, &mut x8, x4, 0x100000001);\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x9, &mut x10, x4, 0x2ffffffff);\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x11, &mut x12, x4, 0x200000003);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x19, &mut x20, x11, 0xfffffffeffffffff);\n    let mut x21: u64 = 0;\n    let mut x22: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x21, &mut x22, x11, 0xffffffffffffffff);\n    let mut x23: u64 = 0;\n    let mut x24: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x23, &mut x24, x11, 0xffffffff00000000);\n    let mut x25: u64 = 0;\n    let mut x26: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x25, &mut x26, x11, 0xffffffffffffffff);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x27, &mut x28, 0x0, x26, x23);\n    let mut x29: u64 = 0;\n    let mut x30: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x29, &mut x30, x28, x24, x21);\n    let mut x31: u64 = 0;\n    let mut x32: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x31, &mut x32, x30, x22, x19);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x33, &mut x34, 0x0, x11, x25);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x35, &mut x36, x34, x13, x27);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x37, &mut x38, x36, x15, x29);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x39, &mut x40, x38, x17, x31);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(\n        &mut x41,\n        &mut x42,\n        x40,\n        ((x18 as u64) + x6),\n        ((x32 as u64) + x20),\n    );\n    let mut x43: u64 = 0;\n    let mut x44: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x43, &mut x44, x1, 0x400000002);\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x45, &mut x46, x1, 0x100000001);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x47, &mut x48, x1, 0x2ffffffff);\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x49, &mut x50, x1, 0x200000003);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x51, &mut x52, 0x0, x50, x47);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x53, &mut x54, x52, x48, x45);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x55, &mut x56, x54, x46, x43);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x57, &mut x58, 0x0, x35, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x59, &mut x60, x58, x37, x51);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x61, &mut x62, x60, x39, x53);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x63, &mut x64, x62, x41, x55);\n    let mut x65: u64 = 0;\n    let mut x66: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x65, &mut x66, x57, 0xfffffffeffffffff);\n    let mut x67: u64 = 0;\n    let mut x68: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x67, &mut x68, x57, 0xffffffffffffffff);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x69, &mut x70, x57, 0xffffffff00000000);\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x71, &mut x72, x57, 0xffffffffffffffff);\n    let mut x73: u64 = 0;\n    let mut x74: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x73, &mut x74, 0x0, x72, x69);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x75, &mut x76, x74, x70, x67);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x77, &mut x78, x76, x68, x65);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x79, &mut x80, 0x0, x57, x71);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x81, &mut x82, x80, x59, x73);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x83, &mut x84, x82, x61, x75);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x85, &mut x86, x84, x63, x77);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(\n        &mut x87,\n        &mut x88,\n        x86,\n        (((x64 as u64) + (x42 as u64)) + ((x56 as u64) + x44)),\n        ((x78 as u64) + x66),\n    );\n    let mut x89: u64 = 0;\n    let mut x90: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x89, &mut x90, x2, 0x400000002);\n    let mut x91: u64 = 0;\n    let mut x92: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x91, &mut x92, x2, 0x100000001);\n    let mut x93: u64 = 0;\n    let mut x94: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x93, &mut x94, x2, 0x2ffffffff);\n    let mut x95: u64 = 0;\n    let mut x96: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x95, &mut x96, x2, 0x200000003);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x97, &mut x98, 0x0, x96, x93);\n    let mut x99: u64 = 0;\n    let mut x100: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x99, &mut x100, x98, x94, x91);\n    let mut x101: u64 = 0;\n    let mut x102: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x101, &mut x102, x100, x92, x89);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x103, &mut x104, 0x0, x81, x95);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x105, &mut x106, x104, x83, x97);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x107, &mut x108, x106, x85, x99);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x109, &mut x110, x108, x87, x101);\n    let mut x111: u64 = 0;\n    let mut x112: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x111, &mut x112, x103, 0xfffffffeffffffff);\n    let mut x113: u64 = 0;\n    let mut x114: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x113, &mut x114, x103, 0xffffffffffffffff);\n    let mut x115: u64 = 0;\n    let mut x116: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x115, &mut x116, x103, 0xffffffff00000000);\n    let mut x117: u64 = 0;\n    let mut x118: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x117, &mut x118, x103, 0xffffffffffffffff);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x119, &mut x120, 0x0, x118, x115);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x121, &mut x122, x120, x116, x113);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x123, &mut x124, x122, x114, x111);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x125, &mut x126, 0x0, x103, x117);\n    let mut x127: u64 = 0;\n    let mut x128: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x127, &mut x128, x126, x105, x119);\n    let mut x129: u64 = 0;\n    let mut x130: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x129, &mut x130, x128, x107, x121);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x131, &mut x132, x130, x109, x123);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(\n        &mut x133,\n        &mut x134,\n        x132,\n        (((x110 as u64) + (x88 as u64)) + ((x102 as u64) + x90)),\n        ((x124 as u64) + x112),\n    );\n    let mut x135: u64 = 0;\n    let mut x136: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x135, &mut x136, x3, 0x400000002);\n    let mut x137: u64 = 0;\n    let mut x138: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x137, &mut x138, x3, 0x100000001);\n    let mut x139: u64 = 0;\n    let mut x140: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x139, &mut x140, x3, 0x2ffffffff);\n    let mut x141: u64 = 0;\n    let mut x142: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x141, &mut x142, x3, 0x200000003);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x143, &mut x144, 0x0, x142, x139);\n    let mut x145: u64 = 0;\n    let mut x146: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x145, &mut x146, x144, x140, x137);\n    let mut x147: u64 = 0;\n    let mut x148: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x147, &mut x148, x146, x138, x135);\n    let mut x149: u64 = 0;\n    let mut x150: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x149, &mut x150, 0x0, x127, x141);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x151, &mut x152, x150, x129, x143);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x153, &mut x154, x152, x131, x145);\n    let mut x155: u64 = 0;\n    let mut x156: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x155, &mut x156, x154, x133, x147);\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x157, &mut x158, x149, 0xfffffffeffffffff);\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x159, &mut x160, x149, 0xffffffffffffffff);\n    let mut x161: u64 = 0;\n    let mut x162: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x161, &mut x162, x149, 0xffffffff00000000);\n    let mut x163: u64 = 0;\n    let mut x164: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x163, &mut x164, x149, 0xffffffffffffffff);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x165, &mut x166, 0x0, x164, x161);\n    let mut x167: u64 = 0;\n    let mut x168: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x167, &mut x168, x166, x162, x159);\n    let mut x169: u64 = 0;\n    let mut x170: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x169, &mut x170, x168, x160, x157);\n    let mut x171: u64 = 0;\n    let mut x172: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x171, &mut x172, 0x0, x149, x163);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x173, &mut x174, x172, x151, x165);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x175, &mut x176, x174, x153, x167);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x177, &mut x178, x176, x155, x169);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(\n        &mut x179,\n        &mut x180,\n        x178,\n        (((x156 as u64) + (x134 as u64)) + ((x148 as u64) + x136)),\n        ((x170 as u64) + x158),\n    );\n    let mut x181: u64 = 0;\n    let mut x182: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x181, &mut x182, 0x0, x173, 0xffffffffffffffff);\n    let mut x183: u64 = 0;\n    let mut x184: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x183, &mut x184, x182, x175, 0xffffffff00000000);\n    let mut x185: u64 = 0;\n    let mut x186: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x185, &mut x186, x184, x177, 0xffffffffffffffff);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x187, &mut x188, x186, x179, 0xfffffffeffffffff);\n    let mut x189: u64 = 0;\n    let mut x190: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x189, &mut x190, x188, (x180 as u64), (0x0 as u64));\n    let mut x191: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x191, x190, x181, x173);\n    let mut x192: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x192, x190, x183, x175);\n    let mut x193: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x193, x190, x185, x177);\n    let mut x194: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x194, x190, x187, x179);\n    out1[0] = x191;\n    out1[1] = x192;\n    out1[2] = x193;\n    out1[3] = x194;\n}",
    "display_name": "fiat_sm2_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/sign_raw",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_raw"
    ],
    "body": "    pub fn sign_raw(&self, message: &[u8]) -> Signature {\n        let sig = self\n            .secret\n            .sign_raw(message)\n            .expect(\"to succeed since no context is provided\");\n        sig.into()\n    }",
    "display_name": "sign_raw",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p384_scalar_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/ShrAssign/shr_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn shr_assign(&mut self, shift: usize) {\n        self.0 >>= shift;\n    }",
    "display_name": "shr_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Sum/sum",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Add/add"
    ],
    "body": "    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Add::add).unwrap_or(Self::ZERO)\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [],
    "body": "    fn is_high(&self) -> Choice {\n        self.0.ct_gt(&HALF_ORDER)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/mul_shift_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/mul_wide"
    ],
    "body": "    pub(crate) fn mul_shift_vartime(a: &Scalar, b: &Scalar, shift: usize) -> Scalar {\n        debug_assert!(shift >= 256);\n\n        let l = Self::mul_wide(a, b).0.to_words();\n        let shiftlimbs = shift >> 6;\n        let shiftlow = shift & 0x3F;\n        let shifthigh = 64 - shiftlow;\n\n        let r0 = if shift < 512 {\n            let lo = l[shiftlimbs] >> shiftlow;\n            let hi = if shift < 448 && shiftlow != 0 {\n                l[1 + shiftlimbs] << shifthigh\n            } else {\n                0\n            };\n            hi | lo\n        } else {\n            0\n        };\n\n        let r1 = if shift < 448 {\n            let lo = l[1 + shiftlimbs] >> shiftlow;\n            let hi = if shift < 384 && shiftlow != 0 {\n                l[2 + shiftlimbs] << shifthigh\n            } else {\n                0\n            };\n            hi | lo\n        } else {\n            0\n        };\n\n        let r2 = if shift < 384 {\n            let lo = l[2 + shiftlimbs] >> shiftlow;\n            let hi = if shift < 320 && shiftlow != 0 {\n                l[3 + shiftlimbs] << shifthigh\n            } else {\n                0\n            };\n            hi | lo\n        } else {\n            0\n        };\n\n        let r3 = if shift < 320 {\n            l[3 + shiftlimbs] >> shiftlow\n        } else {\n            0\n        };\n\n        let res = Scalar(U256::from_words([r0, r1, r2, r3]));\n\n        // Check the highmost discarded bit and round up if it is set.\n        let c = (l[(shift - 1) >> 6] >> ((shift - 1) & 0x3f)) & 1;\n        Scalar::conditional_select(&res, &res.add(&Scalar::ONE), Choice::from(c as u8))\n    }",
    "display_name": "mul_shift_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre encode_pkcs8_public_key_to_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_public_key_to_pem() {\n    let original_public_key = PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    let reencoded_public_key = original_public_key.to_string();\n    assert_eq!(reencoded_public_key.as_str(), PKCS8_PUBLIC_KEY_PEM);\n}",
    "display_name": "encode_pkcs8_public_key_to_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/pkcs8.rs",
    "relative_path": "bign256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double_loose",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add_loose"
    ],
    "body": "    pub const fn double_loose(&self) -> LooseFieldElement {\n        self.add_loose(self)\n    }",
    "display_name": "double_loose",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_mulx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_to_montgomery(\n    out1: &mut fiat_p521_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p521_scalar_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[6]);\n    let x7: u64 = (arg1[7]);\n    let x8: u64 = (arg1[8]);\n    let x9: u64 = (arg1[0]);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x10, &mut x11, x9, 0x3d);\n    let mut x12: u64 = 0;\n    let mut x13: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x12, &mut x13, x9, 0x2d8e03d1492d0d45);\n    let mut x14: u64 = 0;\n    let mut x15: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x14, &mut x15, x9, 0x5bcc6d61a8e567bc);\n    let mut x16: u64 = 0;\n    let mut x17: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x16, &mut x17, x9, 0xcff3d142b7756e3e);\n    let mut x18: u64 = 0;\n    let mut x19: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x18, &mut x19, x9, 0xdd6e23d82e49c7db);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x20, &mut x21, x9, 0xd3721ef557f75e06);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x22, &mut x23, x9, 0x12a78d38794573ff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x24, &mut x25, x9, 0xf707badce5547ea3);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x26, &mut x27, x9, 0x137cd04dcf15dd04);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x28, &mut x29, 0x0, x27, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x25, x22);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x23, x20);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x21, x18);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x36, &mut x37, x35, x19, x16);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x38, &mut x39, x37, x17, x14);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x40, &mut x41, x39, x15, x12);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x42, &mut x43, x41, x13, x10);\n    let mut x44: u64 = 0;\n    let mut x45: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x44, &mut x45, x26, 0x1d2f5ccd79a995c7);\n    let mut x46: u64 = 0;\n    let mut x47: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x46, &mut x47, x44, 0x1ff);\n    let mut x48: u64 = 0;\n    let mut x49: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x48, &mut x49, x44, 0xffffffffffffffff);\n    let mut x50: u64 = 0;\n    let mut x51: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x50, &mut x51, x44, 0xffffffffffffffff);\n    let mut x52: u64 = 0;\n    let mut x53: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x52, &mut x53, x44, 0xffffffffffffffff);\n    let mut x54: u64 = 0;\n    let mut x55: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x54, &mut x55, x44, 0xfffffffffffffffa);\n    let mut x56: u64 = 0;\n    let mut x57: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x56, &mut x57, x44, 0x51868783bf2f966b);\n    let mut x58: u64 = 0;\n    let mut x59: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x58, &mut x59, x44, 0x7fcc0148f709a5d0);\n    let mut x60: u64 = 0;\n    let mut x61: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x60, &mut x61, x44, 0x3bb5c9b8899c47ae);\n    let mut x62: u64 = 0;\n    let mut x63: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x62, &mut x63, x44, 0xbb6fb71e91386409);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x64, &mut x65, 0x0, x63, x60);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x61, x58);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x59, x56);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x70, &mut x71, x69, x57, x54);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x72, &mut x73, x71, x55, x52);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x74, &mut x75, x73, x53, x50);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x76, &mut x77, x75, x51, x48);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x78, &mut x79, x77, x49, x46);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x80, &mut x81, 0x0, x26, x62);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x28, x64);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x30, x66);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x32, x68);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x34, x70);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x36, x72);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x92, &mut x93, x91, x38, x74);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x40, x76);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x42, x78);\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x98, &mut x99, x1, 0x3d);\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x100, &mut x101, x1, 0x2d8e03d1492d0d45);\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x102, &mut x103, x1, 0x5bcc6d61a8e567bc);\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x104, &mut x105, x1, 0xcff3d142b7756e3e);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x106, &mut x107, x1, 0xdd6e23d82e49c7db);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x108, &mut x109, x1, 0xd3721ef557f75e06);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x110, &mut x111, x1, 0x12a78d38794573ff);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x112, &mut x113, x1, 0xf707badce5547ea3);\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x114, &mut x115, x1, 0x137cd04dcf15dd04);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x116, &mut x117, 0x0, x115, x112);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x118, &mut x119, x117, x113, x110);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x120, &mut x121, x119, x111, x108);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x109, x106);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x124, &mut x125, x123, x107, x104);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x126, &mut x127, x125, x105, x102);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x128, &mut x129, x127, x103, x100);\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x130, &mut x131, x129, x101, x98);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x132, &mut x133, 0x0, x82, x114);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x134, &mut x135, x133, x84, x116);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x136, &mut x137, x135, x86, x118);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x138, &mut x139, x137, x88, x120);\n    let mut x140: u64 = 0;\n    let mut x141: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x140, &mut x141, x139, x90, x122);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x142, &mut x143, x141, x92, x124);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x144, &mut x145, x143, x94, x126);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x146, &mut x147, x145, x96, x128);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x148,\n        &mut x149,\n        x147,\n        (((x97 as u64) + ((x43 as u64) + x11)) + ((x79 as u64) + x47)),\n        x130,\n    );\n    let mut x150: u64 = 0;\n    let mut x151: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x150, &mut x151, x132, 0x1d2f5ccd79a995c7);\n    let mut x152: u64 = 0;\n    let mut x153: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x152, &mut x153, x150, 0x1ff);\n    let mut x154: u64 = 0;\n    let mut x155: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x154, &mut x155, x150, 0xffffffffffffffff);\n    let mut x156: u64 = 0;\n    let mut x157: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x156, &mut x157, x150, 0xffffffffffffffff);\n    let mut x158: u64 = 0;\n    let mut x159: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x158, &mut x159, x150, 0xffffffffffffffff);\n    let mut x160: u64 = 0;\n    let mut x161: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x160, &mut x161, x150, 0xfffffffffffffffa);\n    let mut x162: u64 = 0;\n    let mut x163: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x162, &mut x163, x150, 0x51868783bf2f966b);\n    let mut x164: u64 = 0;\n    let mut x165: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x164, &mut x165, x150, 0x7fcc0148f709a5d0);\n    let mut x166: u64 = 0;\n    let mut x167: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x166, &mut x167, x150, 0x3bb5c9b8899c47ae);\n    let mut x168: u64 = 0;\n    let mut x169: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x168, &mut x169, x150, 0xbb6fb71e91386409);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x170, &mut x171, 0x0, x169, x166);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x167, x164);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x165, x162);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x163, x160);\n    let mut x178: u64 = 0;\n    let mut x179: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x178, &mut x179, x177, x161, x158);\n    let mut x180: u64 = 0;\n    let mut x181: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x180, &mut x181, x179, x159, x156);\n    let mut x182: u64 = 0;\n    let mut x183: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x182, &mut x183, x181, x157, x154);\n    let mut x184: u64 = 0;\n    let mut x185: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x184, &mut x185, x183, x155, x152);\n    let mut x186: u64 = 0;\n    let mut x187: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x186, &mut x187, 0x0, x132, x168);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x188, &mut x189, x187, x134, x170);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x190, &mut x191, x189, x136, x172);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x138, x174);\n    let mut x194: u64 = 0;\n    let mut x195: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x194, &mut x195, x193, x140, x176);\n    let mut x196: u64 = 0;\n    let mut x197: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x196, &mut x197, x195, x142, x178);\n    let mut x198: u64 = 0;\n    let mut x199: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x198, &mut x199, x197, x144, x180);\n    let mut x200: u64 = 0;\n    let mut x201: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x200, &mut x201, x199, x146, x182);\n    let mut x202: u64 = 0;\n    let mut x203: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x202, &mut x203, x201, x148, x184);\n    let mut x204: u64 = 0;\n    let mut x205: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x204, &mut x205, x2, 0x3d);\n    let mut x206: u64 = 0;\n    let mut x207: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x206, &mut x207, x2, 0x2d8e03d1492d0d45);\n    let mut x208: u64 = 0;\n    let mut x209: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x208, &mut x209, x2, 0x5bcc6d61a8e567bc);\n    let mut x210: u64 = 0;\n    let mut x211: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x210, &mut x211, x2, 0xcff3d142b7756e3e);\n    let mut x212: u64 = 0;\n    let mut x213: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x212, &mut x213, x2, 0xdd6e23d82e49c7db);\n    let mut x214: u64 = 0;\n    let mut x215: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x214, &mut x215, x2, 0xd3721ef557f75e06);\n    let mut x216: u64 = 0;\n    let mut x217: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x216, &mut x217, x2, 0x12a78d38794573ff);\n    let mut x218: u64 = 0;\n    let mut x219: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x218, &mut x219, x2, 0xf707badce5547ea3);\n    let mut x220: u64 = 0;\n    let mut x221: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x220, &mut x221, x2, 0x137cd04dcf15dd04);\n    let mut x222: u64 = 0;\n    let mut x223: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x222, &mut x223, 0x0, x221, x218);\n    let mut x224: u64 = 0;\n    let mut x225: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x224, &mut x225, x223, x219, x216);\n    let mut x226: u64 = 0;\n    let mut x227: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x226, &mut x227, x225, x217, x214);\n    let mut x228: u64 = 0;\n    let mut x229: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x228, &mut x229, x227, x215, x212);\n    let mut x230: u64 = 0;\n    let mut x231: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x230, &mut x231, x229, x213, x210);\n    let mut x232: u64 = 0;\n    let mut x233: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x232, &mut x233, x231, x211, x208);\n    let mut x234: u64 = 0;\n    let mut x235: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x234, &mut x235, x233, x209, x206);\n    let mut x236: u64 = 0;\n    let mut x237: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x236, &mut x237, x235, x207, x204);\n    let mut x238: u64 = 0;\n    let mut x239: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x238, &mut x239, 0x0, x188, x220);\n    let mut x240: u64 = 0;\n    let mut x241: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x240, &mut x241, x239, x190, x222);\n    let mut x242: u64 = 0;\n    let mut x243: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x242, &mut x243, x241, x192, x224);\n    let mut x244: u64 = 0;\n    let mut x245: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x244, &mut x245, x243, x194, x226);\n    let mut x246: u64 = 0;\n    let mut x247: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x246, &mut x247, x245, x196, x228);\n    let mut x248: u64 = 0;\n    let mut x249: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x248, &mut x249, x247, x198, x230);\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x250, &mut x251, x249, x200, x232);\n    let mut x252: u64 = 0;\n    let mut x253: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x252, &mut x253, x251, x202, x234);\n    let mut x254: u64 = 0;\n    let mut x255: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x254,\n        &mut x255,\n        x253,\n        (((x203 as u64) + ((x149 as u64) + ((x131 as u64) + x99))) + ((x185 as u64) + x153)),\n        x236,\n    );\n    let mut x256: u64 = 0;\n    let mut x257: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x256, &mut x257, x238, 0x1d2f5ccd79a995c7);\n    let mut x258: u64 = 0;\n    let mut x259: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x258, &mut x259, x256, 0x1ff);\n    let mut x260: u64 = 0;\n    let mut x261: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x260, &mut x261, x256, 0xffffffffffffffff);\n    let mut x262: u64 = 0;\n    let mut x263: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x262, &mut x263, x256, 0xffffffffffffffff);\n    let mut x264: u64 = 0;\n    let mut x265: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x264, &mut x265, x256, 0xffffffffffffffff);\n    let mut x266: u64 = 0;\n    let mut x267: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x266, &mut x267, x256, 0xfffffffffffffffa);\n    let mut x268: u64 = 0;\n    let mut x269: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x268, &mut x269, x256, 0x51868783bf2f966b);\n    let mut x270: u64 = 0;\n    let mut x271: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x270, &mut x271, x256, 0x7fcc0148f709a5d0);\n    let mut x272: u64 = 0;\n    let mut x273: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x272, &mut x273, x256, 0x3bb5c9b8899c47ae);\n    let mut x274: u64 = 0;\n    let mut x275: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x274, &mut x275, x256, 0xbb6fb71e91386409);\n    let mut x276: u64 = 0;\n    let mut x277: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x276, &mut x277, 0x0, x275, x272);\n    let mut x278: u64 = 0;\n    let mut x279: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x278, &mut x279, x277, x273, x270);\n    let mut x280: u64 = 0;\n    let mut x281: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x280, &mut x281, x279, x271, x268);\n    let mut x282: u64 = 0;\n    let mut x283: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x282, &mut x283, x281, x269, x266);\n    let mut x284: u64 = 0;\n    let mut x285: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x284, &mut x285, x283, x267, x264);\n    let mut x286: u64 = 0;\n    let mut x287: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x286, &mut x287, x285, x265, x262);\n    let mut x288: u64 = 0;\n    let mut x289: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x288, &mut x289, x287, x263, x260);\n    let mut x290: u64 = 0;\n    let mut x291: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x290, &mut x291, x289, x261, x258);\n    let mut x292: u64 = 0;\n    let mut x293: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x292, &mut x293, 0x0, x238, x274);\n    let mut x294: u64 = 0;\n    let mut x295: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x294, &mut x295, x293, x240, x276);\n    let mut x296: u64 = 0;\n    let mut x297: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x296, &mut x297, x295, x242, x278);\n    let mut x298: u64 = 0;\n    let mut x299: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x298, &mut x299, x297, x244, x280);\n    let mut x300: u64 = 0;\n    let mut x301: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x300, &mut x301, x299, x246, x282);\n    let mut x302: u64 = 0;\n    let mut x303: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x302, &mut x303, x301, x248, x284);\n    let mut x304: u64 = 0;\n    let mut x305: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x304, &mut x305, x303, x250, x286);\n    let mut x306: u64 = 0;\n    let mut x307: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x306, &mut x307, x305, x252, x288);\n    let mut x308: u64 = 0;\n    let mut x309: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x308, &mut x309, x307, x254, x290);\n    let mut x310: u64 = 0;\n    let mut x311: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x310, &mut x311, x3, 0x3d);\n    let mut x312: u64 = 0;\n    let mut x313: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x312, &mut x313, x3, 0x2d8e03d1492d0d45);\n    let mut x314: u64 = 0;\n    let mut x315: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x314, &mut x315, x3, 0x5bcc6d61a8e567bc);\n    let mut x316: u64 = 0;\n    let mut x317: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x316, &mut x317, x3, 0xcff3d142b7756e3e);\n    let mut x318: u64 = 0;\n    let mut x319: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x318, &mut x319, x3, 0xdd6e23d82e49c7db);\n    let mut x320: u64 = 0;\n    let mut x321: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x320, &mut x321, x3, 0xd3721ef557f75e06);\n    let mut x322: u64 = 0;\n    let mut x323: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x322, &mut x323, x3, 0x12a78d38794573ff);\n    let mut x324: u64 = 0;\n    let mut x325: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x324, &mut x325, x3, 0xf707badce5547ea3);\n    let mut x326: u64 = 0;\n    let mut x327: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x326, &mut x327, x3, 0x137cd04dcf15dd04);\n    let mut x328: u64 = 0;\n    let mut x329: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x328, &mut x329, 0x0, x327, x324);\n    let mut x330: u64 = 0;\n    let mut x331: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x330, &mut x331, x329, x325, x322);\n    let mut x332: u64 = 0;\n    let mut x333: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x332, &mut x333, x331, x323, x320);\n    let mut x334: u64 = 0;\n    let mut x335: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x334, &mut x335, x333, x321, x318);\n    let mut x336: u64 = 0;\n    let mut x337: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x336, &mut x337, x335, x319, x316);\n    let mut x338: u64 = 0;\n    let mut x339: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x338, &mut x339, x337, x317, x314);\n    let mut x340: u64 = 0;\n    let mut x341: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x340, &mut x341, x339, x315, x312);\n    let mut x342: u64 = 0;\n    let mut x343: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x342, &mut x343, x341, x313, x310);\n    let mut x344: u64 = 0;\n    let mut x345: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x344, &mut x345, 0x0, x294, x326);\n    let mut x346: u64 = 0;\n    let mut x347: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x346, &mut x347, x345, x296, x328);\n    let mut x348: u64 = 0;\n    let mut x349: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x348, &mut x349, x347, x298, x330);\n    let mut x350: u64 = 0;\n    let mut x351: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x350, &mut x351, x349, x300, x332);\n    let mut x352: u64 = 0;\n    let mut x353: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x352, &mut x353, x351, x302, x334);\n    let mut x354: u64 = 0;\n    let mut x355: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x354, &mut x355, x353, x304, x336);\n    let mut x356: u64 = 0;\n    let mut x357: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x356, &mut x357, x355, x306, x338);\n    let mut x358: u64 = 0;\n    let mut x359: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x358, &mut x359, x357, x308, x340);\n    let mut x360: u64 = 0;\n    let mut x361: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x360,\n        &mut x361,\n        x359,\n        (((x309 as u64) + ((x255 as u64) + ((x237 as u64) + x205))) + ((x291 as u64) + x259)),\n        x342,\n    );\n    let mut x362: u64 = 0;\n    let mut x363: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x362, &mut x363, x344, 0x1d2f5ccd79a995c7);\n    let mut x364: u64 = 0;\n    let mut x365: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x364, &mut x365, x362, 0x1ff);\n    let mut x366: u64 = 0;\n    let mut x367: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x366, &mut x367, x362, 0xffffffffffffffff);\n    let mut x368: u64 = 0;\n    let mut x369: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x368, &mut x369, x362, 0xffffffffffffffff);\n    let mut x370: u64 = 0;\n    let mut x371: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x370, &mut x371, x362, 0xffffffffffffffff);\n    let mut x372: u64 = 0;\n    let mut x373: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x372, &mut x373, x362, 0xfffffffffffffffa);\n    let mut x374: u64 = 0;\n    let mut x375: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x374, &mut x375, x362, 0x51868783bf2f966b);\n    let mut x376: u64 = 0;\n    let mut x377: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x376, &mut x377, x362, 0x7fcc0148f709a5d0);\n    let mut x378: u64 = 0;\n    let mut x379: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x378, &mut x379, x362, 0x3bb5c9b8899c47ae);\n    let mut x380: u64 = 0;\n    let mut x381: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x380, &mut x381, x362, 0xbb6fb71e91386409);\n    let mut x382: u64 = 0;\n    let mut x383: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x382, &mut x383, 0x0, x381, x378);\n    let mut x384: u64 = 0;\n    let mut x385: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x384, &mut x385, x383, x379, x376);\n    let mut x386: u64 = 0;\n    let mut x387: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x386, &mut x387, x385, x377, x374);\n    let mut x388: u64 = 0;\n    let mut x389: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x388, &mut x389, x387, x375, x372);\n    let mut x390: u64 = 0;\n    let mut x391: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x390, &mut x391, x389, x373, x370);\n    let mut x392: u64 = 0;\n    let mut x393: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x392, &mut x393, x391, x371, x368);\n    let mut x394: u64 = 0;\n    let mut x395: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x394, &mut x395, x393, x369, x366);\n    let mut x396: u64 = 0;\n    let mut x397: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x396, &mut x397, x395, x367, x364);\n    let mut x398: u64 = 0;\n    let mut x399: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x398, &mut x399, 0x0, x344, x380);\n    let mut x400: u64 = 0;\n    let mut x401: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x400, &mut x401, x399, x346, x382);\n    let mut x402: u64 = 0;\n    let mut x403: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x402, &mut x403, x401, x348, x384);\n    let mut x404: u64 = 0;\n    let mut x405: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x404, &mut x405, x403, x350, x386);\n    let mut x406: u64 = 0;\n    let mut x407: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x406, &mut x407, x405, x352, x388);\n    let mut x408: u64 = 0;\n    let mut x409: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x408, &mut x409, x407, x354, x390);\n    let mut x410: u64 = 0;\n    let mut x411: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x410, &mut x411, x409, x356, x392);\n    let mut x412: u64 = 0;\n    let mut x413: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x412, &mut x413, x411, x358, x394);\n    let mut x414: u64 = 0;\n    let mut x415: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x414, &mut x415, x413, x360, x396);\n    let mut x416: u64 = 0;\n    let mut x417: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x416, &mut x417, x4, 0x3d);\n    let mut x418: u64 = 0;\n    let mut x419: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x418, &mut x419, x4, 0x2d8e03d1492d0d45);\n    let mut x420: u64 = 0;\n    let mut x421: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x420, &mut x421, x4, 0x5bcc6d61a8e567bc);\n    let mut x422: u64 = 0;\n    let mut x423: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x422, &mut x423, x4, 0xcff3d142b7756e3e);\n    let mut x424: u64 = 0;\n    let mut x425: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x424, &mut x425, x4, 0xdd6e23d82e49c7db);\n    let mut x426: u64 = 0;\n    let mut x427: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x426, &mut x427, x4, 0xd3721ef557f75e06);\n    let mut x428: u64 = 0;\n    let mut x429: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x428, &mut x429, x4, 0x12a78d38794573ff);\n    let mut x430: u64 = 0;\n    let mut x431: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x430, &mut x431, x4, 0xf707badce5547ea3);\n    let mut x432: u64 = 0;\n    let mut x433: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x432, &mut x433, x4, 0x137cd04dcf15dd04);\n    let mut x434: u64 = 0;\n    let mut x435: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x434, &mut x435, 0x0, x433, x430);\n    let mut x436: u64 = 0;\n    let mut x437: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x436, &mut x437, x435, x431, x428);\n    let mut x438: u64 = 0;\n    let mut x439: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x438, &mut x439, x437, x429, x426);\n    let mut x440: u64 = 0;\n    let mut x441: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x440, &mut x441, x439, x427, x424);\n    let mut x442: u64 = 0;\n    let mut x443: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x442, &mut x443, x441, x425, x422);\n    let mut x444: u64 = 0;\n    let mut x445: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x444, &mut x445, x443, x423, x420);\n    let mut x446: u64 = 0;\n    let mut x447: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x446, &mut x447, x445, x421, x418);\n    let mut x448: u64 = 0;\n    let mut x449: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x448, &mut x449, x447, x419, x416);\n    let mut x450: u64 = 0;\n    let mut x451: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x450, &mut x451, 0x0, x400, x432);\n    let mut x452: u64 = 0;\n    let mut x453: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x452, &mut x453, x451, x402, x434);\n    let mut x454: u64 = 0;\n    let mut x455: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x454, &mut x455, x453, x404, x436);\n    let mut x456: u64 = 0;\n    let mut x457: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x456, &mut x457, x455, x406, x438);\n    let mut x458: u64 = 0;\n    let mut x459: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x458, &mut x459, x457, x408, x440);\n    let mut x460: u64 = 0;\n    let mut x461: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x460, &mut x461, x459, x410, x442);\n    let mut x462: u64 = 0;\n    let mut x463: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x462, &mut x463, x461, x412, x444);\n    let mut x464: u64 = 0;\n    let mut x465: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x464, &mut x465, x463, x414, x446);\n    let mut x466: u64 = 0;\n    let mut x467: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x466,\n        &mut x467,\n        x465,\n        (((x415 as u64) + ((x361 as u64) + ((x343 as u64) + x311))) + ((x397 as u64) + x365)),\n        x448,\n    );\n    let mut x468: u64 = 0;\n    let mut x469: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x468, &mut x469, x450, 0x1d2f5ccd79a995c7);\n    let mut x470: u64 = 0;\n    let mut x471: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x470, &mut x471, x468, 0x1ff);\n    let mut x472: u64 = 0;\n    let mut x473: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x472, &mut x473, x468, 0xffffffffffffffff);\n    let mut x474: u64 = 0;\n    let mut x475: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x474, &mut x475, x468, 0xffffffffffffffff);\n    let mut x476: u64 = 0;\n    let mut x477: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x476, &mut x477, x468, 0xffffffffffffffff);\n    let mut x478: u64 = 0;\n    let mut x479: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x478, &mut x479, x468, 0xfffffffffffffffa);\n    let mut x480: u64 = 0;\n    let mut x481: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x480, &mut x481, x468, 0x51868783bf2f966b);\n    let mut x482: u64 = 0;\n    let mut x483: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x482, &mut x483, x468, 0x7fcc0148f709a5d0);\n    let mut x484: u64 = 0;\n    let mut x485: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x484, &mut x485, x468, 0x3bb5c9b8899c47ae);\n    let mut x486: u64 = 0;\n    let mut x487: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x486, &mut x487, x468, 0xbb6fb71e91386409);\n    let mut x488: u64 = 0;\n    let mut x489: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x488, &mut x489, 0x0, x487, x484);\n    let mut x490: u64 = 0;\n    let mut x491: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x490, &mut x491, x489, x485, x482);\n    let mut x492: u64 = 0;\n    let mut x493: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x492, &mut x493, x491, x483, x480);\n    let mut x494: u64 = 0;\n    let mut x495: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x494, &mut x495, x493, x481, x478);\n    let mut x496: u64 = 0;\n    let mut x497: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x496, &mut x497, x495, x479, x476);\n    let mut x498: u64 = 0;\n    let mut x499: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x498, &mut x499, x497, x477, x474);\n    let mut x500: u64 = 0;\n    let mut x501: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x500, &mut x501, x499, x475, x472);\n    let mut x502: u64 = 0;\n    let mut x503: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x502, &mut x503, x501, x473, x470);\n    let mut x504: u64 = 0;\n    let mut x505: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x504, &mut x505, 0x0, x450, x486);\n    let mut x506: u64 = 0;\n    let mut x507: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x506, &mut x507, x505, x452, x488);\n    let mut x508: u64 = 0;\n    let mut x509: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x508, &mut x509, x507, x454, x490);\n    let mut x510: u64 = 0;\n    let mut x511: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x510, &mut x511, x509, x456, x492);\n    let mut x512: u64 = 0;\n    let mut x513: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x512, &mut x513, x511, x458, x494);\n    let mut x514: u64 = 0;\n    let mut x515: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x514, &mut x515, x513, x460, x496);\n    let mut x516: u64 = 0;\n    let mut x517: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x516, &mut x517, x515, x462, x498);\n    let mut x518: u64 = 0;\n    let mut x519: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x518, &mut x519, x517, x464, x500);\n    let mut x520: u64 = 0;\n    let mut x521: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x520, &mut x521, x519, x466, x502);\n    let mut x522: u64 = 0;\n    let mut x523: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x522, &mut x523, x5, 0x3d);\n    let mut x524: u64 = 0;\n    let mut x525: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x524, &mut x525, x5, 0x2d8e03d1492d0d45);\n    let mut x526: u64 = 0;\n    let mut x527: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x526, &mut x527, x5, 0x5bcc6d61a8e567bc);\n    let mut x528: u64 = 0;\n    let mut x529: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x528, &mut x529, x5, 0xcff3d142b7756e3e);\n    let mut x530: u64 = 0;\n    let mut x531: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x530, &mut x531, x5, 0xdd6e23d82e49c7db);\n    let mut x532: u64 = 0;\n    let mut x533: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x532, &mut x533, x5, 0xd3721ef557f75e06);\n    let mut x534: u64 = 0;\n    let mut x535: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x534, &mut x535, x5, 0x12a78d38794573ff);\n    let mut x536: u64 = 0;\n    let mut x537: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x536, &mut x537, x5, 0xf707badce5547ea3);\n    let mut x538: u64 = 0;\n    let mut x539: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x538, &mut x539, x5, 0x137cd04dcf15dd04);\n    let mut x540: u64 = 0;\n    let mut x541: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x540, &mut x541, 0x0, x539, x536);\n    let mut x542: u64 = 0;\n    let mut x543: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x542, &mut x543, x541, x537, x534);\n    let mut x544: u64 = 0;\n    let mut x545: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x544, &mut x545, x543, x535, x532);\n    let mut x546: u64 = 0;\n    let mut x547: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x546, &mut x547, x545, x533, x530);\n    let mut x548: u64 = 0;\n    let mut x549: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x548, &mut x549, x547, x531, x528);\n    let mut x550: u64 = 0;\n    let mut x551: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x550, &mut x551, x549, x529, x526);\n    let mut x552: u64 = 0;\n    let mut x553: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x552, &mut x553, x551, x527, x524);\n    let mut x554: u64 = 0;\n    let mut x555: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x554, &mut x555, x553, x525, x522);\n    let mut x556: u64 = 0;\n    let mut x557: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x556, &mut x557, 0x0, x506, x538);\n    let mut x558: u64 = 0;\n    let mut x559: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x558, &mut x559, x557, x508, x540);\n    let mut x560: u64 = 0;\n    let mut x561: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x560, &mut x561, x559, x510, x542);\n    let mut x562: u64 = 0;\n    let mut x563: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x562, &mut x563, x561, x512, x544);\n    let mut x564: u64 = 0;\n    let mut x565: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x564, &mut x565, x563, x514, x546);\n    let mut x566: u64 = 0;\n    let mut x567: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x566, &mut x567, x565, x516, x548);\n    let mut x568: u64 = 0;\n    let mut x569: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x568, &mut x569, x567, x518, x550);\n    let mut x570: u64 = 0;\n    let mut x571: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x570, &mut x571, x569, x520, x552);\n    let mut x572: u64 = 0;\n    let mut x573: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x572,\n        &mut x573,\n        x571,\n        (((x521 as u64) + ((x467 as u64) + ((x449 as u64) + x417))) + ((x503 as u64) + x471)),\n        x554,\n    );\n    let mut x574: u64 = 0;\n    let mut x575: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x574, &mut x575, x556, 0x1d2f5ccd79a995c7);\n    let mut x576: u64 = 0;\n    let mut x577: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x576, &mut x577, x574, 0x1ff);\n    let mut x578: u64 = 0;\n    let mut x579: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x578, &mut x579, x574, 0xffffffffffffffff);\n    let mut x580: u64 = 0;\n    let mut x581: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x580, &mut x581, x574, 0xffffffffffffffff);\n    let mut x582: u64 = 0;\n    let mut x583: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x582, &mut x583, x574, 0xffffffffffffffff);\n    let mut x584: u64 = 0;\n    let mut x585: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x584, &mut x585, x574, 0xfffffffffffffffa);\n    let mut x586: u64 = 0;\n    let mut x587: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x586, &mut x587, x574, 0x51868783bf2f966b);\n    let mut x588: u64 = 0;\n    let mut x589: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x588, &mut x589, x574, 0x7fcc0148f709a5d0);\n    let mut x590: u64 = 0;\n    let mut x591: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x590, &mut x591, x574, 0x3bb5c9b8899c47ae);\n    let mut x592: u64 = 0;\n    let mut x593: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x592, &mut x593, x574, 0xbb6fb71e91386409);\n    let mut x594: u64 = 0;\n    let mut x595: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x594, &mut x595, 0x0, x593, x590);\n    let mut x596: u64 = 0;\n    let mut x597: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x596, &mut x597, x595, x591, x588);\n    let mut x598: u64 = 0;\n    let mut x599: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x598, &mut x599, x597, x589, x586);\n    let mut x600: u64 = 0;\n    let mut x601: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x600, &mut x601, x599, x587, x584);\n    let mut x602: u64 = 0;\n    let mut x603: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x602, &mut x603, x601, x585, x582);\n    let mut x604: u64 = 0;\n    let mut x605: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x604, &mut x605, x603, x583, x580);\n    let mut x606: u64 = 0;\n    let mut x607: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x606, &mut x607, x605, x581, x578);\n    let mut x608: u64 = 0;\n    let mut x609: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x608, &mut x609, x607, x579, x576);\n    let mut x610: u64 = 0;\n    let mut x611: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x610, &mut x611, 0x0, x556, x592);\n    let mut x612: u64 = 0;\n    let mut x613: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x612, &mut x613, x611, x558, x594);\n    let mut x614: u64 = 0;\n    let mut x615: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x614, &mut x615, x613, x560, x596);\n    let mut x616: u64 = 0;\n    let mut x617: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x616, &mut x617, x615, x562, x598);\n    let mut x618: u64 = 0;\n    let mut x619: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x618, &mut x619, x617, x564, x600);\n    let mut x620: u64 = 0;\n    let mut x621: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x620, &mut x621, x619, x566, x602);\n    let mut x622: u64 = 0;\n    let mut x623: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x622, &mut x623, x621, x568, x604);\n    let mut x624: u64 = 0;\n    let mut x625: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x624, &mut x625, x623, x570, x606);\n    let mut x626: u64 = 0;\n    let mut x627: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x626, &mut x627, x625, x572, x608);\n    let mut x628: u64 = 0;\n    let mut x629: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x628, &mut x629, x6, 0x3d);\n    let mut x630: u64 = 0;\n    let mut x631: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x630, &mut x631, x6, 0x2d8e03d1492d0d45);\n    let mut x632: u64 = 0;\n    let mut x633: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x632, &mut x633, x6, 0x5bcc6d61a8e567bc);\n    let mut x634: u64 = 0;\n    let mut x635: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x634, &mut x635, x6, 0xcff3d142b7756e3e);\n    let mut x636: u64 = 0;\n    let mut x637: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x636, &mut x637, x6, 0xdd6e23d82e49c7db);\n    let mut x638: u64 = 0;\n    let mut x639: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x638, &mut x639, x6, 0xd3721ef557f75e06);\n    let mut x640: u64 = 0;\n    let mut x641: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x640, &mut x641, x6, 0x12a78d38794573ff);\n    let mut x642: u64 = 0;\n    let mut x643: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x642, &mut x643, x6, 0xf707badce5547ea3);\n    let mut x644: u64 = 0;\n    let mut x645: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x644, &mut x645, x6, 0x137cd04dcf15dd04);\n    let mut x646: u64 = 0;\n    let mut x647: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x646, &mut x647, 0x0, x645, x642);\n    let mut x648: u64 = 0;\n    let mut x649: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x648, &mut x649, x647, x643, x640);\n    let mut x650: u64 = 0;\n    let mut x651: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x650, &mut x651, x649, x641, x638);\n    let mut x652: u64 = 0;\n    let mut x653: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x652, &mut x653, x651, x639, x636);\n    let mut x654: u64 = 0;\n    let mut x655: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x654, &mut x655, x653, x637, x634);\n    let mut x656: u64 = 0;\n    let mut x657: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x656, &mut x657, x655, x635, x632);\n    let mut x658: u64 = 0;\n    let mut x659: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x658, &mut x659, x657, x633, x630);\n    let mut x660: u64 = 0;\n    let mut x661: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x660, &mut x661, x659, x631, x628);\n    let mut x662: u64 = 0;\n    let mut x663: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x662, &mut x663, 0x0, x612, x644);\n    let mut x664: u64 = 0;\n    let mut x665: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x664, &mut x665, x663, x614, x646);\n    let mut x666: u64 = 0;\n    let mut x667: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x666, &mut x667, x665, x616, x648);\n    let mut x668: u64 = 0;\n    let mut x669: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x668, &mut x669, x667, x618, x650);\n    let mut x670: u64 = 0;\n    let mut x671: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x670, &mut x671, x669, x620, x652);\n    let mut x672: u64 = 0;\n    let mut x673: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x672, &mut x673, x671, x622, x654);\n    let mut x674: u64 = 0;\n    let mut x675: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x674, &mut x675, x673, x624, x656);\n    let mut x676: u64 = 0;\n    let mut x677: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x676, &mut x677, x675, x626, x658);\n    let mut x678: u64 = 0;\n    let mut x679: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x678,\n        &mut x679,\n        x677,\n        (((x627 as u64) + ((x573 as u64) + ((x555 as u64) + x523))) + ((x609 as u64) + x577)),\n        x660,\n    );\n    let mut x680: u64 = 0;\n    let mut x681: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x680, &mut x681, x662, 0x1d2f5ccd79a995c7);\n    let mut x682: u64 = 0;\n    let mut x683: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x682, &mut x683, x680, 0x1ff);\n    let mut x684: u64 = 0;\n    let mut x685: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x684, &mut x685, x680, 0xffffffffffffffff);\n    let mut x686: u64 = 0;\n    let mut x687: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x686, &mut x687, x680, 0xffffffffffffffff);\n    let mut x688: u64 = 0;\n    let mut x689: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x688, &mut x689, x680, 0xffffffffffffffff);\n    let mut x690: u64 = 0;\n    let mut x691: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x690, &mut x691, x680, 0xfffffffffffffffa);\n    let mut x692: u64 = 0;\n    let mut x693: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x692, &mut x693, x680, 0x51868783bf2f966b);\n    let mut x694: u64 = 0;\n    let mut x695: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x694, &mut x695, x680, 0x7fcc0148f709a5d0);\n    let mut x696: u64 = 0;\n    let mut x697: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x696, &mut x697, x680, 0x3bb5c9b8899c47ae);\n    let mut x698: u64 = 0;\n    let mut x699: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x698, &mut x699, x680, 0xbb6fb71e91386409);\n    let mut x700: u64 = 0;\n    let mut x701: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x700, &mut x701, 0x0, x699, x696);\n    let mut x702: u64 = 0;\n    let mut x703: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x702, &mut x703, x701, x697, x694);\n    let mut x704: u64 = 0;\n    let mut x705: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x704, &mut x705, x703, x695, x692);\n    let mut x706: u64 = 0;\n    let mut x707: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x706, &mut x707, x705, x693, x690);\n    let mut x708: u64 = 0;\n    let mut x709: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x708, &mut x709, x707, x691, x688);\n    let mut x710: u64 = 0;\n    let mut x711: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x710, &mut x711, x709, x689, x686);\n    let mut x712: u64 = 0;\n    let mut x713: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x712, &mut x713, x711, x687, x684);\n    let mut x714: u64 = 0;\n    let mut x715: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x714, &mut x715, x713, x685, x682);\n    let mut x716: u64 = 0;\n    let mut x717: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x716, &mut x717, 0x0, x662, x698);\n    let mut x718: u64 = 0;\n    let mut x719: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x718, &mut x719, x717, x664, x700);\n    let mut x720: u64 = 0;\n    let mut x721: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x720, &mut x721, x719, x666, x702);\n    let mut x722: u64 = 0;\n    let mut x723: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x722, &mut x723, x721, x668, x704);\n    let mut x724: u64 = 0;\n    let mut x725: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x724, &mut x725, x723, x670, x706);\n    let mut x726: u64 = 0;\n    let mut x727: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x726, &mut x727, x725, x672, x708);\n    let mut x728: u64 = 0;\n    let mut x729: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x728, &mut x729, x727, x674, x710);\n    let mut x730: u64 = 0;\n    let mut x731: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x730, &mut x731, x729, x676, x712);\n    let mut x732: u64 = 0;\n    let mut x733: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x732, &mut x733, x731, x678, x714);\n    let mut x734: u64 = 0;\n    let mut x735: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x734, &mut x735, x7, 0x3d);\n    let mut x736: u64 = 0;\n    let mut x737: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x736, &mut x737, x7, 0x2d8e03d1492d0d45);\n    let mut x738: u64 = 0;\n    let mut x739: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x738, &mut x739, x7, 0x5bcc6d61a8e567bc);\n    let mut x740: u64 = 0;\n    let mut x741: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x740, &mut x741, x7, 0xcff3d142b7756e3e);\n    let mut x742: u64 = 0;\n    let mut x743: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x742, &mut x743, x7, 0xdd6e23d82e49c7db);\n    let mut x744: u64 = 0;\n    let mut x745: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x744, &mut x745, x7, 0xd3721ef557f75e06);\n    let mut x746: u64 = 0;\n    let mut x747: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x746, &mut x747, x7, 0x12a78d38794573ff);\n    let mut x748: u64 = 0;\n    let mut x749: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x748, &mut x749, x7, 0xf707badce5547ea3);\n    let mut x750: u64 = 0;\n    let mut x751: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x750, &mut x751, x7, 0x137cd04dcf15dd04);\n    let mut x752: u64 = 0;\n    let mut x753: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x752, &mut x753, 0x0, x751, x748);\n    let mut x754: u64 = 0;\n    let mut x755: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x754, &mut x755, x753, x749, x746);\n    let mut x756: u64 = 0;\n    let mut x757: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x756, &mut x757, x755, x747, x744);\n    let mut x758: u64 = 0;\n    let mut x759: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x758, &mut x759, x757, x745, x742);\n    let mut x760: u64 = 0;\n    let mut x761: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x760, &mut x761, x759, x743, x740);\n    let mut x762: u64 = 0;\n    let mut x763: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x762, &mut x763, x761, x741, x738);\n    let mut x764: u64 = 0;\n    let mut x765: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x764, &mut x765, x763, x739, x736);\n    let mut x766: u64 = 0;\n    let mut x767: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x766, &mut x767, x765, x737, x734);\n    let mut x768: u64 = 0;\n    let mut x769: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x768, &mut x769, 0x0, x718, x750);\n    let mut x770: u64 = 0;\n    let mut x771: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x770, &mut x771, x769, x720, x752);\n    let mut x772: u64 = 0;\n    let mut x773: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x772, &mut x773, x771, x722, x754);\n    let mut x774: u64 = 0;\n    let mut x775: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x774, &mut x775, x773, x724, x756);\n    let mut x776: u64 = 0;\n    let mut x777: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x776, &mut x777, x775, x726, x758);\n    let mut x778: u64 = 0;\n    let mut x779: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x778, &mut x779, x777, x728, x760);\n    let mut x780: u64 = 0;\n    let mut x781: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x780, &mut x781, x779, x730, x762);\n    let mut x782: u64 = 0;\n    let mut x783: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x782, &mut x783, x781, x732, x764);\n    let mut x784: u64 = 0;\n    let mut x785: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x784,\n        &mut x785,\n        x783,\n        (((x733 as u64) + ((x679 as u64) + ((x661 as u64) + x629))) + ((x715 as u64) + x683)),\n        x766,\n    );\n    let mut x786: u64 = 0;\n    let mut x787: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x786, &mut x787, x768, 0x1d2f5ccd79a995c7);\n    let mut x788: u64 = 0;\n    let mut x789: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x788, &mut x789, x786, 0x1ff);\n    let mut x790: u64 = 0;\n    let mut x791: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x790, &mut x791, x786, 0xffffffffffffffff);\n    let mut x792: u64 = 0;\n    let mut x793: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x792, &mut x793, x786, 0xffffffffffffffff);\n    let mut x794: u64 = 0;\n    let mut x795: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x794, &mut x795, x786, 0xffffffffffffffff);\n    let mut x796: u64 = 0;\n    let mut x797: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x796, &mut x797, x786, 0xfffffffffffffffa);\n    let mut x798: u64 = 0;\n    let mut x799: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x798, &mut x799, x786, 0x51868783bf2f966b);\n    let mut x800: u64 = 0;\n    let mut x801: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x800, &mut x801, x786, 0x7fcc0148f709a5d0);\n    let mut x802: u64 = 0;\n    let mut x803: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x802, &mut x803, x786, 0x3bb5c9b8899c47ae);\n    let mut x804: u64 = 0;\n    let mut x805: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x804, &mut x805, x786, 0xbb6fb71e91386409);\n    let mut x806: u64 = 0;\n    let mut x807: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x806, &mut x807, 0x0, x805, x802);\n    let mut x808: u64 = 0;\n    let mut x809: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x808, &mut x809, x807, x803, x800);\n    let mut x810: u64 = 0;\n    let mut x811: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x810, &mut x811, x809, x801, x798);\n    let mut x812: u64 = 0;\n    let mut x813: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x812, &mut x813, x811, x799, x796);\n    let mut x814: u64 = 0;\n    let mut x815: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x814, &mut x815, x813, x797, x794);\n    let mut x816: u64 = 0;\n    let mut x817: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x816, &mut x817, x815, x795, x792);\n    let mut x818: u64 = 0;\n    let mut x819: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x818, &mut x819, x817, x793, x790);\n    let mut x820: u64 = 0;\n    let mut x821: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x820, &mut x821, x819, x791, x788);\n    let mut x822: u64 = 0;\n    let mut x823: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x822, &mut x823, 0x0, x768, x804);\n    let mut x824: u64 = 0;\n    let mut x825: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x824, &mut x825, x823, x770, x806);\n    let mut x826: u64 = 0;\n    let mut x827: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x826, &mut x827, x825, x772, x808);\n    let mut x828: u64 = 0;\n    let mut x829: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x828, &mut x829, x827, x774, x810);\n    let mut x830: u64 = 0;\n    let mut x831: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x830, &mut x831, x829, x776, x812);\n    let mut x832: u64 = 0;\n    let mut x833: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x832, &mut x833, x831, x778, x814);\n    let mut x834: u64 = 0;\n    let mut x835: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x834, &mut x835, x833, x780, x816);\n    let mut x836: u64 = 0;\n    let mut x837: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x836, &mut x837, x835, x782, x818);\n    let mut x838: u64 = 0;\n    let mut x839: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x838, &mut x839, x837, x784, x820);\n    let mut x840: u64 = 0;\n    let mut x841: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x840, &mut x841, x8, 0x3d);\n    let mut x842: u64 = 0;\n    let mut x843: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x842, &mut x843, x8, 0x2d8e03d1492d0d45);\n    let mut x844: u64 = 0;\n    let mut x845: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x844, &mut x845, x8, 0x5bcc6d61a8e567bc);\n    let mut x846: u64 = 0;\n    let mut x847: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x846, &mut x847, x8, 0xcff3d142b7756e3e);\n    let mut x848: u64 = 0;\n    let mut x849: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x848, &mut x849, x8, 0xdd6e23d82e49c7db);\n    let mut x850: u64 = 0;\n    let mut x851: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x850, &mut x851, x8, 0xd3721ef557f75e06);\n    let mut x852: u64 = 0;\n    let mut x853: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x852, &mut x853, x8, 0x12a78d38794573ff);\n    let mut x854: u64 = 0;\n    let mut x855: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x854, &mut x855, x8, 0xf707badce5547ea3);\n    let mut x856: u64 = 0;\n    let mut x857: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x856, &mut x857, x8, 0x137cd04dcf15dd04);\n    let mut x858: u64 = 0;\n    let mut x859: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x858, &mut x859, 0x0, x857, x854);\n    let mut x860: u64 = 0;\n    let mut x861: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x860, &mut x861, x859, x855, x852);\n    let mut x862: u64 = 0;\n    let mut x863: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x862, &mut x863, x861, x853, x850);\n    let mut x864: u64 = 0;\n    let mut x865: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x864, &mut x865, x863, x851, x848);\n    let mut x866: u64 = 0;\n    let mut x867: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x866, &mut x867, x865, x849, x846);\n    let mut x868: u64 = 0;\n    let mut x869: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x868, &mut x869, x867, x847, x844);\n    let mut x870: u64 = 0;\n    let mut x871: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x870, &mut x871, x869, x845, x842);\n    let mut x872: u64 = 0;\n    let mut x873: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x872, &mut x873, x871, x843, x840);\n    let mut x874: u64 = 0;\n    let mut x875: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x874, &mut x875, 0x0, x824, x856);\n    let mut x876: u64 = 0;\n    let mut x877: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x876, &mut x877, x875, x826, x858);\n    let mut x878: u64 = 0;\n    let mut x879: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x878, &mut x879, x877, x828, x860);\n    let mut x880: u64 = 0;\n    let mut x881: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x880, &mut x881, x879, x830, x862);\n    let mut x882: u64 = 0;\n    let mut x883: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x882, &mut x883, x881, x832, x864);\n    let mut x884: u64 = 0;\n    let mut x885: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x884, &mut x885, x883, x834, x866);\n    let mut x886: u64 = 0;\n    let mut x887: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x886, &mut x887, x885, x836, x868);\n    let mut x888: u64 = 0;\n    let mut x889: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x888, &mut x889, x887, x838, x870);\n    let mut x890: u64 = 0;\n    let mut x891: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x890,\n        &mut x891,\n        x889,\n        (((x839 as u64) + ((x785 as u64) + ((x767 as u64) + x735))) + ((x821 as u64) + x789)),\n        x872,\n    );\n    let mut x892: u64 = 0;\n    let mut x893: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x892, &mut x893, x874, 0x1d2f5ccd79a995c7);\n    let mut x894: u64 = 0;\n    let mut x895: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x894, &mut x895, x892, 0x1ff);\n    let mut x896: u64 = 0;\n    let mut x897: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x896, &mut x897, x892, 0xffffffffffffffff);\n    let mut x898: u64 = 0;\n    let mut x899: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x898, &mut x899, x892, 0xffffffffffffffff);\n    let mut x900: u64 = 0;\n    let mut x901: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x900, &mut x901, x892, 0xffffffffffffffff);\n    let mut x902: u64 = 0;\n    let mut x903: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x902, &mut x903, x892, 0xfffffffffffffffa);\n    let mut x904: u64 = 0;\n    let mut x905: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x904, &mut x905, x892, 0x51868783bf2f966b);\n    let mut x906: u64 = 0;\n    let mut x907: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x906, &mut x907, x892, 0x7fcc0148f709a5d0);\n    let mut x908: u64 = 0;\n    let mut x909: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x908, &mut x909, x892, 0x3bb5c9b8899c47ae);\n    let mut x910: u64 = 0;\n    let mut x911: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x910, &mut x911, x892, 0xbb6fb71e91386409);\n    let mut x912: u64 = 0;\n    let mut x913: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x912, &mut x913, 0x0, x911, x908);\n    let mut x914: u64 = 0;\n    let mut x915: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x914, &mut x915, x913, x909, x906);\n    let mut x916: u64 = 0;\n    let mut x917: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x916, &mut x917, x915, x907, x904);\n    let mut x918: u64 = 0;\n    let mut x919: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x918, &mut x919, x917, x905, x902);\n    let mut x920: u64 = 0;\n    let mut x921: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x920, &mut x921, x919, x903, x900);\n    let mut x922: u64 = 0;\n    let mut x923: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x922, &mut x923, x921, x901, x898);\n    let mut x924: u64 = 0;\n    let mut x925: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x924, &mut x925, x923, x899, x896);\n    let mut x926: u64 = 0;\n    let mut x927: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x926, &mut x927, x925, x897, x894);\n    let mut x928: u64 = 0;\n    let mut x929: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x928, &mut x929, 0x0, x874, x910);\n    let mut x930: u64 = 0;\n    let mut x931: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x930, &mut x931, x929, x876, x912);\n    let mut x932: u64 = 0;\n    let mut x933: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x932, &mut x933, x931, x878, x914);\n    let mut x934: u64 = 0;\n    let mut x935: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x934, &mut x935, x933, x880, x916);\n    let mut x936: u64 = 0;\n    let mut x937: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x936, &mut x937, x935, x882, x918);\n    let mut x938: u64 = 0;\n    let mut x939: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x938, &mut x939, x937, x884, x920);\n    let mut x940: u64 = 0;\n    let mut x941: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x940, &mut x941, x939, x886, x922);\n    let mut x942: u64 = 0;\n    let mut x943: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x942, &mut x943, x941, x888, x924);\n    let mut x944: u64 = 0;\n    let mut x945: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x944, &mut x945, x943, x890, x926);\n    let x946: u64 =\n        (((x945 as u64) + ((x891 as u64) + ((x873 as u64) + x841))) + ((x927 as u64) + x895));\n    let mut x947: u64 = 0;\n    let mut x948: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x947, &mut x948, 0x0, x930, 0xbb6fb71e91386409);\n    let mut x949: u64 = 0;\n    let mut x950: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x949, &mut x950, x948, x932, 0x3bb5c9b8899c47ae);\n    let mut x951: u64 = 0;\n    let mut x952: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x951, &mut x952, x950, x934, 0x7fcc0148f709a5d0);\n    let mut x953: u64 = 0;\n    let mut x954: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x953, &mut x954, x952, x936, 0x51868783bf2f966b);\n    let mut x955: u64 = 0;\n    let mut x956: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x955, &mut x956, x954, x938, 0xfffffffffffffffa);\n    let mut x957: u64 = 0;\n    let mut x958: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x957, &mut x958, x956, x940, 0xffffffffffffffff);\n    let mut x959: u64 = 0;\n    let mut x960: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x959, &mut x960, x958, x942, 0xffffffffffffffff);\n    let mut x961: u64 = 0;\n    let mut x962: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x961, &mut x962, x960, x944, 0xffffffffffffffff);\n    let mut x963: u64 = 0;\n    let mut x964: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x963, &mut x964, x962, x946, 0x1ff);\n    let mut x965: u64 = 0;\n    let mut x966: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x965, &mut x966, x964, (0x0 as u64), (0x0 as u64));\n    let mut x967: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x967, x966, x947, x930);\n    let mut x968: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x968, x966, x949, x932);\n    let mut x969: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x969, x966, x951, x934);\n    let mut x970: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x970, x966, x953, x936);\n    let mut x971: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x971, x966, x955, x938);\n    let mut x972: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x972, x966, x957, x940);\n    let mut x973: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x973, x966, x959, x942);\n    let mut x974: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x974, x966, x961, x944);\n    let mut x975: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x975, x966, x963, x946);\n    out1[0] = x967;\n    out1[1] = x968;\n    out1[2] = x969;\n    out1[3] = x970;\n    out1[4] = x971;\n    out1[5] = x972;\n    out1[6] = x973;\n    out1[7] = x974;\n    out1[8] = x975;\n}",
    "display_name": "fiat_p521_scalar_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_zero",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert_unchecked"
    ],
    "body": "    pub fn invert(&self) -> CtOption<Self> {\n        CtOption::new(self.invert_unchecked(), !self.is_zero())\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre bench_field_element",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre bench_field_element_mul",
      "0.14.0_pre bench_field_element_square",
      "0.14.0_pre bench_field_element_sqrt",
      "0.14.0_pre bench_field_element_invert"
    ],
    "body": "fn bench_field_element(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"field element operations\");\n    bench_field_element_mul(&mut group);\n    bench_field_element_square(&mut group);\n    bench_field_element_invert(&mut group);\n    bench_field_element_sqrt(&mut group);\n    group.finish();\n}",
    "display_name": "bench_field_element",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/field.rs",
    "relative_path": "bign256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/to_bytes"
    ],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"bignp256::dsa::Signature(\")?;\n\n        for byte in self.to_bytes() {\n            write!(f, \"{:02X}\", byte)?;\n        }\n\n        write!(f, \")\")\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/wycheproof/wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "        ecdsa_core::new_wycheproof_test!(wycheproof, \"wycheproof\", NistP384);\n    }\n}",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/ecdsa.rs",
    "relative_path": "p384/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/as_nonzero_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_nonzero_scalar(&self) -> &NonZeroScalar {\n        &self.secret_scalar\n    }",
    "display_name": "as_nonzero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decode_field_bytes(field_bytes: &Decaf448FieldBytes) -> Self {\n        U448::from_le_slice(field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/lib.rs",
    "relative_path": "ed448-goldilocks/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/pow_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/multiply",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    pub const fn pow_vartime(&self, exp: &[u64]) -> Self {\n        let mut res = Self::ONE;\n        let mut i = exp.len();\n\n        while i > 0 {\n            i -= 1;\n\n            let mut j = 64;\n            while j > 0 {\n                j -= 1;\n                res = res.square();\n\n                if ((exp[i] >> j) & 1) == 1 {\n                    res = Self::multiply(&res, self);\n                }\n            }\n        }\n\n        res\n    }",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_bign256_scalar_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/DecompressPoint/decompress",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConditionallySelectable/conditional_select",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/new"
    ],
    "body": "    fn decompress(x_bytes: &FieldBytes, y_is_odd: Choice) -> CtOption<Self> {\n        FieldElement::from_bytes(x_bytes).and_then(|x| {\n            let alpha = (x * &x * &x) + &CURVE_EQUATION_B;\n            let beta = alpha.sqrt();\n\n            beta.map(|beta| {\n                let beta = beta.normalize(); // Need to normalize for is_odd() to be consistent\n                let y = FieldElement::conditional_select(\n                    &beta.negate(1),\n                    &beta,\n                    beta.is_odd().ct_eq(&y_is_odd),\n                );\n\n                Self::new(x, y.normalize())\n            })\n        })\n    }",
    "display_name": "decompress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert"
    ],
    "body": "    fn invert() {\n        assert!(bool::from(FieldElement::ZERO.invert().is_none()));\n\n        let one = FieldElement::ONE;\n        assert_eq!(one.invert().unwrap(), one);\n\n        let two = one + &one;\n        let inv_two = two.invert().unwrap();\n        assert_eq!(two * &inv_two, one);\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/PreHasherXof/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/PreHasherXof/new"
    ],
    "body": "    fn from(hasher: HashT) -> Self {\n        Self::new(hasher)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {\n        let compressed = <DecafPointBytes>::try_from(bytes).map_err(|_| \"invalid length\")?;\n        Self::try_from(compressed)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/to_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_scalar(&self) -> Scalar {\n        self.secret.scalar\n    }",
    "display_name": "to_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/subtract",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn subtract(&self, rhs: &Self) -> Self {\n        Self(self.0.sub_mod(&rhs.0, &ORDER))\n    }",
    "display_name": "subtract",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.7.0_pre r1/impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [
      "0.7.0_pre decode_field_bytes"
    ],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        crate::decode_field_bytes(field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp256/src/r1.rs",
    "relative_path": "bp256/src/r1.rs",
    "file_name": "r1.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_divstep_precomp(out1: &mut [u64; 4]) {\n    out1[0] = 0x500000028ffffffe;\n    out1[1] = 0xe80000009ffffffe;\n    out1[2] = 0xd00000018ffffffe;\n    out1[3] = 0x280000011ffffffd;\n}",
    "display_name": "fiat_sm2_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_canonical"
    ],
    "body": "    pub fn is_odd(&self) -> Choice {\n        self.to_canonical().is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/s_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn s_bytes(&self) -> FieldBytes {\n        self.s.to_bytes()\n    }",
    "display_name": "s_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/RandomizedDigestSigner/try_sign_digest_with_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/sign_raw"
    ],
    "body": "    fn try_sign_digest_with_rng<R: TryCryptoRng + ?Sized>(\n        &self,\n        rng: &mut R,\n        digest: D,\n    ) -> Result<Signature> {\n        let mut aux_rand = [0u8; 32];\n        rng.try_fill_bytes(&mut aux_rand)\n            .map_err(|_| Error::new())?;\n        self.sign_raw(&digest.finalize_fixed(), &aux_rand)\n    }",
    "display_name": "try_sign_digest_with_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/AffineCoordinates/x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes_extended"
    ],
    "body": "    fn x(&self) -> Self::FieldRepr {\n        Ed448FieldBytes::from(self.x.to_bytes_extended())\n    }",
    "display_name": "x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes_extended",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes"
    ],
    "body": "    pub fn to_bytes_extended(self) -> [u8; 57] {\n        let mut bytes = [0u8; 57];\n        bytes[..56].copy_from_slice(&self.to_bytes());\n        bytes\n    }",
    "display_name": "to_bytes_extended",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/test_vector_repeated_add_mixed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn test_vector_repeated_add_mixed() {\n        let generator = AffinePoint::GENERATOR;\n        let mut p = ProjectivePoint::GENERATOR;\n\n        for i in 0..ADD_TEST_VECTORS.len() {\n            let affine = p.to_affine();\n\n            let (expected_x, expected_y) = ADD_TEST_VECTORS[i];\n            assert_eq!(affine.x.to_bytes(), expected_x);\n            assert_eq!(affine.y.to_bytes(), expected_y);\n\n            p += &generator;\n        }\n    }",
    "display_name": "test_vector_repeated_add_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/PublicKey/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(verifying_key: VerifyingKey) -> PublicKey {\n        verifying_key.public_key\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/hash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/FromOkm/from_okm"
    ],
    "body": "    pub fn hash<X>(msg: &[u8], dst: &[u8]) -> Self\n    where\n        X: ExpandMsg<U28>,\n    {\n        type RandomLen = U84;\n        let mut random_bytes = Array::<u8, RandomLen>::default();\n        let dst = [dst];\n        let mut expander = X::expand_message(\n            &[msg],\n            &dst,\n            core::num::NonZero::new(RandomLen::U16).expect(\"Invariant violation\"),\n        )\n        .expect(\"invalid dst\");\n        expander.fill_bytes(&mut random_bytes);\n        Self::from_okm(&random_bytes)\n    }",
    "display_name": "hash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/RandomizedPrehashSigner/sign_prehash_with_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/sign_raw"
    ],
    "body": "    fn sign_prehash_with_rng<R: TryCryptoRng + ?Sized>(\n        &self,\n        rng: &mut R,\n        prehash: &[u8],\n    ) -> Result<Signature> {\n        let mut aux_rand = [0u8; 32];\n        rng.try_fill_bytes(&mut aux_rand)\n            .map_err(|_| Error::new())?;\n\n        self.sign_raw(prehash, &aux_rand)\n    }",
    "display_name": "sign_prehash_with_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/carry",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry"
    ],
    "body": "    pub const fn carry(&self) -> FieldElement {\n        let mut out = fiat_p521_tight_field_element([0; 9]);\n        fiat_p521_carry(&mut out, &self.0);\n        FieldElement(out)\n    }",
    "display_name": "carry",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_p224_scalar_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> FieldBytes {\n        self.0.to_be_byte_array()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/public_key",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/from_secret_scalar",
      "0.14.0_pre secret_key/impl/SecretKey/to_nonzero_scalar"
    ],
    "body": "    pub fn public_key(&self) -> PublicKey {\n        PublicKey::from_secret_scalar(&self.to_nonzero_scalar())\n    }",
    "display_name": "public_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/encrypting_key",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn encrypting_key(&self) -> &EncryptingKey {\n        &self.encryting_key\n    }",
    "display_name": "encrypting_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/as_bytes"
    ],
    "body": "    fn ct_eq(&self, other: &CompressedDecaf) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/Radix16Decomposition/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self([0i8; D])\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/tests/overflow_check_after_weak_normalize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalize"
    ],
    "body": "    fn overflow_check_after_weak_normalize() {\n        // A regression test for a missing condition in `get_overflow()`.\n        // The condition was only missing in the 32-bit case,\n        // but we're adding a 64-bit testcase nevertheless.\n        //\n        // In `normalize()`, after the `normalize_weak()` call,\n        // the excess bit from the limb 0 is propagated all the way to the last limb.\n        // This constitutes an overflow, since the last bit becomes equal to (1 << 22),\n        // that is 23 bits in total.\n        // When `get_overflow()` is called afterwards, this was not detected,\n        // since the corresponding condition (checking for the last limb being > 22 bits)\n        // was missing.\n        // This resulted in a debug assert firing later.\n        //\n        // This is essentially 2^256\n        let z = FieldElement5x52([\n            (1 << 52), // an excess bit here\n            // the remaining full-sized limbs are at top normalized capacity\n            (1 << 52) - 1,\n            (1 << 52) - 1,\n            (1 << 52) - 1,\n            // the last limb is also at top normalized capacity\n            (1 << 48) - 1,\n        ]);\n\n        // Used to fail here (debug_assert firing because overflow happened at an unexpected place):\n        let z_normalized = z.normalize();\n\n        // Properly normalized result, just to be sure\n        // The initial number is 2^256, so the result is 0x1000003d1\n        let z_reference = FieldElement5x52([0x1000003d1, 0, 0, 0, 0]);\n\n        assert_eq!(z_normalized.0, z_reference.0);\n    }",
    "display_name": "overflow_check_after_weak_normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/as_nonzero_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_nonzero_scalar(&self) -> &NonZeroScalar {\n        &self.secret_scalar\n    }",
    "display_name": "as_nonzero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ShrAssign/shr_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn shr_assign(&mut self, rhs: usize) {\n        *self = *self >> rhs;\n    }",
    "display_name": "shr_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64"
    ],
    "body": "pub const fn fiat_bign256_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 5],\n    out3: &mut [u64; 5],\n    out4: &mut [u64; 4],\n    out5: &mut [u64; 4],\n    arg1: u64,\n    arg2: &[u64; 5],\n    arg3: &[u64; 5],\n    arg4: &[u64; 4],\n    arg5: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_bign256_u1 =\n        (((x1 >> 63) as fiat_bign256_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_bign256_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x12, &mut x13, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x14, &mut x15, x13, (0x0 as u64), (!(arg2[1])));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), (!(arg2[2])));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), (!(arg2[3])));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), (!(arg2[4])));\n    let mut x22: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x22, x3, (arg3[0]), x12);\n    let mut x23: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x23, x3, (arg3[1]), x14);\n    let mut x24: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x24, x3, (arg3[2]), x16);\n    let mut x25: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x25, x3, (arg3[3]), x18);\n    let mut x26: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x26, x3, (arg3[4]), x20);\n    let mut x27: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x27, x3, (arg4[0]), (arg5[0]));\n    let mut x28: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x28, x3, (arg4[1]), (arg5[1]));\n    let mut x29: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x29, x3, (arg4[2]), (arg5[2]));\n    let mut x30: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x30, x3, (arg4[3]), (arg5[3]));\n    let mut x31: u64 = 0;\n    let mut x32: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x31, &mut x32, 0x0, x27, x27);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x33, &mut x34, x32, x28, x28);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x35, &mut x36, x34, x29, x29);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x37, &mut x38, x36, x30, x30);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x39, &mut x40, 0x0, x31, 0xffffffffffffff43);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x41, &mut x42, x40, x33, 0xffffffffffffffff);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x43, &mut x44, x42, x35, 0xffffffffffffffff);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x45, &mut x46, x44, x37, 0xffffffffffffffff);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x47, &mut x48, x46, (x38 as u64), (0x0 as u64));\n    let x49: u64 = (arg4[3]);\n    let x50: u64 = (arg4[2]);\n    let x51: u64 = (arg4[1]);\n    let x52: u64 = (arg4[0]);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x53, &mut x54, 0x0, (0x0 as u64), x52);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x55, &mut x56, x54, (0x0 as u64), x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x57, &mut x58, x56, (0x0 as u64), x50);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x59, &mut x60, x58, (0x0 as u64), x49);\n    let mut x61: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x61, x60, (0x0 as u64), 0xffffffffffffffff);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x62, &mut x63, 0x0, x53, (x61 & 0xffffffffffffff43));\n    let mut x64: u64 = 0;\n    let mut x65: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x64, &mut x65, x63, x55, x61);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x66, &mut x67, x65, x57, x61);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x68, &mut x69, x67, x59, x61);\n    let mut x70: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x70, x3, (arg5[0]), x62);\n    let mut x71: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x71, x3, (arg5[1]), x64);\n    let mut x72: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x72, x3, (arg5[2]), x66);\n    let mut x73: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x73, x3, (arg5[3]), x68);\n    let x74: fiat_bign256_u1 = ((x22 & (0x1 as u64)) as fiat_bign256_u1);\n    let mut x75: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x75, x74, (0x0 as u64), x7);\n    let mut x76: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x76, x74, (0x0 as u64), x8);\n    let mut x77: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x77, x74, (0x0 as u64), x9);\n    let mut x78: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x78, x74, (0x0 as u64), x10);\n    let mut x79: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x79, x74, (0x0 as u64), x11);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x80, &mut x81, 0x0, x22, x75);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x82, &mut x83, x81, x23, x76);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x84, &mut x85, x83, x24, x77);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x86, &mut x87, x85, x25, x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x88, &mut x89, x87, x26, x79);\n    let mut x90: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x90, x74, (0x0 as u64), x27);\n    let mut x91: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x91, x74, (0x0 as u64), x28);\n    let mut x92: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x92, x74, (0x0 as u64), x29);\n    let mut x93: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x93, x74, (0x0 as u64), x30);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x94, &mut x95, 0x0, x70, x90);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x96, &mut x97, x95, x71, x91);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x98, &mut x99, x97, x72, x92);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x100, &mut x101, x99, x73, x93);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x102, &mut x103, 0x0, x94, 0xffffffffffffff43);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x104, &mut x105, x103, x96, 0xffffffffffffffff);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x106, &mut x107, x105, x98, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x108, &mut x109, x107, x100, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x110, &mut x111, x109, (x101 as u64), (0x0 as u64));\n    let mut x112: u64 = 0;\n    let mut x113: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x112, &mut x113, 0x0, x6, (0x1 as u64));\n    let x114: u64 = ((x80 >> 1) | ((x82 << 63) & 0xffffffffffffffff));\n    let x115: u64 = ((x82 >> 1) | ((x84 << 63) & 0xffffffffffffffff));\n    let x116: u64 = ((x84 >> 1) | ((x86 << 63) & 0xffffffffffffffff));\n    let x117: u64 = ((x86 >> 1) | ((x88 << 63) & 0xffffffffffffffff));\n    let x118: u64 = ((x88 & 0x8000000000000000) | (x88 >> 1));\n    let mut x119: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x119, x48, x39, x31);\n    let mut x120: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x120, x48, x41, x33);\n    let mut x121: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x121, x48, x43, x35);\n    let mut x122: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x122, x48, x45, x37);\n    let mut x123: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x123, x111, x102, x94);\n    let mut x124: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x124, x111, x104, x96);\n    let mut x125: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x125, x111, x106, x98);\n    let mut x126: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x126, x111, x108, x100);\n    *out1 = x112;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out3[0] = x114;\n    out3[1] = x115;\n    out3[2] = x116;\n    out3[3] = x117;\n    out3[4] = x118;\n    out4[0] = x119;\n    out4[1] = x120;\n    out4[2] = x121;\n    out4[3] = x122;\n    out5[0] = x123;\n    out5[1] = x124;\n    out5[2] = x125;\n    out5[3] = x126;\n}",
    "display_name": "fiat_bign256_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_bign256_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/repeated_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn repeated_mul() {\n        let mut r = FieldElement::ONE;\n        let two = r + &r;\n        for item in DBL_TEST_VECTORS {\n            assert_eq!(r.to_bytes().as_slice(), item);\n            r = r * &two;\n        }\n    }",
    "display_name": "repeated_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "affine/impl/AffinePoint/AffineCoordinates/x_is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "    fn x_is_odd(&self) -> Choice {\n        self.x.is_odd()\n    }",
    "display_name": "x_is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "affine/impl/EncodedPoint/From>/from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn from(affine: AffinePoint<C>) -> EncodedPoint<C> {\n        affine.to_encoded_point(false)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.compressed.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre pke/impl/Cipher/DecodeValue/decode_value",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/zero_pad_byte_slice"
    ],
    "body": "    fn decode_value<R: Reader<'a>>(\n        decoder: &mut R,\n        header: elliptic_curve::pkcs8::der::Header,\n    ) -> core::result::Result<Self, Self::Error> {\n        decoder.read_nested(header.length, |nr| {\n            let x = UintRef::decode(nr)?.as_bytes();\n            let y = UintRef::decode(nr)?.as_bytes();\n            let digest = OctetStringRef::decode(nr)?.into();\n            let cipher = OctetStringRef::decode(nr)?.into();\n            Ok(Cipher {\n                x: Uint::from_be_bytes(zero_pad_byte_slice(x)?),\n                y: Uint::from_be_bytes(zero_pad_byte_slice(y)?),\n                digest,\n                cipher,\n            })\n        })\n    }",
    "display_name": "decode_value",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke.rs",
    "relative_path": "sm2/src/pke.rs",
    "file_name": "pke.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_even",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_odd"
    ],
    "body": "    pub fn is_even(&self) -> Choice {\n        !self.is_odd()\n    }",
    "display_name": "is_even",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/q1_times_mu_shift_five",
    "statement_type": "function",
    "deps": [],
    "body": "const fn q1_times_mu_shift_five(q1: &[Limb; 5]) -> [Limb; 5] {\n    // Schoolbook multiplication\n\n    let (_w0, carry) = q1[0].carrying_mul_add(MU[0], Limb::ZERO, Limb::ZERO);\n    let (w1, carry) = q1[0].carrying_mul_add(MU[1], Limb::ZERO, carry);\n    let (w2, carry) = q1[0].carrying_mul_add(MU[2], Limb::ZERO, carry);\n    let (w3, carry) = q1[0].carrying_mul_add(MU[3], Limb::ZERO, carry);\n    // NOTE MU[4] == 1\n    // let (w4, w5) = q1[0].carrying_mul_add(MU[4], Limb::ZERO, carry);\n    let (w4, w5) = Limb::ZERO.carrying_add(q1[0], carry);\n\n    let (_w1, carry) = q1[1].carrying_mul_add(MU[0], w1, Limb::ZERO);\n    let (w2, carry) = q1[1].carrying_mul_add(MU[1], w2, carry);\n    let (w3, carry) = q1[1].carrying_mul_add(MU[2], w3, carry);\n    let (w4, carry) = q1[1].carrying_mul_add(MU[3], w4, carry);\n    // let (w5, w6) = mac(w5, q1[1], MU[4], carry);\n    let (w5, w6) = w5.carrying_add(q1[1], carry);\n\n    let (_w2, carry) = q1[2].carrying_mul_add(MU[0], w2, Limb::ZERO);\n    let (w3, carry) = q1[2].carrying_mul_add(MU[1], w3, carry);\n    let (w4, carry) = q1[2].carrying_mul_add(MU[2], w4, carry);\n    let (w5, carry) = q1[2].carrying_mul_add(MU[3], w5, carry);\n    // let (w6, w7) = q1[2].carrying_mul_add(MU[4], w6, carry);\n    let (w6, w7) = w6.carrying_add(q1[2], carry);\n\n    let (_w3, carry) = q1[3].carrying_mul_add(MU[0], w3, Limb::ZERO);\n    let (w4, carry) = q1[3].carrying_mul_add(MU[1], w4, carry);\n    let (w5, carry) = q1[3].carrying_mul_add(MU[2], w5, carry);\n    let (w6, carry) = q1[3].carrying_mul_add(MU[3], w6, carry);\n    // let (w7, w8) = q1[3].carrying_mul_add(MU[4], w7, carry);\n    let (w7, w8) = w7.carrying_add(q1[3], carry);\n\n    let (_w4, carry) = q1[4].carrying_mul_add(MU[0], w4, Limb::ZERO);\n    let (w5, carry) = q1[4].carrying_mul_add(MU[1], w5, carry);\n    let (w6, carry) = q1[4].carrying_mul_add(MU[2], w6, carry);\n    let (w7, carry) = q1[4].carrying_mul_add(MU[3], w7, carry);\n    // let (w8, w9) = q1[4].carrying_mul_add(MU[4], w8, carry);\n    let (w8, w9) = w8.carrying_add(q1[4], carry);\n\n    // let q2 = [_w0, _w1, _w2, _w3, _w4, w5, w6, w7, w8, w9];\n    [w5, w6, w7, w8, w9]\n}",
    "display_name": "q1_times_mu_shift_five",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar/scalar64.rs",
    "relative_path": "p256/src/arithmetic/scalar/scalar64.rs",
    "file_name": "scalar64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/impl/Signature/from_slice"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Signature> {\n        Signature::from_slice(bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/sumadd_fast",
    "statement_type": "function",
    "deps": [],
    "body": "fn sumadd_fast(a: u64, c0: u64, c1: u64) -> (u64, u64) {\n    let (new_c0, carry0) = c0.overflowing_add(a);\n    let new_c1 = c1 + (carry0 as u64);\n    (new_c0, new_c1)\n}",
    "display_name": "sumadd_fast",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &ProjectivePoint) {\n        *self = ProjectivePoint::sub(self, rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub(self, other: AffinePoint) -> ProjectivePoint {\n        ProjectivePoint::sub_mixed(&self, &other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_twisted",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/edwards_isogeny"
    ],
    "body": "    pub(crate) fn to_twisted(self) -> TwistedExtendedPoint {\n        self.edwards_isogeny(FieldElement::ONE)\n    }",
    "display_name": "to_twisted",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SigningKey\")\n            .field(\"verifying_key\", &self.verifying_key)\n            .finish_non_exhaustive()\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/AffinePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn from(p: ProjectivePoint) -> AffinePoint {\n        p.to_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "    fn reduce_bytes(bytes: &FieldBytes) -> Self {\n        Self::reduce(U256::from_be_byte_array(*bytes))\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_set_one(out1: &mut fiat_p192_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0x1;\n    out1[1] = 0x1;\n    out1[2] = 0x0;\n}",
    "display_name": "fiat_p192_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> Box<[u8]> {\n        self.public_key.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/two_inv_constant",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/From/from"
    ],
    "body": "    fn two_inv_constant() {\n        assert_eq!(\n            (FieldElement::from(2u64) * FieldElement::TWO_INV).normalize(),\n            FieldElement::ONE\n        );\n    }",
    "display_name": "two_inv_constant",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, other: &FieldElement) {\n        *self = *self * *other;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine_internal"
    ],
    "body": "    pub fn to_affine(&self) -> AffinePoint {\n        self.z\n            .invert()\n            .map(|zinv| self.to_affine_internal(zinv))\n            .unwrap_or_else(|| AffinePoint::IDENTITY)\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalize_weak",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/add_modulus_correction",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/get_overflow",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/subtract_modulus_approximation",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/ConditionallySelectable/conditional_select"
    ],
    "body": "    pub fn normalize(&self) -> Self {\n        let res = self.normalize_weak();\n\n        // At most a single final reduction is needed;\n        // check if the value is >= the field characteristic\n        let overflow = res.get_overflow();\n\n        // Apply the final reduction (for constant-time behaviour, we do it always)\n        let res_corrected = res.add_modulus_correction(1u64);\n        // Mask off the possible multiple of 2^256 from the final reduction\n        let (res_corrected, x) = res_corrected.subtract_modulus_approximation();\n\n        // If the last limb didn't carry to bit 48 already,\n        // then it should have after any final reduction\n        debug_assert!(x == (overflow.unwrap_u8() as u64));\n\n        Self::conditional_select(&res, &res_corrected, overflow)\n    }",
    "display_name": "normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sqn"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        // p mod 4 = 3 -> compute sqrt(x) using x^((p+1)/4) =\n        // x^9850501549098619803069760025035903451269934817616361666986726319906914849778315892349739077038073728388608413485661\n        let t1 = *self;\n        let t10 = t1.square();\n        let t11 = *self * t10;\n        let t101 = t10 * t11;\n        let t111 = t10 * t101;\n        let t1001 = t10 * t111;\n        let t1011 = t10 * t1001;\n        let t1101 = t10 * t1011;\n        let t1111 = t10 * t1101;\n        let t11110 = t1111.square();\n        let t11111 = t1 * t11110;\n        let t1111100 = t11111.sqn(2);\n        let t11111000 = t1111100.square();\n        let i14 = t11111000.square();\n        let i20 = i14.sqn(5) * i14;\n        let i31 = i20.sqn(10) * i20;\n        let i58 = (i31.sqn(4) * t11111000).sqn(21) * i31;\n        let i110 = (i58.sqn(3) * t1111100).sqn(47) * i58;\n        let x194 = i110.sqn(95) * i110 * t1111;\n        let i225 = ((x194.sqn(6) * t111).sqn(3) * t11).sqn(7);\n        let i235 = ((t1101 * i225).sqn(6) * t1101).square() * t1;\n        let i258 = ((i235.sqn(11) * t11111).sqn(2) * t1).sqn(8);\n        let i269 = ((t1101 * i258).sqn(2) * t11).sqn(6) * t1011;\n        let i286 = ((i269.sqn(4) * t111).sqn(6) * t11111).sqn(5);\n        let i308 = ((t1011 * i286).sqn(10) * t1101).sqn(9) * t1101;\n        let i323 = ((i308.sqn(4) * t1011).sqn(6) * t1001).sqn(3);\n        let i340 = ((t1 * i323).sqn(7) * t1011).sqn(7) * t101;\n        let i357 = ((i340.sqn(5) * t111).sqn(5) * t1111).sqn(5);\n        let i369 = ((t1011 * i357).sqn(4) * t1011).sqn(5) * t111;\n        let i387 = ((i369.sqn(3) * t11).sqn(7) * t11).sqn(6);\n        let i397 = ((t1011 * i387).sqn(4) * t101).sqn(3) * t11;\n        let i413 = ((i397.sqn(4) * t11).sqn(4) * t11).sqn(6);\n        let i427 = ((t101 * i413).sqn(5) * t101).sqn(6) * t1011;\n        let x = i427.sqn(3) * t101;\n        CtOption::new(x, x.square().ct_eq(&t1))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(value.as_slice())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 test_scalar_y"
    ],
    "body": "fn bench_scalar_sub<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"sub\", |b| b.iter(|| x - y));\n}",
    "display_name": "bench_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: &FieldElement) {\n        *self = *self - other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/elliptic_curve::PublicKey/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(vk: VerifyingKey) -> PublicKey {\n        vk.inner\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/reduce_nonzero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero_bytes",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero"
    ],
    "body": "    fn reduce_nonzero() {\n        assert_eq!(Scalar::reduce_nonzero_bytes(&Array::default()).0, U384::ONE,);\n        assert_eq!(Scalar::reduce_nonzero(U384::ONE).0, U384::from_u8(2),);\n        assert_eq!(Scalar::reduce_nonzero(U384::from_u8(2)).0, U384::from_u8(3),);\n\n        assert_eq!(Scalar::reduce_nonzero(NistP384::ORDER).0, U384::from_u8(2),);\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP384::ORDER.wrapping_sub(&U384::from_u8(1))).0,\n            U384::ONE,\n        );\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP384::ORDER.wrapping_sub(&U384::from_u8(2))).0,\n            NistP384::ORDER.wrapping_sub(&U384::ONE),\n        );\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP384::ORDER.wrapping_sub(&U384::from_u8(3))).0,\n            NistP384::ORDER.wrapping_sub(&U384::from_u8(2)),\n        );\n\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP384::ORDER.wrapping_add(&U384::ONE)).0,\n            U384::from_u8(3),\n        );\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP384::ORDER.wrapping_add(&U384::from_u8(2))).0,\n            U384::from_u8(4),\n        );\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/test/test_hash_to_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/hash",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/is_on_curve"
    ],
    "body": "    fn test_hash_to_curve() {\n        use elliptic_curve::hash2curve::ExpandMsgXof;\n\n        let msg = b\"Hello, world!\";\n        let point = DecafPoint::hash::<ExpandMsgXof<sha3::Shake256>>(msg, b\"test_hash_to_curve\");\n        assert_eq!(point.0.is_on_curve().unwrap_u8(), 1u8);\n        assert_ne!(point, DecafPoint::IDENTITY);\n        assert_ne!(point, DecafPoint::GENERATOR);\n    }",
    "display_name": "test_hash_to_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/fuzzy_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre.8 arithmetic/field/tests/field_element",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/From/from",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/modulus_as_biguint"
    ],
    "body": "        fn fuzzy_square(\n            a in field_element()\n        ) {\n            let a_bi = a.to_biguint().unwrap();\n            let res_bi = (&a_bi * &a_bi) % FieldElement::modulus_as_biguint();\n            let res_ref = FieldElement::from(&res_bi);\n            let res_test = a.square().normalize();\n            assert_eq!(res_test, res_ref);\n        }",
    "display_name": "fuzzy_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.compressed.as_bytes() == other.compressed.as_bytes()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_canonical_bytes",
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    fn test_from_bytes_mod_order_wide() {\n        // n should become 0\n        let mut bytes = WideScalarBytes::from(hex!(\n            \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3\"\n        ));\n        bytes.reverse();\n        let s = Scalar::from_bytes_mod_order_wide(&bytes);\n        assert_eq!(s, Scalar::ZERO);\n\n        // n-1 should stay the same\n        let mut bytes = WideScalarBytes::from(hex!(\n            \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f2\"\n        ));\n        bytes.reverse();\n        let s = Scalar::from_bytes_mod_order_wide(&bytes);\n        assert_eq!(s, Scalar::ZERO - Scalar::ONE);\n\n        // n+1 should become 1\n        let mut bytes = WideScalarBytes::from(hex!(\n            \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f4\"\n        ));\n        bytes.reverse();\n        let s = Scalar::from_bytes_mod_order_wide(&bytes);\n        assert_eq!(s, Scalar::ONE);\n\n        // 2^912-1 should become 0x2939f823b7292052bcb7e4d070af1a9cc14ba3c47c44ae17cf72c985bb24b6c520e319fb37a63e29800f160787ad1d2e11883fa931e7de81\n        let bytes = WideScalarBytes::from(hex!(\n            \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n        ));\n        let s = Scalar::from_bytes_mod_order_wide(&bytes);\n        let mut bytes = ScalarBytes::from(hex!(\n            \"002939f823b7292052bcb7e4d070af1a9cc14ba3c47c44ae17cf72c985bb24b6c520e319fb37a63e29800f160787ad1d2e11883fa931e7de81\"\n        ));\n        bytes.reverse();\n        let reduced = Scalar::from_canonical_bytes(&bytes).unwrap();\n        assert_eq!(s, reduced);\n    }",
    "display_name": "test_from_bytes_mod_order_wide",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_y() -> Scalar {\n    black_box(Scalar::from_repr(\n        hex!(\"017e49b8ea8f9d1b7c0378e378a7a42e68e12cf78779ed41dcd29a090ae7e0f883b0d0f2cbc8f0473c0ad6732bea40d371a7f363bc6537d075bd1a4c23e558b0bc73\").into()\n    ).unwrap())\n}",
    "display_name": "test_scalar_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add_assign(&mut self, rhs: AffinePoint) {\n        *self = ProjectivePoint::add_mixed(self, &rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre bench_field_element_sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_field_element_x",
      "0.14.0_pre arithmetic/field/impl/FieldElement/sqrt"
    ],
    "body": "fn bench_field_element_sqrt<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"sqrt\", |b| b.iter(|| x.sqrt()));\n}",
    "display_name": "bench_field_element_sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/field.rs",
    "relative_path": "bign256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/is_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/is_zero"
    ],
    "body": "    pub fn is_zero(&self) -> Choice {\n        debug_assert!(self.normalized);\n        self.value.is_zero()\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: Box<[u8]>) -> Result<Self, Self::Error> {\n        Self::try_from(value.as_ref())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_to_montgomery(\n    out1: &mut fiat_p224_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p224_scalar_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x5, &mut x6, x4, 0xb1e97961);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x7, &mut x8, x4, 0x6ad15f7cd9714856);\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x9, &mut x10, x4, 0xabc8ff5931d63f4b);\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x11, &mut x12, x4, 0x29947a695f517d15);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x19, &mut x20, x11, 0xd6e242706a1fc2eb);\n    let mut x21: u64 = 0;\n    let mut x22: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x21, &mut x22, x19, 0xffffffff);\n    let mut x23: u64 = 0;\n    let mut x24: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x23, &mut x24, x19, 0xffffffffffffffff);\n    let mut x25: u64 = 0;\n    let mut x26: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x25, &mut x26, x19, 0xffff16a2e0b8f03e);\n    let mut x27: u64 = 0;\n    let mut x28: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x27, &mut x28, x19, 0x13dd29455c5c2a3d);\n    let mut x29: u64 = 0;\n    let mut x30: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x29, &mut x30, 0x0, x28, x25);\n    let mut x31: u64 = 0;\n    let mut x32: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x31, &mut x32, x30, x26, x23);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x33, &mut x34, x32, x24, x21);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x35, &mut x36, 0x0, x11, x27);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x37, &mut x38, x36, x13, x29);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x15, x31);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x17, x33);\n    let mut x43: u64 = 0;\n    let mut x44: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x43, &mut x44, x1, 0xb1e97961);\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x45, &mut x46, x1, 0x6ad15f7cd9714856);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x47, &mut x48, x1, 0xabc8ff5931d63f4b);\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x49, &mut x50, x1, 0x29947a695f517d15);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x51, &mut x52, 0x0, x50, x47);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x53, &mut x54, x52, x48, x45);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x55, &mut x56, x54, x46, x43);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x57, &mut x58, 0x0, x37, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x39, x51);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x61, &mut x62, x60, x41, x53);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(\n        &mut x63,\n        &mut x64,\n        x62,\n        (((x42 as u64) + ((x18 as u64) + x6)) + ((x34 as u64) + x22)),\n        x55,\n    );\n    let mut x65: u64 = 0;\n    let mut x66: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x65, &mut x66, x57, 0xd6e242706a1fc2eb);\n    let mut x67: u64 = 0;\n    let mut x68: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x67, &mut x68, x65, 0xffffffff);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x69, &mut x70, x65, 0xffffffffffffffff);\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x71, &mut x72, x65, 0xffff16a2e0b8f03e);\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x73, &mut x74, x65, 0x13dd29455c5c2a3d);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x75, &mut x76, 0x0, x74, x71);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x77, &mut x78, x76, x72, x69);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x79, &mut x80, x78, x70, x67);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x81, &mut x82, 0x0, x57, x73);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x83, &mut x84, x82, x59, x75);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x85, &mut x86, x84, x61, x77);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x87, &mut x88, x86, x63, x79);\n    let mut x89: u64 = 0;\n    let mut x90: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x89, &mut x90, x2, 0xb1e97961);\n    let mut x91: u64 = 0;\n    let mut x92: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x91, &mut x92, x2, 0x6ad15f7cd9714856);\n    let mut x93: u64 = 0;\n    let mut x94: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x93, &mut x94, x2, 0xabc8ff5931d63f4b);\n    let mut x95: u64 = 0;\n    let mut x96: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x95, &mut x96, x2, 0x29947a695f517d15);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x97, &mut x98, 0x0, x96, x93);\n    let mut x99: u64 = 0;\n    let mut x100: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x99, &mut x100, x98, x94, x91);\n    let mut x101: u64 = 0;\n    let mut x102: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x101, &mut x102, x100, x92, x89);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x103, &mut x104, 0x0, x83, x95);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x105, &mut x106, x104, x85, x97);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x107, &mut x108, x106, x87, x99);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(\n        &mut x109,\n        &mut x110,\n        x108,\n        (((x88 as u64) + ((x64 as u64) + ((x56 as u64) + x44))) + ((x80 as u64) + x68)),\n        x101,\n    );\n    let mut x111: u64 = 0;\n    let mut x112: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x111, &mut x112, x103, 0xd6e242706a1fc2eb);\n    let mut x113: u64 = 0;\n    let mut x114: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x113, &mut x114, x111, 0xffffffff);\n    let mut x115: u64 = 0;\n    let mut x116: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x115, &mut x116, x111, 0xffffffffffffffff);\n    let mut x117: u64 = 0;\n    let mut x118: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x117, &mut x118, x111, 0xffff16a2e0b8f03e);\n    let mut x119: u64 = 0;\n    let mut x120: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x119, &mut x120, x111, 0x13dd29455c5c2a3d);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x121, &mut x122, 0x0, x120, x117);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x123, &mut x124, x122, x118, x115);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x125, &mut x126, x124, x116, x113);\n    let mut x127: u64 = 0;\n    let mut x128: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x127, &mut x128, 0x0, x103, x119);\n    let mut x129: u64 = 0;\n    let mut x130: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x129, &mut x130, x128, x105, x121);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x131, &mut x132, x130, x107, x123);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x133, &mut x134, x132, x109, x125);\n    let mut x135: u64 = 0;\n    let mut x136: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x135, &mut x136, x3, 0xb1e97961);\n    let mut x137: u64 = 0;\n    let mut x138: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x137, &mut x138, x3, 0x6ad15f7cd9714856);\n    let mut x139: u64 = 0;\n    let mut x140: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x139, &mut x140, x3, 0xabc8ff5931d63f4b);\n    let mut x141: u64 = 0;\n    let mut x142: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x141, &mut x142, x3, 0x29947a695f517d15);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x143, &mut x144, 0x0, x142, x139);\n    let mut x145: u64 = 0;\n    let mut x146: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x145, &mut x146, x144, x140, x137);\n    let mut x147: u64 = 0;\n    let mut x148: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x147, &mut x148, x146, x138, x135);\n    let mut x149: u64 = 0;\n    let mut x150: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x149, &mut x150, 0x0, x129, x141);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x151, &mut x152, x150, x131, x143);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x153, &mut x154, x152, x133, x145);\n    let mut x155: u64 = 0;\n    let mut x156: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(\n        &mut x155,\n        &mut x156,\n        x154,\n        (((x134 as u64) + ((x110 as u64) + ((x102 as u64) + x90))) + ((x126 as u64) + x114)),\n        x147,\n    );\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x157, &mut x158, x149, 0xd6e242706a1fc2eb);\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x159, &mut x160, x157, 0xffffffff);\n    let mut x161: u64 = 0;\n    let mut x162: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x161, &mut x162, x157, 0xffffffffffffffff);\n    let mut x163: u64 = 0;\n    let mut x164: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x163, &mut x164, x157, 0xffff16a2e0b8f03e);\n    let mut x165: u64 = 0;\n    let mut x166: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x165, &mut x166, x157, 0x13dd29455c5c2a3d);\n    let mut x167: u64 = 0;\n    let mut x168: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x167, &mut x168, 0x0, x166, x163);\n    let mut x169: u64 = 0;\n    let mut x170: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x169, &mut x170, x168, x164, x161);\n    let mut x171: u64 = 0;\n    let mut x172: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x171, &mut x172, x170, x162, x159);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x173, &mut x174, 0x0, x149, x165);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x175, &mut x176, x174, x151, x167);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x177, &mut x178, x176, x153, x169);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x179, &mut x180, x178, x155, x171);\n    let x181: u64 =\n        (((x180 as u64) + ((x156 as u64) + ((x148 as u64) + x136))) + ((x172 as u64) + x160));\n    let mut x182: u64 = 0;\n    let mut x183: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x182, &mut x183, 0x0, x175, 0x13dd29455c5c2a3d);\n    let mut x184: u64 = 0;\n    let mut x185: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x184, &mut x185, x183, x177, 0xffff16a2e0b8f03e);\n    let mut x186: u64 = 0;\n    let mut x187: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x186, &mut x187, x185, x179, 0xffffffffffffffff);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x188, &mut x189, x187, x181, 0xffffffff);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x190, &mut x191, x189, (0x0 as u64), (0x0 as u64));\n    let mut x192: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x192, x191, x182, x175);\n    let mut x193: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x193, x191, x184, x177);\n    let mut x194: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x194, x191, x186, x179);\n    let mut x195: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x195, x191, x188, x181);\n    out1[0] = x192;\n    out1[1] = x193;\n    out1[2] = x194;\n    out1[3] = x195;\n}",
    "display_name": "fiat_p224_scalar_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> FieldBytes {\n        self.0.to_be_byte_array()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> EdwardsPoint {\n        -&self\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre bench_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_scalar_y",
      "0.14.0_pre test_scalar_x"
    ],
    "body": "fn bench_scalar_add<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"add\", |b| b.iter(|| x + y));\n}",
    "display_name": "bench_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/PrehashVerifier/verify_prehash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/verify_raw"
    ],
    "body": "    fn verify_prehash(\n        &self,\n        prehash: &[u8],\n        signature: &Signature,\n    ) -> core::result::Result<(), Error> {\n        self.verify_raw(prehash, signature)\n    }",
    "display_name": "verify_prehash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/ToEncodedPoint/to_encoded_point",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/to_affine",
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn to_encoded_point(&self, compress: bool) -> EncodedPoint<C> {\n        self.to_affine().to_encoded_point(compress)\n    }",
    "display_name": "to_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/sub",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add",
      "projective/impl/ProjectivePoint/neg"
    ],
    "body": "    pub fn sub(&self, other: &Self) -> Self {\n        self.add(&other.neg())\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/normalize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalize",
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_normalized"
    ],
    "body": "    pub fn normalize(&self) -> Self {\n        Self::new_normalized(&self.value.normalize())\n    }",
    "display_name": "normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/EdwardsPoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_untwisted"
    ],
    "body": "    fn from(point: &DecafPoint) -> Self {\n        point.0.to_untwisted()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "    fn reduce_bytes(bytes: &FieldBytes) -> Self {\n        let w = <U192 as FieldBytesEncoding<NistP192>>::decode_field_bytes(bytes);\n        Self::reduce(w)\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_nonzero(out1: &mut u64, arg1: &[u64; 3]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | (arg1[2])));\n    *out1 = x1;\n}",
    "display_name": "fiat_p192_scalar_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre ecdh",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdh/impl/EphemeralSecret/public_key",
      "0.14.0_pre ecdh/impl/EphemeralSecret/diffie_hellman",
      "0.14.0_pre ecdh/impl/EphemeralSecret/random",
      "0.14.0_pre public_key/impl/sec1::EncodedPoint::FieldBytesSize>/From/from",
      "0.14.0_pre public_key/impl/PublicKey/from_encoded_point",
      "0.14.0_pre ecdh/impl/SharedSecret/raw_secret_bytes"
    ],
    "body": "fn ecdh() {\n    use bign256::{EncodedPoint, PublicKey, ecdh::EphemeralSecret};\n    use rand_core::{OsRng, TryRngCore}; // requires 'os_rng' feature\n\n    // Alice\n    let alice_secret = EphemeralSecret::random(&mut OsRng.unwrap_mut());\n    let alice_pk_bytes = EncodedPoint::from(alice_secret.public_key());\n\n    // Bob\n    let bob_secret = EphemeralSecret::random(&mut OsRng.unwrap_mut());\n    let bob_pk_bytes = EncodedPoint::from(bob_secret.public_key());\n\n    // Alice decodes Bob's serialized public key and computes a shared secret from it\n    let bob_public =\n        PublicKey::from_encoded_point(bob_pk_bytes).expect(\"bob's public key is invalid!\"); // In real usage, don't panic, handle this!\n\n    let alice_shared = alice_secret.diffie_hellman(&bob_public);\n\n    // Bob decodes Alice's serialized public key and computes the same shared secret\n    let alice_public =\n        PublicKey::from_encoded_point(alice_pk_bytes).expect(\"alice's public key is invalid!\"); // In real usage, don't panic, handle this!\n\n    let bob_shared = bob_secret.diffie_hellman(&alice_public);\n\n    // Both participants arrive on the same shared secret\n    assert_eq!(\n        alice_shared.raw_secret_bytes(),\n        bob_shared.raw_secret_bytes()\n    );\n}",
    "display_name": "ecdh",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/ecdh.rs",
    "relative_path": "bign256/tests/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/generate_biased",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce",
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/from_bytes"
    ],
    "body": "    pub fn generate_biased<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        // We reduce a random 512-bit value into a 256-bit field, which results in a\n        // negligible bias from the uniform distribution, but the process is constant-time.\n        let mut buf = [0u8; 64];\n        rng.fill_bytes(&mut buf);\n        WideScalar::from_bytes(&buf).reduce()\n    }",
    "display_name": "generate_biased",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64"
    ],
    "body": "pub const fn fiat_bign256_square(\n    out1: &mut fiat_bign256_montgomery_domain_field_element,\n    arg1: &fiat_bign256_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x5, &mut x6, x4, (arg1[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x7, &mut x8, x4, (arg1[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x9, &mut x10, x4, (arg1[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x11, &mut x12, x4, (arg1[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x20, &mut x21, x11, 0xa53fa94fea53fa95);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x22, &mut x23, x20, 0xffffffffffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x26, &mut x27, x20, 0xffffffffffffffff);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x28, &mut x29, x20, 0xffffffffffffff43);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x30, &mut x31, 0x0, x29, x26);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x32, &mut x33, x31, x27, x24);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x34, &mut x35, x33, x25, x22);\n    let x36: u64 = ((x35 as u64) + x23);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x37, &mut x38, 0x0, x11, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x39, &mut x40, x38, x13, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x41, &mut x42, x40, x15, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x43, &mut x44, x42, x17, x34);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x45, &mut x46, x44, x19, x36);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x47, &mut x48, x1, (arg1[3]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x49, &mut x50, x1, (arg1[2]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x51, &mut x52, x1, (arg1[1]));\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x53, &mut x54, x1, (arg1[0]));\n    let mut x55: u64 = 0;\n    let mut x56: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x55, &mut x56, 0x0, x54, x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x57, &mut x58, x56, x52, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x59, &mut x60, x58, x50, x47);\n    let x61: u64 = ((x60 as u64) + x48);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x62, &mut x63, 0x0, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x68, &mut x69, x67, x45, x59);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x70, &mut x71, x69, (x46 as u64), x61);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x72, &mut x73, x62, 0xa53fa94fea53fa95);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x74, &mut x75, x72, 0xffffffffffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x78, &mut x79, x72, 0xffffffffffffffff);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x80, &mut x81, x72, 0xffffffffffffff43);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x82, &mut x83, 0x0, x81, x78);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x84, &mut x85, x83, x79, x76);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x86, &mut x87, x85, x77, x74);\n    let x88: u64 = ((x87 as u64) + x75);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x89, &mut x90, 0x0, x62, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x91, &mut x92, x90, x64, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x93, &mut x94, x92, x66, x84);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x95, &mut x96, x94, x68, x86);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x97, &mut x98, x96, x70, x88);\n    let x99: u64 = ((x98 as u64) + (x71 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x100, &mut x101, x2, (arg1[3]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x102, &mut x103, x2, (arg1[2]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x104, &mut x105, x2, (arg1[1]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x106, &mut x107, x2, (arg1[0]));\n    let mut x108: u64 = 0;\n    let mut x109: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x108, &mut x109, 0x0, x107, x104);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x110, &mut x111, x109, x105, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x112, &mut x113, x111, x103, x100);\n    let x114: u64 = ((x113 as u64) + x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x115, &mut x116, 0x0, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x121, &mut x122, x120, x97, x112);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x123, &mut x124, x122, x99, x114);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x125, &mut x126, x115, 0xa53fa94fea53fa95);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x127, &mut x128, x125, 0xffffffffffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x129, &mut x130, x125, 0xffffffffffffffff);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x131, &mut x132, x125, 0xffffffffffffffff);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x133, &mut x134, x125, 0xffffffffffffff43);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let x141: u64 = ((x140 as u64) + x128);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x142, &mut x143, 0x0, x115, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x144, &mut x145, x143, x117, x135);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x146, &mut x147, x145, x119, x137);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x148, &mut x149, x147, x121, x139);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x150, &mut x151, x149, x123, x141);\n    let x152: u64 = ((x151 as u64) + (x124 as u64));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x153, &mut x154, x3, (arg1[3]));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x155, &mut x156, x3, (arg1[2]));\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x157, &mut x158, x3, (arg1[1]));\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x159, &mut x160, x3, (arg1[0]));\n    let mut x161: u64 = 0;\n    let mut x162: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x161, &mut x162, 0x0, x160, x157);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x163, &mut x164, x162, x158, x155);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x165, &mut x166, x164, x156, x153);\n    let x167: u64 = ((x166 as u64) + x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x168, &mut x169, 0x0, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x172, &mut x173, x171, x148, x163);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x174, &mut x175, x173, x150, x165);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x176, &mut x177, x175, x152, x167);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x178, &mut x179, x168, 0xa53fa94fea53fa95);\n    let mut x180: u64 = 0;\n    let mut x181: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x180, &mut x181, x178, 0xffffffffffffffff);\n    let mut x182: u64 = 0;\n    let mut x183: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x182, &mut x183, x178, 0xffffffffffffffff);\n    let mut x184: u64 = 0;\n    let mut x185: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x184, &mut x185, x178, 0xffffffffffffffff);\n    let mut x186: u64 = 0;\n    let mut x187: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x186, &mut x187, x178, 0xffffffffffffff43);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x188, &mut x189, 0x0, x187, x184);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x190, &mut x191, x189, x185, x182);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x192, &mut x193, x191, x183, x180);\n    let x194: u64 = ((x193 as u64) + x181);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x195, &mut x196, 0x0, x168, x186);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x197, &mut x198, x196, x170, x188);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x199, &mut x200, x198, x172, x190);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x201, &mut x202, x200, x174, x192);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x203, &mut x204, x202, x176, x194);\n    let x205: u64 = ((x204 as u64) + (x177 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x206, &mut x207, 0x0, x197, 0xffffffffffffff43);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x208, &mut x209, x207, x199, 0xffffffffffffffff);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x210, &mut x211, x209, x201, 0xffffffffffffffff);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x212, &mut x213, x211, x203, 0xffffffffffffffff);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x214, &mut x215, x213, x205, (0x0 as u64));\n    let mut x216: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x216, x215, x206, x197);\n    let mut x217: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x217, x215, x208, x199);\n    let mut x218: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x218, x215, x210, x201);\n    let mut x219: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x219, x215, x212, x203);\n    out1[0] = x216;\n    out1[1] = x217;\n    out1[2] = x218;\n    out1[3] = x219;\n}",
    "display_name": "fiat_bign256_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn sub(&self, rhs: &Self) -> Self {\n        Self(self.0.sub_mod(&rhs.0, &ORDER))\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        self.invert()\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/From>/from"
    ],
    "body": "    fn from(public_key: PublicKey) -> ProjectivePoint {\n        AffinePoint::from(public_key).into()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/negate"
    ],
    "body": "    pub fn negate(&self, magnitude: u32) -> Self {\n        Self(self.0.negate(magnitude))\n    }",
    "display_name": "negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl//u8; _//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/impl/Signature/to_bytes"
    ],
    "body": "    fn from(signature: Signature) -> SignatureBytes {\n        signature.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre sign_and_verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/Verifier/verify",
      "0.14.0_pre signing_key",
      "0.14.0_pre dsa/signing/impl/SigningKey/verifying_key"
    ],
    "body": "    fn sign_and_verify(sk in signing_key()) {\n        let signature = sk.sign(MSG);\n        prop_assert!(sk.verifying_key().verify(MSG, &signature).is_ok());\n    }",
    "display_name": "sign_and_verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2dsa.rs",
    "relative_path": "sm2/tests/sm2dsa.rs",
    "file_name": "sm2dsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub(self, other: &AffinePoint) -> ProjectivePoint {\n        ProjectivePoint::sub_mixed(&self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        self.invert()\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, rhs: Self) {\n        *self = *self + rhs\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre decode_pkcs8_private_key_from_pem",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/to_bytes"
    ],
    "body": "fn decode_pkcs8_private_key_from_pem() {\n    let secret_key = PKCS8_PRIVATE_KEY_PEM.parse::<SecretKey>().unwrap();\n\n    // Ensure key parses equivalently to DER\n    let der_key = SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    assert_eq!(secret_key.to_bytes(), der_key.to_bytes());\n}",
    "display_name": "decode_pkcs8_private_key_from_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/pkcs8.rs",
    "relative_path": "bign256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 ristretto/points/impl/RistrettoPoint/encode",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn encode(&self) -> CompressedRistretto {\n        todo!()\n    }",
    "display_name": "encode",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/ristretto/points.rs",
    "relative_path": "ed448-goldilocks/src/ristretto/points.rs",
    "file_name": "points.rs",
    "parent_folder": "ristretto"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/invert",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine",
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes"
    ],
    "body": "    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // u = y^2 * [(1-dy^2)/(1-y^2)]\n\n        let affine = self.to_affine();\n\n        let yy = affine.y.square();\n        let dyy = FieldElement::EDWARDS_D * yy;\n\n        let u = yy * (FieldElement::ONE - dyy) * (FieldElement::ONE - yy).invert();\n\n        MontgomeryPoint(u.to_bytes())\n    }",
    "display_name": "to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_affine_niels",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn add_affine_niels(&self, other: AffineNielsPoint) -> ExtensiblePoint {\n        let A = other.y_minus_x * (self.Y - self.X);\n        let B = other.y_plus_x * (self.X + self.Y);\n        let C = other.td * self.T1 * self.T2;\n        let D = B + A;\n        let E = B - A;\n        let F = self.Z - C;\n        let G = self.Z + C;\n        ExtensiblePoint {\n            X: E * F,\n            Y: G * D,\n            Z: F * G,\n            T1: E,\n            T2: D,\n        }\n    }",
    "display_name": "add_affine_niels",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/test_compress_decompress",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/tests/hex_to_field",
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress"
    ],
    "body": "    fn test_compress_decompress() {\n        let x = hex_to_field(\n            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa955555555555555555555555555555555555555555555555555555555\",\n        );\n        let y = hex_to_field(\n            \"ae05e9634ad7048db359d6205086c2b0036ed7a035884dd7b7e36d728ad8c4b80d6565833a2a3098bbbcb2bed1cda06bdaeafbcdea9386ed\",\n        );\n        let generated = AffinePoint { x, y }.to_edwards();\n\n        let decompressed_point = generated.compress().decompress();\n        assert!(<Choice as Into<bool>>::into(decompressed_point.is_some()));\n\n        assert!(generated == decompressed_point.unwrap());\n    }",
    "display_name": "test_compress_decompress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add(self, other: ProjectivePoint) -> ProjectivePoint {\n        ProjectivePoint::add(&self, &other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/EdwardsPoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_untwisted"
    ],
    "body": "    fn from(point: DecafPoint) -> Self {\n        point.0.to_untwisted()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre invert_and_invert_vartime_are_equivalent",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre scalar"
    ],
    "body": "    fn invert_and_invert_vartime_are_equivalent(w in scalar()) {\n        let inv: Option<Scalar> = w.invert().into();\n        let inv_vartime: Option<Scalar> = w.invert_vartime().into();\n        prop_assert_eq!(inv, inv_vartime);\n    }",
    "display_name": "invert_and_invert_vartime_are_equivalent",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/scalar.rs",
    "relative_path": "bign256/tests/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "affine/impl/NonIdentity>/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(affine_point: AffinePoint<C>) -> Result<Self> {\n        NonIdentity::new(affine_point).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from(n: u128) -> Scalar {\n        Self::from_uint_unchecked(U576::from(n))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/tests/test_isogeny",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/double",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_untwisted",
      "0.14.0_pre.1 curve/twedwards/extended/tests/hex_to_field",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_twisted"
    ],
    "body": "    fn test_isogeny() {\n        let x = hex_to_field(\n            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa955555555555555555555555555555555555555555555555555555555\",\n        );\n        let y = hex_to_field(\n            \"ae05e9634ad7048db359d6205086c2b0036ed7a035884dd7b7e36d728ad8c4b80d6565833a2a3098bbbcb2bed1cda06bdaeafbcdea9386ed\",\n        );\n        let a = AffinePoint { x, y }.to_extended();\n        let twist_a = a.to_untwisted().to_twisted();\n        assert_eq!(twist_a, a.double().double())\n    }",
    "display_name": "test_isogeny",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/AddAssign>/add_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add_assign(&mut self, rhs: &ProjectivePoint<C>) {\n        *self = ProjectivePoint::add(self, rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_divstep_precomp(out1: &mut [u64; 4]) {\n    out1[0] = 0xeffe1f652465feb0;\n    out1[1] = 0xb12c827f1a30f6de;\n    out1[2] = 0xf63934f7445b1483;\n    out1[3] = 0x898f2e1e55dddae4;\n}",
    "display_name": "fiat_bign256_scalar_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/&FieldElement/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &FieldElement) -> FieldElement {\n        FieldElement(self.0.sub(&other.0))\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdh/diffie_hellman",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre ecdh/impl/SharedSecret/new"
    ],
    "body": "pub fn diffie_hellman(\n    secret_key: impl Borrow<NonZeroScalar>,\n    public_key: impl Borrow<AffinePoint>,\n) -> SharedSecret {\n    let public_point = ProjectivePoint::from(*public_key.borrow());\n    #[allow(clippy::arithmetic_side_effects)]\n    let secret_point = (public_point * secret_key.borrow().as_ref()).to_affine();\n    SharedSecret::new(secret_point)\n}",
    "display_name": "diffie_hellman",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/prehash_signer_signing_with_sha256",
    "statement_type": "function",
    "deps": [],
    "body": "    fn prehash_signer_signing_with_sha256() {\n        let x = hex!(\n            \"6b9d3dad2e1b8c1c05b19875b6659f4de23c3b667bf297ba9aa47740787137d896d5724e4c70a825f872c9ea60d2edf5\"\n        );\n        let signer = SigningKey::from_bytes(&x.into()).unwrap();\n        let digest = sha2::Sha256::digest(b\"test\");\n        let signature: Signature = signer.sign_prehash(&digest).unwrap();\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"010c3ab1a300f8c9d63eafa9a41813f0c5416c08814bdfc0236458d6c2603d71c4941f4696e60aff5717476170bb6ab4\n                03c4ad6274c61691346b2178def879424726909af308596ffb6355a042f48a114e2eb28eaa6918592b4727961057c0c1\"\n            )\n        );\n    }",
    "display_name": "prehash_signer_signing_with_sha256",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/ecdsa.rs",
    "relative_path": "p384/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64"
    ],
    "body": "pub const fn fiat_sm2_selectznz(\n    out1: &mut [u64; 4],\n    arg1: fiat_sm2_u1,\n    arg2: &[u64; 4],\n    arg3: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n}",
    "display_name": "fiat_sm2_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_divstep_precomp(out1: &mut [u64; 6]) {\n    out1[0] = 0xfff69400fff18fff;\n    out1[1] = 0x2b7feffffd3ff;\n    out1[2] = 0xfffedbfffffe97ff;\n    out1[3] = 0x2840000002fff;\n    out1[4] = 0x6040000050400;\n    out1[5] = 0xfffc480000038000;\n}",
    "display_name": "fiat_p384_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/From>/from"
    ],
    "body": "    fn from(uint: &U448) -> Self {\n        Self::from(*uint)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p192_u1,\n    arg1: fiat_p192_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_p192_i1 = ((x1 >> 64) as fiat_p192_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p192_i2) - (x2 as fiat_p192_i2)) as fiat_p192_u1);\n}",
    "display_name": "fiat_p192_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero"
    ],
    "body": "    fn reduce_nonzero_bytes(bytes: &FieldBytes) -> Self {\n        Self::reduce_nonzero(U384::from_be_byte_array(*bytes))\n    }",
    "display_name": "reduce_nonzero_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint"
    ],
    "body": "    fn try_from(w: Uint) -> Result<Self> {\n        Option::from(Self::from_uint(w)).ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn from_bytes_unchecked(bytes: &[u8; 32]) -> Self {\n        Self(U256::from_be_slice(bytes))\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/mul_single",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/mul_single"
    ],
    "body": "    pub fn mul_single(&self, rhs: u32) -> Self {\n        Self(self.0.mul_single(rhs))\n    }",
    "display_name": "mul_single",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/NonIdentity/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(affine_point: AffinePoint) -> Result<Self, Error> {\n        NonIdentity::new(affine_point).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from"
    ],
    "body": "        fn from(x: BigUint) -> Self {\n            Self::from(&x)\n        }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/square_n",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square"
    ],
    "body": "    fn square_n(&self, mut n: u32) -> FieldElement {\n        let mut result = self.square();\n\n        // Decrease value by 1 since we just did a squaring\n        n -= 1;\n\n        for _ in 0..n {\n            result = result.square();\n        }\n\n        result\n    }",
    "display_name": "square_n",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> FieldBytes {\n        self.secret_scalar.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/wycheproof/element_from_padded_slice",
    "statement_type": "function",
    "deps": [],
    "body": "            fn element_from_padded_slice<C: elliptic_curve::Curve>(\n                data: &[u8],\n            ) -> elliptic_curve::FieldBytes<C> {\n                let point_len = C::FieldBytesSize::USIZE;\n                if data.len() >= point_len {\n                    let offset = data.len() - point_len;\n                    for v in data.iter().take(offset) {\n                        assert_eq!(*v, 0, \"EcdsaVerifier: point too large\");\n                    }\n                    elliptic_curve::FieldBytes::<C>::try_from(&data[offset..])\n                        .expect(\"length mismatch\")\n                } else {\n                    let mut point = elliptic_curve::FieldBytes::<C>::default();\n                    let offset = point_len - data.len();\n                    point[offset..].copy_from_slice(data);\n                    point\n                }\n            }",
    "display_name": "element_from_padded_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/ecdsa.rs",
    "relative_path": "k256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/non_zero_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "        fn non_zero_scalar()(bytes in any::<[u8; 66]>()) -> NonZeroScalar {\n            NonZeroScalar::reduce_nonzero_bytes(&bytes.into())\n        }",
    "display_name": "non_zero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_divstep_precomp(out1: &mut [u64; 3]) {\n    out1[0] = 0xd2557b6a093d231d;\n    out1[1] = 0xd6e2378482e7b1;\n    out1[2] = 0x46ae48dd2558cd72;\n}",
    "display_name": "fiat_p192_scalar_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/is_odd"
    ],
    "body": "    pub fn is_odd(&self) -> Choice {\n        self.0.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/PrehashSigner/sign_prehash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_prehashed"
    ],
    "body": "    fn sign_prehash(&self, prehash: &[u8]) -> Result<Signature, Error> {\n        let sig = self.secret.sign_prehashed(&[], prehash)?;\n        Ok(sig.into())\n    }",
    "display_name": "sign_prehash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Self::IDENTITY, |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes"
    ],
    "body": "    pub fn y(&self) -> [u8; 56] {\n        self.y.to_bytes()\n    }",
    "display_name": "y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> Self::Output {\n        -&self\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: &ProjectivePoint) -> ProjectivePoint {\n        rhs * &self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible"
    ],
    "body": "    pub(crate) fn add(&self, other: &ExtendedPoint) -> ExtendedPoint {\n        self.to_extensible().add_extended(other).to_extended()\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/to_projective",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_projective(&self) -> ProjectivePoint {\n        self.point.into()\n    }",
    "display_name": "to_projective",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: &DecafAffinePoint) {\n        *self = *self - *other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/elliptic_curve::PublicKey/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(verifying_key: VerifyingKey) -> PublicKey {\n        verifying_key.public_key\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/tests/rfc6979",
    "statement_type": "function",
    "deps": [],
    "body": "    fn rfc6979() {\n        let x = hex!(\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\");\n        let signer = SigningKey::from_bytes(&x.into()).unwrap();\n        let signature: Signature = signer.sign(b\"sample\");\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"1CDFE6662DDE1E4A1EC4CDEDF6A1F5A2FB7FBD9145C12113E6ABFD3E\n                 A6694FD7718A21053F225D3F46197CA699D45006C06F871808F43EBC\"\n            )\n        );\n\n        let signature: Signature = signer.sign(b\"test\");\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"C441CE8E261DED634E4CF84910E4C5D1D22C5CF3B732BB204DBEF019\n                 902F42847A63BDC5F6046ADA114953120F99442D76510150F372A3F4\"\n            )\n        );\n    }",
    "display_name": "rfc6979",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/ecdsa.rs",
    "relative_path": "p224/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_hex",
      "0.14.0_pre arithmetic/field/impl/FieldElement/pow_vartime",
      "0.14.0_pre arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_u64",
      "0.14.0_pre arithmetic/field/impl/FieldElement/invert_unchecked"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        // Because p ≡ 3 mod 4 for secp192r1's base field modulus, sqrt can be done with only one\n        // exponentiation via the computation of self^((p + 1) // 4) (mod p).\n        let sqrt = self.pow_vartime(&[0xc000000000000000, 0xffffffffffffffff, 0x3fffffffffffffff]);\n        CtOption::new(sqrt, sqrt.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/primefield::bigint::Uint/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: &Scalar) -> U256 {\n        scalar.0\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: ProjectivePoint) -> ProjectivePoint {\n        rhs * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "point_arithmetic/sealed/PointArithmetic/add",
    "statement_type": "function",
    "deps": [],
    "body": "        fn add(lhs: &ProjectivePoint<C>, rhs: &ProjectivePoint<C>) -> ProjectivePoint<C>;\n\n        /// Returns `lhs + rhs`\n        fn add_mixed(lhs: &ProjectivePoint<C>, rhs: &AffinePoint<C>) -> ProjectivePoint<C>;\n\n        /// Returns `point + point`\n        fn double(point: &ProjectivePoint<C>) -> ProjectivePoint<C>;\n    }\n}\n\n/// Allow crate-local visibility\npub(crate) use sealed::PointArithmetic;\n\n/// The 𝒂-coefficient of the short Weierstrass equation does not have specific\n/// properties which allow for an optimized implementation.\npub struct EquationAIsGeneric {}\n",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, other: FieldElement) {\n        *self = *self * other;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/compress"
    ],
    "body": "    fn from(point: &DecafPoint) -> Vec<u8> {\n        point.compress().0.to_vec()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/non_zero_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "        fn non_zero_scalar()(bytes in any::<[u8; 32]>()) -> NonZeroScalar {\n            NonZeroScalar::reduce_nonzero_bytes(&bytes.into())\n        }",
    "display_name": "non_zero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_opp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_opp(\n    out1: &mut fiat_p521_loose_field_element,\n    arg1: &fiat_p521_tight_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (0x7fffffffffffffe - (arg1[0]));\n    let x2: u64 = (0x7fffffffffffffe - (arg1[1]));\n    let x3: u64 = (0x7fffffffffffffe - (arg1[2]));\n    let x4: u64 = (0x7fffffffffffffe - (arg1[3]));\n    let x5: u64 = (0x7fffffffffffffe - (arg1[4]));\n    let x6: u64 = (0x7fffffffffffffe - (arg1[5]));\n    let x7: u64 = (0x7fffffffffffffe - (arg1[6]));\n    let x8: u64 = (0x7fffffffffffffe - (arg1[7]));\n    let x9: u64 = (0x3fffffffffffffe - (arg1[8]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n    out1[4] = x5;\n    out1[5] = x6;\n    out1[6] = x7;\n    out1[7] = x8;\n    out1[8] = x9;\n}",
    "display_name": "fiat_p521_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre test_field_element_x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "fn test_field_element_x() -> FieldElement {\n    FieldElement::from_bytes(\n        &hex!(\"1ccbe91c075fc7f4f033bfa248db8fccd3565de94bbfb12f3c59ff46c271bf83\").into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_field_element_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/field.rs",
    "relative_path": "bign256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre encode_pkcs8_private_key_to_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/EncodePrivateKey/to_pkcs8_der"
    ],
    "body": "fn encode_pkcs8_private_key_to_der() {\n    let original_secret_key = SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let reencoded_secret_key = original_secret_key.to_pkcs8_der();\n    assert_eq!(\n        reencoded_secret_key.unwrap().to_bytes().to_vec(),\n        &PKCS8_PRIVATE_KEY_DER[..]\n    );\n}",
    "display_name": "encode_pkcs8_private_key_to_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/pkcs8.rs",
    "relative_path": "bign256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_mul",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_carry_mul(\n    out1: &mut fiat_p521_tight_field_element,\n    arg1: &fiat_p521_loose_field_element,\n    arg2: &fiat_p521_loose_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u128 = (((arg1[8]) as u128) * (((arg2[8]) * 0x2) as u128));\n    let x2: u128 = (((arg1[8]) as u128) * (((arg2[7]) * 0x2) as u128));\n    let x3: u128 = (((arg1[8]) as u128) * (((arg2[6]) * 0x2) as u128));\n    let x4: u128 = (((arg1[8]) as u128) * (((arg2[5]) * 0x2) as u128));\n    let x5: u128 = (((arg1[8]) as u128) * (((arg2[4]) * 0x2) as u128));\n    let x6: u128 = (((arg1[8]) as u128) * (((arg2[3]) * 0x2) as u128));\n    let x7: u128 = (((arg1[8]) as u128) * (((arg2[2]) * 0x2) as u128));\n    let x8: u128 = (((arg1[8]) as u128) * (((arg2[1]) * 0x2) as u128));\n    let x9: u128 = (((arg1[7]) as u128) * (((arg2[8]) * 0x2) as u128));\n    let x10: u128 = (((arg1[7]) as u128) * (((arg2[7]) * 0x2) as u128));\n    let x11: u128 = (((arg1[7]) as u128) * (((arg2[6]) * 0x2) as u128));\n    let x12: u128 = (((arg1[7]) as u128) * (((arg2[5]) * 0x2) as u128));\n    let x13: u128 = (((arg1[7]) as u128) * (((arg2[4]) * 0x2) as u128));\n    let x14: u128 = (((arg1[7]) as u128) * (((arg2[3]) * 0x2) as u128));\n    let x15: u128 = (((arg1[7]) as u128) * (((arg2[2]) * 0x2) as u128));\n    let x16: u128 = (((arg1[6]) as u128) * (((arg2[8]) * 0x2) as u128));\n    let x17: u128 = (((arg1[6]) as u128) * (((arg2[7]) * 0x2) as u128));\n    let x18: u128 = (((arg1[6]) as u128) * (((arg2[6]) * 0x2) as u128));\n    let x19: u128 = (((arg1[6]) as u128) * (((arg2[5]) * 0x2) as u128));\n    let x20: u128 = (((arg1[6]) as u128) * (((arg2[4]) * 0x2) as u128));\n    let x21: u128 = (((arg1[6]) as u128) * (((arg2[3]) * 0x2) as u128));\n    let x22: u128 = (((arg1[5]) as u128) * (((arg2[8]) * 0x2) as u128));\n    let x23: u128 = (((arg1[5]) as u128) * (((arg2[7]) * 0x2) as u128));\n    let x24: u128 = (((arg1[5]) as u128) * (((arg2[6]) * 0x2) as u128));\n    let x25: u128 = (((arg1[5]) as u128) * (((arg2[5]) * 0x2) as u128));\n    let x26: u128 = (((arg1[5]) as u128) * (((arg2[4]) * 0x2) as u128));\n    let x27: u128 = (((arg1[4]) as u128) * (((arg2[8]) * 0x2) as u128));\n    let x28: u128 = (((arg1[4]) as u128) * (((arg2[7]) * 0x2) as u128));\n    let x29: u128 = (((arg1[4]) as u128) * (((arg2[6]) * 0x2) as u128));\n    let x30: u128 = (((arg1[4]) as u128) * (((arg2[5]) * 0x2) as u128));\n    let x31: u128 = (((arg1[3]) as u128) * (((arg2[8]) * 0x2) as u128));\n    let x32: u128 = (((arg1[3]) as u128) * (((arg2[7]) * 0x2) as u128));\n    let x33: u128 = (((arg1[3]) as u128) * (((arg2[6]) * 0x2) as u128));\n    let x34: u128 = (((arg1[2]) as u128) * (((arg2[8]) * 0x2) as u128));\n    let x35: u128 = (((arg1[2]) as u128) * (((arg2[7]) * 0x2) as u128));\n    let x36: u128 = (((arg1[1]) as u128) * (((arg2[8]) * 0x2) as u128));\n    let x37: u128 = (((arg1[8]) as u128) * ((arg2[0]) as u128));\n    let x38: u128 = (((arg1[7]) as u128) * ((arg2[1]) as u128));\n    let x39: u128 = (((arg1[7]) as u128) * ((arg2[0]) as u128));\n    let x40: u128 = (((arg1[6]) as u128) * ((arg2[2]) as u128));\n    let x41: u128 = (((arg1[6]) as u128) * ((arg2[1]) as u128));\n    let x42: u128 = (((arg1[6]) as u128) * ((arg2[0]) as u128));\n    let x43: u128 = (((arg1[5]) as u128) * ((arg2[3]) as u128));\n    let x44: u128 = (((arg1[5]) as u128) * ((arg2[2]) as u128));\n    let x45: u128 = (((arg1[5]) as u128) * ((arg2[1]) as u128));\n    let x46: u128 = (((arg1[5]) as u128) * ((arg2[0]) as u128));\n    let x47: u128 = (((arg1[4]) as u128) * ((arg2[4]) as u128));\n    let x48: u128 = (((arg1[4]) as u128) * ((arg2[3]) as u128));\n    let x49: u128 = (((arg1[4]) as u128) * ((arg2[2]) as u128));\n    let x50: u128 = (((arg1[4]) as u128) * ((arg2[1]) as u128));\n    let x51: u128 = (((arg1[4]) as u128) * ((arg2[0]) as u128));\n    let x52: u128 = (((arg1[3]) as u128) * ((arg2[5]) as u128));\n    let x53: u128 = (((arg1[3]) as u128) * ((arg2[4]) as u128));\n    let x54: u128 = (((arg1[3]) as u128) * ((arg2[3]) as u128));\n    let x55: u128 = (((arg1[3]) as u128) * ((arg2[2]) as u128));\n    let x56: u128 = (((arg1[3]) as u128) * ((arg2[1]) as u128));\n    let x57: u128 = (((arg1[3]) as u128) * ((arg2[0]) as u128));\n    let x58: u128 = (((arg1[2]) as u128) * ((arg2[6]) as u128));\n    let x59: u128 = (((arg1[2]) as u128) * ((arg2[5]) as u128));\n    let x60: u128 = (((arg1[2]) as u128) * ((arg2[4]) as u128));\n    let x61: u128 = (((arg1[2]) as u128) * ((arg2[3]) as u128));\n    let x62: u128 = (((arg1[2]) as u128) * ((arg2[2]) as u128));\n    let x63: u128 = (((arg1[2]) as u128) * ((arg2[1]) as u128));\n    let x64: u128 = (((arg1[2]) as u128) * ((arg2[0]) as u128));\n    let x65: u128 = (((arg1[1]) as u128) * ((arg2[7]) as u128));\n    let x66: u128 = (((arg1[1]) as u128) * ((arg2[6]) as u128));\n    let x67: u128 = (((arg1[1]) as u128) * ((arg2[5]) as u128));\n    let x68: u128 = (((arg1[1]) as u128) * ((arg2[4]) as u128));\n    let x69: u128 = (((arg1[1]) as u128) * ((arg2[3]) as u128));\n    let x70: u128 = (((arg1[1]) as u128) * ((arg2[2]) as u128));\n    let x71: u128 = (((arg1[1]) as u128) * ((arg2[1]) as u128));\n    let x72: u128 = (((arg1[1]) as u128) * ((arg2[0]) as u128));\n    let x73: u128 = (((arg1[0]) as u128) * ((arg2[8]) as u128));\n    let x74: u128 = (((arg1[0]) as u128) * ((arg2[7]) as u128));\n    let x75: u128 = (((arg1[0]) as u128) * ((arg2[6]) as u128));\n    let x76: u128 = (((arg1[0]) as u128) * ((arg2[5]) as u128));\n    let x77: u128 = (((arg1[0]) as u128) * ((arg2[4]) as u128));\n    let x78: u128 = (((arg1[0]) as u128) * ((arg2[3]) as u128));\n    let x79: u128 = (((arg1[0]) as u128) * ((arg2[2]) as u128));\n    let x80: u128 = (((arg1[0]) as u128) * ((arg2[1]) as u128));\n    let x81: u128 = (((arg1[0]) as u128) * ((arg2[0]) as u128));\n    let x82: u128 = (x81 + (x36 + (x35 + (x33 + (x30 + (x26 + (x21 + (x15 + x8))))))));\n    let x83: u128 = (x82 >> 58);\n    let x84: u64 = ((x82 & (0x3ffffffffffffff as u128)) as u64);\n    let x85: u128 = (x73 + (x65 + (x58 + (x52 + (x47 + (x43 + (x40 + (x38 + x37))))))));\n    let x86: u128 = (x74 + (x66 + (x59 + (x53 + (x48 + (x44 + (x41 + (x39 + x1))))))));\n    let x87: u128 = (x75 + (x67 + (x60 + (x54 + (x49 + (x45 + (x42 + (x9 + x2))))))));\n    let x88: u128 = (x76 + (x68 + (x61 + (x55 + (x50 + (x46 + (x16 + (x10 + x3))))))));\n    let x89: u128 = (x77 + (x69 + (x62 + (x56 + (x51 + (x22 + (x17 + (x11 + x4))))))));\n    let x90: u128 = (x78 + (x70 + (x63 + (x57 + (x27 + (x23 + (x18 + (x12 + x5))))))));\n    let x91: u128 = (x79 + (x71 + (x64 + (x31 + (x28 + (x24 + (x19 + (x13 + x6))))))));\n    let x92: u128 = (x80 + (x72 + (x34 + (x32 + (x29 + (x25 + (x20 + (x14 + x7))))))));\n    let x93: u128 = (x83 + x92);\n    let x94: u128 = (x93 >> 58);\n    let x95: u64 = ((x93 & (0x3ffffffffffffff as u128)) as u64);\n    let x96: u128 = (x94 + x91);\n    let x97: u128 = (x96 >> 58);\n    let x98: u64 = ((x96 & (0x3ffffffffffffff as u128)) as u64);\n    let x99: u128 = (x97 + x90);\n    let x100: u128 = (x99 >> 58);\n    let x101: u64 = ((x99 & (0x3ffffffffffffff as u128)) as u64);\n    let x102: u128 = (x100 + x89);\n    let x103: u128 = (x102 >> 58);\n    let x104: u64 = ((x102 & (0x3ffffffffffffff as u128)) as u64);\n    let x105: u128 = (x103 + x88);\n    let x106: u128 = (x105 >> 58);\n    let x107: u64 = ((x105 & (0x3ffffffffffffff as u128)) as u64);\n    let x108: u128 = (x106 + x87);\n    let x109: u128 = (x108 >> 58);\n    let x110: u64 = ((x108 & (0x3ffffffffffffff as u128)) as u64);\n    let x111: u128 = (x109 + x86);\n    let x112: u128 = (x111 >> 58);\n    let x113: u64 = ((x111 & (0x3ffffffffffffff as u128)) as u64);\n    let x114: u128 = (x112 + x85);\n    let x115: u128 = (x114 >> 57);\n    let x116: u64 = ((x114 & (0x1ffffffffffffff as u128)) as u64);\n    let x117: u128 = ((x84 as u128) + x115);\n    let x118: u64 = ((x117 >> 58) as u64);\n    let x119: u64 = ((x117 & (0x3ffffffffffffff as u128)) as u64);\n    let x120: u64 = (x118 + x95);\n    let x121: fiat_p521_u1 = ((x120 >> 58) as fiat_p521_u1);\n    let x122: u64 = (x120 & 0x3ffffffffffffff);\n    let x123: u64 = ((x121 as u64) + x98);\n    out1[0] = x119;\n    out1[1] = x122;\n    out1[2] = x123;\n    out1[3] = x101;\n    out1[4] = x104;\n    out1[5] = x107;\n    out1[6] = x110;\n    out1[7] = x113;\n    out1[8] = x116;\n}",
    "display_name": "fiat_p521_carry_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/SubAssign>/sub_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub_assign(&mut self, rhs: AffinePoint<C>) {\n        *self = ProjectivePoint::sub_mixed(self, &rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_bign256_scalar_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/hex_to_field",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes"
    ],
    "body": "    fn hex_to_field(hex: &'static str) -> FieldElement {\n        assert_eq!(hex.len(), 56 * 2);\n        let mut bytes =\n            hex_literal::decode(&[hex.as_bytes()]).expect(\"Output array length should be correct\");\n        bytes.reverse();\n        FieldElement::from_bytes(&bytes)\n    }",
    "display_name": "hex_to_field",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/NonIdentity::AffinePoint>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/NonIdentity::AffinePoint>/From/from"
    ],
    "body": "    fn from(value: PublicKey) -> Self {\n        Self::from(&value)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint_unchecked"
    ],
    "body": "    fn from(n: u64) -> FieldElement {\n        Self::from_uint_unchecked(U576::from(n))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/normalize_weak",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalize_weak",
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_weak_normalized"
    ],
    "body": "    pub fn normalize_weak(&self) -> Self {\n        Self::new_weak_normalized(&self.value.normalize_weak())\n    }",
    "display_name": "normalize_weak",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_nonzero(out1: &mut u64, arg1: &[u64; 4]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | ((arg1[2]) | (arg1[3]))));\n    *out1 = x1;\n}",
    "display_name": "fiat_p224_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/error/impl/SigningError/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        match self {\n            SigningError::PrehashedContextLength => {\n                write!(f, \"prehashed context length is invalid\")\n            }\n            SigningError::InvalidPublicKeyBytes => write!(f, \"public key bytes are invalid\"),\n            SigningError::InvalidSignatureSComponent => {\n                write!(f, \"signature S component is invalid\")\n            }\n            SigningError::InvalidSignatureRComponent => {\n                write!(f, \"signature R component is invalid\")\n            }\n            SigningError::InvalidSignatureLength => write!(f, \"signature length is invalid\"),\n            SigningError::Verify => write!(f, \"signature verification failed\"),\n        }\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/error.rs",
    "relative_path": "ed448-goldilocks/src/sign/error.rs",
    "file_name": "error.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p384_scalar_u1,\n    arg1: fiat_p384_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_p384_scalar_i1 = ((x1 >> 64) as fiat_p384_scalar_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p384_scalar_i2) - (x2 as fiat_p384_scalar_i2)) as fiat_p384_scalar_u1);\n}",
    "display_name": "fiat_p384_scalar_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/Vec/From/from"
    ],
    "body": "    fn from(compressed: DecafPoint) -> Vec<u8> {\n        Self::from(&compressed)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&DecafAffinePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended"
    ],
    "body": "    fn sub(self, rhs: &DecafPoint) -> Self::Output {\n        DecafPoint(self.0.to_extended()) - rhs\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_invert<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"invert\", |b| b.iter(|| x.invert()));\n}",
    "display_name": "bench_field_element_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/field.rs",
    "relative_path": "p521/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/double",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn double(&self) -> Self {\n        Self(self.0.add(&self.0))\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Group/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 4],\n    out3: &mut [u64; 4],\n    out4: &mut [u64; 3],\n    out5: &mut [u64; 3],\n    arg1: u64,\n    arg2: &[u64; 4],\n    arg3: &[u64; 4],\n    arg4: &[u64; 3],\n    arg5: &[u64; 3],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_p192_scalar_u1 =\n        (((x1 >> 63) as fiat_p192_scalar_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_p192_scalar_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x11, &mut x12, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x13, &mut x14, x12, (0x0 as u64), (!(arg2[1])));\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x15, &mut x16, x14, (0x0 as u64), (!(arg2[2])));\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x17, &mut x18, x16, (0x0 as u64), (!(arg2[3])));\n    let mut x19: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x19, x3, (arg3[0]), x11);\n    let mut x20: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x20, x3, (arg3[1]), x13);\n    let mut x21: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x21, x3, (arg3[2]), x15);\n    let mut x22: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x22, x3, (arg3[3]), x17);\n    let mut x23: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x23, x3, (arg4[0]), (arg5[0]));\n    let mut x24: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x24, x3, (arg4[1]), (arg5[1]));\n    let mut x25: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x25, x3, (arg4[2]), (arg5[2]));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x26, &mut x27, 0x0, x23, x23);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x28, &mut x29, x27, x24, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x25, x25);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x32, &mut x33, 0x0, x26, 0x146bc9b1b4d22831);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x34, &mut x35, x33, x28, 0xffffffff99def836);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x36, &mut x37, x35, x30, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x38, &mut x39, x37, (x31 as u64), (0x0 as u64));\n    let x40: u64 = (arg4[2]);\n    let x41: u64 = (arg4[1]);\n    let x42: u64 = (arg4[0]);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x43, &mut x44, 0x0, (0x0 as u64), x42);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x45, &mut x46, x44, (0x0 as u64), x41);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x47, &mut x48, x46, (0x0 as u64), x40);\n    let mut x49: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x49, x48, (0x0 as u64), 0xffffffffffffffff);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x50, &mut x51, 0x0, x43, (x49 & 0x146bc9b1b4d22831));\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x52, &mut x53, x51, x45, (x49 & 0xffffffff99def836));\n    let mut x54: u64 = 0;\n    let mut x55: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x54, &mut x55, x53, x47, x49);\n    let mut x56: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x56, x3, (arg5[0]), x50);\n    let mut x57: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x57, x3, (arg5[1]), x52);\n    let mut x58: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x58, x3, (arg5[2]), x54);\n    let x59: fiat_p192_scalar_u1 = ((x19 & (0x1 as u64)) as fiat_p192_scalar_u1);\n    let mut x60: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x60, x59, (0x0 as u64), x7);\n    let mut x61: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x61, x59, (0x0 as u64), x8);\n    let mut x62: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x62, x59, (0x0 as u64), x9);\n    let mut x63: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x63, x59, (0x0 as u64), x10);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x64, &mut x65, 0x0, x19, x60);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x20, x61);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x21, x62);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x70, &mut x71, x69, x22, x63);\n    let mut x72: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x72, x59, (0x0 as u64), x23);\n    let mut x73: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x73, x59, (0x0 as u64), x24);\n    let mut x74: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x74, x59, (0x0 as u64), x25);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x75, &mut x76, 0x0, x56, x72);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x77, &mut x78, x76, x57, x73);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x79, &mut x80, x78, x58, x74);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x81, &mut x82, 0x0, x75, 0x146bc9b1b4d22831);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x83, &mut x84, x82, x77, 0xffffffff99def836);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x85, &mut x86, x84, x79, 0xffffffffffffffff);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x87, &mut x88, x86, (x80 as u64), (0x0 as u64));\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x89, &mut x90, 0x0, x6, (0x1 as u64));\n    let x91: u64 = ((x64 >> 1) | ((x66 << 63) & 0xffffffffffffffff));\n    let x92: u64 = ((x66 >> 1) | ((x68 << 63) & 0xffffffffffffffff));\n    let x93: u64 = ((x68 >> 1) | ((x70 << 63) & 0xffffffffffffffff));\n    let x94: u64 = ((x70 & 0x8000000000000000) | (x70 >> 1));\n    let mut x95: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x95, x39, x32, x26);\n    let mut x96: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x96, x39, x34, x28);\n    let mut x97: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x97, x39, x36, x30);\n    let mut x98: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x98, x88, x81, x75);\n    let mut x99: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x99, x88, x83, x77);\n    let mut x100: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x100, x88, x85, x79);\n    *out1 = x89;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out3[0] = x91;\n    out3[1] = x92;\n    out3[2] = x93;\n    out3[3] = x94;\n    out4[0] = x95;\n    out4[1] = x96;\n    out4[2] = x97;\n    out5[0] = x98;\n    out5[1] = x99;\n    out5[2] = x100;\n}",
    "display_name": "fiat_p192_scalar_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/fuzzy_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/field/tests/field_element",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/From/from",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/ToBigUint/to_biguint"
    ],
    "body": "        fn fuzzy_mul(\n            a in field_element(),\n            b in field_element()\n        ) {\n            let a_bi = a.to_biguint().unwrap();\n            let b_bi = b.to_biguint().unwrap();\n            let res_bi = (&a_bi * &b_bi) % FieldElement::modulus_as_biguint();\n            let res_ref = FieldElement::from(&res_bi);\n            let res_test = (&a * &b).normalize();\n            assert_eq!(res_test, res_ref);\n        }",
    "display_name": "fuzzy_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(p: &ProjectivePoint) -> Self {\n        let mut points = [*p; 8];\n        for j in 0..7 {\n            points[j + 1] = p + &points[j];\n        }\n        LookupTable(points)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 test_field_element_x",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_field_element_x() -> FieldElement {\n    black_box(FieldElement::from_bytes(\n        hex!(\"01a7596d38aac7868327ddc1ef5e8178cf052b7ebc512828e8a45955d85bef49494d15278198bbcc5454358c12a2af9a3874e7002e1a2f02fcb36ff3e3b4bc0c69e7\").as_ref()\n    )\n    .unwrap())\n}",
    "display_name": "test_field_element_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/field.rs",
    "relative_path": "p521/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub_assign(&mut self, rhs: ProjectivePoint<C>) {\n        *self = ProjectivePoint::sub(self, &rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/add"
    ],
    "body": "    fn add(self, other: FieldElement) -> FieldElement {\n        FieldElement(self.0.add(&(other.0)))\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/as_affine",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_affine(&self) -> &AffinePoint {\n        self.inner.as_affine()\n    }",
    "display_name": "as_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert_vartime",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert() {\n        assert_eq!(Scalar::ONE, Scalar::ONE.invert().unwrap());\n\n        let three = Scalar::from(3u64);\n        let inv_three = three.invert().unwrap();\n        assert_eq!(three * inv_three, Scalar::ONE);\n\n        let minus_three = -three;\n        let inv_minus_three = minus_three.invert().unwrap();\n        assert_eq!(inv_minus_three, -inv_three);\n        assert_eq!(three * inv_minus_three, -Scalar::ONE);\n\n        assert!(bool::from(Scalar::ZERO.invert().is_none()));\n        assert_eq!(Scalar::from(2u64).invert().unwrap(), Scalar::TWO_INV);\n        assert_eq!(\n            Scalar::ROOT_OF_UNITY.invert_vartime().unwrap(),\n            Scalar::ROOT_OF_UNITY_INV\n        );\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/GroupEncoding/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        let encoded = self.to_encoded_point(true);\n        let mut result = CompressedPoint::default();\n        result[..encoded.len()].copy_from_slice(encoded.as_bytes());\n        result\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    fn from_repr(repr: Self::Repr) -> CtOption<Self> {\n        Self::from_bytes(&repr)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre signing_key",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/signing/impl/SigningKey/from_nonzero_scalar",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes"
    ],
    "body": "    fn signing_key()(bytes in any::<[u8; 32]>()) -> SigningKey {\n        loop {\n            let scalar = <Scalar as Reduce<U256>>::reduce_bytes(&bytes.into());\n            if let Some(scalar) = Option::from(NonZeroScalar::new(scalar)) {\n                return SigningKey::from_nonzero_scalar(scalar).unwrap();\n            }\n        }\n    }",
    "display_name": "signing_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/dsa.rs",
    "relative_path": "bign256/tests/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.value.ct_eq(&(other.value))\n            & self.magnitude.ct_eq(&(other.magnitude))\n            // See the comment in `conditional_select()`\n            & Choice::from((self.normalized == other.normalized) as u8)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ShrAssign/shr_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn shr_assign(&mut self, rhs: usize) {\n        *self = *self >> rhs;\n    }",
    "display_name": "shr_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/square",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn square(&self) -> Self {\n        let value = self.0.square_wide();\n        Self(U448::rem_wide_vartime(value, &NZ_ORDER))\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/AffineCoordinates/y_is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative"
    ],
    "body": "    fn y_is_odd(&self) -> Choice {\n        self.y.is_negative()\n    }",
    "display_name": "y_is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify"
    ],
    "body": "    fn verify(&self, msg: &[u8], signature: &Signature) -> Result<()> {\n        self.multipart_verify(&[msg], signature)\n    }",
    "display_name": "verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/LinearCombination/lincomb",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/Radix16Decomposition/Default/default",
      "0.14.0_pre.8 arithmetic/mul/lincomb",
      "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/Default/default"
    ],
    "body": "    fn lincomb(points_and_scalars: &[(ProjectivePoint, Scalar)]) -> Self {\n        let mut tables =\n            vec![(LookupTable::default(), LookupTable::default()); points_and_scalars.len()];\n        let mut digits = vec![\n            (\n                Radix16Decomposition::<33>::default(),\n                Radix16Decomposition::<33>::default(),\n            );\n            points_and_scalars.len()\n        ];\n\n        lincomb(points_and_scalars, &mut tables, &mut digits)\n    }",
    "display_name": "lincomb",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &DecryptingKey) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    pub const fn double(&self) -> Self {\n        self.add(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/generator",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn generator() -> ProjectivePoint {\n        Self::GENERATOR\n    }",
    "display_name": "generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/from_bytes_unchecked"
    ],
    "body": "    pub(crate) const fn from_bytes_unchecked(bytes: &[u8; 32]) -> Self {\n        Self(FieldElementImpl::from_bytes_unchecked(bytes))\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/impl/fiat_p384_scalar_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/affine_to_projective",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From/from",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/is_identity"
    ],
    "body": "    fn affine_to_projective() {\n        let basepoint_affine = AffinePoint::GENERATOR;\n        let basepoint_projective = ProjectivePoint::GENERATOR;\n\n        assert_eq!(\n            ProjectivePoint::from(basepoint_affine),\n            basepoint_projective,\n        );\n        assert_eq!(basepoint_projective.to_affine(), basepoint_affine);\n        assert!(!bool::from(basepoint_projective.to_affine().is_identity()));\n\n        assert!(bool::from(\n            ProjectivePoint::IDENTITY.to_affine().is_identity()\n        ));\n    }",
    "display_name": "affine_to_projective",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 impl/primefield::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        U384::from_be_byte_array(*field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/lib.rs",
    "relative_path": "p384/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre decode_pkcs8_private_key_from_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/to_bytes"
    ],
    "body": "fn decode_pkcs8_private_key_from_der() {\n    let secret_key = SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let expected_scalar = hex!(\"1F66B5B84B7339674533F0329C74F21834281FED0732429E0C79235FC273E269\");\n    assert_eq!(secret_key.to_bytes().as_slice(), &expected_scalar[..]);\n}",
    "display_name": "decode_pkcs8_private_key_from_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/pkcs8.rs",
    "relative_path": "bign256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_basic_halving",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/halve",
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_basic_halving() {\n        let eight = Scalar::from(8u8);\n        let four = Scalar::from(4u8);\n        let two = Scalar::from(2u8);\n        assert_eq!(eight.halve(), four);\n        assert_eq!(four.halve(), two);\n        assert_eq!(two.halve(), Scalar::ONE);\n    }",
    "display_name": "test_basic_halving",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64"
    ],
    "body": "pub const fn fiat_sm2_mul(\n    out1: &mut fiat_sm2_montgomery_domain_field_element,\n    arg1: &fiat_sm2_montgomery_domain_field_element,\n    arg2: &fiat_sm2_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x5, &mut x6, x4, (arg2[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x7, &mut x8, x4, (arg2[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x9, &mut x10, x4, (arg2[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x11, &mut x12, x4, (arg2[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x20, &mut x21, x11, 0xfffffffeffffffff);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x22, &mut x23, x11, 0xffffffffffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x24, &mut x25, x11, 0xffffffff00000000);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x26, &mut x27, x11, 0xffffffffffffffff);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x28, &mut x29, 0x0, x27, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x30, &mut x31, x29, x25, x22);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x32, &mut x33, x31, x23, x20);\n    let x34: u64 = ((x33 as u64) + x21);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x35, &mut x36, 0x0, x11, x26);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x37, &mut x38, x36, x13, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x39, &mut x40, x38, x15, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x41, &mut x42, x40, x17, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x43, &mut x44, x42, x19, x34);\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x45, &mut x46, x1, (arg2[3]));\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x47, &mut x48, x1, (arg2[2]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x49, &mut x50, x1, (arg2[1]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x51, &mut x52, x1, (arg2[0]));\n    let mut x53: u64 = 0;\n    let mut x54: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x53, &mut x54, 0x0, x52, x49);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x55, &mut x56, x54, x50, x47);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x57, &mut x58, x56, x48, x45);\n    let x59: u64 = ((x58 as u64) + x46);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x60, &mut x61, 0x0, x37, x51);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x62, &mut x63, x61, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x68, &mut x69, x67, (x44 as u64), x59);\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x70, &mut x71, x60, 0xfffffffeffffffff);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x72, &mut x73, x60, 0xffffffffffffffff);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x74, &mut x75, x60, 0xffffffff00000000);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x76, &mut x77, x60, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x78, &mut x79, 0x0, x77, x74);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x80, &mut x81, x79, x75, x72);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x82, &mut x83, x81, x73, x70);\n    let x84: u64 = ((x83 as u64) + x71);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x85, &mut x86, 0x0, x60, x76);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x87, &mut x88, x86, x62, x78);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x89, &mut x90, x88, x64, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x91, &mut x92, x90, x66, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x93, &mut x94, x92, x68, x84);\n    let x95: u64 = ((x94 as u64) + (x69 as u64));\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x96, &mut x97, x2, (arg2[3]));\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x98, &mut x99, x2, (arg2[2]));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x100, &mut x101, x2, (arg2[1]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x102, &mut x103, x2, (arg2[0]));\n    let mut x104: u64 = 0;\n    let mut x105: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x104, &mut x105, 0x0, x103, x100);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x106, &mut x107, x105, x101, x98);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x108, &mut x109, x107, x99, x96);\n    let x110: u64 = ((x109 as u64) + x97);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x111, &mut x112, 0x0, x87, x102);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x113, &mut x114, x112, x89, x104);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x115, &mut x116, x114, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x121, &mut x122, x111, 0xfffffffeffffffff);\n    let mut x123: u64 = 0;\n    let mut x124: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x123, &mut x124, x111, 0xffffffffffffffff);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x125, &mut x126, x111, 0xffffffff00000000);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x127, &mut x128, x111, 0xffffffffffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x129, &mut x130, 0x0, x128, x125);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x131, &mut x132, x130, x126, x123);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x133, &mut x134, x132, x124, x121);\n    let x135: u64 = ((x134 as u64) + x122);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x136, &mut x137, 0x0, x111, x127);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x138, &mut x139, x137, x113, x129);\n    let mut x140: u64 = 0;\n    let mut x141: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x140, &mut x141, x139, x115, x131);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x142, &mut x143, x141, x117, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x144, &mut x145, x143, x119, x135);\n    let x146: u64 = ((x145 as u64) + (x120 as u64));\n    let mut x147: u64 = 0;\n    let mut x148: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x147, &mut x148, x3, (arg2[3]));\n    let mut x149: u64 = 0;\n    let mut x150: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x149, &mut x150, x3, (arg2[2]));\n    let mut x151: u64 = 0;\n    let mut x152: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x151, &mut x152, x3, (arg2[1]));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x153, &mut x154, x3, (arg2[0]));\n    let mut x155: u64 = 0;\n    let mut x156: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x155, &mut x156, 0x0, x154, x151);\n    let mut x157: u64 = 0;\n    let mut x158: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x157, &mut x158, x156, x152, x149);\n    let mut x159: u64 = 0;\n    let mut x160: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x159, &mut x160, x158, x150, x147);\n    let x161: u64 = ((x160 as u64) + x148);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x162, &mut x163, 0x0, x138, x153);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x164, &mut x165, x163, x140, x155);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x166, &mut x167, x165, x142, x157);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x168, &mut x169, x167, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x172, &mut x173, x162, 0xfffffffeffffffff);\n    let mut x174: u64 = 0;\n    let mut x175: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x174, &mut x175, x162, 0xffffffffffffffff);\n    let mut x176: u64 = 0;\n    let mut x177: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x176, &mut x177, x162, 0xffffffff00000000);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x178, &mut x179, x162, 0xffffffffffffffff);\n    let mut x180: u64 = 0;\n    let mut x181: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x180, &mut x181, 0x0, x179, x176);\n    let mut x182: u64 = 0;\n    let mut x183: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x182, &mut x183, x181, x177, x174);\n    let mut x184: u64 = 0;\n    let mut x185: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x184, &mut x185, x183, x175, x172);\n    let x186: u64 = ((x185 as u64) + x173);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x187, &mut x188, 0x0, x162, x178);\n    let mut x189: u64 = 0;\n    let mut x190: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x189, &mut x190, x188, x164, x180);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x191, &mut x192, x190, x166, x182);\n    let mut x193: u64 = 0;\n    let mut x194: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x193, &mut x194, x192, x168, x184);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x195, &mut x196, x194, x170, x186);\n    let x197: u64 = ((x196 as u64) + (x171 as u64));\n    let mut x198: u64 = 0;\n    let mut x199: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x198, &mut x199, 0x0, x189, 0xffffffffffffffff);\n    let mut x200: u64 = 0;\n    let mut x201: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x200, &mut x201, x199, x191, 0xffffffff00000000);\n    let mut x202: u64 = 0;\n    let mut x203: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x202, &mut x203, x201, x193, 0xffffffffffffffff);\n    let mut x204: u64 = 0;\n    let mut x205: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x204, &mut x205, x203, x195, 0xfffffffeffffffff);\n    let mut x206: u64 = 0;\n    let mut x207: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x206, &mut x207, x205, x197, (0x0 as u64));\n    let mut x208: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x208, x207, x198, x189);\n    let mut x209: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x209, x207, x200, x191);\n    let mut x210: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x210, x207, x202, x193);\n    let mut x211: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x211, x207, x204, x195);\n    out1[0] = x208;\n    out1[1] = x209;\n    out1[2] = x210;\n    out1[3] = x211;\n}",
    "display_name": "fiat_sm2_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(decaf: NonIdentity<DecafPoint>) -> Self {\n        decaf.to_point()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: &ProjectivePoint) -> ProjectivePoint {\n        rhs * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p224_scalar_u1,\n    arg1: fiat_p224_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_p224_scalar_u1 = ((x1 >> 64) as fiat_p224_scalar_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p224_scalar_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_weak_normalized",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/square"
    ],
    "body": "    pub fn square(&self) -> Self {\n        debug_assert!(self.magnitude <= 8);\n        Self::new_weak_normalized(&(self.value.square()))\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/decode_invalid_field_element_returns_err",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn decode_invalid_field_element_returns_err() {\n        let overflowing_bytes = hex!(\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        );\n        let ct_option = FieldElement::from_bytes(&overflowing_bytes.into());\n        assert!(bool::from(ct_option.is_none()));\n    }",
    "display_name": "decode_invalid_field_element_returns_err",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/PreHasherXof/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SigningPreHasherXof\")\n            .finish_non_exhaustive()\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre bench_scalar_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_scalar_x"
    ],
    "body": "fn bench_scalar_invert<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"invert\", |b| b.iter(|| x.invert()));\n}",
    "display_name": "bench_scalar_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_bign256_scalar_u1,\n    arg1: fiat_bign256_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_bign256_scalar_i1 = ((x1 >> 64) as fiat_bign256_scalar_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_bign256_scalar_i2) - (x2 as fiat_bign256_scalar_i2))\n        as fiat_bign256_scalar_u1);\n}",
    "display_name": "fiat_bign256_scalar_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/halve",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn halve(&self) -> Self {\n        Self(self.0.shr_vartime(1))\n    }",
    "display_name": "halve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.0.ct_eq(&(other.0)).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/affine/impl/AffinePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn sub(&self, rhs: &Self) -> Self {\n        Self(self.0.sub_mod(&rhs.0, &NistP256::ORDER))\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/RandomizedMultipartSigner/try_multipart_sign_with_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/RandomizedPrehashSigner/sign_prehash_with_rng",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/hash_msg"
    ],
    "body": "    fn try_multipart_sign_with_rng<R: TryCryptoRng + ?Sized>(\n        &self,\n        rng: &mut R,\n        msg: &[&[u8]],\n    ) -> Result<Signature> {\n        // A1: set M~=ZA || M\n        let hash = self.verifying_key.hash_msg(msg);\n        self.sign_prehash_with_rng(rng, &hash)\n    }",
    "display_name": "try_multipart_sign_with_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_sqrt<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"sqrt\", |b| b.iter(|| x.sqrt()));\n}",
    "display_name": "bench_field_element_sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/field.rs",
    "relative_path": "p256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    fn from(value: &AffinePoint) -> Self {\n        value.to_edwards()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/SignatureEncoding/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        self.into()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64"
    ],
    "body": "pub const fn fiat_bign256_from_montgomery(\n    out1: &mut fiat_bign256_non_montgomery_domain_field_element,\n    arg1: &fiat_bign256_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x2, &mut x3, x1, 0xa53fa94fea53fa95);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x4, &mut x5, x2, 0xffffffffffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x6, &mut x7, x2, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x8, &mut x9, x2, 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x10, &mut x11, x2, 0xffffffffffffff43);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x12, &mut x13, 0x0, x11, x8);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x14, &mut x15, x13, x9, x6);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x16, &mut x17, x15, x7, x4);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x18, &mut x19, 0x0, x1, x10);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), x12);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x22, &mut x23, x21, (0x0 as u64), x14);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x24, &mut x25, x23, (0x0 as u64), x16);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x26, &mut x27, x25, (0x0 as u64), ((x17 as u64) + x5));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x28, &mut x29, 0x0, x20, (arg1[1]));\n    let mut x30: u64 = 0;\n    let mut x31: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x30, &mut x31, x29, x22, (0x0 as u64));\n    let mut x32: u64 = 0;\n    let mut x33: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x32, &mut x33, x31, x24, (0x0 as u64));\n    let mut x34: u64 = 0;\n    let mut x35: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x34, &mut x35, x33, x26, (0x0 as u64));\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x36, &mut x37, x28, 0xa53fa94fea53fa95);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x38, &mut x39, x36, 0xffffffffffffffff);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x40, &mut x41, x36, 0xffffffffffffffff);\n    let mut x42: u64 = 0;\n    let mut x43: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x42, &mut x43, x36, 0xffffffffffffffff);\n    let mut x44: u64 = 0;\n    let mut x45: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x44, &mut x45, x36, 0xffffffffffffff43);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x46, &mut x47, 0x0, x45, x42);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x48, &mut x49, x47, x43, x40);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x50, &mut x51, x49, x41, x38);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x52, &mut x53, 0x0, x28, x44);\n    let mut x54: u64 = 0;\n    let mut x55: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x54, &mut x55, x53, x30, x46);\n    let mut x56: u64 = 0;\n    let mut x57: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x56, &mut x57, x55, x32, x48);\n    let mut x58: u64 = 0;\n    let mut x59: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x58, &mut x59, x57, x34, x50);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(\n        &mut x60,\n        &mut x61,\n        x59,\n        ((x35 as u64) + (x27 as u64)),\n        ((x51 as u64) + x39),\n    );\n    let mut x62: u64 = 0;\n    let mut x63: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x62, &mut x63, 0x0, x54, (arg1[2]));\n    let mut x64: u64 = 0;\n    let mut x65: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x64, &mut x65, x63, x56, (0x0 as u64));\n    let mut x66: u64 = 0;\n    let mut x67: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x66, &mut x67, x65, x58, (0x0 as u64));\n    let mut x68: u64 = 0;\n    let mut x69: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x68, &mut x69, x67, x60, (0x0 as u64));\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x70, &mut x71, x62, 0xa53fa94fea53fa95);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x72, &mut x73, x70, 0xffffffffffffffff);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x74, &mut x75, x70, 0xffffffffffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x76, &mut x77, x70, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x78, &mut x79, x70, 0xffffffffffffff43);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x80, &mut x81, 0x0, x79, x76);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x82, &mut x83, x81, x77, x74);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x84, &mut x85, x83, x75, x72);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x86, &mut x87, 0x0, x62, x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x88, &mut x89, x87, x64, x80);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x90, &mut x91, x89, x66, x82);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x92, &mut x93, x91, x68, x84);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(\n        &mut x94,\n        &mut x95,\n        x93,\n        ((x69 as u64) + (x61 as u64)),\n        ((x85 as u64) + x73),\n    );\n    let mut x96: u64 = 0;\n    let mut x97: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x96, &mut x97, 0x0, x88, (arg1[3]));\n    let mut x98: u64 = 0;\n    let mut x99: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x98, &mut x99, x97, x90, (0x0 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x100, &mut x101, x99, x92, (0x0 as u64));\n    let mut x102: u64 = 0;\n    let mut x103: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x102, &mut x103, x101, x94, (0x0 as u64));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x104, &mut x105, x96, 0xa53fa94fea53fa95);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x106, &mut x107, x104, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x108, &mut x109, x104, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x110, &mut x111, x104, 0xffffffffffffffff);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x112, &mut x113, x104, 0xffffffffffffff43);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x114, &mut x115, 0x0, x113, x110);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x116, &mut x117, x115, x111, x108);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x118, &mut x119, x117, x109, x106);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x120, &mut x121, 0x0, x96, x112);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x122, &mut x123, x121, x98, x114);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x124, &mut x125, x123, x100, x116);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x126, &mut x127, x125, x102, x118);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(\n        &mut x128,\n        &mut x129,\n        x127,\n        ((x103 as u64) + (x95 as u64)),\n        ((x119 as u64) + x107),\n    );\n    let mut x130: u64 = 0;\n    let mut x131: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x130, &mut x131, 0x0, x122, 0xffffffffffffff43);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x132, &mut x133, x131, x124, 0xffffffffffffffff);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x134, &mut x135, x133, x126, 0xffffffffffffffff);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x136, &mut x137, x135, x128, 0xffffffffffffffff);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x138, &mut x139, x137, (x129 as u64), (0x0 as u64));\n    let mut x140: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x140, x139, x130, x122);\n    let mut x141: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x141, x139, x132, x124);\n    let mut x142: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x142, x139, x134, x126);\n    let mut x143: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x143, x139, x136, x128);\n    out1[0] = x140;\n    out1[1] = x141;\n    out1[2] = x142;\n    out1[3] = x143;\n}",
    "display_name": "fiat_bign256_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/recovery/public_key_recovery",
    "statement_type": "function",
    "deps": [],
    "body": "        fn public_key_recovery() {\n            for vector in RECOVERY_TEST_VECTORS {\n                let digest = Sha256::new_with_prefix(vector.msg);\n                let sig = Signature::try_from(vector.sig.as_slice()).unwrap();\n                let recid = vector.recid;\n                let pk = VerifyingKey::recover_from_digest(digest, &sig, recid).unwrap();\n                assert_eq!(&vector.pk[..], EncodedPoint::from(&pk).as_bytes());\n            }\n        }",
    "display_name": "public_key_recovery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/ecdsa.rs",
    "relative_path": "k256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_mulx_u64"
    ],
    "body": "pub const fn fiat_p192_to_montgomery(\n    out1: &mut fiat_p192_montgomery_domain_field_element,\n    arg1: &fiat_p192_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[0]);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p192_mulx_u64(&mut x4, &mut x5, x3, 0x2);\n    let mut x6: u64 = 0;\n    let mut x7: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x6, &mut x7, 0x0, ((x5 as fiat_p192_u1) as u64), x3);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p192_mulx_u64(&mut x8, &mut x9, x3, 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_p192_mulx_u64(&mut x10, &mut x11, x3, 0xfffffffffffffffe);\n    let mut x12: u64 = 0;\n    let mut x13: u64 = 0;\n    fiat_p192_mulx_u64(&mut x12, &mut x13, x3, 0xffffffffffffffff);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x14, &mut x15, 0x0, x13, x10);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x16, &mut x17, x15, x11, x8);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x18, &mut x19, 0x0, x3, x12);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x20, &mut x21, x19, x4, x14);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x22, &mut x23, x21, x6, x16);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x24, &mut x25, x23, (x7 as u64), ((x17 as u64) + x9));\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p192_mulx_u64(&mut x26, &mut x27, x1, 0x2);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x28, &mut x29, 0x0, ((x27 as fiat_p192_u1) as u64), x1);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x30, &mut x31, 0x0, x20, x1);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x32, &mut x33, x31, x22, x26);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x34, &mut x35, x33, x24, x28);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p192_mulx_u64(&mut x36, &mut x37, x30, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p192_mulx_u64(&mut x38, &mut x39, x30, 0xfffffffffffffffe);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_p192_mulx_u64(&mut x40, &mut x41, x30, 0xffffffffffffffff);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x42, &mut x43, 0x0, x41, x38);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x44, &mut x45, x43, x39, x36);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x46, &mut x47, 0x0, x30, x40);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x48, &mut x49, x47, x32, x42);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x50, &mut x51, x49, x34, x44);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(\n        &mut x52,\n        &mut x53,\n        x51,\n        (((x35 as u64) + (x25 as u64)) + (x29 as u64)),\n        ((x45 as u64) + x37),\n    );\n    let mut x54: u64 = 0;\n    let mut x55: u64 = 0;\n    fiat_p192_mulx_u64(&mut x54, &mut x55, x2, 0x2);\n    let mut x56: u64 = 0;\n    let mut x57: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x56, &mut x57, 0x0, ((x55 as fiat_p192_u1) as u64), x2);\n    let mut x58: u64 = 0;\n    let mut x59: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x58, &mut x59, 0x0, x48, x2);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x60, &mut x61, x59, x50, x54);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x62, &mut x63, x61, x52, x56);\n    let mut x64: u64 = 0;\n    let mut x65: u64 = 0;\n    fiat_p192_mulx_u64(&mut x64, &mut x65, x58, 0xffffffffffffffff);\n    let mut x66: u64 = 0;\n    let mut x67: u64 = 0;\n    fiat_p192_mulx_u64(&mut x66, &mut x67, x58, 0xfffffffffffffffe);\n    let mut x68: u64 = 0;\n    let mut x69: u64 = 0;\n    fiat_p192_mulx_u64(&mut x68, &mut x69, x58, 0xffffffffffffffff);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x70, &mut x71, 0x0, x69, x66);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x72, &mut x73, x71, x67, x64);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x74, &mut x75, 0x0, x58, x68);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x76, &mut x77, x75, x60, x70);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x78, &mut x79, x77, x62, x72);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(\n        &mut x80,\n        &mut x81,\n        x79,\n        (((x63 as u64) + (x53 as u64)) + (x57 as u64)),\n        ((x73 as u64) + x65),\n    );\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x82, &mut x83, 0x0, x76, 0xffffffffffffffff);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x84, &mut x85, x83, x78, 0xfffffffffffffffe);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x86, &mut x87, x85, x80, 0xffffffffffffffff);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x88, &mut x89, x87, (x81 as u64), (0x0 as u64));\n    let mut x90: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x90, x89, x82, x76);\n    let mut x91: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x91, x89, x84, x78);\n    let mut x92: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x92, x89, x86, x80);\n    out1[0] = x90;\n    out1[1] = x91;\n    out1[2] = x92;\n}",
    "display_name": "fiat_p192_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt_digest"
    ],
    "body": "    pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>> {\n        self.decrypt_digest::<Sm3>(ciphertext)\n    }",
    "display_name": "decrypt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        let mut acc = Scalar::ZERO;\n        for s in iter {\n            acc += s;\n        }\n        acc\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/FieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/carry"
    ],
    "body": "    fn from(loose: &LooseFieldElement) -> FieldElement {\n        loose.carry()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/Vec/From/from"
    ],
    "body": "    fn from(compressed: CompressedDecaf) -> Vec<u8> {\n        Self::from(&compressed)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre encode_pkcs8_private_key_to_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_private_key_to_pem() {\n    let original_secret_key = SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let reencoded_secret_key = original_secret_key\n        .to_pkcs8_pem(Default::default())\n        .unwrap();\n    assert_eq!(reencoded_secret_key.as_str(), PKCS8_PRIVATE_KEY_PEM);\n}",
    "display_name": "encode_pkcs8_private_key_to_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/pkcs8.rs",
    "relative_path": "bign256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/impl/fiat_p521_scalar_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/sub_inner"
    ],
    "body": "pub(super) const fn sub(a: U256, b: U256) -> U256 {\n    let a = a.as_limbs();\n    let b = b.as_limbs();\n\n    let (result, _) = sub_inner(\n        [a[0], a[1], a[2], a[3], Limb::ZERO],\n        [b[0], b[1], b[2], b[3], Limb::ZERO],\n    );\n    U256::new([result[0], result[1], result[2], result[3]])\n}",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field/field64.rs",
    "relative_path": "p256/src/arithmetic/field/field64.rs",
    "file_name": "field64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/&ProjectivePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/mul"
    ],
    "body": "    fn mul(self, other: &Scalar) -> ProjectivePoint {\n        mul(self, other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "    fn mul_assign(&mut self, rhs: &Scalar) {\n        *self = Scalar::multiply(self, rhs);\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/negate",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn negate(&self, magnitude: u32) -> Self {\n        let m = (magnitude + 1) as u64;\n        let r0 = 0xFFFFEFFFFFC2Fu64 * 2 * m - self.0[0];\n        let r1 = 0xFFFFFFFFFFFFFu64 * 2 * m - self.0[1];\n        let r2 = 0xFFFFFFFFFFFFFu64 * 2 * m - self.0[2];\n        let r3 = 0xFFFFFFFFFFFFFu64 * 2 * m - self.0[3];\n        let r4 = 0x0FFFFFFFFFFFFu64 * 2 * m - self.0[4];\n        Self([r0, r1, r2, r3, r4])\n    }",
    "display_name": "negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/mul",
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_weak_normalized"
    ],
    "body": "    pub fn mul(&self, rhs: &Self) -> Self {\n        debug_assert!(self.magnitude <= 8);\n        debug_assert!(rhs.magnitude <= 8);\n        Self::new_weak_normalized(&(self.value.mul(&(rhs.value))))\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/GroupEncoding/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/GroupEncoding/from_bytes"
    ],
    "body": "    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        <AffinePoint as GroupEncoding>::from_bytes(bytes).map(Into::into)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/Context/PrehashSigner/sign_prehash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_prehashed"
    ],
    "body": "    fn sign_prehash(&self, prehash: &[u8]) -> Result<Signature, Error> {\n        let sig = self.key.secret.sign_prehashed(self.value, prehash)?;\n        Ok(sig.into())\n    }",
    "display_name": "sign_prehash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn test_mul() {\n        let a = Scalar(U448::from_be_hex(\n            \"1e63e8073b089f0747cf8cac2c3dc2732aae8688a8fa552ba8cb0ae8c0be082e74d657641d9ac30a087b8fb97f8ed27dc96a3c35ffb823a3\",\n        ));\n\n        let b = Scalar(U448::from_be_hex(\n            \"16c5450acae1cb680a92de2d8e59b30824e8d4991adaa0e7bc343bcbd099595b188c6b1a1e30b38b17aa6d9be416b899686eb329d8bedc42\",\n        ));\n\n        let exp = Scalar(U448::from_be_hex(\n            \"31e055c14ca389edfccd61b3203d424bb9036ff6f2d89c1e07bcd93174e9335f36a1492008a3a0e46abd26f5994c9c2b1f5b3197a18d010a\",\n        ));\n\n        assert_eq!(a * b, exp)\n    }",
    "display_name": "test_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &'b EdwardsPoint) {\n        *self = *self + _rhs;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(U256::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_opp"
    ],
    "body": "    pub const fn neg(&self) -> Self {\n        let mut out = fiat_p521_scalar_montgomery_domain_field_element([0; 9]);\n        fiat_p521_scalar_opp(&mut out, &self.0);\n        Self(out)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes(bytes: &SignatureBytes) -> Result<Self> {\n        let (s0, s1) = bytes.split_at(Self::BYTE_SIZE / 3);\n        let mut s0_bytes: Array<u8, U32> = Default::default();\n        s0_bytes[..16].copy_from_slice(s0);\n\n        let s0 = ScalarPrimitive::from_slice(&s0_bytes).map_err(|_| Error::new())?;\n        let s1 = ScalarPrimitive::from_slice(s1).map_err(|_| Error::new())?;\n\n        if s0.is_zero().into() || s1.is_zero().into() {\n            return Err(Error::new());\n        }\n\n        Ok(Self { s0, s1 })\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p224_u1,\n    arg1: fiat_p224_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_p224_i1 = ((x1 >> 64) as fiat_p224_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p224_i2) - (x2 as fiat_p224_i2)) as fiat_p224_u1);\n}",
    "display_name": "fiat_p224_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/div_by_four",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn div_by_four(&mut self) {\n        self.0 >>= 2;\n    }",
    "display_name": "div_by_four",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/GroupEncoding/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        let mut value = [0u8; 57];\n        value.copy_from_slice(bytes);\n        CompressedEdwardsY(value).decompress()\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsZero/PointArithmetic/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(lhs: &ProjectivePoint<C>, rhs: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        debug_assert_eq!(\n            C::EQUATION_A,\n            C::FieldElement::ZERO,\n            \"this implementation is only valid for C::EQUATION_A = 0\"\n        );\n\n        let b3 = C::FieldElement::from(3) * C::EQUATION_B;\n\n        let t0 = lhs.x * rhs.x; // 1\n        let t1 = lhs.y * rhs.y; // 2\n        let t2 = lhs.z * rhs.z; // 3\n        let t3 = lhs.x + lhs.y; // 4\n        let t4 = rhs.x + rhs.y; // 5\n        let t3 = t3 * t4; // 6\n        let t4 = t0 + t1; // 7\n        let t3 = t3 - t4; // 8\n        let t4 = lhs.y + lhs.z; // 9\n        let x3 = rhs.y + rhs.z; // 10\n        let t4 = t4 * x3; // 11\n        let x3 = t1 + t2; // 12\n        let t4 = t4 - x3; // 13\n        let x3 = lhs.x + lhs.z; // 14\n        let y3 = rhs.x + rhs.z; // 15\n        let x3 = x3 * y3; // 16\n        let y3 = t0 + t2; // 17\n        let y3 = x3 - y3; // 18\n        let x3 = t0.double(); // 19\n        let t0 = x3 + t0; // 20\n        let t2 = b3 * t2; // 21\n        let z3 = t1 + t2; // 22\n        let t1 = t1 - t2; // 23\n        let y3 = b3 * y3; // 24\n        let x3 = t4 * y3; // 25\n        let t2 = t3 * t1; // 26\n        let x3 = t2 - x3; // 27\n        let y3 = y3 * t0; // 28\n        let t1 = t1 * z3; // 29\n        let y3 = t1 + y3; // 30\n        let t0 = t0 * t3; // 31\n        let z3 = z3 * t4; // 32\n        let z3 = z3 + t0; // 33\n\n        ProjectivePoint {\n            x: x3,\n            y: y3,\n            z: z3,\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/GroupEncoding/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress"
    ],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        Self::Repr::from(self.compress().0)\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_to_bytes(out1: &mut [u8; 48], arg1: &[u64; 6]) {\n    let x1: u64 = (arg1[5]);\n    let x2: u64 = (arg1[4]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[2]);\n    let x5: u64 = (arg1[1]);\n    let x6: u64 = (arg1[0]);\n    let x7: u8 = ((x6 & (0xff as u64)) as u8);\n    let x8: u64 = (x6 >> 8);\n    let x9: u8 = ((x8 & (0xff as u64)) as u8);\n    let x10: u64 = (x8 >> 8);\n    let x11: u8 = ((x10 & (0xff as u64)) as u8);\n    let x12: u64 = (x10 >> 8);\n    let x13: u8 = ((x12 & (0xff as u64)) as u8);\n    let x14: u64 = (x12 >> 8);\n    let x15: u8 = ((x14 & (0xff as u64)) as u8);\n    let x16: u64 = (x14 >> 8);\n    let x17: u8 = ((x16 & (0xff as u64)) as u8);\n    let x18: u64 = (x16 >> 8);\n    let x19: u8 = ((x18 & (0xff as u64)) as u8);\n    let x20: u8 = ((x18 >> 8) as u8);\n    let x21: u8 = ((x5 & (0xff as u64)) as u8);\n    let x22: u64 = (x5 >> 8);\n    let x23: u8 = ((x22 & (0xff as u64)) as u8);\n    let x24: u64 = (x22 >> 8);\n    let x25: u8 = ((x24 & (0xff as u64)) as u8);\n    let x26: u64 = (x24 >> 8);\n    let x27: u8 = ((x26 & (0xff as u64)) as u8);\n    let x28: u64 = (x26 >> 8);\n    let x29: u8 = ((x28 & (0xff as u64)) as u8);\n    let x30: u64 = (x28 >> 8);\n    let x31: u8 = ((x30 & (0xff as u64)) as u8);\n    let x32: u64 = (x30 >> 8);\n    let x33: u8 = ((x32 & (0xff as u64)) as u8);\n    let x34: u8 = ((x32 >> 8) as u8);\n    let x35: u8 = ((x4 & (0xff as u64)) as u8);\n    let x36: u64 = (x4 >> 8);\n    let x37: u8 = ((x36 & (0xff as u64)) as u8);\n    let x38: u64 = (x36 >> 8);\n    let x39: u8 = ((x38 & (0xff as u64)) as u8);\n    let x40: u64 = (x38 >> 8);\n    let x41: u8 = ((x40 & (0xff as u64)) as u8);\n    let x42: u64 = (x40 >> 8);\n    let x43: u8 = ((x42 & (0xff as u64)) as u8);\n    let x44: u64 = (x42 >> 8);\n    let x45: u8 = ((x44 & (0xff as u64)) as u8);\n    let x46: u64 = (x44 >> 8);\n    let x47: u8 = ((x46 & (0xff as u64)) as u8);\n    let x48: u8 = ((x46 >> 8) as u8);\n    let x49: u8 = ((x3 & (0xff as u64)) as u8);\n    let x50: u64 = (x3 >> 8);\n    let x51: u8 = ((x50 & (0xff as u64)) as u8);\n    let x52: u64 = (x50 >> 8);\n    let x53: u8 = ((x52 & (0xff as u64)) as u8);\n    let x54: u64 = (x52 >> 8);\n    let x55: u8 = ((x54 & (0xff as u64)) as u8);\n    let x56: u64 = (x54 >> 8);\n    let x57: u8 = ((x56 & (0xff as u64)) as u8);\n    let x58: u64 = (x56 >> 8);\n    let x59: u8 = ((x58 & (0xff as u64)) as u8);\n    let x60: u64 = (x58 >> 8);\n    let x61: u8 = ((x60 & (0xff as u64)) as u8);\n    let x62: u8 = ((x60 >> 8) as u8);\n    let x63: u8 = ((x2 & (0xff as u64)) as u8);\n    let x64: u64 = (x2 >> 8);\n    let x65: u8 = ((x64 & (0xff as u64)) as u8);\n    let x66: u64 = (x64 >> 8);\n    let x67: u8 = ((x66 & (0xff as u64)) as u8);\n    let x68: u64 = (x66 >> 8);\n    let x69: u8 = ((x68 & (0xff as u64)) as u8);\n    let x70: u64 = (x68 >> 8);\n    let x71: u8 = ((x70 & (0xff as u64)) as u8);\n    let x72: u64 = (x70 >> 8);\n    let x73: u8 = ((x72 & (0xff as u64)) as u8);\n    let x74: u64 = (x72 >> 8);\n    let x75: u8 = ((x74 & (0xff as u64)) as u8);\n    let x76: u8 = ((x74 >> 8) as u8);\n    let x77: u8 = ((x1 & (0xff as u64)) as u8);\n    let x78: u64 = (x1 >> 8);\n    let x79: u8 = ((x78 & (0xff as u64)) as u8);\n    let x80: u64 = (x78 >> 8);\n    let x81: u8 = ((x80 & (0xff as u64)) as u8);\n    let x82: u64 = (x80 >> 8);\n    let x83: u8 = ((x82 & (0xff as u64)) as u8);\n    let x84: u64 = (x82 >> 8);\n    let x85: u8 = ((x84 & (0xff as u64)) as u8);\n    let x86: u64 = (x84 >> 8);\n    let x87: u8 = ((x86 & (0xff as u64)) as u8);\n    let x88: u64 = (x86 >> 8);\n    let x89: u8 = ((x88 & (0xff as u64)) as u8);\n    let x90: u8 = ((x88 >> 8) as u8);\n    out1[0] = x7;\n    out1[1] = x9;\n    out1[2] = x11;\n    out1[3] = x13;\n    out1[4] = x15;\n    out1[5] = x17;\n    out1[6] = x19;\n    out1[7] = x20;\n    out1[8] = x21;\n    out1[9] = x23;\n    out1[10] = x25;\n    out1[11] = x27;\n    out1[12] = x29;\n    out1[13] = x31;\n    out1[14] = x33;\n    out1[15] = x34;\n    out1[16] = x35;\n    out1[17] = x37;\n    out1[18] = x39;\n    out1[19] = x41;\n    out1[20] = x43;\n    out1[21] = x45;\n    out1[22] = x47;\n    out1[23] = x48;\n    out1[24] = x49;\n    out1[25] = x51;\n    out1[26] = x53;\n    out1[27] = x55;\n    out1[28] = x57;\n    out1[29] = x59;\n    out1[30] = x61;\n    out1[31] = x62;\n    out1[32] = x63;\n    out1[33] = x65;\n    out1[34] = x67;\n    out1[35] = x69;\n    out1[36] = x71;\n    out1[37] = x73;\n    out1[38] = x75;\n    out1[39] = x76;\n    out1[40] = x77;\n    out1[41] = x79;\n    out1[42] = x81;\n    out1[43] = x83;\n    out1[44] = x85;\n    out1[45] = x87;\n    out1[46] = x89;\n    out1[47] = x90;\n}",
    "display_name": "fiat_p384_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Ord/cmp",
    "statement_type": "function",
    "deps": [],
    "body": "    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n        self.0.cmp(&other.0)\n    }",
    "display_name": "cmp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/test_vector_repeated_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn test_vector_repeated_add() {\n        let generator = ProjectivePoint::GENERATOR;\n        let mut p = generator;\n\n        for i in 0..ADD_TEST_VECTORS.len() {\n            let affine = p.to_affine();\n\n            let (expected_x, expected_y) = ADD_TEST_VECTORS[i];\n            assert_eq!(affine.x.to_bytes(), expected_x);\n            assert_eq!(affine.y.to_bytes(), expected_y);\n\n            p += &generator;\n        }\n    }",
    "display_name": "test_vector_repeated_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/NonIdentity::AffinePoint>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/to_nonidentity"
    ],
    "body": "    fn from(value: &PublicKey) -> Self {\n        PublicKey::to_nonidentity(value)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/multiply",
    "statement_type": "function",
    "deps": [],
    "body": "    fn multiply() {\n        let one = Scalar::ONE;\n        let two = one + one;\n        let three = two + one;\n        let six = three + three;\n        assert_eq!(six, two * three);\n\n        let minus_two = -two;\n        let minus_three = -three;\n        assert_eq!(two, -minus_two);\n\n        assert_eq!(minus_three * minus_two, minus_two * minus_three);\n        assert_eq!(six, minus_two * minus_three);\n    }",
    "display_name": "multiply",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/fiat_p521_loose_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/&AffinePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/affine/impl/AffinePoint/to_decaf"
    ],
    "body": "    fn mul(self, scalar: &Scalar) -> DecafPoint {\n        self.to_decaf() * scalar\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/SubAssign>/sub_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &ProjectivePoint<C>) {\n        *self = ProjectivePoint::sub(self, rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/negate",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn negate(&self) -> Self {\n        EdwardsPoint {\n            X: -self.X,\n            Y: self.Y,\n            Z: self.Z,\n            T: -self.T,\n        }\n    }",
    "display_name": "negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/torque",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn torque(&self) -> Self {\n        EdwardsPoint {\n            X: -self.X,\n            Y: -self.Y,\n            Z: self.Z,\n            T: self.T,\n        }\n    }",
    "display_name": "torque",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn sqrt(&self) -> CtOption<Self> {\n        // Note: `pow_vartime` is constant-time with respect to `self`\n        let w = self.pow_vartime([\n            0x777fa4bd19a06c82,\n            0xfd755db9cd5e9140,\n            0xffffffffffffffff,\n            0x1ffffffffffffff,\n        ]);\n\n        let mut v = Self::S;\n        let mut x = *self * w;\n        let mut b = x * w;\n        let mut z = Self::ROOT_OF_UNITY;\n\n        for max_v in (1..=Self::S).rev() {\n            let mut k = 1;\n            let mut tmp = b.square();\n            let mut j_less_than_v = Choice::from(1);\n\n            for j in 2..max_v {\n                let tmp_is_one = tmp.ct_eq(&Self::ONE);\n                let squared = Self::conditional_select(&tmp, &z, tmp_is_one).square();\n                tmp = Self::conditional_select(&squared, &tmp, tmp_is_one);\n                let new_z = Self::conditional_select(&z, &squared, tmp_is_one);\n                j_less_than_v &= !j.ct_eq(&v);\n                k = u32::conditional_select(&j, &k, tmp_is_one);\n                z = Self::conditional_select(&z, &new_z, j_less_than_v);\n            }\n\n            let result = x * z;\n            x = Self::conditional_select(&result, &x, b.ct_eq(&Self::ONE));\n            z = z.square();\n            b *= z;\n            v = k;\n        }\n\n        CtOption::new(x, x.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre decode_pkcs8_public_key_from_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/to_bytes"
    ],
    "body": "fn decode_pkcs8_public_key_from_der() {\n    let public_key = PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    let expected_point = hex!(\n        \"\\\n    B2 D8 99 74 6C EB 2D 38 90 1C EF 42 46 39 EA 30 FD A2 72 0B E7 C1 BA 3F 04 BC 31 5D F2 41 2B A9 \\\n    38 0E A8 EC E0 F7 A7 BA 7E A9 65 2D BA C5 3B 82 7B D2 C2 FB 59 84 86 98 DE 2E A6 75 96 05 EB 96\\\n    \"\n    );\n    assert_eq!(public_key.to_bytes().as_ref(), &expected_point[..]);\n}",
    "display_name": "decode_pkcs8_public_key_from_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/tests/pkcs8.rs",
    "relative_path": "bign256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/to_edwards",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_edwards(&self, _sign: u8) -> Option<EdwardsPoint> {\n        // We use the 4-isogeny to map to the Ed448.\n        // This is different to Curve25519, where we use a birational map.\n        todo!()\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: &DecafPoint) {\n        *self = *self + other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64"
    ],
    "body": "pub const fn fiat_bign256_opp(\n    out1: &mut fiat_bign256_montgomery_domain_field_element,\n    arg1: &fiat_bign256_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, (x9 & 0xffffffffffffff43));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x12, &mut x13, x11, x3, x9);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x16, &mut x17, x15, x7, x9);\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_bign256_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_negate<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"negate\", |b| b.iter(|| -x));\n}",
    "display_name": "bench_scalar_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn add(&self, rhs: &Self) -> Self {\n        Self(self.0.add_mod(&rhs.0, &ORDER))\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p192_u1,\n    arg1: fiat_p192_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_p192_u1 = ((x1 >> 64) as fiat_p192_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p192_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/batch_invert_array",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert"
    ],
    "body": "    fn batch_invert_array() {\n        let k: FieldElement = FieldElement::random(&mut OsRng.unwrap_mut());\n        let l: FieldElement = FieldElement::random(&mut OsRng.unwrap_mut());\n\n        let expected = [k.invert().unwrap(), l.invert().unwrap()];\n        assert_eq!(\n            <FieldElement as BatchInvert<_>>::batch_invert([k, l]).unwrap(),\n            expected\n        );\n    }",
    "display_name": "batch_invert_array",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_cmovznz_u64(\n    out1: &mut u64,\n    arg1: fiat_p521_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: fiat_p521_scalar_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_p521_scalar_i2) - (x1 as fiat_p521_scalar_i2))\n        as fiat_p521_scalar_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_p521_scalar_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_from_bytes(out1: &mut [u64; 4], arg1: &[u8; 32]) {\n    let x1: u64 = (((arg1[31]) as u64) << 56);\n    let x2: u64 = (((arg1[30]) as u64) << 48);\n    let x3: u64 = (((arg1[29]) as u64) << 40);\n    let x4: u64 = (((arg1[28]) as u64) << 32);\n    let x5: u64 = (((arg1[27]) as u64) << 24);\n    let x6: u64 = (((arg1[26]) as u64) << 16);\n    let x7: u64 = (((arg1[25]) as u64) << 8);\n    let x8: u8 = (arg1[24]);\n    let x9: u64 = (((arg1[23]) as u64) << 56);\n    let x10: u64 = (((arg1[22]) as u64) << 48);\n    let x11: u64 = (((arg1[21]) as u64) << 40);\n    let x12: u64 = (((arg1[20]) as u64) << 32);\n    let x13: u64 = (((arg1[19]) as u64) << 24);\n    let x14: u64 = (((arg1[18]) as u64) << 16);\n    let x15: u64 = (((arg1[17]) as u64) << 8);\n    let x16: u8 = (arg1[16]);\n    let x17: u64 = (((arg1[15]) as u64) << 56);\n    let x18: u64 = (((arg1[14]) as u64) << 48);\n    let x19: u64 = (((arg1[13]) as u64) << 40);\n    let x20: u64 = (((arg1[12]) as u64) << 32);\n    let x21: u64 = (((arg1[11]) as u64) << 24);\n    let x22: u64 = (((arg1[10]) as u64) << 16);\n    let x23: u64 = (((arg1[9]) as u64) << 8);\n    let x24: u8 = (arg1[8]);\n    let x25: u64 = (((arg1[7]) as u64) << 56);\n    let x26: u64 = (((arg1[6]) as u64) << 48);\n    let x27: u64 = (((arg1[5]) as u64) << 40);\n    let x28: u64 = (((arg1[4]) as u64) << 32);\n    let x29: u64 = (((arg1[3]) as u64) << 24);\n    let x30: u64 = (((arg1[2]) as u64) << 16);\n    let x31: u64 = (((arg1[1]) as u64) << 8);\n    let x32: u8 = (arg1[0]);\n    let x33: u64 = (x31 + (x32 as u64));\n    let x34: u64 = (x30 + x33);\n    let x35: u64 = (x29 + x34);\n    let x36: u64 = (x28 + x35);\n    let x37: u64 = (x27 + x36);\n    let x38: u64 = (x26 + x37);\n    let x39: u64 = (x25 + x38);\n    let x40: u64 = (x23 + (x24 as u64));\n    let x41: u64 = (x22 + x40);\n    let x42: u64 = (x21 + x41);\n    let x43: u64 = (x20 + x42);\n    let x44: u64 = (x19 + x43);\n    let x45: u64 = (x18 + x44);\n    let x46: u64 = (x17 + x45);\n    let x47: u64 = (x15 + (x16 as u64));\n    let x48: u64 = (x14 + x47);\n    let x49: u64 = (x13 + x48);\n    let x50: u64 = (x12 + x49);\n    let x51: u64 = (x11 + x50);\n    let x52: u64 = (x10 + x51);\n    let x53: u64 = (x9 + x52);\n    let x54: u64 = (x7 + (x8 as u64));\n    let x55: u64 = (x6 + x54);\n    let x56: u64 = (x5 + x55);\n    let x57: u64 = (x4 + x56);\n    let x58: u64 = (x3 + x57);\n    let x59: u64 = (x2 + x58);\n    let x60: u64 = (x1 + x59);\n    out1[0] = x39;\n    out1[1] = x46;\n    out1[2] = x53;\n    out1[3] = x60;\n}",
    "display_name": "fiat_bign256_scalar_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre test_x509",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_x509() {\n    fn dummy_cert_builder<S, Signature>(_signer: &S)\n    where\n        S: Signer<Signature>,\n        S: Keypair + DynSignatureAlgorithmIdentifier,\n        S::VerifyingKey: EncodePublicKey,\n        Signature: SignatureBitStringEncoding,\n    {\n        // we just want to check the trait bounds here\n    }\n\n    let secret_key = PKCS8_PRIVATE_KEY_PEM.parse::<sm2::SecretKey>().unwrap();\n    const IDENTITY: &str = \"example@rustcrypto.org\";\n    let signing_key = SigningKey::new(IDENTITY, &secret_key).unwrap();\n    let _signature = dummy_cert_builder::<_, Signature>(&signing_key);\n}",
    "display_name": "test_x509",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/elliptic_curve::bigint::Uint/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: Scalar) -> Self {\n        scalar.0\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/UpperHex/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        write!(\n            f,\n            \"{{ X: {:X}, Y: {:X}, Z: {:X}, T: {:X} }}\",\n            self.0.X, self.0.Y, self.0.Z, self.0.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/AffineCoordinates/x_is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn x_is_odd(&self) -> Choice {\n        self.x.normalize().is_odd()\n    }",
    "display_name": "x_is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsMinusThree/PointArithmetic/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(lhs: &ProjectivePoint<C>, rhs: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        debug_assert_eq!(\n            C::EQUATION_A,\n            -C::FieldElement::from(3),\n            \"this implementation is only valid for C::EQUATION_A = -3\"\n        );\n\n        let xx = lhs.x * rhs.x; // 1\n        let yy = lhs.y * rhs.y; // 2\n        let zz = lhs.z * rhs.z; // 3\n        let xy_pairs = ((lhs.x + lhs.y) * (rhs.x + rhs.y)) - (xx + yy); // 4, 5, 6, 7, 8\n        let yz_pairs = ((lhs.y + lhs.z) * (rhs.y + rhs.z)) - (yy + zz); // 9, 10, 11, 12, 13\n        let xz_pairs = ((lhs.x + lhs.z) * (rhs.x + rhs.z)) - (xx + zz); // 14, 15, 16, 17, 18\n\n        let bzz_part = xz_pairs - (C::EQUATION_B * zz); // 19, 20\n        let bzz3_part = bzz_part.double() + bzz_part; // 21, 22\n        let yy_m_bzz3 = yy - bzz3_part; // 23\n        let yy_p_bzz3 = yy + bzz3_part; // 24\n\n        let zz3 = zz.double() + zz; // 26, 27\n        let bxz_part = (C::EQUATION_B * xz_pairs) - (zz3 + xx); // 25, 28, 29\n        let bxz3_part = bxz_part.double() + bxz_part; // 30, 31\n        let xx3_m_zz3 = xx.double() + xx - zz3; // 32, 33, 34\n\n        ProjectivePoint {\n            x: (yy_p_bzz3 * xy_pairs) - (yz_pairs * bxz3_part), // 35, 39, 40\n            y: (yy_p_bzz3 * yy_m_bzz3) + (xx3_m_zz3 * bxz3_part), // 36, 37, 38\n            z: (yy_m_bzz3 * yz_pairs) + (xy_pairs * xx3_m_zz3), // 41, 42, 43\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre decode_pkcs8_public_key_from_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_public_key_from_pem() {\n    let public_key = PKCS8_PUBLIC_KEY_PEM.parse::<sm2::PublicKey>().unwrap();\n\n    // Ensure key parses equivalently to DER\n    let der_key = sm2::PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    assert_eq!(public_key, der_key);\n}",
    "display_name": "decode_pkcs8_public_key_from_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre pke/xor",
    "statement_type": "function",
    "deps": [],
    "body": "fn xor(c2: &mut [u8], ha: &[u8], offset: usize, xor_len: usize) {\n    for i in 0..xor_len {\n        c2[offset + i] ^= ha[i];\n    }\n}",
    "display_name": "xor",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke.rs",
    "relative_path": "sm2/src/pke.rs",
    "file_name": "pke.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/fiat_p521_tight_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/neg_loose",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_opp"
    ],
    "body": "    pub const fn neg_loose(&self) -> LooseFieldElement {\n        let mut out = fiat_p521_loose_field_element([0; 9]);\n        fiat_p521_opp(&mut out, &self.0);\n        LooseFieldElement(out)\n    }",
    "display_name": "neg_loose",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64"
    ],
    "body": "pub const fn fiat_sm2_sub(\n    out1: &mut fiat_sm2_montgomery_domain_field_element,\n    arg1: &fiat_sm2_montgomery_domain_field_element,\n    arg2: &fiat_sm2_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, x9);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0xffffffff00000000));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x16, &mut x17, x15, x7, (x9 & 0xfffffffeffffffff));\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_sm2_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_basic_inversion",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/invert",
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_basic_inversion() {\n        // Test inversion from 2 to 100\n        for i in 1..=100u8 {\n            let x = Scalar::from(i);\n            let x_inv = x.invert();\n            assert_eq!(x_inv * x, Scalar::ONE)\n        }\n\n        // Inversion of zero is zero\n        let zero = Scalar::ZERO;\n        let expected_zero = zero.invert();\n        assert_eq!(expected_zero, zero)\n    }",
    "display_name": "test_basic_inversion",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "affine/impl/AffinePoint/is_identity",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_identity(&self) -> Choice {\n        Choice::from(self.infinity)\n    }",
    "display_name": "is_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/from_slice"
    ],
    "body": "    pub fn from_bytes(bytes: &FieldBytes) -> Result<Self> {\n        Self::from_slice(bytes)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/tests/uncompressed_round_trip",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    fn uncompressed_round_trip() {\n        let pubkey = EncodedPoint::from_bytes(UNCOMPRESSED_BASEPOINT).unwrap();\n        let res: EncodedPoint = AffinePoint::from_encoded_point(&pubkey)\n            .unwrap()\n            .to_encoded_point(false);\n\n        assert_eq!(res, pubkey);\n    }",
    "display_name": "uncompressed_round_trip",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Add>/add",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add(self, other: AffinePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::add_mixed(&self, &other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/From>/from"
    ],
    "body": "    fn from(public_key: PublicKey<C>) -> ProjectivePoint<C> {\n        AffinePoint::from(public_key).into()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(ProjectivePoint::IDENTITY, |a, b| a + b)\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from_uint_unchecked(uint: Self::Uint) -> Self {\n        Self::from_uint_unchecked(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes_mod_order_wide(input: &WideScalarBytes) -> Scalar {\n        // top multiplier = 2^896 mod ℓ\n        const TOP_MULTIPLIER: U448 = U448::from_be_hex(\n            \"3402a939f823b7292052bcb7e4d070af1a9cc14ba3c47c44ae17cf725ee4d8380d66de2388ea18597af32c4bc1b195d9e3539257049b9b60\",\n        );\n        let value = (\n            U448::from_le_slice(&input[..56]),\n            U448::from_le_slice(&input[56..112]),\n        );\n        let mut top = [0u8; 56];\n        top[..2].copy_from_slice(&input[112..]);\n        let top = U448::from_le_slice(&top).mul_mod(&TOP_MULTIPLIER, &NZ_ORDER);\n        let bottom = U448::rem_wide_vartime(value, &NZ_ORDER);\n        Self(bottom.add_mod(&top, &ORDER))\n    }",
    "display_name": "from_bytes_mod_order_wide",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn bench_point_mul<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let p = ProjectivePoint::GENERATOR;\n    let m = test_scalar_x();\n    let s = Scalar::from_repr(m.into()).unwrap();\n    group.bench_function(\"point-scalar mul\", |b| b.iter(|| p * s));\n}",
    "display_name": "bench_point_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/addition",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn addition(&self, rhs: &Self) -> Self {\n        Self(self.0.add_mod(&rhs.0, &ORDER))\n    }",
    "display_name": "addition",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/encode",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/double",
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/isogeny",
      "0.14.0_pre.1 field/element/impl/FieldElement/FromOkm/from_okm",
      "0.14.0_pre.1 field/element/impl/FieldElement/map_to_curve_elligator2"
    ],
    "body": "    pub fn encode<X>(msg: &[u8], dst: &[u8]) -> Self\n    where\n        X: ExpandMsg<U28>,\n    {\n        type RandomLen = U84;\n        let mut random_bytes = Array::<u8, RandomLen>::default();\n        let dst = [dst];\n        let mut expander = X::expand_message(\n            &[msg],\n            &dst,\n            core::num::NonZero::new(RandomLen::U16)\n                .expect(\"invariant violation: random is non zero length\"),\n        )\n        .expect(\"bad dst\");\n        expander.fill_bytes(&mut random_bytes);\n        let u0 = FieldElement::from_okm(&random_bytes);\n        let mut q0 = u0.map_to_curve_elligator2();\n        q0 = q0.isogeny();\n\n        q0.to_edwards().double().double()\n    }",
    "display_name": "encode",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre distid/hash_z",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
      "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "pub(crate) fn hash_z(distid: &DistId, public_key: &impl AsRef<AffinePoint>) -> Result<Hash> {\n    let entla: u16 = distid\n        .len()\n        .checked_mul(8)\n        .and_then(|l| l.try_into().ok())\n        .ok_or(Error)?;\n\n    let mut sm3 = Sm3::new();\n    sm3.update(entla.to_be_bytes());\n    sm3.update(distid);\n    sm3.update(Sm2::EQUATION_A.to_bytes());\n    sm3.update(Sm2::EQUATION_B.to_bytes());\n    sm3.update(Sm2::GENERATOR.0.to_bytes());\n    sm3.update(Sm2::GENERATOR.1.to_bytes());\n\n    match public_key.as_ref().to_encoded_point(false).coordinates() {\n        sec1::Coordinates::Uncompressed { x, y } => {\n            sm3.update(x);\n            sm3.update(y);\n            Ok(sm3.finalize())\n        }\n        _ => Err(Error),\n    }\n}",
    "display_name": "hash_z",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/distid.rs",
    "relative_path": "sm2/src/distid.rs",
    "file_name": "distid.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(public_key: PublicKey) -> AffinePoint {\n        *public_key.as_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/AffineCoordinates/x_is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative"
    ],
    "body": "    fn x_is_odd(&self) -> Choice {\n        self.x.is_negative()\n    }",
    "display_name": "x_is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/is_high",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/IsHigh/is_high",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from"
    ],
    "body": "    fn is_high() {\n        // 0 is not high\n        let high: bool = Scalar::ZERO.is_high().into();\n        assert!(!high);\n\n        // 1 is not high\n        let one = 1.to_biguint().unwrap();\n        let high: bool = Scalar::from(&one).is_high().into();\n        assert!(!high);\n\n        let m = Scalar::modulus_as_biguint();\n        let m_by_2 = &m >> 1;\n\n        // M / 2 is not high\n        let high: bool = Scalar::from(&m_by_2).is_high().into();\n        assert!(!high);\n\n        // M / 2 + 1 is high\n        let high: bool = Scalar::from(&m_by_2 + &one).is_high().into();\n        assert!(high);\n\n        // MODULUS - 1 is high\n        let high: bool = Scalar::from(&m - &one).is_high().into();\n        assert!(high);\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_selectznz(\n    out1: &mut [u64; 9],\n    arg1: fiat_p521_scalar_u1,\n    arg2: &[u64; 9],\n    arg3: &[u64; 9],\n) {\n    let mut x1: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    let mut x5: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x5, arg1, (arg2[4]), (arg3[4]));\n    let mut x6: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x6, arg1, (arg2[5]), (arg3[5]));\n    let mut x7: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x7, arg1, (arg2[6]), (arg3[6]));\n    let mut x8: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x8, arg1, (arg2[7]), (arg3[7]));\n    let mut x9: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x9, arg1, (arg2[8]), (arg3[8]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n    out1[4] = x5;\n    out1[5] = x6;\n    out1[6] = x7;\n    out1[7] = x8;\n    out1[8] = x9;\n}",
    "display_name": "fiat_p521_scalar_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/BatchNormalize/batch_normalize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/batch_normalize_generic"
    ],
    "body": "    fn batch_normalize(points: &[Self]) -> Vec<<Self as CurveGroup>::AffineRepr> {\n        let zs = vec![FieldElement::ONE; points.len()];\n        let mut affine_points = vec![AffinePoint::IDENTITY; points.len()];\n        batch_normalize_generic(points, zs, &mut affine_points);\n        affine_points\n    }",
    "display_name": "batch_normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/EncodePrivateKey/to_pkcs8_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/to_bytes"
    ],
    "body": "    fn to_pkcs8_der(&self) -> pkcs8::Result<SecretDocument> {\n        let algorithm_identifier = pkcs8::AlgorithmIdentifierRef {\n            oid: ALGORITHM_OID,\n            parameters: Some((&BignP256::OID).into()),\n        };\n\n        let ec_private_key = self.to_bytes();\n        let pkcs8_key = pkcs8::PrivateKeyInfoRef::new(\n            algorithm_identifier,\n            OctetStringRef::new(&ec_private_key)?,\n        );\n        Ok(SecretDocument::encode_msg(&pkcs8_key)?)\n    }",
    "display_name": "to_pkcs8_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/pow2k"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        /*\n        Given that p is congruent to 3 mod 4, we can compute the square root of\n        a mod p as the (p+1)/4'th power of a.\n\n        As (p+1)/4 is an even number, it will have the same result for a and for\n        (-a). Only one of these two numbers actually has a square root however,\n        so we test at the end by squaring and comparing to the input.\n        Also because (p+1)/4 is an even number, the computed square root is\n        itself always a square (a ** ((p+1)/4) is the square of a ** ((p+1)/8)).\n        */\n\n        // The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths in\n        // { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n        // 1, [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n\n        let x2 = self.pow2k(1).mul(self);\n        let x3 = x2.pow2k(1).mul(self);\n        let x6 = x3.pow2k(3).mul(&x3);\n        let x9 = x6.pow2k(3).mul(&x3);\n        let x11 = x9.pow2k(2).mul(&x2);\n        let x22 = x11.pow2k(11).mul(&x11);\n        let x44 = x22.pow2k(22).mul(&x22);\n        let x88 = x44.pow2k(44).mul(&x44);\n        let x176 = x88.pow2k(88).mul(&x88);\n        let x220 = x176.pow2k(44).mul(&x44);\n        let x223 = x220.pow2k(3).mul(&x3);\n\n        // The final result is then assembled using a sliding window over the blocks.\n        let res = x223.pow2k(23).mul(&x22).pow2k(6).mul(&x2).pow2k(2);\n\n        let is_root = (res.mul(&res).negate(1) + self).normalizes_to_zero();\n\n        // Only return Some if it's the square root.\n        CtOption::new(res, is_root)\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/test/test_invalid_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/decompress"
    ],
    "body": "    fn test_invalid_point() {\n        // Test that the identity point is not on the curve\n        let all_ones = CompressedDecaf([1u8; 56]);\n        assert_eq!(all_ones.decompress().is_none().unwrap_u8(), 1u8);\n        let all_twos = CompressedDecaf([2u8; 56]);\n        assert_eq!(all_twos.decompress().is_none().unwrap_u8(), 1u8);\n    }",
    "display_name": "test_invalid_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn shr_vartime(&self, shift: u32) -> Scalar {\n        Self(self.0.wrapping_shr_vartime(shift))\n    }",
    "display_name": "shr_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::co",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve"
    ],
    "body": "    fn from(secret_scalar: &SecretKey) -> Self {\n        Self {\n            secret: ExpandedSecretKey::from(secret_scalar),\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_bign256_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/EphemeralSecret/public_key",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/from_secret_scalar"
    ],
    "body": "    pub fn public_key(&self) -> PublicKey {\n        PublicKey::from_secret_scalar(&self.scalar)\n    }",
    "display_name": "public_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsZero/PointArithmetic/add_mixed",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/is_identity"
    ],
    "body": "    fn add_mixed(lhs: &ProjectivePoint<C>, rhs: &AffinePoint<C>) -> ProjectivePoint<C> {\n        debug_assert_eq!(\n            C::EQUATION_A,\n            C::FieldElement::ZERO,\n            \"this implementation is only valid for C::EQUATION_A = 0\"\n        );\n\n        let b3 = C::EQUATION_B * C::FieldElement::from(3);\n\n        let t0 = lhs.x * rhs.x; // 1\n        let t1 = lhs.y * rhs.y; // 2\n        let t3 = rhs.x + rhs.y; // 3\n        let t4 = lhs.x + lhs.y; // 4\n        let t3 = t3 * t4; // 5\n        let t4 = t0 + t1; // 6\n        let t3 = t3 - t4; // 7\n        let t4 = rhs.y * lhs.z; // 8\n        let t4 = t4 + lhs.y; // 9\n        let y3 = rhs.x * lhs.z; // 10\n        let y3 = y3 + lhs.x; // 11\n        let x3 = t0.double(); // 12\n        let t0 = x3 + t0; // 13\n        let t2 = b3 * lhs.z; // 14\n        let z3 = t1 + t2; // 15\n        let t1 = t1 - t2; // 16\n        let y3 = b3 * y3; // 17\n        let x3 = t4 * y3; // 18\n        let t2 = t3 * t1; // 19\n        let x3 = t2 - x3; // 20\n        let y3 = y3 * t0; // 21\n        let t1 = t1 * z3; // 22\n        let y3 = t1 + y3; // 23\n        let t0 = t0 * t3; // 24\n        let z3 = z3 * t4; // 25\n        let z3 = z3 + t0; // 26\n\n        let mut ret = ProjectivePoint {\n            x: x3,\n            y: y3,\n            z: z3,\n        };\n        ret.conditional_assign(lhs, rhs.is_identity());\n        ret\n    }",
    "display_name": "add_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/from_slice",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<Self> {\n        SignatureBytes::try_from(bytes)\n            .map_err(|_| Error::new())?\n            .try_into()\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_to_bytes(out1: &mut [u8; 24], arg1: &[u64; 3]) {\n    let x1: u64 = (arg1[2]);\n    let x2: u64 = (arg1[1]);\n    let x3: u64 = (arg1[0]);\n    let x4: u8 = ((x3 & (0xff as u64)) as u8);\n    let x5: u64 = (x3 >> 8);\n    let x6: u8 = ((x5 & (0xff as u64)) as u8);\n    let x7: u64 = (x5 >> 8);\n    let x8: u8 = ((x7 & (0xff as u64)) as u8);\n    let x9: u64 = (x7 >> 8);\n    let x10: u8 = ((x9 & (0xff as u64)) as u8);\n    let x11: u64 = (x9 >> 8);\n    let x12: u8 = ((x11 & (0xff as u64)) as u8);\n    let x13: u64 = (x11 >> 8);\n    let x14: u8 = ((x13 & (0xff as u64)) as u8);\n    let x15: u64 = (x13 >> 8);\n    let x16: u8 = ((x15 & (0xff as u64)) as u8);\n    let x17: u8 = ((x15 >> 8) as u8);\n    let x18: u8 = ((x2 & (0xff as u64)) as u8);\n    let x19: u64 = (x2 >> 8);\n    let x20: u8 = ((x19 & (0xff as u64)) as u8);\n    let x21: u64 = (x19 >> 8);\n    let x22: u8 = ((x21 & (0xff as u64)) as u8);\n    let x23: u64 = (x21 >> 8);\n    let x24: u8 = ((x23 & (0xff as u64)) as u8);\n    let x25: u64 = (x23 >> 8);\n    let x26: u8 = ((x25 & (0xff as u64)) as u8);\n    let x27: u64 = (x25 >> 8);\n    let x28: u8 = ((x27 & (0xff as u64)) as u8);\n    let x29: u64 = (x27 >> 8);\n    let x30: u8 = ((x29 & (0xff as u64)) as u8);\n    let x31: u8 = ((x29 >> 8) as u8);\n    let x32: u8 = ((x1 & (0xff as u64)) as u8);\n    let x33: u64 = (x1 >> 8);\n    let x34: u8 = ((x33 & (0xff as u64)) as u8);\n    let x35: u64 = (x33 >> 8);\n    let x36: u8 = ((x35 & (0xff as u64)) as u8);\n    let x37: u64 = (x35 >> 8);\n    let x38: u8 = ((x37 & (0xff as u64)) as u8);\n    let x39: u64 = (x37 >> 8);\n    let x40: u8 = ((x39 & (0xff as u64)) as u8);\n    let x41: u64 = (x39 >> 8);\n    let x42: u8 = ((x41 & (0xff as u64)) as u8);\n    let x43: u64 = (x41 >> 8);\n    let x44: u8 = ((x43 & (0xff as u64)) as u8);\n    let x45: u8 = ((x43 >> 8) as u8);\n    out1[0] = x4;\n    out1[1] = x6;\n    out1[2] = x8;\n    out1[3] = x10;\n    out1[4] = x12;\n    out1[5] = x14;\n    out1[6] = x16;\n    out1[7] = x17;\n    out1[8] = x18;\n    out1[9] = x20;\n    out1[10] = x22;\n    out1[11] = x24;\n    out1[12] = x26;\n    out1[13] = x28;\n    out1[14] = x30;\n    out1[15] = x31;\n    out1[16] = x32;\n    out1[17] = x34;\n    out1[18] = x36;\n    out1[19] = x38;\n    out1[20] = x40;\n    out1[21] = x42;\n    out1[22] = x44;\n    out1[23] = x45;\n}",
    "display_name": "fiat_p192_scalar_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: &Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(value.as_slice())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/test_decompress_compress",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress"
    ],
    "body": "    fn test_decompress_compress() {\n        let bytes = hex!(\n            \"649c6a53b109897d962d033f23d01fd4e1053dddf3746d2ddce9bd66aea38ccfc3df061df03ca399eb806312ab3037c0c31523142956ada780\"\n        );\n        let compressed = CompressedEdwardsY(bytes);\n        let decompressed = compressed.decompress().unwrap();\n\n        let recompressed = decompressed.compress();\n\n        assert_eq!(bytes, recompressed.0);\n    }",
    "display_name": "test_decompress_compress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub fn is_zero(&self) -> Choice {\n        self.ct_eq(&Self::ZERO)\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/to_extended",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square"
    ],
    "body": "    pub fn to_extended(self) -> ExtendedPoint {\n        let A = self.Y_plus_X - self.Y_minus_X;\n        let B = self.Y_plus_X + self.Y_minus_X;\n        ExtendedPoint {\n            X: self.Z * A,\n            Y: self.Z * B,\n            Z: self.Z.square(),\n            T: B * A,\n        }\n    }",
    "display_name": "to_extended",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/projective.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/from_encoded_point",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    pub fn from_encoded_point(point: EncodedPoint) -> Result<Self, Error> {\n        let affine = AffinePoint::<BignP256>::from_encoded_point(&point);\n        if affine.is_none().into() {\n            Err(Error)\n        } else {\n            Ok(Self {\n                point: affine.unwrap(),\n            })\n        }\n    }",
    "display_name": "from_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_from_bytes(out1: &mut [u64; 4], arg1: &[u8; 28]) {\n    let x1: u64 = (((arg1[27]) as u64) << 24);\n    let x2: u64 = (((arg1[26]) as u64) << 16);\n    let x3: u64 = (((arg1[25]) as u64) << 8);\n    let x4: u8 = (arg1[24]);\n    let x5: u64 = (((arg1[23]) as u64) << 56);\n    let x6: u64 = (((arg1[22]) as u64) << 48);\n    let x7: u64 = (((arg1[21]) as u64) << 40);\n    let x8: u64 = (((arg1[20]) as u64) << 32);\n    let x9: u64 = (((arg1[19]) as u64) << 24);\n    let x10: u64 = (((arg1[18]) as u64) << 16);\n    let x11: u64 = (((arg1[17]) as u64) << 8);\n    let x12: u8 = (arg1[16]);\n    let x13: u64 = (((arg1[15]) as u64) << 56);\n    let x14: u64 = (((arg1[14]) as u64) << 48);\n    let x15: u64 = (((arg1[13]) as u64) << 40);\n    let x16: u64 = (((arg1[12]) as u64) << 32);\n    let x17: u64 = (((arg1[11]) as u64) << 24);\n    let x18: u64 = (((arg1[10]) as u64) << 16);\n    let x19: u64 = (((arg1[9]) as u64) << 8);\n    let x20: u8 = (arg1[8]);\n    let x21: u64 = (((arg1[7]) as u64) << 56);\n    let x22: u64 = (((arg1[6]) as u64) << 48);\n    let x23: u64 = (((arg1[5]) as u64) << 40);\n    let x24: u64 = (((arg1[4]) as u64) << 32);\n    let x25: u64 = (((arg1[3]) as u64) << 24);\n    let x26: u64 = (((arg1[2]) as u64) << 16);\n    let x27: u64 = (((arg1[1]) as u64) << 8);\n    let x28: u8 = (arg1[0]);\n    let x29: u64 = (x27 + (x28 as u64));\n    let x30: u64 = (x26 + x29);\n    let x31: u64 = (x25 + x30);\n    let x32: u64 = (x24 + x31);\n    let x33: u64 = (x23 + x32);\n    let x34: u64 = (x22 + x33);\n    let x35: u64 = (x21 + x34);\n    let x36: u64 = (x19 + (x20 as u64));\n    let x37: u64 = (x18 + x36);\n    let x38: u64 = (x17 + x37);\n    let x39: u64 = (x16 + x38);\n    let x40: u64 = (x15 + x39);\n    let x41: u64 = (x14 + x40);\n    let x42: u64 = (x13 + x41);\n    let x43: u64 = (x11 + (x12 as u64));\n    let x44: u64 = (x10 + x43);\n    let x45: u64 = (x9 + x44);\n    let x46: u64 = (x8 + x45);\n    let x47: u64 = (x7 + x46);\n    let x48: u64 = (x6 + x47);\n    let x49: u64 = (x5 + x48);\n    let x50: u64 = (x3 + (x4 as u64));\n    let x51: u64 = (x2 + x50);\n    let x52: u64 = (x1 + x51);\n    out1[0] = x35;\n    out1[1] = x42;\n    out1[2] = x49;\n    out1[3] = x52;\n}",
    "display_name": "fiat_p224_scalar_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64"
    ],
    "body": "pub const fn fiat_sm2_opp(\n    out1: &mut fiat_sm2_montgomery_domain_field_element,\n    arg1: &fiat_sm2_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, x9);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0xffffffff00000000));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x16, &mut x17, x15, x7, (x9 & 0xfffffffeffffffff));\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_sm2_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub(self, other: Scalar) -> Scalar {\n        Scalar::sub(&self, &other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_opp(\n    out1: &mut fiat_bign256_scalar_montgomery_domain_field_element,\n    arg1: &fiat_bign256_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, (x9 & 0x7e5abf99263d6607));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0xd95c8ed60dfb4dfc));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, x9);\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_bign256_scalar_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/ToEncodedPoint/to_encoded_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn to_encoded_point(&self, compress: bool) -> EncodedPoint {\n        self.to_affine().to_encoded_point(compress)\n    }",
    "display_name": "to_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: &ScalarPrimitive<Secp256k1>) -> Scalar {\n        Scalar(*scalar.as_uint())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_y",
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_sub<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"sub\", |b| b.iter(|| x - y));\n}",
    "display_name": "bench_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64"
    ],
    "body": "pub const fn fiat_sm2_from_montgomery(\n    out1: &mut fiat_sm2_non_montgomery_domain_field_element,\n    arg1: &fiat_sm2_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x2, &mut x3, x1, 0xfffffffeffffffff);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x4, &mut x5, x1, 0xffffffffffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x6, &mut x7, x1, 0xffffffff00000000);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x8, &mut x9, x1, 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x10, &mut x11, 0x0, x9, x6);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x12, &mut x13, x11, x7, x4);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x14, &mut x15, x13, x5, x2);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x16, &mut x17, 0x0, x1, x8);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), x10);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), x12);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x22, &mut x23, x21, (0x0 as u64), x14);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x24, &mut x25, 0x0, x18, (arg1[1]));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x26, &mut x27, x25, x20, (0x0 as u64));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x28, &mut x29, x27, x22, (0x0 as u64));\n    let mut x30: u64 = 0;\n    let mut x31: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x30, &mut x31, x24, 0xfffffffeffffffff);\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x32, &mut x33, x24, 0xffffffffffffffff);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x34, &mut x35, x24, 0xffffffff00000000);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x36, &mut x37, x24, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x38, &mut x39, 0x0, x37, x34);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x40, &mut x41, x39, x35, x32);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x42, &mut x43, x41, x33, x30);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x44, &mut x45, 0x0, x24, x36);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x46, &mut x47, x45, x26, x38);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x48, &mut x49, x47, x28, x40);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(\n        &mut x50,\n        &mut x51,\n        x49,\n        ((x29 as u64) + ((x23 as u64) + ((x15 as u64) + x3))),\n        x42,\n    );\n    let mut x52: u64 = 0;\n    let mut x53: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x52, &mut x53, 0x0, x46, (arg1[2]));\n    let mut x54: u64 = 0;\n    let mut x55: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x54, &mut x55, x53, x48, (0x0 as u64));\n    let mut x56: u64 = 0;\n    let mut x57: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x56, &mut x57, x55, x50, (0x0 as u64));\n    let mut x58: u64 = 0;\n    let mut x59: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x58, &mut x59, x52, 0xfffffffeffffffff);\n    let mut x60: u64 = 0;\n    let mut x61: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x60, &mut x61, x52, 0xffffffffffffffff);\n    let mut x62: u64 = 0;\n    let mut x63: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x62, &mut x63, x52, 0xffffffff00000000);\n    let mut x64: u64 = 0;\n    let mut x65: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x64, &mut x65, x52, 0xffffffffffffffff);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x66, &mut x67, 0x0, x65, x62);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x68, &mut x69, x67, x63, x60);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x70, &mut x71, x69, x61, x58);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x72, &mut x73, 0x0, x52, x64);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x74, &mut x75, x73, x54, x66);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x76, &mut x77, x75, x56, x68);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(\n        &mut x78,\n        &mut x79,\n        x77,\n        ((x57 as u64) + ((x51 as u64) + ((x43 as u64) + x31))),\n        x70,\n    );\n    let mut x80: u64 = 0;\n    let mut x81: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x80, &mut x81, 0x0, x74, (arg1[3]));\n    let mut x82: u64 = 0;\n    let mut x83: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x82, &mut x83, x81, x76, (0x0 as u64));\n    let mut x84: u64 = 0;\n    let mut x85: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x84, &mut x85, x83, x78, (0x0 as u64));\n    let mut x86: u64 = 0;\n    let mut x87: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x86, &mut x87, x80, 0xfffffffeffffffff);\n    let mut x88: u64 = 0;\n    let mut x89: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x88, &mut x89, x80, 0xffffffffffffffff);\n    let mut x90: u64 = 0;\n    let mut x91: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x90, &mut x91, x80, 0xffffffff00000000);\n    let mut x92: u64 = 0;\n    let mut x93: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x92, &mut x93, x80, 0xffffffffffffffff);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x94, &mut x95, 0x0, x93, x90);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x96, &mut x97, x95, x91, x88);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x98, &mut x99, x97, x89, x86);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x100, &mut x101, 0x0, x80, x92);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x102, &mut x103, x101, x82, x94);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x104, &mut x105, x103, x84, x96);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(\n        &mut x106,\n        &mut x107,\n        x105,\n        ((x85 as u64) + ((x79 as u64) + ((x71 as u64) + x59))),\n        x98,\n    );\n    let x108: u64 = ((x107 as u64) + ((x99 as u64) + x87));\n    let mut x109: u64 = 0;\n    let mut x110: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x109, &mut x110, 0x0, x102, 0xffffffffffffffff);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x111, &mut x112, x110, x104, 0xffffffff00000000);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x113, &mut x114, x112, x106, 0xffffffffffffffff);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x115, &mut x116, x114, x108, 0xfffffffeffffffff);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x117, &mut x118, x116, (0x0 as u64), (0x0 as u64));\n    let mut x119: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x119, x118, x109, x102);\n    let mut x120: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x120, x118, x111, x104);\n    let mut x121: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x121, x118, x113, x106);\n    let mut x122: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x122, x118, x115, x108);\n    out1[0] = x119;\n    out1[1] = x120;\n    out1[2] = x121;\n    out1[3] = x122;\n}",
    "display_name": "fiat_sm2_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        self.to_be_byte_array()\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/lib.rs",
    "relative_path": "k256/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_sm2_u1,\n    arg1: fiat_sm2_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_sm2_u1 = ((x1 >> 64) as fiat_sm2_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_sm2_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/mul_single",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn mul_single(&self, rhs: u32) -> Self {\n        let rhs_u64 = rhs as u64;\n        Self([\n            self.0[0] * rhs_u64,\n            self.0[1] * rhs_u64,\n            self.0[2] * rhs_u64,\n            self.0[3] * rhs_u64,\n            self.0[4] * rhs_u64,\n        ])\n    }",
    "display_name": "mul_single",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/mul"
    ],
    "body": "    fn mul(self, other: &Scalar) -> Scalar {\n        Scalar::mul(&self, other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_mulx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_to_montgomery(\n    out1: &mut fiat_p384_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p384_scalar_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[0]);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x7, &mut x8, x6, 0xc84ee012b39bf21);\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x9, &mut x10, x6, 0x3fb05b7a28266895);\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x11, &mut x12, x6, 0xd40d49174aab1cc5);\n    let mut x13: u64 = 0;\n    let mut x14: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x13, &mut x14, x6, 0xbc3e483afcb82947);\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x15, &mut x16, x6, 0xff3d81e5df1aa419);\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x17, &mut x18, x6, 0x2d319b2419b409a9);\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x19, &mut x20, 0x0, x18, x15);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x21, &mut x22, x20, x16, x13);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x23, &mut x24, x22, x14, x11);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x25, &mut x26, x24, x12, x9);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x27, &mut x28, x26, x10, x7);\n    let mut x29: u64 = 0;\n    let mut x30: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x29, &mut x30, x17, 0x6ed46089e88fdc45);\n    let mut x31: u64 = 0;\n    let mut x32: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x31, &mut x32, x29, 0xffffffffffffffff);\n    let mut x33: u64 = 0;\n    let mut x34: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x33, &mut x34, x29, 0xffffffffffffffff);\n    let mut x35: u64 = 0;\n    let mut x36: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x35, &mut x36, x29, 0xffffffffffffffff);\n    let mut x37: u64 = 0;\n    let mut x38: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x37, &mut x38, x29, 0xc7634d81f4372ddf);\n    let mut x39: u64 = 0;\n    let mut x40: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x39, &mut x40, x29, 0x581a0db248b0a77a);\n    let mut x41: u64 = 0;\n    let mut x42: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x41, &mut x42, x29, 0xecec196accc52973);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x43, &mut x44, 0x0, x42, x39);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x45, &mut x46, x44, x40, x37);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x47, &mut x48, x46, x38, x35);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x49, &mut x50, x48, x36, x33);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x51, &mut x52, x50, x34, x31);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x53, &mut x54, 0x0, x17, x41);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x55, &mut x56, x54, x19, x43);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x21, x45);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x23, x47);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x61, &mut x62, x60, x25, x49);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x63, &mut x64, x62, x27, x51);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x65,\n        &mut x66,\n        x64,\n        ((x28 as u64) + x8),\n        ((x52 as u64) + x32),\n    );\n    let mut x67: u64 = 0;\n    let mut x68: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x67, &mut x68, x1, 0xc84ee012b39bf21);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x69, &mut x70, x1, 0x3fb05b7a28266895);\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x71, &mut x72, x1, 0xd40d49174aab1cc5);\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x73, &mut x74, x1, 0xbc3e483afcb82947);\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x75, &mut x76, x1, 0xff3d81e5df1aa419);\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x77, &mut x78, x1, 0x2d319b2419b409a9);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x79, &mut x80, 0x0, x78, x75);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x81, &mut x82, x80, x76, x73);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x83, &mut x84, x82, x74, x71);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x85, &mut x86, x84, x72, x69);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x87, &mut x88, x86, x70, x67);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x89, &mut x90, 0x0, x55, x77);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x91, &mut x92, x90, x57, x79);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x93, &mut x94, x92, x59, x81);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x95, &mut x96, x94, x61, x83);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x97, &mut x98, x96, x63, x85);\n    let mut x99: u64 = 0;\n    let mut x100: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x99, &mut x100, x98, x65, x87);\n    let mut x101: u64 = 0;\n    let mut x102: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x101, &mut x102, x89, 0x6ed46089e88fdc45);\n    let mut x103: u64 = 0;\n    let mut x104: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x103, &mut x104, x101, 0xffffffffffffffff);\n    let mut x105: u64 = 0;\n    let mut x106: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x105, &mut x106, x101, 0xffffffffffffffff);\n    let mut x107: u64 = 0;\n    let mut x108: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x107, &mut x108, x101, 0xffffffffffffffff);\n    let mut x109: u64 = 0;\n    let mut x110: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x109, &mut x110, x101, 0xc7634d81f4372ddf);\n    let mut x111: u64 = 0;\n    let mut x112: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x111, &mut x112, x101, 0x581a0db248b0a77a);\n    let mut x113: u64 = 0;\n    let mut x114: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x113, &mut x114, x101, 0xecec196accc52973);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x115, &mut x116, 0x0, x114, x111);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x117, &mut x118, x116, x112, x109);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x119, &mut x120, x118, x110, x107);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x121, &mut x122, x120, x108, x105);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x123, &mut x124, x122, x106, x103);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x125, &mut x126, 0x0, x89, x113);\n    let mut x127: u64 = 0;\n    let mut x128: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x127, &mut x128, x126, x91, x115);\n    let mut x129: u64 = 0;\n    let mut x130: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x129, &mut x130, x128, x93, x117);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x131, &mut x132, x130, x95, x119);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x133, &mut x134, x132, x97, x121);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x135, &mut x136, x134, x99, x123);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x137,\n        &mut x138,\n        x136,\n        (((x100 as u64) + (x66 as u64)) + ((x88 as u64) + x68)),\n        ((x124 as u64) + x104),\n    );\n    let mut x139: u64 = 0;\n    let mut x140: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x139, &mut x140, x2, 0xc84ee012b39bf21);\n    let mut x141: u64 = 0;\n    let mut x142: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x141, &mut x142, x2, 0x3fb05b7a28266895);\n    let mut x143: u64 = 0;\n    let mut x144: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x143, &mut x144, x2, 0xd40d49174aab1cc5);\n    let mut x145: u64 = 0;\n    let mut x146: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x145, &mut x146, x2, 0xbc3e483afcb82947);\n    let mut x147: u64 = 0;\n    let mut x148: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x147, &mut x148, x2, 0xff3d81e5df1aa419);\n    let mut x149: u64 = 0;\n    let mut x150: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x149, &mut x150, x2, 0x2d319b2419b409a9);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x151, &mut x152, 0x0, x150, x147);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x153, &mut x154, x152, x148, x145);\n    let mut x155: u64 = 0;\n    let mut x156: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x155, &mut x156, x154, x146, x143);\n    let mut x157: u64 = 0;\n    let mut x158: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x157, &mut x158, x156, x144, x141);\n    let mut x159: u64 = 0;\n    let mut x160: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x159, &mut x160, x158, x142, x139);\n    let mut x161: u64 = 0;\n    let mut x162: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x161, &mut x162, 0x0, x127, x149);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x163, &mut x164, x162, x129, x151);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x165, &mut x166, x164, x131, x153);\n    let mut x167: u64 = 0;\n    let mut x168: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x167, &mut x168, x166, x133, x155);\n    let mut x169: u64 = 0;\n    let mut x170: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x169, &mut x170, x168, x135, x157);\n    let mut x171: u64 = 0;\n    let mut x172: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x171, &mut x172, x170, x137, x159);\n    let mut x173: u64 = 0;\n    let mut x174: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x173, &mut x174, x161, 0x6ed46089e88fdc45);\n    let mut x175: u64 = 0;\n    let mut x176: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x175, &mut x176, x173, 0xffffffffffffffff);\n    let mut x177: u64 = 0;\n    let mut x178: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x177, &mut x178, x173, 0xffffffffffffffff);\n    let mut x179: u64 = 0;\n    let mut x180: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x179, &mut x180, x173, 0xffffffffffffffff);\n    let mut x181: u64 = 0;\n    let mut x182: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x181, &mut x182, x173, 0xc7634d81f4372ddf);\n    let mut x183: u64 = 0;\n    let mut x184: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x183, &mut x184, x173, 0x581a0db248b0a77a);\n    let mut x185: u64 = 0;\n    let mut x186: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x185, &mut x186, x173, 0xecec196accc52973);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x187, &mut x188, 0x0, x186, x183);\n    let mut x189: u64 = 0;\n    let mut x190: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x189, &mut x190, x188, x184, x181);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x191, &mut x192, x190, x182, x179);\n    let mut x193: u64 = 0;\n    let mut x194: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x193, &mut x194, x192, x180, x177);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x195, &mut x196, x194, x178, x175);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x197, &mut x198, 0x0, x161, x185);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x163, x187);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x165, x189);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x167, x191);\n    let mut x205: u64 = 0;\n    let mut x206: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x205, &mut x206, x204, x169, x193);\n    let mut x207: u64 = 0;\n    let mut x208: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x207, &mut x208, x206, x171, x195);\n    let mut x209: u64 = 0;\n    let mut x210: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x209,\n        &mut x210,\n        x208,\n        (((x172 as u64) + (x138 as u64)) + ((x160 as u64) + x140)),\n        ((x196 as u64) + x176),\n    );\n    let mut x211: u64 = 0;\n    let mut x212: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x211, &mut x212, x3, 0xc84ee012b39bf21);\n    let mut x213: u64 = 0;\n    let mut x214: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x213, &mut x214, x3, 0x3fb05b7a28266895);\n    let mut x215: u64 = 0;\n    let mut x216: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x215, &mut x216, x3, 0xd40d49174aab1cc5);\n    let mut x217: u64 = 0;\n    let mut x218: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x217, &mut x218, x3, 0xbc3e483afcb82947);\n    let mut x219: u64 = 0;\n    let mut x220: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x219, &mut x220, x3, 0xff3d81e5df1aa419);\n    let mut x221: u64 = 0;\n    let mut x222: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x221, &mut x222, x3, 0x2d319b2419b409a9);\n    let mut x223: u64 = 0;\n    let mut x224: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x223, &mut x224, 0x0, x222, x219);\n    let mut x225: u64 = 0;\n    let mut x226: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x225, &mut x226, x224, x220, x217);\n    let mut x227: u64 = 0;\n    let mut x228: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x227, &mut x228, x226, x218, x215);\n    let mut x229: u64 = 0;\n    let mut x230: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x229, &mut x230, x228, x216, x213);\n    let mut x231: u64 = 0;\n    let mut x232: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x231, &mut x232, x230, x214, x211);\n    let mut x233: u64 = 0;\n    let mut x234: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x233, &mut x234, 0x0, x199, x221);\n    let mut x235: u64 = 0;\n    let mut x236: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x235, &mut x236, x234, x201, x223);\n    let mut x237: u64 = 0;\n    let mut x238: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x237, &mut x238, x236, x203, x225);\n    let mut x239: u64 = 0;\n    let mut x240: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x239, &mut x240, x238, x205, x227);\n    let mut x241: u64 = 0;\n    let mut x242: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x241, &mut x242, x240, x207, x229);\n    let mut x243: u64 = 0;\n    let mut x244: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x243, &mut x244, x242, x209, x231);\n    let mut x245: u64 = 0;\n    let mut x246: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x245, &mut x246, x233, 0x6ed46089e88fdc45);\n    let mut x247: u64 = 0;\n    let mut x248: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x247, &mut x248, x245, 0xffffffffffffffff);\n    let mut x249: u64 = 0;\n    let mut x250: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x249, &mut x250, x245, 0xffffffffffffffff);\n    let mut x251: u64 = 0;\n    let mut x252: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x251, &mut x252, x245, 0xffffffffffffffff);\n    let mut x253: u64 = 0;\n    let mut x254: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x253, &mut x254, x245, 0xc7634d81f4372ddf);\n    let mut x255: u64 = 0;\n    let mut x256: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x255, &mut x256, x245, 0x581a0db248b0a77a);\n    let mut x257: u64 = 0;\n    let mut x258: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x257, &mut x258, x245, 0xecec196accc52973);\n    let mut x259: u64 = 0;\n    let mut x260: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x259, &mut x260, 0x0, x258, x255);\n    let mut x261: u64 = 0;\n    let mut x262: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x261, &mut x262, x260, x256, x253);\n    let mut x263: u64 = 0;\n    let mut x264: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x263, &mut x264, x262, x254, x251);\n    let mut x265: u64 = 0;\n    let mut x266: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x265, &mut x266, x264, x252, x249);\n    let mut x267: u64 = 0;\n    let mut x268: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x267, &mut x268, x266, x250, x247);\n    let mut x269: u64 = 0;\n    let mut x270: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x269, &mut x270, 0x0, x233, x257);\n    let mut x271: u64 = 0;\n    let mut x272: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x271, &mut x272, x270, x235, x259);\n    let mut x273: u64 = 0;\n    let mut x274: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x273, &mut x274, x272, x237, x261);\n    let mut x275: u64 = 0;\n    let mut x276: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x275, &mut x276, x274, x239, x263);\n    let mut x277: u64 = 0;\n    let mut x278: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x277, &mut x278, x276, x241, x265);\n    let mut x279: u64 = 0;\n    let mut x280: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x279, &mut x280, x278, x243, x267);\n    let mut x281: u64 = 0;\n    let mut x282: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x281,\n        &mut x282,\n        x280,\n        (((x244 as u64) + (x210 as u64)) + ((x232 as u64) + x212)),\n        ((x268 as u64) + x248),\n    );\n    let mut x283: u64 = 0;\n    let mut x284: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x283, &mut x284, x4, 0xc84ee012b39bf21);\n    let mut x285: u64 = 0;\n    let mut x286: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x285, &mut x286, x4, 0x3fb05b7a28266895);\n    let mut x287: u64 = 0;\n    let mut x288: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x287, &mut x288, x4, 0xd40d49174aab1cc5);\n    let mut x289: u64 = 0;\n    let mut x290: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x289, &mut x290, x4, 0xbc3e483afcb82947);\n    let mut x291: u64 = 0;\n    let mut x292: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x291, &mut x292, x4, 0xff3d81e5df1aa419);\n    let mut x293: u64 = 0;\n    let mut x294: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x293, &mut x294, x4, 0x2d319b2419b409a9);\n    let mut x295: u64 = 0;\n    let mut x296: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x295, &mut x296, 0x0, x294, x291);\n    let mut x297: u64 = 0;\n    let mut x298: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x297, &mut x298, x296, x292, x289);\n    let mut x299: u64 = 0;\n    let mut x300: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x299, &mut x300, x298, x290, x287);\n    let mut x301: u64 = 0;\n    let mut x302: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x301, &mut x302, x300, x288, x285);\n    let mut x303: u64 = 0;\n    let mut x304: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x303, &mut x304, x302, x286, x283);\n    let mut x305: u64 = 0;\n    let mut x306: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x305, &mut x306, 0x0, x271, x293);\n    let mut x307: u64 = 0;\n    let mut x308: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x307, &mut x308, x306, x273, x295);\n    let mut x309: u64 = 0;\n    let mut x310: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x309, &mut x310, x308, x275, x297);\n    let mut x311: u64 = 0;\n    let mut x312: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x311, &mut x312, x310, x277, x299);\n    let mut x313: u64 = 0;\n    let mut x314: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x313, &mut x314, x312, x279, x301);\n    let mut x315: u64 = 0;\n    let mut x316: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x315, &mut x316, x314, x281, x303);\n    let mut x317: u64 = 0;\n    let mut x318: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x317, &mut x318, x305, 0x6ed46089e88fdc45);\n    let mut x319: u64 = 0;\n    let mut x320: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x319, &mut x320, x317, 0xffffffffffffffff);\n    let mut x321: u64 = 0;\n    let mut x322: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x321, &mut x322, x317, 0xffffffffffffffff);\n    let mut x323: u64 = 0;\n    let mut x324: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x323, &mut x324, x317, 0xffffffffffffffff);\n    let mut x325: u64 = 0;\n    let mut x326: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x325, &mut x326, x317, 0xc7634d81f4372ddf);\n    let mut x327: u64 = 0;\n    let mut x328: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x327, &mut x328, x317, 0x581a0db248b0a77a);\n    let mut x329: u64 = 0;\n    let mut x330: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x329, &mut x330, x317, 0xecec196accc52973);\n    let mut x331: u64 = 0;\n    let mut x332: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x331, &mut x332, 0x0, x330, x327);\n    let mut x333: u64 = 0;\n    let mut x334: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x333, &mut x334, x332, x328, x325);\n    let mut x335: u64 = 0;\n    let mut x336: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x335, &mut x336, x334, x326, x323);\n    let mut x337: u64 = 0;\n    let mut x338: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x337, &mut x338, x336, x324, x321);\n    let mut x339: u64 = 0;\n    let mut x340: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x339, &mut x340, x338, x322, x319);\n    let mut x341: u64 = 0;\n    let mut x342: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x341, &mut x342, 0x0, x305, x329);\n    let mut x343: u64 = 0;\n    let mut x344: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x343, &mut x344, x342, x307, x331);\n    let mut x345: u64 = 0;\n    let mut x346: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x345, &mut x346, x344, x309, x333);\n    let mut x347: u64 = 0;\n    let mut x348: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x347, &mut x348, x346, x311, x335);\n    let mut x349: u64 = 0;\n    let mut x350: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x349, &mut x350, x348, x313, x337);\n    let mut x351: u64 = 0;\n    let mut x352: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x351, &mut x352, x350, x315, x339);\n    let mut x353: u64 = 0;\n    let mut x354: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x353,\n        &mut x354,\n        x352,\n        (((x316 as u64) + (x282 as u64)) + ((x304 as u64) + x284)),\n        ((x340 as u64) + x320),\n    );\n    let mut x355: u64 = 0;\n    let mut x356: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x355, &mut x356, x5, 0xc84ee012b39bf21);\n    let mut x357: u64 = 0;\n    let mut x358: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x357, &mut x358, x5, 0x3fb05b7a28266895);\n    let mut x359: u64 = 0;\n    let mut x360: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x359, &mut x360, x5, 0xd40d49174aab1cc5);\n    let mut x361: u64 = 0;\n    let mut x362: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x361, &mut x362, x5, 0xbc3e483afcb82947);\n    let mut x363: u64 = 0;\n    let mut x364: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x363, &mut x364, x5, 0xff3d81e5df1aa419);\n    let mut x365: u64 = 0;\n    let mut x366: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x365, &mut x366, x5, 0x2d319b2419b409a9);\n    let mut x367: u64 = 0;\n    let mut x368: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x367, &mut x368, 0x0, x366, x363);\n    let mut x369: u64 = 0;\n    let mut x370: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x369, &mut x370, x368, x364, x361);\n    let mut x371: u64 = 0;\n    let mut x372: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x371, &mut x372, x370, x362, x359);\n    let mut x373: u64 = 0;\n    let mut x374: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x373, &mut x374, x372, x360, x357);\n    let mut x375: u64 = 0;\n    let mut x376: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x375, &mut x376, x374, x358, x355);\n    let mut x377: u64 = 0;\n    let mut x378: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x377, &mut x378, 0x0, x343, x365);\n    let mut x379: u64 = 0;\n    let mut x380: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x379, &mut x380, x378, x345, x367);\n    let mut x381: u64 = 0;\n    let mut x382: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x381, &mut x382, x380, x347, x369);\n    let mut x383: u64 = 0;\n    let mut x384: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x383, &mut x384, x382, x349, x371);\n    let mut x385: u64 = 0;\n    let mut x386: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x385, &mut x386, x384, x351, x373);\n    let mut x387: u64 = 0;\n    let mut x388: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x387, &mut x388, x386, x353, x375);\n    let mut x389: u64 = 0;\n    let mut x390: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x389, &mut x390, x377, 0x6ed46089e88fdc45);\n    let mut x391: u64 = 0;\n    let mut x392: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x391, &mut x392, x389, 0xffffffffffffffff);\n    let mut x393: u64 = 0;\n    let mut x394: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x393, &mut x394, x389, 0xffffffffffffffff);\n    let mut x395: u64 = 0;\n    let mut x396: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x395, &mut x396, x389, 0xffffffffffffffff);\n    let mut x397: u64 = 0;\n    let mut x398: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x397, &mut x398, x389, 0xc7634d81f4372ddf);\n    let mut x399: u64 = 0;\n    let mut x400: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x399, &mut x400, x389, 0x581a0db248b0a77a);\n    let mut x401: u64 = 0;\n    let mut x402: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x401, &mut x402, x389, 0xecec196accc52973);\n    let mut x403: u64 = 0;\n    let mut x404: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x403, &mut x404, 0x0, x402, x399);\n    let mut x405: u64 = 0;\n    let mut x406: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x405, &mut x406, x404, x400, x397);\n    let mut x407: u64 = 0;\n    let mut x408: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x407, &mut x408, x406, x398, x395);\n    let mut x409: u64 = 0;\n    let mut x410: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x409, &mut x410, x408, x396, x393);\n    let mut x411: u64 = 0;\n    let mut x412: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x411, &mut x412, x410, x394, x391);\n    let mut x413: u64 = 0;\n    let mut x414: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x413, &mut x414, 0x0, x377, x401);\n    let mut x415: u64 = 0;\n    let mut x416: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x415, &mut x416, x414, x379, x403);\n    let mut x417: u64 = 0;\n    let mut x418: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x417, &mut x418, x416, x381, x405);\n    let mut x419: u64 = 0;\n    let mut x420: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x419, &mut x420, x418, x383, x407);\n    let mut x421: u64 = 0;\n    let mut x422: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x421, &mut x422, x420, x385, x409);\n    let mut x423: u64 = 0;\n    let mut x424: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x423, &mut x424, x422, x387, x411);\n    let mut x425: u64 = 0;\n    let mut x426: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x425,\n        &mut x426,\n        x424,\n        (((x388 as u64) + (x354 as u64)) + ((x376 as u64) + x356)),\n        ((x412 as u64) + x392),\n    );\n    let mut x427: u64 = 0;\n    let mut x428: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x427, &mut x428, 0x0, x415, 0xecec196accc52973);\n    let mut x429: u64 = 0;\n    let mut x430: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x429, &mut x430, x428, x417, 0x581a0db248b0a77a);\n    let mut x431: u64 = 0;\n    let mut x432: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x431, &mut x432, x430, x419, 0xc7634d81f4372ddf);\n    let mut x433: u64 = 0;\n    let mut x434: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x433, &mut x434, x432, x421, 0xffffffffffffffff);\n    let mut x435: u64 = 0;\n    let mut x436: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x435, &mut x436, x434, x423, 0xffffffffffffffff);\n    let mut x437: u64 = 0;\n    let mut x438: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x437, &mut x438, x436, x425, 0xffffffffffffffff);\n    let mut x439: u64 = 0;\n    let mut x440: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x439, &mut x440, x438, (x426 as u64), (0x0 as u64));\n    let mut x441: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x441, x440, x427, x415);\n    let mut x442: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x442, x440, x429, x417);\n    let mut x443: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x443, x440, x431, x419);\n    let mut x444: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x444, x440, x433, x421);\n    let mut x445: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x445, x440, x435, x423);\n    let mut x446: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x446, x440, x437, x425);\n    out1[0] = x441;\n    out1[1] = x442;\n    out1[2] = x443;\n    out1[3] = x444;\n    out1[4] = x445;\n    out1[5] = x446;\n}",
    "display_name": "fiat_p384_scalar_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn reduce(w: U576) -> Self {\n        let (r, underflow) = w.borrowing_sub(&NistP521::ORDER, bigint::Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (bigint::Limb::BITS - 1)) as u8);\n        Self::from_uint_unchecked(U576::conditional_select(&w, &r, !underflow))\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/q3_times_n_keep_five",
    "statement_type": "function",
    "deps": [],
    "body": "const fn q3_times_n_keep_five(q3: &[Limb; 5]) -> [Limb; 5] {\n    // Schoolbook multiplication.\n\n    let modulus = MODULUS.as_limbs();\n\n    let (w0, carry) = q3[0].carrying_mul_add(modulus[0], Limb::ZERO, Limb::ZERO);\n    let (w1, carry) = q3[0].carrying_mul_add(modulus[1], Limb::ZERO, carry);\n    let (w2, carry) = q3[0].carrying_mul_add(modulus[2], Limb::ZERO, carry);\n    let (w3, carry) = q3[0].carrying_mul_add(modulus[3], Limb::ZERO, carry);\n    // let (w4, _) = q3[0].carrying_mul_add(0, Limb::ZERO, carry);\n    let (w4, _) = (carry, Limb::ZERO);\n\n    let (w1, carry) = q3[1].carrying_mul_add(modulus[0], w1, Limb::ZERO);\n    let (w2, carry) = q3[1].carrying_mul_add(modulus[1], w2, carry);\n    let (w3, carry) = q3[1].carrying_mul_add(modulus[2], w3, carry);\n    let (w4, _) = q3[1].carrying_mul_add(modulus[3], w4, carry);\n\n    let (w2, carry) = q3[2].carrying_mul_add(modulus[0], w2, Limb::ZERO);\n    let (w3, carry) = q3[2].carrying_mul_add(modulus[1], w3, carry);\n    let (w4, _) = q3[2].carrying_mul_add(modulus[2], w4, carry);\n\n    let (w3, carry) = q3[3].carrying_mul_add(modulus[0], w3, Limb::ZERO);\n    let (w4, _) = q3[3].carrying_mul_add(modulus[1], w4, carry);\n\n    let (w4, _) = q3[4].carrying_mul_add(modulus[0], w4, Limb::ZERO);\n\n    [w0, w1, w2, w3, w4]\n}",
    "display_name": "q3_times_n_keep_five",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar/scalar64.rs",
    "relative_path": "p256/src/arithmetic/scalar/scalar64.rs",
    "file_name": "scalar64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/EncodePrivateKey/to_pkcs8_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/KeypairBytes/EncodePrivateKey/to_pkcs8_der",
      "0.14.0_pre.1 sign/signing_key/impl/KeypairBytes/From/from"
    ],
    "body": "    fn to_pkcs8_der(&self) -> pkcs8::Result<pkcs8::SecretDocument> {\n        KeypairBytes::from(self).to_pkcs8_der()\n    }",
    "display_name": "to_pkcs8_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: ScalarPrimitive<Secp256k1>) -> Scalar {\n        Scalar(*scalar.as_uint())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add_mixed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize_weak",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/is_identity",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/mul_single"
    ],
    "body": "    fn add_mixed(&self, other: &AffinePoint) -> ProjectivePoint {\n        // We implement the complete addition formula from Renes-Costello-Batina 2015\n        // (https://eprint.iacr.org/2015/1060 Algorithm 8).\n\n        let xx = self.x * &other.x;\n        let yy = self.y * &other.y;\n        let xy_pairs = ((self.x + &self.y) * &(other.x + &other.y)) + &(xx + &yy).negate(2);\n        let yz_pairs = (other.y * &self.z) + &self.y;\n        let xz_pairs = (other.x * &self.z) + &self.x;\n\n        let bzz = &self.z.mul_single(CURVE_EQUATION_B_SINGLE);\n        let bzz3 = (bzz.double() + bzz).normalize_weak();\n\n        let yy_m_bzz3 = yy + &bzz3.negate(1);\n        let yy_p_bzz3 = yy + &bzz3;\n\n        let byz = &yz_pairs\n            .mul_single(CURVE_EQUATION_B_SINGLE)\n            .normalize_weak();\n        let byz3 = (byz.double() + byz).normalize_weak();\n\n        let xx3 = xx.double() + &xx;\n        let bxx9 = &(xx3.double() + &xx3)\n            .normalize_weak()\n            .mul_single(CURVE_EQUATION_B_SINGLE)\n            .normalize_weak();\n\n        let mut ret = ProjectivePoint {\n            x: ((xy_pairs * &yy_m_bzz3) + &(byz3 * &xz_pairs).negate(1)).normalize_weak(),\n            y: ((yy_p_bzz3 * &yy_m_bzz3) + &(bxx9 * &xz_pairs)).normalize_weak(),\n            z: ((yz_pairs * &yy_p_bzz3) + &(xx3 * &xy_pairs)).normalize_weak(),\n        };\n        ret.conditional_assign(self, other.is_identity());\n        ret\n    }",
    "display_name": "add_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/kdf",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/xor",
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "fn kdf(hasher: &mut dyn DynDigest, kpb: AffinePoint, c2: &mut [u8]) -> Result<()> {\n    let klen = c2.len();\n    let mut ct: i32 = 0x00000001;\n    let mut offset = 0;\n    let digest_size = hasher.output_size();\n    let mut ha = vec![0u8; digest_size];\n    let encode_point = kpb.to_encoded_point(false);\n\n    while offset < klen {\n        hasher.update(encode_point.x().ok_or(elliptic_curve::Error)?);\n        hasher.update(encode_point.y().ok_or(elliptic_curve::Error)?);\n        hasher.update(&ct.to_be_bytes());\n\n        hasher\n            .finalize_into_reset(&mut ha)\n            .map_err(|_e| elliptic_curve::Error)?;\n\n        let xor_len = min(digest_size, klen - offset);\n        xor(c2, &ha, offset, xor_len);\n        offset += xor_len;\n        ct += 1;\n    }\n    Ok(())\n}",
    "display_name": "kdf",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke.rs",
    "relative_path": "sm2/src/pke.rs",
    "file_name": "pke.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_cmovznz_u64(out1: &mut u64, arg1: fiat_sm2_u1, arg2: u64, arg3: u64) {\n    let x1: fiat_sm2_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_sm2_i2) - (x1 as fiat_sm2_i2)) as fiat_sm2_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_sm2_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/barrett_reduce"
    ],
    "body": "    pub const fn multiply(&self, rhs: &Self) -> Self {\n        let (lo, hi) = self.0.widening_mul(&rhs.0);\n        Self(barrett_reduce(lo, hi))\n    }",
    "display_name": "multiply",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        let inner = U256::from_be_byte_array(bytes);\n        CtOption::new(Self(inner), inner.ct_lt(&Secp256k1::ORDER))\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/mul"
    ],
    "body": "    fn mul(self, scalar: S) -> Self {\n        ProjectivePoint::mul(&self, scalar.borrow())\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &CompressedDecaf) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/mul"
    ],
    "body": "    fn mul_assign(&mut self, rhs: &Scalar) {\n        *self = Scalar::mul(self, rhs);\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn add_extended(&self, other: &ExtendedPoint) -> ExtensiblePoint {\n        let A = self.X * other.X;\n        let B = self.Y * other.Y;\n        let C = self.T1 * self.T2 * other.T * FieldElement::TWISTED_D;\n        let D = self.Z * other.Z;\n        let E = (self.X + self.Y) * (other.X + other.Y) - A - B;\n        let F = D - C;\n        let G = D + C;\n        let H = B + A;\n        ExtensiblePoint {\n            X: E * F,\n            Y: G * H,\n            T1: E,\n            T2: H,\n            Z: F * G,\n        }\n    }",
    "display_name": "add_extended",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/sub_mixed",
    "statement_type": "function",
    "deps": [
      "affine/impl/&AffinePoint/Neg/neg",
      "projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn sub_mixed(&self, other: &AffinePoint<C>) -> Self {\n        self.add_mixed(&other.neg())\n    }",
    "display_name": "sub_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/dev/biguint_to_bytes"
    ],
    "body": "        fn from(x: &BigUint) -> Self {\n            debug_assert!(x < &Scalar::modulus_as_biguint());\n            let bytes = biguint_to_bytes(x);\n            Self::from_repr(bytes.into()).unwrap()\n        }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "affine/impl/AffinePoint/GroupEncoding/from_bytes",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        EncodedPoint::<C>::from_bytes(bytes)\n            .map(|point| CtOption::new(point, Choice::from(1)))\n            .unwrap_or_else(|_| {\n                // SEC1 identity encoding is technically 1-byte 0x00, but the\n                // `GroupEncoding` API requires a fixed-width `Repr`\n                let is_identity = bytes.ct_eq(&Self::Repr::default());\n                CtOption::new(EncodedPoint::<C>::identity(), is_identity)\n            })\n            .and_then(|point| Self::from_encoded_point(&point))\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/tests/affine_negation",
    "statement_type": "function",
    "deps": [],
    "body": "    fn affine_negation() {\n        let basepoint = AffinePoint::GENERATOR;\n        assert_eq!((-(-basepoint)), basepoint);\n    }",
    "display_name": "affine_negation",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_to_bytes_rfc8032",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032"
    ],
    "body": "    fn test_to_bytes_rfc8032() {\n        // n-1\n        let mut bytes: [u8; 57] = hex!(\n            \"003fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f2\"\n        );\n        bytes.reverse();\n        let x = Scalar::ZERO - Scalar::ONE;\n        let candidate = x.to_bytes_rfc_8032();\n        assert_eq!(&bytes[..], &candidate[..]);\n    }",
    "display_name": "test_to_bytes_rfc8032",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify"
    ],
    "body": "    fn verify(&self, msg: &[u8], signature: &Signature) -> Result<()> {\n        self.multipart_verify(&[msg], signature)\n    }",
    "display_name": "verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/PrehashSigner/sign_prehash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/signing/impl/SigningKey/as_nonzero_scalar",
      "0.14.0_pre ecdsa/impl/Signature/from_scalars",
      "affine/impl/AffinePoint/AffineCoordinates/x",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
      "projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
      "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn sign_prehash(&self, prehash: &[u8]) -> Result<Signature> {\n        if prehash.len() != <BignP256 as Curve>::FieldBytesSize::USIZE {\n            return Err(Error::new());\n        }\n        let mut h_word: Array<u8, U32> = Array::clone_from_slice(prehash);\n        h_word.reverse();\n\n        let h = Scalar::reduce_bytes(&h_word);\n\n        //2. Generate 𝑘 ← rand(1,..,𝑞-1)\n        let k = Scalar::from_repr(rfc6979::generate_k::<BeltHash, _>(\n            &self.secret_scalar.to_repr(),\n            &FieldBytesEncoding::<BignP256>::encode_field_bytes(&BignP256::ORDER),\n            &h.to_bytes(),\n            &[],\n        ))\n        .unwrap();\n\n        // 3. Set 𝑅 ← 𝑘𝐺.\n        let mut R: Array<u8, _> = ProjectivePoint::mul_by_generator(&k).to_affine().x();\n        R.reverse();\n\n        // 4. Set 𝑆0 ← ⟨︀belt-hash(OID(ℎ) ‖ ⟨𝑅⟩2𝑙 ‖ 𝐻)⟩︀_𝑙.\n        let mut hasher = BeltHash::new();\n        hasher.update(BELT_OID);\n        hasher.update(R);\n        hasher.update(prehash);\n\n        let mut s0 = hasher.finalize();\n        s0[16..].fill(0x00);\n        s0.reverse();\n\n        let s0_scalar = Scalar::from_slice(&s0).ok_or_else(Error::new)?;\n\n        let right = s0_scalar\n            .add(&Scalar::from_u64(2).pow([128, 0, 0, 0]))\n            .multiply(self.as_nonzero_scalar());\n\n        // 5. Set 𝑆1 ← ⟨︀(𝑘 − 𝐻 − (𝑆0 + 2^𝑙)𝑑) mod 𝑞⟩︀_2𝑙.\n        let s1 = k.sub(&h).sub(&right);\n\n        // 6. Set 𝑆 ← 𝑆0 ‖ 𝑆1.\n        // 7. Return S.\n        Signature::from_scalars(s0_scalar, s1)\n    }",
    "display_name": "sign_prehash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [],
    "body": "    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n        let mut acc = Scalar::ONE;\n        for s in iter {\n            acc *= s;\n        }\n        acc\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/EphemeralSecret/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.scalar.zeroize()\n    }",
    "display_name": "zeroize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/&Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/subtract"
    ],
    "body": "    fn sub(self, rhs: &Scalar) -> Self::Output {\n        self.subtract(rhs)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/&FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, other: &FieldElement) -> FieldElement {\n        FieldElement(self.0.mul(&other.0))\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "    fn is_odd(&self) -> Choice {\n        self.0.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, rhs: &FieldElement) {\n        *self = *self * rhs;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/tests/test_mul_by_generator",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/mul_by_generator"
    ],
    "body": "    fn test_mul_by_generator() {\n        let k = Scalar::random(&mut OsRng.unwrap_mut());\n        let reference = ProjectivePoint::GENERATOR * k;\n        let test = ProjectivePoint::mul_by_generator(&k);\n        assert_eq!(reference, test);\n    }",
    "display_name": "test_mul_by_generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/is_zero",
    "statement_type": "function",
    "deps": [],
    "body": "fn is_zero(b: u8) -> Choice {\n    let res = b as i8;\n    Choice::from((((res | -res) >> 7) + 1) as u8)\n}",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let bytes = self.to_bytes();\n        let formatter = base16ct::HexDisplay(&bytes);\n        f.debug_tuple(\"FieldElement\")\n            .field(&format_args!(\"0x{formatter:X}\"))\n            .finish()\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square"
    ],
    "body": "    pub fn double(&self) -> ExtensiblePoint {\n        let A = self.X.square();\n        let B = self.Y.square();\n        let C = self.Z.square() + self.Z.square();\n        let D = -A;\n        let E = (self.X + self.Y).square() - A - B;\n        let G = D + B;\n        let F = G - C;\n        let H = D - B;\n        ExtensiblePoint {\n            X: E * F,\n            Y: G * H,\n            Z: F * G,\n            T1: E,\n            T2: H,\n        }\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Group/generator",
    "statement_type": "function",
    "deps": [],
    "body": "    fn generator() -> Self {\n        Self::GENERATOR\n    }",
    "display_name": "generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/test_just_decompress",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress",
      "0.14.0_pre.1 curve/edwards/extended/tests/hex_to_field"
    ],
    "body": "    fn test_just_decompress() {\n        let bytes = hex!(\n            \"649c6a53b109897d962d033f23d01fd4e1053dddf3746d2ddce9bd66aea38ccfc3df061df03ca399eb806312ab3037c0c31523142956ada780\"\n        );\n        let compressed = CompressedEdwardsY(bytes);\n        let decompressed = compressed.decompress().unwrap();\n\n        assert_eq!(\n            decompressed.X,\n            hex_to_field(\n                \"39c41cea305d737df00de8223a0d5f4d48c8e098e16e9b4b2f38ac353262e119cb5ff2afd6d02464702d9d01c9921243fc572f9c718e2527\"\n            )\n        );\n        assert_eq!(\n            decompressed.Y,\n            hex_to_field(\n                \"a7ad5629142315c3c03730ab126380eb99a33cf01d06dfc3cf8ca3ae66bde9dc2d6d74f3dd3d05e1d41fd0233f032d967d8909b1536a9c64\"\n            )\n        );\n\n        let bytes = hex!(\n            \"010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n        );\n        let compressed = CompressedEdwardsY(bytes);\n        let decompressed = compressed.decompress().unwrap();\n\n        assert_eq!(\n            decompressed.X,\n            hex_to_field(\n                \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n            )\n        );\n        assert_eq!(\n            decompressed.Y,\n            hex_to_field(\n                \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"\n            )\n        );\n    }",
    "display_name": "test_just_decompress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/encode",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/encode",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine",
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_on_curve"
    ],
    "body": "    fn encode() {\n        const DST: &[u8] = b\"QUUX-V01-CS02-with-edwards448_XOF:SHAKE256_ELL2_NU_\";\n        const MSGS: &[(&[u8], [u8; 56], [u8; 56])] = &[\n            (b\"\", hex!(\"eb5a1fc376fd73230af2de0f3374087cc7f279f0460114cf0a6c12d6d044c16de34ec2350c34b26bf110377655ab77936869d085406af71e\"), hex!(\"df5dcea6d42e8f494b279a500d09e895d26ac703d75ca6d118e8ca58bf6f608a2a383f292fce1563ff995dce75aede1fdc8e7c0c737ae9ad\")),\n            (b\"abc\", hex!(\"4623a64bceaba3202df76cd8b6e3daf70164f3fcbda6d6e340f7fab5cdf89140d955f722524f5fe4d968fef6ba2853ff4ea086c2f67d8110\"), hex!(\"abaac321a169761a8802ab5b5d10061fec1a83c670ac6bc95954700317ee5f82870120e0e2c5a21b12a0c7ad17ebd343363604c4bcecafd1\")),\n            (b\"abcdef0123456789\", hex!(\"e9eb562e76db093baa43a31b7edd04ec4aadcef3389a7b9c58a19cf87f8ae3d154e134b6b3ed45847a741e33df51903da681629a4b8bcc2e\"), hex!(\"0cf6606927ad7eb15dbc193993bc7e4dda744b311a8ec4274c8f738f74f605934582474c79260f60280fe35bd37d4347e59184cbfa12cbc4\")),\n            (b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\", hex!(\"122a3234d34b26c69749f23356452bf9501efa2d94859d5ef741fef024156d9d191a03a2ad24c38186f93e02d05572575968b083d8a39738\"), hex!(\"ddf55e74eb4414c2c1fa4aa6bc37c4ab470a3fed6bb5af1e43570309b162fb61879bb15f9ea49c712efd42d0a71666430f9f0d4a20505050\")),\n            (b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", hex!(\"221704949b1ce1ab8dd174dc9b8c56fcffa27179569ce9219c0c2fe183d3d23343a4c42a0e2e9d6b9d0feb1df3883ec489b6671d1fa64089\"), hex!(\"ebdecfdc87142d1a919034bf22ecfad934c9a85effff14b594ae2c00943ca62a39d6ee3be9df0bb504ce8a9e1669bc6959c42ad6a1d3b686\")),\n        ];\n\n        for (msg, x, y) in MSGS {\n            let p = EdwardsPoint::encode::<ExpandMsgXof<sha3::Shake256>>(msg, DST);\n            assert_eq!(p.is_on_curve().unwrap_u8(), 1u8);\n            let p = p.to_affine();\n            let mut xx = [0u8; 56];\n            xx.copy_from_slice(&x[..]);\n            xx.reverse();\n            let mut yy = [0u8; 56];\n            yy.copy_from_slice(&y[..]);\n            yy.reverse();\n            assert_eq!(p.x.to_bytes(), xx);\n            assert_eq!(p.y.to_bytes(), yy);\n        }\n    }",
    "display_name": "encode",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [],
    "body": "    fn is_high(&self) -> Choice {\n        self.0.ct_gt(&FRAC_MODULUS_2.0)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_p192_scalar_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_prehashed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_inner"
    ],
    "body": "    pub fn verify_prehashed<D>(\n        self,\n        sig: &Signature,\n        ctx: Option<&[u8]>,\n        mut prehashed_message: D,\n    ) -> Result<(), Error>\n    where\n        D: PreHash,\n    {\n        let mut m = [0u8; 64];\n        prehashed_message.fill_bytes(&mut m);\n        self.verify_inner(sig, 1, ctx.unwrap_or_default(), &m)\n    }",
    "display_name": "verify_prehashed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_x() -> Scalar {\n    Scalar::from_repr(\n        hex!(\"519b423d715f8b581f4fa8ee59f4771a5b44c8130b4e3eacca54a56dda72b464\").into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_scalar_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre encrypt_and_decrypt_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt_der",
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt_der",
      "0.14.0_pre decrypting_key",
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/encrypting_key"
    ],
    "body": "    fn encrypt_and_decrypt_der(dk in decrypting_key()) {\n        let ek = dk.encrypting_key();\n        let cipher_bytes = ek.encrypt_der(&mut OsRng, MSG).unwrap();\n        prop_assert!(dk.decrypt_der(&cipher_bytes).is_ok());\n    }",
    "display_name": "encrypt_and_decrypt_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2pke.rs",
    "relative_path": "sm2/tests/sm2pke.rs",
    "file_name": "sm2pke.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.7.0_pre decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_field_bytes(field_bytes: &FieldBytes) -> U384 {\n    U384::from_be_byte_array(*field_bytes)\n}",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp384/src/lib.rs",
    "relative_path": "bp384/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes(bytes: &SignatureBytes) -> Result<Self> {\n        let (r_bytes, s_bytes) = bytes.split_at(Self::BYTE_SIZE / 2);\n        let r = ScalarPrimitive::from_slice(r_bytes).map_err(|_| Error::new())?;\n        let s = ScalarPrimitive::from_slice(s_bytes).map_err(|_| Error::new())?;\n\n        if r.is_zero().into() || s.is_zero().into() {\n            return Err(Error::new());\n        }\n\n        Ok(Self { r, s })\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/to_radix_16",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    pub(crate) fn to_radix_16(self) -> [i8; 113] {\n        let bytes = self.to_bytes();\n        let mut output = [0i8; 113];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            x & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        // radix-16\n        for i in 0..56 {\n            output[2 * i] = bot_half(bytes[i]) as i8;\n            output[2 * i + 1] = top_half(bytes[i]) as i8;\n        }\n        // re-center co-efficients to be between [-8, 8)\n        for i in 0..112 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n\n        output\n    }",
    "display_name": "to_radix_16",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_twisted"
    ],
    "body": "    fn from(point: &EdwardsPoint) -> Self {\n        Self(point.to_twisted())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre encode_pkcs8_private_key_to_der",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_private_key_to_der() {\n    let original_secret_key = sm2::SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let reencoded_secret_key = original_secret_key.to_pkcs8_der().unwrap();\n    assert_eq!(reencoded_secret_key.as_bytes(), &PKCS8_PRIVATE_KEY_DER[..]);\n}",
    "display_name": "encode_pkcs8_private_key_to_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 decode_pkcs8_public_key_from_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_public_key_from_pem() {\n    let public_key = PKCS8_PUBLIC_KEY_PEM.parse::<p256::PublicKey>().unwrap();\n\n    // Ensure key parses equivalently to DER\n    let der_key = p256::PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    assert_eq!(public_key, der_key);\n}",
    "display_name": "decode_pkcs8_public_key_from_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/pkcs8.rs",
    "relative_path": "p256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/projective_add_vs_double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/double"
    ],
    "body": "    fn projective_add_vs_double() {\n        let generator = ProjectivePoint::GENERATOR;\n\n        let r1 = generator + &generator;\n        let r2 = generator.double();\n        assert_eq!(r1, r2);\n\n        let r1 = (generator + &generator) + &(generator + &generator);\n        let r2 = generator.double().double();\n        assert_eq!(r1, r2);\n    }",
    "display_name": "projective_add_vs_double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/UpperHex/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        for b in &self.0[..] {\n            write!(f, \"{:02X}\", b)?;\n        }\n        Ok(())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/div_by_four",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_untwisted",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/scalar_mod_four",
      "0.14.0_pre.1 curve/scalar_mul/variable_base/variable_base",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_twisted",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Add/add"
    ],
    "body": "    pub fn scalar_mul(&self, scalar: &Scalar) -> Self {\n        // Compute floor(s/4)\n        let mut scalar_div_four = *scalar;\n        scalar_div_four.div_by_four();\n\n        // Use isogeny and dual isogeny to compute phi^-1((s/4) * phi(P))\n        let partial_result = variable_base(&self.to_twisted(), &scalar_div_four).to_untwisted();\n        // Add partial result to (scalar mod 4) * P\n        partial_result.add(&self.scalar_mod_four(scalar))\n    }",
    "display_name": "scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Add>/add",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add(self, other: &AffinePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::add_mixed(&self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/AffineCoordinates/y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes_extended"
    ],
    "body": "    fn y(&self) -> Self::FieldRepr {\n        Ed448FieldBytes::from(self.y.to_bytes_extended())\n    }",
    "display_name": "y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub_assign(&mut self, rhs: AffinePoint) {\n        *self = ProjectivePoint::sub_mixed(self, &rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_add(\n    out1: &mut fiat_p192_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p192_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p192_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x7, &mut x8, 0x0, x1, 0x146bc9b1b4d22831);\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x9, &mut x10, x8, x3, 0xffffffff99def836);\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x11, &mut x12, x10, x5, 0xffffffffffffffff);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x13, &mut x14, x12, (x6 as u64), (0x0 as u64));\n    let mut x15: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x15, x14, x7, x1);\n    let mut x16: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x16, x14, x9, x3);\n    let mut x17: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x17, x14, x11, x5);\n    out1[0] = x15;\n    out1[1] = x16;\n    out1[2] = x17;\n}",
    "display_name": "fiat_p192_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_scalar_invert",
      "0.14.0_pre.8 bench_scalar_sub",
      "0.14.0_pre.8 bench_scalar_negate",
      "0.14.0_pre.8 bench_scalar_mul",
      "0.14.0_pre.8 bench_scalar_add"
    ],
    "body": "fn bench_scalar(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"scalar operations\");\n    bench_scalar_sub(&mut group);\n    bench_scalar_add(&mut group);\n    bench_scalar_mul(&mut group);\n    bench_scalar_negate(&mut group);\n    bench_scalar_invert(&mut group);\n    group.finish();\n}",
    "display_name": "bench_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/tests/from_okm_edwards448",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes",
      "0.14.0_pre.1 field/element/impl/FieldElement/FromOkm/from_okm"
    ],
    "body": "    fn from_okm_edwards448() {\n        const DST: &[u8] = b\"QUUX-V01-CS02-with-edwards448_XOF:SHAKE256_ELL2_RO_\";\n        const MSGS: &[(&[u8], [u8; 56], [u8; 56])] = &[\n            (b\"\", hex!(\"0847c5ebf957d3370b1f98fde499fb3e659996d9fc9b5707176ade785ba72cd84b8a5597c12b1024be5f510fa5ba99642c4cec7f3f69d3e7\"), hex!(\"f8cbd8a7ae8c8deed071f3ac4b93e7cfcb8f1eac1645d699fd6d3881cb295a5d3006d9449ed7cad412a77a1fe61e84a9e41d59ef384d6f9a\")),\n            (b\"abc\", hex!(\"04d975cd938ab49be3e81703d6a57cca84ed80d2ff6d4756d3f22947fb5b70ab0231f0087cbfb4b7cae73b41b0c9396b356a4831d9a14322\"), hex!(\"2547ca887ac3db7b5fad3a098aa476e90078afe1358af6c63d677d6edfd2100bc004e0f5db94dd2560fc5b308e223241d00488c9ca6b0ef2\")),\n            (b\"abcdef0123456789\", hex!(\"10659ce25588db4e4be6f7c791a79eb21a7f24aaaca76a6ca3b83b80aaf95aa328fe7d569a1ac99f9cd216edf3915d72632f1a8b990e250c\"), hex!(\"9243e5b6c480683fd533e81f4a778349a309ce00bd163a29eb9fa8dbc8f549242bef33e030db21cffacd408d2c4264b93e476c6a8590e7aa\")),\n            (b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\", hex!(\"c80390020e578f009ead417029eff6cd0926110922db63ab98395e3bdfdd5d8a65b1a2b8d495dc8c5e59b7f3518731f7dfc0f93ace5dee4b\"), hex!(\"1c4dc6653a445bbef2add81d8e90a6c8591a788deb91d0d3f1519a2e4a460313041b77c1b0817f2e80b388e5c3e49f37d787dc1f85e4324a\")),\n            (b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", hex!(\"163c79ab0210a4b5e4f44fb19437ea965bf5431ab233ef16606f0b03c5f16a3feb7d46a5a675ce8f606e9c2bf74ee5336c54a1e54919f13f\"), hex!(\"f99666bde4995c4088333d6c2734687e815f80a99c6da02c47df4b51f6c9d9ed466b4fecf7d9884990a8e0d0be6907fa437e0b1a27f49265\")),\n        ];\n\n        for (msg, expected_u0, expected_u1) in MSGS {\n            let mut expander = <ExpandMsgXof<Shake256> as ExpandMsg<U32>>::expand_message(\n                &[msg],\n                &[DST],\n                (84 * 2).try_into().unwrap(),\n            )\n            .unwrap();\n            let mut data = Array::<u8, U84>::default();\n            expander.fill_bytes(&mut data);\n            let u0 = FieldElement::from_okm(&data);\n            let mut e_u0 = *expected_u0;\n            e_u0.reverse();\n            let mut e_u1 = *expected_u1;\n            e_u1.reverse();\n            assert_eq!(u0.to_bytes(), e_u0);\n            expander.fill_bytes(&mut data);\n            let u1 = FieldElement::from_okm(&data);\n            assert_eq!(u1.to_bytes(), e_u1);\n        }\n    }",
    "display_name": "from_okm_edwards448",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/r",
    "statement_type": "function",
    "deps": [],
    "body": "    fn r(&self) -> &FieldElement {\n        &self.r\n    }",
    "display_name": "r",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/SharedSecret/raw_secret_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn raw_secret_bytes(&self) -> &FieldBytes {\n        &self.secret_bytes\n    }",
    "display_name": "raw_secret_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_nonzero(out1: &mut u64, arg1: &[u64; 9]) {\n    let x1: u64 = ((arg1[0])\n        | ((arg1[1])\n            | ((arg1[2])\n                | ((arg1[3])\n                    | ((arg1[4]) | ((arg1[5]) | ((arg1[6]) | ((arg1[7]) | (arg1[8])))))))));\n    *out1 = x1;\n}",
    "display_name": "fiat_p521_scalar_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce_nonzero"
    ],
    "body": "    fn reduce_nonzero(w: U512) -> Self {\n        WideScalar(w).reduce_nonzero()\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/batch_invert_array",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn batch_invert_array() {\n        let k: Scalar = Scalar::random(&mut OsRng.unwrap_mut());\n        let l: Scalar = Scalar::random(&mut OsRng.unwrap_mut());\n\n        let expected = [k.invert().unwrap(), l.invert().unwrap()];\n        assert_eq!(\n            <Scalar as BatchInvert<_>>::batch_invert([k, l]).unwrap(),\n            expected\n        );\n    }",
    "display_name": "batch_invert_array",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert_unchecked"
    ],
    "body": "    pub fn invert(&self) -> CtOption<Self> {\n        CtOption::new(self.invert_unchecked(), !self.is_zero())\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_to_bytes(out1: &mut [u8; 24], arg1: &[u64; 3]) {\n    let x1: u64 = (arg1[2]);\n    let x2: u64 = (arg1[1]);\n    let x3: u64 = (arg1[0]);\n    let x4: u8 = ((x3 & (0xff as u64)) as u8);\n    let x5: u64 = (x3 >> 8);\n    let x6: u8 = ((x5 & (0xff as u64)) as u8);\n    let x7: u64 = (x5 >> 8);\n    let x8: u8 = ((x7 & (0xff as u64)) as u8);\n    let x9: u64 = (x7 >> 8);\n    let x10: u8 = ((x9 & (0xff as u64)) as u8);\n    let x11: u64 = (x9 >> 8);\n    let x12: u8 = ((x11 & (0xff as u64)) as u8);\n    let x13: u64 = (x11 >> 8);\n    let x14: u8 = ((x13 & (0xff as u64)) as u8);\n    let x15: u64 = (x13 >> 8);\n    let x16: u8 = ((x15 & (0xff as u64)) as u8);\n    let x17: u8 = ((x15 >> 8) as u8);\n    let x18: u8 = ((x2 & (0xff as u64)) as u8);\n    let x19: u64 = (x2 >> 8);\n    let x20: u8 = ((x19 & (0xff as u64)) as u8);\n    let x21: u64 = (x19 >> 8);\n    let x22: u8 = ((x21 & (0xff as u64)) as u8);\n    let x23: u64 = (x21 >> 8);\n    let x24: u8 = ((x23 & (0xff as u64)) as u8);\n    let x25: u64 = (x23 >> 8);\n    let x26: u8 = ((x25 & (0xff as u64)) as u8);\n    let x27: u64 = (x25 >> 8);\n    let x28: u8 = ((x27 & (0xff as u64)) as u8);\n    let x29: u64 = (x27 >> 8);\n    let x30: u8 = ((x29 & (0xff as u64)) as u8);\n    let x31: u8 = ((x29 >> 8) as u8);\n    let x32: u8 = ((x1 & (0xff as u64)) as u8);\n    let x33: u64 = (x1 >> 8);\n    let x34: u8 = ((x33 & (0xff as u64)) as u8);\n    let x35: u64 = (x33 >> 8);\n    let x36: u8 = ((x35 & (0xff as u64)) as u8);\n    let x37: u64 = (x35 >> 8);\n    let x38: u8 = ((x37 & (0xff as u64)) as u8);\n    let x39: u64 = (x37 >> 8);\n    let x40: u8 = ((x39 & (0xff as u64)) as u8);\n    let x41: u64 = (x39 >> 8);\n    let x42: u8 = ((x41 & (0xff as u64)) as u8);\n    let x43: u64 = (x41 >> 8);\n    let x44: u8 = ((x43 & (0xff as u64)) as u8);\n    let x45: u8 = ((x43 >> 8) as u8);\n    out1[0] = x4;\n    out1[1] = x6;\n    out1[2] = x8;\n    out1[3] = x10;\n    out1[4] = x12;\n    out1[5] = x14;\n    out1[6] = x16;\n    out1[7] = x17;\n    out1[8] = x18;\n    out1[9] = x20;\n    out1[10] = x22;\n    out1[11] = x24;\n    out1[12] = x26;\n    out1[13] = x28;\n    out1[14] = x30;\n    out1[15] = x31;\n    out1[16] = x32;\n    out1[17] = x34;\n    out1[18] = x36;\n    out1[19] = x38;\n    out1[20] = x40;\n    out1[21] = x42;\n    out1[22] = x44;\n    out1[23] = x45;\n}",
    "display_name": "fiat_p192_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(self) -> [u8; 56] {\n        let mut bytes = [0u8; 56];\n        bytes.copy_from_slice(&self.0.retrieve().to_le_bytes()[..56]);\n        bytes\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        U256::from_be_byte_array(*field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/lib.rs",
    "relative_path": "k256/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/negate",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn negate(&self) -> Self {\n        Self(self.0.neg_mod(&ORDER))\n    }",
    "display_name": "negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p224_opp(\n    out1: &mut fiat_p224_montgomery_domain_field_element,\n    arg1: &fiat_p224_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x10,\n        &mut x11,\n        0x0,\n        x1,\n        (((x9 & (0x1 as u64)) as fiat_p224_u1) as u64),\n    );\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0xffffffff00000000));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x16, &mut x17, x15, x7, (x9 & 0xffffffff));\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_p224_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Add>/add",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add(self, other: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::add(&self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Field/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut seed = WideScalarBytes::default();\n        rng.try_fill_bytes(&mut seed)?;\n        Ok(Scalar::from_bytes_mod_order_wide(&seed))\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        let mut acc = Scalar::ZERO;\n        for s in iter {\n            acc += s;\n        }\n        acc\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/as_affine",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_affine(&self) -> &AffinePoint<BignP256> {\n        &self.point\n    }",
    "display_name": "as_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_opp(\n    out1: &mut fiat_p384_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p384_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x9, &mut x10, x8, (0x0 as u64), (arg1[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x11, &mut x12, x10, (0x0 as u64), (arg1[5]));\n    let mut x13: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x13, x12, (0x0 as u64), 0xffffffffffffffff);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x14, &mut x15, 0x0, x1, (x13 & 0xecec196accc52973));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x3, (x13 & 0x581a0db248b0a77a));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x18, &mut x19, x17, x5, (x13 & 0xc7634d81f4372ddf));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x20, &mut x21, x19, x7, x13);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x22, &mut x23, x21, x9, x13);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x24, &mut x25, x23, x11, x13);\n    out1[0] = x14;\n    out1[1] = x16;\n    out1[2] = x18;\n    out1[3] = x20;\n    out1[4] = x22;\n    out1[5] = x24;\n}",
    "display_name": "fiat_p384_scalar_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Curve/batch_normalize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/batch_normalize_generic"
    ],
    "body": "    fn batch_normalize(projective: &[Self], affine: &mut [Self::AffineRepr]) {\n        assert_eq!(projective.len(), affine.len());\n        let mut zs = vec![FieldElement::ONE; projective.len()];\n        batch_normalize_generic(projective, zs.as_mut_slice(), affine);\n    }",
    "display_name": "batch_normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 ristretto/points/impl/CompressedRistretto/decode",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn decode(&self) -> Option<RistrettoPoint> {\n        todo!()\n    }",
    "display_name": "decode",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/ristretto/points.rs",
    "relative_path": "ed448-goldilocks/src/ristretto/points.rs",
    "file_name": "points.rs",
    "parent_folder": "ristretto"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 5],\n    out3: &mut [u64; 5],\n    out4: &mut [u64; 4],\n    out5: &mut [u64; 4],\n    arg1: u64,\n    arg2: &[u64; 5],\n    arg3: &[u64; 5],\n    arg4: &[u64; 4],\n    arg5: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_bign256_scalar_u1 = (((x1 >> 63) as fiat_bign256_scalar_u1)\n        & (((arg3[0]) & (0x1 as u64)) as fiat_bign256_scalar_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x12, &mut x13, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x14, &mut x15, x13, (0x0 as u64), (!(arg2[1])));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), (!(arg2[2])));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), (!(arg2[3])));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), (!(arg2[4])));\n    let mut x22: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x22, x3, (arg3[0]), x12);\n    let mut x23: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x23, x3, (arg3[1]), x14);\n    let mut x24: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x24, x3, (arg3[2]), x16);\n    let mut x25: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x25, x3, (arg3[3]), x18);\n    let mut x26: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x26, x3, (arg3[4]), x20);\n    let mut x27: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x27, x3, (arg4[0]), (arg5[0]));\n    let mut x28: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x28, x3, (arg4[1]), (arg5[1]));\n    let mut x29: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x29, x3, (arg4[2]), (arg5[2]));\n    let mut x30: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x30, x3, (arg4[3]), (arg5[3]));\n    let mut x31: u64 = 0;\n    let mut x32: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x31, &mut x32, 0x0, x27, x27);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x33, &mut x34, x32, x28, x28);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x35, &mut x36, x34, x29, x29);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x37, &mut x38, x36, x30, x30);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x39, &mut x40, 0x0, x31, 0x7e5abf99263d6607);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x41, &mut x42, x40, x33, 0xd95c8ed60dfb4dfc);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x43, &mut x44, x42, x35, 0xffffffffffffffff);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x45, &mut x46, x44, x37, 0xffffffffffffffff);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x47, &mut x48, x46, (x38 as u64), (0x0 as u64));\n    let x49: u64 = (arg4[3]);\n    let x50: u64 = (arg4[2]);\n    let x51: u64 = (arg4[1]);\n    let x52: u64 = (arg4[0]);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x53, &mut x54, 0x0, (0x0 as u64), x52);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x55, &mut x56, x54, (0x0 as u64), x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x57, &mut x58, x56, (0x0 as u64), x50);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x59, &mut x60, x58, (0x0 as u64), x49);\n    let mut x61: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x61, x60, (0x0 as u64), 0xffffffffffffffff);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x53, (x61 & 0x7e5abf99263d6607));\n    let mut x64: u64 = 0;\n    let mut x65: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x55, (x61 & 0xd95c8ed60dfb4dfc));\n    let mut x66: u64 = 0;\n    let mut x67: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x57, x61);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x59, x61);\n    let mut x70: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x70, x3, (arg5[0]), x62);\n    let mut x71: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x71, x3, (arg5[1]), x64);\n    let mut x72: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x72, x3, (arg5[2]), x66);\n    let mut x73: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x73, x3, (arg5[3]), x68);\n    let x74: fiat_bign256_scalar_u1 = ((x22 & (0x1 as u64)) as fiat_bign256_scalar_u1);\n    let mut x75: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x75, x74, (0x0 as u64), x7);\n    let mut x76: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x76, x74, (0x0 as u64), x8);\n    let mut x77: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x77, x74, (0x0 as u64), x9);\n    let mut x78: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x78, x74, (0x0 as u64), x10);\n    let mut x79: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x79, x74, (0x0 as u64), x11);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x80, &mut x81, 0x0, x22, x75);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x23, x76);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x24, x77);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x25, x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x26, x79);\n    let mut x90: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x90, x74, (0x0 as u64), x27);\n    let mut x91: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x91, x74, (0x0 as u64), x28);\n    let mut x92: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x92, x74, (0x0 as u64), x29);\n    let mut x93: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x93, x74, (0x0 as u64), x30);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x94, &mut x95, 0x0, x70, x90);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x71, x91);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x72, x92);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x73, x93);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x102, &mut x103, 0x0, x94, 0x7e5abf99263d6607);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x104, &mut x105, x103, x96, 0xd95c8ed60dfb4dfc);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x106, &mut x107, x105, x98, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x108, &mut x109, x107, x100, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x110, &mut x111, x109, (x101 as u64), (0x0 as u64));\n    let mut x112: u64 = 0;\n    let mut x113: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x112, &mut x113, 0x0, x6, (0x1 as u64));\n    let x114: u64 = ((x80 >> 1) | ((x82 << 63) & 0xffffffffffffffff));\n    let x115: u64 = ((x82 >> 1) | ((x84 << 63) & 0xffffffffffffffff));\n    let x116: u64 = ((x84 >> 1) | ((x86 << 63) & 0xffffffffffffffff));\n    let x117: u64 = ((x86 >> 1) | ((x88 << 63) & 0xffffffffffffffff));\n    let x118: u64 = ((x88 & 0x8000000000000000) | (x88 >> 1));\n    let mut x119: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x119, x48, x39, x31);\n    let mut x120: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x120, x48, x41, x33);\n    let mut x121: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x121, x48, x43, x35);\n    let mut x122: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x122, x48, x45, x37);\n    let mut x123: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x123, x111, x102, x94);\n    let mut x124: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x124, x111, x104, x96);\n    let mut x125: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x125, x111, x106, x98);\n    let mut x126: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x126, x111, x108, x100);\n    *out1 = x112;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out3[0] = x114;\n    out3[1] = x115;\n    out3[2] = x116;\n    out3[3] = x117;\n    out3[4] = x118;\n    out4[0] = x119;\n    out4[1] = x120;\n    out4[2] = x121;\n    out4[3] = x122;\n    out5[0] = x123;\n    out5[1] = x124;\n    out5[2] = x125;\n    out5[3] = x126;\n}",
    "display_name": "fiat_bign256_scalar_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/as_affine",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_affine(&self) -> &AffinePoint {\n        self.public_key.as_affine()\n    }",
    "display_name": "as_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/to_edwards",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_edwards(self) -> EdwardsPoint {\n        self.point\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/from_slice",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<Self> {\n        SignatureBytes::try_from(bytes)\n            .map_err(|_| Error::new())?\n            .try_into()\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/repeated_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn repeated_add() {\n        let mut r = FieldElement::ONE;\n        for i in 0..DBL_TEST_VECTORS.len() {\n            assert_eq!(r.to_bytes(), DBL_TEST_VECTORS[i]);\n            r = (r + &r).normalize();\n        }\n    }",
    "display_name": "repeated_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Vec/From/from"
    ],
    "body": "    fn from(scalar: Scalar) -> Vec<u8> {\n        Self::from(&scalar)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/tests/test_negation",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/add",
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/negate",
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/is_on_curve",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_affine"
    ],
    "body": "    fn test_negation() {\n        use crate::TWISTED_EDWARDS_BASE_POINT;\n        let a = TWISTED_EDWARDS_BASE_POINT.to_affine();\n        assert!(a.is_on_curve());\n\n        let neg_a = a.negate();\n        let got = neg_a.add(&a);\n        assert!(got == AffinePoint::IDENTITY);\n    }",
    "display_name": "test_negation",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "affine/impl/AffinePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/From>/from"
    ],
    "body": "    fn mul(self, scalar: S) -> ProjectivePoint<C> {\n        ProjectivePoint::<C>::from(self) * scalar\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_add(\n    out1: &mut fiat_p384_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p384_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p384_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x9, &mut x10, x8, (arg1[4]), (arg2[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x11, &mut x12, x10, (arg1[5]), (arg2[5]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x13, &mut x14, 0x0, x1, 0xecec196accc52973);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x15, &mut x16, x14, x3, 0x581a0db248b0a77a);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x17, &mut x18, x16, x5, 0xc7634d81f4372ddf);\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x19, &mut x20, x18, x7, 0xffffffffffffffff);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x21, &mut x22, x20, x9, 0xffffffffffffffff);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x23, &mut x24, x22, x11, 0xffffffffffffffff);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x25, &mut x26, x24, (x12 as u64), (0x0 as u64));\n    let mut x27: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x27, x26, x13, x1);\n    let mut x28: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x28, x26, x15, x3);\n    let mut x29: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x29, x26, x17, x5);\n    let mut x30: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x30, x26, x19, x7);\n    let mut x31: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x31, x26, x21, x9);\n    let mut x32: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x32, x26, x23, x11);\n    out1[0] = x27;\n    out1[1] = x28;\n    out1[2] = x29;\n    out1[3] = x30;\n    out1[4] = x31;\n    out1[5] = x32;\n}",
    "display_name": "fiat_p384_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/sub_extended",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn sub_extended(&self, other: &ExtendedPoint) -> ExtensiblePoint {\n        let A = self.X * other.X;\n        let B = self.Y * other.Y;\n        let C = self.T1 * self.T2 * other.T * FieldElement::TWISTED_D;\n        let D = self.Z * other.Z;\n        let E = (self.X + self.Y) * (other.Y - other.X) + A - B;\n        let F = D + C;\n        let G = D - C;\n        let H = B - A;\n        ExtensiblePoint {\n            X: E * F,\n            Y: G * H,\n            T1: E,\n            T2: H,\n            Z: F * G,\n        }\n    }",
    "display_name": "sub_extended",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 benches",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_scalar",
      "0.14.0_pre.8 bench_point",
      "0.14.0_pre.8 bench_field_element"
    ],
    "body": "criterion_group!(benches, bench_field_element);\ncriterion_main!(benches);",
    "display_name": "benches",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/field.rs",
    "relative_path": "p521/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_montgomery"
    ],
    "body": "    pub(crate) const fn from_uint_unchecked(w: U256) -> Self {\n        Self(w).to_montgomery()\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/invert"
    ],
    "body": "    pub(crate) fn to_affine(self) -> AffinePoint {\n        // Points to consider:\n        // - All points where Z=0, translate to (0,0)\n        // - The identity point has z=1, so it is not a problem\n\n        let INV_Z = self.Z.invert();\n\n        let x = self.X * INV_Z;\n        let y = self.Y * INV_Z;\n\n        AffinePoint { x, y }\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/&ProjectivePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub(self, other: &ProjectivePoint) -> ProjectivePoint {\n        ProjectivePoint::sub(self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce_impl",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/muladd",
      "0.14.0_pre.8 arithmetic/scalar/wide/muladd_fast",
      "0.14.0_pre.8 arithmetic/scalar/wide/sumadd",
      "0.14.0_pre.8 arithmetic/scalar/wide/sumadd_fast"
    ],
    "body": "    fn reduce_impl(&self, modulus_minus_one: bool) -> Scalar {\n        let neg_modulus0 = if modulus_minus_one {\n            NEG_MODULUS[0] + 1\n        } else {\n            NEG_MODULUS[0]\n        };\n        let modulus = if modulus_minus_one {\n            ORDER.wrapping_sub(&U256::ONE)\n        } else {\n            ORDER\n        };\n\n        let w = self.0.to_words();\n        let n0 = w[4];\n        let n1 = w[5];\n        let n2 = w[6];\n        let n3 = w[7];\n\n        // Reduce 512 bits into 385.\n        // m[0..6] = self[0..3] + n[0..3] * neg_modulus.\n        let c0 = w[0];\n        let c1 = 0;\n        let c2 = 0;\n        let (c0, c1) = muladd_fast(n0, neg_modulus0, c0, c1);\n        let (m0, c0, c1) = (c0, c1, 0);\n        let (c0, c1) = sumadd_fast(w[1], c0, c1);\n        let (c0, c1, c2) = muladd(n1, neg_modulus0, c0, c1, c2);\n        let (c0, c1, c2) = muladd(n0, NEG_MODULUS[1], c0, c1, c2);\n        let (m1, c0, c1, c2) = (c0, c1, c2, 0);\n        let (c0, c1, c2) = sumadd(w[2], c0, c1, c2);\n        let (c0, c1, c2) = muladd(n2, neg_modulus0, c0, c1, c2);\n        let (c0, c1, c2) = muladd(n1, NEG_MODULUS[1], c0, c1, c2);\n        let (c0, c1, c2) = sumadd(n0, c0, c1, c2);\n        let (m2, c0, c1, c2) = (c0, c1, c2, 0);\n        let (c0, c1, c2) = sumadd(w[3], c0, c1, c2);\n        let (c0, c1, c2) = muladd(n3, neg_modulus0, c0, c1, c2);\n        let (c0, c1, c2) = muladd(n2, NEG_MODULUS[1], c0, c1, c2);\n        let (c0, c1, c2) = sumadd(n1, c0, c1, c2);\n        let (m3, c0, c1, c2) = (c0, c1, c2, 0);\n        let (c0, c1, c2) = muladd(n3, NEG_MODULUS[1], c0, c1, c2);\n        let (c0, c1, c2) = sumadd(n2, c0, c1, c2);\n        let (m4, c0, c1, _c2) = (c0, c1, c2, 0);\n        let (c0, c1) = sumadd_fast(n3, c0, c1);\n        let (m5, c0, _c1) = (c0, c1, 0);\n        debug_assert!(c0 <= 1);\n        let m6 = c0;\n\n        // Reduce 385 bits into 258.\n        // p[0..4] = m[0..3] + m[4..6] * neg_modulus.\n        let c0 = m0;\n        let c1 = 0;\n        let c2 = 0;\n        let (c0, c1) = muladd_fast(m4, neg_modulus0, c0, c1);\n        let (p0, c0, c1) = (c0, c1, 0);\n        let (c0, c1) = sumadd_fast(m1, c0, c1);\n        let (c0, c1, c2) = muladd(m5, neg_modulus0, c0, c1, c2);\n        let (c0, c1, c2) = muladd(m4, NEG_MODULUS[1], c0, c1, c2);\n        let (p1, c0, c1) = (c0, c1, 0);\n        let (c0, c1, c2) = sumadd(m2, c0, c1, c2);\n        let (c0, c1, c2) = muladd(m6, neg_modulus0, c0, c1, c2);\n        let (c0, c1, c2) = muladd(m5, NEG_MODULUS[1], c0, c1, c2);\n        let (c0, c1, c2) = sumadd(m4, c0, c1, c2);\n        let (p2, c0, c1, _c2) = (c0, c1, c2, 0);\n        let (c0, c1) = sumadd_fast(m3, c0, c1);\n        let (c0, c1) = muladd_fast(m6, NEG_MODULUS[1], c0, c1);\n        let (c0, c1) = sumadd_fast(m5, c0, c1);\n        let (p3, c0, _c1) = (c0, c1, 0);\n        let p4 = c0 + m6;\n        debug_assert!(p4 <= 2);\n\n        // Reduce 258 bits into 256.\n        // r[0..3] = p[0..3] + p[4] * neg_modulus.\n        let mut c = (p0 as u128) + (neg_modulus0 as u128) * (p4 as u128);\n        let r0 = (c & 0xFFFFFFFFFFFFFFFFu128) as u64;\n        c >>= 64;\n        c += (p1 as u128) + (NEG_MODULUS[1] as u128) * (p4 as u128);\n        let r1 = (c & 0xFFFFFFFFFFFFFFFFu128) as u64;\n        c >>= 64;\n        c += (p2 as u128) + (p4 as u128);\n        let r2 = (c & 0xFFFFFFFFFFFFFFFFu128) as u64;\n        c >>= 64;\n        c += p3 as u128;\n        let r3 = (c & 0xFFFFFFFFFFFFFFFFu128) as u64;\n        c >>= 64;\n\n        // Final reduction of r.\n        let r = U256::from([r0, r1, r2, r3]);\n        let (r2, underflow) = r.borrowing_sub(&modulus, Limb::ZERO);\n        let high_bit = Choice::from(c as u8);\n        let underflow = Choice::from((underflow.0 >> 63) as u8);\n        Scalar(U256::conditional_select(&r, &r2, !underflow | high_bit))\n    }",
    "display_name": "reduce_impl",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/TryFrom, der::asn1::BitStringRef>>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/from_bytes"
    ],
    "body": "    fn try_from(spki: &pkcs8::SubjectPublicKeyInfoRef<'_>) -> pkcs8::spki::Result<Self> {\n        spki.algorithm.assert_oids(ALGORITHM_OID, BignP256::OID)?;\n\n        let public_key_bytes = spki\n            .subject_public_key\n            .as_bytes()\n            .ok_or_else(|| der::Tag::BitString.value_error().to_error())?;\n\n        Self::from_bytes(public_key_bytes).map_err(|_| pkcs8::spki::Error::KeyMalformed)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/DigestVerifier/verify_digest"
    ],
    "body": "    fn multipart_verify(&self, msg: &[&[u8]], signature: &Signature) -> Result<()> {\n        let mut digest = Sha256::new();\n        msg.iter().for_each(|slice| digest.update(slice));\n        self.verify_digest(digest, signature)\n    }",
    "display_name": "multipart_verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/impl/fiat_p384_scalar_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre ecdsa/tests/wycheproof/wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "        ecdsa_core::new_wycheproof_test!(wycheproof, \"wycheproof\", NistP224);\n    }\n}",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/ecdsa.rs",
    "relative_path": "p224/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PartialOrd/partial_cmp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Ord/cmp"
    ],
    "body": "    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n        Some(self.cmp(other))\n    }",
    "display_name": "partial_cmp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_bign256_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p224_scalar_u1,\n    arg1: fiat_p224_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_p224_scalar_i1 = ((x1 >> 64) as fiat_p224_scalar_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p224_scalar_i2) - (x2 as fiat_p224_scalar_i2)) as fiat_p224_scalar_u1);\n}",
    "display_name": "fiat_p224_scalar_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> CompressedDecaf {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_even",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    pub fn is_even(&self) -> Choice {\n        !self.is_odd()\n    }",
    "display_name": "is_even",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_hex",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    pub(crate) const fn from_hex(hex: &str) -> Self {\n        Self::from_uint_unchecked(U576::from_be_hex(hex))\n    }",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre test_signature_consistency",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre create_test_signing_key",
      "0.14.0_pre dsa/signing/impl/SigningKey/verifying_key",
      "0.14.0_pre dsa/impl/Signature/to_bytes",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/Verifier/verify"
    ],
    "body": "    fn test_signature_consistency(\n        msg1 in any::<Vec<u8>>(),\n        msg2 in any::<Vec<u8>>()\n    ) {\n        let sk = create_test_signing_key();\n        let sig1 = sk.sign(&msg1);\n        let sig2 = sk.sign(&msg1); // Same message\n        let sig3 = sk.sign(&msg2); // Different message\n\n        // Same message should verify with both signatures\n        prop_assert!(sk.verifying_key().verify(&msg1, &sig1).is_ok());\n        prop_assert!(sk.verifying_key().verify(&msg1, &sig2).is_ok());\n\n        // Different messages should have different signatures\n        if msg1 != msg2 {\n            prop_assert_ne!(sig1.to_bytes(), sig3.to_bytes());\n        }\n    }",
    "display_name": "test_signature_consistency",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/dsa_extended.rs",
    "relative_path": "sm2/tests/dsa_extended.rs",
    "file_name": "dsa_extended.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from"
    ],
    "body": "    fn negate() {\n        let zero_neg = -Scalar::ZERO;\n        assert_eq!(zero_neg, Scalar::ZERO);\n\n        let m = Scalar::modulus_as_biguint();\n        let one = 1.to_biguint().unwrap();\n        let m_minus_one = &m - &one;\n        let m_by_2 = &m >> 1;\n\n        let one_neg = -Scalar::ONE;\n        assert_eq!(one_neg, Scalar::from(&m_minus_one));\n\n        let frac_modulus_2_neg = -Scalar::from(&m_by_2);\n        let frac_modulus_2_plus_one = Scalar::from(&m_by_2 + &one);\n        assert_eq!(frac_modulus_2_neg, frac_modulus_2_plus_one);\n\n        let modulus_minus_one_neg = -Scalar::from(&m - &one);\n        assert_eq!(modulus_minus_one_neg, Scalar::ONE);\n    }",
    "display_name": "negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_addcarryx_u57",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_addcarryx_u57(\n    out1: &mut u64,\n    out2: &mut fiat_p521_u1,\n    arg1: fiat_p521_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u64 = (((arg1 as u64) + arg2) + arg3);\n    let x2: u64 = (x1 & 0x1ffffffffffffff);\n    let x3: fiat_p521_u1 = ((x1 >> 57) as fiat_p521_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p521_addcarryx_u57",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce",
      "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/decode_field_bytes"
    ],
    "body": "    fn reduce_bytes(bytes: &FieldBytes) -> Self {\n        let w = <U256 as FieldBytesEncoding<Sm2>>::decode_field_bytes(bytes);\n        Self::reduce(w)\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::co",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::co"
    ],
    "body": "    fn from(secret_scalar: SecretKey) -> Self {\n        Self::from(&secret_scalar)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/LowerHex/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        for b in &self.0[..] {\n            write!(f, \"{:02x}\", b)?;\n        }\n        Ok(())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_sm2_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/prehash_signer_verification_with_sha256",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    fn prehash_signer_verification_with_sha256() {\n        // The following test vector adapted from the FIPS 186-4 ECDSA test vectors\n        // (P-384, SHA-256, from `SigGen.txt` in `186-4ecdsatestvectors.zip`)\n        // <https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/digital-signatures>\n        let verifier = VerifyingKey::from_affine(\n            AffinePoint::from_encoded_point(\n                &EncodedPoint::from_affine_coordinates(\n                    &hex!(\"0400193b21f07cd059826e9453d3e96dd145041c97d49ff6b7047f86bb0b0439e909274cb9c282bfab88674c0765bc75\").into(),\n                    &hex! (\"f70d89c52acbc70468d2c5ae75c76d7f69b76af62dcf95e99eba5dd11adf8f42ec9a425b0c5ec98e2f234a926b82a147\").into(),\n                    false,\n                ),\n            ).unwrap()\n        ).unwrap();\n        let signature = Signature::from_scalars(\n            hex!(\"b11db00cdaf53286d4483f38cd02785948477ed7ebc2ad609054551da0ab0359978c61851788aa2ec3267946d440e878\"),\n            hex!(\"16007873c5b0604ce68112a8fee973e8e2b6e3319c683a762ff5065a076512d7c98b27e74b7887671048ac027df8cbf2\"),\n        ).unwrap();\n        let result = verifier.verify_prehash(\n            &hex!(\"bbbd0a5f645d3fda10e288d172b299455f9dff00e0fbc2833e18cd017d7f3ed1\"),\n            &signature,\n        );\n        assert!(result.is_ok());\n    }",
    "display_name": "prehash_signer_verification_with_sha256",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/ecdsa.rs",
    "relative_path": "p384/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_cmovznz_u64(out1: &mut u64, arg1: fiat_p384_u1, arg2: u64, arg3: u64) {\n    let x1: fiat_p384_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_p384_i2) - (x1 as fiat_p384_i2)) as fiat_p384_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_p384_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/dev/biguint_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn biguint_to_bytes(x: &BigUint) -> [u8; 32] {\n    let mask = BigUint::from(u8::MAX);\n    let mut bytes = [0u8; 32];\n    for i in 0..32 {\n        bytes[i] = ((x >> ((31 - i) * 8)) as BigUint & &mask).to_u8().unwrap();\n    }\n    bytes\n}",
    "display_name": "biguint_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/dev.rs",
    "relative_path": "k256/src/arithmetic/dev.rs",
    "file_name": "dev.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 compact_to_uncompact",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "fn compact_to_uncompact() {\n    let pubkey = EncodedPoint::from_bytes(COMPACT_BASEPOINT).unwrap();\n    assert!(pubkey.is_compact());\n\n    let point = AffinePoint::from_encoded_point(&pubkey).unwrap();\n    // Do not do compact encoding as we want to keep uncompressed point\n    let res = point.to_encoded_point(false);\n    assert_eq!(res.as_bytes(), UNCOMPACT_BASEPOINT);\n}",
    "display_name": "compact_to_uncompact",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub_mixed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/Neg/neg",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn sub_mixed(&self, other: &AffinePoint) -> ProjectivePoint {\n        self.add_mixed(&other.neg())\n    }",
    "display_name": "sub_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/From>>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(p: NonIdentity<ProjectivePoint<C>>) -> Self {\n        p.to_point()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_msat(out1: &mut [u64; 10]) {\n    out1[0] = 0xbb6fb71e91386409;\n    out1[1] = 0x3bb5c9b8899c47ae;\n    out1[2] = 0x7fcc0148f709a5d0;\n    out1[3] = 0x51868783bf2f966b;\n    out1[4] = 0xfffffffffffffffa;\n    out1[5] = 0xffffffffffffffff;\n    out1[6] = 0xffffffffffffffff;\n    out1[7] = 0xffffffffffffffff;\n    out1[8] = 0x1ff;\n    out1[9] = (0x0 as u64);\n}",
    "display_name": "fiat_p521_scalar_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_sm2_scalar_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/EncodedPoint::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/EncodedPoint::FieldBytesSize>/From/from"
    ],
    "body": "    fn from(affine_point: AffinePoint) -> EncodedPoint {\n        EncodedPoint::from(&affine_point)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point_lincomb",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/LinearCombination/lincomb",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn bench_point_lincomb<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let p = ProjectivePoint::GENERATOR;\n    let m = hex!(\"AA5E28D6A97A2479A65527F7290311A3624D4CC0FA1578598EE3C2613BF99522\");\n    let s = Scalar::from_repr(m.into()).unwrap();\n    group.bench_function(\"lincomb via mul+add\", |b| {\n        b.iter(|| black_box(p) * black_box(s) + black_box(p) * black_box(s))\n    });\n    group.bench_function(\"lincomb()\", |b| {\n        b.iter(|| {\n            ProjectivePoint::lincomb(&[(black_box(p), black_box(s)), (black_box(p), black_box(s))])\n        })\n    });\n}",
    "display_name": "bench_point_lincomb",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_point_mul<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let p = ProjectivePoint::GENERATOR;\n    let m = test_scalar_x();\n    let s = Scalar::from_repr(m.into()).unwrap();\n    group.bench_function(\"point-scalar mul\", |b| b.iter(|| p * s));\n}",
    "display_name": "bench_point_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_even",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_odd"
    ],
    "body": "    pub fn is_even(&self) -> Choice {\n        !self.is_odd()\n    }",
    "display_name": "is_even",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce_nonzero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce_impl"
    ],
    "body": "    pub(super) fn reduce_nonzero(&self) -> Scalar {\n        self.reduce_impl(true) + Scalar::ONE\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/mul_single",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize_weak"
    ],
    "body": "    fn add(&self, other: &ProjectivePoint) -> ProjectivePoint {\n        // We implement the complete addition formula from Renes-Costello-Batina 2015\n        // (https://eprint.iacr.org/2015/1060 Algorithm 7).\n\n        let xx = self.x * &other.x;\n        let yy = self.y * &other.y;\n        let zz = self.z * &other.z;\n\n        let n_xx_yy = (xx + &yy).negate(2);\n        let n_yy_zz = (yy + &zz).negate(2);\n        let n_xx_zz = (xx + &zz).negate(2);\n        let xy_pairs = ((self.x + &self.y) * &(other.x + &other.y)) + &n_xx_yy;\n        let yz_pairs = ((self.y + &self.z) * &(other.y + &other.z)) + &n_yy_zz;\n        let xz_pairs = ((self.x + &self.z) * &(other.x + &other.z)) + &n_xx_zz;\n\n        let bzz = zz.mul_single(CURVE_EQUATION_B_SINGLE);\n        let bzz3 = (bzz.double() + &bzz).normalize_weak();\n\n        let yy_m_bzz3 = yy + &bzz3.negate(1);\n        let yy_p_bzz3 = yy + &bzz3;\n\n        let byz = &yz_pairs\n            .mul_single(CURVE_EQUATION_B_SINGLE)\n            .normalize_weak();\n        let byz3 = (byz.double() + byz).normalize_weak();\n\n        let xx3 = xx.double() + &xx;\n        let bxx9 = (xx3.double() + &xx3)\n            .normalize_weak()\n            .mul_single(CURVE_EQUATION_B_SINGLE)\n            .normalize_weak();\n\n        let new_x = ((xy_pairs * &yy_m_bzz3) + &(byz3 * &xz_pairs).negate(1)).normalize_weak(); // m1\n        let new_y = ((yy_p_bzz3 * &yy_m_bzz3) + &(bxx9 * &xz_pairs)).normalize_weak();\n        let new_z = ((yz_pairs * &yy_p_bzz3) + &(xx3 * &xy_pairs)).normalize_weak();\n\n        ProjectivePoint {\n            x: new_x,\n            y: new_y,\n            z: new_z,\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &'b EdwardsPoint) {\n        *self = *self - _rhs;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl//u8; _//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/to_bytes"
    ],
    "body": "    fn from(signature: &Signature) -> SignatureBytes {\n        signature.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/hash_fuzzing",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/hash_with_defaults",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_on_curve",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_torsion_free"
    ],
    "body": "    fn hash_fuzzing() {\n        for _ in 0..25 {\n            let mut msg = [0u8; 64];\n            rand_core::OsRng.try_fill_bytes(&mut msg).unwrap();\n            let p = EdwardsPoint::hash_with_defaults(&msg);\n            assert_eq!(p.is_on_curve().unwrap_u8(), 1u8);\n            assert_eq!(p.is_torsion_free().unwrap_u8(), 1u8);\n        }\n    }",
    "display_name": "hash_fuzzing",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "projective/impl/&ProjectivePoint/Add>/add",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add(self, other: &AffinePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::add_mixed(self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> SignatureBytes {\n        let mut ret = [0; Self::BYTE_SIZE];\n        let (s0_bytes, s1_bytes) = ret.split_at_mut(Self::BYTE_SIZE / 3);\n        s0_bytes.copy_from_slice(&self.s0.to_bytes()[..16]);\n        s1_bytes.copy_from_slice(&self.s1.to_bytes());\n        ret\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/RandomizedPrehashSigner/sign_prehash_with_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/sign_prehash_rfc6979"
    ],
    "body": "    fn sign_prehash_with_rng<R: TryCryptoRng + ?Sized>(\n        &self,\n        rng: &mut R,\n        prehash: &[u8],\n    ) -> Result<Signature> {\n        let mut data = FieldBytes::default();\n        rng.try_fill_bytes(&mut data).map_err(|_| Error::new())?;\n        sign_prehash_rfc6979(&self.secret_scalar, prehash, &data)\n    }",
    "display_name": "sign_prehash_with_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "projective/impl/&ProjectivePoint/Sub>/sub",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub(self, other: &AffinePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::sub_mixed(self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 benches",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_point",
      "0.14.0_pre.8 bench_scalar",
      "0.14.0_pre.8 bench_field_element"
    ],
    "body": "criterion_group!(benches, bench_field_element);\ncriterion_main!(benches);",
    "display_name": "benches",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/field.rs",
    "relative_path": "p384/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_set_one(out1: &mut fiat_sm2_scalar_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0xac440bf6c62abedd;\n    out1[1] = 0x8dfc2094de39fad4;\n    out1[2] = (0x0 as u64);\n    out1[3] = 0x100000000;\n}",
    "display_name": "fiat_sm2_scalar_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_from_bytes(out1: &mut fiat_p521_tight_field_element, arg1: &[u8; 66]) {\n    let out1 = &mut out1.0;\n    let x1: u64 = ((((arg1[65]) as fiat_p521_u1) as u64) << 56);\n    let x2: u64 = (((arg1[64]) as u64) << 48);\n    let x3: u64 = (((arg1[63]) as u64) << 40);\n    let x4: u64 = (((arg1[62]) as u64) << 32);\n    let x5: u64 = (((arg1[61]) as u64) << 24);\n    let x6: u64 = (((arg1[60]) as u64) << 16);\n    let x7: u64 = (((arg1[59]) as u64) << 8);\n    let x8: u8 = (arg1[58]);\n    let x9: u64 = (((arg1[57]) as u64) << 50);\n    let x10: u64 = (((arg1[56]) as u64) << 42);\n    let x11: u64 = (((arg1[55]) as u64) << 34);\n    let x12: u64 = (((arg1[54]) as u64) << 26);\n    let x13: u64 = (((arg1[53]) as u64) << 18);\n    let x14: u64 = (((arg1[52]) as u64) << 10);\n    let x15: u64 = (((arg1[51]) as u64) << 2);\n    let x16: u64 = (((arg1[50]) as u64) << 52);\n    let x17: u64 = (((arg1[49]) as u64) << 44);\n    let x18: u64 = (((arg1[48]) as u64) << 36);\n    let x19: u64 = (((arg1[47]) as u64) << 28);\n    let x20: u64 = (((arg1[46]) as u64) << 20);\n    let x21: u64 = (((arg1[45]) as u64) << 12);\n    let x22: u64 = (((arg1[44]) as u64) << 4);\n    let x23: u64 = (((arg1[43]) as u64) << 54);\n    let x24: u64 = (((arg1[42]) as u64) << 46);\n    let x25: u64 = (((arg1[41]) as u64) << 38);\n    let x26: u64 = (((arg1[40]) as u64) << 30);\n    let x27: u64 = (((arg1[39]) as u64) << 22);\n    let x28: u64 = (((arg1[38]) as u64) << 14);\n    let x29: u64 = (((arg1[37]) as u64) << 6);\n    let x30: u64 = (((arg1[36]) as u64) << 56);\n    let x31: u64 = (((arg1[35]) as u64) << 48);\n    let x32: u64 = (((arg1[34]) as u64) << 40);\n    let x33: u64 = (((arg1[33]) as u64) << 32);\n    let x34: u64 = (((arg1[32]) as u64) << 24);\n    let x35: u64 = (((arg1[31]) as u64) << 16);\n    let x36: u64 = (((arg1[30]) as u64) << 8);\n    let x37: u8 = (arg1[29]);\n    let x38: u64 = (((arg1[28]) as u64) << 50);\n    let x39: u64 = (((arg1[27]) as u64) << 42);\n    let x40: u64 = (((arg1[26]) as u64) << 34);\n    let x41: u64 = (((arg1[25]) as u64) << 26);\n    let x42: u64 = (((arg1[24]) as u64) << 18);\n    let x43: u64 = (((arg1[23]) as u64) << 10);\n    let x44: u64 = (((arg1[22]) as u64) << 2);\n    let x45: u64 = (((arg1[21]) as u64) << 52);\n    let x46: u64 = (((arg1[20]) as u64) << 44);\n    let x47: u64 = (((arg1[19]) as u64) << 36);\n    let x48: u64 = (((arg1[18]) as u64) << 28);\n    let x49: u64 = (((arg1[17]) as u64) << 20);\n    let x50: u64 = (((arg1[16]) as u64) << 12);\n    let x51: u64 = (((arg1[15]) as u64) << 4);\n    let x52: u64 = (((arg1[14]) as u64) << 54);\n    let x53: u64 = (((arg1[13]) as u64) << 46);\n    let x54: u64 = (((arg1[12]) as u64) << 38);\n    let x55: u64 = (((arg1[11]) as u64) << 30);\n    let x56: u64 = (((arg1[10]) as u64) << 22);\n    let x57: u64 = (((arg1[9]) as u64) << 14);\n    let x58: u64 = (((arg1[8]) as u64) << 6);\n    let x59: u64 = (((arg1[7]) as u64) << 56);\n    let x60: u64 = (((arg1[6]) as u64) << 48);\n    let x61: u64 = (((arg1[5]) as u64) << 40);\n    let x62: u64 = (((arg1[4]) as u64) << 32);\n    let x63: u64 = (((arg1[3]) as u64) << 24);\n    let x64: u64 = (((arg1[2]) as u64) << 16);\n    let x65: u64 = (((arg1[1]) as u64) << 8);\n    let x66: u8 = (arg1[0]);\n    let x67: u64 = (x65 + (x66 as u64));\n    let x68: u64 = (x64 + x67);\n    let x69: u64 = (x63 + x68);\n    let x70: u64 = (x62 + x69);\n    let x71: u64 = (x61 + x70);\n    let x72: u64 = (x60 + x71);\n    let x73: u64 = (x59 + x72);\n    let x74: u64 = (x73 & 0x3ffffffffffffff);\n    let x75: u8 = ((x73 >> 58) as u8);\n    let x76: u64 = (x58 + (x75 as u64));\n    let x77: u64 = (x57 + x76);\n    let x78: u64 = (x56 + x77);\n    let x79: u64 = (x55 + x78);\n    let x80: u64 = (x54 + x79);\n    let x81: u64 = (x53 + x80);\n    let x82: u64 = (x52 + x81);\n    let x83: u64 = (x82 & 0x3ffffffffffffff);\n    let x84: u8 = ((x82 >> 58) as u8);\n    let x85: u64 = (x51 + (x84 as u64));\n    let x86: u64 = (x50 + x85);\n    let x87: u64 = (x49 + x86);\n    let x88: u64 = (x48 + x87);\n    let x89: u64 = (x47 + x88);\n    let x90: u64 = (x46 + x89);\n    let x91: u64 = (x45 + x90);\n    let x92: u64 = (x91 & 0x3ffffffffffffff);\n    let x93: u8 = ((x91 >> 58) as u8);\n    let x94: u64 = (x44 + (x93 as u64));\n    let x95: u64 = (x43 + x94);\n    let x96: u64 = (x42 + x95);\n    let x97: u64 = (x41 + x96);\n    let x98: u64 = (x40 + x97);\n    let x99: u64 = (x39 + x98);\n    let x100: u64 = (x38 + x99);\n    let x101: u64 = (x36 + (x37 as u64));\n    let x102: u64 = (x35 + x101);\n    let x103: u64 = (x34 + x102);\n    let x104: u64 = (x33 + x103);\n    let x105: u64 = (x32 + x104);\n    let x106: u64 = (x31 + x105);\n    let x107: u64 = (x30 + x106);\n    let x108: u64 = (x107 & 0x3ffffffffffffff);\n    let x109: u8 = ((x107 >> 58) as u8);\n    let x110: u64 = (x29 + (x109 as u64));\n    let x111: u64 = (x28 + x110);\n    let x112: u64 = (x27 + x111);\n    let x113: u64 = (x26 + x112);\n    let x114: u64 = (x25 + x113);\n    let x115: u64 = (x24 + x114);\n    let x116: u64 = (x23 + x115);\n    let x117: u64 = (x116 & 0x3ffffffffffffff);\n    let x118: u8 = ((x116 >> 58) as u8);\n    let x119: u64 = (x22 + (x118 as u64));\n    let x120: u64 = (x21 + x119);\n    let x121: u64 = (x20 + x120);\n    let x122: u64 = (x19 + x121);\n    let x123: u64 = (x18 + x122);\n    let x124: u64 = (x17 + x123);\n    let x125: u64 = (x16 + x124);\n    let x126: u64 = (x125 & 0x3ffffffffffffff);\n    let x127: u8 = ((x125 >> 58) as u8);\n    let x128: u64 = (x15 + (x127 as u64));\n    let x129: u64 = (x14 + x128);\n    let x130: u64 = (x13 + x129);\n    let x131: u64 = (x12 + x130);\n    let x132: u64 = (x11 + x131);\n    let x133: u64 = (x10 + x132);\n    let x134: u64 = (x9 + x133);\n    let x135: u64 = (x7 + (x8 as u64));\n    let x136: u64 = (x6 + x135);\n    let x137: u64 = (x5 + x136);\n    let x138: u64 = (x4 + x137);\n    let x139: u64 = (x3 + x138);\n    let x140: u64 = (x2 + x139);\n    let x141: u64 = (x1 + x140);\n    out1[0] = x74;\n    out1[1] = x83;\n    out1[2] = x92;\n    out1[3] = x100;\n    out1[4] = x108;\n    out1[5] = x117;\n    out1[6] = x126;\n    out1[7] = x134;\n    out1[8] = x141;\n}",
    "display_name": "fiat_p521_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 compressed_round_trip",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/PrimeCurveAffine/generator",
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "fn compressed_round_trip() {\n    let pubkey = EncodedPoint::from_bytes(COMPRESSED_BASEPOINT).unwrap();\n    let point = AffinePoint::from_encoded_point(&pubkey).unwrap();\n    assert_eq!(point, AffinePoint::generator());\n\n    let res: EncodedPoint = point.to_encoded_point(true);\n    assert_eq!(res, pubkey);\n}",
    "display_name": "compressed_round_trip",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero"
    ],
    "body": "    fn reduce_nonzero_bytes(bytes: &FieldBytes) -> Self {\n        Self::reduce_nonzero(U256::from_be_byte_array(*bytes))\n    }",
    "display_name": "reduce_nonzero_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/montgomery_reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/sub_inner"
    ],
    "body": "pub(super) const fn montgomery_reduce(lo: U256, hi: U256) -> U256 {\n    let lo = lo.as_limbs();\n    let hi = hi.as_limbs();\n\n    let a0 = lo[0];\n    let a1 = lo[1];\n    let a2 = lo[2];\n    let a3 = lo[3];\n    let a4 = hi[0];\n    let a5 = hi[1];\n    let a6 = hi[2];\n    let a7 = hi[3];\n\n    let modulus = MODULUS.as_limbs();\n\n    /*\n    let (a1, carry) = mac(a1, a0, modulus[1], a0);\n    let (a2, carry) = carrying_add(a2, 0, carry);\n    let (a3, carry) = mac(a3, a0, modulus[3], carry);\n    let (a4, carry2) = carrying_add(a4, 0, carry);\n\n    let (a2, carry) = mac(a2, a1, modulus[1], a1);\n    let (a3, carry) = carrying_add(a3, 0, carry);\n    let (a4, carry) = mac(a4, a1, modulus[3], carry);\n    let (a5, carry2) = carrying_add(a5, carry2, carry);\n\n    let (a3, carry) = mac(a3, a2, modulus[1], a2);\n    let (a4, carry) = carrying_add(a4, 0, carry);\n    let (a5, carry) = mac(a5, a2, modulus[3], carry);\n    let (a6, carry2) = carrying_add(a6, carry2, carry);\n\n    let (a4, carry) = mac(a4, a3, modulus[1], a3);\n    let (a5, carry) = carrying_add(a5, 0, carry);\n    let (a6, carry) = mac(a6, a3, modulus[3], carry);\n    let (a7, a8) = carrying_add(a7, carry2, carry);\n    */\n\n    let (a1, carry) = a0.carrying_mul_add(modulus[1], a1, a0);\n    let (a2, carry) = a2.carrying_add(Limb::ZERO, carry);\n    let (a3, carry) = a0.carrying_mul_add(modulus[3], a3, carry);\n    let (a4, carry2) = a4.carrying_add(Limb::ZERO, carry);\n\n    let (a2, carry) = a1.carrying_mul_add(modulus[1], a2, a1);\n    let (a3, carry) = a3.carrying_add(Limb::ZERO, carry);\n    let (a4, carry) = a1.carrying_mul_add(modulus[3], a4, carry);\n    let (a5, carry2) = a5.carrying_add(carry2, carry);\n\n    let (a3, carry) = a2.carrying_mul_add(modulus[1], a3, a2);\n    let (a4, carry) = a4.carrying_add(Limb::ZERO, carry);\n    let (a5, carry) = a2.carrying_mul_add(modulus[3], a5, carry);\n    let (a6, carry2) = a6.carrying_add(carry2, carry);\n\n    let (a4, carry) = a3.carrying_mul_add(modulus[1], a4, a3);\n    let (a5, carry) = a5.carrying_add(Limb::ZERO, carry);\n    let (a6, carry) = a3.carrying_mul_add(modulus[3], a6, carry);\n    let (a7, a8) = a7.carrying_add(carry2, carry);\n\n    // Result may be within MODULUS of the correct value\n    let (result, _) = sub_inner(\n        [a4, a5, a6, a7, a8],\n        [modulus[0], modulus[1], modulus[2], modulus[3], Limb::ZERO],\n    );\n    U256::new([result[0], result[1], result[2], result[3]])\n}",
    "display_name": "montgomery_reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field/field64.rs",
    "relative_path": "p256/src/arithmetic/field/field64.rs",
    "file_name": "field64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/Vec/From/from"
    ],
    "body": "    fn from(value: CompressedEdwardsY) -> Self {\n        Self::from(&value)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [],
    "body": "    fn product<I: Iterator<Item = &'a Scalar>>(iter: I) -> Self {\n        iter.copied().product()\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre decrypt_der_verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/new_with_mode",
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt_der"
    ],
    "body": "fn decrypt_der_verify() {\n    let dk = DecryptingKey::new_with_mode(\n        NonZeroScalar::<Sm2>::try_from(PRIVATE_KEY.as_ref() as &[u8]).unwrap(),\n        sm2::pke::Mode::C1C2C3,\n    );\n    assert_eq!(dk.decrypt_der(&ASN1_CIPHER).unwrap(), MSG);\n}",
    "display_name": "decrypt_der_verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2pke.rs",
    "relative_path": "sm2/tests/sm2pke.rs",
    "file_name": "sm2pke.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: Box<[u8]>) -> Result<Self, Self::Error> {\n        Self::try_from(value.as_ref())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Group/is_identity",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Self::IDENTITY)\n    }",
    "display_name": "is_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "affine/impl/AffinePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/from_bytes_reduced",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint"
    ],
    "body": "    fn from_bytes_reduced() {\n        let m = Scalar::modulus_as_biguint();\n\n        fn reduce<T: Reduce<U256, Bytes = FieldBytes>>(arr: &[u8]) -> T {\n            T::reduce_bytes(&Array::try_from(arr).unwrap())\n        }\n\n        // Regular reduction\n\n        let s = reduce::<Scalar>(&[0xffu8; 32]).to_biguint().unwrap();\n        assert!(s < m);\n\n        let s = reduce::<Scalar>(&[0u8; 32]).to_biguint().unwrap();\n        assert!(s.is_zero());\n\n        let s = reduce::<Scalar>(&ORDER.to_be_byte_array())\n            .to_biguint()\n            .unwrap();\n        assert!(s.is_zero());\n\n        // Reduction to a non-zero scalar\n\n        let s = reduce::<NonZeroScalar>(&[0xffu8; 32]).to_biguint().unwrap();\n        assert!(s < m);\n\n        let s = reduce::<NonZeroScalar>(&[0u8; 32]).to_biguint().unwrap();\n        assert!(s < m);\n        assert!(!s.is_zero());\n\n        let s = reduce::<NonZeroScalar>(&ORDER.to_be_byte_array())\n            .to_biguint()\n            .unwrap();\n        assert!(s < m);\n        assert!(!s.is_zero());\n\n        let s = reduce::<NonZeroScalar>(&(ORDER.wrapping_sub(&U256::ONE)).to_be_byte_array())\n            .to_biguint()\n            .unwrap();\n        assert!(s < m);\n        assert!(!s.is_zero());\n    }",
    "display_name": "from_bytes_reduced",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/fiat_p521_loose_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/batch_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/non_zero_scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "        fn batch_invert(\n            a in non_zero_scalar(),\n            b in non_zero_scalar(),\n            c in non_zero_scalar(),\n            d in non_zero_scalar(),\n            e in non_zero_scalar(),\n        ) {\n            let scalars: [Scalar; 5] = [*a, *b, *c, *d, *e];\n\n            let inverted_scalars = Scalar::batch_invert(scalars).unwrap();\n\n            for (scalar, inverted_scalar) in scalars.into_iter().zip(inverted_scalars) {\n                assert_eq!(inverted_scalar, scalar.invert().unwrap());\n            }\n        }",
    "display_name": "batch_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::ZERO\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/split_scalars",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/s0",
      "0.14.0_pre ecdsa/impl/Signature/s1"
    ],
    "body": "    pub fn split_scalars(&self) -> (NonZeroScalar, NonZeroScalar) {\n        (self.s0(), self.s1())\n    }",
    "display_name": "split_scalars",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/projective/tests/test_conditional_negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/ConditionallyNegatable/conditional_negate",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/add",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/to_extended",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_projective_niels"
    ],
    "body": "    fn test_conditional_negate() {\n        let bp = ExtendedPoint::GENERATOR;\n\n        let mut bp_neg = bp.to_extensible().to_projective_niels();\n        bp_neg.conditional_negate(1.into());\n\n        let expect_identity = bp_neg.to_extended().add(&bp);\n        assert_eq!(ExtendedPoint::IDENTITY, expect_identity);\n    }",
    "display_name": "test_conditional_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/projective.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/&LooseFieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/multiply"
    ],
    "body": "    fn mul(self, rhs: &LooseFieldElement) -> FieldElement {\n        LooseFieldElement::multiply(self, rhs)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/sub_inner",
    "statement_type": "function",
    "deps": [],
    "body": "const fn sub_inner(l: [Limb; 5], r: [Limb; 5]) -> ([Limb; 4], Limb) {\n    /*\n    let (w0, borrow) = borrowing_sub(l[0], r[0], 0);\n    let (w1, borrow) = borrowing_sub(l[1], r[1], borrow);\n    let (w2, borrow) = borrowing_sub(l[2], r[2], borrow);\n    let (w3, borrow) = borrowing_sub(l[3], r[3], borrow);\n    let (_, borrow) = borrowing_sub(l[4], r[4], borrow);\n    */\n\n    let (w0, borrow) = l[0].borrowing_sub(r[0], Limb::ZERO);\n    let (w1, borrow) = l[1].borrowing_sub(r[1], borrow);\n    let (w2, borrow) = l[2].borrowing_sub(r[2], borrow);\n    let (w3, borrow) = l[3].borrowing_sub(r[3], borrow);\n    let (_, borrow) = l[4].borrowing_sub(r[4], borrow);\n\n    // If underflow occurred on the final limb, borrow = 0xfff...fff, otherwise\n    // borrow = 0x000...000. Thus, we use it as a mask to conditionally add the\n    // modulus.\n\n    let modulus = MODULUS.as_limbs();\n\n    /*\n    let (w0, carry) = carrying_add(w0, modulus[0] & borrow, 0);\n    let (w1, carry) = carrying_add(w1, modulus[1] & borrow, carry);\n    let (w2, carry) = carrying_add(w2, modulus[2] & borrow, carry);\n    let (w3, _) = carrying_add(w3, modulus[3] & borrow, carry);\n    */\n\n    let (w0, carry) = w0.carrying_add(modulus[0].bitand(borrow), Limb::ZERO);\n    let (w1, carry) = w1.carrying_add(modulus[1].bitand(borrow), carry);\n    let (w2, carry) = w2.carrying_add(modulus[2].bitand(borrow), carry);\n    let (w3, _) = w3.carrying_add(modulus[3].bitand(borrow), carry);\n\n    ([w0, w1, w2, w3], borrow)\n}",
    "display_name": "sub_inner",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field/field64.rs",
    "relative_path": "p256/src/arithmetic/field/field64.rs",
    "file_name": "field64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre encode_pkcs8_public_key_to_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_public_key_to_pem() {\n    let original_public_key =\n        sm2::PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    let reencoded_public_key = original_public_key.to_string();\n    assert_eq!(reencoded_public_key.as_str(), PKCS8_PUBLIC_KEY_PEM);\n}",
    "display_name": "encode_pkcs8_public_key_to_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqn",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    const fn sqn(&self, n: usize) -> Self {\n        let mut x = *self;\n        let mut i = 0;\n        while i < n {\n            x = x.square();\n            i += 1;\n        }\n        x\n    }",
    "display_name": "sqn",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new_normalized",
    "statement_type": "function",
    "deps": [],
    "body": "    const fn new_normalized(value: &FieldElementUnsafeImpl) -> Self {\n        Self {\n            value: *value,\n            magnitude: 1,\n            normalized: true,\n        }\n    }",
    "display_name": "new_normalized",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/max_magnitude"
    ],
    "body": "    fn new(value: &FieldElementUnsafeImpl, magnitude: u32) -> Self {\n        debug_assert!(magnitude <= FieldElementUnsafeImpl::max_magnitude());\n        Self {\n            value: *value,\n            magnitude,\n            normalized: false,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/PreHasherXmd/PreHash/fill_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fill_bytes(&mut self, out: &mut [u8]) {\n        out.copy_from_slice(self.hasher.finalize_reset().as_slice());\n    }",
    "display_name": "fill_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafAffinePoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended",
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/Curve/to_affine"
    ],
    "body": "    fn add_assign(&mut self, rhs: &DecafPoint) {\n        *self = (DecafPoint(self.0.to_extended()) + rhs).to_affine();\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/add"
    ],
    "body": "    pub const fn add(&self, rhs: &Self) -> Self {\n        Self(field_impl::add(self.0, rhs.0))\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/&ProjectivePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/mul"
    ],
    "body": "    fn mul(self, scalar: S) -> ProjectivePoint<C> {\n        ProjectivePoint::mul(self, scalar.borrow())\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&EdwardsPoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/scalar_mul"
    ],
    "body": "    fn mul(self, scalar: &Scalar) -> EdwardsPoint {\n        self.scalar_mul(scalar)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_uint_unchecked(uint: Self::Uint) -> Self {\n        Self(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_mul(\n    out1: &mut fiat_p224_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p224_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p224_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x5, &mut x6, x4, (arg2[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x7, &mut x8, x4, (arg2[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x9, &mut x10, x4, (arg2[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x11, &mut x12, x4, (arg2[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x20, &mut x21, x11, 0xd6e242706a1fc2eb);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x22, &mut x23, x20, 0xffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x26, &mut x27, x20, 0xffff16a2e0b8f03e);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x28, &mut x29, x20, 0x13dd29455c5c2a3d);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x30, &mut x31, 0x0, x29, x26);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x27, x24);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x25, x22);\n    let x36: u64 = ((x35 as u64) + x23);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x37, &mut x38, 0x0, x11, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x13, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x15, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x43, &mut x44, x42, x17, x34);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x45, &mut x46, x44, x19, x36);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x47, &mut x48, x1, (arg2[3]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x49, &mut x50, x1, (arg2[2]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x51, &mut x52, x1, (arg2[1]));\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x53, &mut x54, x1, (arg2[0]));\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x55, &mut x56, 0x0, x54, x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x52, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x50, x47);\n    let x61: u64 = ((x60 as u64) + x48);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x45, x59);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x70, &mut x71, x69, (x46 as u64), x61);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x72, &mut x73, x62, 0xd6e242706a1fc2eb);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x74, &mut x75, x72, 0xffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x78, &mut x79, x72, 0xffff16a2e0b8f03e);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x80, &mut x81, x72, 0x13dd29455c5c2a3d);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x82, &mut x83, 0x0, x81, x78);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x79, x76);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x77, x74);\n    let x88: u64 = ((x87 as u64) + x75);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x89, &mut x90, 0x0, x62, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x91, &mut x92, x90, x64, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x93, &mut x94, x92, x66, x84);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x95, &mut x96, x94, x68, x86);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x97, &mut x98, x96, x70, x88);\n    let x99: u64 = ((x98 as u64) + (x71 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x100, &mut x101, x2, (arg2[3]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x102, &mut x103, x2, (arg2[2]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x104, &mut x105, x2, (arg2[1]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x106, &mut x107, x2, (arg2[0]));\n    let mut x108: u64 = 0;\n    let mut x109: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x107, x104);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x105, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x103, x100);\n    let x114: u64 = ((x113 as u64) + x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x115, &mut x116, 0x0, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x121, &mut x122, x120, x97, x112);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x123, &mut x124, x122, x99, x114);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x125, &mut x126, x115, 0xd6e242706a1fc2eb);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x127, &mut x128, x125, 0xffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x129, &mut x130, x125, 0xffffffffffffffff);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x131, &mut x132, x125, 0xffff16a2e0b8f03e);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x133, &mut x134, x125, 0x13dd29455c5c2a3d);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let x141: u64 = ((x140 as u64) + x128);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x142, &mut x143, 0x0, x115, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x144, &mut x145, x143, x117, x135);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x146, &mut x147, x145, x119, x137);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x148, &mut x149, x147, x121, x139);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x150, &mut x151, x149, x123, x141);\n    let x152: u64 = ((x151 as u64) + (x124 as u64));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x153, &mut x154, x3, (arg2[3]));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x155, &mut x156, x3, (arg2[2]));\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x157, &mut x158, x3, (arg2[1]));\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x159, &mut x160, x3, (arg2[0]));\n    let mut x161: u64 = 0;\n    let mut x162: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x161, &mut x162, 0x0, x160, x157);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x163, &mut x164, x162, x158, x155);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x165, &mut x166, x164, x156, x153);\n    let x167: u64 = ((x166 as u64) + x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x168, &mut x169, 0x0, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x148, x163);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x150, x165);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x152, x167);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x178, &mut x179, x168, 0xd6e242706a1fc2eb);\n    let mut x180: u64 = 0;\n    let mut x181: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x180, &mut x181, x178, 0xffffffff);\n    let mut x182: u64 = 0;\n    let mut x183: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x182, &mut x183, x178, 0xffffffffffffffff);\n    let mut x184: u64 = 0;\n    let mut x185: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x184, &mut x185, x178, 0xffff16a2e0b8f03e);\n    let mut x186: u64 = 0;\n    let mut x187: u64 = 0;\n    fiat_p224_scalar_mulx_u64(&mut x186, &mut x187, x178, 0x13dd29455c5c2a3d);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x188, &mut x189, 0x0, x187, x184);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x190, &mut x191, x189, x185, x182);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x183, x180);\n    let x194: u64 = ((x193 as u64) + x181);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x195, &mut x196, 0x0, x168, x186);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x197, &mut x198, x196, x170, x188);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x172, x190);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x174, x192);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x176, x194);\n    let x205: u64 = ((x204 as u64) + (x177 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x206, &mut x207, 0x0, x197, 0x13dd29455c5c2a3d);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x208, &mut x209, x207, x199, 0xffff16a2e0b8f03e);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x210, &mut x211, x209, x201, 0xffffffffffffffff);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x212, &mut x213, x211, x203, 0xffffffff);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x214, &mut x215, x213, x205, (0x0 as u64));\n    let mut x216: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x216, x215, x206, x197);\n    let mut x217: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x217, x215, x208, x199);\n    let mut x218: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x218, x215, x210, x201);\n    let mut x219: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x219, x215, x212, x203);\n    out1[0] = x216;\n    out1[1] = x217;\n    out1[2] = x218;\n    out1[3] = x219;\n}",
    "display_name": "fiat_p224_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 curve/scalar_mul/variable_base/variable_base",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_radix_16",
      "0.14.0_pre.1 curve/scalar_mul/window/wnaf/impl/LookupTable/From/from",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/double",
      "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/ConditionallyNegatable/conditional_negate",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_projective_niels",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
      "0.14.0_pre.1 curve/scalar_mul/window/wnaf/impl/LookupTable/select"
    ],
    "body": "pub fn variable_base(point: &ExtendedPoint, s: &Scalar) -> ExtendedPoint {\n    let mut result = ExtensiblePoint::IDENTITY;\n\n    // Recode Scalar\n    let scalar = s.to_radix_16();\n\n    let lookup = LookupTable::from(point);\n\n    for i in (0..113).rev() {\n        result = result.double();\n        result = result.double();\n        result = result.double();\n        result = result.double();\n\n        // The mask is the top bit, will be 1 for negative numbers, 0 for positive numbers\n        let mask = scalar[i] >> 7;\n        let sign = mask & 0x1;\n        // Use the mask to get the absolute value of scalar\n        let abs_value = ((scalar[i] + mask) ^ mask) as u32;\n\n        let mut neg_P = lookup.select(abs_value);\n        neg_P.conditional_negate(Choice::from((sign) as u8));\n\n        result = result.add_projective_niels(&neg_P);\n    }\n\n    result.to_extended()\n}",
    "display_name": "variable_base",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/scalar_mul/variable_base.rs",
    "relative_path": "ed448-goldilocks/src/curve/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Group/is_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero"
    ],
    "body": "    fn is_identity(&self) -> Choice {\n        self.z.normalizes_to_zero()\n    }",
    "display_name": "is_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub(self, other: ProjectivePoint) -> ProjectivePoint {\n        ProjectivePoint::sub(&self, &other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/is_on_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub(crate) fn is_on_curve(&self) -> Choice {\n        let XY = self.X * self.Y;\n        let ZT = self.Z * self.T;\n\n        // Y^2 - X^2 == Z^2 + T^2 * (TWISTED_D)\n\n        let YY = self.Y.square();\n        let XX = self.X.square();\n        let ZZ = self.Z.square();\n        let TT = self.T.square();\n        let lhs = YY - XX;\n        let rhs = ZZ + TT * FieldElement::TWISTED_D;\n\n        XY.ct_eq(&ZT) & lhs.ct_eq(&rhs)\n    }",
    "display_name": "is_on_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Field/double",
    "statement_type": "function",
    "deps": [],
    "body": "    fn double(&self) -> Self {\n        self + self\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: Box<[u8]>) -> Result<Self, Self::Error> {\n        Self::try_from(bytes.as_ref())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/tests/uncompressed_to_compressed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn uncompressed_to_compressed() {\n        let encoded = EncodedPoint::from_bytes(UNCOMPRESSED_BASEPOINT).unwrap();\n\n        let res = AffinePoint::from_encoded_point(&encoded)\n            .unwrap()\n            .to_encoded_point(true);\n\n        assert_eq!(res.as_bytes(), COMPRESSED_BASEPOINT);\n    }",
    "display_name": "uncompressed_to_compressed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/sqrt_ratio",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert_unchecked",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_hex",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_u64"
    ],
    "body": "    fn sqrt_ratio(num: &Self, div: &Self) -> (Choice, Self) {\n        ff::helpers::sqrt_ratio_generic(num, div)\n    }",
    "display_name": "sqrt_ratio",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_ecdsa",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_z",
      "0.14.0_pre.8 test_scalar_d"
    ],
    "body": "fn bench_ecdsa(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"ecdsa\");\n\n    let d = SigningKey::from(test_scalar_d());\n    let z = test_scalar_z();\n\n    group.bench_function(\"try_sign_prehashed\", |b| {\n        b.iter(|| {\n            let _: Signature = black_box(&d).sign_prehash(&black_box(z)).unwrap();\n        })\n    });\n\n    let q = d.verifying_key();\n    let s: Signature = d.sign_prehash(&z).unwrap();\n\n    group.bench_function(\"verify_prehashed\", |b| {\n        b.iter(|| {\n            black_box(q)\n                .verify_prehash(&black_box(z), &black_box(s))\n                .unwrap()\n        })\n    });\n\n    group.finish();\n}",
    "display_name": "bench_ecdsa",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/ecdsa.rs",
    "relative_path": "k256/benches/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/from_to_bytes_roundtrip",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "    fn from_to_bytes_roundtrip() {\n        let k: u64 = 42;\n        let mut bytes = FieldBytes::default();\n        bytes[24..].copy_from_slice(k.to_be_bytes().as_ref());\n\n        let scalar = Scalar::from_repr(bytes).unwrap();\n        assert_eq!(bytes, scalar.to_bytes());\n    }",
    "display_name": "from_to_bytes_roundtrip",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, rhs: FieldElement) {\n        *self = *self * &rhs;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/random",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {\n        let mut scalar_bytes = WideScalarBytes::default();\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }",
    "display_name": "random",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/BatchNormalize; N/>/batch_normalize",
    "statement_type": "function",
    "deps": [
      "projective/batch_normalize_generic"
    ],
    "body": "    fn batch_normalize(points: &[Self; N]) -> [<Self as CurveGroup>::AffineRepr; N] {\n        let zs = [C::FieldElement::ONE; N];\n        let mut affine_points = [C::AffinePoint::IDENTITY; N];\n        batch_normalize_generic(points, zs, &mut affine_points);\n        affine_points\n    }",
    "display_name": "batch_normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_p192_scalar_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/relax"
    ],
    "body": "    fn from(tight: &FieldElement) -> LooseFieldElement {\n        tight.relax()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "    fn reduce_nonzero(bytes: U896) -> Self {\n        let (r, underflow) = bytes.borrowing_sub(&WIDE_ORDER_MINUS_ONE, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n\n        Self(\n            U896::conditional_select(&bytes, &r, !underflow)\n                .split()\n                .1\n                .wrapping_add(&U448::ONE),\n        )\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_odd(&self) -> Choice {\n        Choice::from(self.0[0] as u8 & 1)\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/is_square",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_square(&self) -> Choice {\n        const IS_SQUARE_EXP: U448 = U448::from_le_hex(\n            \"ffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n        );\n        self.0.pow(&IS_SQUARE_EXP).ct_eq(&FieldElement::ONE.0)\n    }",
    "display_name": "is_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/Group/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/double"
    ],
    "body": "    fn double(&self) -> Self {\n        Self(self.0.double())\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/from_slice"
    ],
    "body": "    pub fn from_bytes(distid: &DistId, bytes: &FieldBytes) -> Result<Self> {\n        Self::from_slice(distid, bytes)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/repeated_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn repeated_add() {\n        let mut r = FieldElement::ONE;\n        for item in DBL_TEST_VECTORS {\n            assert_eq!(r.to_bytes().as_slice(), item);\n            r = r + &r;\n        }\n    }",
    "display_name": "repeated_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_square<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"square\", |b| b.iter(|| x.square()));\n}",
    "display_name": "bench_field_element_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/field.rs",
    "relative_path": "p521/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(p: NonIdentity<ProjectivePoint>) -> Self {\n        p.to_point()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/is_on_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square"
    ],
    "body": "    fn is_on_curve(&self) -> bool {\n        let xx = self.x.square();\n        let yy = self.y.square();\n\n        yy - xx == FieldElement::ONE + (FieldElement::TWISTED_D * xx * yy)\n    }",
    "display_name": "is_on_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add(self, other: &Scalar) -> Scalar {\n        Scalar::add(&self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_p192_scalar_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "point_arithmetic/sealed/PointArithmetic/double",
    "statement_type": "function",
    "deps": [],
    "body": "        fn double(point: &ProjectivePoint<C>) -> ProjectivePoint<C>;\n    }\n}\n\n/// Allow crate-local visibility\npub(crate) use sealed::PointArithmetic;\n\n/// The 𝒂-coefficient of the short Weierstrass equation does not have specific\n/// properties which allow for an optimized implementation.\npub struct EquationAIsGeneric {}\n",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_from_montgomery",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_canonical"
    ],
    "body": "    pub fn to_bytes(self) -> FieldBytes {\n        FieldBytesEncoding::<NistP521>::encode_field_bytes(&self.to_canonical())\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/LowerHex/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:x}\", self.0.retrieve())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, point: &AffinePoint) -> DecafPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_field_element_invert",
      "0.14.0_pre.8 bench_field_element_square",
      "0.14.0_pre.8 bench_field_element_mul",
      "0.14.0_pre.8 bench_field_element_sqrt"
    ],
    "body": "fn bench_field_element(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"field element operations\");\n    bench_field_element_mul(&mut group);\n    bench_field_element_square(&mut group);\n    bench_field_element_invert(&mut group);\n    bench_field_element_sqrt(&mut group);\n    group.finish();\n}",
    "display_name": "bench_field_element",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/field.rs",
    "relative_path": "p384/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_to_bytes(out1: &mut [u8; 28], arg1: &[u64; 4]) {\n    let x1: u64 = (arg1[3]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[1]);\n    let x4: u64 = (arg1[0]);\n    let x5: u8 = ((x4 & (0xff as u64)) as u8);\n    let x6: u64 = (x4 >> 8);\n    let x7: u8 = ((x6 & (0xff as u64)) as u8);\n    let x8: u64 = (x6 >> 8);\n    let x9: u8 = ((x8 & (0xff as u64)) as u8);\n    let x10: u64 = (x8 >> 8);\n    let x11: u8 = ((x10 & (0xff as u64)) as u8);\n    let x12: u64 = (x10 >> 8);\n    let x13: u8 = ((x12 & (0xff as u64)) as u8);\n    let x14: u64 = (x12 >> 8);\n    let x15: u8 = ((x14 & (0xff as u64)) as u8);\n    let x16: u64 = (x14 >> 8);\n    let x17: u8 = ((x16 & (0xff as u64)) as u8);\n    let x18: u8 = ((x16 >> 8) as u8);\n    let x19: u8 = ((x3 & (0xff as u64)) as u8);\n    let x20: u64 = (x3 >> 8);\n    let x21: u8 = ((x20 & (0xff as u64)) as u8);\n    let x22: u64 = (x20 >> 8);\n    let x23: u8 = ((x22 & (0xff as u64)) as u8);\n    let x24: u64 = (x22 >> 8);\n    let x25: u8 = ((x24 & (0xff as u64)) as u8);\n    let x26: u64 = (x24 >> 8);\n    let x27: u8 = ((x26 & (0xff as u64)) as u8);\n    let x28: u64 = (x26 >> 8);\n    let x29: u8 = ((x28 & (0xff as u64)) as u8);\n    let x30: u64 = (x28 >> 8);\n    let x31: u8 = ((x30 & (0xff as u64)) as u8);\n    let x32: u8 = ((x30 >> 8) as u8);\n    let x33: u8 = ((x2 & (0xff as u64)) as u8);\n    let x34: u64 = (x2 >> 8);\n    let x35: u8 = ((x34 & (0xff as u64)) as u8);\n    let x36: u64 = (x34 >> 8);\n    let x37: u8 = ((x36 & (0xff as u64)) as u8);\n    let x38: u64 = (x36 >> 8);\n    let x39: u8 = ((x38 & (0xff as u64)) as u8);\n    let x40: u64 = (x38 >> 8);\n    let x41: u8 = ((x40 & (0xff as u64)) as u8);\n    let x42: u64 = (x40 >> 8);\n    let x43: u8 = ((x42 & (0xff as u64)) as u8);\n    let x44: u64 = (x42 >> 8);\n    let x45: u8 = ((x44 & (0xff as u64)) as u8);\n    let x46: u8 = ((x44 >> 8) as u8);\n    let x47: u8 = ((x1 & (0xff as u64)) as u8);\n    let x48: u64 = (x1 >> 8);\n    let x49: u8 = ((x48 & (0xff as u64)) as u8);\n    let x50: u64 = (x48 >> 8);\n    let x51: u8 = ((x50 & (0xff as u64)) as u8);\n    let x52: u8 = ((x50 >> 8) as u8);\n    out1[0] = x5;\n    out1[1] = x7;\n    out1[2] = x9;\n    out1[3] = x11;\n    out1[4] = x13;\n    out1[5] = x15;\n    out1[6] = x17;\n    out1[7] = x18;\n    out1[8] = x19;\n    out1[9] = x21;\n    out1[10] = x23;\n    out1[11] = x25;\n    out1[12] = x27;\n    out1[13] = x29;\n    out1[14] = x31;\n    out1[15] = x32;\n    out1[16] = x33;\n    out1[17] = x35;\n    out1[18] = x37;\n    out1[19] = x39;\n    out1[20] = x41;\n    out1[21] = x43;\n    out1[22] = x45;\n    out1[23] = x46;\n    out1[24] = x47;\n    out1[25] = x49;\n    out1[26] = x51;\n    out1[27] = x52;\n}",
    "display_name": "fiat_p224_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: Box<[u8]>) -> Result<Self, Self::Error> {\n        Self::try_from(bytes.as_ref())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre test_varying_message_lengths",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre create_test_signing_key",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/Verifier/verify",
      "0.14.0_pre dsa/signing/impl/SigningKey/verifying_key"
    ],
    "body": "fn test_varying_message_lengths() {\n    let sk = create_test_signing_key();\n    let test_messages = vec![\n        vec![],          // Empty message\n        vec![1u8; 1],    // 1 byte\n        vec![2u8; 32],   // 32 bytes\n        vec![3u8; 1024], // 1KB\n    ];\n\n    for msg in test_messages {\n        let sig = sk.sign(&msg);\n        assert!(sk.verifying_key().verify(&msg, &sig).is_ok());\n    }\n}",
    "display_name": "test_varying_message_lengths",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/dsa_extended.rs",
    "relative_path": "sm2/tests/dsa_extended.rs",
    "file_name": "dsa_extended.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: Scalar) {\n        *self = *self - other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/AffineCoordinates/y_is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn y_is_odd(&self) -> Choice {\n        self.y.normalize().is_odd()\n    }",
    "display_name": "y_is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/max_magnitude",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn max_magnitude() -> u32 {\n        2047u32\n    }",
    "display_name": "max_magnitude",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        U256::from_be_byte_array(*field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/lib.rs",
    "relative_path": "sm2/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre benches",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre bench_scalar",
      "0.14.0_pre bench_field_element",
      "0.14.0_pre bench_point"
    ],
    "body": "criterion_group!(benches, bench_field_element);\ncriterion_main!(benches);",
    "display_name": "benches",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/field.rs",
    "relative_path": "bign256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Display/fmt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032"
    ],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        let bytes = self.to_bytes_rfc_8032();\n        for b in &bytes {\n            write!(f, \"{:02x}\", b)?;\n        }\n        Ok(())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> ExtendedPoint {\n        ExtendedPoint::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_slice",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    pub fn from_slice(slice: &[u8]) -> elliptic_curve::Result<Self> {\n        let field_bytes = FieldBytes::try_from(slice).map_err(|_| Error)?;\n        Self::from_bytes(&field_bytes).into_option().ok_or(Error)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/fiat_p384_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_projective_niels"
    ],
    "body": "    pub fn identity() -> ProjectiveNielsPoint {\n        ExtensiblePoint::IDENTITY.to_projective_niels()\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/projective.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert_unchecked",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero"
    ],
    "body": "    pub fn invert(&self) -> CtOption<Self> {\n        CtOption::new(self.invert_unchecked(), !self.is_zero())\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_to_bytes"
    ],
    "body": "    pub fn to_bytes(self) -> FieldBytes {\n        let mut ret = [0u8; 66];\n        fiat_p521_to_bytes(&mut ret, &self.0);\n        ret.reverse();\n        ret.into()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint"
    ],
    "body": "    fn try_from(w: U256) -> Result<Self> {\n        Option::from(Self::from_uint(w)).ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/verifying_key",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn verifying_key(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }",
    "display_name": "verifying_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre decrypting_key_c1c2c3",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/new_with_mode"
    ],
    "body": "    fn decrypting_key_c1c2c3()(bytes in any::<[u8; 32]>()) -> DecryptingKey {\n        loop {\n            let scalar = <Scalar as Reduce<U256>>::reduce_bytes(&bytes.into());\n            if let Some(scalar) = Option::from(NonZeroScalar::new(scalar)) {\n                return DecryptingKey::new_with_mode(scalar, sm2::pke::Mode::C1C2C3);\n            }\n        }\n    }",
    "display_name": "decrypting_key_c1c2c3",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2pke.rs",
    "relative_path": "sm2/tests/sm2pke.rs",
    "file_name": "sm2pke.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_to_bytes(out1: &mut [u8; 66], arg1: &[u64; 9]) {\n    let x1: u64 = (arg1[8]);\n    let x2: u64 = (arg1[7]);\n    let x3: u64 = (arg1[6]);\n    let x4: u64 = (arg1[5]);\n    let x5: u64 = (arg1[4]);\n    let x6: u64 = (arg1[3]);\n    let x7: u64 = (arg1[2]);\n    let x8: u64 = (arg1[1]);\n    let x9: u64 = (arg1[0]);\n    let x10: u8 = ((x9 & (0xff as u64)) as u8);\n    let x11: u64 = (x9 >> 8);\n    let x12: u8 = ((x11 & (0xff as u64)) as u8);\n    let x13: u64 = (x11 >> 8);\n    let x14: u8 = ((x13 & (0xff as u64)) as u8);\n    let x15: u64 = (x13 >> 8);\n    let x16: u8 = ((x15 & (0xff as u64)) as u8);\n    let x17: u64 = (x15 >> 8);\n    let x18: u8 = ((x17 & (0xff as u64)) as u8);\n    let x19: u64 = (x17 >> 8);\n    let x20: u8 = ((x19 & (0xff as u64)) as u8);\n    let x21: u64 = (x19 >> 8);\n    let x22: u8 = ((x21 & (0xff as u64)) as u8);\n    let x23: u8 = ((x21 >> 8) as u8);\n    let x24: u8 = ((x8 & (0xff as u64)) as u8);\n    let x25: u64 = (x8 >> 8);\n    let x26: u8 = ((x25 & (0xff as u64)) as u8);\n    let x27: u64 = (x25 >> 8);\n    let x28: u8 = ((x27 & (0xff as u64)) as u8);\n    let x29: u64 = (x27 >> 8);\n    let x30: u8 = ((x29 & (0xff as u64)) as u8);\n    let x31: u64 = (x29 >> 8);\n    let x32: u8 = ((x31 & (0xff as u64)) as u8);\n    let x33: u64 = (x31 >> 8);\n    let x34: u8 = ((x33 & (0xff as u64)) as u8);\n    let x35: u64 = (x33 >> 8);\n    let x36: u8 = ((x35 & (0xff as u64)) as u8);\n    let x37: u8 = ((x35 >> 8) as u8);\n    let x38: u8 = ((x7 & (0xff as u64)) as u8);\n    let x39: u64 = (x7 >> 8);\n    let x40: u8 = ((x39 & (0xff as u64)) as u8);\n    let x41: u64 = (x39 >> 8);\n    let x42: u8 = ((x41 & (0xff as u64)) as u8);\n    let x43: u64 = (x41 >> 8);\n    let x44: u8 = ((x43 & (0xff as u64)) as u8);\n    let x45: u64 = (x43 >> 8);\n    let x46: u8 = ((x45 & (0xff as u64)) as u8);\n    let x47: u64 = (x45 >> 8);\n    let x48: u8 = ((x47 & (0xff as u64)) as u8);\n    let x49: u64 = (x47 >> 8);\n    let x50: u8 = ((x49 & (0xff as u64)) as u8);\n    let x51: u8 = ((x49 >> 8) as u8);\n    let x52: u8 = ((x6 & (0xff as u64)) as u8);\n    let x53: u64 = (x6 >> 8);\n    let x54: u8 = ((x53 & (0xff as u64)) as u8);\n    let x55: u64 = (x53 >> 8);\n    let x56: u8 = ((x55 & (0xff as u64)) as u8);\n    let x57: u64 = (x55 >> 8);\n    let x58: u8 = ((x57 & (0xff as u64)) as u8);\n    let x59: u64 = (x57 >> 8);\n    let x60: u8 = ((x59 & (0xff as u64)) as u8);\n    let x61: u64 = (x59 >> 8);\n    let x62: u8 = ((x61 & (0xff as u64)) as u8);\n    let x63: u64 = (x61 >> 8);\n    let x64: u8 = ((x63 & (0xff as u64)) as u8);\n    let x65: u8 = ((x63 >> 8) as u8);\n    let x66: u8 = ((x5 & (0xff as u64)) as u8);\n    let x67: u64 = (x5 >> 8);\n    let x68: u8 = ((x67 & (0xff as u64)) as u8);\n    let x69: u64 = (x67 >> 8);\n    let x70: u8 = ((x69 & (0xff as u64)) as u8);\n    let x71: u64 = (x69 >> 8);\n    let x72: u8 = ((x71 & (0xff as u64)) as u8);\n    let x73: u64 = (x71 >> 8);\n    let x74: u8 = ((x73 & (0xff as u64)) as u8);\n    let x75: u64 = (x73 >> 8);\n    let x76: u8 = ((x75 & (0xff as u64)) as u8);\n    let x77: u64 = (x75 >> 8);\n    let x78: u8 = ((x77 & (0xff as u64)) as u8);\n    let x79: u8 = ((x77 >> 8) as u8);\n    let x80: u8 = ((x4 & (0xff as u64)) as u8);\n    let x81: u64 = (x4 >> 8);\n    let x82: u8 = ((x81 & (0xff as u64)) as u8);\n    let x83: u64 = (x81 >> 8);\n    let x84: u8 = ((x83 & (0xff as u64)) as u8);\n    let x85: u64 = (x83 >> 8);\n    let x86: u8 = ((x85 & (0xff as u64)) as u8);\n    let x87: u64 = (x85 >> 8);\n    let x88: u8 = ((x87 & (0xff as u64)) as u8);\n    let x89: u64 = (x87 >> 8);\n    let x90: u8 = ((x89 & (0xff as u64)) as u8);\n    let x91: u64 = (x89 >> 8);\n    let x92: u8 = ((x91 & (0xff as u64)) as u8);\n    let x93: u8 = ((x91 >> 8) as u8);\n    let x94: u8 = ((x3 & (0xff as u64)) as u8);\n    let x95: u64 = (x3 >> 8);\n    let x96: u8 = ((x95 & (0xff as u64)) as u8);\n    let x97: u64 = (x95 >> 8);\n    let x98: u8 = ((x97 & (0xff as u64)) as u8);\n    let x99: u64 = (x97 >> 8);\n    let x100: u8 = ((x99 & (0xff as u64)) as u8);\n    let x101: u64 = (x99 >> 8);\n    let x102: u8 = ((x101 & (0xff as u64)) as u8);\n    let x103: u64 = (x101 >> 8);\n    let x104: u8 = ((x103 & (0xff as u64)) as u8);\n    let x105: u64 = (x103 >> 8);\n    let x106: u8 = ((x105 & (0xff as u64)) as u8);\n    let x107: u8 = ((x105 >> 8) as u8);\n    let x108: u8 = ((x2 & (0xff as u64)) as u8);\n    let x109: u64 = (x2 >> 8);\n    let x110: u8 = ((x109 & (0xff as u64)) as u8);\n    let x111: u64 = (x109 >> 8);\n    let x112: u8 = ((x111 & (0xff as u64)) as u8);\n    let x113: u64 = (x111 >> 8);\n    let x114: u8 = ((x113 & (0xff as u64)) as u8);\n    let x115: u64 = (x113 >> 8);\n    let x116: u8 = ((x115 & (0xff as u64)) as u8);\n    let x117: u64 = (x115 >> 8);\n    let x118: u8 = ((x117 & (0xff as u64)) as u8);\n    let x119: u64 = (x117 >> 8);\n    let x120: u8 = ((x119 & (0xff as u64)) as u8);\n    let x121: u8 = ((x119 >> 8) as u8);\n    let x122: u8 = ((x1 & (0xff as u64)) as u8);\n    let x123: fiat_p521_scalar_u1 = ((x1 >> 8) as fiat_p521_scalar_u1);\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n    out1[4] = x18;\n    out1[5] = x20;\n    out1[6] = x22;\n    out1[7] = x23;\n    out1[8] = x24;\n    out1[9] = x26;\n    out1[10] = x28;\n    out1[11] = x30;\n    out1[12] = x32;\n    out1[13] = x34;\n    out1[14] = x36;\n    out1[15] = x37;\n    out1[16] = x38;\n    out1[17] = x40;\n    out1[18] = x42;\n    out1[19] = x44;\n    out1[20] = x46;\n    out1[21] = x48;\n    out1[22] = x50;\n    out1[23] = x51;\n    out1[24] = x52;\n    out1[25] = x54;\n    out1[26] = x56;\n    out1[27] = x58;\n    out1[28] = x60;\n    out1[29] = x62;\n    out1[30] = x64;\n    out1[31] = x65;\n    out1[32] = x66;\n    out1[33] = x68;\n    out1[34] = x70;\n    out1[35] = x72;\n    out1[36] = x74;\n    out1[37] = x76;\n    out1[38] = x78;\n    out1[39] = x79;\n    out1[40] = x80;\n    out1[41] = x82;\n    out1[42] = x84;\n    out1[43] = x86;\n    out1[44] = x88;\n    out1[45] = x90;\n    out1[46] = x92;\n    out1[47] = x93;\n    out1[48] = x94;\n    out1[49] = x96;\n    out1[50] = x98;\n    out1[51] = x100;\n    out1[52] = x102;\n    out1[53] = x104;\n    out1[54] = x106;\n    out1[55] = x107;\n    out1[56] = x108;\n    out1[57] = x110;\n    out1[58] = x112;\n    out1[59] = x114;\n    out1[60] = x116;\n    out1[61] = x118;\n    out1[62] = x120;\n    out1[63] = x121;\n    out1[64] = x122;\n    out1[65] = (x123 as u8);\n}",
    "display_name": "fiat_p521_scalar_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_sub"
    ],
    "body": "    pub const fn sub(&self, rhs: &Self) -> Self {\n        let mut out = fiat_p521_tight_field_element([0; 9]);\n        fiat_p521_carry_sub(&mut out, &self.0, &rhs.0);\n        Self(out)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/sign_prehashed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_prehashed"
    ],
    "body": "    pub fn sign_prehashed<D>(\n        &self,\n        context: Option<&[u8]>,\n        mut prehashed_message: D,\n    ) -> Result<Signature, Error>\n    where\n        D: PreHash,\n    {\n        let mut m = [0u8; 64];\n        prehashed_message.fill_bytes(&mut m);\n        let sig = self\n            .secret\n            .sign_prehashed(context.unwrap_or_default(), &m)?;\n        Ok(sig.into())\n    }",
    "display_name": "sign_prehashed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_sub(\n    out1: &mut fiat_p521_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p521_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p521_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x9, &mut x10, x8, (arg1[4]), (arg2[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x11, &mut x12, x10, (arg1[5]), (arg2[5]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x13, &mut x14, x12, (arg1[6]), (arg2[6]));\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x15, &mut x16, x14, (arg1[7]), (arg2[7]));\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x17, &mut x18, x16, (arg1[8]), (arg2[8]));\n    let mut x19: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x19, x18, (0x0 as u64), 0xffffffffffffffff);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x20, &mut x21, 0x0, x1, (x19 & 0xbb6fb71e91386409));\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x22, &mut x23, x21, x3, (x19 & 0x3bb5c9b8899c47ae));\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x24, &mut x25, x23, x5, (x19 & 0x7fcc0148f709a5d0));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x26, &mut x27, x25, x7, (x19 & 0x51868783bf2f966b));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x28, &mut x29, x27, x9, (x19 & 0xfffffffffffffffa));\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x11, x19);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x13, x19);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x15, x19);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x36, &mut x37, x35, x17, (x19 & 0x1ff));\n    out1[0] = x20;\n    out1[1] = x22;\n    out1[2] = x24;\n    out1[3] = x26;\n    out1[4] = x28;\n    out1[5] = x30;\n    out1[6] = x32;\n    out1[7] = x34;\n    out1[8] = x36;\n}",
    "display_name": "fiat_p521_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/reduce_nonzero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero_bytes",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero"
    ],
    "body": "    fn reduce_nonzero() {\n        assert_eq!(Scalar::reduce_nonzero_bytes(&Array::default()).0, U256::ONE,);\n        assert_eq!(Scalar::reduce_nonzero(U256::ONE).0, U256::from_u8(2),);\n        assert_eq!(Scalar::reduce_nonzero(U256::from_u8(2)).0, U256::from_u8(3),);\n\n        assert_eq!(Scalar::reduce_nonzero(NistP256::ORDER).0, U256::from_u8(2),);\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP256::ORDER.wrapping_sub(&U256::from_u8(1))).0,\n            U256::ONE,\n        );\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP256::ORDER.wrapping_sub(&U256::from_u8(2))).0,\n            NistP256::ORDER.wrapping_sub(&U256::ONE),\n        );\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP256::ORDER.wrapping_sub(&U256::from_u8(3))).0,\n            NistP256::ORDER.wrapping_sub(&U256::from_u8(2)),\n        );\n\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP256::ORDER.wrapping_add(&U256::ONE)).0,\n            U256::from_u8(3),\n        );\n        assert_eq!(\n            Scalar::reduce_nonzero(NistP256::ORDER.wrapping_add(&U256::from_u8(2))).0,\n            U256::from_u8(4),\n        );\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::co"
    ],
    "body": "    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {\n        if value.len() != SECRET_KEY_LENGTH {\n            return Err(\"Invalid length for a signing key\");\n        }\n        Ok(Self::from(\n            ScalarBytes::try_from(value).expect(\"Invalid length\"),\n        ))\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/neg",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn sub(&self, other: &ProjectivePoint) -> ProjectivePoint {\n        self.add(&other.neg())\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Shr/shr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/ShrAssign/shr_assign"
    ],
    "body": "    fn shr(self, rhs: usize) -> Self::Output {\n        let mut cp = self;\n        cp.shr_assign(rhs);\n        cp\n    }",
    "display_name": "shr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/sqrt_ratio_i",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative"
    ],
    "body": "    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (FieldElement, Choice) {\n        const P_MINUS_THREE_DIV_4: U448 = U448::from_be_hex(\n            \"3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n        );\n        let u = u.0;\n        let v = v.0;\n\n        let r = u * (u * v).pow(&P_MINUS_THREE_DIV_4);\n        let check = v * r.square();\n        let was_square = check.ct_eq(&u);\n\n        let mut r = FieldElement(r);\n        r.conditional_negate(r.is_negative());\n        (r, was_square)\n    }",
    "display_name": "sqrt_ratio_i",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/from_to_bytes_roundtrip",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "    fn from_to_bytes_roundtrip() {\n        let k: u64 = 42;\n        let mut bytes = FieldBytes::default();\n        bytes[40..].copy_from_slice(k.to_be_bytes().as_ref());\n\n        let scalar = Scalar::from_repr(bytes).unwrap();\n        assert_eq!(bytes, scalar.to_bytes());\n    }",
    "display_name": "from_to_bytes_roundtrip",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Shr/shr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime"
    ],
    "body": "    fn shr(self, rhs: usize) -> Self::Output {\n        self.shr_vartime(rhs as u32)\n    }",
    "display_name": "shr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sqrt"
    ],
    "body": "    fn sqrt(&self) -> CtOption<Self> {\n        self.sqrt()\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add_assign(&mut self, rhs: &AffinePoint) {\n        *self = ProjectivePoint::add_mixed(self, rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl//u8; 57//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress"
    ],
    "body": "    fn from(value: EdwardsPoint) -> Self {\n        value.compress().into()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "projective/impl/&ProjectivePoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub(self, other: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::sub(self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/PublicKey/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(verifying_key: &VerifyingKey) -> PublicKey {\n        verifying_key.public_key\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add_assign(&mut self, rhs: ProjectivePoint) {\n        *self = ProjectivePoint::add(self, &rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/batch_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert"
    ],
    "body": "    fn batch_invert() {\n        let k: FieldElement = FieldElement::random(&mut OsRng.unwrap_mut());\n        let l: FieldElement = FieldElement::random(&mut OsRng.unwrap_mut());\n\n        let expected = vec![k.invert().unwrap(), l.invert().unwrap()];\n        let field_elements = vec![k, l];\n        let res = <FieldElement as BatchInvert<_>>::batch_invert(field_elements).unwrap();\n        assert_eq!(res, expected);\n    }",
    "display_name": "batch_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_mul",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_divstep_precomp",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_divstep",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_msat",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_selectznz",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_from_montgomery",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_opp"
    ],
    "body": "    const fn invert_unchecked(&self) -> Self {\n        let words = primefield::fiat_bernstein_yang_invert!(\n            &self.0,\n            Self::ONE.0,\n            521,\n            9,\n            u64,\n            fiat_p521_scalar_non_montgomery_domain_field_element,\n            fiat_p521_scalar_montgomery_domain_field_element,\n            fiat_p521_scalar_from_montgomery,\n            fiat_p521_scalar_mul,\n            fiat_p521_scalar_opp,\n            fiat_p521_scalar_divstep_precomp,\n            fiat_p521_scalar_divstep,\n            fiat_p521_scalar_msat,\n            fiat_p521_scalar_selectznz\n        );\n\n        Self(fiat_p521_scalar_montgomery_domain_field_element(words))\n    }",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_sub(\n    out1: &mut fiat_p224_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p224_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p224_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, (x9 & 0x13dd29455c5c2a3d));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0xffff16a2e0b8f03e));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, (x9 & 0xffffffff));\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_p224_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre signing_key",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/from_nonzero_scalar",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes"
    ],
    "body": "    fn signing_key()(bytes in any::<[u8; 32]>()) -> SigningKey {\n        loop {\n            let scalar = <Scalar as Reduce<U256>>::reduce_bytes(&bytes.into());\n            if let Some(scalar) = Option::from(NonZeroScalar::new(scalar)) {\n                return SigningKey::from_nonzero_scalar(IDENTITY, scalar).unwrap();\n            }\n        }\n    }",
    "display_name": "signing_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2dsa.rs",
    "relative_path": "sm2/tests/sm2dsa.rs",
    "file_name": "sm2dsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_mulx_u64"
    ],
    "body": "pub const fn fiat_p384_square(\n    out1: &mut fiat_p384_montgomery_domain_field_element,\n    arg1: &fiat_p384_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[0]);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p384_mulx_u64(&mut x7, &mut x8, x6, (arg1[5]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p384_mulx_u64(&mut x9, &mut x10, x6, (arg1[4]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p384_mulx_u64(&mut x11, &mut x12, x6, (arg1[3]));\n    let mut x13: u64 = 0;\n    let mut x14: u64 = 0;\n    fiat_p384_mulx_u64(&mut x13, &mut x14, x6, (arg1[2]));\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p384_mulx_u64(&mut x15, &mut x16, x6, (arg1[1]));\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p384_mulx_u64(&mut x17, &mut x18, x6, (arg1[0]));\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x19, &mut x20, 0x0, x18, x15);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x21, &mut x22, x20, x16, x13);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x23, &mut x24, x22, x14, x11);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x25, &mut x26, x24, x12, x9);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x27, &mut x28, x26, x10, x7);\n    let x29: u64 = ((x28 as u64) + x8);\n    let mut x30: u64 = 0;\n    let mut x31: u64 = 0;\n    fiat_p384_mulx_u64(&mut x30, &mut x31, x17, 0x100000001);\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_p384_mulx_u64(&mut x32, &mut x33, x30, 0xffffffffffffffff);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p384_mulx_u64(&mut x34, &mut x35, x30, 0xffffffffffffffff);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p384_mulx_u64(&mut x36, &mut x37, x30, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p384_mulx_u64(&mut x38, &mut x39, x30, 0xfffffffffffffffe);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_p384_mulx_u64(&mut x40, &mut x41, x30, 0xffffffff00000000);\n    let mut x42: u64 = 0;\n    let mut x43: u64 = 0;\n    fiat_p384_mulx_u64(&mut x42, &mut x43, x30, 0xffffffff);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x44, &mut x45, 0x0, x43, x40);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x46, &mut x47, x45, x41, x38);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x48, &mut x49, x47, x39, x36);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x50, &mut x51, x49, x37, x34);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x52, &mut x53, x51, x35, x32);\n    let x54: u64 = ((x53 as u64) + x33);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x55, &mut x56, 0x0, x17, x42);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x57, &mut x58, x56, x19, x44);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x59, &mut x60, x58, x21, x46);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x61, &mut x62, x60, x23, x48);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x63, &mut x64, x62, x25, x50);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x65, &mut x66, x64, x27, x52);\n    let mut x67: u64 = 0;\n    let mut x68: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x67, &mut x68, x66, x29, x54);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_p384_mulx_u64(&mut x69, &mut x70, x1, (arg1[5]));\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_p384_mulx_u64(&mut x71, &mut x72, x1, (arg1[4]));\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_p384_mulx_u64(&mut x73, &mut x74, x1, (arg1[3]));\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_p384_mulx_u64(&mut x75, &mut x76, x1, (arg1[2]));\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p384_mulx_u64(&mut x77, &mut x78, x1, (arg1[1]));\n    let mut x79: u64 = 0;\n    let mut x80: u64 = 0;\n    fiat_p384_mulx_u64(&mut x79, &mut x80, x1, (arg1[0]));\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x81, &mut x82, 0x0, x80, x77);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x83, &mut x84, x82, x78, x75);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x85, &mut x86, x84, x76, x73);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x87, &mut x88, x86, x74, x71);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x89, &mut x90, x88, x72, x69);\n    let x91: u64 = ((x90 as u64) + x70);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x92, &mut x93, 0x0, x57, x79);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x94, &mut x95, x93, x59, x81);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x96, &mut x97, x95, x61, x83);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x98, &mut x99, x97, x63, x85);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x100, &mut x101, x99, x65, x87);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x102, &mut x103, x101, x67, x89);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x104, &mut x105, x103, (x68 as u64), x91);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p384_mulx_u64(&mut x106, &mut x107, x92, 0x100000001);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p384_mulx_u64(&mut x108, &mut x109, x106, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p384_mulx_u64(&mut x110, &mut x111, x106, 0xffffffffffffffff);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p384_mulx_u64(&mut x112, &mut x113, x106, 0xffffffffffffffff);\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p384_mulx_u64(&mut x114, &mut x115, x106, 0xfffffffffffffffe);\n    let mut x116: u64 = 0;\n    let mut x117: u64 = 0;\n    fiat_p384_mulx_u64(&mut x116, &mut x117, x106, 0xffffffff00000000);\n    let mut x118: u64 = 0;\n    let mut x119: u64 = 0;\n    fiat_p384_mulx_u64(&mut x118, &mut x119, x106, 0xffffffff);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x120, &mut x121, 0x0, x119, x116);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x122, &mut x123, x121, x117, x114);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x124, &mut x125, x123, x115, x112);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x126, &mut x127, x125, x113, x110);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x128, &mut x129, x127, x111, x108);\n    let x130: u64 = ((x129 as u64) + x109);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x131, &mut x132, 0x0, x92, x118);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x133, &mut x134, x132, x94, x120);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x135, &mut x136, x134, x96, x122);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x137, &mut x138, x136, x98, x124);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x139, &mut x140, x138, x100, x126);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x141, &mut x142, x140, x102, x128);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x143, &mut x144, x142, x104, x130);\n    let x145: u64 = ((x144 as u64) + (x105 as u64));\n    let mut x146: u64 = 0;\n    let mut x147: u64 = 0;\n    fiat_p384_mulx_u64(&mut x146, &mut x147, x2, (arg1[5]));\n    let mut x148: u64 = 0;\n    let mut x149: u64 = 0;\n    fiat_p384_mulx_u64(&mut x148, &mut x149, x2, (arg1[4]));\n    let mut x150: u64 = 0;\n    let mut x151: u64 = 0;\n    fiat_p384_mulx_u64(&mut x150, &mut x151, x2, (arg1[3]));\n    let mut x152: u64 = 0;\n    let mut x153: u64 = 0;\n    fiat_p384_mulx_u64(&mut x152, &mut x153, x2, (arg1[2]));\n    let mut x154: u64 = 0;\n    let mut x155: u64 = 0;\n    fiat_p384_mulx_u64(&mut x154, &mut x155, x2, (arg1[1]));\n    let mut x156: u64 = 0;\n    let mut x157: u64 = 0;\n    fiat_p384_mulx_u64(&mut x156, &mut x157, x2, (arg1[0]));\n    let mut x158: u64 = 0;\n    let mut x159: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x158, &mut x159, 0x0, x157, x154);\n    let mut x160: u64 = 0;\n    let mut x161: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x160, &mut x161, x159, x155, x152);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x162, &mut x163, x161, x153, x150);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x164, &mut x165, x163, x151, x148);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x166, &mut x167, x165, x149, x146);\n    let x168: u64 = ((x167 as u64) + x147);\n    let mut x169: u64 = 0;\n    let mut x170: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x169, &mut x170, 0x0, x133, x156);\n    let mut x171: u64 = 0;\n    let mut x172: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x171, &mut x172, x170, x135, x158);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x173, &mut x174, x172, x137, x160);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x175, &mut x176, x174, x139, x162);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x177, &mut x178, x176, x141, x164);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x179, &mut x180, x178, x143, x166);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x181, &mut x182, x180, x145, x168);\n    let mut x183: u64 = 0;\n    let mut x184: u64 = 0;\n    fiat_p384_mulx_u64(&mut x183, &mut x184, x169, 0x100000001);\n    let mut x185: u64 = 0;\n    let mut x186: u64 = 0;\n    fiat_p384_mulx_u64(&mut x185, &mut x186, x183, 0xffffffffffffffff);\n    let mut x187: u64 = 0;\n    let mut x188: u64 = 0;\n    fiat_p384_mulx_u64(&mut x187, &mut x188, x183, 0xffffffffffffffff);\n    let mut x189: u64 = 0;\n    let mut x190: u64 = 0;\n    fiat_p384_mulx_u64(&mut x189, &mut x190, x183, 0xffffffffffffffff);\n    let mut x191: u64 = 0;\n    let mut x192: u64 = 0;\n    fiat_p384_mulx_u64(&mut x191, &mut x192, x183, 0xfffffffffffffffe);\n    let mut x193: u64 = 0;\n    let mut x194: u64 = 0;\n    fiat_p384_mulx_u64(&mut x193, &mut x194, x183, 0xffffffff00000000);\n    let mut x195: u64 = 0;\n    let mut x196: u64 = 0;\n    fiat_p384_mulx_u64(&mut x195, &mut x196, x183, 0xffffffff);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x197, &mut x198, 0x0, x196, x193);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x199, &mut x200, x198, x194, x191);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x201, &mut x202, x200, x192, x189);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x203, &mut x204, x202, x190, x187);\n    let mut x205: u64 = 0;\n    let mut x206: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x205, &mut x206, x204, x188, x185);\n    let x207: u64 = ((x206 as u64) + x186);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x208, &mut x209, 0x0, x169, x195);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x210, &mut x211, x209, x171, x197);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x212, &mut x213, x211, x173, x199);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x214, &mut x215, x213, x175, x201);\n    let mut x216: u64 = 0;\n    let mut x217: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x216, &mut x217, x215, x177, x203);\n    let mut x218: u64 = 0;\n    let mut x219: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x218, &mut x219, x217, x179, x205);\n    let mut x220: u64 = 0;\n    let mut x221: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x220, &mut x221, x219, x181, x207);\n    let x222: u64 = ((x221 as u64) + (x182 as u64));\n    let mut x223: u64 = 0;\n    let mut x224: u64 = 0;\n    fiat_p384_mulx_u64(&mut x223, &mut x224, x3, (arg1[5]));\n    let mut x225: u64 = 0;\n    let mut x226: u64 = 0;\n    fiat_p384_mulx_u64(&mut x225, &mut x226, x3, (arg1[4]));\n    let mut x227: u64 = 0;\n    let mut x228: u64 = 0;\n    fiat_p384_mulx_u64(&mut x227, &mut x228, x3, (arg1[3]));\n    let mut x229: u64 = 0;\n    let mut x230: u64 = 0;\n    fiat_p384_mulx_u64(&mut x229, &mut x230, x3, (arg1[2]));\n    let mut x231: u64 = 0;\n    let mut x232: u64 = 0;\n    fiat_p384_mulx_u64(&mut x231, &mut x232, x3, (arg1[1]));\n    let mut x233: u64 = 0;\n    let mut x234: u64 = 0;\n    fiat_p384_mulx_u64(&mut x233, &mut x234, x3, (arg1[0]));\n    let mut x235: u64 = 0;\n    let mut x236: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x235, &mut x236, 0x0, x234, x231);\n    let mut x237: u64 = 0;\n    let mut x238: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x237, &mut x238, x236, x232, x229);\n    let mut x239: u64 = 0;\n    let mut x240: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x239, &mut x240, x238, x230, x227);\n    let mut x241: u64 = 0;\n    let mut x242: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x241, &mut x242, x240, x228, x225);\n    let mut x243: u64 = 0;\n    let mut x244: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x243, &mut x244, x242, x226, x223);\n    let x245: u64 = ((x244 as u64) + x224);\n    let mut x246: u64 = 0;\n    let mut x247: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x246, &mut x247, 0x0, x210, x233);\n    let mut x248: u64 = 0;\n    let mut x249: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x248, &mut x249, x247, x212, x235);\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x250, &mut x251, x249, x214, x237);\n    let mut x252: u64 = 0;\n    let mut x253: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x252, &mut x253, x251, x216, x239);\n    let mut x254: u64 = 0;\n    let mut x255: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x254, &mut x255, x253, x218, x241);\n    let mut x256: u64 = 0;\n    let mut x257: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x256, &mut x257, x255, x220, x243);\n    let mut x258: u64 = 0;\n    let mut x259: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x258, &mut x259, x257, x222, x245);\n    let mut x260: u64 = 0;\n    let mut x261: u64 = 0;\n    fiat_p384_mulx_u64(&mut x260, &mut x261, x246, 0x100000001);\n    let mut x262: u64 = 0;\n    let mut x263: u64 = 0;\n    fiat_p384_mulx_u64(&mut x262, &mut x263, x260, 0xffffffffffffffff);\n    let mut x264: u64 = 0;\n    let mut x265: u64 = 0;\n    fiat_p384_mulx_u64(&mut x264, &mut x265, x260, 0xffffffffffffffff);\n    let mut x266: u64 = 0;\n    let mut x267: u64 = 0;\n    fiat_p384_mulx_u64(&mut x266, &mut x267, x260, 0xffffffffffffffff);\n    let mut x268: u64 = 0;\n    let mut x269: u64 = 0;\n    fiat_p384_mulx_u64(&mut x268, &mut x269, x260, 0xfffffffffffffffe);\n    let mut x270: u64 = 0;\n    let mut x271: u64 = 0;\n    fiat_p384_mulx_u64(&mut x270, &mut x271, x260, 0xffffffff00000000);\n    let mut x272: u64 = 0;\n    let mut x273: u64 = 0;\n    fiat_p384_mulx_u64(&mut x272, &mut x273, x260, 0xffffffff);\n    let mut x274: u64 = 0;\n    let mut x275: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x274, &mut x275, 0x0, x273, x270);\n    let mut x276: u64 = 0;\n    let mut x277: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x276, &mut x277, x275, x271, x268);\n    let mut x278: u64 = 0;\n    let mut x279: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x278, &mut x279, x277, x269, x266);\n    let mut x280: u64 = 0;\n    let mut x281: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x280, &mut x281, x279, x267, x264);\n    let mut x282: u64 = 0;\n    let mut x283: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x282, &mut x283, x281, x265, x262);\n    let x284: u64 = ((x283 as u64) + x263);\n    let mut x285: u64 = 0;\n    let mut x286: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x285, &mut x286, 0x0, x246, x272);\n    let mut x287: u64 = 0;\n    let mut x288: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x287, &mut x288, x286, x248, x274);\n    let mut x289: u64 = 0;\n    let mut x290: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x289, &mut x290, x288, x250, x276);\n    let mut x291: u64 = 0;\n    let mut x292: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x291, &mut x292, x290, x252, x278);\n    let mut x293: u64 = 0;\n    let mut x294: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x293, &mut x294, x292, x254, x280);\n    let mut x295: u64 = 0;\n    let mut x296: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x295, &mut x296, x294, x256, x282);\n    let mut x297: u64 = 0;\n    let mut x298: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x297, &mut x298, x296, x258, x284);\n    let x299: u64 = ((x298 as u64) + (x259 as u64));\n    let mut x300: u64 = 0;\n    let mut x301: u64 = 0;\n    fiat_p384_mulx_u64(&mut x300, &mut x301, x4, (arg1[5]));\n    let mut x302: u64 = 0;\n    let mut x303: u64 = 0;\n    fiat_p384_mulx_u64(&mut x302, &mut x303, x4, (arg1[4]));\n    let mut x304: u64 = 0;\n    let mut x305: u64 = 0;\n    fiat_p384_mulx_u64(&mut x304, &mut x305, x4, (arg1[3]));\n    let mut x306: u64 = 0;\n    let mut x307: u64 = 0;\n    fiat_p384_mulx_u64(&mut x306, &mut x307, x4, (arg1[2]));\n    let mut x308: u64 = 0;\n    let mut x309: u64 = 0;\n    fiat_p384_mulx_u64(&mut x308, &mut x309, x4, (arg1[1]));\n    let mut x310: u64 = 0;\n    let mut x311: u64 = 0;\n    fiat_p384_mulx_u64(&mut x310, &mut x311, x4, (arg1[0]));\n    let mut x312: u64 = 0;\n    let mut x313: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x312, &mut x313, 0x0, x311, x308);\n    let mut x314: u64 = 0;\n    let mut x315: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x314, &mut x315, x313, x309, x306);\n    let mut x316: u64 = 0;\n    let mut x317: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x316, &mut x317, x315, x307, x304);\n    let mut x318: u64 = 0;\n    let mut x319: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x318, &mut x319, x317, x305, x302);\n    let mut x320: u64 = 0;\n    let mut x321: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x320, &mut x321, x319, x303, x300);\n    let x322: u64 = ((x321 as u64) + x301);\n    let mut x323: u64 = 0;\n    let mut x324: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x323, &mut x324, 0x0, x287, x310);\n    let mut x325: u64 = 0;\n    let mut x326: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x325, &mut x326, x324, x289, x312);\n    let mut x327: u64 = 0;\n    let mut x328: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x327, &mut x328, x326, x291, x314);\n    let mut x329: u64 = 0;\n    let mut x330: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x329, &mut x330, x328, x293, x316);\n    let mut x331: u64 = 0;\n    let mut x332: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x331, &mut x332, x330, x295, x318);\n    let mut x333: u64 = 0;\n    let mut x334: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x333, &mut x334, x332, x297, x320);\n    let mut x335: u64 = 0;\n    let mut x336: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x335, &mut x336, x334, x299, x322);\n    let mut x337: u64 = 0;\n    let mut x338: u64 = 0;\n    fiat_p384_mulx_u64(&mut x337, &mut x338, x323, 0x100000001);\n    let mut x339: u64 = 0;\n    let mut x340: u64 = 0;\n    fiat_p384_mulx_u64(&mut x339, &mut x340, x337, 0xffffffffffffffff);\n    let mut x341: u64 = 0;\n    let mut x342: u64 = 0;\n    fiat_p384_mulx_u64(&mut x341, &mut x342, x337, 0xffffffffffffffff);\n    let mut x343: u64 = 0;\n    let mut x344: u64 = 0;\n    fiat_p384_mulx_u64(&mut x343, &mut x344, x337, 0xffffffffffffffff);\n    let mut x345: u64 = 0;\n    let mut x346: u64 = 0;\n    fiat_p384_mulx_u64(&mut x345, &mut x346, x337, 0xfffffffffffffffe);\n    let mut x347: u64 = 0;\n    let mut x348: u64 = 0;\n    fiat_p384_mulx_u64(&mut x347, &mut x348, x337, 0xffffffff00000000);\n    let mut x349: u64 = 0;\n    let mut x350: u64 = 0;\n    fiat_p384_mulx_u64(&mut x349, &mut x350, x337, 0xffffffff);\n    let mut x351: u64 = 0;\n    let mut x352: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x351, &mut x352, 0x0, x350, x347);\n    let mut x353: u64 = 0;\n    let mut x354: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x353, &mut x354, x352, x348, x345);\n    let mut x355: u64 = 0;\n    let mut x356: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x355, &mut x356, x354, x346, x343);\n    let mut x357: u64 = 0;\n    let mut x358: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x357, &mut x358, x356, x344, x341);\n    let mut x359: u64 = 0;\n    let mut x360: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x359, &mut x360, x358, x342, x339);\n    let x361: u64 = ((x360 as u64) + x340);\n    let mut x362: u64 = 0;\n    let mut x363: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x362, &mut x363, 0x0, x323, x349);\n    let mut x364: u64 = 0;\n    let mut x365: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x364, &mut x365, x363, x325, x351);\n    let mut x366: u64 = 0;\n    let mut x367: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x366, &mut x367, x365, x327, x353);\n    let mut x368: u64 = 0;\n    let mut x369: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x368, &mut x369, x367, x329, x355);\n    let mut x370: u64 = 0;\n    let mut x371: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x370, &mut x371, x369, x331, x357);\n    let mut x372: u64 = 0;\n    let mut x373: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x372, &mut x373, x371, x333, x359);\n    let mut x374: u64 = 0;\n    let mut x375: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x374, &mut x375, x373, x335, x361);\n    let x376: u64 = ((x375 as u64) + (x336 as u64));\n    let mut x377: u64 = 0;\n    let mut x378: u64 = 0;\n    fiat_p384_mulx_u64(&mut x377, &mut x378, x5, (arg1[5]));\n    let mut x379: u64 = 0;\n    let mut x380: u64 = 0;\n    fiat_p384_mulx_u64(&mut x379, &mut x380, x5, (arg1[4]));\n    let mut x381: u64 = 0;\n    let mut x382: u64 = 0;\n    fiat_p384_mulx_u64(&mut x381, &mut x382, x5, (arg1[3]));\n    let mut x383: u64 = 0;\n    let mut x384: u64 = 0;\n    fiat_p384_mulx_u64(&mut x383, &mut x384, x5, (arg1[2]));\n    let mut x385: u64 = 0;\n    let mut x386: u64 = 0;\n    fiat_p384_mulx_u64(&mut x385, &mut x386, x5, (arg1[1]));\n    let mut x387: u64 = 0;\n    let mut x388: u64 = 0;\n    fiat_p384_mulx_u64(&mut x387, &mut x388, x5, (arg1[0]));\n    let mut x389: u64 = 0;\n    let mut x390: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x389, &mut x390, 0x0, x388, x385);\n    let mut x391: u64 = 0;\n    let mut x392: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x391, &mut x392, x390, x386, x383);\n    let mut x393: u64 = 0;\n    let mut x394: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x393, &mut x394, x392, x384, x381);\n    let mut x395: u64 = 0;\n    let mut x396: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x395, &mut x396, x394, x382, x379);\n    let mut x397: u64 = 0;\n    let mut x398: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x397, &mut x398, x396, x380, x377);\n    let x399: u64 = ((x398 as u64) + x378);\n    let mut x400: u64 = 0;\n    let mut x401: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x400, &mut x401, 0x0, x364, x387);\n    let mut x402: u64 = 0;\n    let mut x403: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x402, &mut x403, x401, x366, x389);\n    let mut x404: u64 = 0;\n    let mut x405: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x404, &mut x405, x403, x368, x391);\n    let mut x406: u64 = 0;\n    let mut x407: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x406, &mut x407, x405, x370, x393);\n    let mut x408: u64 = 0;\n    let mut x409: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x408, &mut x409, x407, x372, x395);\n    let mut x410: u64 = 0;\n    let mut x411: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x410, &mut x411, x409, x374, x397);\n    let mut x412: u64 = 0;\n    let mut x413: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x412, &mut x413, x411, x376, x399);\n    let mut x414: u64 = 0;\n    let mut x415: u64 = 0;\n    fiat_p384_mulx_u64(&mut x414, &mut x415, x400, 0x100000001);\n    let mut x416: u64 = 0;\n    let mut x417: u64 = 0;\n    fiat_p384_mulx_u64(&mut x416, &mut x417, x414, 0xffffffffffffffff);\n    let mut x418: u64 = 0;\n    let mut x419: u64 = 0;\n    fiat_p384_mulx_u64(&mut x418, &mut x419, x414, 0xffffffffffffffff);\n    let mut x420: u64 = 0;\n    let mut x421: u64 = 0;\n    fiat_p384_mulx_u64(&mut x420, &mut x421, x414, 0xffffffffffffffff);\n    let mut x422: u64 = 0;\n    let mut x423: u64 = 0;\n    fiat_p384_mulx_u64(&mut x422, &mut x423, x414, 0xfffffffffffffffe);\n    let mut x424: u64 = 0;\n    let mut x425: u64 = 0;\n    fiat_p384_mulx_u64(&mut x424, &mut x425, x414, 0xffffffff00000000);\n    let mut x426: u64 = 0;\n    let mut x427: u64 = 0;\n    fiat_p384_mulx_u64(&mut x426, &mut x427, x414, 0xffffffff);\n    let mut x428: u64 = 0;\n    let mut x429: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x428, &mut x429, 0x0, x427, x424);\n    let mut x430: u64 = 0;\n    let mut x431: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x430, &mut x431, x429, x425, x422);\n    let mut x432: u64 = 0;\n    let mut x433: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x432, &mut x433, x431, x423, x420);\n    let mut x434: u64 = 0;\n    let mut x435: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x434, &mut x435, x433, x421, x418);\n    let mut x436: u64 = 0;\n    let mut x437: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x436, &mut x437, x435, x419, x416);\n    let x438: u64 = ((x437 as u64) + x417);\n    let mut x439: u64 = 0;\n    let mut x440: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x439, &mut x440, 0x0, x400, x426);\n    let mut x441: u64 = 0;\n    let mut x442: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x441, &mut x442, x440, x402, x428);\n    let mut x443: u64 = 0;\n    let mut x444: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x443, &mut x444, x442, x404, x430);\n    let mut x445: u64 = 0;\n    let mut x446: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x445, &mut x446, x444, x406, x432);\n    let mut x447: u64 = 0;\n    let mut x448: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x447, &mut x448, x446, x408, x434);\n    let mut x449: u64 = 0;\n    let mut x450: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x449, &mut x450, x448, x410, x436);\n    let mut x451: u64 = 0;\n    let mut x452: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x451, &mut x452, x450, x412, x438);\n    let x453: u64 = ((x452 as u64) + (x413 as u64));\n    let mut x454: u64 = 0;\n    let mut x455: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x454, &mut x455, 0x0, x441, 0xffffffff);\n    let mut x456: u64 = 0;\n    let mut x457: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x456, &mut x457, x455, x443, 0xffffffff00000000);\n    let mut x458: u64 = 0;\n    let mut x459: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x458, &mut x459, x457, x445, 0xfffffffffffffffe);\n    let mut x460: u64 = 0;\n    let mut x461: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x460, &mut x461, x459, x447, 0xffffffffffffffff);\n    let mut x462: u64 = 0;\n    let mut x463: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x462, &mut x463, x461, x449, 0xffffffffffffffff);\n    let mut x464: u64 = 0;\n    let mut x465: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x464, &mut x465, x463, x451, 0xffffffffffffffff);\n    let mut x466: u64 = 0;\n    let mut x467: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x466, &mut x467, x465, x453, (0x0 as u64));\n    let mut x468: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x468, x467, x454, x441);\n    let mut x469: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x469, x467, x456, x443);\n    let mut x470: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x470, x467, x458, x445);\n    let mut x471: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x471, x467, x460, x447);\n    let mut x472: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x472, x467, x462, x449);\n    let mut x473: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x473, x467, x464, x451);\n    out1[0] = x468;\n    out1[1] = x469;\n    out1[2] = x470;\n    out1[3] = x471;\n    out1[4] = x472;\n    out1[5] = x473;\n}",
    "display_name": "fiat_p384_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/multiply"
    ],
    "body": "    pub const fn square(&self) -> Self {\n        // Schoolbook multiplication.\n        self.multiply(self)\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/mul_by_generator",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/double",
      "0.14.0_pre.8 arithmetic/mul/impl/Radix16Decomposition/new",
      "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/select"
    ],
    "body": "    pub(super) fn mul_by_generator(k: &Scalar) -> ProjectivePoint {\n        let digits = Radix16Decomposition::<65>::new(k);\n        let table = *GEN_LOOKUP_TABLE;\n        let mut acc = table[32].select(digits.0[64]);\n        let mut acc2 = ProjectivePoint::IDENTITY;\n        for i in (0..32).rev() {\n            acc2 += &table[i].select(digits.0[i * 2 + 1]);\n            acc += &table[i].select(digits.0[i * 2]);\n        }\n        // This is the price of halving the precomputed table size (from 60kb to 30kb)\n        // The performance hit is minor, about 3%.\n        for _ in 0..4 {\n            acc2 = acc2.double();\n        }\n        acc + acc2\n    }",
    "display_name": "mul_by_generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/r",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn r(&self) -> NonZeroScalar {\n        NonZeroScalar::new(self.r.into()).unwrap()\n    }",
    "display_name": "r",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    pub fn to_bytes_rfc_8032(&self) -> ScalarBytes {\n        let mut bytes = ScalarBytes::default();\n        bytes[..56].copy_from_slice(&self.to_bytes());\n        bytes\n    }",
    "display_name": "to_bytes_rfc_8032",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "affine/impl/AffinePoint/PrimeCurveAffine/is_identity",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/is_identity"
    ],
    "body": "    fn is_identity(&self) -> Choice {\n        self.is_identity()\n    }",
    "display_name": "is_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre encrypt_and_decrypt_mode",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre decrypting_key_c1c2c3",
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt",
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt",
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/encrypting_key"
    ],
    "body": "    fn encrypt_and_decrypt_mode(dk in decrypting_key_c1c2c3()) {\n        let ek = dk.encrypting_key();\n        let cipher_bytes = ek.encrypt(&mut OsRng, MSG).unwrap();\n        assert_eq!(\n            dk.decrypt(&cipher_bytes)\n                .unwrap(),\n            MSG\n        );\n    }",
    "display_name": "encrypt_and_decrypt_mode",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2pke.rs",
    "relative_path": "sm2/tests/sm2pke.rs",
    "file_name": "sm2pke.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/s",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn s(&self) -> NonZeroScalar {\n        NonZeroScalar::new(self.s.into()).unwrap()\n    }",
    "display_name": "s",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p384_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 7],\n    out3: &mut [u64; 7],\n    out4: &mut [u64; 6],\n    out5: &mut [u64; 6],\n    arg1: u64,\n    arg2: &[u64; 7],\n    arg3: &[u64; 7],\n    arg4: &[u64; 6],\n    arg5: &[u64; 6],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_p384_u1 =\n        (((x1 >> 63) as fiat_p384_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_p384_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x12, x3, (arg2[5]), (arg3[5]));\n    let mut x13: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x13, x3, (arg2[6]), (arg3[6]));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x14, &mut x15, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), (!(arg2[1])));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), (!(arg2[2])));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), (!(arg2[3])));\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x22, &mut x23, x21, (0x0 as u64), (!(arg2[4])));\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x24, &mut x25, x23, (0x0 as u64), (!(arg2[5])));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x26, &mut x27, x25, (0x0 as u64), (!(arg2[6])));\n    let mut x28: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x28, x3, (arg3[0]), x14);\n    let mut x29: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x29, x3, (arg3[1]), x16);\n    let mut x30: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x30, x3, (arg3[2]), x18);\n    let mut x31: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x31, x3, (arg3[3]), x20);\n    let mut x32: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x32, x3, (arg3[4]), x22);\n    let mut x33: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x33, x3, (arg3[5]), x24);\n    let mut x34: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x34, x3, (arg3[6]), x26);\n    let mut x35: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x35, x3, (arg4[0]), (arg5[0]));\n    let mut x36: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x36, x3, (arg4[1]), (arg5[1]));\n    let mut x37: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x37, x3, (arg4[2]), (arg5[2]));\n    let mut x38: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x38, x3, (arg4[3]), (arg5[3]));\n    let mut x39: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x39, x3, (arg4[4]), (arg5[4]));\n    let mut x40: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x40, x3, (arg4[5]), (arg5[5]));\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x41, &mut x42, 0x0, x35, x35);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x43, &mut x44, x42, x36, x36);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x45, &mut x46, x44, x37, x37);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x47, &mut x48, x46, x38, x38);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x49, &mut x50, x48, x39, x39);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x51, &mut x52, x50, x40, x40);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x53, &mut x54, 0x0, x41, 0xffffffff);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x55, &mut x56, x54, x43, 0xffffffff00000000);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x57, &mut x58, x56, x45, 0xfffffffffffffffe);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x59, &mut x60, x58, x47, 0xffffffffffffffff);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x61, &mut x62, x60, x49, 0xffffffffffffffff);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x63, &mut x64, x62, x51, 0xffffffffffffffff);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x65, &mut x66, x64, (x52 as u64), (0x0 as u64));\n    let x67: u64 = (arg4[5]);\n    let x68: u64 = (arg4[4]);\n    let x69: u64 = (arg4[3]);\n    let x70: u64 = (arg4[2]);\n    let x71: u64 = (arg4[1]);\n    let x72: u64 = (arg4[0]);\n    let mut x73: u64 = 0;\n    let mut x74: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x73, &mut x74, 0x0, (0x0 as u64), x72);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x75, &mut x76, x74, (0x0 as u64), x71);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x77, &mut x78, x76, (0x0 as u64), x70);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x79, &mut x80, x78, (0x0 as u64), x69);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x81, &mut x82, x80, (0x0 as u64), x68);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x83, &mut x84, x82, (0x0 as u64), x67);\n    let mut x85: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x85, x84, (0x0 as u64), 0xffffffffffffffff);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x86, &mut x87, 0x0, x73, (x85 & 0xffffffff));\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x88, &mut x89, x87, x75, (x85 & 0xffffffff00000000));\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x90, &mut x91, x89, x77, (x85 & 0xfffffffffffffffe));\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x92, &mut x93, x91, x79, x85);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x94, &mut x95, x93, x81, x85);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x96, &mut x97, x95, x83, x85);\n    let mut x98: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x98, x3, (arg5[0]), x86);\n    let mut x99: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x99, x3, (arg5[1]), x88);\n    let mut x100: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x100, x3, (arg5[2]), x90);\n    let mut x101: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x101, x3, (arg5[3]), x92);\n    let mut x102: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x102, x3, (arg5[4]), x94);\n    let mut x103: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x103, x3, (arg5[5]), x96);\n    let x104: fiat_p384_u1 = ((x28 & (0x1 as u64)) as fiat_p384_u1);\n    let mut x105: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x105, x104, (0x0 as u64), x7);\n    let mut x106: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x106, x104, (0x0 as u64), x8);\n    let mut x107: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x107, x104, (0x0 as u64), x9);\n    let mut x108: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x108, x104, (0x0 as u64), x10);\n    let mut x109: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x109, x104, (0x0 as u64), x11);\n    let mut x110: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x110, x104, (0x0 as u64), x12);\n    let mut x111: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x111, x104, (0x0 as u64), x13);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x112, &mut x113, 0x0, x28, x105);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x114, &mut x115, x113, x29, x106);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x116, &mut x117, x115, x30, x107);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x118, &mut x119, x117, x31, x108);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x120, &mut x121, x119, x32, x109);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x122, &mut x123, x121, x33, x110);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x124, &mut x125, x123, x34, x111);\n    let mut x126: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x126, x104, (0x0 as u64), x35);\n    let mut x127: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x127, x104, (0x0 as u64), x36);\n    let mut x128: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x128, x104, (0x0 as u64), x37);\n    let mut x129: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x129, x104, (0x0 as u64), x38);\n    let mut x130: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x130, x104, (0x0 as u64), x39);\n    let mut x131: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x131, x104, (0x0 as u64), x40);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x132, &mut x133, 0x0, x98, x126);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x134, &mut x135, x133, x99, x127);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x136, &mut x137, x135, x100, x128);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x138, &mut x139, x137, x101, x129);\n    let mut x140: u64 = 0;\n    let mut x141: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x140, &mut x141, x139, x102, x130);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x142, &mut x143, x141, x103, x131);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x144, &mut x145, 0x0, x132, 0xffffffff);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x146, &mut x147, x145, x134, 0xffffffff00000000);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x148, &mut x149, x147, x136, 0xfffffffffffffffe);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x150, &mut x151, x149, x138, 0xffffffffffffffff);\n    let mut x152: u64 = 0;\n    let mut x153: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x152, &mut x153, x151, x140, 0xffffffffffffffff);\n    let mut x154: u64 = 0;\n    let mut x155: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x154, &mut x155, x153, x142, 0xffffffffffffffff);\n    let mut x156: u64 = 0;\n    let mut x157: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x156, &mut x157, x155, (x143 as u64), (0x0 as u64));\n    let mut x158: u64 = 0;\n    let mut x159: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x158, &mut x159, 0x0, x6, (0x1 as u64));\n    let x160: u64 = ((x112 >> 1) | ((x114 << 63) & 0xffffffffffffffff));\n    let x161: u64 = ((x114 >> 1) | ((x116 << 63) & 0xffffffffffffffff));\n    let x162: u64 = ((x116 >> 1) | ((x118 << 63) & 0xffffffffffffffff));\n    let x163: u64 = ((x118 >> 1) | ((x120 << 63) & 0xffffffffffffffff));\n    let x164: u64 = ((x120 >> 1) | ((x122 << 63) & 0xffffffffffffffff));\n    let x165: u64 = ((x122 >> 1) | ((x124 << 63) & 0xffffffffffffffff));\n    let x166: u64 = ((x124 & 0x8000000000000000) | (x124 >> 1));\n    let mut x167: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x167, x66, x53, x41);\n    let mut x168: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x168, x66, x55, x43);\n    let mut x169: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x169, x66, x57, x45);\n    let mut x170: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x170, x66, x59, x47);\n    let mut x171: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x171, x66, x61, x49);\n    let mut x172: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x172, x66, x63, x51);\n    let mut x173: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x173, x157, x144, x132);\n    let mut x174: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x174, x157, x146, x134);\n    let mut x175: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x175, x157, x148, x136);\n    let mut x176: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x176, x157, x150, x138);\n    let mut x177: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x177, x157, x152, x140);\n    let mut x178: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x178, x157, x154, x142);\n    *out1 = x158;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out2[5] = x12;\n    out2[6] = x13;\n    out3[0] = x160;\n    out3[1] = x161;\n    out3[2] = x162;\n    out3[3] = x163;\n    out3[4] = x164;\n    out3[5] = x165;\n    out3[6] = x166;\n    out4[0] = x167;\n    out4[1] = x168;\n    out4[2] = x169;\n    out4[3] = x170;\n    out4[4] = x171;\n    out4[5] = x172;\n    out5[0] = x173;\n    out5[1] = x174;\n    out5[2] = x175;\n    out5[3] = x176;\n    out5[4] = x177;\n    out5[5] = x178;\n}",
    "display_name": "fiat_p384_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes(bytes: &FieldBytes) -> Result<Self> {\n        let inner: ScalarPrimitive =\n            Option::from(ScalarPrimitive::from_bytes(bytes)).ok_or(Error)?;\n\n        if inner.is_zero().into() {\n            return Err(Error);\n        }\n\n        Ok(Self { inner })\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre create_test_signing_key",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
      "0.14.0_pre dsa/signing/impl/SigningKey/from_nonzero_scalar"
    ],
    "body": "fn create_test_signing_key() -> SigningKey {\n    // Use a fixed test key for deterministic testing\n    let test_key = [42u8; 32];\n    let scalar = <Scalar as Reduce<U256>>::reduce_bytes(&test_key.into());\n    let scalar = NonZeroScalar::new(scalar).unwrap();\n    SigningKey::from_nonzero_scalar(IDENTITY.into(), scalar).unwrap()\n}",
    "display_name": "create_test_signing_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/dsa_extended.rs",
    "relative_path": "sm2/tests/dsa_extended.rs",
    "file_name": "dsa_extended.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64"
    ],
    "body": "pub const fn fiat_sm2_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 5],\n    out3: &mut [u64; 5],\n    out4: &mut [u64; 4],\n    out5: &mut [u64; 4],\n    arg1: u64,\n    arg2: &[u64; 5],\n    arg3: &[u64; 5],\n    arg4: &[u64; 4],\n    arg5: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_sm2_u1 =\n        (((x1 >> 63) as fiat_sm2_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_sm2_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x12, &mut x13, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x14, &mut x15, x13, (0x0 as u64), (!(arg2[1])));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), (!(arg2[2])));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), (!(arg2[3])));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), (!(arg2[4])));\n    let mut x22: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x22, x3, (arg3[0]), x12);\n    let mut x23: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x23, x3, (arg3[1]), x14);\n    let mut x24: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x24, x3, (arg3[2]), x16);\n    let mut x25: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x25, x3, (arg3[3]), x18);\n    let mut x26: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x26, x3, (arg3[4]), x20);\n    let mut x27: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x27, x3, (arg4[0]), (arg5[0]));\n    let mut x28: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x28, x3, (arg4[1]), (arg5[1]));\n    let mut x29: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x29, x3, (arg4[2]), (arg5[2]));\n    let mut x30: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x30, x3, (arg4[3]), (arg5[3]));\n    let mut x31: u64 = 0;\n    let mut x32: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x31, &mut x32, 0x0, x27, x27);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x33, &mut x34, x32, x28, x28);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x35, &mut x36, x34, x29, x29);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x37, &mut x38, x36, x30, x30);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x39, &mut x40, 0x0, x31, 0xffffffffffffffff);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x41, &mut x42, x40, x33, 0xffffffff00000000);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x43, &mut x44, x42, x35, 0xffffffffffffffff);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x45, &mut x46, x44, x37, 0xfffffffeffffffff);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x47, &mut x48, x46, (x38 as u64), (0x0 as u64));\n    let x49: u64 = (arg4[3]);\n    let x50: u64 = (arg4[2]);\n    let x51: u64 = (arg4[1]);\n    let x52: u64 = (arg4[0]);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x53, &mut x54, 0x0, (0x0 as u64), x52);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x55, &mut x56, x54, (0x0 as u64), x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x57, &mut x58, x56, (0x0 as u64), x50);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x59, &mut x60, x58, (0x0 as u64), x49);\n    let mut x61: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x61, x60, (0x0 as u64), 0xffffffffffffffff);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x62, &mut x63, 0x0, x53, x61);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x64, &mut x65, x63, x55, (x61 & 0xffffffff00000000));\n    let mut x66: u64 = 0;\n    let mut x67: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x66, &mut x67, x65, x57, x61);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x68, &mut x69, x67, x59, (x61 & 0xfffffffeffffffff));\n    let mut x70: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x70, x3, (arg5[0]), x62);\n    let mut x71: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x71, x3, (arg5[1]), x64);\n    let mut x72: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x72, x3, (arg5[2]), x66);\n    let mut x73: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x73, x3, (arg5[3]), x68);\n    let x74: fiat_sm2_u1 = ((x22 & (0x1 as u64)) as fiat_sm2_u1);\n    let mut x75: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x75, x74, (0x0 as u64), x7);\n    let mut x76: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x76, x74, (0x0 as u64), x8);\n    let mut x77: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x77, x74, (0x0 as u64), x9);\n    let mut x78: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x78, x74, (0x0 as u64), x10);\n    let mut x79: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x79, x74, (0x0 as u64), x11);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x80, &mut x81, 0x0, x22, x75);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x82, &mut x83, x81, x23, x76);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x84, &mut x85, x83, x24, x77);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x86, &mut x87, x85, x25, x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x88, &mut x89, x87, x26, x79);\n    let mut x90: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x90, x74, (0x0 as u64), x27);\n    let mut x91: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x91, x74, (0x0 as u64), x28);\n    let mut x92: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x92, x74, (0x0 as u64), x29);\n    let mut x93: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x93, x74, (0x0 as u64), x30);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x94, &mut x95, 0x0, x70, x90);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x96, &mut x97, x95, x71, x91);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x98, &mut x99, x97, x72, x92);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x100, &mut x101, x99, x73, x93);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x102, &mut x103, 0x0, x94, 0xffffffffffffffff);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x104, &mut x105, x103, x96, 0xffffffff00000000);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x106, &mut x107, x105, x98, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x108, &mut x109, x107, x100, 0xfffffffeffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x110, &mut x111, x109, (x101 as u64), (0x0 as u64));\n    let mut x112: u64 = 0;\n    let mut x113: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x112, &mut x113, 0x0, x6, (0x1 as u64));\n    let x114: u64 = ((x80 >> 1) | ((x82 << 63) & 0xffffffffffffffff));\n    let x115: u64 = ((x82 >> 1) | ((x84 << 63) & 0xffffffffffffffff));\n    let x116: u64 = ((x84 >> 1) | ((x86 << 63) & 0xffffffffffffffff));\n    let x117: u64 = ((x86 >> 1) | ((x88 << 63) & 0xffffffffffffffff));\n    let x118: u64 = ((x88 & 0x8000000000000000) | (x88 >> 1));\n    let mut x119: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x119, x48, x39, x31);\n    let mut x120: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x120, x48, x41, x33);\n    let mut x121: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x121, x48, x43, x35);\n    let mut x122: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x122, x48, x45, x37);\n    let mut x123: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x123, x111, x102, x94);\n    let mut x124: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x124, x111, x104, x96);\n    let mut x125: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x125, x111, x106, x98);\n    let mut x126: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x126, x111, x108, x100);\n    *out1 = x112;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out3[0] = x114;\n    out3[1] = x115;\n    out3[2] = x116;\n    out3[3] = x117;\n    out3[4] = x118;\n    out4[0] = x119;\n    out4[1] = x120;\n    out4[2] = x121;\n    out4[3] = x122;\n    out5[0] = x123;\n    out5[1] = x124;\n    out5[2] = x125;\n    out5[3] = x126;\n}",
    "display_name": "fiat_sm2_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from",
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint"
    ],
    "body": "        fn fuzzy_neg(a in scalar()) {\n            let a_bi = a.to_biguint().unwrap();\n\n            let m = Scalar::modulus_as_biguint();\n            let res_bi = (&m - &a_bi) % &m;\n            let res_ref = Scalar::from(&res_bi);\n            let res_test = -a;\n\n            assert_eq!(res_ref, res_test);\n        }",
    "display_name": "fuzzy_neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        let XZ = self.X * other.Z;\n        let ZX = self.Z * other.X;\n\n        let YZ = self.Y * other.Z;\n        let ZY = self.Z * other.Y;\n\n        (XZ.ct_eq(&ZX)) & (YZ.ct_eq(&ZY))\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 5],\n    out3: &mut [u64; 5],\n    out4: &mut [u64; 4],\n    out5: &mut [u64; 4],\n    arg1: u64,\n    arg2: &[u64; 5],\n    arg3: &[u64; 5],\n    arg4: &[u64; 4],\n    arg5: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_sm2_scalar_u1 =\n        (((x1 >> 63) as fiat_sm2_scalar_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_sm2_scalar_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x12, &mut x13, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x14, &mut x15, x13, (0x0 as u64), (!(arg2[1])));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), (!(arg2[2])));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), (!(arg2[3])));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), (!(arg2[4])));\n    let mut x22: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x22, x3, (arg3[0]), x12);\n    let mut x23: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x23, x3, (arg3[1]), x14);\n    let mut x24: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x24, x3, (arg3[2]), x16);\n    let mut x25: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x25, x3, (arg3[3]), x18);\n    let mut x26: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x26, x3, (arg3[4]), x20);\n    let mut x27: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x27, x3, (arg4[0]), (arg5[0]));\n    let mut x28: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x28, x3, (arg4[1]), (arg5[1]));\n    let mut x29: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x29, x3, (arg4[2]), (arg5[2]));\n    let mut x30: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x30, x3, (arg4[3]), (arg5[3]));\n    let mut x31: u64 = 0;\n    let mut x32: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x31, &mut x32, 0x0, x27, x27);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x33, &mut x34, x32, x28, x28);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x35, &mut x36, x34, x29, x29);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x37, &mut x38, x36, x30, x30);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x39, &mut x40, 0x0, x31, 0x53bbf40939d54123);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x41, &mut x42, x40, x33, 0x7203df6b21c6052b);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x43, &mut x44, x42, x35, 0xffffffffffffffff);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x45, &mut x46, x44, x37, 0xfffffffeffffffff);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x47, &mut x48, x46, (x38 as u64), (0x0 as u64));\n    let x49: u64 = (arg4[3]);\n    let x50: u64 = (arg4[2]);\n    let x51: u64 = (arg4[1]);\n    let x52: u64 = (arg4[0]);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x53, &mut x54, 0x0, (0x0 as u64), x52);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x55, &mut x56, x54, (0x0 as u64), x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x57, &mut x58, x56, (0x0 as u64), x50);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x59, &mut x60, x58, (0x0 as u64), x49);\n    let mut x61: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x61, x60, (0x0 as u64), 0xffffffffffffffff);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x53, (x61 & 0x53bbf40939d54123));\n    let mut x64: u64 = 0;\n    let mut x65: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x55, (x61 & 0x7203df6b21c6052b));\n    let mut x66: u64 = 0;\n    let mut x67: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x57, x61);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x59, (x61 & 0xfffffffeffffffff));\n    let mut x70: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x70, x3, (arg5[0]), x62);\n    let mut x71: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x71, x3, (arg5[1]), x64);\n    let mut x72: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x72, x3, (arg5[2]), x66);\n    let mut x73: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x73, x3, (arg5[3]), x68);\n    let x74: fiat_sm2_scalar_u1 = ((x22 & (0x1 as u64)) as fiat_sm2_scalar_u1);\n    let mut x75: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x75, x74, (0x0 as u64), x7);\n    let mut x76: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x76, x74, (0x0 as u64), x8);\n    let mut x77: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x77, x74, (0x0 as u64), x9);\n    let mut x78: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x78, x74, (0x0 as u64), x10);\n    let mut x79: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x79, x74, (0x0 as u64), x11);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x80, &mut x81, 0x0, x22, x75);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x23, x76);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x24, x77);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x25, x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x26, x79);\n    let mut x90: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x90, x74, (0x0 as u64), x27);\n    let mut x91: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x91, x74, (0x0 as u64), x28);\n    let mut x92: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x92, x74, (0x0 as u64), x29);\n    let mut x93: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x93, x74, (0x0 as u64), x30);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x94, &mut x95, 0x0, x70, x90);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x71, x91);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x72, x92);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x73, x93);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x102, &mut x103, 0x0, x94, 0x53bbf40939d54123);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x104, &mut x105, x103, x96, 0x7203df6b21c6052b);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x106, &mut x107, x105, x98, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x108, &mut x109, x107, x100, 0xfffffffeffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x110, &mut x111, x109, (x101 as u64), (0x0 as u64));\n    let mut x112: u64 = 0;\n    let mut x113: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x112, &mut x113, 0x0, x6, (0x1 as u64));\n    let x114: u64 = ((x80 >> 1) | ((x82 << 63) & 0xffffffffffffffff));\n    let x115: u64 = ((x82 >> 1) | ((x84 << 63) & 0xffffffffffffffff));\n    let x116: u64 = ((x84 >> 1) | ((x86 << 63) & 0xffffffffffffffff));\n    let x117: u64 = ((x86 >> 1) | ((x88 << 63) & 0xffffffffffffffff));\n    let x118: u64 = ((x88 & 0x8000000000000000) | (x88 >> 1));\n    let mut x119: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x119, x48, x39, x31);\n    let mut x120: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x120, x48, x41, x33);\n    let mut x121: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x121, x48, x43, x35);\n    let mut x122: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x122, x48, x45, x37);\n    let mut x123: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x123, x111, x102, x94);\n    let mut x124: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x124, x111, x104, x96);\n    let mut x125: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x125, x111, x106, x98);\n    let mut x126: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x126, x111, x108, x100);\n    *out1 = x112;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out3[0] = x114;\n    out3[1] = x115;\n    out3[2] = x116;\n    out3[3] = x117;\n    out3[4] = x118;\n    out4[0] = x119;\n    out4[1] = x120;\n    out4[2] = x121;\n    out4[3] = x122;\n    out5[0] = x123;\n    out5[1] = x124;\n    out5[2] = x125;\n    out5[3] = x126;\n}",
    "display_name": "fiat_sm2_scalar_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre test_special_messages",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/Verifier/verify",
      "0.14.0_pre create_test_signing_key",
      "0.14.0_pre dsa/signing/impl/SigningKey/verifying_key"
    ],
    "body": "fn test_special_messages() {\n    let sk = create_test_signing_key();\n    let special_msgs = vec![\n        vec![0u8; 32],      // All zeros\n        vec![255u8; 32],    // All ones\n        b\"\\n\\r\\t\".to_vec(), // Control chars\n    ];\n\n    for msg in special_msgs {\n        let sig = sk.sign(&msg);\n        assert!(sk.verifying_key().verify(&msg, &sig).is_ok());\n    }\n}",
    "display_name": "test_special_messages",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/dsa_extended.rs",
    "relative_path": "sm2/tests/dsa_extended.rs",
    "file_name": "dsa_extended.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/from_seed"
    ],
    "body": "    fn from(secret_key: &SecretKey) -> Self {\n        Self::from_seed(secret_key)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/expanded.rs",
    "relative_path": "ed448-goldilocks/src/sign/expanded.rs",
    "file_name": "expanded.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre bench_field_element_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_field_element_x"
    ],
    "body": "fn bench_field_element_square<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"square\", |b| b.iter(|| x.square()));\n}",
    "display_name": "bench_field_element_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/field.rs",
    "relative_path": "bign256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/From>/from"
    ],
    "body": "    fn from(scalar: NonZeroScalar) -> SecretKey {\n        SecretKey::from(&scalar)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_nonzero(out1: &mut u64, arg1: &[u64; 4]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | ((arg1[2]) | (arg1[3]))));\n    *out1 = x1;\n}",
    "display_name": "fiat_bign256_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, point: &EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: &'s Scalar) {\n        *self = *self * scalar;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/scalar_mul/window/wnaf/test_lookup",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/scalar_mul/window/wnaf/impl/LookupTable/select",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/scalar_mul/window/wnaf/impl/LookupTable/From/from",
      "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/to_extended",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended"
    ],
    "body": "fn test_lookup() {\n    let p = ExtendedPoint::GENERATOR;\n    let points = LookupTable::from(&p);\n\n    let mut expected_point = ExtendedPoint::IDENTITY;\n    for i in 0..8 {\n        let selected_point = points.select(i);\n        assert_eq!(selected_point.to_extended(), expected_point);\n\n        expected_point = expected_point\n            .to_extensible()\n            .add_extended(&p)\n            .to_extended();\n    }\n}",
    "display_name": "test_lookup",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/scalar_mul/window/wnaf.rs",
    "relative_path": "ed448-goldilocks/src/curve/scalar_mul/window/wnaf.rs",
    "file_name": "wnaf.rs",
    "parent_folder": "window"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/GroupEncoding/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        EncodedPoint::from_bytes(bytes)\n            .map(|point| CtOption::new(point, Choice::from(1)))\n            .unwrap_or_else(|_| {\n                // SEC1 identity encoding is technically 1-byte 0x00, but the\n                // `GroupEncoding` API requires a fixed-width `Repr`\n                let is_identity = bytes.ct_eq(&Self::Repr::default());\n                CtOption::new(EncodedPoint::identity(), is_identity)\n            })\n            .and_then(|point| Self::from_encoded_point(&point))\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/NonIdentity/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(point: EdwardsPoint) -> Result<Self, Error> {\n        NonIdentity::new(point).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre bench_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_scalar_x",
      "0.14.0_pre test_scalar_y"
    ],
    "body": "fn bench_scalar_sub<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"sub\", |b| b.iter(|| x - y));\n}",
    "display_name": "bench_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/AsRef>/as_ref",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/as_affine"
    ],
    "body": "    fn as_ref(&self) -> &AffinePoint {\n        self.as_affine()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: FieldElement) -> FieldElement {\n        self + -other\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "    fn from(uint: U448) -> Self {\n        <Self as Reduce<U448>>::reduce(uint)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/is_negative",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes"
    ],
    "body": "    pub fn is_negative(&self) -> Choice {\n        let bytes = self.to_bytes();\n        (bytes[0] & 1).into()\n    }",
    "display_name": "is_negative",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_msat(out1: &mut [u64; 7]) {\n    out1[0] = 0xffffffff;\n    out1[1] = 0xffffffff00000000;\n    out1[2] = 0xfffffffffffffffe;\n    out1[3] = 0xffffffffffffffff;\n    out1[4] = 0xffffffffffffffff;\n    out1[5] = 0xffffffffffffffff;\n    out1[6] = (0x0 as u64);\n}",
    "display_name": "fiat_p384_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/MultipartSigner/try_multipart_sign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/DigestSigner/try_sign_digest"
    ],
    "body": "    fn try_multipart_sign(&self, msg: &[&[u8]]) -> Result<Signature> {\n        let mut digest = Sha256::new();\n        msg.iter().for_each(|slice| digest.update(slice));\n        self.try_sign_digest(digest)\n    }",
    "display_name": "try_multipart_sign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqn",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    const fn sqn(&self, n: usize) -> Self {\n        let mut x = self.square();\n        let mut i = 1;\n        while i < n {\n            x = x.square();\n            i += 1;\n        }\n        x\n    }",
    "display_name": "sqn",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes(bytes: &[u8; 56]) -> Scalar {\n        Self(U448::from_le_slice(bytes))\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_to_bytes(out1: &mut [u8; 32], arg1: &[u64; 4]) {\n    let x1: u64 = (arg1[3]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[1]);\n    let x4: u64 = (arg1[0]);\n    let x5: u8 = ((x4 & (0xff as u64)) as u8);\n    let x6: u64 = (x4 >> 8);\n    let x7: u8 = ((x6 & (0xff as u64)) as u8);\n    let x8: u64 = (x6 >> 8);\n    let x9: u8 = ((x8 & (0xff as u64)) as u8);\n    let x10: u64 = (x8 >> 8);\n    let x11: u8 = ((x10 & (0xff as u64)) as u8);\n    let x12: u64 = (x10 >> 8);\n    let x13: u8 = ((x12 & (0xff as u64)) as u8);\n    let x14: u64 = (x12 >> 8);\n    let x15: u8 = ((x14 & (0xff as u64)) as u8);\n    let x16: u64 = (x14 >> 8);\n    let x17: u8 = ((x16 & (0xff as u64)) as u8);\n    let x18: u8 = ((x16 >> 8) as u8);\n    let x19: u8 = ((x3 & (0xff as u64)) as u8);\n    let x20: u64 = (x3 >> 8);\n    let x21: u8 = ((x20 & (0xff as u64)) as u8);\n    let x22: u64 = (x20 >> 8);\n    let x23: u8 = ((x22 & (0xff as u64)) as u8);\n    let x24: u64 = (x22 >> 8);\n    let x25: u8 = ((x24 & (0xff as u64)) as u8);\n    let x26: u64 = (x24 >> 8);\n    let x27: u8 = ((x26 & (0xff as u64)) as u8);\n    let x28: u64 = (x26 >> 8);\n    let x29: u8 = ((x28 & (0xff as u64)) as u8);\n    let x30: u64 = (x28 >> 8);\n    let x31: u8 = ((x30 & (0xff as u64)) as u8);\n    let x32: u8 = ((x30 >> 8) as u8);\n    let x33: u8 = ((x2 & (0xff as u64)) as u8);\n    let x34: u64 = (x2 >> 8);\n    let x35: u8 = ((x34 & (0xff as u64)) as u8);\n    let x36: u64 = (x34 >> 8);\n    let x37: u8 = ((x36 & (0xff as u64)) as u8);\n    let x38: u64 = (x36 >> 8);\n    let x39: u8 = ((x38 & (0xff as u64)) as u8);\n    let x40: u64 = (x38 >> 8);\n    let x41: u8 = ((x40 & (0xff as u64)) as u8);\n    let x42: u64 = (x40 >> 8);\n    let x43: u8 = ((x42 & (0xff as u64)) as u8);\n    let x44: u64 = (x42 >> 8);\n    let x45: u8 = ((x44 & (0xff as u64)) as u8);\n    let x46: u8 = ((x44 >> 8) as u8);\n    let x47: u8 = ((x1 & (0xff as u64)) as u8);\n    let x48: u64 = (x1 >> 8);\n    let x49: u8 = ((x48 & (0xff as u64)) as u8);\n    let x50: u64 = (x48 >> 8);\n    let x51: u8 = ((x50 & (0xff as u64)) as u8);\n    let x52: u64 = (x50 >> 8);\n    let x53: u8 = ((x52 & (0xff as u64)) as u8);\n    let x54: u64 = (x52 >> 8);\n    let x55: u8 = ((x54 & (0xff as u64)) as u8);\n    let x56: u64 = (x54 >> 8);\n    let x57: u8 = ((x56 & (0xff as u64)) as u8);\n    let x58: u64 = (x56 >> 8);\n    let x59: u8 = ((x58 & (0xff as u64)) as u8);\n    let x60: u8 = ((x58 >> 8) as u8);\n    out1[0] = x5;\n    out1[1] = x7;\n    out1[2] = x9;\n    out1[3] = x11;\n    out1[4] = x13;\n    out1[5] = x15;\n    out1[6] = x17;\n    out1[7] = x18;\n    out1[8] = x19;\n    out1[9] = x21;\n    out1[10] = x23;\n    out1[11] = x25;\n    out1[12] = x27;\n    out1[13] = x29;\n    out1[14] = x31;\n    out1[15] = x32;\n    out1[16] = x33;\n    out1[17] = x35;\n    out1[18] = x37;\n    out1[19] = x39;\n    out1[20] = x41;\n    out1[21] = x43;\n    out1[22] = x45;\n    out1[23] = x46;\n    out1[24] = x47;\n    out1[25] = x49;\n    out1[26] = x51;\n    out1[27] = x53;\n    out1[28] = x55;\n    out1[29] = x57;\n    out1[30] = x59;\n    out1[31] = x60;\n}",
    "display_name": "fiat_bign256_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.7.0_pre t1/impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [
      "0.7.0_pre decode_field_bytes"
    ],
    "body": "    fn decode_field_bytes(field_bytes: &crate::r1::FieldBytes) -> Self {\n        crate::decode_field_bytes(field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp256/src/t1.rs",
    "relative_path": "bp256/src/t1.rs",
    "file_name": "t1.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_sub(\n    out1: &mut fiat_bign256_scalar_montgomery_domain_field_element,\n    arg1: &fiat_bign256_scalar_montgomery_domain_field_element,\n    arg2: &fiat_bign256_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, (x9 & 0x7e5abf99263d6607));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0xd95c8ed60dfb4dfc));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, x9);\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_bign256_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/one_is_multiplicative_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn one_is_multiplicative_identity() {\n        let one = FieldElement::ONE;\n        assert_eq!((one * &one).normalize(), one);\n    }",
    "display_name": "one_is_multiplicative_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &DecafPointBytes {\n        &self.0\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_extended(&self) -> ExtendedPoint {\n        ExtendedPoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n            T: self.T1 * self.T2,\n        }\n    }",
    "display_name": "to_extended",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_to_montgomery"
    ],
    "body": "    pub(crate) const fn from_uint_unchecked(w: U576) -> Self {\n        let mut out = fiat_p521_scalar_montgomery_domain_field_element([0; 9]);\n        fiat_p521_scalar_to_montgomery(\n            &mut out,\n            &fiat_p521_scalar_non_montgomery_domain_field_element(*w.as_words()),\n        );\n        Self(out)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "    fn reduce_bytes(bytes: &FieldBytes) -> Self {\n        let w = <U256 as FieldBytesEncoding<BignP256>>::decode_field_bytes(bytes);\n        Self::reduce(w)\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_cmovznz_u64(\n    out1: &mut u64,\n    arg1: fiat_p192_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: fiat_p192_scalar_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_p192_scalar_i2) - (x1 as fiat_p192_scalar_i2))\n        as fiat_p192_scalar_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_p192_scalar_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> [u8; 56] {\n        let bytes = self.0.to_le_bytes();\n        let output: [u8; 56] = core::array::from_fn(|i| bytes[i]);\n        output\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/lincomb",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/Radix16Decomposition/new",
      "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/From/from",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/IsHigh/is_high",
      "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/select",
      "0.14.0_pre.8 arithmetic/mul/decompose_scalar",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/endomorphism",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/ConditionallySelectable/conditional_select",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/double",
      "0.14.0_pre.8 arithmetic/mul/precompute_gen_lookup_table",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select"
    ],
    "body": "fn lincomb(\n    xks: &[(ProjectivePoint, Scalar)],\n    tables: &mut [(LookupTable, LookupTable)],\n    digits: &mut [(Radix16Decomposition<33>, Radix16Decomposition<33>)],\n) -> ProjectivePoint {\n    xks.iter().enumerate().for_each(|(i, (x, k))| {\n        let (r1, r2) = decompose_scalar(k);\n        let x_beta = x.endomorphism();\n        let (r1_sign, r2_sign) = (r1.is_high(), r2.is_high());\n\n        let (r1_c, r2_c) = (\n            Scalar::conditional_select(&r1, &-r1, r1_sign),\n            Scalar::conditional_select(&r2, &-r2, r2_sign),\n        );\n\n        tables[i] = (\n            LookupTable::from(&ProjectivePoint::conditional_select(x, &-*x, r1_sign)),\n            LookupTable::from(&ProjectivePoint::conditional_select(\n                &x_beta, &-x_beta, r2_sign,\n            )),\n        );\n\n        digits[i] = (\n            Radix16Decomposition::<33>::new(&r1_c),\n            Radix16Decomposition::<33>::new(&r2_c),\n        )\n    });\n\n    let mut acc = ProjectivePoint::IDENTITY;\n    for component in 0..xks.len() {\n        let (digit1, digit2) = digits[component];\n        let (table1, table2) = tables[component];\n\n        acc += &table1.select(digit1.0[32]);\n        acc += &table2.select(digit2.0[32]);\n    }\n\n    for i in (0..32).rev() {\n        for _j in 0..4 {\n            acc = acc.double();\n        }\n\n        for component in 0..xks.len() {\n            let (digit1, digit2) = digits[component];\n            let (table1, table2) = tables[component];\n\n            acc += &table1.select(digit1.0[i]);\n            acc += &table2.select(digit2.0[i]);\n        }\n    }\n    acc\n}",
    "display_name": "lincomb",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_msat(out1: &mut [u64; 5]) {\n    out1[0] = 0x13dd29455c5c2a3d;\n    out1[1] = 0xffff16a2e0b8f03e;\n    out1[2] = 0xffffffffffffffff;\n    out1[3] = 0xffffffff;\n    out1[4] = (0x0 as u64);\n}",
    "display_name": "fiat_p224_scalar_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/impl/Signature/from_bytes"
    ],
    "body": "    fn try_from(signature: SignatureBytes) -> Result<Signature> {\n        Signature::from_bytes(&signature)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/from_nonzero_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/new_with_mode"
    ],
    "body": "    pub fn from_nonzero_scalar(secret_scalar: NonZeroScalar) -> Result<Self> {\n        Ok(Self::new_with_mode(secret_scalar, Mode::C1C3C2))\n    }",
    "display_name": "from_nonzero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes_unchecked"
    ],
    "body": "    fn select(&self, x: i8) -> ProjectivePoint {\n        debug_assert!(x >= -8);\n        debug_assert!(x <= 8);\n\n        // Compute xabs = |x|\n        let xmask = x >> 7;\n        let xabs = (x + xmask) ^ xmask;\n\n        // Get an array element in constant time\n        let mut t = ProjectivePoint::IDENTITY;\n        for j in 1..9 {\n            let c = (xabs as u8).ct_eq(&(j as u8));\n            t.conditional_assign(&self.0[j - 1], c);\n        }\n        // Now t == |x| * p.\n\n        let neg_mask = Choice::from((xmask & 1) as u8);\n        t.conditional_assign(&-t, neg_mask);\n        // Now t == x * p.\n\n        t\n    }",
    "display_name": "select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_mul(\n    out1: &mut fiat_bign256_montgomery_domain_field_element,\n    arg1: &fiat_bign256_montgomery_domain_field_element,\n    arg2: &fiat_bign256_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x5, &mut x6, x4, (arg2[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x7, &mut x8, x4, (arg2[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x9, &mut x10, x4, (arg2[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x11, &mut x12, x4, (arg2[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x20, &mut x21, x11, 0xa53fa94fea53fa95);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x22, &mut x23, x20, 0xffffffffffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x26, &mut x27, x20, 0xffffffffffffffff);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x28, &mut x29, x20, 0xffffffffffffff43);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x30, &mut x31, 0x0, x29, x26);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x32, &mut x33, x31, x27, x24);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x34, &mut x35, x33, x25, x22);\n    let x36: u64 = ((x35 as u64) + x23);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x37, &mut x38, 0x0, x11, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x39, &mut x40, x38, x13, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x41, &mut x42, x40, x15, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x43, &mut x44, x42, x17, x34);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x45, &mut x46, x44, x19, x36);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x47, &mut x48, x1, (arg2[3]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x49, &mut x50, x1, (arg2[2]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x51, &mut x52, x1, (arg2[1]));\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x53, &mut x54, x1, (arg2[0]));\n    let mut x55: u64 = 0;\n    let mut x56: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x55, &mut x56, 0x0, x54, x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x57, &mut x58, x56, x52, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x59, &mut x60, x58, x50, x47);\n    let x61: u64 = ((x60 as u64) + x48);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x62, &mut x63, 0x0, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x68, &mut x69, x67, x45, x59);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x70, &mut x71, x69, (x46 as u64), x61);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x72, &mut x73, x62, 0xa53fa94fea53fa95);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x74, &mut x75, x72, 0xffffffffffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x78, &mut x79, x72, 0xffffffffffffffff);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x80, &mut x81, x72, 0xffffffffffffff43);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x82, &mut x83, 0x0, x81, x78);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x84, &mut x85, x83, x79, x76);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x86, &mut x87, x85, x77, x74);\n    let x88: u64 = ((x87 as u64) + x75);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x89, &mut x90, 0x0, x62, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x91, &mut x92, x90, x64, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x93, &mut x94, x92, x66, x84);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x95, &mut x96, x94, x68, x86);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x97, &mut x98, x96, x70, x88);\n    let x99: u64 = ((x98 as u64) + (x71 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x100, &mut x101, x2, (arg2[3]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x102, &mut x103, x2, (arg2[2]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x104, &mut x105, x2, (arg2[1]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x106, &mut x107, x2, (arg2[0]));\n    let mut x108: u64 = 0;\n    let mut x109: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x108, &mut x109, 0x0, x107, x104);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x110, &mut x111, x109, x105, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x112, &mut x113, x111, x103, x100);\n    let x114: u64 = ((x113 as u64) + x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x115, &mut x116, 0x0, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x121, &mut x122, x120, x97, x112);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x123, &mut x124, x122, x99, x114);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x125, &mut x126, x115, 0xa53fa94fea53fa95);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x127, &mut x128, x125, 0xffffffffffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x129, &mut x130, x125, 0xffffffffffffffff);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x131, &mut x132, x125, 0xffffffffffffffff);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x133, &mut x134, x125, 0xffffffffffffff43);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let x141: u64 = ((x140 as u64) + x128);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x142, &mut x143, 0x0, x115, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x144, &mut x145, x143, x117, x135);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x146, &mut x147, x145, x119, x137);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x148, &mut x149, x147, x121, x139);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x150, &mut x151, x149, x123, x141);\n    let x152: u64 = ((x151 as u64) + (x124 as u64));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x153, &mut x154, x3, (arg2[3]));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x155, &mut x156, x3, (arg2[2]));\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x157, &mut x158, x3, (arg2[1]));\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x159, &mut x160, x3, (arg2[0]));\n    let mut x161: u64 = 0;\n    let mut x162: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x161, &mut x162, 0x0, x160, x157);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x163, &mut x164, x162, x158, x155);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x165, &mut x166, x164, x156, x153);\n    let x167: u64 = ((x166 as u64) + x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x168, &mut x169, 0x0, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x172, &mut x173, x171, x148, x163);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x174, &mut x175, x173, x150, x165);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x176, &mut x177, x175, x152, x167);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x178, &mut x179, x168, 0xa53fa94fea53fa95);\n    let mut x180: u64 = 0;\n    let mut x181: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x180, &mut x181, x178, 0xffffffffffffffff);\n    let mut x182: u64 = 0;\n    let mut x183: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x182, &mut x183, x178, 0xffffffffffffffff);\n    let mut x184: u64 = 0;\n    let mut x185: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x184, &mut x185, x178, 0xffffffffffffffff);\n    let mut x186: u64 = 0;\n    let mut x187: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x186, &mut x187, x178, 0xffffffffffffff43);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x188, &mut x189, 0x0, x187, x184);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x190, &mut x191, x189, x185, x182);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x192, &mut x193, x191, x183, x180);\n    let x194: u64 = ((x193 as u64) + x181);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x195, &mut x196, 0x0, x168, x186);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x197, &mut x198, x196, x170, x188);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x199, &mut x200, x198, x172, x190);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x201, &mut x202, x200, x174, x192);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x203, &mut x204, x202, x176, x194);\n    let x205: u64 = ((x204 as u64) + (x177 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x206, &mut x207, 0x0, x197, 0xffffffffffffff43);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x208, &mut x209, x207, x199, 0xffffffffffffffff);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x210, &mut x211, x209, x201, 0xffffffffffffffff);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x212, &mut x213, x211, x203, 0xffffffffffffffff);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x214, &mut x215, x213, x205, (0x0 as u64));\n    let mut x216: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x216, x215, x206, x197);\n    let mut x217: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x217, x215, x208, x199);\n    let mut x218: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x218, x215, x210, x201);\n    let mut x219: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x219, x215, x212, x203);\n    out1[0] = x216;\n    out1[1] = x217;\n    out1[2] = x218;\n    out1[3] = x219;\n}",
    "display_name": "fiat_bign256_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 benches",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_scalar",
      "0.14.0_pre.8 bench_field_element",
      "0.14.0_pre.8 bench_ecdsa",
      "0.14.0_pre.8 bench_high_level"
    ],
    "body": "criterion_group!(benches, bench_ecdsa);\ncriterion_main!(benches);",
    "display_name": "benches",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/ecdsa.rs",
    "relative_path": "k256/benches/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/to_bytes"
    ],
    "body": "    pub fn to_bytes(self) -> FieldBytes {\n        debug_assert!(self.normalized);\n        self.value.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_square<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"square\", |b| b.iter(|| x.square()));\n}",
    "display_name": "bench_field_element_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/field.rs",
    "relative_path": "p384/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre decode_pkcs8_public_key_from_der",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_public_key_from_der() {\n    let public_key = sm2::PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n\n    assert_eq!(\n        public_key.to_encoded_point(false).as_bytes(),\n        &SEC1_PUBLIC_KEY[..]\n    );\n}",
    "display_name": "decode_pkcs8_public_key_from_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/fuzzy_negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/From/from",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/field/tests/field_element"
    ],
    "body": "        fn fuzzy_negate(\n            a in field_element()\n        ) {\n            let m = FieldElement::modulus_as_biguint();\n            let a_bi = a.to_biguint().unwrap();\n            let res_bi = (&m - &a_bi) % &m;\n            let res_ref = FieldElement::from(&res_bi);\n            let res_test = a.negate(1).normalize();\n            assert_eq!(res_test, res_ref);\n        }",
    "display_name": "fuzzy_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/SignatureEncoding/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        self.into()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 decode_pkcs8_public_key_from_der",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_public_key_from_der() {\n    let public_key = p256::PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    let expected_sec1_point = hex!(\n        \"041CACFFB55F2F2CEFD89D89EB374B2681152452802DEEA09916068137D839CF7FC481A44492304D7EF66AC117BEFE83A8D08F155F2B52F9F618DD447029048E0F\"\n    );\n    assert_eq!(\n        public_key.to_encoded_point(false).as_bytes(),\n        &expected_sec1_point[..]\n    );\n}",
    "display_name": "decode_pkcs8_public_key_from_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/pkcs8.rs",
    "relative_path": "p256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/wycheproof/wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "        fn wycheproof() {\n            use blobby::Blob5Iterator;\n\n            // Build a field element but allow for too-short input (left pad with zeros)\n            // or too-long input (check excess leftmost bytes are zeros).\n            fn element_from_padded_slice<C: elliptic_curve::Curve>(\n                data: &[u8],\n            ) -> elliptic_curve::FieldBytes<C> {\n                let point_len = C::FieldBytesSize::USIZE;\n                if data.len() >= point_len {\n                    let offset = data.len() - point_len;\n                    for v in data.iter().take(offset) {\n                        assert_eq!(*v, 0, \"EcdsaVerifier: point too large\");\n                    }\n                    elliptic_curve::FieldBytes::<C>::try_from(&data[offset..])\n                        .expect(\"length mismatch\")\n                } else {\n                    let mut point = elliptic_curve::FieldBytes::<C>::default();\n                    let offset = point_len - data.len();\n                    point[offset..].copy_from_slice(data);\n                    point\n                }\n            }\n\n            fn run_test(\n                wx: &[u8],\n                wy: &[u8],\n                msg: &[u8],\n                sig: &[u8],\n                pass: bool,\n                p1363_sig: bool,\n            ) -> Option<&'static str> {\n                let x = element_from_padded_slice::<Secp256k1>(wx);\n                let y = element_from_padded_slice::<Secp256k1>(wy);\n                let q_encoded =\n                    EncodedPoint::from_affine_coordinates(&x, &y, /* compress= */ false);\n                let verifying_key =\n                    ecdsa_core::VerifyingKey::from_encoded_point(&q_encoded).unwrap();\n\n                let sig = if p1363_sig {\n                    match Signature::<Secp256k1>::from_slice(sig) {\n                        Ok(s) => s.normalize_s(),\n                        Err(_) if !pass => return None,\n                        Err(_) => return Some(\"failed to parse signature P1363\"),\n                    }\n                } else {\n                    match Signature::<Secp256k1>::from_der(sig) {\n                        Ok(s) => s.normalize_s(),\n                        Err(_) if !pass => return None,\n                        Err(_) => return Some(\"failed to parse signature ASN.1\"),\n                    }\n                };\n\n                match verifying_key.verify(msg, &sig) {\n                    Ok(_) if pass => None,\n                    Ok(_) => Some(\"signature verify unexpectedly succeeded\"),\n                    Err(_) if !pass => None,\n                    Err(_) => Some(\"signature verify failed\"),\n                }\n            }\n\n            fn run(data: &[u8], p1363_sig: bool) {\n                for (i, row) in Blob5Iterator::new(data).unwrap().enumerate() {\n                    let [wx, wy, msg, sig, status] = row.unwrap();\n                    let pass = match status[0] {\n                        0 => false,\n                        1 => true,\n                        _ => panic!(\"invalid value for pass flag\"),\n                    };\n                    if let Some(desc) = run_test(wx, wy, msg, sig, pass, p1363_sig) {\n                        panic!(\n                            \"\\n\\\n                                     Failed test №{}: {}\\n\\\n                                     wx:\\t{:?}\\n\\\n                                     wy:\\t{:?}\\n\\\n                                     msg:\\t{:?}\\n\\\n                                     sig:\\t{:?}\\n\\\n                                     pass:\\t{}\\n\",\n                            i,\n                            desc,\n                            hex::encode(wx),\n                            hex::encode(wy),\n                            hex::encode(msg),\n                            hex::encode(sig),\n                            pass,\n                        );\n                    }\n                }\n            }\n            let data = include_bytes!(concat!(\"test_vectors/data/\", \"wycheproof\", \".blb\"));\n            run(data, false);\n            let data2 = include_bytes!(concat!(\"test_vectors/data/\", \"wycheproof-p1316\", \".blb\"));\n            run(data2, true);\n        }",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/ecdsa.rs",
    "relative_path": "k256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add(self, other: Scalar) -> Scalar {\n        Scalar::add(&self, &other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Product/product",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/dev/biguint_to_bytes",
      "0.14.0_pre.8 arithmetic/dev/bytes_to_biguint"
    ],
    "body": "    fn product<I: Iterator<Item = &'a FieldElement>>(iter: I) -> Self {\n        iter.copied().product()\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: Box<[u8]>) -> Result<Self, Self::Error> {\n        Self::try_from(bytes.as_ref())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(affine: NonIdentity<AffinePoint>) -> Self {\n        affine.to_point()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.0.ct_eq(&other.0)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/primefield::bigint::Uint/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: Scalar) -> U256 {\n        scalar.0\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/invert_unchecked",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_hex",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/pow_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "    pub const fn pow_vartime(&self, exp: &[u64]) -> Self {\n        let mut res = Self::ONE;\n        let mut i = exp.len();\n\n        while i > 0 {\n            i -= 1;\n\n            let mut j = 64;\n            while j > 0 {\n                j -= 1;\n                res = res.square();\n\n                if ((exp[i] >> j) & 1) == 1 {\n                    res = res.multiply(self);\n                }\n            }\n        }\n\n        res\n    }",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        self.invert()\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_sub",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_sub(\n    out1: &mut fiat_p521_loose_field_element,\n    arg1: &fiat_p521_tight_field_element,\n    arg2: &fiat_p521_tight_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = ((0x7fffffffffffffe + (arg1[0])) - (arg2[0]));\n    let x2: u64 = ((0x7fffffffffffffe + (arg1[1])) - (arg2[1]));\n    let x3: u64 = ((0x7fffffffffffffe + (arg1[2])) - (arg2[2]));\n    let x4: u64 = ((0x7fffffffffffffe + (arg1[3])) - (arg2[3]));\n    let x5: u64 = ((0x7fffffffffffffe + (arg1[4])) - (arg2[4]));\n    let x6: u64 = ((0x7fffffffffffffe + (arg1[5])) - (arg2[5]));\n    let x7: u64 = ((0x7fffffffffffffe + (arg1[6])) - (arg2[6]));\n    let x8: u64 = ((0x7fffffffffffffe + (arg1[7])) - (arg2[7]));\n    let x9: u64 = ((0x3fffffffffffffe + (arg1[8])) - (arg2[8]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n    out1[4] = x5;\n    out1[5] = x6;\n    out1[6] = x7;\n    out1[7] = x8;\n    out1[8] = x9;\n}",
    "display_name": "fiat_p521_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.7.0_pre t1/impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [
      "0.7.0_pre decode_field_bytes"
    ],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        crate::decode_field_bytes(field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp384/src/t1.rs",
    "relative_path": "bp384/src/t1.rs",
    "file_name": "t1.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_canonical_bytes"
    ],
    "body": "    fn from_repr(repr: Self::Repr) -> CtOption<Self> {\n        Self::from_canonical_bytes(&repr)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.7.0_pre r1/impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [
      "0.7.0_pre encode_field_bytes"
    ],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        crate::encode_field_bytes(self)\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp384/src/r1.rs",
    "relative_path": "bp384/src/r1.rs",
    "file_name": "r1.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "projective/impl/PublicKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/From>/from"
    ],
    "body": "    fn try_from(point: &ProjectivePoint<C>) -> Result<PublicKey<C>> {\n        AffinePoint::<C>::from(point).try_into()\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_sm2_scalar_u1,\n    arg1: fiat_sm2_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_sm2_scalar_u1 = ((x1 >> 64) as fiat_sm2_scalar_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_sm2_scalar_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> SecretKey {\n        self.secret.seed\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_zero",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/From>/from"
    ],
    "body": "    fn from(secret_key: SecretKey) -> SigningKey {\n        SigningKey::from(&secret_key)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Add/add"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        // If both points are not equal to infinity then they are in the form:\n        //\n        // lhs: (x₁z₁, y₁z₁, z₁), rhs: (x₂z₂, y₂z₂, z₂) where z₁ ≠ 0 and z₂ ≠ 0.\n        // we want to know if x₁ == x₂ and y₁ == y₂\n        // So we multiply the x and y by the opposing z to get:\n        // lhs: (x₁z₁z₂, y₁z₁z₂) rhs: (x₂z₁z₂, y₂z₁z₂)\n        // and check lhs == rhs which implies x₁ == x₂ and y₁ == y₂.\n        //\n        // If one point is infinity it is always in the form (0, y, 0). Note that the above\n        // algorithm still works here. If They are both infinity then they'll both evaluate to (0,0).\n        // If for example the first point is infinity then the above will evaluate to (z₂ * 0, z₂ *\n        // y₂) = (0, z₂y₂) for the first point and (0 * x₂z₂, 0 * y₂z₂) = (0, 0) for the second.\n        //\n        // Since z₂y₂ will never be 0 they will not be equal in this case either.\n        let lhs_x = self.x * &other.z;\n        let rhs_x = other.x * &self.z;\n        let x_eq = rhs_x.negate(1).add(&lhs_x).normalizes_to_zero();\n\n        let lhs_y = self.y * &other.z;\n        let rhs_y = other.y * &self.z;\n        let y_eq = rhs_y.negate(1).add(&lhs_y).normalizes_to_zero();\n        x_eq & y_eq\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/PreHasherXmd/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/PreHasherXmd/new"
    ],
    "body": "    fn from(hasher: HashT) -> Self {\n        Self::new(hasher)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(FieldElementImpl::conditional_select(&(a.0), &(b.0), choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&DecafPoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/sub_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended"
    ],
    "body": "    fn sub(self, other: &DecafPoint) -> DecafPoint {\n        DecafPoint(self.0.to_extensible().sub_extended(&other.0).to_extended())\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 57];\n        for (i, byte) in bytes.iter_mut().enumerate() {\n            *byte = u8::conditional_select(&a.0[i], &b.0[i], choice);\n        }\n        Self(bytes)\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, other: Scalar) {\n        *self = *self * other;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p384_selectznz(\n    out1: &mut [u64; 6],\n    arg1: fiat_p384_u1,\n    arg2: &[u64; 6],\n    arg3: &[u64; 6],\n) {\n    let mut x1: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    let mut x5: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x5, arg1, (arg2[4]), (arg3[4]));\n    let mut x6: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x6, arg1, (arg2[5]), (arg3[5]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n    out1[4] = x5;\n    out1[5] = x6;\n}",
    "display_name": "fiat_p384_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 signing_key",
    "statement_type": "function",
    "deps": [],
    "body": "    fn signing_key()(bytes in any::<[u8; 32]>()) -> SigningKey {\n        <NonZeroScalar as Reduce<U256>>::reduce_bytes(&bytes.into()).into()\n    }",
    "display_name": "signing_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/ecdsa.rs",
    "relative_path": "p256/tests/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn reduce(w: U256) -> Self {\n        let (r, underflow) = w.borrowing_sub(&Sm2::ORDER, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self::from_uint_unchecked(U256::conditional_select(&w, &r, !underflow))\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/GroupEncoding/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/GroupEncoding/from_bytes"
    ],
    "body": "    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // No unchecked conversion possible for compressed points\n        Self::from_bytes(bytes)\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/negate",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn negate(&self) -> ExtendedPoint {\n        ExtendedPoint {\n            X: -self.X,\n            Y: self.Y,\n            Z: self.Z,\n            T: -self.T,\n        }\n    }",
    "display_name": "negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032"
    ],
    "body": "    fn to_repr(&self) -> Self::Repr {\n        self.to_bytes_rfc_8032()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/invert"
    ],
    "body": "    pub fn to_affine(&self) -> AffinePoint {\n        let INV_Z = self.Z.invert();\n\n        let x = self.X * INV_Z;\n        let y = self.Y * INV_Z;\n\n        AffinePoint { x, y }\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/scalar_mul/double_and_add/double_and_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/bits",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/add",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/double"
    ],
    "body": "pub(crate) fn double_and_add(point: &ExtendedPoint, s: &Scalar) -> ExtendedPoint {\n    let mut result = ExtendedPoint::IDENTITY;\n\n    // NB, we reverse here, so we are going from MSB to LSB\n    // XXX: Would be great if subtle had a From<u32> for Choice. But maybe that is not it's purpose?\n    for bit in s.bits().into_iter().rev() {\n        result = result.double();\n\n        let mut p = ExtendedPoint::IDENTITY;\n        p.conditional_assign(point, Choice::from(bit as u8));\n        result = result.add(&p);\n    }\n\n    result\n}",
    "display_name": "double_and_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/scalar_mul/double_and_add.rs",
    "relative_path": "ed448-goldilocks/src/curve/scalar_mul/double_and_add.rs",
    "file_name": "double_and_add.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/sub_inner_five",
    "statement_type": "function",
    "deps": [],
    "body": "const fn sub_inner_five(l: [Limb; 5], r: [Limb; 5]) -> [Limb; 5] {\n    let (w0, borrow) = l[0].borrowing_sub(r[0], Limb::ZERO);\n    let (w1, borrow) = l[1].borrowing_sub(r[1], borrow);\n    let (w2, borrow) = l[2].borrowing_sub(r[2], borrow);\n    let (w3, borrow) = l[3].borrowing_sub(r[3], borrow);\n    let (w4, _borrow) = l[4].borrowing_sub(r[4], borrow);\n\n    // If underflow occurred on the final limb - don't care (= add b^{k+1}).\n    [w0, w1, w2, w3, w4]\n}",
    "display_name": "sub_inner_five",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar/scalar64.rs",
    "relative_path": "p256/src/arithmetic/scalar/scalar64.rs",
    "file_name": "scalar64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/relax",
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/Mul/mul"
    ],
    "body": "    fn mul(self, rhs: FieldElement) -> FieldElement {\n        self.relax().mul(&rhs.relax())\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(k: u64) -> Self {\n        Self(k.into())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/context/impl/Context/value",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn value(&self) -> &'v [u8] {\n        self.value\n    }",
    "display_name": "value",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/context.rs",
    "relative_path": "ed448-goldilocks/src/sign/context.rs",
    "file_name": "context.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/to_vec",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/to_bytes"
    ],
    "body": "    pub fn to_vec(&self) -> Vec<u8> {\n        self.to_bytes().to_vec()\n    }",
    "display_name": "to_vec",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_u64",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_to_montgomery",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    pub const fn from_u64(w: u64) -> Self {\n        Self::from_uint_unchecked(U576::from_u64(w))\n    }",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.0.ct_eq(&(other.0))\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        let XZ = self.X * other.Z;\n        let ZX = self.Z * other.X;\n\n        let YZ = self.Y * other.Z;\n        let ZY = self.Z * other.Y;\n\n        (XZ.ct_eq(&ZX)) & (YZ.ct_eq(&ZY))\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/tests/compressed_to_uncompressed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn compressed_to_uncompressed() {\n        let encoded = EncodedPoint::from_bytes(COMPRESSED_BASEPOINT).unwrap();\n\n        let res = AffinePoint::from_encoded_point(&encoded)\n            .unwrap()\n            .to_encoded_point(false);\n\n        assert_eq!(res.as_bytes(), UNCOMPRESSED_BASEPOINT);\n    }",
    "display_name": "compressed_to_uncompressed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/fiat_p521_tight_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add(self, other: &ProjectivePoint) -> ProjectivePoint {\n        ProjectivePoint::add(&self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Group/mul_by_generator",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/mul_by_generator"
    ],
    "body": "    fn mul_by_generator(k: &Scalar) -> Self {\n        Self::mul_by_generator(k)\n    }",
    "display_name": "mul_by_generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_selectznz(\n    out1: &mut [u64; 4],\n    arg1: fiat_bign256_scalar_u1,\n    arg2: &[u64; 4],\n    arg3: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n}",
    "display_name": "fiat_bign256_scalar_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 impl/primefield::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        U256::from_be_byte_array(*field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/lib.rs",
    "relative_path": "p256/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/wycheproof/run_test",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 ecdsa/tests/wycheproof/element_from_padded_slice"
    ],
    "body": "            fn run_test(\n                wx: &[u8],\n                wy: &[u8],\n                msg: &[u8],\n                sig: &[u8],\n                pass: bool,\n                p1363_sig: bool,\n            ) -> Option<&'static str> {\n                let x = element_from_padded_slice::<Secp256k1>(wx);\n                let y = element_from_padded_slice::<Secp256k1>(wy);\n                let q_encoded =\n                    EncodedPoint::from_affine_coordinates(&x, &y, /* compress= */ false);\n                let verifying_key =\n                    ecdsa_core::VerifyingKey::from_encoded_point(&q_encoded).unwrap();\n\n                let sig = if p1363_sig {\n                    match Signature::<Secp256k1>::from_slice(sig) {\n                        Ok(s) => s.normalize_s(),\n                        Err(_) if !pass => return None,\n                        Err(_) => return Some(\"failed to parse signature P1363\"),\n                    }\n                } else {\n                    match Signature::<Secp256k1>::from_der(sig) {\n                        Ok(s) => s.normalize_s(),\n                        Err(_) if !pass => return None,\n                        Err(_) => return Some(\"failed to parse signature ASN.1\"),\n                    }\n                };\n\n                match verifying_key.verify(msg, &sig) {\n                    Ok(_) if pass => None,\n                    Ok(_) => Some(\"signature verify unexpectedly succeeded\"),\n                    Err(_) if !pass => None,\n                    Err(_) => Some(\"signature verify failed\"),\n                }\n            }",
    "display_name": "run_test",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/ecdsa.rs",
    "relative_path": "k256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint"
    ],
    "body": "        fn fuzzy_invert(\n            a in scalar()\n        ) {\n            let a = if bool::from(a.is_zero()) { Scalar::ONE } else { a };\n            let a_bi = a.to_biguint().unwrap();\n            let inv = a.invert().unwrap();\n            let inv_bi = inv.to_biguint().unwrap();\n            let m = Scalar::modulus_as_biguint();\n            assert_eq!((&inv_bi * &a_bi) % &m, 1.to_biguint().unwrap());\n        }",
    "display_name": "fuzzy_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = &'a FieldElement>>(iter: I) -> Self {\n        iter.copied().sum()\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from"
    ],
    "body": "        fn fuzzy_add(a in scalar(), b in scalar()) {\n            let a_bi = a.to_biguint().unwrap();\n            let b_bi = b.to_biguint().unwrap();\n\n            let res_bi = (&a_bi + &b_bi) % &Scalar::modulus_as_biguint();\n            let res_ref = Scalar::from(&res_bi);\n            let res_test = a.add(&b);\n\n            assert_eq!(res_ref, res_test);\n        }",
    "display_name": "fuzzy_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/bot_half",
    "statement_type": "function",
    "deps": [],
    "body": "        fn bot_half(x: u8) -> u8 {\n            x & 15\n        }",
    "display_name": "bot_half",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut bytes = FieldBytes::default();\n\n        loop {\n            rng.try_fill_bytes(&mut bytes)?;\n            if let Some(fe) = Self::from_bytes(&bytes).into() {\n                return Ok(fe);\n            }\n        }\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub_assign(&mut self, rhs: ProjectivePoint) {\n        *self = ProjectivePoint::sub(self, &rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/add",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn add(&self, other: &EdwardsPoint) -> Self {\n        let aXX = self.X * other.X; // aX1X2\n        let dTT = FieldElement::EDWARDS_D * self.T * other.T; // dT1T2\n        let ZZ = self.Z * other.Z; // Z1Z2\n        let YY = self.Y * other.Y;\n\n        let X = {\n            let x_1 = (self.X * other.Y) + (self.Y * other.X);\n            let x_2 = ZZ - dTT;\n            x_1 * x_2\n        };\n        let Y = {\n            let y_1 = YY - aXX;\n            let y_2 = ZZ + dTT;\n            y_1 * y_2\n        };\n\n        let T = {\n            let t_1 = YY - aXX;\n            let t_2 = (self.X * other.Y) + (self.Y * other.X);\n            t_1 * t_2\n        };\n\n        let Z = { (ZZ - dTT) * (ZZ + dTT) };\n\n        EdwardsPoint { X, Y, Z, T }\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_nonzero(out1: &mut u64, arg1: &[u64; 6]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | ((arg1[2]) | ((arg1[3]) | ((arg1[4]) | (arg1[5]))))));\n    *out1 = x1;\n}",
    "display_name": "fiat_p384_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &EncryptingKey {\n        &self.encryting_key\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffineNielsPoint/to_extended",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn to_extended(self) -> ExtendedPoint {\n        ExtendedPoint {\n            X: self.y_plus_x - self.y_minus_x,\n            Y: self.y_minus_x + self.y_plus_x,\n            Z: FieldElement::ONE,\n            T: self.y_plus_x * self.y_minus_x,\n        }\n    }",
    "display_name": "to_extended",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_msat(out1: &mut [u64; 4]) {\n    out1[0] = 0xffffffffffffffff;\n    out1[1] = 0xfffffffffffffffe;\n    out1[2] = 0xffffffffffffffff;\n    out1[3] = (0x0 as u64);\n}",
    "display_name": "fiat_p192_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/sumadd",
    "statement_type": "function",
    "deps": [],
    "body": "fn sumadd(a: u64, c0: u64, c1: u64, c2: u64) -> (u64, u64, u64) {\n    let (new_c0, carry0) = c0.overflowing_add(a);\n    let (new_c1, carry1) = c1.overflowing_add(carry0 as u64);\n    let new_c2 = c2 + (carry1 as u64);\n    (new_c0, new_c1, new_c2)\n}",
    "display_name": "sumadd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {\n        let mut bytes = Array::try_from(bytes).map_err(|_| Error)?;\n\n        // It is because public_key in little endian\n        bytes[..32].reverse();\n        bytes[32..].reverse();\n\n        let point = EncodedPoint::from_untagged_bytes(&bytes);\n        let affine = AffinePoint::<BignP256>::from_encoded_point(&point);\n        if affine.is_none().into() {\n            Err(Error)\n        } else {\n            Ok(Self {\n                point: affine.unwrap(),\n            })\n        }\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_add(\n    out1: &mut fiat_sm2_scalar_montgomery_domain_field_element,\n    arg1: &fiat_sm2_scalar_montgomery_domain_field_element,\n    arg2: &fiat_sm2_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x9, &mut x10, 0x0, x1, 0x53bbf40939d54123);\n    let mut x11: u64 = 0;\n    let mut x12: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x11, &mut x12, x10, x3, 0x7203df6b21c6052b);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x13, &mut x14, x12, x5, 0xffffffffffffffff);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x15, &mut x16, x14, x7, 0xfffffffeffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x17, &mut x18, x16, (x8 as u64), (0x0 as u64));\n    let mut x19: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x19, x18, x9, x1);\n    let mut x20: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x20, x18, x11, x3);\n    let mut x21: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x21, x18, x13, x5);\n    let mut x22: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x22, x18, x15, x7);\n    out1[0] = x19;\n    out1[1] = x20;\n    out1[2] = x21;\n    out1[3] = x22;\n}",
    "display_name": "fiat_sm2_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_invert<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"invert\", |b| b.iter(|| x.invert()));\n}",
    "display_name": "bench_field_element_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/field.rs",
    "relative_path": "p256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/relax",
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/Mul/mul"
    ],
    "body": "    fn mul(self, rhs: &FieldElement) -> FieldElement {\n        self.relax().mul(&rhs.relax())\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre reject_invalid_signature",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre signing_key",
      "0.14.0_pre dsa/impl/Signature/to_bytes",
      "0.14.0_pre dsa/signing/impl/SigningKey/verifying_key",
      "0.14.0_pre dsa/impl/Signature/from_bytes",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/Verifier/verify"
    ],
    "body": "    fn reject_invalid_signature(sk in signing_key(), byte in 0usize..32, bit in 0usize..8) {\n        let mut signature_bytes = sk.sign(MSG).to_bytes();\n\n        // tweak signature to make it invalid\n        signature_bytes[byte] ^= 1 << bit;\n\n        let signature = Signature::from_bytes(&signature_bytes).unwrap();\n        prop_assert!(sk.verifying_key().verify(MSG, &signature).is_err());\n    }",
    "display_name": "reject_invalid_signature",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2dsa.rs",
    "relative_path": "sm2/tests/sm2dsa.rs",
    "file_name": "sm2dsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/mul_wide",
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce"
    ],
    "body": "    pub fn mul(&self, rhs: &Scalar) -> Scalar {\n        WideScalar::mul_wide(self, rhs).reduce()\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate"
    ],
    "body": "    fn neg(self) -> FieldElement {\n        self.negate(1)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "affine/impl/PublicKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "affine/impl/PublicKey/TryFrom>/try_from"
    ],
    "body": "    fn try_from(affine_point: &AffinePoint<C>) -> Result<PublicKey<C>> {\n        PublicKey::<C>::try_from(*affine_point)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul"
    ],
    "body": "    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Mul::mul).unwrap_or(Self::ONE)\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p224_u1,\n    arg1: fiat_p224_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_p224_u1 = ((x1 >> 64) as fiat_p224_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p224_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/multiply"
    ],
    "body": "    pub(crate) const fn to_montgomery(self) -> Self {\n        Self::multiply(&self, &R2)\n    }",
    "display_name": "to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p384_sub(\n    out1: &mut fiat_p384_montgomery_domain_field_element,\n    arg1: &fiat_p384_montgomery_domain_field_element,\n    arg2: &fiat_p384_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x9, &mut x10, x8, (arg1[4]), (arg2[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x11, &mut x12, x10, (arg1[5]), (arg2[5]));\n    let mut x13: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x13, x12, (0x0 as u64), 0xffffffffffffffff);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x14, &mut x15, 0x0, x1, (x13 & 0xffffffff));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x16, &mut x17, x15, x3, (x13 & 0xffffffff00000000));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x18, &mut x19, x17, x5, (x13 & 0xfffffffffffffffe));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x20, &mut x21, x19, x7, x13);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x22, &mut x23, x21, x9, x13);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x24, &mut x25, x23, x11, x13);\n    out1[0] = x14;\n    out1[1] = x16;\n    out1[2] = x18;\n    out1[3] = x20;\n    out1[4] = x22;\n    out1[5] = x24;\n}",
    "display_name": "fiat_p384_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/LookupTable/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_mulx_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_from_montgomery(\n    out1: &mut fiat_p192_scalar_non_montgomery_domain_field_element,\n    arg1: &fiat_p192_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x2, &mut x3, x1, 0x882672070ddbcf2f);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x4, &mut x5, x2, 0xffffffffffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x6, &mut x7, x2, 0xffffffff99def836);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x8, &mut x9, x2, 0x146bc9b1b4d22831);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x9, x6);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x7, x4);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x14, &mut x15, 0x0, x1, x8);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), x10);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), x12);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), ((x13 as u64) + x5));\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x22, &mut x23, 0x0, x16, (arg1[1]));\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x24, &mut x25, x23, x18, (0x0 as u64));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x26, &mut x27, x25, x20, (0x0 as u64));\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x28, &mut x29, x22, 0x882672070ddbcf2f);\n    let mut x30: u64 = 0;\n    let mut x31: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x30, &mut x31, x28, 0xffffffffffffffff);\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x32, &mut x33, x28, 0xffffffff99def836);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x34, &mut x35, x28, 0x146bc9b1b4d22831);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x36, &mut x37, 0x0, x35, x32);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x38, &mut x39, x37, x33, x30);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x40, &mut x41, 0x0, x22, x34);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x42, &mut x43, x41, x24, x36);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x44, &mut x45, x43, x26, x38);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(\n        &mut x46,\n        &mut x47,\n        x45,\n        ((x27 as u64) + (x21 as u64)),\n        ((x39 as u64) + x31),\n    );\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x48, &mut x49, 0x0, x42, (arg1[2]));\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x50, &mut x51, x49, x44, (0x0 as u64));\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x52, &mut x53, x51, x46, (0x0 as u64));\n    let mut x54: u64 = 0;\n    let mut x55: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x54, &mut x55, x48, 0x882672070ddbcf2f);\n    let mut x56: u64 = 0;\n    let mut x57: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x56, &mut x57, x54, 0xffffffffffffffff);\n    let mut x58: u64 = 0;\n    let mut x59: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x58, &mut x59, x54, 0xffffffff99def836);\n    let mut x60: u64 = 0;\n    let mut x61: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x60, &mut x61, x54, 0x146bc9b1b4d22831);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x61, x58);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x59, x56);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x66, &mut x67, 0x0, x48, x60);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x50, x62);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x70, &mut x71, x69, x52, x64);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(\n        &mut x72,\n        &mut x73,\n        x71,\n        ((x53 as u64) + (x47 as u64)),\n        ((x65 as u64) + x57),\n    );\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x74, &mut x75, 0x0, x68, 0x146bc9b1b4d22831);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x76, &mut x77, x75, x70, 0xffffffff99def836);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x78, &mut x79, x77, x72, 0xffffffffffffffff);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x80, &mut x81, x79, (x73 as u64), (0x0 as u64));\n    let mut x82: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x82, x81, x74, x68);\n    let mut x83: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x83, x81, x76, x70);\n    let mut x84: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x84, x81, x78, x72);\n    out1[0] = x82;\n    out1[1] = x83;\n    out1[2] = x84;\n}",
    "display_name": "fiat_p192_scalar_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalize_weak",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/add_modulus_correction",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/subtract_modulus_approximation"
    ],
    "body": "    pub fn normalize_weak(&self) -> Self {\n        // Reduce t4 at the start so there will be at most a single carry from the first pass\n        let (t, x) = self.subtract_modulus_approximation();\n\n        // The first pass ensures the magnitude is 1, ...\n        let res = t.add_modulus_correction(x);\n\n        // ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element)\n        debug_assert!(res.0[4] >> 49 == 0);\n\n        res\n    }",
    "display_name": "normalize_weak",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/EncodePublicKey/to_public_key_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/to_bytes"
    ],
    "body": "    fn to_public_key_der(&self) -> pkcs8::spki::Result<der::Document> {\n        let pk_bytes = self.to_bytes();\n        let subject_public_key = der::asn1::BitStringRef::new(0, &pk_bytes)?;\n\n        pkcs8::SubjectPublicKeyInfo {\n            algorithm: Self::ALGORITHM_IDENTIFIER,\n            subject_public_key,\n        }\n        .try_into()\n    }",
    "display_name": "to_public_key_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_to_bytes(out1: &mut [u8; 32], arg1: &[u64; 4]) {\n    let x1: u64 = (arg1[3]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[1]);\n    let x4: u64 = (arg1[0]);\n    let x5: u8 = ((x4 & (0xff as u64)) as u8);\n    let x6: u64 = (x4 >> 8);\n    let x7: u8 = ((x6 & (0xff as u64)) as u8);\n    let x8: u64 = (x6 >> 8);\n    let x9: u8 = ((x8 & (0xff as u64)) as u8);\n    let x10: u64 = (x8 >> 8);\n    let x11: u8 = ((x10 & (0xff as u64)) as u8);\n    let x12: u64 = (x10 >> 8);\n    let x13: u8 = ((x12 & (0xff as u64)) as u8);\n    let x14: u64 = (x12 >> 8);\n    let x15: u8 = ((x14 & (0xff as u64)) as u8);\n    let x16: u64 = (x14 >> 8);\n    let x17: u8 = ((x16 & (0xff as u64)) as u8);\n    let x18: u8 = ((x16 >> 8) as u8);\n    let x19: u8 = ((x3 & (0xff as u64)) as u8);\n    let x20: u64 = (x3 >> 8);\n    let x21: u8 = ((x20 & (0xff as u64)) as u8);\n    let x22: u64 = (x20 >> 8);\n    let x23: u8 = ((x22 & (0xff as u64)) as u8);\n    let x24: u64 = (x22 >> 8);\n    let x25: u8 = ((x24 & (0xff as u64)) as u8);\n    let x26: u64 = (x24 >> 8);\n    let x27: u8 = ((x26 & (0xff as u64)) as u8);\n    let x28: u64 = (x26 >> 8);\n    let x29: u8 = ((x28 & (0xff as u64)) as u8);\n    let x30: u64 = (x28 >> 8);\n    let x31: u8 = ((x30 & (0xff as u64)) as u8);\n    let x32: u8 = ((x30 >> 8) as u8);\n    let x33: u8 = ((x2 & (0xff as u64)) as u8);\n    let x34: u64 = (x2 >> 8);\n    let x35: u8 = ((x34 & (0xff as u64)) as u8);\n    let x36: u64 = (x34 >> 8);\n    let x37: u8 = ((x36 & (0xff as u64)) as u8);\n    let x38: u64 = (x36 >> 8);\n    let x39: u8 = ((x38 & (0xff as u64)) as u8);\n    let x40: u64 = (x38 >> 8);\n    let x41: u8 = ((x40 & (0xff as u64)) as u8);\n    let x42: u64 = (x40 >> 8);\n    let x43: u8 = ((x42 & (0xff as u64)) as u8);\n    let x44: u64 = (x42 >> 8);\n    let x45: u8 = ((x44 & (0xff as u64)) as u8);\n    let x46: u8 = ((x44 >> 8) as u8);\n    let x47: u8 = ((x1 & (0xff as u64)) as u8);\n    let x48: u64 = (x1 >> 8);\n    let x49: u8 = ((x48 & (0xff as u64)) as u8);\n    let x50: u64 = (x48 >> 8);\n    let x51: u8 = ((x50 & (0xff as u64)) as u8);\n    let x52: u64 = (x50 >> 8);\n    let x53: u8 = ((x52 & (0xff as u64)) as u8);\n    let x54: u64 = (x52 >> 8);\n    let x55: u8 = ((x54 & (0xff as u64)) as u8);\n    let x56: u64 = (x54 >> 8);\n    let x57: u8 = ((x56 & (0xff as u64)) as u8);\n    let x58: u64 = (x56 >> 8);\n    let x59: u8 = ((x58 & (0xff as u64)) as u8);\n    let x60: u8 = ((x58 >> 8) as u8);\n    out1[0] = x5;\n    out1[1] = x7;\n    out1[2] = x9;\n    out1[3] = x11;\n    out1[4] = x13;\n    out1[5] = x15;\n    out1[6] = x17;\n    out1[7] = x18;\n    out1[8] = x19;\n    out1[9] = x21;\n    out1[10] = x23;\n    out1[11] = x25;\n    out1[12] = x27;\n    out1[13] = x29;\n    out1[14] = x31;\n    out1[15] = x32;\n    out1[16] = x33;\n    out1[17] = x35;\n    out1[18] = x37;\n    out1[19] = x39;\n    out1[20] = x41;\n    out1[21] = x43;\n    out1[22] = x45;\n    out1[23] = x46;\n    out1[24] = x47;\n    out1[25] = x49;\n    out1[26] = x51;\n    out1[27] = x53;\n    out1[28] = x55;\n    out1[29] = x57;\n    out1[30] = x59;\n    out1[31] = x60;\n}",
    "display_name": "fiat_sm2_scalar_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_mulx_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_to_montgomery(\n    out1: &mut fiat_sm2_scalar_montgomery_domain_field_element,\n    arg1: &fiat_sm2_scalar_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x5, &mut x6, x4, 0x1eb5e412a22b3d3b);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x7, &mut x8, x4, 0x620fc84c3affe0d4);\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x9, &mut x10, x4, 0x3464504ade6fa2fa);\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x11, &mut x12, x4, 0x901192af7c114f20);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x19, &mut x20, x11, 0x327f9e8872350975);\n    let mut x21: u64 = 0;\n    let mut x22: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x21, &mut x22, x19, 0xfffffffeffffffff);\n    let mut x23: u64 = 0;\n    let mut x24: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x23, &mut x24, x19, 0xffffffffffffffff);\n    let mut x25: u64 = 0;\n    let mut x26: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x25, &mut x26, x19, 0x7203df6b21c6052b);\n    let mut x27: u64 = 0;\n    let mut x28: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x27, &mut x28, x19, 0x53bbf40939d54123);\n    let mut x29: u64 = 0;\n    let mut x30: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x29, &mut x30, 0x0, x28, x25);\n    let mut x31: u64 = 0;\n    let mut x32: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x31, &mut x32, x30, x26, x23);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x33, &mut x34, x32, x24, x21);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x35, &mut x36, 0x0, x11, x27);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x37, &mut x38, x36, x13, x29);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x15, x31);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x17, x33);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(\n        &mut x43,\n        &mut x44,\n        x42,\n        ((x18 as u64) + x6),\n        ((x34 as u64) + x22),\n    );\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x45, &mut x46, x1, 0x1eb5e412a22b3d3b);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x47, &mut x48, x1, 0x620fc84c3affe0d4);\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x49, &mut x50, x1, 0x3464504ade6fa2fa);\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x51, &mut x52, x1, 0x901192af7c114f20);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x53, &mut x54, 0x0, x52, x49);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x55, &mut x56, x54, x50, x47);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x48, x45);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x59, &mut x60, 0x0, x37, x51);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x61, &mut x62, x60, x39, x53);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x63, &mut x64, x62, x41, x55);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x65, &mut x66, x64, x43, x57);\n    let mut x67: u64 = 0;\n    let mut x68: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x67, &mut x68, x59, 0x327f9e8872350975);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x69, &mut x70, x67, 0xfffffffeffffffff);\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x71, &mut x72, x67, 0xffffffffffffffff);\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x73, &mut x74, x67, 0x7203df6b21c6052b);\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x75, &mut x76, x67, 0x53bbf40939d54123);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x77, &mut x78, 0x0, x76, x73);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x79, &mut x80, x78, x74, x71);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x81, &mut x82, x80, x72, x69);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x83, &mut x84, 0x0, x59, x75);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x85, &mut x86, x84, x61, x77);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x87, &mut x88, x86, x63, x79);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x89, &mut x90, x88, x65, x81);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(\n        &mut x91,\n        &mut x92,\n        x90,\n        (((x66 as u64) + (x44 as u64)) + ((x58 as u64) + x46)),\n        ((x82 as u64) + x70),\n    );\n    let mut x93: u64 = 0;\n    let mut x94: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x93, &mut x94, x2, 0x1eb5e412a22b3d3b);\n    let mut x95: u64 = 0;\n    let mut x96: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x95, &mut x96, x2, 0x620fc84c3affe0d4);\n    let mut x97: u64 = 0;\n    let mut x98: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x97, &mut x98, x2, 0x3464504ade6fa2fa);\n    let mut x99: u64 = 0;\n    let mut x100: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x99, &mut x100, x2, 0x901192af7c114f20);\n    let mut x101: u64 = 0;\n    let mut x102: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x101, &mut x102, 0x0, x100, x97);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x103, &mut x104, x102, x98, x95);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x105, &mut x106, x104, x96, x93);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x107, &mut x108, 0x0, x85, x99);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x109, &mut x110, x108, x87, x101);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x111, &mut x112, x110, x89, x103);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x113, &mut x114, x112, x91, x105);\n    let mut x115: u64 = 0;\n    let mut x116: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x115, &mut x116, x107, 0x327f9e8872350975);\n    let mut x117: u64 = 0;\n    let mut x118: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x117, &mut x118, x115, 0xfffffffeffffffff);\n    let mut x119: u64 = 0;\n    let mut x120: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x119, &mut x120, x115, 0xffffffffffffffff);\n    let mut x121: u64 = 0;\n    let mut x122: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x121, &mut x122, x115, 0x7203df6b21c6052b);\n    let mut x123: u64 = 0;\n    let mut x124: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x123, &mut x124, x115, 0x53bbf40939d54123);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x125, &mut x126, 0x0, x124, x121);\n    let mut x127: u64 = 0;\n    let mut x128: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x127, &mut x128, x126, x122, x119);\n    let mut x129: u64 = 0;\n    let mut x130: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x129, &mut x130, x128, x120, x117);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x131, &mut x132, 0x0, x107, x123);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x133, &mut x134, x132, x109, x125);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x135, &mut x136, x134, x111, x127);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x113, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(\n        &mut x139,\n        &mut x140,\n        x138,\n        (((x114 as u64) + (x92 as u64)) + ((x106 as u64) + x94)),\n        ((x130 as u64) + x118),\n    );\n    let mut x141: u64 = 0;\n    let mut x142: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x141, &mut x142, x3, 0x1eb5e412a22b3d3b);\n    let mut x143: u64 = 0;\n    let mut x144: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x143, &mut x144, x3, 0x620fc84c3affe0d4);\n    let mut x145: u64 = 0;\n    let mut x146: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x145, &mut x146, x3, 0x3464504ade6fa2fa);\n    let mut x147: u64 = 0;\n    let mut x148: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x147, &mut x148, x3, 0x901192af7c114f20);\n    let mut x149: u64 = 0;\n    let mut x150: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x149, &mut x150, 0x0, x148, x145);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x151, &mut x152, x150, x146, x143);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x153, &mut x154, x152, x144, x141);\n    let mut x155: u64 = 0;\n    let mut x156: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x155, &mut x156, 0x0, x133, x147);\n    let mut x157: u64 = 0;\n    let mut x158: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x157, &mut x158, x156, x135, x149);\n    let mut x159: u64 = 0;\n    let mut x160: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x159, &mut x160, x158, x137, x151);\n    let mut x161: u64 = 0;\n    let mut x162: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x161, &mut x162, x160, x139, x153);\n    let mut x163: u64 = 0;\n    let mut x164: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x163, &mut x164, x155, 0x327f9e8872350975);\n    let mut x165: u64 = 0;\n    let mut x166: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x165, &mut x166, x163, 0xfffffffeffffffff);\n    let mut x167: u64 = 0;\n    let mut x168: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x167, &mut x168, x163, 0xffffffffffffffff);\n    let mut x169: u64 = 0;\n    let mut x170: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x169, &mut x170, x163, 0x7203df6b21c6052b);\n    let mut x171: u64 = 0;\n    let mut x172: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x171, &mut x172, x163, 0x53bbf40939d54123);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x173, &mut x174, 0x0, x172, x169);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x175, &mut x176, x174, x170, x167);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x177, &mut x178, x176, x168, x165);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x179, &mut x180, 0x0, x155, x171);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x181, &mut x182, x180, x157, x173);\n    let mut x183: u64 = 0;\n    let mut x184: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x183, &mut x184, x182, x159, x175);\n    let mut x185: u64 = 0;\n    let mut x186: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x185, &mut x186, x184, x161, x177);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(\n        &mut x187,\n        &mut x188,\n        x186,\n        (((x162 as u64) + (x140 as u64)) + ((x154 as u64) + x142)),\n        ((x178 as u64) + x166),\n    );\n    let mut x189: u64 = 0;\n    let mut x190: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x189, &mut x190, 0x0, x181, 0x53bbf40939d54123);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x191, &mut x192, x190, x183, 0x7203df6b21c6052b);\n    let mut x193: u64 = 0;\n    let mut x194: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x193, &mut x194, x192, x185, 0xffffffffffffffff);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x195, &mut x196, x194, x187, 0xfffffffeffffffff);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x197, &mut x198, x196, (x188 as u64), (0x0 as u64));\n    let mut x199: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x199, x198, x189, x181);\n    let mut x200: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x200, x198, x191, x183);\n    let mut x201: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x201, x198, x193, x185);\n    let mut x202: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x202, x198, x195, x187);\n    out1[0] = x199;\n    out1[1] = x200;\n    out1[2] = x201;\n    out1[3] = x202;\n}",
    "display_name": "fiat_sm2_scalar_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/fiat_p384_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Td: FieldElement::conditional_select(&a.Td, &b.Td, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/projective.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn add(&self, rhs: &Self) -> Self {\n        Self(self.0.add_mod(&rhs.0, &NistP256::ORDER))\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/repeated_double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double"
    ],
    "body": "    fn repeated_double() {\n        let mut r = FieldElement::ONE;\n        for item in DBL_TEST_VECTORS {\n            assert_eq!(r.to_bytes().as_slice(), item);\n            r = r.double();\n        }\n    }",
    "display_name": "repeated_double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/&Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> Self::Output {\n        Scalar::ZERO - self\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_odd(&self) -> Choice {\n        self.0.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/&MontgomeryPoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/montgomery/impl/ProjectiveMontgomeryPoint/identity",
      "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes",
      "0.14.0_pre.1 curve/montgomery/differential_add_and_double",
      "0.14.0_pre.1 curve/montgomery/impl/ProjectiveMontgomeryPoint/to_affine",
      "0.14.0_pre.1 field/scalar/impl/Scalar/bits"
    ],
    "body": "    fn mul(self, scalar: &Scalar) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectiveMontgomeryPoint::identity();\n        let mut x1 = ProjectiveMontgomeryPoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        let bits = scalar.bits();\n        let mut swap = 0;\n        for s in (0..448).rev() {\n            let bit = bits[s] as u8;\n            let choice: u8 = swap ^ bit;\n\n            ProjectiveMontgomeryPoint::conditional_swap(&mut x0, &mut x1, Choice::from(choice));\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            swap = bit;\n        }\n\n        x0.to_affine()\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_mulx_u64",
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p384_mul(\n    out1: &mut fiat_p384_montgomery_domain_field_element,\n    arg1: &fiat_p384_montgomery_domain_field_element,\n    arg2: &fiat_p384_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[0]);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p384_mulx_u64(&mut x7, &mut x8, x6, (arg2[5]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p384_mulx_u64(&mut x9, &mut x10, x6, (arg2[4]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p384_mulx_u64(&mut x11, &mut x12, x6, (arg2[3]));\n    let mut x13: u64 = 0;\n    let mut x14: u64 = 0;\n    fiat_p384_mulx_u64(&mut x13, &mut x14, x6, (arg2[2]));\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p384_mulx_u64(&mut x15, &mut x16, x6, (arg2[1]));\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p384_mulx_u64(&mut x17, &mut x18, x6, (arg2[0]));\n    let mut x19: u64 = 0;\n    let mut x20: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x19, &mut x20, 0x0, x18, x15);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x21, &mut x22, x20, x16, x13);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x23, &mut x24, x22, x14, x11);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x25, &mut x26, x24, x12, x9);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x27, &mut x28, x26, x10, x7);\n    let x29: u64 = ((x28 as u64) + x8);\n    let mut x30: u64 = 0;\n    let mut x31: u64 = 0;\n    fiat_p384_mulx_u64(&mut x30, &mut x31, x17, 0x100000001);\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_p384_mulx_u64(&mut x32, &mut x33, x30, 0xffffffffffffffff);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p384_mulx_u64(&mut x34, &mut x35, x30, 0xffffffffffffffff);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p384_mulx_u64(&mut x36, &mut x37, x30, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p384_mulx_u64(&mut x38, &mut x39, x30, 0xfffffffffffffffe);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_p384_mulx_u64(&mut x40, &mut x41, x30, 0xffffffff00000000);\n    let mut x42: u64 = 0;\n    let mut x43: u64 = 0;\n    fiat_p384_mulx_u64(&mut x42, &mut x43, x30, 0xffffffff);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x44, &mut x45, 0x0, x43, x40);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x46, &mut x47, x45, x41, x38);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x48, &mut x49, x47, x39, x36);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x50, &mut x51, x49, x37, x34);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x52, &mut x53, x51, x35, x32);\n    let x54: u64 = ((x53 as u64) + x33);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x55, &mut x56, 0x0, x17, x42);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x57, &mut x58, x56, x19, x44);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x59, &mut x60, x58, x21, x46);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x61, &mut x62, x60, x23, x48);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x63, &mut x64, x62, x25, x50);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x65, &mut x66, x64, x27, x52);\n    let mut x67: u64 = 0;\n    let mut x68: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x67, &mut x68, x66, x29, x54);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_p384_mulx_u64(&mut x69, &mut x70, x1, (arg2[5]));\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_p384_mulx_u64(&mut x71, &mut x72, x1, (arg2[4]));\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_p384_mulx_u64(&mut x73, &mut x74, x1, (arg2[3]));\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_p384_mulx_u64(&mut x75, &mut x76, x1, (arg2[2]));\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p384_mulx_u64(&mut x77, &mut x78, x1, (arg2[1]));\n    let mut x79: u64 = 0;\n    let mut x80: u64 = 0;\n    fiat_p384_mulx_u64(&mut x79, &mut x80, x1, (arg2[0]));\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x81, &mut x82, 0x0, x80, x77);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x83, &mut x84, x82, x78, x75);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x85, &mut x86, x84, x76, x73);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x87, &mut x88, x86, x74, x71);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x89, &mut x90, x88, x72, x69);\n    let x91: u64 = ((x90 as u64) + x70);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x92, &mut x93, 0x0, x57, x79);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x94, &mut x95, x93, x59, x81);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x96, &mut x97, x95, x61, x83);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x98, &mut x99, x97, x63, x85);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x100, &mut x101, x99, x65, x87);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x102, &mut x103, x101, x67, x89);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x104, &mut x105, x103, (x68 as u64), x91);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p384_mulx_u64(&mut x106, &mut x107, x92, 0x100000001);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p384_mulx_u64(&mut x108, &mut x109, x106, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p384_mulx_u64(&mut x110, &mut x111, x106, 0xffffffffffffffff);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p384_mulx_u64(&mut x112, &mut x113, x106, 0xffffffffffffffff);\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p384_mulx_u64(&mut x114, &mut x115, x106, 0xfffffffffffffffe);\n    let mut x116: u64 = 0;\n    let mut x117: u64 = 0;\n    fiat_p384_mulx_u64(&mut x116, &mut x117, x106, 0xffffffff00000000);\n    let mut x118: u64 = 0;\n    let mut x119: u64 = 0;\n    fiat_p384_mulx_u64(&mut x118, &mut x119, x106, 0xffffffff);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x120, &mut x121, 0x0, x119, x116);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x122, &mut x123, x121, x117, x114);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x124, &mut x125, x123, x115, x112);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x126, &mut x127, x125, x113, x110);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x128, &mut x129, x127, x111, x108);\n    let x130: u64 = ((x129 as u64) + x109);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x131, &mut x132, 0x0, x92, x118);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x133, &mut x134, x132, x94, x120);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x135, &mut x136, x134, x96, x122);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x137, &mut x138, x136, x98, x124);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x139, &mut x140, x138, x100, x126);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x141, &mut x142, x140, x102, x128);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x143, &mut x144, x142, x104, x130);\n    let x145: u64 = ((x144 as u64) + (x105 as u64));\n    let mut x146: u64 = 0;\n    let mut x147: u64 = 0;\n    fiat_p384_mulx_u64(&mut x146, &mut x147, x2, (arg2[5]));\n    let mut x148: u64 = 0;\n    let mut x149: u64 = 0;\n    fiat_p384_mulx_u64(&mut x148, &mut x149, x2, (arg2[4]));\n    let mut x150: u64 = 0;\n    let mut x151: u64 = 0;\n    fiat_p384_mulx_u64(&mut x150, &mut x151, x2, (arg2[3]));\n    let mut x152: u64 = 0;\n    let mut x153: u64 = 0;\n    fiat_p384_mulx_u64(&mut x152, &mut x153, x2, (arg2[2]));\n    let mut x154: u64 = 0;\n    let mut x155: u64 = 0;\n    fiat_p384_mulx_u64(&mut x154, &mut x155, x2, (arg2[1]));\n    let mut x156: u64 = 0;\n    let mut x157: u64 = 0;\n    fiat_p384_mulx_u64(&mut x156, &mut x157, x2, (arg2[0]));\n    let mut x158: u64 = 0;\n    let mut x159: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x158, &mut x159, 0x0, x157, x154);\n    let mut x160: u64 = 0;\n    let mut x161: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x160, &mut x161, x159, x155, x152);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x162, &mut x163, x161, x153, x150);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x164, &mut x165, x163, x151, x148);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x166, &mut x167, x165, x149, x146);\n    let x168: u64 = ((x167 as u64) + x147);\n    let mut x169: u64 = 0;\n    let mut x170: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x169, &mut x170, 0x0, x133, x156);\n    let mut x171: u64 = 0;\n    let mut x172: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x171, &mut x172, x170, x135, x158);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x173, &mut x174, x172, x137, x160);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x175, &mut x176, x174, x139, x162);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x177, &mut x178, x176, x141, x164);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x179, &mut x180, x178, x143, x166);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x181, &mut x182, x180, x145, x168);\n    let mut x183: u64 = 0;\n    let mut x184: u64 = 0;\n    fiat_p384_mulx_u64(&mut x183, &mut x184, x169, 0x100000001);\n    let mut x185: u64 = 0;\n    let mut x186: u64 = 0;\n    fiat_p384_mulx_u64(&mut x185, &mut x186, x183, 0xffffffffffffffff);\n    let mut x187: u64 = 0;\n    let mut x188: u64 = 0;\n    fiat_p384_mulx_u64(&mut x187, &mut x188, x183, 0xffffffffffffffff);\n    let mut x189: u64 = 0;\n    let mut x190: u64 = 0;\n    fiat_p384_mulx_u64(&mut x189, &mut x190, x183, 0xffffffffffffffff);\n    let mut x191: u64 = 0;\n    let mut x192: u64 = 0;\n    fiat_p384_mulx_u64(&mut x191, &mut x192, x183, 0xfffffffffffffffe);\n    let mut x193: u64 = 0;\n    let mut x194: u64 = 0;\n    fiat_p384_mulx_u64(&mut x193, &mut x194, x183, 0xffffffff00000000);\n    let mut x195: u64 = 0;\n    let mut x196: u64 = 0;\n    fiat_p384_mulx_u64(&mut x195, &mut x196, x183, 0xffffffff);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x197, &mut x198, 0x0, x196, x193);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x199, &mut x200, x198, x194, x191);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x201, &mut x202, x200, x192, x189);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x203, &mut x204, x202, x190, x187);\n    let mut x205: u64 = 0;\n    let mut x206: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x205, &mut x206, x204, x188, x185);\n    let x207: u64 = ((x206 as u64) + x186);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x208, &mut x209, 0x0, x169, x195);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x210, &mut x211, x209, x171, x197);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x212, &mut x213, x211, x173, x199);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x214, &mut x215, x213, x175, x201);\n    let mut x216: u64 = 0;\n    let mut x217: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x216, &mut x217, x215, x177, x203);\n    let mut x218: u64 = 0;\n    let mut x219: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x218, &mut x219, x217, x179, x205);\n    let mut x220: u64 = 0;\n    let mut x221: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x220, &mut x221, x219, x181, x207);\n    let x222: u64 = ((x221 as u64) + (x182 as u64));\n    let mut x223: u64 = 0;\n    let mut x224: u64 = 0;\n    fiat_p384_mulx_u64(&mut x223, &mut x224, x3, (arg2[5]));\n    let mut x225: u64 = 0;\n    let mut x226: u64 = 0;\n    fiat_p384_mulx_u64(&mut x225, &mut x226, x3, (arg2[4]));\n    let mut x227: u64 = 0;\n    let mut x228: u64 = 0;\n    fiat_p384_mulx_u64(&mut x227, &mut x228, x3, (arg2[3]));\n    let mut x229: u64 = 0;\n    let mut x230: u64 = 0;\n    fiat_p384_mulx_u64(&mut x229, &mut x230, x3, (arg2[2]));\n    let mut x231: u64 = 0;\n    let mut x232: u64 = 0;\n    fiat_p384_mulx_u64(&mut x231, &mut x232, x3, (arg2[1]));\n    let mut x233: u64 = 0;\n    let mut x234: u64 = 0;\n    fiat_p384_mulx_u64(&mut x233, &mut x234, x3, (arg2[0]));\n    let mut x235: u64 = 0;\n    let mut x236: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x235, &mut x236, 0x0, x234, x231);\n    let mut x237: u64 = 0;\n    let mut x238: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x237, &mut x238, x236, x232, x229);\n    let mut x239: u64 = 0;\n    let mut x240: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x239, &mut x240, x238, x230, x227);\n    let mut x241: u64 = 0;\n    let mut x242: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x241, &mut x242, x240, x228, x225);\n    let mut x243: u64 = 0;\n    let mut x244: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x243, &mut x244, x242, x226, x223);\n    let x245: u64 = ((x244 as u64) + x224);\n    let mut x246: u64 = 0;\n    let mut x247: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x246, &mut x247, 0x0, x210, x233);\n    let mut x248: u64 = 0;\n    let mut x249: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x248, &mut x249, x247, x212, x235);\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x250, &mut x251, x249, x214, x237);\n    let mut x252: u64 = 0;\n    let mut x253: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x252, &mut x253, x251, x216, x239);\n    let mut x254: u64 = 0;\n    let mut x255: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x254, &mut x255, x253, x218, x241);\n    let mut x256: u64 = 0;\n    let mut x257: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x256, &mut x257, x255, x220, x243);\n    let mut x258: u64 = 0;\n    let mut x259: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x258, &mut x259, x257, x222, x245);\n    let mut x260: u64 = 0;\n    let mut x261: u64 = 0;\n    fiat_p384_mulx_u64(&mut x260, &mut x261, x246, 0x100000001);\n    let mut x262: u64 = 0;\n    let mut x263: u64 = 0;\n    fiat_p384_mulx_u64(&mut x262, &mut x263, x260, 0xffffffffffffffff);\n    let mut x264: u64 = 0;\n    let mut x265: u64 = 0;\n    fiat_p384_mulx_u64(&mut x264, &mut x265, x260, 0xffffffffffffffff);\n    let mut x266: u64 = 0;\n    let mut x267: u64 = 0;\n    fiat_p384_mulx_u64(&mut x266, &mut x267, x260, 0xffffffffffffffff);\n    let mut x268: u64 = 0;\n    let mut x269: u64 = 0;\n    fiat_p384_mulx_u64(&mut x268, &mut x269, x260, 0xfffffffffffffffe);\n    let mut x270: u64 = 0;\n    let mut x271: u64 = 0;\n    fiat_p384_mulx_u64(&mut x270, &mut x271, x260, 0xffffffff00000000);\n    let mut x272: u64 = 0;\n    let mut x273: u64 = 0;\n    fiat_p384_mulx_u64(&mut x272, &mut x273, x260, 0xffffffff);\n    let mut x274: u64 = 0;\n    let mut x275: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x274, &mut x275, 0x0, x273, x270);\n    let mut x276: u64 = 0;\n    let mut x277: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x276, &mut x277, x275, x271, x268);\n    let mut x278: u64 = 0;\n    let mut x279: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x278, &mut x279, x277, x269, x266);\n    let mut x280: u64 = 0;\n    let mut x281: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x280, &mut x281, x279, x267, x264);\n    let mut x282: u64 = 0;\n    let mut x283: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x282, &mut x283, x281, x265, x262);\n    let x284: u64 = ((x283 as u64) + x263);\n    let mut x285: u64 = 0;\n    let mut x286: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x285, &mut x286, 0x0, x246, x272);\n    let mut x287: u64 = 0;\n    let mut x288: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x287, &mut x288, x286, x248, x274);\n    let mut x289: u64 = 0;\n    let mut x290: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x289, &mut x290, x288, x250, x276);\n    let mut x291: u64 = 0;\n    let mut x292: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x291, &mut x292, x290, x252, x278);\n    let mut x293: u64 = 0;\n    let mut x294: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x293, &mut x294, x292, x254, x280);\n    let mut x295: u64 = 0;\n    let mut x296: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x295, &mut x296, x294, x256, x282);\n    let mut x297: u64 = 0;\n    let mut x298: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x297, &mut x298, x296, x258, x284);\n    let x299: u64 = ((x298 as u64) + (x259 as u64));\n    let mut x300: u64 = 0;\n    let mut x301: u64 = 0;\n    fiat_p384_mulx_u64(&mut x300, &mut x301, x4, (arg2[5]));\n    let mut x302: u64 = 0;\n    let mut x303: u64 = 0;\n    fiat_p384_mulx_u64(&mut x302, &mut x303, x4, (arg2[4]));\n    let mut x304: u64 = 0;\n    let mut x305: u64 = 0;\n    fiat_p384_mulx_u64(&mut x304, &mut x305, x4, (arg2[3]));\n    let mut x306: u64 = 0;\n    let mut x307: u64 = 0;\n    fiat_p384_mulx_u64(&mut x306, &mut x307, x4, (arg2[2]));\n    let mut x308: u64 = 0;\n    let mut x309: u64 = 0;\n    fiat_p384_mulx_u64(&mut x308, &mut x309, x4, (arg2[1]));\n    let mut x310: u64 = 0;\n    let mut x311: u64 = 0;\n    fiat_p384_mulx_u64(&mut x310, &mut x311, x4, (arg2[0]));\n    let mut x312: u64 = 0;\n    let mut x313: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x312, &mut x313, 0x0, x311, x308);\n    let mut x314: u64 = 0;\n    let mut x315: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x314, &mut x315, x313, x309, x306);\n    let mut x316: u64 = 0;\n    let mut x317: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x316, &mut x317, x315, x307, x304);\n    let mut x318: u64 = 0;\n    let mut x319: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x318, &mut x319, x317, x305, x302);\n    let mut x320: u64 = 0;\n    let mut x321: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x320, &mut x321, x319, x303, x300);\n    let x322: u64 = ((x321 as u64) + x301);\n    let mut x323: u64 = 0;\n    let mut x324: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x323, &mut x324, 0x0, x287, x310);\n    let mut x325: u64 = 0;\n    let mut x326: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x325, &mut x326, x324, x289, x312);\n    let mut x327: u64 = 0;\n    let mut x328: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x327, &mut x328, x326, x291, x314);\n    let mut x329: u64 = 0;\n    let mut x330: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x329, &mut x330, x328, x293, x316);\n    let mut x331: u64 = 0;\n    let mut x332: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x331, &mut x332, x330, x295, x318);\n    let mut x333: u64 = 0;\n    let mut x334: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x333, &mut x334, x332, x297, x320);\n    let mut x335: u64 = 0;\n    let mut x336: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x335, &mut x336, x334, x299, x322);\n    let mut x337: u64 = 0;\n    let mut x338: u64 = 0;\n    fiat_p384_mulx_u64(&mut x337, &mut x338, x323, 0x100000001);\n    let mut x339: u64 = 0;\n    let mut x340: u64 = 0;\n    fiat_p384_mulx_u64(&mut x339, &mut x340, x337, 0xffffffffffffffff);\n    let mut x341: u64 = 0;\n    let mut x342: u64 = 0;\n    fiat_p384_mulx_u64(&mut x341, &mut x342, x337, 0xffffffffffffffff);\n    let mut x343: u64 = 0;\n    let mut x344: u64 = 0;\n    fiat_p384_mulx_u64(&mut x343, &mut x344, x337, 0xffffffffffffffff);\n    let mut x345: u64 = 0;\n    let mut x346: u64 = 0;\n    fiat_p384_mulx_u64(&mut x345, &mut x346, x337, 0xfffffffffffffffe);\n    let mut x347: u64 = 0;\n    let mut x348: u64 = 0;\n    fiat_p384_mulx_u64(&mut x347, &mut x348, x337, 0xffffffff00000000);\n    let mut x349: u64 = 0;\n    let mut x350: u64 = 0;\n    fiat_p384_mulx_u64(&mut x349, &mut x350, x337, 0xffffffff);\n    let mut x351: u64 = 0;\n    let mut x352: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x351, &mut x352, 0x0, x350, x347);\n    let mut x353: u64 = 0;\n    let mut x354: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x353, &mut x354, x352, x348, x345);\n    let mut x355: u64 = 0;\n    let mut x356: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x355, &mut x356, x354, x346, x343);\n    let mut x357: u64 = 0;\n    let mut x358: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x357, &mut x358, x356, x344, x341);\n    let mut x359: u64 = 0;\n    let mut x360: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x359, &mut x360, x358, x342, x339);\n    let x361: u64 = ((x360 as u64) + x340);\n    let mut x362: u64 = 0;\n    let mut x363: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x362, &mut x363, 0x0, x323, x349);\n    let mut x364: u64 = 0;\n    let mut x365: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x364, &mut x365, x363, x325, x351);\n    let mut x366: u64 = 0;\n    let mut x367: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x366, &mut x367, x365, x327, x353);\n    let mut x368: u64 = 0;\n    let mut x369: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x368, &mut x369, x367, x329, x355);\n    let mut x370: u64 = 0;\n    let mut x371: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x370, &mut x371, x369, x331, x357);\n    let mut x372: u64 = 0;\n    let mut x373: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x372, &mut x373, x371, x333, x359);\n    let mut x374: u64 = 0;\n    let mut x375: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x374, &mut x375, x373, x335, x361);\n    let x376: u64 = ((x375 as u64) + (x336 as u64));\n    let mut x377: u64 = 0;\n    let mut x378: u64 = 0;\n    fiat_p384_mulx_u64(&mut x377, &mut x378, x5, (arg2[5]));\n    let mut x379: u64 = 0;\n    let mut x380: u64 = 0;\n    fiat_p384_mulx_u64(&mut x379, &mut x380, x5, (arg2[4]));\n    let mut x381: u64 = 0;\n    let mut x382: u64 = 0;\n    fiat_p384_mulx_u64(&mut x381, &mut x382, x5, (arg2[3]));\n    let mut x383: u64 = 0;\n    let mut x384: u64 = 0;\n    fiat_p384_mulx_u64(&mut x383, &mut x384, x5, (arg2[2]));\n    let mut x385: u64 = 0;\n    let mut x386: u64 = 0;\n    fiat_p384_mulx_u64(&mut x385, &mut x386, x5, (arg2[1]));\n    let mut x387: u64 = 0;\n    let mut x388: u64 = 0;\n    fiat_p384_mulx_u64(&mut x387, &mut x388, x5, (arg2[0]));\n    let mut x389: u64 = 0;\n    let mut x390: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x389, &mut x390, 0x0, x388, x385);\n    let mut x391: u64 = 0;\n    let mut x392: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x391, &mut x392, x390, x386, x383);\n    let mut x393: u64 = 0;\n    let mut x394: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x393, &mut x394, x392, x384, x381);\n    let mut x395: u64 = 0;\n    let mut x396: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x395, &mut x396, x394, x382, x379);\n    let mut x397: u64 = 0;\n    let mut x398: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x397, &mut x398, x396, x380, x377);\n    let x399: u64 = ((x398 as u64) + x378);\n    let mut x400: u64 = 0;\n    let mut x401: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x400, &mut x401, 0x0, x364, x387);\n    let mut x402: u64 = 0;\n    let mut x403: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x402, &mut x403, x401, x366, x389);\n    let mut x404: u64 = 0;\n    let mut x405: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x404, &mut x405, x403, x368, x391);\n    let mut x406: u64 = 0;\n    let mut x407: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x406, &mut x407, x405, x370, x393);\n    let mut x408: u64 = 0;\n    let mut x409: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x408, &mut x409, x407, x372, x395);\n    let mut x410: u64 = 0;\n    let mut x411: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x410, &mut x411, x409, x374, x397);\n    let mut x412: u64 = 0;\n    let mut x413: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x412, &mut x413, x411, x376, x399);\n    let mut x414: u64 = 0;\n    let mut x415: u64 = 0;\n    fiat_p384_mulx_u64(&mut x414, &mut x415, x400, 0x100000001);\n    let mut x416: u64 = 0;\n    let mut x417: u64 = 0;\n    fiat_p384_mulx_u64(&mut x416, &mut x417, x414, 0xffffffffffffffff);\n    let mut x418: u64 = 0;\n    let mut x419: u64 = 0;\n    fiat_p384_mulx_u64(&mut x418, &mut x419, x414, 0xffffffffffffffff);\n    let mut x420: u64 = 0;\n    let mut x421: u64 = 0;\n    fiat_p384_mulx_u64(&mut x420, &mut x421, x414, 0xffffffffffffffff);\n    let mut x422: u64 = 0;\n    let mut x423: u64 = 0;\n    fiat_p384_mulx_u64(&mut x422, &mut x423, x414, 0xfffffffffffffffe);\n    let mut x424: u64 = 0;\n    let mut x425: u64 = 0;\n    fiat_p384_mulx_u64(&mut x424, &mut x425, x414, 0xffffffff00000000);\n    let mut x426: u64 = 0;\n    let mut x427: u64 = 0;\n    fiat_p384_mulx_u64(&mut x426, &mut x427, x414, 0xffffffff);\n    let mut x428: u64 = 0;\n    let mut x429: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x428, &mut x429, 0x0, x427, x424);\n    let mut x430: u64 = 0;\n    let mut x431: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x430, &mut x431, x429, x425, x422);\n    let mut x432: u64 = 0;\n    let mut x433: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x432, &mut x433, x431, x423, x420);\n    let mut x434: u64 = 0;\n    let mut x435: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x434, &mut x435, x433, x421, x418);\n    let mut x436: u64 = 0;\n    let mut x437: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x436, &mut x437, x435, x419, x416);\n    let x438: u64 = ((x437 as u64) + x417);\n    let mut x439: u64 = 0;\n    let mut x440: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x439, &mut x440, 0x0, x400, x426);\n    let mut x441: u64 = 0;\n    let mut x442: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x441, &mut x442, x440, x402, x428);\n    let mut x443: u64 = 0;\n    let mut x444: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x443, &mut x444, x442, x404, x430);\n    let mut x445: u64 = 0;\n    let mut x446: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x445, &mut x446, x444, x406, x432);\n    let mut x447: u64 = 0;\n    let mut x448: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x447, &mut x448, x446, x408, x434);\n    let mut x449: u64 = 0;\n    let mut x450: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x449, &mut x450, x448, x410, x436);\n    let mut x451: u64 = 0;\n    let mut x452: fiat_p384_u1 = 0;\n    fiat_p384_addcarryx_u64(&mut x451, &mut x452, x450, x412, x438);\n    let x453: u64 = ((x452 as u64) + (x413 as u64));\n    let mut x454: u64 = 0;\n    let mut x455: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x454, &mut x455, 0x0, x441, 0xffffffff);\n    let mut x456: u64 = 0;\n    let mut x457: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x456, &mut x457, x455, x443, 0xffffffff00000000);\n    let mut x458: u64 = 0;\n    let mut x459: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x458, &mut x459, x457, x445, 0xfffffffffffffffe);\n    let mut x460: u64 = 0;\n    let mut x461: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x460, &mut x461, x459, x447, 0xffffffffffffffff);\n    let mut x462: u64 = 0;\n    let mut x463: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x462, &mut x463, x461, x449, 0xffffffffffffffff);\n    let mut x464: u64 = 0;\n    let mut x465: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x464, &mut x465, x463, x451, 0xffffffffffffffff);\n    let mut x466: u64 = 0;\n    let mut x467: fiat_p384_u1 = 0;\n    fiat_p384_subborrowx_u64(&mut x466, &mut x467, x465, x453, (0x0 as u64));\n    let mut x468: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x468, x467, x454, x441);\n    let mut x469: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x469, x467, x456, x443);\n    let mut x470: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x470, x467, x458, x445);\n    let mut x471: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x471, x467, x460, x447);\n    let mut x472: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x472, x467, x462, x449);\n    let mut x473: u64 = 0;\n    fiat_p384_cmovznz_u64(&mut x473, x467, x464, x451);\n    out1[0] = x468;\n    out1[1] = x469;\n    out1[2] = x470;\n    out1[3] = x471;\n    out1[4] = x472;\n    out1[5] = x473;\n}",
    "display_name": "fiat_p384_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_from_bytes(out1: &mut [u64; 3], arg1: &[u8; 24]) {\n    let x1: u64 = (((arg1[23]) as u64) << 56);\n    let x2: u64 = (((arg1[22]) as u64) << 48);\n    let x3: u64 = (((arg1[21]) as u64) << 40);\n    let x4: u64 = (((arg1[20]) as u64) << 32);\n    let x5: u64 = (((arg1[19]) as u64) << 24);\n    let x6: u64 = (((arg1[18]) as u64) << 16);\n    let x7: u64 = (((arg1[17]) as u64) << 8);\n    let x8: u8 = (arg1[16]);\n    let x9: u64 = (((arg1[15]) as u64) << 56);\n    let x10: u64 = (((arg1[14]) as u64) << 48);\n    let x11: u64 = (((arg1[13]) as u64) << 40);\n    let x12: u64 = (((arg1[12]) as u64) << 32);\n    let x13: u64 = (((arg1[11]) as u64) << 24);\n    let x14: u64 = (((arg1[10]) as u64) << 16);\n    let x15: u64 = (((arg1[9]) as u64) << 8);\n    let x16: u8 = (arg1[8]);\n    let x17: u64 = (((arg1[7]) as u64) << 56);\n    let x18: u64 = (((arg1[6]) as u64) << 48);\n    let x19: u64 = (((arg1[5]) as u64) << 40);\n    let x20: u64 = (((arg1[4]) as u64) << 32);\n    let x21: u64 = (((arg1[3]) as u64) << 24);\n    let x22: u64 = (((arg1[2]) as u64) << 16);\n    let x23: u64 = (((arg1[1]) as u64) << 8);\n    let x24: u8 = (arg1[0]);\n    let x25: u64 = (x23 + (x24 as u64));\n    let x26: u64 = (x22 + x25);\n    let x27: u64 = (x21 + x26);\n    let x28: u64 = (x20 + x27);\n    let x29: u64 = (x19 + x28);\n    let x30: u64 = (x18 + x29);\n    let x31: u64 = (x17 + x30);\n    let x32: u64 = (x15 + (x16 as u64));\n    let x33: u64 = (x14 + x32);\n    let x34: u64 = (x13 + x33);\n    let x35: u64 = (x12 + x34);\n    let x36: u64 = (x11 + x35);\n    let x37: u64 = (x10 + x36);\n    let x38: u64 = (x9 + x37);\n    let x39: u64 = (x7 + (x8 as u64));\n    let x40: u64 = (x6 + x39);\n    let x41: u64 = (x5 + x40);\n    let x42: u64 = (x4 + x41);\n    let x43: u64 = (x3 + x42);\n    let x44: u64 = (x2 + x43);\n    let x45: u64 = (x1 + x44);\n    out1[0] = x31;\n    out1[1] = x38;\n    out1[2] = x45;\n}",
    "display_name": "fiat_p192_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_inner",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/impl/InnerSignature/TryFrom/try_from",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Group/is_identity",
      "0.14.0_pre.1 field/scalar/impl/Scalar/is_zero",
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order_wide",
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn verify_inner(\n        &self,\n        signature: &Signature,\n        phflag: u8,\n        ctx: &[u8],\n        m: &[u8],\n    ) -> Result<(), Error> {\n        // `signature` should already be valid but check to make sure\n        // Note that the scalar itself uses only 56 bytes; the extra\n        // 57th byte must be 0x00.\n        if signature.s_bytes()[56] != 0x00 {\n            return Err(SigningError::InvalidSignatureSComponent.into());\n        }\n        if self.point.is_identity().into() {\n            return Err(SigningError::InvalidPublicKeyBytes.into());\n        }\n\n        let inner_signature = InnerSignature::try_from(signature)?;\n        if inner_signature.r.is_identity().into() {\n            return Err(SigningError::InvalidSignatureRComponent.into());\n        }\n\n        if inner_signature.s.is_zero().into() {\n            return Err(SigningError::InvalidSignatureSComponent.into());\n        }\n\n        // SHAKE256(dom4(F, C) || R || A || PH(M), 114) -> scalar k\n        let mut bytes = WideScalarBytes::default();\n        let ctx_len = ctx.len() as u8;\n        let mut reader = Shake256::default()\n            .chain(HASH_HEAD)\n            .chain([phflag])\n            .chain([ctx_len])\n            .chain(ctx)\n            .chain(signature.r_bytes())\n            .chain(self.compressed.as_bytes())\n            .chain(m)\n            .finalize_xof();\n        reader.read(&mut bytes);\n        let k = Scalar::from_bytes_mod_order_wide(&bytes);\n        // Check the verification equation [S]B = R + [k]A.\n        let lhs = EdwardsPoint::GENERATOR * inner_signature.s;\n        let rhs = inner_signature.r + (self.point * k);\n        if lhs == rhs {\n            Ok(())\n        } else {\n            Err(SigningError::Verify.into())\n        }\n    }",
    "display_name": "verify_inner",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/s0",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    pub fn s0(&self) -> NonZeroScalar {\n        let mut s0 = self.s0.to_bytes();\n        s0.reverse();\n        NonZeroScalar::new(Scalar::from_bytes(&s0).unwrap()).unwrap()\n    }",
    "display_name": "s0",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64"
    ],
    "body": "pub const fn fiat_bign256_to_montgomery(\n    out1: &mut fiat_bign256_montgomery_domain_field_element,\n    arg1: &fiat_bign256_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x1, &mut x2, (arg1[0]), 0x8b89);\n    let mut x3: u64 = 0;\n    let mut x4: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x3, &mut x4, x1, 0xa53fa94fea53fa95);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x5, &mut x6, x3, 0xffffffffffffffff);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x7, &mut x8, x3, 0xffffffffffffffff);\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x9, &mut x10, x3, 0xffffffffffffffff);\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x11, &mut x12, x3, 0xffffffffffffff43);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let mut x19: u64 = 0;\n    let mut x20: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x19, &mut x20, 0x0, x1, x11);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x21, &mut x22, x20, x2, x13);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x23, &mut x24, x22, (0x0 as u64), x15);\n    let mut x25: u64 = 0;\n    let mut x26: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x25, &mut x26, x24, (0x0 as u64), x17);\n    let mut x27: u64 = 0;\n    let mut x28: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x27, &mut x28, x26, (0x0 as u64), ((x18 as u64) + x6));\n    let mut x29: u64 = 0;\n    let mut x30: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x29, &mut x30, (arg1[1]), 0x8b89);\n    let mut x31: u64 = 0;\n    let mut x32: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x31, &mut x32, 0x0, x21, x29);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x33, &mut x34, x32, x23, x30);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x35, &mut x36, x34, x25, (0x0 as u64));\n    let mut x37: u64 = 0;\n    let mut x38: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x37, &mut x38, x36, x27, (0x0 as u64));\n    let mut x39: u64 = 0;\n    let mut x40: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x39, &mut x40, x31, 0xa53fa94fea53fa95);\n    let mut x41: u64 = 0;\n    let mut x42: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x41, &mut x42, x39, 0xffffffffffffffff);\n    let mut x43: u64 = 0;\n    let mut x44: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x43, &mut x44, x39, 0xffffffffffffffff);\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x45, &mut x46, x39, 0xffffffffffffffff);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x47, &mut x48, x39, 0xffffffffffffff43);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x49, &mut x50, 0x0, x48, x45);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x51, &mut x52, x50, x46, x43);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x53, &mut x54, x52, x44, x41);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x55, &mut x56, 0x0, x31, x47);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x57, &mut x58, x56, x33, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x59, &mut x60, x58, x35, x51);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x61, &mut x62, x60, x37, x53);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(\n        &mut x63,\n        &mut x64,\n        x62,\n        ((x38 as u64) + (x28 as u64)),\n        ((x54 as u64) + x42),\n    );\n    let mut x65: u64 = 0;\n    let mut x66: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x65, &mut x66, (arg1[2]), 0x8b89);\n    let mut x67: u64 = 0;\n    let mut x68: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x67, &mut x68, 0x0, x57, x65);\n    let mut x69: u64 = 0;\n    let mut x70: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x69, &mut x70, x68, x59, x66);\n    let mut x71: u64 = 0;\n    let mut x72: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x71, &mut x72, x70, x61, (0x0 as u64));\n    let mut x73: u64 = 0;\n    let mut x74: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x73, &mut x74, x72, x63, (0x0 as u64));\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x75, &mut x76, x67, 0xa53fa94fea53fa95);\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x77, &mut x78, x75, 0xffffffffffffffff);\n    let mut x79: u64 = 0;\n    let mut x80: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x79, &mut x80, x75, 0xffffffffffffffff);\n    let mut x81: u64 = 0;\n    let mut x82: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x81, &mut x82, x75, 0xffffffffffffffff);\n    let mut x83: u64 = 0;\n    let mut x84: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x83, &mut x84, x75, 0xffffffffffffff43);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x85, &mut x86, 0x0, x84, x81);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x87, &mut x88, x86, x82, x79);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x89, &mut x90, x88, x80, x77);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x91, &mut x92, 0x0, x67, x83);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x93, &mut x94, x92, x69, x85);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x95, &mut x96, x94, x71, x87);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x97, &mut x98, x96, x73, x89);\n    let mut x99: u64 = 0;\n    let mut x100: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(\n        &mut x99,\n        &mut x100,\n        x98,\n        ((x74 as u64) + (x64 as u64)),\n        ((x90 as u64) + x78),\n    );\n    let mut x101: u64 = 0;\n    let mut x102: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x101, &mut x102, (arg1[3]), 0x8b89);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x103, &mut x104, 0x0, x93, x101);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x105, &mut x106, x104, x95, x102);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x107, &mut x108, x106, x97, (0x0 as u64));\n    let mut x109: u64 = 0;\n    let mut x110: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x109, &mut x110, x108, x99, (0x0 as u64));\n    let mut x111: u64 = 0;\n    let mut x112: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x111, &mut x112, x103, 0xa53fa94fea53fa95);\n    let mut x113: u64 = 0;\n    let mut x114: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x113, &mut x114, x111, 0xffffffffffffffff);\n    let mut x115: u64 = 0;\n    let mut x116: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x115, &mut x116, x111, 0xffffffffffffffff);\n    let mut x117: u64 = 0;\n    let mut x118: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x117, &mut x118, x111, 0xffffffffffffffff);\n    let mut x119: u64 = 0;\n    let mut x120: u64 = 0;\n    fiat_bign256_mulx_u64(&mut x119, &mut x120, x111, 0xffffffffffffff43);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x121, &mut x122, 0x0, x120, x117);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x123, &mut x124, x122, x118, x115);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x125, &mut x126, x124, x116, x113);\n    let mut x127: u64 = 0;\n    let mut x128: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x127, &mut x128, 0x0, x103, x119);\n    let mut x129: u64 = 0;\n    let mut x130: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x129, &mut x130, x128, x105, x121);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x131, &mut x132, x130, x107, x123);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x133, &mut x134, x132, x109, x125);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(\n        &mut x135,\n        &mut x136,\n        x134,\n        ((x110 as u64) + (x100 as u64)),\n        ((x126 as u64) + x114),\n    );\n    let mut x137: u64 = 0;\n    let mut x138: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x137, &mut x138, 0x0, x129, 0xffffffffffffff43);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x139, &mut x140, x138, x131, 0xffffffffffffffff);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x141, &mut x142, x140, x133, 0xffffffffffffffff);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x143, &mut x144, x142, x135, 0xffffffffffffffff);\n    let mut x145: u64 = 0;\n    let mut x146: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x145, &mut x146, x144, (x136 as u64), (0x0 as u64));\n    let mut x147: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x147, x146, x137, x129);\n    let mut x148: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x148, x146, x139, x131);\n    let mut x149: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x149, x146, x141, x133);\n    let mut x150: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x150, x146, x143, x135);\n    out1[0] = x147;\n    out1[1] = x148;\n    out1[2] = x149;\n    out1[3] = x150;\n}",
    "display_name": "fiat_bign256_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: &FieldElement) {\n        *self = *self - *other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_torsion_free",
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress_unchecked",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_on_curve"
    ],
    "body": "    pub fn decompress(&self) -> CtOption<EdwardsPoint> {\n        self.decompress_unchecked()\n            .and_then(|pt| CtOption::new(pt, pt.is_on_curve() & pt.is_torsion_free()))\n    }",
    "display_name": "decompress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre verify_test_vector",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/TryFrom/try_from",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/from_sec1_bytes",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/Verifier/verify"
    ],
    "body": "fn verify_test_vector() {\n    let vk = VerifyingKey::from_sec1_bytes(IDENTITY, &PUBLIC_KEY).unwrap();\n    let sig = Signature::try_from(&SIG).unwrap();\n    assert!(vk.verify(MSG, &sig).is_ok());\n}",
    "display_name": "verify_test_vector",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2dsa.rs",
    "relative_path": "sm2/tests/sm2dsa.rs",
    "file_name": "sm2dsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/impl/fiat_p521_scalar_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub(self, other: &Scalar) -> Scalar {\n        Scalar::sub(self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero"
    ],
    "body": "    fn reduce_nonzero_bytes(bytes: &Self::Bytes) -> Self {\n        Self::reduce_nonzero(U896::from_le_slice(bytes))\n    }",
    "display_name": "reduce_nonzero_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/square",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/pow_vartime"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        // Because n ≡ 3 mod 4 for SM2's scalar field modulus, sqrt can be done with only one\n        // exponentiation via the computation of self^((n + 1) // 4) (mod n).\n        let sqrt = self.pow_vartime(&[\n            0xd4eefd024e755049,\n            0xdc80f7dac871814a,\n            0xffffffffffffffff,\n            0x3fffffffbfffffff,\n        ]);\n        CtOption::new(sqrt, sqrt.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_p224_scalar_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_selectznz(\n    out1: &mut [u64; 4],\n    arg1: fiat_sm2_scalar_u1,\n    arg2: &[u64; 4],\n    arg3: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n}",
    "display_name": "fiat_sm2_scalar_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_field_element_square",
      "0.14.0_pre.8 bench_field_element_mul",
      "0.14.0_pre.8 bench_field_element_normalize_weak",
      "0.14.0_pre.8 bench_field_element_sqrt",
      "0.14.0_pre.8 bench_field_element_invert",
      "0.14.0_pre.8 bench_field_element_normalize"
    ],
    "body": "fn bench_field_element(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"field element operations\");\n    bench_field_element_normalize_weak(&mut group);\n    bench_field_element_normalize(&mut group);\n    bench_field_element_mul(&mut group);\n    bench_field_element_square(&mut group);\n    bench_field_element_invert(&mut group);\n    bench_field_element_sqrt(&mut group);\n    group.finish();\n}",
    "display_name": "bench_field_element",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_field_bytes(&self) -> Ed448FieldBytes {\n        let mut data = Ed448FieldBytes::default();\n        data.copy_from_slice(&self.to_le_byte_array()[..]);\n        data\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/lib.rs",
    "relative_path": "ed448-goldilocks/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/mul"
    ],
    "body": "    fn mul(self, other: &FieldElement) -> FieldElement {\n        FieldElement(self.0.mul(&(other.0)))\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 uncompressed_round_trip",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "affine/impl/AffinePoint/PrimeCurveAffine/generator"
    ],
    "body": "fn uncompressed_round_trip() {\n    let pubkey = EncodedPoint::from_bytes(UNCOMPRESSED_BASEPOINT).unwrap();\n    let point = AffinePoint::from_encoded_point(&pubkey).unwrap();\n    assert_eq!(point, AffinePoint::generator());\n\n    let res: EncodedPoint = point.into();\n    assert_eq!(res, pubkey);\n}",
    "display_name": "uncompressed_round_trip",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/new",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre secret_key/impl/SecretKey/to_nonzero_scalar",
      "0.14.0_pre ecdsa/signing/impl/SigningKey/from_nonzero_scalar"
    ],
    "body": "    pub fn new(secret_key: &SecretKey) -> Result<Self> {\n        Self::from_nonzero_scalar(secret_key.to_nonzero_scalar())\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero"
    ],
    "body": "    fn ct_eq(&self, other: &AffinePoint) -> Choice {\n        (self.x.negate(1) + &other.x).normalizes_to_zero()\n            & (self.y.negate(1) + &other.y).normalizes_to_zero()\n            & self.infinity.ct_eq(&other.infinity)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre bench_point_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
      "0.14.0_pre test_scalar_x"
    ],
    "body": "fn bench_point_mul<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let p = ProjectivePoint::GENERATOR;\n    let m = test_scalar_x();\n    let s = Scalar::from_repr(m.into()).unwrap();\n    group.bench_function(\"point-scalar mul\", |b| b.iter(|| p * s));\n}",
    "display_name": "bench_point_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/scalar.rs",
    "relative_path": "bign256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/r_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn r_bytes(&self) -> FieldBytes {\n        self.r.to_bytes()\n    }",
    "display_name": "r_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/tests/bip340_sign_vectors",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/to_bytes",
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/from_bytes",
      "0.14.0_pre.8 schnorr/impl/Signature/to_bytes",
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/verifying_key",
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/sign_raw"
    ],
    "body": "    fn bip340_sign_vectors() {\n        for vector in BIP340_SIGN_VECTORS {\n            let sk = SigningKey::from_bytes(&vector.secret_key).unwrap();\n            assert_eq!(sk.verifying_key().to_bytes().as_slice(), &vector.public_key);\n\n            let sig = sk\n                .sign_raw(&vector.message, &vector.aux_rand)\n                .unwrap_or_else(|_| {\n                    panic!(\n                        \"low-level Schnorr signing failure for index {}\",\n                        vector.index\n                    )\n                });\n\n            assert_eq!(\n                vector.signature,\n                sig.to_bytes(),\n                \"wrong signature for index {}\",\n                vector.index\n            );\n        }\n    }",
    "display_name": "bip340_sign_vectors",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/GroupEncoding/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/GroupEncoding/to_bytes",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        self.to_affine().to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/mul"
    ],
    "body": "    fn mul(self, other: &Scalar) -> Scalar {\n        Scalar::mul(self, other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/&ProjectivePoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/neg"
    ],
    "body": "    fn neg(self) -> ProjectivePoint<C> {\n        ProjectivePoint::neg(self)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/negate"
    ],
    "body": "    fn neg(self) -> Scalar {\n        self.negate()\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_raw",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_inner"
    ],
    "body": "    pub fn verify_raw(&self, signature: &Signature, message: &[u8]) -> Result<(), Error> {\n        self.verify_inner(signature, 0, &[], message)\n    }",
    "display_name": "verify_raw",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_zero",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert_unchecked"
    ],
    "body": "    pub fn invert(&self) -> CtOption<Self> {\n        CtOption::new(self.invert_unchecked(), !self.is_zero())\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/NonIdentity/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(point: ProjectivePoint) -> Result<Self> {\n        NonIdentity::new(point).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/AffinePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/as_affine"
    ],
    "body": "    fn from(vk: &VerifyingKey) -> AffinePoint {\n        *vk.as_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(a: u64) -> Self {\n        Scalar(U448::from_u64(a))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_add",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_add(\n    out1: &mut fiat_p521_loose_field_element,\n    arg1: &fiat_p521_tight_field_element,\n    arg2: &fiat_p521_tight_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = ((arg1[0]) + (arg2[0]));\n    let x2: u64 = ((arg1[1]) + (arg2[1]));\n    let x3: u64 = ((arg1[2]) + (arg2[2]));\n    let x4: u64 = ((arg1[3]) + (arg2[3]));\n    let x5: u64 = ((arg1[4]) + (arg2[4]));\n    let x6: u64 = ((arg1[5]) + (arg2[5]));\n    let x7: u64 = ((arg1[6]) + (arg2[6]));\n    let x8: u64 = ((arg1[7]) + (arg2[7]));\n    let x9: u64 = ((arg1[8]) + (arg2[8]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n    out1[4] = x5;\n    out1[5] = x6;\n    out1[6] = x7;\n    out1[7] = x8;\n    out1[8] = x9;\n}",
    "display_name": "fiat_p521_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/to_projective",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes"
    ],
    "body": "    pub fn to_projective(&self) -> ProjectiveMontgomeryPoint {\n        ProjectiveMontgomeryPoint {\n            U: FieldElement::from_bytes(&self.0),\n            W: FieldElement::ONE,\n        }\n    }",
    "display_name": "to_projective",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Self::IDENTITY, |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/ScalarPrimitive/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/ScalarPrimitive/From/from"
    ],
    "body": "    fn from(scalar: Scalar) -> ScalarPrimitive<Secp256k1> {\n        ScalarPrimitive::from(&scalar)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_mul"
    ],
    "body": "    pub const fn multiply(&self, rhs: &Self) -> Self {\n        let mut out = fiat_p521_scalar_montgomery_domain_field_element([0; 9]);\n        fiat_p521_scalar_mul(&mut out, &self.0, &rhs.0);\n        Self(out)\n    }",
    "display_name": "multiply",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64"
    ],
    "body": "pub const fn fiat_sm2_square(\n    out1: &mut fiat_sm2_montgomery_domain_field_element,\n    arg1: &fiat_sm2_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x5, &mut x6, x4, (arg1[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x7, &mut x8, x4, (arg1[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x9, &mut x10, x4, (arg1[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x11, &mut x12, x4, (arg1[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x20, &mut x21, x11, 0xfffffffeffffffff);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x22, &mut x23, x11, 0xffffffffffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x24, &mut x25, x11, 0xffffffff00000000);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x26, &mut x27, x11, 0xffffffffffffffff);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x28, &mut x29, 0x0, x27, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x30, &mut x31, x29, x25, x22);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x32, &mut x33, x31, x23, x20);\n    let x34: u64 = ((x33 as u64) + x21);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x35, &mut x36, 0x0, x11, x26);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x37, &mut x38, x36, x13, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x39, &mut x40, x38, x15, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x41, &mut x42, x40, x17, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x43, &mut x44, x42, x19, x34);\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x45, &mut x46, x1, (arg1[3]));\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x47, &mut x48, x1, (arg1[2]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x49, &mut x50, x1, (arg1[1]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x51, &mut x52, x1, (arg1[0]));\n    let mut x53: u64 = 0;\n    let mut x54: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x53, &mut x54, 0x0, x52, x49);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x55, &mut x56, x54, x50, x47);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x57, &mut x58, x56, x48, x45);\n    let x59: u64 = ((x58 as u64) + x46);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x60, &mut x61, 0x0, x37, x51);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x62, &mut x63, x61, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x68, &mut x69, x67, (x44 as u64), x59);\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x70, &mut x71, x60, 0xfffffffeffffffff);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x72, &mut x73, x60, 0xffffffffffffffff);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x74, &mut x75, x60, 0xffffffff00000000);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x76, &mut x77, x60, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x78, &mut x79, 0x0, x77, x74);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x80, &mut x81, x79, x75, x72);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x82, &mut x83, x81, x73, x70);\n    let x84: u64 = ((x83 as u64) + x71);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x85, &mut x86, 0x0, x60, x76);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x87, &mut x88, x86, x62, x78);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x89, &mut x90, x88, x64, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x91, &mut x92, x90, x66, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x93, &mut x94, x92, x68, x84);\n    let x95: u64 = ((x94 as u64) + (x69 as u64));\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x96, &mut x97, x2, (arg1[3]));\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x98, &mut x99, x2, (arg1[2]));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x100, &mut x101, x2, (arg1[1]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x102, &mut x103, x2, (arg1[0]));\n    let mut x104: u64 = 0;\n    let mut x105: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x104, &mut x105, 0x0, x103, x100);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x106, &mut x107, x105, x101, x98);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x108, &mut x109, x107, x99, x96);\n    let x110: u64 = ((x109 as u64) + x97);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x111, &mut x112, 0x0, x87, x102);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x113, &mut x114, x112, x89, x104);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x115, &mut x116, x114, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x121, &mut x122, x111, 0xfffffffeffffffff);\n    let mut x123: u64 = 0;\n    let mut x124: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x123, &mut x124, x111, 0xffffffffffffffff);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x125, &mut x126, x111, 0xffffffff00000000);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x127, &mut x128, x111, 0xffffffffffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x129, &mut x130, 0x0, x128, x125);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x131, &mut x132, x130, x126, x123);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x133, &mut x134, x132, x124, x121);\n    let x135: u64 = ((x134 as u64) + x122);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x136, &mut x137, 0x0, x111, x127);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x138, &mut x139, x137, x113, x129);\n    let mut x140: u64 = 0;\n    let mut x141: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x140, &mut x141, x139, x115, x131);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x142, &mut x143, x141, x117, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x144, &mut x145, x143, x119, x135);\n    let x146: u64 = ((x145 as u64) + (x120 as u64));\n    let mut x147: u64 = 0;\n    let mut x148: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x147, &mut x148, x3, (arg1[3]));\n    let mut x149: u64 = 0;\n    let mut x150: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x149, &mut x150, x3, (arg1[2]));\n    let mut x151: u64 = 0;\n    let mut x152: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x151, &mut x152, x3, (arg1[1]));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x153, &mut x154, x3, (arg1[0]));\n    let mut x155: u64 = 0;\n    let mut x156: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x155, &mut x156, 0x0, x154, x151);\n    let mut x157: u64 = 0;\n    let mut x158: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x157, &mut x158, x156, x152, x149);\n    let mut x159: u64 = 0;\n    let mut x160: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x159, &mut x160, x158, x150, x147);\n    let x161: u64 = ((x160 as u64) + x148);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x162, &mut x163, 0x0, x138, x153);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x164, &mut x165, x163, x140, x155);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x166, &mut x167, x165, x142, x157);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x168, &mut x169, x167, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x172, &mut x173, x162, 0xfffffffeffffffff);\n    let mut x174: u64 = 0;\n    let mut x175: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x174, &mut x175, x162, 0xffffffffffffffff);\n    let mut x176: u64 = 0;\n    let mut x177: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x176, &mut x177, x162, 0xffffffff00000000);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_sm2_mulx_u64(&mut x178, &mut x179, x162, 0xffffffffffffffff);\n    let mut x180: u64 = 0;\n    let mut x181: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x180, &mut x181, 0x0, x179, x176);\n    let mut x182: u64 = 0;\n    let mut x183: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x182, &mut x183, x181, x177, x174);\n    let mut x184: u64 = 0;\n    let mut x185: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x184, &mut x185, x183, x175, x172);\n    let x186: u64 = ((x185 as u64) + x173);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x187, &mut x188, 0x0, x162, x178);\n    let mut x189: u64 = 0;\n    let mut x190: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x189, &mut x190, x188, x164, x180);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x191, &mut x192, x190, x166, x182);\n    let mut x193: u64 = 0;\n    let mut x194: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x193, &mut x194, x192, x168, x184);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x195, &mut x196, x194, x170, x186);\n    let x197: u64 = ((x196 as u64) + (x171 as u64));\n    let mut x198: u64 = 0;\n    let mut x199: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x198, &mut x199, 0x0, x189, 0xffffffffffffffff);\n    let mut x200: u64 = 0;\n    let mut x201: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x200, &mut x201, x199, x191, 0xffffffff00000000);\n    let mut x202: u64 = 0;\n    let mut x203: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x202, &mut x203, x201, x193, 0xffffffffffffffff);\n    let mut x204: u64 = 0;\n    let mut x205: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x204, &mut x205, x203, x195, 0xfffffffeffffffff);\n    let mut x206: u64 = 0;\n    let mut x207: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x206, &mut x207, x205, x197, (0x0 as u64));\n    let mut x208: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x208, x207, x198, x189);\n    let mut x209: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x209, x207, x200, x191);\n    let mut x210: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x210, x207, x202, x193);\n    let mut x211: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x211, x207, x204, x195);\n    out1[0] = x208;\n    out1[1] = x209;\n    out1[2] = x210;\n    out1[3] = x211;\n}",
    "display_name": "fiat_sm2_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_inner",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress",
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes_mod_order_wide",
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn sign_inner(&self, phflag: u8, ctx: &[u8], m: &[u8]) -> Result<InnerSignature, SigningError> {\n        if ctx.len() > 255 {\n            return Err(SigningError::PrehashedContextLength);\n        }\n        // SHAKE256(dom4(F, C) || prefix || PH(M), 114) -> scalar r\n        let ctx_len = ctx.len() as u8;\n        let mut reader = Shake256::default()\n            .chain(HASH_HEAD)\n            .chain([phflag])\n            .chain([ctx_len])\n            .chain(ctx)\n            .chain(self.hash_prefix)\n            .chain(m)\n            .finalize_xof_reset();\n        let mut bytes = WideScalarBytes::default();\n        reader.read(&mut bytes);\n        let r = Scalar::from_bytes_mod_order_wide(&bytes);\n\n        // R = r*B\n        let big_r = EdwardsPoint::GENERATOR * r;\n        let compressed_r = big_r.compress();\n\n        // SHAKE256(dom4(F, C) || R || A || PH(M), 114) -> scalar k\n        reader = Shake256::default()\n            .chain(HASH_HEAD)\n            .chain([phflag])\n            .chain([ctx_len])\n            .chain(ctx)\n            .chain(compressed_r.as_bytes())\n            .chain(self.public_key.compressed.as_bytes())\n            .chain(m)\n            .finalize_xof();\n        reader.read(&mut bytes);\n        let k = Scalar::from_bytes_mod_order_wide(&bytes);\n        Ok(InnerSignature {\n            r: big_r,\n            s: r + k * self.scalar,\n        })\n    }",
    "display_name": "sign_inner",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/expanded.rs",
    "relative_path": "ed448-goldilocks/src/sign/expanded.rs",
    "file_name": "expanded.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize_weak",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/normalize_weak"
    ],
    "body": "    pub fn normalize_weak(&self) -> Self {\n        Self(self.0.normalize_weak())\n    }",
    "display_name": "normalize_weak",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(bytes.as_slice())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress"
    ],
    "body": "    fn from(value: &EdwardsPoint) -> Self {\n        value.compress().0.to_vec()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [],
    "body": "    fn product<I: Iterator<Item = &'a Scalar>>(iter: I) -> Self {\n        iter.copied().product()\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 sign/error/impl/ed448::Error/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(err: SigningError) -> Self {\n        signature::Error::from_source(err)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/error.rs",
    "relative_path": "ed448-goldilocks/src/sign/error.rs",
    "file_name": "error.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafAffinePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_affine"
    ],
    "body": "    fn from(point: DecafPoint) -> Self {\n        DecafAffinePoint(point.0.to_affine())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/ToEncodedPoint/to_encoded_point",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/as_affine"
    ],
    "body": "    fn to_encoded_point(&self, compress: bool) -> EncodedPoint {\n        self.as_affine().to_encoded_point(compress)\n    }",
    "display_name": "to_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_subborrowx_u58",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_subborrowx_u58(\n    out1: &mut u64,\n    out2: &mut fiat_p521_u1,\n    arg1: fiat_p521_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i64 = ((((((arg2 as i128) - (arg1 as i128)) as i64) as i128) - (arg3 as i128)) as i64);\n    let x2: fiat_p521_i1 = ((x1 >> 58) as fiat_p521_i1);\n    let x3: u64 = (((x1 as i128) & (0x3ffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p521_i2) - (x2 as fiat_p521_i2)) as fiat_p521_u1);\n}",
    "display_name": "fiat_p521_subborrowx_u58",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> Self::Repr {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsGeneric/PointArithmetic/add_mixed",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/is_identity"
    ],
    "body": "    fn add_mixed(lhs: &ProjectivePoint<C>, rhs: &AffinePoint<C>) -> ProjectivePoint<C> {\n        let b3 = C::EQUATION_B * C::FieldElement::from(3);\n\n        let t0 = lhs.x * rhs.x; // 1\n        let t1 = lhs.y * rhs.y; // 2\n        let t3 = rhs.x + rhs.y; // 3\n        let t4 = lhs.x + lhs.y; // 4\n        let t3 = t3 * t4; // 5\n        let t4 = t0 + t1; // 6\n        let t3 = t3 - t4; // 7\n        let t4 = rhs.x * lhs.z; // 8\n        let t4 = t4 + lhs.x; // 9\n        let t5 = rhs.y * lhs.z; // 10\n        let t5 = t5 + lhs.y; // 11\n        let z3 = C::EQUATION_A * t4; // 12\n        let x3 = b3 * lhs.z; // 13\n        let z3 = x3 + z3; // 14\n        let x3 = t1 - z3; // 15\n        let z3 = t1 + z3; // 16\n        let y3 = x3 * z3; // 17\n        let t1 = t0 + t0; // 18\n        let t1 = t1 + t0; // 19\n        let t2 = C::EQUATION_A * lhs.z; // 20\n        let t4 = b3 * t4; // 21\n        let t1 = t1 + t2; // 22\n        let t2 = t0 - t2; // 23\n        let t2 = C::EQUATION_A * t2; // 24\n        let t4 = t4 + t2; // 25\n        let t0 = t1 * t4; // 26\n        let y3 = y3 + t0; // 27\n        let t0 = t5 * t4; // 28\n        let x3 = t3 * x3; // 29\n        let x3 = x3 - t0; // 30\n        let t0 = t3 * t1; // 31\n        let z3 = t5 * z3; // 32\n        let z3 = z3 + t0; // 33\n\n        let mut ret = ProjectivePoint {\n            x: x3,\n            y: y3,\n            z: z3,\n        };\n        ret.conditional_assign(lhs, rhs.is_identity());\n        ret\n    }",
    "display_name": "add_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_set_one(out1: &mut fiat_p384_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0xffffffff00000001;\n    out1[1] = 0xffffffff;\n    out1[2] = (0x1 as u64);\n    out1[3] = (0x0 as u64);\n    out1[4] = (0x0 as u64);\n    out1[5] = (0x0 as u64);\n}",
    "display_name": "fiat_p384_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_mulx_u64"
    ],
    "body": "pub const fn fiat_p224_square(\n    out1: &mut fiat_p224_montgomery_domain_field_element,\n    arg1: &fiat_p224_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_p224_mulx_u64(&mut x5, &mut x6, x4, (arg1[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p224_mulx_u64(&mut x7, &mut x8, x4, (arg1[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p224_mulx_u64(&mut x9, &mut x10, x4, (arg1[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p224_mulx_u64(&mut x11, &mut x12, x4, (arg1[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p224_mulx_u64(&mut x20, &mut x21, x11, 0xffffffffffffffff);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_p224_mulx_u64(&mut x22, &mut x23, x20, 0xffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_p224_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p224_mulx_u64(&mut x26, &mut x27, x20, 0xffffffff00000000);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x28, &mut x29, 0x0, x27, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x30, &mut x31, x29, x25, x22);\n    let x32: u64 = ((x31 as u64) + x23);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x33, &mut x34, 0x0, x11, x20);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x35, &mut x36, x34, x13, x26);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x37, &mut x38, x36, x15, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x39, &mut x40, x38, x17, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x41, &mut x42, x40, x19, x32);\n    let mut x43: u64 = 0;\n    let mut x44: u64 = 0;\n    fiat_p224_mulx_u64(&mut x43, &mut x44, x1, (arg1[3]));\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_p224_mulx_u64(&mut x45, &mut x46, x1, (arg1[2]));\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_p224_mulx_u64(&mut x47, &mut x48, x1, (arg1[1]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_p224_mulx_u64(&mut x49, &mut x50, x1, (arg1[0]));\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x51, &mut x52, 0x0, x50, x47);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x53, &mut x54, x52, x48, x45);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x55, &mut x56, x54, x46, x43);\n    let x57: u64 = ((x56 as u64) + x44);\n    let mut x58: u64 = 0;\n    let mut x59: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x58, &mut x59, 0x0, x35, x49);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x60, &mut x61, x59, x37, x51);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x62, &mut x63, x61, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x66, &mut x67, x65, (x42 as u64), x57);\n    let mut x68: u64 = 0;\n    let mut x69: u64 = 0;\n    fiat_p224_mulx_u64(&mut x68, &mut x69, x58, 0xffffffffffffffff);\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_p224_mulx_u64(&mut x70, &mut x71, x68, 0xffffffff);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_p224_mulx_u64(&mut x72, &mut x73, x68, 0xffffffffffffffff);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_p224_mulx_u64(&mut x74, &mut x75, x68, 0xffffffff00000000);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x76, &mut x77, 0x0, x75, x72);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x78, &mut x79, x77, x73, x70);\n    let x80: u64 = ((x79 as u64) + x71);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x81, &mut x82, 0x0, x58, x68);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x83, &mut x84, x82, x60, x74);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x85, &mut x86, x84, x62, x76);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x87, &mut x88, x86, x64, x78);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x89, &mut x90, x88, x66, x80);\n    let x91: u64 = ((x90 as u64) + (x67 as u64));\n    let mut x92: u64 = 0;\n    let mut x93: u64 = 0;\n    fiat_p224_mulx_u64(&mut x92, &mut x93, x2, (arg1[3]));\n    let mut x94: u64 = 0;\n    let mut x95: u64 = 0;\n    fiat_p224_mulx_u64(&mut x94, &mut x95, x2, (arg1[2]));\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_p224_mulx_u64(&mut x96, &mut x97, x2, (arg1[1]));\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_p224_mulx_u64(&mut x98, &mut x99, x2, (arg1[0]));\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x100, &mut x101, 0x0, x99, x96);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x102, &mut x103, x101, x97, x94);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x104, &mut x105, x103, x95, x92);\n    let x106: u64 = ((x105 as u64) + x93);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x107, &mut x108, 0x0, x83, x98);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x109, &mut x110, x108, x85, x100);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x111, &mut x112, x110, x87, x102);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x113, &mut x114, x112, x89, x104);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x115, &mut x116, x114, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: u64 = 0;\n    fiat_p224_mulx_u64(&mut x117, &mut x118, x107, 0xffffffffffffffff);\n    let mut x119: u64 = 0;\n    let mut x120: u64 = 0;\n    fiat_p224_mulx_u64(&mut x119, &mut x120, x117, 0xffffffff);\n    let mut x121: u64 = 0;\n    let mut x122: u64 = 0;\n    fiat_p224_mulx_u64(&mut x121, &mut x122, x117, 0xffffffffffffffff);\n    let mut x123: u64 = 0;\n    let mut x124: u64 = 0;\n    fiat_p224_mulx_u64(&mut x123, &mut x124, x117, 0xffffffff00000000);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x125, &mut x126, 0x0, x124, x121);\n    let mut x127: u64 = 0;\n    let mut x128: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x127, &mut x128, x126, x122, x119);\n    let x129: u64 = ((x128 as u64) + x120);\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x130, &mut x131, 0x0, x107, x117);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x132, &mut x133, x131, x109, x123);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x134, &mut x135, x133, x111, x125);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x136, &mut x137, x135, x113, x127);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x138, &mut x139, x137, x115, x129);\n    let x140: u64 = ((x139 as u64) + (x116 as u64));\n    let mut x141: u64 = 0;\n    let mut x142: u64 = 0;\n    fiat_p224_mulx_u64(&mut x141, &mut x142, x3, (arg1[3]));\n    let mut x143: u64 = 0;\n    let mut x144: u64 = 0;\n    fiat_p224_mulx_u64(&mut x143, &mut x144, x3, (arg1[2]));\n    let mut x145: u64 = 0;\n    let mut x146: u64 = 0;\n    fiat_p224_mulx_u64(&mut x145, &mut x146, x3, (arg1[1]));\n    let mut x147: u64 = 0;\n    let mut x148: u64 = 0;\n    fiat_p224_mulx_u64(&mut x147, &mut x148, x3, (arg1[0]));\n    let mut x149: u64 = 0;\n    let mut x150: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x149, &mut x150, 0x0, x148, x145);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x151, &mut x152, x150, x146, x143);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x153, &mut x154, x152, x144, x141);\n    let x155: u64 = ((x154 as u64) + x142);\n    let mut x156: u64 = 0;\n    let mut x157: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x156, &mut x157, 0x0, x132, x147);\n    let mut x158: u64 = 0;\n    let mut x159: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x158, &mut x159, x157, x134, x149);\n    let mut x160: u64 = 0;\n    let mut x161: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x160, &mut x161, x159, x136, x151);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x162, &mut x163, x161, x138, x153);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x164, &mut x165, x163, x140, x155);\n    let mut x166: u64 = 0;\n    let mut x167: u64 = 0;\n    fiat_p224_mulx_u64(&mut x166, &mut x167, x156, 0xffffffffffffffff);\n    let mut x168: u64 = 0;\n    let mut x169: u64 = 0;\n    fiat_p224_mulx_u64(&mut x168, &mut x169, x166, 0xffffffff);\n    let mut x170: u64 = 0;\n    let mut x171: u64 = 0;\n    fiat_p224_mulx_u64(&mut x170, &mut x171, x166, 0xffffffffffffffff);\n    let mut x172: u64 = 0;\n    let mut x173: u64 = 0;\n    fiat_p224_mulx_u64(&mut x172, &mut x173, x166, 0xffffffff00000000);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x174, &mut x175, 0x0, x173, x170);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x176, &mut x177, x175, x171, x168);\n    let x178: u64 = ((x177 as u64) + x169);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x179, &mut x180, 0x0, x156, x166);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x181, &mut x182, x180, x158, x172);\n    let mut x183: u64 = 0;\n    let mut x184: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x183, &mut x184, x182, x160, x174);\n    let mut x185: u64 = 0;\n    let mut x186: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x185, &mut x186, x184, x162, x176);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x187, &mut x188, x186, x164, x178);\n    let x189: u64 = ((x188 as u64) + (x165 as u64));\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x190, &mut x191, 0x0, x181, (0x1 as u64));\n    let mut x192: u64 = 0;\n    let mut x193: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x192, &mut x193, x191, x183, 0xffffffff00000000);\n    let mut x194: u64 = 0;\n    let mut x195: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x194, &mut x195, x193, x185, 0xffffffffffffffff);\n    let mut x196: u64 = 0;\n    let mut x197: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x196, &mut x197, x195, x187, 0xffffffff);\n    let mut x198: u64 = 0;\n    let mut x199: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x198, &mut x199, x197, x189, (0x0 as u64));\n    let mut x200: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x200, x199, x190, x181);\n    let mut x201: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x201, x199, x192, x183);\n    let mut x202: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x202, x199, x194, x185);\n    let mut x203: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x203, x199, x196, x187);\n    out1[0] = x200;\n    out1[1] = x201;\n    out1[2] = x202;\n    out1[3] = x203;\n}",
    "display_name": "fiat_p224_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_from_bytes(out1: &mut [u64; 4], arg1: &[u8; 32]) {\n    let x1: u64 = (((arg1[31]) as u64) << 56);\n    let x2: u64 = (((arg1[30]) as u64) << 48);\n    let x3: u64 = (((arg1[29]) as u64) << 40);\n    let x4: u64 = (((arg1[28]) as u64) << 32);\n    let x5: u64 = (((arg1[27]) as u64) << 24);\n    let x6: u64 = (((arg1[26]) as u64) << 16);\n    let x7: u64 = (((arg1[25]) as u64) << 8);\n    let x8: u8 = (arg1[24]);\n    let x9: u64 = (((arg1[23]) as u64) << 56);\n    let x10: u64 = (((arg1[22]) as u64) << 48);\n    let x11: u64 = (((arg1[21]) as u64) << 40);\n    let x12: u64 = (((arg1[20]) as u64) << 32);\n    let x13: u64 = (((arg1[19]) as u64) << 24);\n    let x14: u64 = (((arg1[18]) as u64) << 16);\n    let x15: u64 = (((arg1[17]) as u64) << 8);\n    let x16: u8 = (arg1[16]);\n    let x17: u64 = (((arg1[15]) as u64) << 56);\n    let x18: u64 = (((arg1[14]) as u64) << 48);\n    let x19: u64 = (((arg1[13]) as u64) << 40);\n    let x20: u64 = (((arg1[12]) as u64) << 32);\n    let x21: u64 = (((arg1[11]) as u64) << 24);\n    let x22: u64 = (((arg1[10]) as u64) << 16);\n    let x23: u64 = (((arg1[9]) as u64) << 8);\n    let x24: u8 = (arg1[8]);\n    let x25: u64 = (((arg1[7]) as u64) << 56);\n    let x26: u64 = (((arg1[6]) as u64) << 48);\n    let x27: u64 = (((arg1[5]) as u64) << 40);\n    let x28: u64 = (((arg1[4]) as u64) << 32);\n    let x29: u64 = (((arg1[3]) as u64) << 24);\n    let x30: u64 = (((arg1[2]) as u64) << 16);\n    let x31: u64 = (((arg1[1]) as u64) << 8);\n    let x32: u8 = (arg1[0]);\n    let x33: u64 = (x31 + (x32 as u64));\n    let x34: u64 = (x30 + x33);\n    let x35: u64 = (x29 + x34);\n    let x36: u64 = (x28 + x35);\n    let x37: u64 = (x27 + x36);\n    let x38: u64 = (x26 + x37);\n    let x39: u64 = (x25 + x38);\n    let x40: u64 = (x23 + (x24 as u64));\n    let x41: u64 = (x22 + x40);\n    let x42: u64 = (x21 + x41);\n    let x43: u64 = (x20 + x42);\n    let x44: u64 = (x19 + x43);\n    let x45: u64 = (x18 + x44);\n    let x46: u64 = (x17 + x45);\n    let x47: u64 = (x15 + (x16 as u64));\n    let x48: u64 = (x14 + x47);\n    let x49: u64 = (x13 + x48);\n    let x50: u64 = (x12 + x49);\n    let x51: u64 = (x11 + x50);\n    let x52: u64 = (x10 + x51);\n    let x53: u64 = (x9 + x52);\n    let x54: u64 = (x7 + (x8 as u64));\n    let x55: u64 = (x6 + x54);\n    let x56: u64 = (x5 + x55);\n    let x57: u64 = (x4 + x56);\n    let x58: u64 = (x3 + x57);\n    let x59: u64 = (x2 + x58);\n    let x60: u64 = (x1 + x59);\n    out1[0] = x39;\n    out1[1] = x46;\n    out1[2] = x53;\n    out1[3] = x60;\n}",
    "display_name": "fiat_sm2_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn reduce(w: U192) -> Self {\n        let (r, underflow) = w.borrowing_sub(&NistP192::ORDER, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self::from_uint_unchecked(U192::conditional_select(&w, &r, !underflow))\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/EphemeralSecret/diffie_hellman",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdh/diffie_hellman",
      "0.14.0_pre public_key/impl/PublicKey/as_affine"
    ],
    "body": "    pub fn diffie_hellman(&self, public_key: &PublicKey) -> SharedSecret {\n        diffie_hellman(self.scalar, public_key.as_affine())\n    }",
    "display_name": "diffie_hellman",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectivePoint {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n            z: FieldElement::conditional_select(&a.z, &b.z, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 test_field_element_y",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_field_element_y() -> FieldElement {\n    FieldElement::from_bytes(\n        hex!(\"ce4014c68811f9a21a1fdb2c0e6113e06db7ca93b7404e78dc7ccd5ca89a4ca9\").as_ref(),\n    )\n    .unwrap()\n}",
    "display_name": "test_field_element_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/field.rs",
    "relative_path": "p256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre dsa/impl//u8; _//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/to_bytes"
    ],
    "body": "    fn from(signature: &Signature) -> SignatureBytes {\n        signature.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/normalize/s_low",
    "statement_type": "function",
    "deps": [],
    "body": "        fn s_low() {\n            #[rustfmt::skip]\n            let sig = Signature::try_from([\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ].as_slice()).unwrap();\n\n            assert_eq!(sig.normalize_s(), sig);\n        }",
    "display_name": "s_low",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/ecdsa.rs",
    "relative_path": "k256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        write!(f, \"VerifyingKey({:?}), {:?}\", self.compressed, self.point)\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: DecafPoint) {\n        *self = *self - other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            self.to_public_key_pem(Default::default())\n                .expect(\"PEM encoding error\")\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Product/product",
    "statement_type": "function",
    "deps": [],
    "body": "    fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        iter.copied().product()\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt"
    ],
    "body": "    fn sqrt() {\n        let one = FieldElement::ONE;\n        let two = one + &one;\n        let four = two.square();\n        assert_eq!(four.sqrt().unwrap(), two);\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, other: &Scalar) {\n        *self = *self * other;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_addcarryx_u58",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_addcarryx_u58(\n    out1: &mut u64,\n    out2: &mut fiat_p521_u1,\n    arg1: fiat_p521_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u64 = (((arg1 as u64) + arg2) + arg3);\n    let x2: u64 = (x1 & 0x3ffffffffffffff);\n    let x3: fiat_p521_u1 = ((x1 >> 58) as fiat_p521_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p521_addcarryx_u58",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/root_of_unity_inv_constant",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn root_of_unity_inv_constant() {\n        assert_eq!(\n            (FieldElement::ROOT_OF_UNITY * FieldElement::ROOT_OF_UNITY_INV).normalize(),\n            FieldElement::ONE\n        );\n    }",
    "display_name": "root_of_unity_inv_constant",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_from_bytes(out1: &mut [u64; 6], arg1: &[u8; 48]) {\n    let x1: u64 = (((arg1[47]) as u64) << 56);\n    let x2: u64 = (((arg1[46]) as u64) << 48);\n    let x3: u64 = (((arg1[45]) as u64) << 40);\n    let x4: u64 = (((arg1[44]) as u64) << 32);\n    let x5: u64 = (((arg1[43]) as u64) << 24);\n    let x6: u64 = (((arg1[42]) as u64) << 16);\n    let x7: u64 = (((arg1[41]) as u64) << 8);\n    let x8: u8 = (arg1[40]);\n    let x9: u64 = (((arg1[39]) as u64) << 56);\n    let x10: u64 = (((arg1[38]) as u64) << 48);\n    let x11: u64 = (((arg1[37]) as u64) << 40);\n    let x12: u64 = (((arg1[36]) as u64) << 32);\n    let x13: u64 = (((arg1[35]) as u64) << 24);\n    let x14: u64 = (((arg1[34]) as u64) << 16);\n    let x15: u64 = (((arg1[33]) as u64) << 8);\n    let x16: u8 = (arg1[32]);\n    let x17: u64 = (((arg1[31]) as u64) << 56);\n    let x18: u64 = (((arg1[30]) as u64) << 48);\n    let x19: u64 = (((arg1[29]) as u64) << 40);\n    let x20: u64 = (((arg1[28]) as u64) << 32);\n    let x21: u64 = (((arg1[27]) as u64) << 24);\n    let x22: u64 = (((arg1[26]) as u64) << 16);\n    let x23: u64 = (((arg1[25]) as u64) << 8);\n    let x24: u8 = (arg1[24]);\n    let x25: u64 = (((arg1[23]) as u64) << 56);\n    let x26: u64 = (((arg1[22]) as u64) << 48);\n    let x27: u64 = (((arg1[21]) as u64) << 40);\n    let x28: u64 = (((arg1[20]) as u64) << 32);\n    let x29: u64 = (((arg1[19]) as u64) << 24);\n    let x30: u64 = (((arg1[18]) as u64) << 16);\n    let x31: u64 = (((arg1[17]) as u64) << 8);\n    let x32: u8 = (arg1[16]);\n    let x33: u64 = (((arg1[15]) as u64) << 56);\n    let x34: u64 = (((arg1[14]) as u64) << 48);\n    let x35: u64 = (((arg1[13]) as u64) << 40);\n    let x36: u64 = (((arg1[12]) as u64) << 32);\n    let x37: u64 = (((arg1[11]) as u64) << 24);\n    let x38: u64 = (((arg1[10]) as u64) << 16);\n    let x39: u64 = (((arg1[9]) as u64) << 8);\n    let x40: u8 = (arg1[8]);\n    let x41: u64 = (((arg1[7]) as u64) << 56);\n    let x42: u64 = (((arg1[6]) as u64) << 48);\n    let x43: u64 = (((arg1[5]) as u64) << 40);\n    let x44: u64 = (((arg1[4]) as u64) << 32);\n    let x45: u64 = (((arg1[3]) as u64) << 24);\n    let x46: u64 = (((arg1[2]) as u64) << 16);\n    let x47: u64 = (((arg1[1]) as u64) << 8);\n    let x48: u8 = (arg1[0]);\n    let x49: u64 = (x47 + (x48 as u64));\n    let x50: u64 = (x46 + x49);\n    let x51: u64 = (x45 + x50);\n    let x52: u64 = (x44 + x51);\n    let x53: u64 = (x43 + x52);\n    let x54: u64 = (x42 + x53);\n    let x55: u64 = (x41 + x54);\n    let x56: u64 = (x39 + (x40 as u64));\n    let x57: u64 = (x38 + x56);\n    let x58: u64 = (x37 + x57);\n    let x59: u64 = (x36 + x58);\n    let x60: u64 = (x35 + x59);\n    let x61: u64 = (x34 + x60);\n    let x62: u64 = (x33 + x61);\n    let x63: u64 = (x31 + (x32 as u64));\n    let x64: u64 = (x30 + x63);\n    let x65: u64 = (x29 + x64);\n    let x66: u64 = (x28 + x65);\n    let x67: u64 = (x27 + x66);\n    let x68: u64 = (x26 + x67);\n    let x69: u64 = (x25 + x68);\n    let x70: u64 = (x23 + (x24 as u64));\n    let x71: u64 = (x22 + x70);\n    let x72: u64 = (x21 + x71);\n    let x73: u64 = (x20 + x72);\n    let x74: u64 = (x19 + x73);\n    let x75: u64 = (x18 + x74);\n    let x76: u64 = (x17 + x75);\n    let x77: u64 = (x15 + (x16 as u64));\n    let x78: u64 = (x14 + x77);\n    let x79: u64 = (x13 + x78);\n    let x80: u64 = (x12 + x79);\n    let x81: u64 = (x11 + x80);\n    let x82: u64 = (x10 + x81);\n    let x83: u64 = (x9 + x82);\n    let x84: u64 = (x7 + (x8 as u64));\n    let x85: u64 = (x6 + x84);\n    let x86: u64 = (x5 + x85);\n    let x87: u64 = (x4 + x86);\n    let x88: u64 = (x3 + x87);\n    let x89: u64 = (x2 + x88);\n    let x90: u64 = (x1 + x89);\n    out1[0] = x55;\n    out1[1] = x62;\n    out1[2] = x69;\n    out1[3] = x76;\n    out1[4] = x83;\n    out1[5] = x90;\n}",
    "display_name": "fiat_p384_scalar_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/PreHasherXof/PreHash/fill_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fill_bytes(&mut self, out: &mut [u8]) {\n        self.reader.read(out);\n    }",
    "display_name": "fill_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Scalar) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0.as_mut_words()[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/signing/impl/SigningKey/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &SigningKey) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> AffinePoint {\n        AffinePoint::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: KeypairBytes) -> Result<Self, Self::Error> {\n        Self::try_from(&value)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/EncodedPoint::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn from(affine_point: &AffinePoint) -> EncodedPoint {\n        affine_point.to_encoded_point(true)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/generate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve"
    ],
    "body": "    pub fn generate<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        let mut secret_scalar = SecretKey::default();\n        rng.fill_bytes(secret_scalar.as_mut());\n        assert!(!secret_scalar.iter().all(|&v| v == 0));\n        Self {\n            secret: ExpandedSecretKey::from(&secret_scalar),\n        }\n    }",
    "display_name": "generate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 ristretto/points/impl/CompressedRistretto/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn identity() -> CompressedRistretto {\n        CompressedRistretto([0; 56])\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/ristretto/points.rs",
    "relative_path": "ed448-goldilocks/src/ristretto/points.rs",
    "file_name": "points.rs",
    "parent_folder": "ristretto"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/rfc6979",
    "statement_type": "function",
    "deps": [],
    "body": "    fn rfc6979() {\n        let x = hex!(\n            \"00FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\"\n        );\n        let signer = SigningKey::from_bytes(&x.into()).unwrap();\n        let signature: Signature = signer.sign(b\"sample\");\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"00C328FAFCBD79DD77850370C46325D987CB525569FB63C5D3BC53950E6D4C5F174E25A1EE9017B5D450606ADD152B534931D7D4E8455CC91F9B15BF05EC36E377FA\"\n                \"00617CCE7CF5064806C467F678D3B4080D6F1CC50AF26CA209417308281B68AF282623EAA63E5B5C0723D8B8C37FF0777B1A20F8CCB1DCCC43997F1EE0E44DA4A67A\"\n            )\n        );\n    }",
    "display_name": "rfc6979",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/ecdsa.rs",
    "relative_path": "p521/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &DecafPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl//u8; 57//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl//u8; 57//From/from"
    ],
    "body": "    fn from(value: &CompressedEdwardsY) -> Self {\n        Self::from(*value)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, other: &FieldElement) {\n        *self = *self * other;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [],
    "body": "    fn is_high(&self) -> Choice {\n        self.0.ct_gt(&FRAC_MODULUS_2)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&DecafPoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended"
    ],
    "body": "    fn add(self, other: &DecafPoint) -> DecafPoint {\n        DecafPoint(self.0.to_extensible().add_extended(&other.0).to_extended())\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_projective_niels",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn add_projective_niels(&self, other: &ProjectiveNielsPoint) -> ExtensiblePoint {\n        // This is the only step which makes it different than adding an AffineNielsPoint\n        let Z = self.Z * other.Z;\n\n        let A = (self.Y - self.X) * other.Y_minus_X;\n        let B = (self.Y + self.X) * other.Y_plus_X;\n        let C = other.Td * self.T1 * self.T2;\n        let D = B + A;\n        let E = B - A;\n        let F = Z - C;\n        let G = Z + C;\n        ExtensiblePoint {\n            X: E * F,\n            Y: G * D,\n            Z: F * G,\n            T1: E,\n            T2: D,\n        }\n    }",
    "display_name": "add_projective_niels",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&AffinePoint/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, other: &EdwardsPoint) -> EdwardsPoint {\n        *other + *self\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_msat(out1: &mut [u64; 5]) {\n    out1[0] = 0xffffffffffffff43;\n    out1[1] = 0xffffffffffffffff;\n    out1[2] = 0xffffffffffffffff;\n    out1[3] = 0xffffffffffffffff;\n    out1[4] = (0x0 as u64);\n}",
    "display_name": "fiat_bign256_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: &Scalar) {\n        *self = *self - other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_x() -> Scalar {\n    Scalar::from_repr(\n        hex!(\"201b432d8df14324182d6261db3e4b3f46a8284482d52e370da41e6cbdf45ec2952f5db7ccbce3bc29449f4fb080ac97\").into()\n    ).unwrap()\n}",
    "display_name": "test_scalar_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/sqrt_ratio",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/from_bytes_unchecked",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_u64"
    ],
    "body": "    fn sqrt_ratio(num: &Self, div: &Self) -> (Choice, Self) {\n        ff::helpers::sqrt_ratio_generic(num, div)\n    }",
    "display_name": "sqrt_ratio",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl//u8; 56//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl//u8; 56//From/from"
    ],
    "body": "    fn from(compressed: &CompressedDecaf) -> DecafPointBytes {\n        Self::from(*compressed)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_raw"
    ],
    "body": "    fn verify(&self, msg: &[u8], signature: &Signature) -> Result<(), Error> {\n        self.secret.public_key.verify_raw(signature, msg)\n    }",
    "display_name": "verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_cmovznz_u64(out1: &mut u64, arg1: fiat_p521_u1, arg2: u64, arg3: u64) {\n    let x1: fiat_p521_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_p521_i2) - (x1 as fiat_p521_i2)) as fiat_p521_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_p521_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub(self, other: &Scalar) -> Scalar {\n        Scalar::sub(&self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/mul"
    ],
    "body": "    fn mul(self, other: &Scalar) -> ProjectivePoint {\n        mul(&self, other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/DigestVerifier/verify_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_inner"
    ],
    "body": "    fn verify_digest(&self, digest: D, signature: &Signature) -> Result<(), Error> {\n        let mut prehashed_message = [0u8; 64];\n        prehashed_message.copy_from_slice(digest.finalize().as_slice());\n        self.verify_inner(signature, 1, &[], &prehashed_message)\n    }",
    "display_name": "verify_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/tests/test_point_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/double",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/negate",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/sub_extended",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended"
    ],
    "body": "    fn test_point_sub() {\n        let a = TWISTED_EDWARDS_BASE_POINT;\n        let b = a.double();\n\n        // A - B = C\n        let c_1 = a.to_extensible().sub_extended(&b).to_extended();\n\n        // -B + A = C\n        let c_2 = b.negate().to_extensible().add_extended(&a).to_extended();\n        assert!(c_1 == c_2);\n    }",
    "display_name": "test_point_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        let a = self.to_bytes();\n        let b = other.to_bytes();\n        a.ct_eq(&b)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/invert",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn invert(&self) -> Self {\n        const INV_EXP: U448 = U448::from_be_hex(\n            \"fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffffffffffffffffffffffffffffffffffffffffffffffffffffd\",\n        );\n        Self(self.0.pow(&INV_EXP))\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/tests/compressed_round_trip",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn compressed_round_trip() {\n        let pubkey = EncodedPoint::from_bytes(COMPRESSED_BASEPOINT).unwrap();\n        let res: EncodedPoint = AffinePoint::from_encoded_point(&pubkey)\n            .unwrap()\n            .to_encoded_point(true);\n\n        assert_eq!(res, pubkey);\n    }",
    "display_name": "compressed_round_trip",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_divstep_precomp(out1: &mut [u64; 9]) {\n    out1[0] = 0x7b27a0cb33d1884b;\n    out1[1] = 0x9ef6cb011f2467d8;\n    out1[2] = 0x5fbc88e1d6e7fce;\n    out1[3] = 0xb08222d0fe97e1dc;\n    out1[4] = 0x1624870c44df3fce;\n    out1[5] = 0xb7f07b8eedbce602;\n    out1[6] = 0x62da93cf721f63bc;\n    out1[7] = 0xafd209c16c4f0d20;\n    out1[8] = 0x1c7;\n}",
    "display_name": "fiat_p521_scalar_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> SignatureBytes {\n        let mut ret = [0; Self::BYTE_SIZE];\n        let (r_bytes, s_bytes) = ret.split_at_mut(Self::BYTE_SIZE / 2);\n        r_bytes.copy_from_slice(&self.r.to_bytes());\n        s_bytes.copy_from_slice(&self.s.to_bytes());\n        ret\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_set_one(out1: &mut fiat_p192_scalar_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0xeb94364e4b2dd7cf;\n    out1[1] = 0x662107c9;\n    out1[2] = (0x0 as u64);\n}",
    "display_name": "fiat_p192_scalar_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p192_square(\n    out1: &mut fiat_p192_montgomery_domain_field_element,\n    arg1: &fiat_p192_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[0]);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p192_mulx_u64(&mut x4, &mut x5, x3, (arg1[2]));\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p192_mulx_u64(&mut x6, &mut x7, x3, (arg1[1]));\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p192_mulx_u64(&mut x8, &mut x9, x3, (arg1[0]));\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x10, &mut x11, 0x0, x9, x6);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x12, &mut x13, x11, x7, x4);\n    let x14: u64 = ((x13 as u64) + x5);\n    let mut x15: u64 = 0;\n    let mut x16: u64 = 0;\n    fiat_p192_mulx_u64(&mut x15, &mut x16, x8, 0xffffffffffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: u64 = 0;\n    fiat_p192_mulx_u64(&mut x17, &mut x18, x8, 0xfffffffffffffffe);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_p192_mulx_u64(&mut x19, &mut x20, x8, 0xffffffffffffffff);\n    let mut x21: u64 = 0;\n    let mut x22: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x21, &mut x22, 0x0, x20, x17);\n    let mut x23: u64 = 0;\n    let mut x24: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x23, &mut x24, x22, x18, x15);\n    let x25: u64 = ((x24 as u64) + x16);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x26, &mut x27, 0x0, x8, x19);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x28, &mut x29, x27, x10, x21);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x30, &mut x31, x29, x12, x23);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x32, &mut x33, x31, x14, x25);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p192_mulx_u64(&mut x34, &mut x35, x1, (arg1[2]));\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p192_mulx_u64(&mut x36, &mut x37, x1, (arg1[1]));\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p192_mulx_u64(&mut x38, &mut x39, x1, (arg1[0]));\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x40, &mut x41, 0x0, x39, x36);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x42, &mut x43, x41, x37, x34);\n    let x44: u64 = ((x43 as u64) + x35);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x45, &mut x46, 0x0, x28, x38);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x47, &mut x48, x46, x30, x40);\n    let mut x49: u64 = 0;\n    let mut x50: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x49, &mut x50, x48, x32, x42);\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x51, &mut x52, x50, (x33 as u64), x44);\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_p192_mulx_u64(&mut x53, &mut x54, x45, 0xffffffffffffffff);\n    let mut x55: u64 = 0;\n    let mut x56: u64 = 0;\n    fiat_p192_mulx_u64(&mut x55, &mut x56, x45, 0xfffffffffffffffe);\n    let mut x57: u64 = 0;\n    let mut x58: u64 = 0;\n    fiat_p192_mulx_u64(&mut x57, &mut x58, x45, 0xffffffffffffffff);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x59, &mut x60, 0x0, x58, x55);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x61, &mut x62, x60, x56, x53);\n    let x63: u64 = ((x62 as u64) + x54);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x64, &mut x65, 0x0, x45, x57);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x66, &mut x67, x65, x47, x59);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x68, &mut x69, x67, x49, x61);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x70, &mut x71, x69, x51, x63);\n    let x72: u64 = ((x71 as u64) + (x52 as u64));\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_p192_mulx_u64(&mut x73, &mut x74, x2, (arg1[2]));\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_p192_mulx_u64(&mut x75, &mut x76, x2, (arg1[1]));\n    let mut x77: u64 = 0;\n    let mut x78: u64 = 0;\n    fiat_p192_mulx_u64(&mut x77, &mut x78, x2, (arg1[0]));\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x79, &mut x80, 0x0, x78, x75);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x81, &mut x82, x80, x76, x73);\n    let x83: u64 = ((x82 as u64) + x74);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x84, &mut x85, 0x0, x66, x77);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x86, &mut x87, x85, x68, x79);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x88, &mut x89, x87, x70, x81);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x90, &mut x91, x89, x72, x83);\n    let mut x92: u64 = 0;\n    let mut x93: u64 = 0;\n    fiat_p192_mulx_u64(&mut x92, &mut x93, x84, 0xffffffffffffffff);\n    let mut x94: u64 = 0;\n    let mut x95: u64 = 0;\n    fiat_p192_mulx_u64(&mut x94, &mut x95, x84, 0xfffffffffffffffe);\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_p192_mulx_u64(&mut x96, &mut x97, x84, 0xffffffffffffffff);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x98, &mut x99, 0x0, x97, x94);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x100, &mut x101, x99, x95, x92);\n    let x102: u64 = ((x101 as u64) + x93);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x103, &mut x104, 0x0, x84, x96);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x105, &mut x106, x104, x86, x98);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x107, &mut x108, x106, x88, x100);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x109, &mut x110, x108, x90, x102);\n    let x111: u64 = ((x110 as u64) + (x91 as u64));\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x112, &mut x113, 0x0, x105, 0xffffffffffffffff);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x114, &mut x115, x113, x107, 0xfffffffffffffffe);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x116, &mut x117, x115, x109, 0xffffffffffffffff);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x118, &mut x119, x117, x111, (0x0 as u64));\n    let mut x120: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x120, x119, x112, x105);\n    let mut x121: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x121, x119, x114, x107);\n    let mut x122: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x122, x119, x116, x109);\n    out1[0] = x120;\n    out1[1] = x121;\n    out1[2] = x122;\n}",
    "display_name": "fiat_p192_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/pow2k",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalizes_to_zero"
    ],
    "body": "    pub fn invert(&self) -> CtOption<Self> {\n        // The binary representation of (p - 2) has 5 blocks of 1s, with lengths in\n        // { 1, 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n        // [1], [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n\n        let x2 = self.pow2k(1).mul(self);\n        let x3 = x2.pow2k(1).mul(self);\n        let x6 = x3.pow2k(3).mul(&x3);\n        let x9 = x6.pow2k(3).mul(&x3);\n        let x11 = x9.pow2k(2).mul(&x2);\n        let x22 = x11.pow2k(11).mul(&x11);\n        let x44 = x22.pow2k(22).mul(&x22);\n        let x88 = x44.pow2k(44).mul(&x44);\n        let x176 = x88.pow2k(88).mul(&x88);\n        let x220 = x176.pow2k(44).mul(&x44);\n        let x223 = x220.pow2k(3).mul(&x3);\n\n        // The final result is then assembled using a sliding window over the blocks.\n        let res = x223\n            .pow2k(23)\n            .mul(&x22)\n            .pow2k(5)\n            .mul(self)\n            .pow2k(3)\n            .mul(&x2)\n            .pow2k(2)\n            .mul(self);\n\n        CtOption::new(res, !self.normalizes_to_zero())\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/From::AffinePoint>>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(value: &NonIdentity<AffinePoint<BignP256>>) -> Self {\n        Self {\n            point: value.to_point(),\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/from_slice",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/signing/impl/SigningKey/from_nonzero_scalar"
    ],
    "body": "    pub fn from_slice(slice: &[u8]) -> Result<Self> {\n        let secret_scalar = NonZeroScalar::try_from(slice).map_err(|_| Error::new())?;\n        Self::from_nonzero_scalar(secret_scalar)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_repr(repr: Self::Repr) -> CtOption<Self> {\n        Self::from_bytes(&repr)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_set_one(\n    out1: &mut fiat_bign256_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    out1[0] = 0x81a54066d9c299f9;\n    out1[1] = 0x26a37129f204b203;\n    out1[2] = (0x0 as u64);\n    out1[3] = (0x0 as u64);\n}",
    "display_name": "fiat_bign256_scalar_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_bytes() {\n        assert_eq!(\n            FieldElement::from_bytes(&FieldBytes::default()).unwrap(),\n            FieldElement::ZERO\n        );\n        assert_eq!(\n            FieldElement::from_bytes(\n                [\n                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                    0, 0, 0, 0, 0, 1\n                ]\n                .as_ref()\n            )\n            .unwrap(),\n            FieldElement::ONE\n        );\n        assert!(bool::from(\n            FieldElement::from_bytes([0xff; 32].as_ref()).is_none()\n        ));\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/is_identity"
    ],
    "body": "    fn to_encoded_point(&self, compress: bool) -> EncodedPoint<C> {\n        EncodedPoint::<C>::conditional_select(\n            &EncodedPoint::<C>::from_affine_coordinates(\n                &self.x.to_repr(),\n                &self.y.to_repr(),\n                compress,\n            ),\n            &EncodedPoint::<C>::identity(),\n            self.is_identity(),\n        )\n    }",
    "display_name": "to_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/LinearCombination/lincomb"
    ],
    "body": "fn mul(x: &ProjectivePoint, k: &Scalar) -> ProjectivePoint {\n    ProjectivePoint::lincomb(&[(*x, *k)])\n}",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_mulx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p384_scalar_from_montgomery(\n    out1: &mut fiat_p384_scalar_non_montgomery_domain_field_element,\n    arg1: &fiat_p384_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x2, &mut x3, x1, 0x6ed46089e88fdc45);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x4, &mut x5, x2, 0xffffffffffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x6, &mut x7, x2, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x8, &mut x9, x2, 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x10, &mut x11, x2, 0xc7634d81f4372ddf);\n    let mut x12: u64 = 0;\n    let mut x13: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x12, &mut x13, x2, 0x581a0db248b0a77a);\n    let mut x14: u64 = 0;\n    let mut x15: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x14, &mut x15, x2, 0xecec196accc52973);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x16, &mut x17, 0x0, x15, x12);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x18, &mut x19, x17, x13, x10);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x20, &mut x21, x19, x11, x8);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x22, &mut x23, x21, x9, x6);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x24, &mut x25, x23, x7, x4);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x26, &mut x27, 0x0, x1, x14);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x28, &mut x29, x27, (0x0 as u64), x16);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x30, &mut x31, x29, (0x0 as u64), x18);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x32, &mut x33, x31, (0x0 as u64), x20);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x34, &mut x35, x33, (0x0 as u64), x22);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x36, &mut x37, x35, (0x0 as u64), x24);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x38, &mut x39, x37, (0x0 as u64), ((x25 as u64) + x5));\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x40, &mut x41, 0x0, x28, (arg1[1]));\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x42, &mut x43, x41, x30, (0x0 as u64));\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x44, &mut x45, x43, x32, (0x0 as u64));\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x46, &mut x47, x45, x34, (0x0 as u64));\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x48, &mut x49, x47, x36, (0x0 as u64));\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x50, &mut x51, x49, x38, (0x0 as u64));\n    let mut x52: u64 = 0;\n    let mut x53: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x52, &mut x53, x40, 0x6ed46089e88fdc45);\n    let mut x54: u64 = 0;\n    let mut x55: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x54, &mut x55, x52, 0xffffffffffffffff);\n    let mut x56: u64 = 0;\n    let mut x57: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x56, &mut x57, x52, 0xffffffffffffffff);\n    let mut x58: u64 = 0;\n    let mut x59: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x58, &mut x59, x52, 0xffffffffffffffff);\n    let mut x60: u64 = 0;\n    let mut x61: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x60, &mut x61, x52, 0xc7634d81f4372ddf);\n    let mut x62: u64 = 0;\n    let mut x63: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x62, &mut x63, x52, 0x581a0db248b0a77a);\n    let mut x64: u64 = 0;\n    let mut x65: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x64, &mut x65, x52, 0xecec196accc52973);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x66, &mut x67, 0x0, x65, x62);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x63, x60);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x70, &mut x71, x69, x61, x58);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x72, &mut x73, x71, x59, x56);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x74, &mut x75, x73, x57, x54);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x76, &mut x77, 0x0, x40, x64);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x78, &mut x79, x77, x42, x66);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x80, &mut x81, x79, x44, x68);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x46, x70);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x48, x72);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x50, x74);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x88,\n        &mut x89,\n        x87,\n        ((x51 as u64) + (x39 as u64)),\n        ((x75 as u64) + x55),\n    );\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x90, &mut x91, 0x0, x78, (arg1[2]));\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x92, &mut x93, x91, x80, (0x0 as u64));\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x82, (0x0 as u64));\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x84, (0x0 as u64));\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x86, (0x0 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x88, (0x0 as u64));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x102, &mut x103, x90, 0x6ed46089e88fdc45);\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x104, &mut x105, x102, 0xffffffffffffffff);\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x106, &mut x107, x102, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x108, &mut x109, x102, 0xffffffffffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x110, &mut x111, x102, 0xc7634d81f4372ddf);\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x112, &mut x113, x102, 0x581a0db248b0a77a);\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x114, &mut x115, x102, 0xecec196accc52973);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x116, &mut x117, 0x0, x115, x112);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x118, &mut x119, x117, x113, x110);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x120, &mut x121, x119, x111, x108);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x109, x106);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x124, &mut x125, x123, x107, x104);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x126, &mut x127, 0x0, x90, x114);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x128, &mut x129, x127, x92, x116);\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x130, &mut x131, x129, x94, x118);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x132, &mut x133, x131, x96, x120);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x134, &mut x135, x133, x98, x122);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x136, &mut x137, x135, x100, x124);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x138,\n        &mut x139,\n        x137,\n        ((x101 as u64) + (x89 as u64)),\n        ((x125 as u64) + x105),\n    );\n    let mut x140: u64 = 0;\n    let mut x141: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x140, &mut x141, 0x0, x128, (arg1[3]));\n    let mut x142: u64 = 0;\n    let mut x143: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x142, &mut x143, x141, x130, (0x0 as u64));\n    let mut x144: u64 = 0;\n    let mut x145: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x144, &mut x145, x143, x132, (0x0 as u64));\n    let mut x146: u64 = 0;\n    let mut x147: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x146, &mut x147, x145, x134, (0x0 as u64));\n    let mut x148: u64 = 0;\n    let mut x149: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x148, &mut x149, x147, x136, (0x0 as u64));\n    let mut x150: u64 = 0;\n    let mut x151: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x150, &mut x151, x149, x138, (0x0 as u64));\n    let mut x152: u64 = 0;\n    let mut x153: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x152, &mut x153, x140, 0x6ed46089e88fdc45);\n    let mut x154: u64 = 0;\n    let mut x155: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x154, &mut x155, x152, 0xffffffffffffffff);\n    let mut x156: u64 = 0;\n    let mut x157: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x156, &mut x157, x152, 0xffffffffffffffff);\n    let mut x158: u64 = 0;\n    let mut x159: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x158, &mut x159, x152, 0xffffffffffffffff);\n    let mut x160: u64 = 0;\n    let mut x161: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x160, &mut x161, x152, 0xc7634d81f4372ddf);\n    let mut x162: u64 = 0;\n    let mut x163: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x162, &mut x163, x152, 0x581a0db248b0a77a);\n    let mut x164: u64 = 0;\n    let mut x165: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x164, &mut x165, x152, 0xecec196accc52973);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x166, &mut x167, 0x0, x165, x162);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x168, &mut x169, x167, x163, x160);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x161, x158);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x159, x156);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x157, x154);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x176, &mut x177, 0x0, x140, x164);\n    let mut x178: u64 = 0;\n    let mut x179: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x178, &mut x179, x177, x142, x166);\n    let mut x180: u64 = 0;\n    let mut x181: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x180, &mut x181, x179, x144, x168);\n    let mut x182: u64 = 0;\n    let mut x183: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x182, &mut x183, x181, x146, x170);\n    let mut x184: u64 = 0;\n    let mut x185: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x184, &mut x185, x183, x148, x172);\n    let mut x186: u64 = 0;\n    let mut x187: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x186, &mut x187, x185, x150, x174);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x188,\n        &mut x189,\n        x187,\n        ((x151 as u64) + (x139 as u64)),\n        ((x175 as u64) + x155),\n    );\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x190, &mut x191, 0x0, x178, (arg1[4]));\n    let mut x192: u64 = 0;\n    let mut x193: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x180, (0x0 as u64));\n    let mut x194: u64 = 0;\n    let mut x195: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x194, &mut x195, x193, x182, (0x0 as u64));\n    let mut x196: u64 = 0;\n    let mut x197: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x196, &mut x197, x195, x184, (0x0 as u64));\n    let mut x198: u64 = 0;\n    let mut x199: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x198, &mut x199, x197, x186, (0x0 as u64));\n    let mut x200: u64 = 0;\n    let mut x201: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x200, &mut x201, x199, x188, (0x0 as u64));\n    let mut x202: u64 = 0;\n    let mut x203: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x202, &mut x203, x190, 0x6ed46089e88fdc45);\n    let mut x204: u64 = 0;\n    let mut x205: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x204, &mut x205, x202, 0xffffffffffffffff);\n    let mut x206: u64 = 0;\n    let mut x207: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x206, &mut x207, x202, 0xffffffffffffffff);\n    let mut x208: u64 = 0;\n    let mut x209: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x208, &mut x209, x202, 0xffffffffffffffff);\n    let mut x210: u64 = 0;\n    let mut x211: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x210, &mut x211, x202, 0xc7634d81f4372ddf);\n    let mut x212: u64 = 0;\n    let mut x213: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x212, &mut x213, x202, 0x581a0db248b0a77a);\n    let mut x214: u64 = 0;\n    let mut x215: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x214, &mut x215, x202, 0xecec196accc52973);\n    let mut x216: u64 = 0;\n    let mut x217: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x216, &mut x217, 0x0, x215, x212);\n    let mut x218: u64 = 0;\n    let mut x219: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x218, &mut x219, x217, x213, x210);\n    let mut x220: u64 = 0;\n    let mut x221: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x220, &mut x221, x219, x211, x208);\n    let mut x222: u64 = 0;\n    let mut x223: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x222, &mut x223, x221, x209, x206);\n    let mut x224: u64 = 0;\n    let mut x225: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x224, &mut x225, x223, x207, x204);\n    let mut x226: u64 = 0;\n    let mut x227: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x226, &mut x227, 0x0, x190, x214);\n    let mut x228: u64 = 0;\n    let mut x229: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x228, &mut x229, x227, x192, x216);\n    let mut x230: u64 = 0;\n    let mut x231: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x230, &mut x231, x229, x194, x218);\n    let mut x232: u64 = 0;\n    let mut x233: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x232, &mut x233, x231, x196, x220);\n    let mut x234: u64 = 0;\n    let mut x235: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x234, &mut x235, x233, x198, x222);\n    let mut x236: u64 = 0;\n    let mut x237: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x236, &mut x237, x235, x200, x224);\n    let mut x238: u64 = 0;\n    let mut x239: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x238,\n        &mut x239,\n        x237,\n        ((x201 as u64) + (x189 as u64)),\n        ((x225 as u64) + x205),\n    );\n    let mut x240: u64 = 0;\n    let mut x241: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x240, &mut x241, 0x0, x228, (arg1[5]));\n    let mut x242: u64 = 0;\n    let mut x243: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x242, &mut x243, x241, x230, (0x0 as u64));\n    let mut x244: u64 = 0;\n    let mut x245: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x244, &mut x245, x243, x232, (0x0 as u64));\n    let mut x246: u64 = 0;\n    let mut x247: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x246, &mut x247, x245, x234, (0x0 as u64));\n    let mut x248: u64 = 0;\n    let mut x249: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x248, &mut x249, x247, x236, (0x0 as u64));\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x250, &mut x251, x249, x238, (0x0 as u64));\n    let mut x252: u64 = 0;\n    let mut x253: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x252, &mut x253, x240, 0x6ed46089e88fdc45);\n    let mut x254: u64 = 0;\n    let mut x255: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x254, &mut x255, x252, 0xffffffffffffffff);\n    let mut x256: u64 = 0;\n    let mut x257: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x256, &mut x257, x252, 0xffffffffffffffff);\n    let mut x258: u64 = 0;\n    let mut x259: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x258, &mut x259, x252, 0xffffffffffffffff);\n    let mut x260: u64 = 0;\n    let mut x261: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x260, &mut x261, x252, 0xc7634d81f4372ddf);\n    let mut x262: u64 = 0;\n    let mut x263: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x262, &mut x263, x252, 0x581a0db248b0a77a);\n    let mut x264: u64 = 0;\n    let mut x265: u64 = 0;\n    fiat_p384_scalar_mulx_u64(&mut x264, &mut x265, x252, 0xecec196accc52973);\n    let mut x266: u64 = 0;\n    let mut x267: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x266, &mut x267, 0x0, x265, x262);\n    let mut x268: u64 = 0;\n    let mut x269: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x268, &mut x269, x267, x263, x260);\n    let mut x270: u64 = 0;\n    let mut x271: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x270, &mut x271, x269, x261, x258);\n    let mut x272: u64 = 0;\n    let mut x273: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x272, &mut x273, x271, x259, x256);\n    let mut x274: u64 = 0;\n    let mut x275: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x274, &mut x275, x273, x257, x254);\n    let mut x276: u64 = 0;\n    let mut x277: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x276, &mut x277, 0x0, x240, x264);\n    let mut x278: u64 = 0;\n    let mut x279: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x278, &mut x279, x277, x242, x266);\n    let mut x280: u64 = 0;\n    let mut x281: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x280, &mut x281, x279, x244, x268);\n    let mut x282: u64 = 0;\n    let mut x283: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x282, &mut x283, x281, x246, x270);\n    let mut x284: u64 = 0;\n    let mut x285: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x284, &mut x285, x283, x248, x272);\n    let mut x286: u64 = 0;\n    let mut x287: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(&mut x286, &mut x287, x285, x250, x274);\n    let mut x288: u64 = 0;\n    let mut x289: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_addcarryx_u64(\n        &mut x288,\n        &mut x289,\n        x287,\n        ((x251 as u64) + (x239 as u64)),\n        ((x275 as u64) + x255),\n    );\n    let mut x290: u64 = 0;\n    let mut x291: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x290, &mut x291, 0x0, x278, 0xecec196accc52973);\n    let mut x292: u64 = 0;\n    let mut x293: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x292, &mut x293, x291, x280, 0x581a0db248b0a77a);\n    let mut x294: u64 = 0;\n    let mut x295: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x294, &mut x295, x293, x282, 0xc7634d81f4372ddf);\n    let mut x296: u64 = 0;\n    let mut x297: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x296, &mut x297, x295, x284, 0xffffffffffffffff);\n    let mut x298: u64 = 0;\n    let mut x299: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x298, &mut x299, x297, x286, 0xffffffffffffffff);\n    let mut x300: u64 = 0;\n    let mut x301: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x300, &mut x301, x299, x288, 0xffffffffffffffff);\n    let mut x302: u64 = 0;\n    let mut x303: fiat_p384_scalar_u1 = 0;\n    fiat_p384_scalar_subborrowx_u64(&mut x302, &mut x303, x301, (x289 as u64), (0x0 as u64));\n    let mut x304: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x304, x303, x290, x278);\n    let mut x305: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x305, x303, x292, x280);\n    let mut x306: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x306, x303, x294, x282);\n    let mut x307: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x307, x303, x296, x284);\n    let mut x308: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x308, x303, x298, x286);\n    let mut x309: u64 = 0;\n    fiat_p384_scalar_cmovznz_u64(&mut x309, x303, x300, x288);\n    out1[0] = x304;\n    out1[1] = x305;\n    out1[2] = x306;\n    out1[3] = x307;\n    out1[4] = x308;\n    out1[5] = x309;\n}",
    "display_name": "fiat_p384_scalar_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/DigestSigner/try_sign_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/sign_raw"
    ],
    "body": "    fn try_sign_digest(&self, digest: D) -> Result<Signature> {\n        self.sign_raw(&digest.finalize_fixed(), &Default::default())\n    }",
    "display_name": "try_sign_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/square",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn square(&self) -> Self {\n        Self(self.0.square())\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/elliptic_curve::bigint::Uint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/dev/biguint_to_bytes",
      "0.14.0_pre.8 arithmetic/dev/bytes_to_biguint"
    ],
    "body": "    fn from(scalar: &Scalar) -> Self {\n        scalar.0\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_cmovznz_u64(out1: &mut u64, arg1: fiat_p192_u1, arg2: u64, arg3: u64) {\n    let x1: fiat_p192_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_p192_i2) - (x1 as fiat_p192_i2)) as fiat_p192_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_p192_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> FieldBytes {\n        self.secret_scalar.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/relax",
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/square"
    ],
    "body": "    pub const fn square(&self) -> Self {\n        self.relax().square()\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_to_bytes(out1: &mut [u8; 28], arg1: &[u64; 4]) {\n    let x1: u64 = (arg1[3]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[1]);\n    let x4: u64 = (arg1[0]);\n    let x5: u8 = ((x4 & (0xff as u64)) as u8);\n    let x6: u64 = (x4 >> 8);\n    let x7: u8 = ((x6 & (0xff as u64)) as u8);\n    let x8: u64 = (x6 >> 8);\n    let x9: u8 = ((x8 & (0xff as u64)) as u8);\n    let x10: u64 = (x8 >> 8);\n    let x11: u8 = ((x10 & (0xff as u64)) as u8);\n    let x12: u64 = (x10 >> 8);\n    let x13: u8 = ((x12 & (0xff as u64)) as u8);\n    let x14: u64 = (x12 >> 8);\n    let x15: u8 = ((x14 & (0xff as u64)) as u8);\n    let x16: u64 = (x14 >> 8);\n    let x17: u8 = ((x16 & (0xff as u64)) as u8);\n    let x18: u8 = ((x16 >> 8) as u8);\n    let x19: u8 = ((x3 & (0xff as u64)) as u8);\n    let x20: u64 = (x3 >> 8);\n    let x21: u8 = ((x20 & (0xff as u64)) as u8);\n    let x22: u64 = (x20 >> 8);\n    let x23: u8 = ((x22 & (0xff as u64)) as u8);\n    let x24: u64 = (x22 >> 8);\n    let x25: u8 = ((x24 & (0xff as u64)) as u8);\n    let x26: u64 = (x24 >> 8);\n    let x27: u8 = ((x26 & (0xff as u64)) as u8);\n    let x28: u64 = (x26 >> 8);\n    let x29: u8 = ((x28 & (0xff as u64)) as u8);\n    let x30: u64 = (x28 >> 8);\n    let x31: u8 = ((x30 & (0xff as u64)) as u8);\n    let x32: u8 = ((x30 >> 8) as u8);\n    let x33: u8 = ((x2 & (0xff as u64)) as u8);\n    let x34: u64 = (x2 >> 8);\n    let x35: u8 = ((x34 & (0xff as u64)) as u8);\n    let x36: u64 = (x34 >> 8);\n    let x37: u8 = ((x36 & (0xff as u64)) as u8);\n    let x38: u64 = (x36 >> 8);\n    let x39: u8 = ((x38 & (0xff as u64)) as u8);\n    let x40: u64 = (x38 >> 8);\n    let x41: u8 = ((x40 & (0xff as u64)) as u8);\n    let x42: u64 = (x40 >> 8);\n    let x43: u8 = ((x42 & (0xff as u64)) as u8);\n    let x44: u64 = (x42 >> 8);\n    let x45: u8 = ((x44 & (0xff as u64)) as u8);\n    let x46: u8 = ((x44 >> 8) as u8);\n    let x47: u8 = ((x1 & (0xff as u64)) as u8);\n    let x48: u64 = (x1 >> 8);\n    let x49: u8 = ((x48 & (0xff as u64)) as u8);\n    let x50: u64 = (x48 >> 8);\n    let x51: u8 = ((x50 & (0xff as u64)) as u8);\n    let x52: u8 = ((x50 >> 8) as u8);\n    out1[0] = x5;\n    out1[1] = x7;\n    out1[2] = x9;\n    out1[3] = x11;\n    out1[4] = x13;\n    out1[5] = x15;\n    out1[6] = x17;\n    out1[7] = x18;\n    out1[8] = x19;\n    out1[9] = x21;\n    out1[10] = x23;\n    out1[11] = x25;\n    out1[12] = x27;\n    out1[13] = x29;\n    out1[14] = x31;\n    out1[15] = x32;\n    out1[16] = x33;\n    out1[17] = x35;\n    out1[18] = x37;\n    out1[19] = x39;\n    out1[20] = x41;\n    out1[21] = x43;\n    out1[22] = x45;\n    out1[23] = x46;\n    out1[24] = x47;\n    out1[25] = x49;\n    out1[26] = x51;\n    out1[27] = x52;\n}",
    "display_name": "fiat_p224_scalar_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/verifying_key",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn verifying_key(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }",
    "display_name": "verifying_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/SubAssign>/sub_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &AffinePoint<C>) {\n        *self = ProjectivePoint::sub_mixed(self, rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/sign_ctx",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_ctx"
    ],
    "body": "    pub fn sign_ctx(&self, context: &[u8], message: &[u8]) -> Result<Signature, Error> {\n        let sig = self.secret.sign_ctx(context, message)?;\n        Ok(sig.into())\n    }",
    "display_name": "sign_ctx",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double"
    ],
    "body": "    fn double(&self) -> Self {\n        self.double()\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        self.invert()\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt"
    ],
    "body": "    fn sqrt(&self) -> CtOption<Self> {\n        self.sqrt()\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/PrehashSigner/sign_prehash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/sign_raw"
    ],
    "body": "    fn sign_prehash(&self, prehash: &[u8]) -> Result<Signature> {\n        self.sign_raw(prehash, &Default::default())\n    }",
    "display_name": "sign_prehash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/sign_prehash_rfc6979",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes",
      "0.14.0_pre dsa/impl/Signature/from_scalars",
      "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
      "affine/impl/AffinePoint/AffineCoordinates/x",
      "projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "fn sign_prehash_rfc6979(secret_scalar: &Scalar, prehash: &[u8], data: &[u8]) -> Result<Signature> {\n    if prehash.len() != <Sm2 as Curve>::FieldBytesSize::USIZE {\n        return Err(Error::new());\n    }\n\n    // A2: calculate e=Hv(M~)\n    #[allow(deprecated)] // from_slice\n    let e = Scalar::reduce_bytes(FieldBytes::from_slice(prehash));\n\n    // A3: pick a random number k in [1, n-1] via a random number generator\n    let k = Scalar::from_repr(rfc6979::generate_k::<Sm3, _>(\n        &secret_scalar.to_repr(),\n        &FieldBytesEncoding::<Sm2>::encode_field_bytes(&Sm2::ORDER),\n        &e.to_bytes(),\n        data,\n    ))\n    .unwrap();\n\n    // A4: calculate the elliptic curve point (x1, y1)=[k]G\n    let R = ProjectivePoint::mul_by_generator(&k).to_affine();\n\n    // A5: calculate r=(e+x1) modn, return to A3 if r=0 or r+k=n\n    let r = e + Scalar::reduce_bytes(&R.x());\n    if bool::from(r.is_zero() | (r + k).ct_eq(&Scalar::ZERO)) {\n        return Err(Error::new());\n    }\n\n    // A6: calculate s=((1+dA)^(-1)*(k-r*dA)) modn, return to A3 if s=0\n    let d_plus_1_inv =\n        Option::<Scalar>::from((secret_scalar + &Scalar::ONE).invert()).ok_or_else(Error::new)?;\n\n    let s = d_plus_1_inv * (k - (r * secret_scalar));\n\n    // A7: the digital signature of M is (r, s)\n    Signature::from_scalars(r, s)\n}",
    "display_name": "sign_prehash_rfc6979",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/square",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom, ed448::pkcs8::OctetStringRef, ed448::pkcs8::BitStringRef>>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/KeypairBytes/TryFrom, ed448::pkcs8::OctetStringRef, ed448::pkcs8::BitStringRef>>/try_from"
    ],
    "body": "    fn try_from(value: pkcs8::PrivateKeyInfoRef<'_>) -> Result<Self, Self::Error> {\n        KeypairBytes::try_from(value)?.try_into()\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint_unchecked"
    ],
    "body": "    fn from(n: u128) -> FieldElement {\n        Self::from_uint_unchecked(U576::from(n))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn to_bytes(&self) -> PointBytes {\n        self.0\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/bigint::Uint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_canonical"
    ],
    "body": "    fn from(scalar: &Scalar) -> U576 {\n        scalar.to_canonical()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_p192_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_opp(\n    out1: &mut fiat_p224_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p224_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, (x9 & 0x13dd29455c5c2a3d));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0xffff16a2e0b8f03e));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, (x9 & 0xffffffff));\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_p224_scalar_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_invert_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert_vartime"
    ],
    "body": "        fn fuzzy_invert_vartime(w in scalar()) {\n            let inv: Option<Scalar> = w.invert().into();\n            let inv_vartime: Option<Scalar> = w.invert_vartime().into();\n            assert_eq!(inv, inv_vartime);\n        }",
    "display_name": "fuzzy_invert_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut bytes = FieldBytes::default();\n\n        // Generate a uniformly random scalar using rejection sampling,\n        // which produces a uniformly random distribution of scalars.\n        //\n        // This method is not constant time, but should be secure so long as\n        // rejected RNG outputs are unrelated to future ones (which is a\n        // necessary property of a `CryptoRng`).\n        //\n        // With an unbiased RNG, the probability of failing to complete after 4\n        // iterations is vanishingly small.\n        loop {\n            rng.try_fill_bytes(&mut bytes)?;\n            if let Some(scalar) = Scalar::from_repr(bytes).into() {\n                return Ok(scalar);\n            }\n        }\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/From>/from"
    ],
    "body": "    fn from(public_key: &PublicKey) -> AffinePoint {\n        AffinePoint::from(*public_key)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&EdwardsPoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/negate"
    ],
    "body": "    fn neg(self) -> EdwardsPoint {\n        self.negate()\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/FromStr/from_str",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_str(s: &str) -> Result<Self, Error> {\n        Self::from_public_key_pem(s).map_err(|_| Error)\n    }",
    "display_name": "from_str",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/sqrt_ratio",
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes",
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative",
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    pub fn decompress_unchecked(&self) -> CtOption<EdwardsPoint> {\n        // Safe to unwrap here as the underlying data structure is a slice\n        let (sign, b) = self.0.split_last().expect(\"slice is non-empty\");\n\n        let mut y_bytes: [u8; 56] = [0; 56];\n        y_bytes.copy_from_slice(b);\n\n        // Recover x using y\n        let y = FieldElement::from_bytes(&y_bytes);\n        let yy = y.square();\n        let dyy = FieldElement::EDWARDS_D * yy;\n        let numerator = FieldElement::ONE - yy;\n        let denominator = FieldElement::ONE - dyy;\n\n        let (mut x, is_res) = FieldElement::sqrt_ratio(&numerator, &denominator);\n\n        // Compute correct sign of x\n        let compressed_sign_bit = Choice::from(sign >> 7);\n        let is_negative = x.is_negative();\n        x.conditional_negate(compressed_sign_bit ^ is_negative);\n\n        CtOption::new(AffinePoint { x, y }.to_edwards(), is_res)\n    }",
    "display_name": "decompress_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 ristretto/points/impl/CompressedRistretto/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 ristretto/points/impl/CompressedRistretto/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &CompressedRistretto) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/ristretto/points.rs",
    "relative_path": "ed448-goldilocks/src/ristretto/points.rs",
    "file_name": "points.rs",
    "parent_folder": "ristretto"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_mulx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_square(\n    out1: &mut fiat_p521_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p521_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[6]);\n    let x7: u64 = (arg1[7]);\n    let x8: u64 = (arg1[8]);\n    let x9: u64 = (arg1[0]);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x10, &mut x11, x9, (arg1[8]));\n    let mut x12: u64 = 0;\n    let mut x13: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x12, &mut x13, x9, (arg1[7]));\n    let mut x14: u64 = 0;\n    let mut x15: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x14, &mut x15, x9, (arg1[6]));\n    let mut x16: u64 = 0;\n    let mut x17: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x16, &mut x17, x9, (arg1[5]));\n    let mut x18: u64 = 0;\n    let mut x19: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x18, &mut x19, x9, (arg1[4]));\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x20, &mut x21, x9, (arg1[3]));\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x22, &mut x23, x9, (arg1[2]));\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x24, &mut x25, x9, (arg1[1]));\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x26, &mut x27, x9, (arg1[0]));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x28, &mut x29, 0x0, x27, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x25, x22);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x23, x20);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x21, x18);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x36, &mut x37, x35, x19, x16);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x38, &mut x39, x37, x17, x14);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x40, &mut x41, x39, x15, x12);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x42, &mut x43, x41, x13, x10);\n    let x44: u64 = ((x43 as u64) + x11);\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x45, &mut x46, x26, 0x1d2f5ccd79a995c7);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x47, &mut x48, x45, 0x1ff);\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x49, &mut x50, x45, 0xffffffffffffffff);\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x51, &mut x52, x45, 0xffffffffffffffff);\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x53, &mut x54, x45, 0xffffffffffffffff);\n    let mut x55: u64 = 0;\n    let mut x56: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x55, &mut x56, x45, 0xfffffffffffffffa);\n    let mut x57: u64 = 0;\n    let mut x58: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x57, &mut x58, x45, 0x51868783bf2f966b);\n    let mut x59: u64 = 0;\n    let mut x60: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x59, &mut x60, x45, 0x7fcc0148f709a5d0);\n    let mut x61: u64 = 0;\n    let mut x62: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x61, &mut x62, x45, 0x3bb5c9b8899c47ae);\n    let mut x63: u64 = 0;\n    let mut x64: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x63, &mut x64, x45, 0xbb6fb71e91386409);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x65, &mut x66, 0x0, x64, x61);\n    let mut x67: u64 = 0;\n    let mut x68: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x67, &mut x68, x66, x62, x59);\n    let mut x69: u64 = 0;\n    let mut x70: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x69, &mut x70, x68, x60, x57);\n    let mut x71: u64 = 0;\n    let mut x72: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x71, &mut x72, x70, x58, x55);\n    let mut x73: u64 = 0;\n    let mut x74: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x73, &mut x74, x72, x56, x53);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x75, &mut x76, x74, x54, x51);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x77, &mut x78, x76, x52, x49);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x79, &mut x80, x78, x50, x47);\n    let x81: u64 = ((x80 as u64) + x48);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x82, &mut x83, 0x0, x26, x63);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x28, x65);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x30, x67);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x32, x69);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x34, x71);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x92, &mut x93, x91, x36, x73);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x38, x75);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x40, x77);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x42, x79);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x44, x81);\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x102, &mut x103, x1, (arg1[8]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x104, &mut x105, x1, (arg1[7]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x106, &mut x107, x1, (arg1[6]));\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x108, &mut x109, x1, (arg1[5]));\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x110, &mut x111, x1, (arg1[4]));\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x112, &mut x113, x1, (arg1[3]));\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x114, &mut x115, x1, (arg1[2]));\n    let mut x116: u64 = 0;\n    let mut x117: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x116, &mut x117, x1, (arg1[1]));\n    let mut x118: u64 = 0;\n    let mut x119: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x118, &mut x119, x1, (arg1[0]));\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x120, &mut x121, 0x0, x119, x116);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x117, x114);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x124, &mut x125, x123, x115, x112);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x126, &mut x127, x125, x113, x110);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x128, &mut x129, x127, x111, x108);\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x130, &mut x131, x129, x109, x106);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x132, &mut x133, x131, x107, x104);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x134, &mut x135, x133, x105, x102);\n    let x136: u64 = ((x135 as u64) + x103);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x137, &mut x138, 0x0, x84, x118);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x86, x120);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x141, &mut x142, x140, x88, x122);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x143, &mut x144, x142, x90, x124);\n    let mut x145: u64 = 0;\n    let mut x146: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x145, &mut x146, x144, x92, x126);\n    let mut x147: u64 = 0;\n    let mut x148: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x147, &mut x148, x146, x94, x128);\n    let mut x149: u64 = 0;\n    let mut x150: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x149, &mut x150, x148, x96, x130);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x151, &mut x152, x150, x98, x132);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x153, &mut x154, x152, x100, x134);\n    let mut x155: u64 = 0;\n    let mut x156: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x155, &mut x156, x154, (x101 as u64), x136);\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x157, &mut x158, x137, 0x1d2f5ccd79a995c7);\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x159, &mut x160, x157, 0x1ff);\n    let mut x161: u64 = 0;\n    let mut x162: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x161, &mut x162, x157, 0xffffffffffffffff);\n    let mut x163: u64 = 0;\n    let mut x164: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x163, &mut x164, x157, 0xffffffffffffffff);\n    let mut x165: u64 = 0;\n    let mut x166: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x165, &mut x166, x157, 0xffffffffffffffff);\n    let mut x167: u64 = 0;\n    let mut x168: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x167, &mut x168, x157, 0xfffffffffffffffa);\n    let mut x169: u64 = 0;\n    let mut x170: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x169, &mut x170, x157, 0x51868783bf2f966b);\n    let mut x171: u64 = 0;\n    let mut x172: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x171, &mut x172, x157, 0x7fcc0148f709a5d0);\n    let mut x173: u64 = 0;\n    let mut x174: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x173, &mut x174, x157, 0x3bb5c9b8899c47ae);\n    let mut x175: u64 = 0;\n    let mut x176: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x175, &mut x176, x157, 0xbb6fb71e91386409);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x177, &mut x178, 0x0, x176, x173);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x179, &mut x180, x178, x174, x171);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x181, &mut x182, x180, x172, x169);\n    let mut x183: u64 = 0;\n    let mut x184: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x183, &mut x184, x182, x170, x167);\n    let mut x185: u64 = 0;\n    let mut x186: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x185, &mut x186, x184, x168, x165);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x187, &mut x188, x186, x166, x163);\n    let mut x189: u64 = 0;\n    let mut x190: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x189, &mut x190, x188, x164, x161);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x191, &mut x192, x190, x162, x159);\n    let x193: u64 = ((x192 as u64) + x160);\n    let mut x194: u64 = 0;\n    let mut x195: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x194, &mut x195, 0x0, x137, x175);\n    let mut x196: u64 = 0;\n    let mut x197: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x196, &mut x197, x195, x139, x177);\n    let mut x198: u64 = 0;\n    let mut x199: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x198, &mut x199, x197, x141, x179);\n    let mut x200: u64 = 0;\n    let mut x201: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x200, &mut x201, x199, x143, x181);\n    let mut x202: u64 = 0;\n    let mut x203: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x202, &mut x203, x201, x145, x183);\n    let mut x204: u64 = 0;\n    let mut x205: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x204, &mut x205, x203, x147, x185);\n    let mut x206: u64 = 0;\n    let mut x207: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x206, &mut x207, x205, x149, x187);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x208, &mut x209, x207, x151, x189);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x210, &mut x211, x209, x153, x191);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x212, &mut x213, x211, x155, x193);\n    let x214: u64 = ((x213 as u64) + (x156 as u64));\n    let mut x215: u64 = 0;\n    let mut x216: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x215, &mut x216, x2, (arg1[8]));\n    let mut x217: u64 = 0;\n    let mut x218: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x217, &mut x218, x2, (arg1[7]));\n    let mut x219: u64 = 0;\n    let mut x220: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x219, &mut x220, x2, (arg1[6]));\n    let mut x221: u64 = 0;\n    let mut x222: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x221, &mut x222, x2, (arg1[5]));\n    let mut x223: u64 = 0;\n    let mut x224: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x223, &mut x224, x2, (arg1[4]));\n    let mut x225: u64 = 0;\n    let mut x226: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x225, &mut x226, x2, (arg1[3]));\n    let mut x227: u64 = 0;\n    let mut x228: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x227, &mut x228, x2, (arg1[2]));\n    let mut x229: u64 = 0;\n    let mut x230: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x229, &mut x230, x2, (arg1[1]));\n    let mut x231: u64 = 0;\n    let mut x232: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x231, &mut x232, x2, (arg1[0]));\n    let mut x233: u64 = 0;\n    let mut x234: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x233, &mut x234, 0x0, x232, x229);\n    let mut x235: u64 = 0;\n    let mut x236: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x235, &mut x236, x234, x230, x227);\n    let mut x237: u64 = 0;\n    let mut x238: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x237, &mut x238, x236, x228, x225);\n    let mut x239: u64 = 0;\n    let mut x240: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x239, &mut x240, x238, x226, x223);\n    let mut x241: u64 = 0;\n    let mut x242: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x241, &mut x242, x240, x224, x221);\n    let mut x243: u64 = 0;\n    let mut x244: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x243, &mut x244, x242, x222, x219);\n    let mut x245: u64 = 0;\n    let mut x246: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x245, &mut x246, x244, x220, x217);\n    let mut x247: u64 = 0;\n    let mut x248: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x247, &mut x248, x246, x218, x215);\n    let x249: u64 = ((x248 as u64) + x216);\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x250, &mut x251, 0x0, x196, x231);\n    let mut x252: u64 = 0;\n    let mut x253: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x252, &mut x253, x251, x198, x233);\n    let mut x254: u64 = 0;\n    let mut x255: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x254, &mut x255, x253, x200, x235);\n    let mut x256: u64 = 0;\n    let mut x257: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x256, &mut x257, x255, x202, x237);\n    let mut x258: u64 = 0;\n    let mut x259: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x258, &mut x259, x257, x204, x239);\n    let mut x260: u64 = 0;\n    let mut x261: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x260, &mut x261, x259, x206, x241);\n    let mut x262: u64 = 0;\n    let mut x263: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x262, &mut x263, x261, x208, x243);\n    let mut x264: u64 = 0;\n    let mut x265: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x264, &mut x265, x263, x210, x245);\n    let mut x266: u64 = 0;\n    let mut x267: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x266, &mut x267, x265, x212, x247);\n    let mut x268: u64 = 0;\n    let mut x269: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x268, &mut x269, x267, x214, x249);\n    let mut x270: u64 = 0;\n    let mut x271: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x270, &mut x271, x250, 0x1d2f5ccd79a995c7);\n    let mut x272: u64 = 0;\n    let mut x273: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x272, &mut x273, x270, 0x1ff);\n    let mut x274: u64 = 0;\n    let mut x275: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x274, &mut x275, x270, 0xffffffffffffffff);\n    let mut x276: u64 = 0;\n    let mut x277: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x276, &mut x277, x270, 0xffffffffffffffff);\n    let mut x278: u64 = 0;\n    let mut x279: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x278, &mut x279, x270, 0xffffffffffffffff);\n    let mut x280: u64 = 0;\n    let mut x281: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x280, &mut x281, x270, 0xfffffffffffffffa);\n    let mut x282: u64 = 0;\n    let mut x283: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x282, &mut x283, x270, 0x51868783bf2f966b);\n    let mut x284: u64 = 0;\n    let mut x285: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x284, &mut x285, x270, 0x7fcc0148f709a5d0);\n    let mut x286: u64 = 0;\n    let mut x287: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x286, &mut x287, x270, 0x3bb5c9b8899c47ae);\n    let mut x288: u64 = 0;\n    let mut x289: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x288, &mut x289, x270, 0xbb6fb71e91386409);\n    let mut x290: u64 = 0;\n    let mut x291: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x290, &mut x291, 0x0, x289, x286);\n    let mut x292: u64 = 0;\n    let mut x293: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x292, &mut x293, x291, x287, x284);\n    let mut x294: u64 = 0;\n    let mut x295: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x294, &mut x295, x293, x285, x282);\n    let mut x296: u64 = 0;\n    let mut x297: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x296, &mut x297, x295, x283, x280);\n    let mut x298: u64 = 0;\n    let mut x299: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x298, &mut x299, x297, x281, x278);\n    let mut x300: u64 = 0;\n    let mut x301: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x300, &mut x301, x299, x279, x276);\n    let mut x302: u64 = 0;\n    let mut x303: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x302, &mut x303, x301, x277, x274);\n    let mut x304: u64 = 0;\n    let mut x305: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x304, &mut x305, x303, x275, x272);\n    let x306: u64 = ((x305 as u64) + x273);\n    let mut x307: u64 = 0;\n    let mut x308: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x307, &mut x308, 0x0, x250, x288);\n    let mut x309: u64 = 0;\n    let mut x310: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x309, &mut x310, x308, x252, x290);\n    let mut x311: u64 = 0;\n    let mut x312: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x311, &mut x312, x310, x254, x292);\n    let mut x313: u64 = 0;\n    let mut x314: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x313, &mut x314, x312, x256, x294);\n    let mut x315: u64 = 0;\n    let mut x316: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x315, &mut x316, x314, x258, x296);\n    let mut x317: u64 = 0;\n    let mut x318: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x317, &mut x318, x316, x260, x298);\n    let mut x319: u64 = 0;\n    let mut x320: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x319, &mut x320, x318, x262, x300);\n    let mut x321: u64 = 0;\n    let mut x322: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x321, &mut x322, x320, x264, x302);\n    let mut x323: u64 = 0;\n    let mut x324: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x323, &mut x324, x322, x266, x304);\n    let mut x325: u64 = 0;\n    let mut x326: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x325, &mut x326, x324, x268, x306);\n    let x327: u64 = ((x326 as u64) + (x269 as u64));\n    let mut x328: u64 = 0;\n    let mut x329: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x328, &mut x329, x3, (arg1[8]));\n    let mut x330: u64 = 0;\n    let mut x331: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x330, &mut x331, x3, (arg1[7]));\n    let mut x332: u64 = 0;\n    let mut x333: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x332, &mut x333, x3, (arg1[6]));\n    let mut x334: u64 = 0;\n    let mut x335: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x334, &mut x335, x3, (arg1[5]));\n    let mut x336: u64 = 0;\n    let mut x337: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x336, &mut x337, x3, (arg1[4]));\n    let mut x338: u64 = 0;\n    let mut x339: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x338, &mut x339, x3, (arg1[3]));\n    let mut x340: u64 = 0;\n    let mut x341: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x340, &mut x341, x3, (arg1[2]));\n    let mut x342: u64 = 0;\n    let mut x343: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x342, &mut x343, x3, (arg1[1]));\n    let mut x344: u64 = 0;\n    let mut x345: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x344, &mut x345, x3, (arg1[0]));\n    let mut x346: u64 = 0;\n    let mut x347: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x346, &mut x347, 0x0, x345, x342);\n    let mut x348: u64 = 0;\n    let mut x349: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x348, &mut x349, x347, x343, x340);\n    let mut x350: u64 = 0;\n    let mut x351: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x350, &mut x351, x349, x341, x338);\n    let mut x352: u64 = 0;\n    let mut x353: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x352, &mut x353, x351, x339, x336);\n    let mut x354: u64 = 0;\n    let mut x355: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x354, &mut x355, x353, x337, x334);\n    let mut x356: u64 = 0;\n    let mut x357: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x356, &mut x357, x355, x335, x332);\n    let mut x358: u64 = 0;\n    let mut x359: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x358, &mut x359, x357, x333, x330);\n    let mut x360: u64 = 0;\n    let mut x361: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x360, &mut x361, x359, x331, x328);\n    let x362: u64 = ((x361 as u64) + x329);\n    let mut x363: u64 = 0;\n    let mut x364: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x363, &mut x364, 0x0, x309, x344);\n    let mut x365: u64 = 0;\n    let mut x366: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x365, &mut x366, x364, x311, x346);\n    let mut x367: u64 = 0;\n    let mut x368: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x367, &mut x368, x366, x313, x348);\n    let mut x369: u64 = 0;\n    let mut x370: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x369, &mut x370, x368, x315, x350);\n    let mut x371: u64 = 0;\n    let mut x372: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x371, &mut x372, x370, x317, x352);\n    let mut x373: u64 = 0;\n    let mut x374: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x373, &mut x374, x372, x319, x354);\n    let mut x375: u64 = 0;\n    let mut x376: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x375, &mut x376, x374, x321, x356);\n    let mut x377: u64 = 0;\n    let mut x378: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x377, &mut x378, x376, x323, x358);\n    let mut x379: u64 = 0;\n    let mut x380: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x379, &mut x380, x378, x325, x360);\n    let mut x381: u64 = 0;\n    let mut x382: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x381, &mut x382, x380, x327, x362);\n    let mut x383: u64 = 0;\n    let mut x384: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x383, &mut x384, x363, 0x1d2f5ccd79a995c7);\n    let mut x385: u64 = 0;\n    let mut x386: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x385, &mut x386, x383, 0x1ff);\n    let mut x387: u64 = 0;\n    let mut x388: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x387, &mut x388, x383, 0xffffffffffffffff);\n    let mut x389: u64 = 0;\n    let mut x390: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x389, &mut x390, x383, 0xffffffffffffffff);\n    let mut x391: u64 = 0;\n    let mut x392: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x391, &mut x392, x383, 0xffffffffffffffff);\n    let mut x393: u64 = 0;\n    let mut x394: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x393, &mut x394, x383, 0xfffffffffffffffa);\n    let mut x395: u64 = 0;\n    let mut x396: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x395, &mut x396, x383, 0x51868783bf2f966b);\n    let mut x397: u64 = 0;\n    let mut x398: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x397, &mut x398, x383, 0x7fcc0148f709a5d0);\n    let mut x399: u64 = 0;\n    let mut x400: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x399, &mut x400, x383, 0x3bb5c9b8899c47ae);\n    let mut x401: u64 = 0;\n    let mut x402: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x401, &mut x402, x383, 0xbb6fb71e91386409);\n    let mut x403: u64 = 0;\n    let mut x404: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x403, &mut x404, 0x0, x402, x399);\n    let mut x405: u64 = 0;\n    let mut x406: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x405, &mut x406, x404, x400, x397);\n    let mut x407: u64 = 0;\n    let mut x408: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x407, &mut x408, x406, x398, x395);\n    let mut x409: u64 = 0;\n    let mut x410: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x409, &mut x410, x408, x396, x393);\n    let mut x411: u64 = 0;\n    let mut x412: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x411, &mut x412, x410, x394, x391);\n    let mut x413: u64 = 0;\n    let mut x414: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x413, &mut x414, x412, x392, x389);\n    let mut x415: u64 = 0;\n    let mut x416: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x415, &mut x416, x414, x390, x387);\n    let mut x417: u64 = 0;\n    let mut x418: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x417, &mut x418, x416, x388, x385);\n    let x419: u64 = ((x418 as u64) + x386);\n    let mut x420: u64 = 0;\n    let mut x421: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x420, &mut x421, 0x0, x363, x401);\n    let mut x422: u64 = 0;\n    let mut x423: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x422, &mut x423, x421, x365, x403);\n    let mut x424: u64 = 0;\n    let mut x425: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x424, &mut x425, x423, x367, x405);\n    let mut x426: u64 = 0;\n    let mut x427: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x426, &mut x427, x425, x369, x407);\n    let mut x428: u64 = 0;\n    let mut x429: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x428, &mut x429, x427, x371, x409);\n    let mut x430: u64 = 0;\n    let mut x431: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x430, &mut x431, x429, x373, x411);\n    let mut x432: u64 = 0;\n    let mut x433: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x432, &mut x433, x431, x375, x413);\n    let mut x434: u64 = 0;\n    let mut x435: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x434, &mut x435, x433, x377, x415);\n    let mut x436: u64 = 0;\n    let mut x437: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x436, &mut x437, x435, x379, x417);\n    let mut x438: u64 = 0;\n    let mut x439: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x438, &mut x439, x437, x381, x419);\n    let x440: u64 = ((x439 as u64) + (x382 as u64));\n    let mut x441: u64 = 0;\n    let mut x442: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x441, &mut x442, x4, (arg1[8]));\n    let mut x443: u64 = 0;\n    let mut x444: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x443, &mut x444, x4, (arg1[7]));\n    let mut x445: u64 = 0;\n    let mut x446: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x445, &mut x446, x4, (arg1[6]));\n    let mut x447: u64 = 0;\n    let mut x448: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x447, &mut x448, x4, (arg1[5]));\n    let mut x449: u64 = 0;\n    let mut x450: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x449, &mut x450, x4, (arg1[4]));\n    let mut x451: u64 = 0;\n    let mut x452: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x451, &mut x452, x4, (arg1[3]));\n    let mut x453: u64 = 0;\n    let mut x454: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x453, &mut x454, x4, (arg1[2]));\n    let mut x455: u64 = 0;\n    let mut x456: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x455, &mut x456, x4, (arg1[1]));\n    let mut x457: u64 = 0;\n    let mut x458: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x457, &mut x458, x4, (arg1[0]));\n    let mut x459: u64 = 0;\n    let mut x460: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x459, &mut x460, 0x0, x458, x455);\n    let mut x461: u64 = 0;\n    let mut x462: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x461, &mut x462, x460, x456, x453);\n    let mut x463: u64 = 0;\n    let mut x464: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x463, &mut x464, x462, x454, x451);\n    let mut x465: u64 = 0;\n    let mut x466: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x465, &mut x466, x464, x452, x449);\n    let mut x467: u64 = 0;\n    let mut x468: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x467, &mut x468, x466, x450, x447);\n    let mut x469: u64 = 0;\n    let mut x470: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x469, &mut x470, x468, x448, x445);\n    let mut x471: u64 = 0;\n    let mut x472: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x471, &mut x472, x470, x446, x443);\n    let mut x473: u64 = 0;\n    let mut x474: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x473, &mut x474, x472, x444, x441);\n    let x475: u64 = ((x474 as u64) + x442);\n    let mut x476: u64 = 0;\n    let mut x477: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x476, &mut x477, 0x0, x422, x457);\n    let mut x478: u64 = 0;\n    let mut x479: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x478, &mut x479, x477, x424, x459);\n    let mut x480: u64 = 0;\n    let mut x481: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x480, &mut x481, x479, x426, x461);\n    let mut x482: u64 = 0;\n    let mut x483: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x482, &mut x483, x481, x428, x463);\n    let mut x484: u64 = 0;\n    let mut x485: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x484, &mut x485, x483, x430, x465);\n    let mut x486: u64 = 0;\n    let mut x487: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x486, &mut x487, x485, x432, x467);\n    let mut x488: u64 = 0;\n    let mut x489: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x488, &mut x489, x487, x434, x469);\n    let mut x490: u64 = 0;\n    let mut x491: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x490, &mut x491, x489, x436, x471);\n    let mut x492: u64 = 0;\n    let mut x493: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x492, &mut x493, x491, x438, x473);\n    let mut x494: u64 = 0;\n    let mut x495: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x494, &mut x495, x493, x440, x475);\n    let mut x496: u64 = 0;\n    let mut x497: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x496, &mut x497, x476, 0x1d2f5ccd79a995c7);\n    let mut x498: u64 = 0;\n    let mut x499: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x498, &mut x499, x496, 0x1ff);\n    let mut x500: u64 = 0;\n    let mut x501: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x500, &mut x501, x496, 0xffffffffffffffff);\n    let mut x502: u64 = 0;\n    let mut x503: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x502, &mut x503, x496, 0xffffffffffffffff);\n    let mut x504: u64 = 0;\n    let mut x505: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x504, &mut x505, x496, 0xffffffffffffffff);\n    let mut x506: u64 = 0;\n    let mut x507: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x506, &mut x507, x496, 0xfffffffffffffffa);\n    let mut x508: u64 = 0;\n    let mut x509: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x508, &mut x509, x496, 0x51868783bf2f966b);\n    let mut x510: u64 = 0;\n    let mut x511: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x510, &mut x511, x496, 0x7fcc0148f709a5d0);\n    let mut x512: u64 = 0;\n    let mut x513: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x512, &mut x513, x496, 0x3bb5c9b8899c47ae);\n    let mut x514: u64 = 0;\n    let mut x515: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x514, &mut x515, x496, 0xbb6fb71e91386409);\n    let mut x516: u64 = 0;\n    let mut x517: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x516, &mut x517, 0x0, x515, x512);\n    let mut x518: u64 = 0;\n    let mut x519: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x518, &mut x519, x517, x513, x510);\n    let mut x520: u64 = 0;\n    let mut x521: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x520, &mut x521, x519, x511, x508);\n    let mut x522: u64 = 0;\n    let mut x523: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x522, &mut x523, x521, x509, x506);\n    let mut x524: u64 = 0;\n    let mut x525: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x524, &mut x525, x523, x507, x504);\n    let mut x526: u64 = 0;\n    let mut x527: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x526, &mut x527, x525, x505, x502);\n    let mut x528: u64 = 0;\n    let mut x529: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x528, &mut x529, x527, x503, x500);\n    let mut x530: u64 = 0;\n    let mut x531: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x530, &mut x531, x529, x501, x498);\n    let x532: u64 = ((x531 as u64) + x499);\n    let mut x533: u64 = 0;\n    let mut x534: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x533, &mut x534, 0x0, x476, x514);\n    let mut x535: u64 = 0;\n    let mut x536: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x535, &mut x536, x534, x478, x516);\n    let mut x537: u64 = 0;\n    let mut x538: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x537, &mut x538, x536, x480, x518);\n    let mut x539: u64 = 0;\n    let mut x540: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x539, &mut x540, x538, x482, x520);\n    let mut x541: u64 = 0;\n    let mut x542: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x541, &mut x542, x540, x484, x522);\n    let mut x543: u64 = 0;\n    let mut x544: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x543, &mut x544, x542, x486, x524);\n    let mut x545: u64 = 0;\n    let mut x546: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x545, &mut x546, x544, x488, x526);\n    let mut x547: u64 = 0;\n    let mut x548: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x547, &mut x548, x546, x490, x528);\n    let mut x549: u64 = 0;\n    let mut x550: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x549, &mut x550, x548, x492, x530);\n    let mut x551: u64 = 0;\n    let mut x552: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x551, &mut x552, x550, x494, x532);\n    let x553: u64 = ((x552 as u64) + (x495 as u64));\n    let mut x554: u64 = 0;\n    let mut x555: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x554, &mut x555, x5, (arg1[8]));\n    let mut x556: u64 = 0;\n    let mut x557: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x556, &mut x557, x5, (arg1[7]));\n    let mut x558: u64 = 0;\n    let mut x559: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x558, &mut x559, x5, (arg1[6]));\n    let mut x560: u64 = 0;\n    let mut x561: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x560, &mut x561, x5, (arg1[5]));\n    let mut x562: u64 = 0;\n    let mut x563: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x562, &mut x563, x5, (arg1[4]));\n    let mut x564: u64 = 0;\n    let mut x565: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x564, &mut x565, x5, (arg1[3]));\n    let mut x566: u64 = 0;\n    let mut x567: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x566, &mut x567, x5, (arg1[2]));\n    let mut x568: u64 = 0;\n    let mut x569: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x568, &mut x569, x5, (arg1[1]));\n    let mut x570: u64 = 0;\n    let mut x571: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x570, &mut x571, x5, (arg1[0]));\n    let mut x572: u64 = 0;\n    let mut x573: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x572, &mut x573, 0x0, x571, x568);\n    let mut x574: u64 = 0;\n    let mut x575: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x574, &mut x575, x573, x569, x566);\n    let mut x576: u64 = 0;\n    let mut x577: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x576, &mut x577, x575, x567, x564);\n    let mut x578: u64 = 0;\n    let mut x579: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x578, &mut x579, x577, x565, x562);\n    let mut x580: u64 = 0;\n    let mut x581: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x580, &mut x581, x579, x563, x560);\n    let mut x582: u64 = 0;\n    let mut x583: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x582, &mut x583, x581, x561, x558);\n    let mut x584: u64 = 0;\n    let mut x585: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x584, &mut x585, x583, x559, x556);\n    let mut x586: u64 = 0;\n    let mut x587: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x586, &mut x587, x585, x557, x554);\n    let x588: u64 = ((x587 as u64) + x555);\n    let mut x589: u64 = 0;\n    let mut x590: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x589, &mut x590, 0x0, x535, x570);\n    let mut x591: u64 = 0;\n    let mut x592: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x591, &mut x592, x590, x537, x572);\n    let mut x593: u64 = 0;\n    let mut x594: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x593, &mut x594, x592, x539, x574);\n    let mut x595: u64 = 0;\n    let mut x596: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x595, &mut x596, x594, x541, x576);\n    let mut x597: u64 = 0;\n    let mut x598: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x597, &mut x598, x596, x543, x578);\n    let mut x599: u64 = 0;\n    let mut x600: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x599, &mut x600, x598, x545, x580);\n    let mut x601: u64 = 0;\n    let mut x602: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x601, &mut x602, x600, x547, x582);\n    let mut x603: u64 = 0;\n    let mut x604: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x603, &mut x604, x602, x549, x584);\n    let mut x605: u64 = 0;\n    let mut x606: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x605, &mut x606, x604, x551, x586);\n    let mut x607: u64 = 0;\n    let mut x608: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x607, &mut x608, x606, x553, x588);\n    let mut x609: u64 = 0;\n    let mut x610: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x609, &mut x610, x589, 0x1d2f5ccd79a995c7);\n    let mut x611: u64 = 0;\n    let mut x612: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x611, &mut x612, x609, 0x1ff);\n    let mut x613: u64 = 0;\n    let mut x614: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x613, &mut x614, x609, 0xffffffffffffffff);\n    let mut x615: u64 = 0;\n    let mut x616: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x615, &mut x616, x609, 0xffffffffffffffff);\n    let mut x617: u64 = 0;\n    let mut x618: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x617, &mut x618, x609, 0xffffffffffffffff);\n    let mut x619: u64 = 0;\n    let mut x620: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x619, &mut x620, x609, 0xfffffffffffffffa);\n    let mut x621: u64 = 0;\n    let mut x622: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x621, &mut x622, x609, 0x51868783bf2f966b);\n    let mut x623: u64 = 0;\n    let mut x624: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x623, &mut x624, x609, 0x7fcc0148f709a5d0);\n    let mut x625: u64 = 0;\n    let mut x626: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x625, &mut x626, x609, 0x3bb5c9b8899c47ae);\n    let mut x627: u64 = 0;\n    let mut x628: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x627, &mut x628, x609, 0xbb6fb71e91386409);\n    let mut x629: u64 = 0;\n    let mut x630: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x629, &mut x630, 0x0, x628, x625);\n    let mut x631: u64 = 0;\n    let mut x632: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x631, &mut x632, x630, x626, x623);\n    let mut x633: u64 = 0;\n    let mut x634: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x633, &mut x634, x632, x624, x621);\n    let mut x635: u64 = 0;\n    let mut x636: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x635, &mut x636, x634, x622, x619);\n    let mut x637: u64 = 0;\n    let mut x638: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x637, &mut x638, x636, x620, x617);\n    let mut x639: u64 = 0;\n    let mut x640: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x639, &mut x640, x638, x618, x615);\n    let mut x641: u64 = 0;\n    let mut x642: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x641, &mut x642, x640, x616, x613);\n    let mut x643: u64 = 0;\n    let mut x644: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x643, &mut x644, x642, x614, x611);\n    let x645: u64 = ((x644 as u64) + x612);\n    let mut x646: u64 = 0;\n    let mut x647: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x646, &mut x647, 0x0, x589, x627);\n    let mut x648: u64 = 0;\n    let mut x649: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x648, &mut x649, x647, x591, x629);\n    let mut x650: u64 = 0;\n    let mut x651: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x650, &mut x651, x649, x593, x631);\n    let mut x652: u64 = 0;\n    let mut x653: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x652, &mut x653, x651, x595, x633);\n    let mut x654: u64 = 0;\n    let mut x655: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x654, &mut x655, x653, x597, x635);\n    let mut x656: u64 = 0;\n    let mut x657: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x656, &mut x657, x655, x599, x637);\n    let mut x658: u64 = 0;\n    let mut x659: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x658, &mut x659, x657, x601, x639);\n    let mut x660: u64 = 0;\n    let mut x661: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x660, &mut x661, x659, x603, x641);\n    let mut x662: u64 = 0;\n    let mut x663: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x662, &mut x663, x661, x605, x643);\n    let mut x664: u64 = 0;\n    let mut x665: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x664, &mut x665, x663, x607, x645);\n    let x666: u64 = ((x665 as u64) + (x608 as u64));\n    let mut x667: u64 = 0;\n    let mut x668: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x667, &mut x668, x6, (arg1[8]));\n    let mut x669: u64 = 0;\n    let mut x670: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x669, &mut x670, x6, (arg1[7]));\n    let mut x671: u64 = 0;\n    let mut x672: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x671, &mut x672, x6, (arg1[6]));\n    let mut x673: u64 = 0;\n    let mut x674: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x673, &mut x674, x6, (arg1[5]));\n    let mut x675: u64 = 0;\n    let mut x676: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x675, &mut x676, x6, (arg1[4]));\n    let mut x677: u64 = 0;\n    let mut x678: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x677, &mut x678, x6, (arg1[3]));\n    let mut x679: u64 = 0;\n    let mut x680: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x679, &mut x680, x6, (arg1[2]));\n    let mut x681: u64 = 0;\n    let mut x682: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x681, &mut x682, x6, (arg1[1]));\n    let mut x683: u64 = 0;\n    let mut x684: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x683, &mut x684, x6, (arg1[0]));\n    let mut x685: u64 = 0;\n    let mut x686: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x685, &mut x686, 0x0, x684, x681);\n    let mut x687: u64 = 0;\n    let mut x688: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x687, &mut x688, x686, x682, x679);\n    let mut x689: u64 = 0;\n    let mut x690: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x689, &mut x690, x688, x680, x677);\n    let mut x691: u64 = 0;\n    let mut x692: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x691, &mut x692, x690, x678, x675);\n    let mut x693: u64 = 0;\n    let mut x694: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x693, &mut x694, x692, x676, x673);\n    let mut x695: u64 = 0;\n    let mut x696: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x695, &mut x696, x694, x674, x671);\n    let mut x697: u64 = 0;\n    let mut x698: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x697, &mut x698, x696, x672, x669);\n    let mut x699: u64 = 0;\n    let mut x700: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x699, &mut x700, x698, x670, x667);\n    let x701: u64 = ((x700 as u64) + x668);\n    let mut x702: u64 = 0;\n    let mut x703: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x702, &mut x703, 0x0, x648, x683);\n    let mut x704: u64 = 0;\n    let mut x705: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x704, &mut x705, x703, x650, x685);\n    let mut x706: u64 = 0;\n    let mut x707: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x706, &mut x707, x705, x652, x687);\n    let mut x708: u64 = 0;\n    let mut x709: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x708, &mut x709, x707, x654, x689);\n    let mut x710: u64 = 0;\n    let mut x711: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x710, &mut x711, x709, x656, x691);\n    let mut x712: u64 = 0;\n    let mut x713: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x712, &mut x713, x711, x658, x693);\n    let mut x714: u64 = 0;\n    let mut x715: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x714, &mut x715, x713, x660, x695);\n    let mut x716: u64 = 0;\n    let mut x717: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x716, &mut x717, x715, x662, x697);\n    let mut x718: u64 = 0;\n    let mut x719: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x718, &mut x719, x717, x664, x699);\n    let mut x720: u64 = 0;\n    let mut x721: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x720, &mut x721, x719, x666, x701);\n    let mut x722: u64 = 0;\n    let mut x723: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x722, &mut x723, x702, 0x1d2f5ccd79a995c7);\n    let mut x724: u64 = 0;\n    let mut x725: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x724, &mut x725, x722, 0x1ff);\n    let mut x726: u64 = 0;\n    let mut x727: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x726, &mut x727, x722, 0xffffffffffffffff);\n    let mut x728: u64 = 0;\n    let mut x729: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x728, &mut x729, x722, 0xffffffffffffffff);\n    let mut x730: u64 = 0;\n    let mut x731: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x730, &mut x731, x722, 0xffffffffffffffff);\n    let mut x732: u64 = 0;\n    let mut x733: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x732, &mut x733, x722, 0xfffffffffffffffa);\n    let mut x734: u64 = 0;\n    let mut x735: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x734, &mut x735, x722, 0x51868783bf2f966b);\n    let mut x736: u64 = 0;\n    let mut x737: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x736, &mut x737, x722, 0x7fcc0148f709a5d0);\n    let mut x738: u64 = 0;\n    let mut x739: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x738, &mut x739, x722, 0x3bb5c9b8899c47ae);\n    let mut x740: u64 = 0;\n    let mut x741: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x740, &mut x741, x722, 0xbb6fb71e91386409);\n    let mut x742: u64 = 0;\n    let mut x743: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x742, &mut x743, 0x0, x741, x738);\n    let mut x744: u64 = 0;\n    let mut x745: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x744, &mut x745, x743, x739, x736);\n    let mut x746: u64 = 0;\n    let mut x747: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x746, &mut x747, x745, x737, x734);\n    let mut x748: u64 = 0;\n    let mut x749: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x748, &mut x749, x747, x735, x732);\n    let mut x750: u64 = 0;\n    let mut x751: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x750, &mut x751, x749, x733, x730);\n    let mut x752: u64 = 0;\n    let mut x753: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x752, &mut x753, x751, x731, x728);\n    let mut x754: u64 = 0;\n    let mut x755: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x754, &mut x755, x753, x729, x726);\n    let mut x756: u64 = 0;\n    let mut x757: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x756, &mut x757, x755, x727, x724);\n    let x758: u64 = ((x757 as u64) + x725);\n    let mut x759: u64 = 0;\n    let mut x760: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x759, &mut x760, 0x0, x702, x740);\n    let mut x761: u64 = 0;\n    let mut x762: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x761, &mut x762, x760, x704, x742);\n    let mut x763: u64 = 0;\n    let mut x764: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x763, &mut x764, x762, x706, x744);\n    let mut x765: u64 = 0;\n    let mut x766: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x765, &mut x766, x764, x708, x746);\n    let mut x767: u64 = 0;\n    let mut x768: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x767, &mut x768, x766, x710, x748);\n    let mut x769: u64 = 0;\n    let mut x770: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x769, &mut x770, x768, x712, x750);\n    let mut x771: u64 = 0;\n    let mut x772: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x771, &mut x772, x770, x714, x752);\n    let mut x773: u64 = 0;\n    let mut x774: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x773, &mut x774, x772, x716, x754);\n    let mut x775: u64 = 0;\n    let mut x776: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x775, &mut x776, x774, x718, x756);\n    let mut x777: u64 = 0;\n    let mut x778: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x777, &mut x778, x776, x720, x758);\n    let x779: u64 = ((x778 as u64) + (x721 as u64));\n    let mut x780: u64 = 0;\n    let mut x781: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x780, &mut x781, x7, (arg1[8]));\n    let mut x782: u64 = 0;\n    let mut x783: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x782, &mut x783, x7, (arg1[7]));\n    let mut x784: u64 = 0;\n    let mut x785: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x784, &mut x785, x7, (arg1[6]));\n    let mut x786: u64 = 0;\n    let mut x787: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x786, &mut x787, x7, (arg1[5]));\n    let mut x788: u64 = 0;\n    let mut x789: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x788, &mut x789, x7, (arg1[4]));\n    let mut x790: u64 = 0;\n    let mut x791: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x790, &mut x791, x7, (arg1[3]));\n    let mut x792: u64 = 0;\n    let mut x793: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x792, &mut x793, x7, (arg1[2]));\n    let mut x794: u64 = 0;\n    let mut x795: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x794, &mut x795, x7, (arg1[1]));\n    let mut x796: u64 = 0;\n    let mut x797: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x796, &mut x797, x7, (arg1[0]));\n    let mut x798: u64 = 0;\n    let mut x799: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x798, &mut x799, 0x0, x797, x794);\n    let mut x800: u64 = 0;\n    let mut x801: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x800, &mut x801, x799, x795, x792);\n    let mut x802: u64 = 0;\n    let mut x803: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x802, &mut x803, x801, x793, x790);\n    let mut x804: u64 = 0;\n    let mut x805: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x804, &mut x805, x803, x791, x788);\n    let mut x806: u64 = 0;\n    let mut x807: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x806, &mut x807, x805, x789, x786);\n    let mut x808: u64 = 0;\n    let mut x809: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x808, &mut x809, x807, x787, x784);\n    let mut x810: u64 = 0;\n    let mut x811: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x810, &mut x811, x809, x785, x782);\n    let mut x812: u64 = 0;\n    let mut x813: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x812, &mut x813, x811, x783, x780);\n    let x814: u64 = ((x813 as u64) + x781);\n    let mut x815: u64 = 0;\n    let mut x816: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x815, &mut x816, 0x0, x761, x796);\n    let mut x817: u64 = 0;\n    let mut x818: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x817, &mut x818, x816, x763, x798);\n    let mut x819: u64 = 0;\n    let mut x820: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x819, &mut x820, x818, x765, x800);\n    let mut x821: u64 = 0;\n    let mut x822: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x821, &mut x822, x820, x767, x802);\n    let mut x823: u64 = 0;\n    let mut x824: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x823, &mut x824, x822, x769, x804);\n    let mut x825: u64 = 0;\n    let mut x826: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x825, &mut x826, x824, x771, x806);\n    let mut x827: u64 = 0;\n    let mut x828: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x827, &mut x828, x826, x773, x808);\n    let mut x829: u64 = 0;\n    let mut x830: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x829, &mut x830, x828, x775, x810);\n    let mut x831: u64 = 0;\n    let mut x832: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x831, &mut x832, x830, x777, x812);\n    let mut x833: u64 = 0;\n    let mut x834: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x833, &mut x834, x832, x779, x814);\n    let mut x835: u64 = 0;\n    let mut x836: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x835, &mut x836, x815, 0x1d2f5ccd79a995c7);\n    let mut x837: u64 = 0;\n    let mut x838: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x837, &mut x838, x835, 0x1ff);\n    let mut x839: u64 = 0;\n    let mut x840: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x839, &mut x840, x835, 0xffffffffffffffff);\n    let mut x841: u64 = 0;\n    let mut x842: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x841, &mut x842, x835, 0xffffffffffffffff);\n    let mut x843: u64 = 0;\n    let mut x844: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x843, &mut x844, x835, 0xffffffffffffffff);\n    let mut x845: u64 = 0;\n    let mut x846: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x845, &mut x846, x835, 0xfffffffffffffffa);\n    let mut x847: u64 = 0;\n    let mut x848: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x847, &mut x848, x835, 0x51868783bf2f966b);\n    let mut x849: u64 = 0;\n    let mut x850: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x849, &mut x850, x835, 0x7fcc0148f709a5d0);\n    let mut x851: u64 = 0;\n    let mut x852: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x851, &mut x852, x835, 0x3bb5c9b8899c47ae);\n    let mut x853: u64 = 0;\n    let mut x854: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x853, &mut x854, x835, 0xbb6fb71e91386409);\n    let mut x855: u64 = 0;\n    let mut x856: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x855, &mut x856, 0x0, x854, x851);\n    let mut x857: u64 = 0;\n    let mut x858: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x857, &mut x858, x856, x852, x849);\n    let mut x859: u64 = 0;\n    let mut x860: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x859, &mut x860, x858, x850, x847);\n    let mut x861: u64 = 0;\n    let mut x862: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x861, &mut x862, x860, x848, x845);\n    let mut x863: u64 = 0;\n    let mut x864: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x863, &mut x864, x862, x846, x843);\n    let mut x865: u64 = 0;\n    let mut x866: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x865, &mut x866, x864, x844, x841);\n    let mut x867: u64 = 0;\n    let mut x868: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x867, &mut x868, x866, x842, x839);\n    let mut x869: u64 = 0;\n    let mut x870: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x869, &mut x870, x868, x840, x837);\n    let x871: u64 = ((x870 as u64) + x838);\n    let mut x872: u64 = 0;\n    let mut x873: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x872, &mut x873, 0x0, x815, x853);\n    let mut x874: u64 = 0;\n    let mut x875: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x874, &mut x875, x873, x817, x855);\n    let mut x876: u64 = 0;\n    let mut x877: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x876, &mut x877, x875, x819, x857);\n    let mut x878: u64 = 0;\n    let mut x879: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x878, &mut x879, x877, x821, x859);\n    let mut x880: u64 = 0;\n    let mut x881: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x880, &mut x881, x879, x823, x861);\n    let mut x882: u64 = 0;\n    let mut x883: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x882, &mut x883, x881, x825, x863);\n    let mut x884: u64 = 0;\n    let mut x885: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x884, &mut x885, x883, x827, x865);\n    let mut x886: u64 = 0;\n    let mut x887: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x886, &mut x887, x885, x829, x867);\n    let mut x888: u64 = 0;\n    let mut x889: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x888, &mut x889, x887, x831, x869);\n    let mut x890: u64 = 0;\n    let mut x891: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x890, &mut x891, x889, x833, x871);\n    let x892: u64 = ((x891 as u64) + (x834 as u64));\n    let mut x893: u64 = 0;\n    let mut x894: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x893, &mut x894, x8, (arg1[8]));\n    let mut x895: u64 = 0;\n    let mut x896: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x895, &mut x896, x8, (arg1[7]));\n    let mut x897: u64 = 0;\n    let mut x898: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x897, &mut x898, x8, (arg1[6]));\n    let mut x899: u64 = 0;\n    let mut x900: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x899, &mut x900, x8, (arg1[5]));\n    let mut x901: u64 = 0;\n    let mut x902: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x901, &mut x902, x8, (arg1[4]));\n    let mut x903: u64 = 0;\n    let mut x904: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x903, &mut x904, x8, (arg1[3]));\n    let mut x905: u64 = 0;\n    let mut x906: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x905, &mut x906, x8, (arg1[2]));\n    let mut x907: u64 = 0;\n    let mut x908: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x907, &mut x908, x8, (arg1[1]));\n    let mut x909: u64 = 0;\n    let mut x910: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x909, &mut x910, x8, (arg1[0]));\n    let mut x911: u64 = 0;\n    let mut x912: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x911, &mut x912, 0x0, x910, x907);\n    let mut x913: u64 = 0;\n    let mut x914: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x913, &mut x914, x912, x908, x905);\n    let mut x915: u64 = 0;\n    let mut x916: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x915, &mut x916, x914, x906, x903);\n    let mut x917: u64 = 0;\n    let mut x918: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x917, &mut x918, x916, x904, x901);\n    let mut x919: u64 = 0;\n    let mut x920: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x919, &mut x920, x918, x902, x899);\n    let mut x921: u64 = 0;\n    let mut x922: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x921, &mut x922, x920, x900, x897);\n    let mut x923: u64 = 0;\n    let mut x924: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x923, &mut x924, x922, x898, x895);\n    let mut x925: u64 = 0;\n    let mut x926: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x925, &mut x926, x924, x896, x893);\n    let x927: u64 = ((x926 as u64) + x894);\n    let mut x928: u64 = 0;\n    let mut x929: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x928, &mut x929, 0x0, x874, x909);\n    let mut x930: u64 = 0;\n    let mut x931: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x930, &mut x931, x929, x876, x911);\n    let mut x932: u64 = 0;\n    let mut x933: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x932, &mut x933, x931, x878, x913);\n    let mut x934: u64 = 0;\n    let mut x935: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x934, &mut x935, x933, x880, x915);\n    let mut x936: u64 = 0;\n    let mut x937: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x936, &mut x937, x935, x882, x917);\n    let mut x938: u64 = 0;\n    let mut x939: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x938, &mut x939, x937, x884, x919);\n    let mut x940: u64 = 0;\n    let mut x941: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x940, &mut x941, x939, x886, x921);\n    let mut x942: u64 = 0;\n    let mut x943: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x942, &mut x943, x941, x888, x923);\n    let mut x944: u64 = 0;\n    let mut x945: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x944, &mut x945, x943, x890, x925);\n    let mut x946: u64 = 0;\n    let mut x947: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x946, &mut x947, x945, x892, x927);\n    let mut x948: u64 = 0;\n    let mut x949: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x948, &mut x949, x928, 0x1d2f5ccd79a995c7);\n    let mut x950: u64 = 0;\n    let mut x951: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x950, &mut x951, x948, 0x1ff);\n    let mut x952: u64 = 0;\n    let mut x953: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x952, &mut x953, x948, 0xffffffffffffffff);\n    let mut x954: u64 = 0;\n    let mut x955: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x954, &mut x955, x948, 0xffffffffffffffff);\n    let mut x956: u64 = 0;\n    let mut x957: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x956, &mut x957, x948, 0xffffffffffffffff);\n    let mut x958: u64 = 0;\n    let mut x959: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x958, &mut x959, x948, 0xfffffffffffffffa);\n    let mut x960: u64 = 0;\n    let mut x961: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x960, &mut x961, x948, 0x51868783bf2f966b);\n    let mut x962: u64 = 0;\n    let mut x963: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x962, &mut x963, x948, 0x7fcc0148f709a5d0);\n    let mut x964: u64 = 0;\n    let mut x965: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x964, &mut x965, x948, 0x3bb5c9b8899c47ae);\n    let mut x966: u64 = 0;\n    let mut x967: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x966, &mut x967, x948, 0xbb6fb71e91386409);\n    let mut x968: u64 = 0;\n    let mut x969: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x968, &mut x969, 0x0, x967, x964);\n    let mut x970: u64 = 0;\n    let mut x971: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x970, &mut x971, x969, x965, x962);\n    let mut x972: u64 = 0;\n    let mut x973: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x972, &mut x973, x971, x963, x960);\n    let mut x974: u64 = 0;\n    let mut x975: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x974, &mut x975, x973, x961, x958);\n    let mut x976: u64 = 0;\n    let mut x977: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x976, &mut x977, x975, x959, x956);\n    let mut x978: u64 = 0;\n    let mut x979: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x978, &mut x979, x977, x957, x954);\n    let mut x980: u64 = 0;\n    let mut x981: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x980, &mut x981, x979, x955, x952);\n    let mut x982: u64 = 0;\n    let mut x983: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x982, &mut x983, x981, x953, x950);\n    let x984: u64 = ((x983 as u64) + x951);\n    let mut x985: u64 = 0;\n    let mut x986: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x985, &mut x986, 0x0, x928, x966);\n    let mut x987: u64 = 0;\n    let mut x988: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x987, &mut x988, x986, x930, x968);\n    let mut x989: u64 = 0;\n    let mut x990: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x989, &mut x990, x988, x932, x970);\n    let mut x991: u64 = 0;\n    let mut x992: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x991, &mut x992, x990, x934, x972);\n    let mut x993: u64 = 0;\n    let mut x994: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x993, &mut x994, x992, x936, x974);\n    let mut x995: u64 = 0;\n    let mut x996: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x995, &mut x996, x994, x938, x976);\n    let mut x997: u64 = 0;\n    let mut x998: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x997, &mut x998, x996, x940, x978);\n    let mut x999: u64 = 0;\n    let mut x1000: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x999, &mut x1000, x998, x942, x980);\n    let mut x1001: u64 = 0;\n    let mut x1002: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x1001, &mut x1002, x1000, x944, x982);\n    let mut x1003: u64 = 0;\n    let mut x1004: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x1003, &mut x1004, x1002, x946, x984);\n    let x1005: u64 = ((x1004 as u64) + (x947 as u64));\n    let mut x1006: u64 = 0;\n    let mut x1007: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1006, &mut x1007, 0x0, x987, 0xbb6fb71e91386409);\n    let mut x1008: u64 = 0;\n    let mut x1009: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1008, &mut x1009, x1007, x989, 0x3bb5c9b8899c47ae);\n    let mut x1010: u64 = 0;\n    let mut x1011: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1010, &mut x1011, x1009, x991, 0x7fcc0148f709a5d0);\n    let mut x1012: u64 = 0;\n    let mut x1013: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1012, &mut x1013, x1011, x993, 0x51868783bf2f966b);\n    let mut x1014: u64 = 0;\n    let mut x1015: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1014, &mut x1015, x1013, x995, 0xfffffffffffffffa);\n    let mut x1016: u64 = 0;\n    let mut x1017: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1016, &mut x1017, x1015, x997, 0xffffffffffffffff);\n    let mut x1018: u64 = 0;\n    let mut x1019: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1018, &mut x1019, x1017, x999, 0xffffffffffffffff);\n    let mut x1020: u64 = 0;\n    let mut x1021: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1020, &mut x1021, x1019, x1001, 0xffffffffffffffff);\n    let mut x1022: u64 = 0;\n    let mut x1023: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1022, &mut x1023, x1021, x1003, 0x1ff);\n    let mut x1024: u64 = 0;\n    let mut x1025: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1024, &mut x1025, x1023, x1005, (0x0 as u64));\n    let mut x1026: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1026, x1025, x1006, x987);\n    let mut x1027: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1027, x1025, x1008, x989);\n    let mut x1028: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1028, x1025, x1010, x991);\n    let mut x1029: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1029, x1025, x1012, x993);\n    let mut x1030: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1030, x1025, x1014, x995);\n    let mut x1031: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1031, x1025, x1016, x997);\n    let mut x1032: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1032, x1025, x1018, x999);\n    let mut x1033: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1033, x1025, x1020, x1001);\n    let mut x1034: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1034, x1025, x1022, x1003);\n    out1[0] = x1026;\n    out1[1] = x1027;\n    out1[2] = x1028;\n    out1[3] = x1029;\n    out1[4] = x1030;\n    out1[5] = x1031;\n    out1[6] = x1032;\n    out1[7] = x1033;\n    out1[8] = x1034;\n}",
    "display_name": "fiat_p521_scalar_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_zero",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    pub fn from_bytes(bytes: &SignatureBytes) -> Result<Self> {\n        let components = FieldBytes::slice_as_chunks(bytes).0;\n        let r_bytes = components[0];\n        let s_bytes = components[1];\n\n        let r = FieldElement::from_bytes(&r_bytes)\n            .into_option()\n            .ok_or_else(Error::new)?;\n\n        // one of the rules for valid signatures: !is_infinite(R);\n        if r.is_zero().into() {\n            return Err(Error::new());\n        }\n\n        let s = NonZeroScalar::try_from(s_bytes.as_slice()).map_err(|_| Error::new())?;\n\n        Ok(Self { r, s })\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add"
    ],
    "body": "    fn add(self, rhs: FieldElement) -> FieldElement {\n        Self::add(&self, &rhs)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_roundtrip_to_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes_unchecked"
    ],
    "body": "        fn fuzzy_roundtrip_to_bytes_unchecked(a in scalar()) {\n            let bytes = a.to_bytes();\n            let a_back = Scalar::from_bytes_unchecked(bytes.as_ref());\n            assert_eq!(a, a_back);\n        }",
    "display_name": "fuzzy_roundtrip_to_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/SignatureEncoding/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        self.into()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/projective_add_and_sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn projective_add_and_sub() {\n        let basepoint_affine = AffinePoint::GENERATOR;\n        let basepoint_projective = ProjectivePoint::GENERATOR;\n\n        assert_eq!(\n            (basepoint_projective + &basepoint_projective) - &basepoint_projective,\n            basepoint_projective\n        );\n        assert_eq!(\n            (basepoint_projective + &basepoint_affine) - &basepoint_affine,\n            basepoint_projective\n        );\n    }",
    "display_name": "projective_add_and_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/tests/identity_encoding",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/GroupEncoding/to_bytes",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/GroupEncoding/from_bytes",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/is_identity"
    ],
    "body": "    fn identity_encoding() {\n        // This is technically an invalid SEC1 encoding, but is preferable to panicking.\n        assert_eq!([0; 33], AffinePoint::IDENTITY.to_bytes().as_slice());\n        assert!(bool::from(\n            AffinePoint::from_bytes(&AffinePoint::IDENTITY.to_bytes())\n                .unwrap()\n                .is_identity()\n        ))\n    }",
    "display_name": "identity_encoding",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "    fn reduce_bytes(bytes: &FieldBytes) -> Self {\n        Self::reduce(U384::from_be_byte_array(*bytes))\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/DecompactPoint/decompact",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/DecompressPoint/decompress"
    ],
    "body": "    fn decompact(x_bytes: &FieldBytes) -> CtOption<Self> {\n        Self::decompress(x_bytes, Choice::from(0))\n    }",
    "display_name": "decompact",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/GroupEncoding/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/decompress"
    ],
    "body": "    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        let pt = CompressedDecaf(*(bytes.as_ref()));\n        pt.decompress()\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_from_bytes"
    ],
    "body": "    pub(crate) const fn from_uint_unchecked(w: U576) -> Self {\n        // Converts the saturated representation used by `U576` into a 66-byte array with a\n        // little-endian byte ordering.\n        // TODO(tarcieri): use `FieldBytesEncoding::encode_field_bytes` when `const impl` is stable\n        let le_bytes_wide = w.to_le_bytes();\n\n        let mut le_bytes = [0u8; 66];\n        let mut i = 0;\n\n        // Extract the first 66-bytes of the 72-byte (576-bit) little endian serialized value\n        while i < le_bytes.len() {\n            le_bytes[i] = le_bytes_wide[i];\n            i += 1;\n        }\n\n        // Decode the little endian serialization into the unsaturated big integer form used by\n        // the fiat-crypto synthesized code.\n        let mut out = fiat_p521_tight_field_element([0; 9]);\n        fiat_p521_from_bytes(&mut out, &le_bytes);\n        Self(out)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/generate_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/generate_vartime"
    ],
    "body": "    fn generate_vartime() {\n        let a = Scalar::generate_vartime(&mut OsRng).unwrap();\n        // just to make sure `a` is not optimized out by the compiler\n        assert_eq!((a - &a).is_zero().unwrap_u8(), 1);\n    }",
    "display_name": "generate_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/BatchNormalize/batch_normalize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/batch_normalize_generic"
    ],
    "body": "    fn batch_normalize(points: &[Self; N]) -> [<Self as CurveGroup>::AffineRepr; N] {\n        let zs = [FieldElement::ONE; N];\n        let mut affine_points = [AffinePoint::IDENTITY; N];\n        batch_normalize_generic(points, zs, &mut affine_points);\n        affine_points\n    }",
    "display_name": "batch_normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_set_one(out1: &mut fiat_p224_scalar_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = 0xa3a3d5c300000000;\n    out1[1] = 0x1f470fc1ec22d6ba;\n    out1[2] = 0xe95d;\n    out1[3] = (0x0 as u64);\n}",
    "display_name": "fiat_p224_scalar_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/&ProjectivePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add(self, other: &AffinePoint) -> ProjectivePoint {\n        ProjectivePoint::add_mixed(self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/SignatureEncoding/encoded_len",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encoded_len(&self) -> usize {\n        Self::BYTE_SIZE\n    }",
    "display_name": "encoded_len",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add_assign(&mut self, rhs: Scalar) {\n        *self = Scalar::add(self, &rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_add(\n    out1: &mut fiat_bign256_montgomery_domain_field_element,\n    arg1: &fiat_bign256_montgomery_domain_field_element,\n    arg2: &fiat_bign256_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x9, &mut x10, 0x0, x1, 0xffffffffffffff43);\n    let mut x11: u64 = 0;\n    let mut x12: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x11, &mut x12, x10, x3, 0xffffffffffffffff);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x13, &mut x14, x12, x5, 0xffffffffffffffff);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x15, &mut x16, x14, x7, 0xffffffffffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x17, &mut x18, x16, (x8 as u64), (0x0 as u64));\n    let mut x19: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x19, x18, x9, x1);\n    let mut x20: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x20, x18, x11, x3);\n    let mut x21: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x21, x18, x13, x5);\n    let mut x22: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x22, x18, x15, x7);\n    out1[0] = x19;\n    out1[1] = x20;\n    out1[2] = x21;\n    out1[3] = x22;\n}",
    "display_name": "fiat_bign256_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/pow_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Product/product",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul"
    ],
    "body": "    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Mul::mul).unwrap_or(Self::ONE)\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/from_slice",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<Self> {\n        SignatureBytes::try_from(bytes)\n            .map_err(|_| Error::new())?\n            .try_into()\n    }",
    "display_name": "from_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/sqrt_ratio",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sqrt_ratio(num: &Self, div: &Self) -> (Choice, Self) {\n        ff::helpers::sqrt_ratio_generic(num, div)\n    }",
    "display_name": "sqrt_ratio",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sub"
    ],
    "body": "    pub const fn neg(&self) -> Self {\n        Self::sub(&Self::ZERO, self)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/Ed448/MapToCurve/map_to_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/map_to_curve_elligator2",
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    fn map_to_curve(element: FieldElement) -> Self::CurvePoint {\n        element.map_to_curve_elligator2().to_edwards()\n    }",
    "display_name": "map_to_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_sqrt<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"sqrt\", |b| b.iter(|| x.sqrt()));\n}",
    "display_name": "bench_field_element_sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/field.rs",
    "relative_path": "p384/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(bytes.as_slice())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::ZERO\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.0[0].ct_eq(&other.0[0])\n            & self.0[1].ct_eq(&other.0[1])\n            & self.0[2].ct_eq(&other.0[2])\n            & self.0[3].ct_eq(&other.0[3])\n            & self.0[4].ct_eq(&other.0[4])\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/delta_constant",
    "statement_type": "function",
    "deps": [],
    "body": "    fn delta_constant() {\n        // DELTA^{t} mod m == 1\n        assert_eq!(Scalar::DELTA.pow_vartime(T), Scalar::ONE);\n    }",
    "display_name": "delta_constant",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    fn try_from(value: PointBytes) -> Result<Self, Self::Error> {\n        Option::<Self>::from(CompressedEdwardsY(value).decompress()).ok_or(\"Invalid point\")\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/&FieldElement/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/add"
    ],
    "body": "    fn add(self, other: &FieldElement) -> FieldElement {\n        FieldElement(self.0.add(&(other.0)))\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/batch_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn batch_invert() {\n        let k: Scalar = Scalar::random(&mut OsRng.unwrap_mut());\n        let l: Scalar = Scalar::random(&mut OsRng.unwrap_mut());\n\n        let expected = vec![k.invert().unwrap(), l.invert().unwrap()];\n        let scalars = vec![k, l];\n        let res = <Scalar as BatchInvert<_>>::batch_invert(scalars).unwrap();\n        assert_eq!(res, expected);\n    }",
    "display_name": "batch_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/to_nonzero_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_nonzero_scalar(&self) -> NonZeroScalar {\n        (*self).into()\n    }",
    "display_name": "to_nonzero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = &'a ProjectivePoint>>(iter: I) -> Self {\n        iter.cloned().sum()\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Sub>/sub",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub(self, other: &AffinePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::sub_mixed(&self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_uint_unchecked(uint: Self::Uint) -> Self {\n        Self(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_from_bytes(out1: &mut [u64; 4], arg1: &[u8; 32]) {\n    let x1: u64 = (((arg1[31]) as u64) << 56);\n    let x2: u64 = (((arg1[30]) as u64) << 48);\n    let x3: u64 = (((arg1[29]) as u64) << 40);\n    let x4: u64 = (((arg1[28]) as u64) << 32);\n    let x5: u64 = (((arg1[27]) as u64) << 24);\n    let x6: u64 = (((arg1[26]) as u64) << 16);\n    let x7: u64 = (((arg1[25]) as u64) << 8);\n    let x8: u8 = (arg1[24]);\n    let x9: u64 = (((arg1[23]) as u64) << 56);\n    let x10: u64 = (((arg1[22]) as u64) << 48);\n    let x11: u64 = (((arg1[21]) as u64) << 40);\n    let x12: u64 = (((arg1[20]) as u64) << 32);\n    let x13: u64 = (((arg1[19]) as u64) << 24);\n    let x14: u64 = (((arg1[18]) as u64) << 16);\n    let x15: u64 = (((arg1[17]) as u64) << 8);\n    let x16: u8 = (arg1[16]);\n    let x17: u64 = (((arg1[15]) as u64) << 56);\n    let x18: u64 = (((arg1[14]) as u64) << 48);\n    let x19: u64 = (((arg1[13]) as u64) << 40);\n    let x20: u64 = (((arg1[12]) as u64) << 32);\n    let x21: u64 = (((arg1[11]) as u64) << 24);\n    let x22: u64 = (((arg1[10]) as u64) << 16);\n    let x23: u64 = (((arg1[9]) as u64) << 8);\n    let x24: u8 = (arg1[8]);\n    let x25: u64 = (((arg1[7]) as u64) << 56);\n    let x26: u64 = (((arg1[6]) as u64) << 48);\n    let x27: u64 = (((arg1[5]) as u64) << 40);\n    let x28: u64 = (((arg1[4]) as u64) << 32);\n    let x29: u64 = (((arg1[3]) as u64) << 24);\n    let x30: u64 = (((arg1[2]) as u64) << 16);\n    let x31: u64 = (((arg1[1]) as u64) << 8);\n    let x32: u8 = (arg1[0]);\n    let x33: u64 = (x31 + (x32 as u64));\n    let x34: u64 = (x30 + x33);\n    let x35: u64 = (x29 + x34);\n    let x36: u64 = (x28 + x35);\n    let x37: u64 = (x27 + x36);\n    let x38: u64 = (x26 + x37);\n    let x39: u64 = (x25 + x38);\n    let x40: u64 = (x23 + (x24 as u64));\n    let x41: u64 = (x22 + x40);\n    let x42: u64 = (x21 + x41);\n    let x43: u64 = (x20 + x42);\n    let x44: u64 = (x19 + x43);\n    let x45: u64 = (x18 + x44);\n    let x46: u64 = (x17 + x45);\n    let x47: u64 = (x15 + (x16 as u64));\n    let x48: u64 = (x14 + x47);\n    let x49: u64 = (x13 + x48);\n    let x50: u64 = (x12 + x49);\n    let x51: u64 = (x11 + x50);\n    let x52: u64 = (x10 + x51);\n    let x53: u64 = (x9 + x52);\n    let x54: u64 = (x7 + (x8 as u64));\n    let x55: u64 = (x6 + x54);\n    let x56: u64 = (x5 + x55);\n    let x57: u64 = (x4 + x56);\n    let x58: u64 = (x3 + x57);\n    let x59: u64 = (x2 + x58);\n    let x60: u64 = (x1 + x59);\n    out1[0] = x39;\n    out1[1] = x46;\n    out1[2] = x53;\n    out1[3] = x60;\n}",
    "display_name": "fiat_sm2_scalar_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, scalar: Scalar) -> DecafPoint {\n        &self * scalar\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_to_bytes(out1: &mut [u8; 48], arg1: &[u64; 6]) {\n    let x1: u64 = (arg1[5]);\n    let x2: u64 = (arg1[4]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[2]);\n    let x5: u64 = (arg1[1]);\n    let x6: u64 = (arg1[0]);\n    let x7: u8 = ((x6 & (0xff as u64)) as u8);\n    let x8: u64 = (x6 >> 8);\n    let x9: u8 = ((x8 & (0xff as u64)) as u8);\n    let x10: u64 = (x8 >> 8);\n    let x11: u8 = ((x10 & (0xff as u64)) as u8);\n    let x12: u64 = (x10 >> 8);\n    let x13: u8 = ((x12 & (0xff as u64)) as u8);\n    let x14: u64 = (x12 >> 8);\n    let x15: u8 = ((x14 & (0xff as u64)) as u8);\n    let x16: u64 = (x14 >> 8);\n    let x17: u8 = ((x16 & (0xff as u64)) as u8);\n    let x18: u64 = (x16 >> 8);\n    let x19: u8 = ((x18 & (0xff as u64)) as u8);\n    let x20: u8 = ((x18 >> 8) as u8);\n    let x21: u8 = ((x5 & (0xff as u64)) as u8);\n    let x22: u64 = (x5 >> 8);\n    let x23: u8 = ((x22 & (0xff as u64)) as u8);\n    let x24: u64 = (x22 >> 8);\n    let x25: u8 = ((x24 & (0xff as u64)) as u8);\n    let x26: u64 = (x24 >> 8);\n    let x27: u8 = ((x26 & (0xff as u64)) as u8);\n    let x28: u64 = (x26 >> 8);\n    let x29: u8 = ((x28 & (0xff as u64)) as u8);\n    let x30: u64 = (x28 >> 8);\n    let x31: u8 = ((x30 & (0xff as u64)) as u8);\n    let x32: u64 = (x30 >> 8);\n    let x33: u8 = ((x32 & (0xff as u64)) as u8);\n    let x34: u8 = ((x32 >> 8) as u8);\n    let x35: u8 = ((x4 & (0xff as u64)) as u8);\n    let x36: u64 = (x4 >> 8);\n    let x37: u8 = ((x36 & (0xff as u64)) as u8);\n    let x38: u64 = (x36 >> 8);\n    let x39: u8 = ((x38 & (0xff as u64)) as u8);\n    let x40: u64 = (x38 >> 8);\n    let x41: u8 = ((x40 & (0xff as u64)) as u8);\n    let x42: u64 = (x40 >> 8);\n    let x43: u8 = ((x42 & (0xff as u64)) as u8);\n    let x44: u64 = (x42 >> 8);\n    let x45: u8 = ((x44 & (0xff as u64)) as u8);\n    let x46: u64 = (x44 >> 8);\n    let x47: u8 = ((x46 & (0xff as u64)) as u8);\n    let x48: u8 = ((x46 >> 8) as u8);\n    let x49: u8 = ((x3 & (0xff as u64)) as u8);\n    let x50: u64 = (x3 >> 8);\n    let x51: u8 = ((x50 & (0xff as u64)) as u8);\n    let x52: u64 = (x50 >> 8);\n    let x53: u8 = ((x52 & (0xff as u64)) as u8);\n    let x54: u64 = (x52 >> 8);\n    let x55: u8 = ((x54 & (0xff as u64)) as u8);\n    let x56: u64 = (x54 >> 8);\n    let x57: u8 = ((x56 & (0xff as u64)) as u8);\n    let x58: u64 = (x56 >> 8);\n    let x59: u8 = ((x58 & (0xff as u64)) as u8);\n    let x60: u64 = (x58 >> 8);\n    let x61: u8 = ((x60 & (0xff as u64)) as u8);\n    let x62: u8 = ((x60 >> 8) as u8);\n    let x63: u8 = ((x2 & (0xff as u64)) as u8);\n    let x64: u64 = (x2 >> 8);\n    let x65: u8 = ((x64 & (0xff as u64)) as u8);\n    let x66: u64 = (x64 >> 8);\n    let x67: u8 = ((x66 & (0xff as u64)) as u8);\n    let x68: u64 = (x66 >> 8);\n    let x69: u8 = ((x68 & (0xff as u64)) as u8);\n    let x70: u64 = (x68 >> 8);\n    let x71: u8 = ((x70 & (0xff as u64)) as u8);\n    let x72: u64 = (x70 >> 8);\n    let x73: u8 = ((x72 & (0xff as u64)) as u8);\n    let x74: u64 = (x72 >> 8);\n    let x75: u8 = ((x74 & (0xff as u64)) as u8);\n    let x76: u8 = ((x74 >> 8) as u8);\n    let x77: u8 = ((x1 & (0xff as u64)) as u8);\n    let x78: u64 = (x1 >> 8);\n    let x79: u8 = ((x78 & (0xff as u64)) as u8);\n    let x80: u64 = (x78 >> 8);\n    let x81: u8 = ((x80 & (0xff as u64)) as u8);\n    let x82: u64 = (x80 >> 8);\n    let x83: u8 = ((x82 & (0xff as u64)) as u8);\n    let x84: u64 = (x82 >> 8);\n    let x85: u8 = ((x84 & (0xff as u64)) as u8);\n    let x86: u64 = (x84 >> 8);\n    let x87: u8 = ((x86 & (0xff as u64)) as u8);\n    let x88: u64 = (x86 >> 8);\n    let x89: u8 = ((x88 & (0xff as u64)) as u8);\n    let x90: u8 = ((x88 >> 8) as u8);\n    out1[0] = x7;\n    out1[1] = x9;\n    out1[2] = x11;\n    out1[3] = x13;\n    out1[4] = x15;\n    out1[5] = x17;\n    out1[6] = x19;\n    out1[7] = x20;\n    out1[8] = x21;\n    out1[9] = x23;\n    out1[10] = x25;\n    out1[11] = x27;\n    out1[12] = x29;\n    out1[13] = x31;\n    out1[14] = x33;\n    out1[15] = x34;\n    out1[16] = x35;\n    out1[17] = x37;\n    out1[18] = x39;\n    out1[19] = x41;\n    out1[20] = x43;\n    out1[21] = x45;\n    out1[22] = x47;\n    out1[23] = x48;\n    out1[24] = x49;\n    out1[25] = x51;\n    out1[26] = x53;\n    out1[27] = x55;\n    out1[28] = x57;\n    out1[29] = x59;\n    out1[30] = x61;\n    out1[31] = x62;\n    out1[32] = x63;\n    out1[33] = x65;\n    out1[34] = x67;\n    out1[35] = x69;\n    out1[36] = x71;\n    out1[37] = x73;\n    out1[38] = x75;\n    out1[39] = x76;\n    out1[40] = x77;\n    out1[41] = x79;\n    out1[42] = x81;\n    out1[43] = x83;\n    out1[44] = x85;\n    out1[45] = x87;\n    out1[46] = x89;\n    out1[47] = x90;\n}",
    "display_name": "fiat_p384_scalar_to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/multiply"
    ],
    "body": "    fn mul(self, rhs: &Scalar) -> Self::Output {\n        self.multiply(rhs)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: &NonZeroScalar) -> Self {\n        *scalar.as_ref()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SigningKey\")\n            .field(\"verifying_key\", &self.verifying_key)\n            .finish_non_exhaustive()\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/verifying_key",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn verifying_key(&self) -> VerifyingKey {\n        self.secret.public_key\n    }",
    "display_name": "verifying_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "affine/impl/AffinePoint/PrimeCurveAffine/generator",
    "statement_type": "function",
    "deps": [],
    "body": "    fn generator() -> AffinePoint<C> {\n        Self::GENERATOR\n    }",
    "display_name": "generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> Scalar {\n        Scalar::ZERO - self\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/negate",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/max_magnitude",
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/negate"
    ],
    "body": "    pub fn negate(&self, magnitude: u32) -> Self {\n        debug_assert!(self.magnitude <= magnitude);\n        let new_magnitude = magnitude + 1;\n        debug_assert!(new_magnitude <= FieldElementUnsafeImpl::max_magnitude());\n        Self::new(&(self.value.negate(magnitude)), new_magnitude)\n    }",
    "display_name": "negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_raw"
    ],
    "body": "    fn verify(&self, msg: &[u8], signature: &Signature) -> Result<(), Error> {\n        self.verify_raw(signature, msg)\n    }",
    "display_name": "verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    fn from(value: AffinePoint) -> Self {\n        value.to_edwards()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 ristretto/points/impl/RistrettoPoint/equals",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn equals(&self, other: &RistrettoPoint) -> bool {\n        let XY = self.0.X * other.0.Y;\n        let YX = self.0.Y * other.0.X;\n        XY == YX\n    }",
    "display_name": "equals",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/ristretto/points.rs",
    "relative_path": "ed448-goldilocks/src/ristretto/points.rs",
    "file_name": "points.rs",
    "parent_folder": "ristretto"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square"
    ],
    "body": "    fn square(&self) -> Self {\n        Scalar::square(self)\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/from_bytes"
    ],
    "body": "    fn try_from(signature: &SignatureBytes) -> Result<Signature> {\n        Signature::from_bytes(signature)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x",
      "0.14.0_pre.8 test_field_element_y"
    ],
    "body": "fn bench_field_element_mul<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    let y = test_field_element_y();\n    group.bench_function(\"mul\", |b| b.iter(|| &x * &y));\n}",
    "display_name": "bench_field_element_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/field.rs",
    "relative_path": "p256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/new",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn new(x: FieldElement, y: FieldElement) -> Self {\n        Self { x, y, infinity: 0 }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &FieldElement) -> FieldElement {\n        self + -other\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/neg"
    ],
    "body": "    fn neg(self) -> Scalar {\n        Self::neg(&self)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn from(p: &ProjectivePoint<C>) -> AffinePoint<C> {\n        p.to_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point_mul_by_generator",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Group/mul_by_generator"
    ],
    "body": "fn bench_point_mul_by_generator<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let p = ProjectivePoint::GENERATOR;\n    let x = test_scalar_x();\n\n    group.bench_function(\"mul_by_generator naive\", |b| {\n        b.iter(|| black_box(p) * black_box(x))\n    });\n\n    group.bench_function(\"mul_by_generator precomputed\", |b| {\n        b.iter(|| ProjectivePoint::mul_by_generator(&black_box(x)))\n    });\n}",
    "display_name": "bench_point_mul_by_generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/square",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_mulx_u64"
    ],
    "body": "pub const fn fiat_p192_scalar_to_montgomery(\n    out1: &mut fiat_p192_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p192_scalar_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[0]);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x4, &mut x5, x3, 0x28be5677ea0581a2);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x6, &mut x7, x3, 0x4696ea5bbb3a6bee);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x8, &mut x9, x3, 0xce66baccdeb35961);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x9, x6);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x7, x4);\n    let mut x14: u64 = 0;\n    let mut x15: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x14, &mut x15, x8, 0x882672070ddbcf2f);\n    let mut x16: u64 = 0;\n    let mut x17: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x16, &mut x17, x14, 0xffffffffffffffff);\n    let mut x18: u64 = 0;\n    let mut x19: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x18, &mut x19, x14, 0xffffffff99def836);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x20, &mut x21, x14, 0x146bc9b1b4d22831);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x22, &mut x23, 0x0, x21, x18);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x24, &mut x25, x23, x19, x16);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x26, &mut x27, 0x0, x8, x20);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x28, &mut x29, x27, x10, x22);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x12, x24);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(\n        &mut x32,\n        &mut x33,\n        x31,\n        ((x13 as u64) + x5),\n        ((x25 as u64) + x17),\n    );\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x34, &mut x35, x1, 0x28be5677ea0581a2);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x36, &mut x37, x1, 0x4696ea5bbb3a6bee);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x38, &mut x39, x1, 0xce66baccdeb35961);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x40, &mut x41, 0x0, x39, x36);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x42, &mut x43, x41, x37, x34);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x44, &mut x45, 0x0, x28, x38);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x46, &mut x47, x45, x30, x40);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x48, &mut x49, x47, x32, x42);\n    let mut x50: u64 = 0;\n    let mut x51: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x50, &mut x51, x44, 0x882672070ddbcf2f);\n    let mut x52: u64 = 0;\n    let mut x53: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x52, &mut x53, x50, 0xffffffffffffffff);\n    let mut x54: u64 = 0;\n    let mut x55: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x54, &mut x55, x50, 0xffffffff99def836);\n    let mut x56: u64 = 0;\n    let mut x57: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x56, &mut x57, x50, 0x146bc9b1b4d22831);\n    let mut x58: u64 = 0;\n    let mut x59: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x58, &mut x59, 0x0, x57, x54);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x60, &mut x61, x59, x55, x52);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x44, x56);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x46, x58);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x48, x60);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(\n        &mut x68,\n        &mut x69,\n        x67,\n        (((x49 as u64) + (x33 as u64)) + ((x43 as u64) + x35)),\n        ((x61 as u64) + x53),\n    );\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x70, &mut x71, x2, 0x28be5677ea0581a2);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x72, &mut x73, x2, 0x4696ea5bbb3a6bee);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x74, &mut x75, x2, 0xce66baccdeb35961);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x76, &mut x77, 0x0, x75, x72);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x78, &mut x79, x77, x73, x70);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x80, &mut x81, 0x0, x64, x74);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x66, x76);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x68, x78);\n    let mut x86: u64 = 0;\n    let mut x87: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x86, &mut x87, x80, 0x882672070ddbcf2f);\n    let mut x88: u64 = 0;\n    let mut x89: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x88, &mut x89, x86, 0xffffffffffffffff);\n    let mut x90: u64 = 0;\n    let mut x91: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x90, &mut x91, x86, 0xffffffff99def836);\n    let mut x92: u64 = 0;\n    let mut x93: u64 = 0;\n    fiat_p192_scalar_mulx_u64(&mut x92, &mut x93, x86, 0x146bc9b1b4d22831);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x94, &mut x95, 0x0, x93, x90);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x91, x88);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x98, &mut x99, 0x0, x80, x92);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x82, x94);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(&mut x102, &mut x103, x101, x84, x96);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_addcarryx_u64(\n        &mut x104,\n        &mut x105,\n        x103,\n        (((x85 as u64) + (x69 as u64)) + ((x79 as u64) + x71)),\n        ((x97 as u64) + x89),\n    );\n    let mut x106: u64 = 0;\n    let mut x107: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x106, &mut x107, 0x0, x100, 0x146bc9b1b4d22831);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x108, &mut x109, x107, x102, 0xffffffff99def836);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x110, &mut x111, x109, x104, 0xffffffffffffffff);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p192_scalar_u1 = 0;\n    fiat_p192_scalar_subborrowx_u64(&mut x112, &mut x113, x111, (x105 as u64), (0x0 as u64));\n    let mut x114: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x114, x113, x106, x100);\n    let mut x115: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x115, x113, x108, x102);\n    let mut x116: u64 = 0;\n    fiat_p192_scalar_cmovznz_u64(&mut x116, x113, x110, x104);\n    out1[0] = x114;\n    out1[1] = x115;\n    out1[2] = x116;\n}",
    "display_name": "fiat_p192_scalar_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl//u8; _//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/to_bytes"
    ],
    "body": "    fn from(signature: Signature) -> SignatureBytes {\n        signature.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/mul"
    ],
    "body": "    fn mul_assign(&mut self, rhs: &Scalar) {\n        *self = mul(self, rhs);\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/impl/InnerSignature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_canonical_bytes",
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/decompress",
      "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/From/from"
    ],
    "body": "    fn try_from(signature: &Signature) -> Result<Self, Self::Error> {\n        let s_bytes: &Array<u8, _> = (signature.s_bytes()).into();\n        let s = Option::from(Scalar::from_canonical_bytes(s_bytes))\n            .ok_or(SigningError::InvalidSignatureSComponent)?;\n        let r = Option::from(CompressedEdwardsY::from(*signature.r_bytes()).decompress())\n            .ok_or(SigningError::InvalidSignatureRComponent)?;\n        Ok(Self { r, s })\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign.rs",
    "relative_path": "ed448-goldilocks/src/sign.rs",
    "file_name": "sign.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, point: &MontgomeryPoint) -> MontgomeryPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/add"
    ],
    "body": "    pub const fn double(&self) -> Self {\n        self.add(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.0.ct_eq(&other.0)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/EncodePublicKey/to_public_key_der",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/PublicKeyBytes/From/from"
    ],
    "body": "    fn to_public_key_der(&self) -> pkcs8::spki::Result<pkcs8::Document> {\n        PublicKeyBytes::from(*self).to_public_key_der()\n    }",
    "display_name": "to_public_key_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        DecafPoint(ExtendedPoint {\n            X: FieldElement::conditional_select(&a.0.X, &b.0.X, choice),\n            Y: FieldElement::conditional_select(&a.0.Y, &b.0.Y, choice),\n            Z: FieldElement::conditional_select(&a.0.Z, &b.0.Z, choice),\n            T: FieldElement::conditional_select(&a.0.T, &b.0.T, choice),\n        })\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/neg"
    ],
    "body": "    fn neg(self) -> FieldElement {\n        Self::neg(&self)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: &DecafPoint) {\n        *self = *self - other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn reduce(w: Uint) -> Self {\n        let (r, underflow) = w.borrowing_sub(&NistP224::ORDER, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self::from_uint_unchecked(Uint::conditional_select(&w, &r, !underflow))\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt_der_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt_digest"
    ],
    "body": "    pub fn decrypt_der_digest<D>(&self, ciphertext: &[u8]) -> Result<Vec<u8>>\n    where\n        D: 'static + Digest + DynDigest + Send + Sync,\n    {\n        let cipher = Cipher::from_der(ciphertext).map_err(elliptic_curve::pkcs8::Error::from)?;\n        let prefix: &[u8] = &[0x04];\n        let x: [u8; 32] = cipher.x.to_be_bytes();\n        let y: [u8; 32] = cipher.y.to_be_bytes();\n        let cipher = match self.mode {\n            Mode::C1C2C3 => [prefix, &x, &y, cipher.cipher, cipher.digest].concat(),\n            Mode::C1C3C2 => [prefix, &x, &y, cipher.digest, cipher.cipher].concat(),\n        };\n\n        Ok(self.decrypt_digest::<D>(&cipher)?.to_vec())\n    }",
    "display_name": "decrypt_der_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/mul"
    ],
    "body": "    pub fn mul(&self, rhs: &Self) -> Self {\n        Self(self.0.mul(&(rhs.0)))\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Sum/sum",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Add/add"
    ],
    "body": "    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Add::add).unwrap_or(Self::ZERO)\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/tests/test_lincomb_slice",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/LinearCombination/lincomb"
    ],
    "body": "    fn test_lincomb_slice() {\n        let x = ProjectivePoint::random(&mut OsRng.unwrap_mut());\n        let y = ProjectivePoint::random(&mut OsRng.unwrap_mut());\n        let k = Scalar::random(&mut OsRng.unwrap_mut());\n        let l = Scalar::random(&mut OsRng.unwrap_mut());\n\n        let reference = x * k + y * l;\n        let points_and_scalars = vec![(x, k), (y, l)];\n\n        let test = ProjectivePoint::lincomb(points_and_scalars.as_slice());\n        assert_eq!(reference, test);\n    }",
    "display_name": "test_lincomb_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/is_zero"
    ],
    "body": "    fn invert_vartime(&self) -> CtOption<Self> {\n        let mut u = *self;\n        let mut v = Self::from_uint_unchecked(Secp256k1::ORDER);\n        let mut A = Self::ONE;\n        let mut C = Self::ZERO;\n\n        while !bool::from(u.is_zero()) {\n            // u-loop\n            while bool::from(u.is_even()) {\n                u >>= 1;\n\n                let was_odd: bool = A.is_odd().into();\n                A >>= 1;\n\n                if was_odd {\n                    A += Self::from_uint_unchecked(FRAC_MODULUS_2);\n                    A += Self::ONE;\n                }\n            }\n\n            // v-loop\n            while bool::from(v.is_even()) {\n                v >>= 1;\n\n                let was_odd: bool = C.is_odd().into();\n                C >>= 1;\n\n                if was_odd {\n                    C += Self::from_uint_unchecked(FRAC_MODULUS_2);\n                    C += Self::ONE;\n                }\n            }\n\n            // sub-step\n            if u >= v {\n                u -= &v;\n                A -= &C;\n            } else {\n                v -= &u;\n                C -= &A;\n            }\n        }\n\n        CtOption::new(C, !self.is_zero())\n    }",
    "display_name": "invert_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_field_element_invert",
      "0.14.0_pre.8 bench_field_element_mul",
      "0.14.0_pre.8 bench_field_element_sqrt",
      "0.14.0_pre.8 bench_field_element_square"
    ],
    "body": "fn bench_field_element(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"field element operations\");\n    bench_field_element_mul(&mut group);\n    bench_field_element_square(&mut group);\n    bench_field_element_invert(&mut group);\n    bench_field_element_sqrt(&mut group);\n    group.finish();\n}",
    "display_name": "bench_field_element",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/field.rs",
    "relative_path": "p521/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/as_nonzero_scalar",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_nonzero_scalar(&self) -> &NonZeroScalar {\n        &self.secret_key\n    }",
    "display_name": "as_nonzero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Shr/shr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime"
    ],
    "body": "    fn shr(self, rhs: usize) -> Self::Output {\n        self.shr_vartime(rhs as u32)\n    }",
    "display_name": "shr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032"
    ],
    "body": "    fn from(scalar: &Scalar) -> Vec<u8> {\n        scalar.to_bytes_rfc_8032().to_vec()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/from_secret_scalar",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/to_affine",
      "projective/impl/ProjectivePoint/Group/generator"
    ],
    "body": "    pub fn from_secret_scalar(scalar: &NonZeroScalar) -> Self {\n        // `NonZeroScalar` ensures the resulting point is not the identity\n        #[allow(clippy::arithmetic_side_effects)]\n        Self {\n            point: (<BignP256 as CurveArithmetic>::ProjectivePoint::generator() * scalar.as_ref())\n                .to_affine(),\n        }\n    }",
    "display_name": "from_secret_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/repeated_double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn repeated_double() {\n        let mut r = FieldElement::ONE;\n        for i in 0..DBL_TEST_VECTORS.len() {\n            assert_eq!(r.to_bytes(), DBL_TEST_VECTORS[i]);\n            r = r.double().normalize();\n        }\n    }",
    "display_name": "repeated_double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/DigestVerifier/verify_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/DigestVerifier/verify_digest"
    ],
    "body": "    fn verify_digest(&self, msg: D, signature: &Signature) -> Result<(), Error> {\n        <VerifyingKey as signature::DigestVerifier<D, Signature>>::verify_digest(\n            &self.secret.public_key,\n            msg,\n            signature,\n        )\n    }",
    "display_name": "verify_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/sub_mixed"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &AffinePoint) {\n        *self = ProjectivePoint::sub_mixed(self, rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_invert<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"invert\", |b| b.iter(|| x.invert()));\n}",
    "display_name": "bench_field_element_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/field.rs",
    "relative_path": "p384/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/negation",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double"
    ],
    "body": "    fn negation() {\n        let two = FieldElement::ONE.double();\n        let neg_two = -two;\n        assert_eq!(two + &neg_two, FieldElement::ZERO);\n        assert_eq!(-neg_two, two);\n    }",
    "display_name": "negation",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/PrehashSigner/sign_prehash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/sign_prehash_rfc6979"
    ],
    "body": "    fn sign_prehash(&self, prehash: &[u8]) -> Result<Signature> {\n        sign_prehash_rfc6979(&self.secret_scalar, prehash, &[])\n    }",
    "display_name": "sign_prehash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_opp",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_opp(\n    out1: &mut fiat_p521_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p521_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (0x0 as u64), (arg1[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (0x0 as u64), (arg1[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (0x0 as u64), (arg1[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (0x0 as u64), (arg1[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x9, &mut x10, x8, (0x0 as u64), (arg1[4]));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x11, &mut x12, x10, (0x0 as u64), (arg1[5]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x13, &mut x14, x12, (0x0 as u64), (arg1[6]));\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x15, &mut x16, x14, (0x0 as u64), (arg1[7]));\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x17, &mut x18, x16, (0x0 as u64), (arg1[8]));\n    let mut x19: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x19, x18, (0x0 as u64), 0xffffffffffffffff);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x20, &mut x21, 0x0, x1, (x19 & 0xbb6fb71e91386409));\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x22, &mut x23, x21, x3, (x19 & 0x3bb5c9b8899c47ae));\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x24, &mut x25, x23, x5, (x19 & 0x7fcc0148f709a5d0));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x26, &mut x27, x25, x7, (x19 & 0x51868783bf2f966b));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x28, &mut x29, x27, x9, (x19 & 0xfffffffffffffffa));\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x11, x19);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x13, x19);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x15, x19);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x36, &mut x37, x35, x17, (x19 & 0x1ff));\n    out1[0] = x20;\n    out1[1] = x22;\n    out1[2] = x24;\n    out1[3] = x26;\n    out1[4] = x28;\n    out1[5] = x30;\n    out1[6] = x32;\n    out1[7] = x34;\n    out1[8] = x36;\n}",
    "display_name": "fiat_p521_scalar_opp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Invert/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        self.invert()\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/GroupEncoding/from_bytes_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/GroupEncoding/from_bytes"
    ],
    "body": "    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // No unchecked conversion possible for compressed points\n        Self::from_bytes(bytes)\n    }",
    "display_name": "from_bytes_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sqn",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square"
    ],
    "body": "    fn sqn(&self, n: usize) -> Self {\n        let mut x = *self;\n        for _ in 0..n {\n            x = x.square();\n        }\n        x\n    }",
    "display_name": "sqn",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, other: FieldElement) {\n        *self = *self * other;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_nonzero(out1: &mut u64, arg1: &[u64; 4]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | ((arg1[2]) | (arg1[3]))));\n    *out1 = x1;\n}",
    "display_name": "fiat_sm2_scalar_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From/from"
    ],
    "body": "    fn mul(self, scalar: &Scalar) -> ProjectivePoint {\n        ProjectivePoint::from(self) * scalar\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 test_field_element_x",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_field_element_x() -> FieldElement {\n    FieldElement::from_bytes(\n        &[\n            0xbb, 0x48, 0x8a, 0xef, 0x41, 0x6a, 0x41, 0xd7, 0x68, 0x0d, 0x1c, 0xf0, 0x1d, 0x70,\n            0xf5, 0x9b, 0x60, 0xd7, 0xf5, 0xf7, 0x7e, 0x30, 0xe7, 0x8b, 0x8b, 0xf9, 0xd2, 0xd8,\n            0x82, 0xf1, 0x56, 0xa6,\n        ]\n        .into(),\n    )\n    .unwrap()\n}",
    "display_name": "test_field_element_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/sub"
    ],
    "body": "    pub const fn sub(&self, rhs: &Self) -> Self {\n        Self(field_impl::sub(self.0, rhs.0))\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/add_mixed"
    ],
    "body": "    fn add(self, other: &AffinePoint) -> ProjectivePoint {\n        ProjectivePoint::add_mixed(&self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/FromStr/from_str",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_str(s: &str) -> core::result::Result<Self, Error> {\n        Self::from_pkcs8_pem(s).map_err(|_| Error)\n    }",
    "display_name": "from_str",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Array, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::consts::B0>, ell",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Array, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::consts::B0>, ell"
    ],
    "body": "    fn from(scalar: Scalar) -> ScalarBytes {\n        Self::from(&scalar)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/as_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/as_affine"
    ],
    "body": "    pub fn as_affine(&self) -> &AffinePoint {\n        self.public_key.as_affine()\n    }",
    "display_name": "as_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/tests/generate_secret_key",
    "statement_type": "function",
    "deps": [],
    "body": "    fn generate_secret_key() {\n        use crate::SecretKey;\n        use elliptic_curve::rand_core::{OsRng, TryRngCore};\n        let key = SecretKey::random(&mut OsRng.unwrap_mut());\n\n        // Sanity check\n        assert!(!key.to_bytes().iter().all(|b| *b == 0))\n    }",
    "display_name": "generate_secret_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic.rs",
    "relative_path": "k256/src/arithmetic.rs",
    "file_name": "arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/fuzzy_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/From/from",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/mul",
      "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint"
    ],
    "body": "        fn fuzzy_mul(a in scalar(), b in scalar()) {\n            let a_bi = a.to_biguint().unwrap();\n            let b_bi = b.to_biguint().unwrap();\n\n            let res_bi = (&a_bi * &b_bi) % &Scalar::modulus_as_biguint();\n            let res_ref = Scalar::from(&res_bi);\n            let res_test = a.mul(&b);\n\n            assert_eq!(res_ref, res_test);\n        }",
    "display_name": "fuzzy_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub(self, other: &Scalar) -> Scalar {\n        Scalar::sub(self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = &'a Scalar>>(iter: I) -> Self {\n        iter.copied().sum()\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/wycheproof/wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "        ecdsa_core::new_wycheproof_test!(wycheproof, \"wycheproof\", NistP521);\n    }\n}",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/ecdsa.rs",
    "relative_path": "p521/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_torsion_free",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub fn is_torsion_free(&self) -> Choice {\n        (self * BASEPOINT_ORDER).ct_eq(&Self::IDENTITY)\n    }",
    "display_name": "is_torsion_free",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(a: u8) -> Self {\n        Scalar(U448::from_u8(a))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/AffinePoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &EdwardsPoint) {\n        *self = (self.to_edwards() - rhs).to_affine();\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/&FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_normalize_weak",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_normalize_weak<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"normalize_weak\", |b| {\n        b.iter(|| black_box(x).normalize_weak())\n    });\n}",
    "display_name": "bench_field_element_normalize_weak",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        self.0.ct_eq(&other.0)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/TryFrom, der::asn1::BitStringRef>>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre public_key/impl/PublicKey/TryFrom, der::asn1::BitStringRef>>/try_from"
    ],
    "body": "    fn try_from(spki: pkcs8::SubjectPublicKeyInfoRef<'_>) -> pkcs8::spki::Result<Self> {\n        Self::try_from(&spki)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/AffinePoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine"
    ],
    "body": "    fn add_assign(&mut self, rhs: &EdwardsPoint) {\n        *self = (self.to_edwards() + rhs).to_affine();\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/Signer/try_sign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/MultipartSigner/try_multipart_sign"
    ],
    "body": "    fn try_sign(&self, msg: &[u8]) -> Result<Signature> {\n        self.try_multipart_sign(&[msg])\n    }",
    "display_name": "try_sign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/elliptic_curve::NonZeroScalar/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(scalar: Scalar) -> Result<Self, Error> {\n        NonZeroScalar::new(scalar).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/verifying_key/tests/signatures",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::co",
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/sign_prehashed",
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/from_bytes",
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/as_bytes",
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_raw",
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/verifying_key",
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_inner",
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/sign_ctx",
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/verify_ctx",
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/sign_raw"
    ],
    "body": "    fn signatures() {\n        for tv in TEST_VECTORS.iter() {\n            let mut seed = SecretKey::default();\n            hex::decode_to_slice(tv.s, &mut seed).unwrap();\n            let mut q_enc = [0u8; PUBLIC_KEY_LENGTH];\n            hex::decode_to_slice(tv.q, &mut q_enc).unwrap();\n            let msg = hex::decode(tv.m).unwrap();\n            let ctx = hex::decode(tv.ctx).unwrap();\n            let mut sig = [0u8; 114];\n            hex::decode_to_slice(tv.sig, &mut sig[..]).unwrap();\n            let sig = Signature::try_from(&sig[..]).unwrap();\n\n            let skey = SigningKey::from(&seed);\n            assert_eq!(&q_enc[..], skey.verifying_key().as_bytes());\n            if tv.ph {\n                assert_eq!(\n                    skey.sign_prehashed::<PreHasherXof<Shake256>>(\n                        Some(&ctx[..]),\n                        Shake256::default().chain(&msg).into(),\n                    )\n                    .unwrap(),\n                    sig\n                );\n            } else {\n                assert_eq!(skey.sign_ctx(&ctx[..], &msg[..]).unwrap(), sig);\n                if ctx.is_empty() {\n                    assert_eq!(skey.sign_raw(&msg[..]), sig);\n                }\n            }\n\n            let pkey = VerifyingKey::from_bytes(&q_enc).unwrap();\n            if tv.ph {\n                let mut reader = Shake256::default().chain(&msg).finalize_xof();\n                let mut hm = [0u8; 64];\n                reader.read(&mut hm);\n                assert!(pkey.verify_inner(&sig, 1, &ctx[..], &hm).is_ok());\n                assert!(pkey.verify_inner(&sig, 1, &[1u8], &hm).is_err());\n                hm[42] ^= 0x08;\n                assert!(pkey.verify_inner(&sig, 1, &ctx[..], &hm).is_err());\n            } else {\n                assert!(pkey.verify_ctx(&sig, &ctx[..], &msg[..]).is_ok());\n                assert!(pkey.verify_ctx(&sig, &[1u8], &msg[..]).is_err());\n                assert!(pkey.verify_ctx(&sig, &ctx[..], &[0u8]).is_err());\n                if ctx.is_empty() {\n                    assert!(pkey.verify_raw(&sig, &msg[..]).is_ok());\n                }\n            }\n        }\n    }",
    "display_name": "signatures",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/verifying_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/verifying_key.rs",
    "file_name": "verifying_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre encrypt_and_decrypt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt",
      "0.14.0_pre decrypting_key",
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/encrypting_key",
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt"
    ],
    "body": "    fn encrypt_and_decrypt(dk in decrypting_key()) {\n        let ek = dk.encrypting_key();\n        let cipher_bytes = ek.encrypt(&mut OsRng, MSG).unwrap();\n        assert_eq!(dk.decrypt(&cipher_bytes).unwrap(), MSG);\n    }",
    "display_name": "encrypt_and_decrypt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/sm2pke.rs",
    "relative_path": "sm2/tests/sm2pke.rs",
    "file_name": "sm2pke.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/muladd",
    "statement_type": "function",
    "deps": [],
    "body": "fn muladd(a: u64, b: u64, c0: u64, c1: u64, c2: u64) -> (u64, u64, u64) {\n    let t = (a as u128) * (b as u128);\n    let th = (t >> 64) as u64; // at most 0xFFFFFFFFFFFFFFFE\n    let tl = t as u64;\n\n    let (new_c0, carry0) = c0.overflowing_add(tl);\n    let new_th = th.wrapping_add(carry0 as u64); // at most 0xFFFFFFFFFFFFFFFF\n    let (new_c1, carry1) = c1.overflowing_add(new_th);\n    let new_c2 = c2 + (carry1 as u64);\n\n    (new_c0, new_c1, new_c2)\n}",
    "display_name": "muladd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn from_u64(val: u64) -> Self {\n        let w0 = val & 0xFFFFFFFFFFFFF;\n        let w1 = val >> 52;\n        Self([w0, w1, 0, 0, 0])\n    }",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/batch_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/tests/non_zero_scalar",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "        fn batch_invert(\n            a in non_zero_scalar(),\n            b in non_zero_scalar(),\n            c in non_zero_scalar(),\n            d in non_zero_scalar(),\n            e in non_zero_scalar(),\n        ) {\n            let scalars: [Scalar; 5] = [*a, *b, *c, *d, *e];\n\n            let inverted_scalars = Scalar::batch_invert(scalars).unwrap();\n\n            for (scalar, inverted_scalar) in scalars.into_iter().zip(inverted_scalars) {\n                assert_eq!(inverted_scalar, scalar.invert().unwrap());\n            }\n        }",
    "display_name": "batch_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_from_bytes(out1: &mut [u64; 3], arg1: &[u8; 24]) {\n    let x1: u64 = (((arg1[23]) as u64) << 56);\n    let x2: u64 = (((arg1[22]) as u64) << 48);\n    let x3: u64 = (((arg1[21]) as u64) << 40);\n    let x4: u64 = (((arg1[20]) as u64) << 32);\n    let x5: u64 = (((arg1[19]) as u64) << 24);\n    let x6: u64 = (((arg1[18]) as u64) << 16);\n    let x7: u64 = (((arg1[17]) as u64) << 8);\n    let x8: u8 = (arg1[16]);\n    let x9: u64 = (((arg1[15]) as u64) << 56);\n    let x10: u64 = (((arg1[14]) as u64) << 48);\n    let x11: u64 = (((arg1[13]) as u64) << 40);\n    let x12: u64 = (((arg1[12]) as u64) << 32);\n    let x13: u64 = (((arg1[11]) as u64) << 24);\n    let x14: u64 = (((arg1[10]) as u64) << 16);\n    let x15: u64 = (((arg1[9]) as u64) << 8);\n    let x16: u8 = (arg1[8]);\n    let x17: u64 = (((arg1[7]) as u64) << 56);\n    let x18: u64 = (((arg1[6]) as u64) << 48);\n    let x19: u64 = (((arg1[5]) as u64) << 40);\n    let x20: u64 = (((arg1[4]) as u64) << 32);\n    let x21: u64 = (((arg1[3]) as u64) << 24);\n    let x22: u64 = (((arg1[2]) as u64) << 16);\n    let x23: u64 = (((arg1[1]) as u64) << 8);\n    let x24: u8 = (arg1[0]);\n    let x25: u64 = (x23 + (x24 as u64));\n    let x26: u64 = (x22 + x25);\n    let x27: u64 = (x21 + x26);\n    let x28: u64 = (x20 + x27);\n    let x29: u64 = (x19 + x28);\n    let x30: u64 = (x18 + x29);\n    let x31: u64 = (x17 + x30);\n    let x32: u64 = (x15 + (x16 as u64));\n    let x33: u64 = (x14 + x32);\n    let x34: u64 = (x13 + x33);\n    let x35: u64 = (x12 + x34);\n    let x36: u64 = (x11 + x35);\n    let x37: u64 = (x10 + x36);\n    let x38: u64 = (x9 + x37);\n    let x39: u64 = (x7 + (x8 as u64));\n    let x40: u64 = (x6 + x39);\n    let x41: u64 = (x5 + x40);\n    let x42: u64 = (x4 + x41);\n    let x43: u64 = (x3 + x42);\n    let x44: u64 = (x2 + x43);\n    let x45: u64 = (x1 + x44);\n    out1[0] = x31;\n    out1[1] = x38;\n    out1[2] = x45;\n}",
    "display_name": "fiat_p192_scalar_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_sm2_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    pub fn from_uint(uint: U576) -> CtOption<Self> {\n        let is_some = uint.ct_lt(&NistP521::ORDER);\n        CtOption::new(Self::from_uint_unchecked(uint), is_some)\n    }",
    "display_name": "from_uint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_sm2_scalar_u1,\n    arg1: fiat_sm2_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_sm2_scalar_i1 = ((x1 >> 64) as fiat_sm2_scalar_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_sm2_scalar_i2) - (x2 as fiat_sm2_scalar_i2)) as fiat_sm2_scalar_u1);\n}",
    "display_name": "fiat_sm2_scalar_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/DigestSigner/try_sign_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_prehashed"
    ],
    "body": "    fn try_sign_digest(&self, digest: D) -> Result<Signature, Error> {\n        let mut prehashed_message = [0u8; 64];\n        prehashed_message.copy_from_slice(digest.finalize().as_slice());\n        let sig = self.secret.sign_prehashed(&[], &prehashed_message)?;\n        Ok(sig.into())\n    }",
    "display_name": "try_sign_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_p192_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/s",
    "statement_type": "function",
    "deps": [],
    "body": "    fn s(&self) -> &NonZeroScalar {\n        &self.s\n    }",
    "display_name": "s",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    fn add_assign(&mut self, rhs: &AffinePoint) {\n        *self += rhs.to_edwards();\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: AffinePoint) -> ProjectivePoint {\n        rhs * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Group/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/double"
    ],
    "body": "    fn double(&self) -> Self {\n        Self::double(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/test/test_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/compress"
    ],
    "body": "    fn test_identity() {\n        // Basic test to check the identity is being encoded properly\n        let compress_identity = DecafPoint::IDENTITY.compress();\n        assert!(compress_identity == CompressedDecaf::IDENTITY)\n    }",
    "display_name": "test_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/test_pow_add_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/random",
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes_rfc_8032",
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/hash_with_defaults"
    ],
    "body": "    fn test_pow_add_mul() {\n        use rand_core::SeedableRng;\n\n        let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(0);\n        let x = Scalar::random(&mut rng);\n        let b = Scalar::random(&mut rng);\n\n        let g1 = EdwardsPoint::GENERATOR;\n        let g2 = EdwardsPoint::hash_with_defaults(b\"test_pow_add_mul\");\n\n        let expected_commitment = g1 * x + g2 * b;\n\n        let shift = Scalar::from(256u16);\n        let x_bytes = x.to_bytes_rfc_8032();\n        let mut sum = Scalar::ZERO;\n        let mut components = [EdwardsPoint::IDENTITY; 57];\n        for i in 1..57 {\n            let r = Scalar::random(&mut rng);\n            sum += r * shift.pow([i as u64]);\n            components[i] = g1 * Scalar::from(x_bytes[i]) + g2 * r;\n        }\n        components[0] = g1 * Scalar::from(x_bytes[0]) + g2 * (b - sum);\n\n        let mut computed_commitment = EdwardsPoint::IDENTITY;\n        for i in (0..57).rev() {\n            computed_commitment *= shift;\n            computed_commitment += components[i];\n        }\n\n        assert_eq!(computed_commitment, expected_commitment);\n    }",
    "display_name": "test_pow_add_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_y",
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_mul<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"mul\", |b| b.iter(|| black_box(x) * black_box(y)));\n}",
    "display_name": "bench_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/map_to_curve_decaf448",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/sqrt_ratio_i",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_twisted",
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/ConditionallySelectable/conditional_select",
      "0.14.0_pre.1 field/element/impl/FieldElement/Neg/neg",
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative"
    ],
    "body": "    pub(crate) fn map_to_curve_decaf448(&self) -> TwistedExtendedPoint {\n        const ONE_MINUS_TWO_D: FieldElement =\n            FieldElement(ConstMontyType::new(&U448::from_u64(78163)));\n\n        let r = -self.square();\n        let u0 = Self::EDWARDS_D * (r - Self::ONE);\n        let u1 = (u0 + Self::ONE) * (u0 - r);\n\n        let rhs = (r + Self::ONE) * u1;\n        let (v, was_square) = Self::sqrt_ratio_i(&ONE_MINUS_TWO_D, &rhs);\n\n        let mut v_prime = self * v;\n        v_prime.conditional_assign(&v, was_square);\n        let mut sgn = Self::MINUS_ONE;\n        sgn.conditional_negate(was_square);\n\n        let s = v_prime * (r + Self::ONE);\n        let s2 = s.square();\n        let s_abs = Self::conditional_select(&s, &s.neg(), s.is_negative());\n\n        let w0 = s_abs + s_abs;\n        let w1 = s2 + Self::ONE;\n        let w2 = s2 - Self::ONE;\n        let w3 = v_prime * s * (r - Self::ONE) * ONE_MINUS_TWO_D + sgn;\n\n        EdwardsPoint {\n            X: w0 * w3,\n            Y: w2 * w1,\n            Z: w1 * w3,\n            T: w0 * w2,\n        }\n        .to_twisted()\n    }",
    "display_name": "map_to_curve_decaf448",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/multiply",
    "statement_type": "function",
    "deps": [],
    "body": "    fn multiply() {\n        let one = Scalar::ONE;\n        let two = one + one;\n        let three = two + one;\n        let six = three + three;\n        assert_eq!(six, two * three);\n\n        let minus_two = -two;\n        let minus_three = -three;\n        assert_eq!(two, -minus_two);\n\n        assert_eq!(minus_three * minus_two, minus_two * minus_three);\n        assert_eq!(six, minus_two * minus_three);\n    }",
    "display_name": "multiply",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_msat(out1: &mut [u64; 5]) {\n    out1[0] = (0x1 as u64);\n    out1[1] = 0xffffffff00000000;\n    out1[2] = 0xffffffffffffffff;\n    out1[3] = 0xffffffff;\n    out1[4] = (0x0 as u64);\n}",
    "display_name": "fiat_p224_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_msat(out1: &mut [u64; 5]) {\n    out1[0] = 0xffffffffffffffff;\n    out1[1] = 0xffffffff00000000;\n    out1[2] = 0xffffffffffffffff;\n    out1[3] = 0xfffffffeffffffff;\n    out1[4] = (0x0 as u64);\n}",
    "display_name": "fiat_sm2_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_mulx_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_square(\n    out1: &mut fiat_bign256_scalar_montgomery_domain_field_element,\n    arg1: &fiat_bign256_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x5, &mut x6, x4, (arg1[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x7, &mut x8, x4, (arg1[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x9, &mut x10, x4, (arg1[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x11, &mut x12, x4, (arg1[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x20, &mut x21, x11, 0x8d64dbd30858d849);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x22, &mut x23, x20, 0xffffffffffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x26, &mut x27, x20, 0xd95c8ed60dfb4dfc);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x28, &mut x29, x20, 0x7e5abf99263d6607);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x30, &mut x31, 0x0, x29, x26);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x27, x24);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x25, x22);\n    let x36: u64 = ((x35 as u64) + x23);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x37, &mut x38, 0x0, x11, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x13, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x15, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x43, &mut x44, x42, x17, x34);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x45, &mut x46, x44, x19, x36);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x47, &mut x48, x1, (arg1[3]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x49, &mut x50, x1, (arg1[2]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x51, &mut x52, x1, (arg1[1]));\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x53, &mut x54, x1, (arg1[0]));\n    let mut x55: u64 = 0;\n    let mut x56: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x55, &mut x56, 0x0, x54, x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x52, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x50, x47);\n    let x61: u64 = ((x60 as u64) + x48);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x45, x59);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x70, &mut x71, x69, (x46 as u64), x61);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x72, &mut x73, x62, 0x8d64dbd30858d849);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x74, &mut x75, x72, 0xffffffffffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x78, &mut x79, x72, 0xd95c8ed60dfb4dfc);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x80, &mut x81, x72, 0x7e5abf99263d6607);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x82, &mut x83, 0x0, x81, x78);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x79, x76);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x77, x74);\n    let x88: u64 = ((x87 as u64) + x75);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x89, &mut x90, 0x0, x62, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x91, &mut x92, x90, x64, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x93, &mut x94, x92, x66, x84);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x95, &mut x96, x94, x68, x86);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x97, &mut x98, x96, x70, x88);\n    let x99: u64 = ((x98 as u64) + (x71 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x100, &mut x101, x2, (arg1[3]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x102, &mut x103, x2, (arg1[2]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x104, &mut x105, x2, (arg1[1]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x106, &mut x107, x2, (arg1[0]));\n    let mut x108: u64 = 0;\n    let mut x109: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x107, x104);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x105, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x103, x100);\n    let x114: u64 = ((x113 as u64) + x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x115, &mut x116, 0x0, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x121, &mut x122, x120, x97, x112);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x123, &mut x124, x122, x99, x114);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x125, &mut x126, x115, 0x8d64dbd30858d849);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x127, &mut x128, x125, 0xffffffffffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x129, &mut x130, x125, 0xffffffffffffffff);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x131, &mut x132, x125, 0xd95c8ed60dfb4dfc);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x133, &mut x134, x125, 0x7e5abf99263d6607);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let x141: u64 = ((x140 as u64) + x128);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x142, &mut x143, 0x0, x115, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x144, &mut x145, x143, x117, x135);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x146, &mut x147, x145, x119, x137);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x148, &mut x149, x147, x121, x139);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x150, &mut x151, x149, x123, x141);\n    let x152: u64 = ((x151 as u64) + (x124 as u64));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x153, &mut x154, x3, (arg1[3]));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x155, &mut x156, x3, (arg1[2]));\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x157, &mut x158, x3, (arg1[1]));\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x159, &mut x160, x3, (arg1[0]));\n    let mut x161: u64 = 0;\n    let mut x162: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x161, &mut x162, 0x0, x160, x157);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x163, &mut x164, x162, x158, x155);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x165, &mut x166, x164, x156, x153);\n    let x167: u64 = ((x166 as u64) + x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x168, &mut x169, 0x0, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x148, x163);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x150, x165);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x152, x167);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x178, &mut x179, x168, 0x8d64dbd30858d849);\n    let mut x180: u64 = 0;\n    let mut x181: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x180, &mut x181, x178, 0xffffffffffffffff);\n    let mut x182: u64 = 0;\n    let mut x183: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x182, &mut x183, x178, 0xffffffffffffffff);\n    let mut x184: u64 = 0;\n    let mut x185: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x184, &mut x185, x178, 0xd95c8ed60dfb4dfc);\n    let mut x186: u64 = 0;\n    let mut x187: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x186, &mut x187, x178, 0x7e5abf99263d6607);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x188, &mut x189, 0x0, x187, x184);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x190, &mut x191, x189, x185, x182);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x183, x180);\n    let x194: u64 = ((x193 as u64) + x181);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x195, &mut x196, 0x0, x168, x186);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x197, &mut x198, x196, x170, x188);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x172, x190);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x174, x192);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x176, x194);\n    let x205: u64 = ((x204 as u64) + (x177 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x206, &mut x207, 0x0, x197, 0x7e5abf99263d6607);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x208, &mut x209, x207, x199, 0xd95c8ed60dfb4dfc);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x210, &mut x211, x209, x201, 0xffffffffffffffff);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x212, &mut x213, x211, x203, 0xffffffffffffffff);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x214, &mut x215, x213, x205, (0x0 as u64));\n    let mut x216: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x216, x215, x206, x197);\n    let mut x217: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x217, x215, x208, x199);\n    let mut x218: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x218, x215, x210, x201);\n    let mut x219: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x219, x215, x212, x203);\n    out1[0] = x216;\n    out1[1] = x217;\n    out1[2] = x218;\n    out1[3] = x219;\n}",
    "display_name": "fiat_bign256_scalar_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/square",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/test_vector_add_mixed_identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn test_vector_add_mixed_identity() {\n        let generator = ProjectivePoint::GENERATOR;\n        let p0 = generator + ProjectivePoint::IDENTITY;\n        let p1 = generator + AffinePoint::IDENTITY;\n        assert_eq!(p0, p1);\n    }",
    "display_name": "test_vector_add_mixed_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/new",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/new_with_mode"
    ],
    "body": "    pub fn new(public_key: PublicKey) -> Self {\n        Self::new_with_mode(public_key, Mode::C1C2C3)\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&DecafPoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended"
    ],
    "body": "    fn add(self, rhs: &DecafAffinePoint) -> Self::Output {\n        self + DecafPoint(rhs.0.to_extended())\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Curve/to_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn to_affine(&self) -> AffinePoint {\n        ProjectivePoint::to_affine(self)\n    }",
    "display_name": "to_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> MontgomeryPoint {\n        Self([0u8; 56])\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/mul_wide",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/muladd_fast",
      "0.14.0_pre.8 arithmetic/scalar/wide/muladd"
    ],
    "body": "    pub fn mul_wide(a: &Scalar, b: &Scalar) -> Self {\n        let a = a.0.to_words();\n        let b = b.0.to_words();\n\n        // 160 bit accumulator.\n        let c0 = 0;\n        let c1 = 0;\n        let c2 = 0;\n\n        // l[0..7] = a[0..3] * b[0..3].\n        let (c0, c1) = muladd_fast(a[0], b[0], c0, c1);\n        let (l0, c0, c1) = (c0, c1, 0);\n        let (c0, c1, c2) = muladd(a[0], b[1], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[1], b[0], c0, c1, c2);\n        let (l1, c0, c1, c2) = (c0, c1, c2, 0);\n        let (c0, c1, c2) = muladd(a[0], b[2], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[1], b[1], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[2], b[0], c0, c1, c2);\n        let (l2, c0, c1, c2) = (c0, c1, c2, 0);\n        let (c0, c1, c2) = muladd(a[0], b[3], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[1], b[2], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[2], b[1], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[3], b[0], c0, c1, c2);\n        let (l3, c0, c1, c2) = (c0, c1, c2, 0);\n        let (c0, c1, c2) = muladd(a[1], b[3], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[2], b[2], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[3], b[1], c0, c1, c2);\n        let (l4, c0, c1, c2) = (c0, c1, c2, 0);\n        let (c0, c1, c2) = muladd(a[2], b[3], c0, c1, c2);\n        let (c0, c1, c2) = muladd(a[3], b[2], c0, c1, c2);\n        let (l5, c0, c1, _c2) = (c0, c1, c2, 0);\n        let (c0, c1) = muladd_fast(a[3], b[3], c0, c1);\n        let (l6, c0, _c1) = (c0, c1, 0);\n        let l7 = c0;\n\n        Self(U512::from_words([l0, l1, l2, l3, l4, l5, l6, l7]))\n    }",
    "display_name": "mul_wide",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.seed.zeroize();\n        self.scalar.zeroize();\n        self.hash_prefix.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/expanded.rs",
    "relative_path": "ed448-goldilocks/src/sign/expanded.rs",
    "file_name": "expanded.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_hex",
      "0.14.0_pre arithmetic/field/impl/FieldElement/ConditionallySelectable/conditional_select",
      "0.14.0_pre arithmetic/field/impl/FieldElement/from_u64",
      "0.14.0_pre arithmetic/field/impl/FieldElement/square",
      "0.14.0_pre arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
      "0.14.0_pre arithmetic/field/impl/FieldElement/invert_unchecked"
    ],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        let t0 = self;\n        let t1 = t0.square();\n        let t2 = t1 * t0;\n        let t3 = t2.square();\n        let t4 = t3 * t0;\n        let t5 = t4.square();\n        let t6 = t5 * t0;\n        let t7 = t6.square();\n        let t8 = t7.square();\n        let t9 = t8.square();\n        let t10 = t9 * t4;\n        let t11 = t10.square();\n        let t12 = t11 * t0;\n        let t13 = t12.square();\n        let t14 = t13.square();\n        let t15 = t14.square();\n        let t16 = t15.square();\n        let t17 = t16.square();\n        let t18 = t17.square();\n        let t19 = t18.square();\n        let t20 = t19 * t10;\n        let t21 = t20.square();\n        let t22 = t21 * t0;\n        let t23 = t22.square();\n        let t24 = t23.square();\n        let t25 = t24.square();\n        let t26 = t25.square();\n        let t27 = t26.square();\n        let t28 = t27.square();\n        let t29 = t28.square();\n        let t30 = t29.square();\n        let t31 = t30.square();\n        let t32 = t31.square();\n        let t33 = t32.square();\n        let t34 = t33.square();\n        let t35 = t34.square();\n        let t36 = t35.square();\n        let t37 = t36.square();\n        let t38 = t37 * t20;\n        let t39 = t38.square();\n        let t40 = t39 * t0;\n        let t41 = t40.square();\n        let t42 = t41.square();\n        let t43 = t42.square();\n        let t44 = t43.square();\n        let t45 = t44.square();\n        let t46 = t45.square();\n        let t47 = t46.square();\n        let t48 = t47.square();\n        let t49 = t48.square();\n        let t50 = t49.square();\n        let t51 = t50.square();\n        let t52 = t51.square();\n        let t53 = t52.square();\n        let t54 = t53.square();\n        let t55 = t54.square();\n        let t56 = t55.square();\n        let t57 = t56.square();\n        let t58 = t57.square();\n        let t59 = t58.square();\n        let t60 = t59.square();\n        let t61 = t60.square();\n        let t62 = t61.square();\n        let t63 = t62.square();\n        let t64 = t63.square();\n        let t65 = t64.square();\n        let t66 = t65.square();\n        let t67 = t66.square();\n        let t68 = t67.square();\n        let t69 = t68.square();\n        let t70 = t69.square();\n        let t71 = t70.square();\n        let t72 = t71 * t38;\n        let t73 = t72.square();\n        let t74 = t73 * t0;\n        let t75 = t74.square();\n        let t76 = t75.square();\n        let t77 = t76.square();\n        let t78 = t77.square();\n        let t79 = t78.square();\n        let t80 = t79.square();\n        let t81 = t80.square();\n        let t82 = t81.square();\n        let t83 = t82.square();\n        let t84 = t83.square();\n        let t85 = t84.square();\n        let t86 = t85.square();\n        let t87 = t86.square();\n        let t88 = t87.square();\n        let t89 = t88.square();\n        let t90 = t89.square();\n        let t91 = t90.square();\n        let t92 = t91.square();\n        let t93 = t92.square();\n        let t94 = t93.square();\n        let t95 = t94.square();\n        let t96 = t95.square();\n        let t97 = t96.square();\n        let t98 = t97.square();\n        let t99 = t98.square();\n        let t100 = t99.square();\n        let t101 = t100.square();\n        let t102 = t101.square();\n        let t103 = t102.square();\n        let t104 = t103.square();\n        let t105 = t104.square();\n        let t106 = t105.square();\n        let t107 = t106.square();\n        let t108 = t107.square();\n        let t109 = t108.square();\n        let t110 = t109.square();\n        let t111 = t110.square();\n        let t112 = t111.square();\n        let t113 = t112.square();\n        let t114 = t113.square();\n        let t115 = t114.square();\n        let t116 = t115.square();\n        let t117 = t116.square();\n        let t118 = t117.square();\n        let t119 = t118.square();\n        let t120 = t119.square();\n        let t121 = t120.square();\n        let t122 = t121.square();\n        let t123 = t122.square();\n        let t124 = t123.square();\n        let t125 = t124.square();\n        let t126 = t125.square();\n        let t127 = t126.square();\n        let t128 = t127.square();\n        let t129 = t128.square();\n        let t130 = t129.square();\n        let t131 = t130.square();\n        let t132 = t131.square();\n        let t133 = t132.square();\n        let t134 = t133.square();\n        let t135 = t134.square();\n        let t136 = t135.square();\n        let t137 = t136.square();\n        let w = t137 * t72;\n\n        let mut v = Self::S;\n        let mut x = *self * w;\n        let mut b = x * w;\n        let mut z = Self::ROOT_OF_UNITY;\n\n        for max_v in (1..=Self::S).rev() {\n            let mut k = 1;\n            let mut tmp = b.square();\n            let mut j_less_than_v = Choice::from(1);\n\n            for j in 2..max_v {\n                let tmp_is_one = tmp.ct_eq(&Self::ONE);\n                let squared = Self::conditional_select(&tmp, &z, tmp_is_one).square();\n                tmp = Self::conditional_select(&squared, &tmp, tmp_is_one);\n                let new_z = Self::conditional_select(&z, &squared, tmp_is_one);\n                j_less_than_v &= !j.ct_eq(&v);\n                k = u32::conditional_select(&j, &k, tmp_is_one);\n                z = Self::conditional_select(&z, &new_z, j_less_than_v);\n            }\n\n            let result = x * z;\n            x = Self::conditional_select(&result, &x, b.ct_eq(&Self::ONE));\n            z = z.square();\n            b *= &z;\n            v = k;\n        }\n\n        CtOption::new(x, x.square().ct_eq(self))\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/&FieldElement/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sub"
    ],
    "body": "    fn sub(self, rhs: &FieldElement) -> FieldElement {\n        FieldElement::sub(self, rhs)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalizes_to_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalize_weak"
    ],
    "body": "    pub fn normalizes_to_zero(&self) -> Choice {\n        let res = self.normalize_weak();\n\n        let t0 = res.0[0];\n        let t1 = res.0[1];\n        let t2 = res.0[2];\n        let t3 = res.0[3];\n        let t4 = res.0[4];\n\n        // z0 tracks a possible raw value of 0, z1 tracks a possible raw value of the modulus\n        let z0 = t0 | t1 | t2 | t3 | t4;\n        let z1 = (t0 ^ 0x1000003D0u64) & t1 & t2 & t3 & (t4 ^ 0xF000000000000u64);\n\n        Choice::from(((z0 == 0) | (z1 == 0xFFFFFFFFFFFFFu64)) as u8)\n    }",
    "display_name": "normalizes_to_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint"
    ],
    "body": "    fn try_from(w: U384) -> Result<Self> {\n        Option::from(Self::from_uint(w)).ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, rhs: &Self) -> bool {\n        self.ct_eq(rhs).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/RandomizedSigner/try_sign_with_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/signing/impl/SigningKey/RandomizedMultipartSigner/try_multipart_sign_with_rng"
    ],
    "body": "    fn try_sign_with_rng<R: TryCryptoRng + ?Sized>(\n        &self,\n        rng: &mut R,\n        msg: &[u8],\n    ) -> Result<Signature> {\n        self.try_multipart_sign_with_rng(rng, &[msg])\n    }",
    "display_name": "try_sign_with_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p224_sub(\n    out1: &mut fiat_p224_montgomery_domain_field_element,\n    arg1: &fiat_p224_montgomery_domain_field_element,\n    arg2: &fiat_p224_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x10,\n        &mut x11,\n        0x0,\n        x1,\n        (((x9 & (0x1 as u64)) as fiat_p224_u1) as u64),\n    );\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0xffffffff00000000));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x16, &mut x17, x15, x7, (x9 & 0xffffffff));\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_p224_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn reduce(w: U384) -> Self {\n        let (r, underflow) = w.borrowing_sub(&NistP384::ORDER, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self::from_uint_unchecked(U384::conditional_select(&w, &r, !underflow))\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square"
    ],
    "body": "    fn square(&self) -> Self {\n        self.square()\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify"
    ],
    "body": "    fn verify(&self, msg: &[u8], signature: &Signature) -> Result<()> {\n        self.multipart_verify(&[msg], signature)\n    }",
    "display_name": "verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ConstantTimeEq/ct_eq",
      "projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.to_affine().ct_eq(&other.to_affine())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_p224_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x",
      "0.14.0_pre.8 test_field_element_y"
    ],
    "body": "fn bench_field_element_mul<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    let y = test_field_element_y();\n    group.bench_function(\"mul\", |b| b.iter(|| &black_box(x) * &black_box(y)));\n}",
    "display_name": "bench_field_element_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/sqrt_ratio",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert_unchecked"
    ],
    "body": "    fn sqrt_ratio(num: &Self, div: &Self) -> (Choice, Self) {\n        ff::helpers::sqrt_ratio_generic(num, div)\n    }",
    "display_name": "sqrt_ratio",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/tests/hex_to_field",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/from_bytes"
    ],
    "body": "    fn hex_to_field(hex: &'static str) -> FieldElement {\n        assert_eq!(hex.len(), 56 * 2);\n        let mut bytes =\n            hex_literal::decode(&[hex.as_bytes()]).expect(\"Output array length should be correct\");\n        bytes.reverse();\n        FieldElement::from_bytes(&bytes)\n    }",
    "display_name": "hex_to_field",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.7.0_pre r1/impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/decode_field_bytes",
    "statement_type": "function",
    "deps": [
      "0.7.0_pre decode_field_bytes"
    ],
    "body": "    fn decode_field_bytes(field_bytes: &FieldBytes) -> Self {\n        crate::decode_field_bytes(field_bytes)\n    }",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp384/src/r1.rs",
    "relative_path": "bp384/src/r1.rs",
    "file_name": "r1.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes"
    ],
    "body": "    pub fn y(&self) -> [u8; 56] {\n        self.0.y.to_bytes()\n    }",
    "display_name": "y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub_assign(&mut self, rhs: &Scalar) {\n        *self = Scalar::sub(self, rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: &FieldElement) {\n        *self = *self + other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/elliptic_curve::bigint::Uint/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: Scalar) -> Self {\n        scalar.0\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 compact_round_trip",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToCompactEncodedPoint/to_compact_encoded_point",
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "fn compact_round_trip() {\n    let pubkey = EncodedPoint::from_bytes(COMPACT_BASEPOINT).unwrap();\n    assert!(pubkey.is_compact());\n\n    let point = AffinePoint::from_encoded_point(&pubkey).unwrap();\n    let res = point.to_compact_encoded_point().unwrap();\n    assert_eq!(res, pubkey)\n}",
    "display_name": "compact_round_trip",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/AffinePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn from(p: &ProjectivePoint) -> AffinePoint {\n        p.to_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &ExtensiblePoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafAffinePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_affine"
    ],
    "body": "    fn from(point: &DecafPoint) -> Self {\n        DecafAffinePoint(point.0.to_affine())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = &'a Scalar>>(iter: I) -> Self {\n        iter.copied().sum()\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/to_canonical",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_canonical",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub_assign(&mut self, rhs: Scalar) {\n        *self = Scalar::sub(self, &rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/add_mixed",
    "statement_type": "function",
    "deps": [
      "point_arithmetic/sealed/PointArithmetic/add_mixed"
    ],
    "body": "    fn add_mixed(&self, other: &AffinePoint<C>) -> Self {\n        C::PointArithmetic::add_mixed(self, other)\n    }",
    "display_name": "add_mixed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_scalar_from_bytes(out1: &mut [u64; 9], arg1: &[u8; 66]) {\n    let x1: u64 = ((((arg1[65]) as fiat_p521_scalar_u1) as u64) << 8);\n    let x2: u8 = (arg1[64]);\n    let x3: u64 = (((arg1[63]) as u64) << 56);\n    let x4: u64 = (((arg1[62]) as u64) << 48);\n    let x5: u64 = (((arg1[61]) as u64) << 40);\n    let x6: u64 = (((arg1[60]) as u64) << 32);\n    let x7: u64 = (((arg1[59]) as u64) << 24);\n    let x8: u64 = (((arg1[58]) as u64) << 16);\n    let x9: u64 = (((arg1[57]) as u64) << 8);\n    let x10: u8 = (arg1[56]);\n    let x11: u64 = (((arg1[55]) as u64) << 56);\n    let x12: u64 = (((arg1[54]) as u64) << 48);\n    let x13: u64 = (((arg1[53]) as u64) << 40);\n    let x14: u64 = (((arg1[52]) as u64) << 32);\n    let x15: u64 = (((arg1[51]) as u64) << 24);\n    let x16: u64 = (((arg1[50]) as u64) << 16);\n    let x17: u64 = (((arg1[49]) as u64) << 8);\n    let x18: u8 = (arg1[48]);\n    let x19: u64 = (((arg1[47]) as u64) << 56);\n    let x20: u64 = (((arg1[46]) as u64) << 48);\n    let x21: u64 = (((arg1[45]) as u64) << 40);\n    let x22: u64 = (((arg1[44]) as u64) << 32);\n    let x23: u64 = (((arg1[43]) as u64) << 24);\n    let x24: u64 = (((arg1[42]) as u64) << 16);\n    let x25: u64 = (((arg1[41]) as u64) << 8);\n    let x26: u8 = (arg1[40]);\n    let x27: u64 = (((arg1[39]) as u64) << 56);\n    let x28: u64 = (((arg1[38]) as u64) << 48);\n    let x29: u64 = (((arg1[37]) as u64) << 40);\n    let x30: u64 = (((arg1[36]) as u64) << 32);\n    let x31: u64 = (((arg1[35]) as u64) << 24);\n    let x32: u64 = (((arg1[34]) as u64) << 16);\n    let x33: u64 = (((arg1[33]) as u64) << 8);\n    let x34: u8 = (arg1[32]);\n    let x35: u64 = (((arg1[31]) as u64) << 56);\n    let x36: u64 = (((arg1[30]) as u64) << 48);\n    let x37: u64 = (((arg1[29]) as u64) << 40);\n    let x38: u64 = (((arg1[28]) as u64) << 32);\n    let x39: u64 = (((arg1[27]) as u64) << 24);\n    let x40: u64 = (((arg1[26]) as u64) << 16);\n    let x41: u64 = (((arg1[25]) as u64) << 8);\n    let x42: u8 = (arg1[24]);\n    let x43: u64 = (((arg1[23]) as u64) << 56);\n    let x44: u64 = (((arg1[22]) as u64) << 48);\n    let x45: u64 = (((arg1[21]) as u64) << 40);\n    let x46: u64 = (((arg1[20]) as u64) << 32);\n    let x47: u64 = (((arg1[19]) as u64) << 24);\n    let x48: u64 = (((arg1[18]) as u64) << 16);\n    let x49: u64 = (((arg1[17]) as u64) << 8);\n    let x50: u8 = (arg1[16]);\n    let x51: u64 = (((arg1[15]) as u64) << 56);\n    let x52: u64 = (((arg1[14]) as u64) << 48);\n    let x53: u64 = (((arg1[13]) as u64) << 40);\n    let x54: u64 = (((arg1[12]) as u64) << 32);\n    let x55: u64 = (((arg1[11]) as u64) << 24);\n    let x56: u64 = (((arg1[10]) as u64) << 16);\n    let x57: u64 = (((arg1[9]) as u64) << 8);\n    let x58: u8 = (arg1[8]);\n    let x59: u64 = (((arg1[7]) as u64) << 56);\n    let x60: u64 = (((arg1[6]) as u64) << 48);\n    let x61: u64 = (((arg1[5]) as u64) << 40);\n    let x62: u64 = (((arg1[4]) as u64) << 32);\n    let x63: u64 = (((arg1[3]) as u64) << 24);\n    let x64: u64 = (((arg1[2]) as u64) << 16);\n    let x65: u64 = (((arg1[1]) as u64) << 8);\n    let x66: u8 = (arg1[0]);\n    let x67: u64 = (x65 + (x66 as u64));\n    let x68: u64 = (x64 + x67);\n    let x69: u64 = (x63 + x68);\n    let x70: u64 = (x62 + x69);\n    let x71: u64 = (x61 + x70);\n    let x72: u64 = (x60 + x71);\n    let x73: u64 = (x59 + x72);\n    let x74: u64 = (x57 + (x58 as u64));\n    let x75: u64 = (x56 + x74);\n    let x76: u64 = (x55 + x75);\n    let x77: u64 = (x54 + x76);\n    let x78: u64 = (x53 + x77);\n    let x79: u64 = (x52 + x78);\n    let x80: u64 = (x51 + x79);\n    let x81: u64 = (x49 + (x50 as u64));\n    let x82: u64 = (x48 + x81);\n    let x83: u64 = (x47 + x82);\n    let x84: u64 = (x46 + x83);\n    let x85: u64 = (x45 + x84);\n    let x86: u64 = (x44 + x85);\n    let x87: u64 = (x43 + x86);\n    let x88: u64 = (x41 + (x42 as u64));\n    let x89: u64 = (x40 + x88);\n    let x90: u64 = (x39 + x89);\n    let x91: u64 = (x38 + x90);\n    let x92: u64 = (x37 + x91);\n    let x93: u64 = (x36 + x92);\n    let x94: u64 = (x35 + x93);\n    let x95: u64 = (x33 + (x34 as u64));\n    let x96: u64 = (x32 + x95);\n    let x97: u64 = (x31 + x96);\n    let x98: u64 = (x30 + x97);\n    let x99: u64 = (x29 + x98);\n    let x100: u64 = (x28 + x99);\n    let x101: u64 = (x27 + x100);\n    let x102: u64 = (x25 + (x26 as u64));\n    let x103: u64 = (x24 + x102);\n    let x104: u64 = (x23 + x103);\n    let x105: u64 = (x22 + x104);\n    let x106: u64 = (x21 + x105);\n    let x107: u64 = (x20 + x106);\n    let x108: u64 = (x19 + x107);\n    let x109: u64 = (x17 + (x18 as u64));\n    let x110: u64 = (x16 + x109);\n    let x111: u64 = (x15 + x110);\n    let x112: u64 = (x14 + x111);\n    let x113: u64 = (x13 + x112);\n    let x114: u64 = (x12 + x113);\n    let x115: u64 = (x11 + x114);\n    let x116: u64 = (x9 + (x10 as u64));\n    let x117: u64 = (x8 + x116);\n    let x118: u64 = (x7 + x117);\n    let x119: u64 = (x6 + x118);\n    let x120: u64 = (x5 + x119);\n    let x121: u64 = (x4 + x120);\n    let x122: u64 = (x3 + x121);\n    let x123: u64 = (x1 + (x2 as u64));\n    out1[0] = x73;\n    out1[1] = x80;\n    out1[2] = x87;\n    out1[3] = x94;\n    out1[4] = x101;\n    out1[5] = x108;\n    out1[6] = x115;\n    out1[7] = x122;\n    out1[8] = x123;\n}",
    "display_name": "fiat_p521_scalar_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre ecdsa/signing/impl/SigningKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/signing.rs",
    "relative_path": "bign256/src/ecdsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_relax",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_relax(\n    out1: &mut fiat_p521_loose_field_element,\n    arg1: &fiat_p521_tight_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let x2: u64 = (arg1[1]);\n    let x3: u64 = (arg1[2]);\n    let x4: u64 = (arg1[3]);\n    let x5: u64 = (arg1[4]);\n    let x6: u64 = (arg1[5]);\n    let x7: u64 = (arg1[6]);\n    let x8: u64 = (arg1[7]);\n    let x9: u64 = (arg1[8]);\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n    out1[4] = x5;\n    out1[5] = x6;\n    out1[6] = x7;\n    out1[7] = x8;\n    out1[8] = x9;\n}",
    "display_name": "fiat_p521_relax",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_even",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/is_odd"
    ],
    "body": "    pub fn is_even(&self) -> Choice {\n        !self.0.is_odd()\n    }",
    "display_name": "is_even",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/s1_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn s1_bytes(&self) -> FieldBytes {\n        self.s1.to_bytes()\n    }",
    "display_name": "s1_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/test_vector_double_generator",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/double",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn test_vector_double_generator() {\n        let generator = ProjectivePoint::GENERATOR;\n        let mut p = generator;\n\n        for i in 0..2 {\n            let affine = p.to_affine();\n\n            let (expected_x, expected_y) = ADD_TEST_VECTORS[i];\n            assert_eq!(affine.x.to_bytes(), expected_x);\n            assert_eq!(affine.y.to_bytes(), expected_y);\n\n            p = p.double();\n        }\n    }",
    "display_name": "test_vector_double_generator",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/fiat_p384_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_selectznz(\n    out1: &mut [u64; 4],\n    arg1: fiat_bign256_u1,\n    arg2: &[u64; 4],\n    arg3: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n}",
    "display_name": "fiat_bign256_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/mul/mul"
    ],
    "body": "    fn mul(self, other: Scalar) -> ProjectivePoint {\n        mul(&self, &other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/mul.rs",
    "relative_path": "k256/src/arithmetic/mul.rs",
    "file_name": "mul.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: FieldElement) {\n        *self = *self + other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/add"
    ],
    "body": "    pub fn double(&self) -> Self {\n        Self(self.0.add(&(self.0)))\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_square",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_carry_square(\n    out1: &mut fiat_p521_tight_field_element,\n    arg1: &fiat_p521_loose_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[8]);\n    let x2: u64 = (x1 * 0x2);\n    let x3: u64 = ((arg1[8]) * 0x2);\n    let x4: u64 = (arg1[7]);\n    let x5: u64 = (x4 * 0x2);\n    let x6: u64 = ((arg1[7]) * 0x2);\n    let x7: u64 = (arg1[6]);\n    let x8: u64 = (x7 * 0x2);\n    let x9: u64 = ((arg1[6]) * 0x2);\n    let x10: u64 = (arg1[5]);\n    let x11: u64 = (x10 * 0x2);\n    let x12: u64 = ((arg1[5]) * 0x2);\n    let x13: u64 = ((arg1[4]) * 0x2);\n    let x14: u64 = ((arg1[3]) * 0x2);\n    let x15: u64 = ((arg1[2]) * 0x2);\n    let x16: u64 = ((arg1[1]) * 0x2);\n    let x17: u128 = (((arg1[8]) as u128) * ((x1 * 0x2) as u128));\n    let x18: u128 = (((arg1[7]) as u128) * ((x2 * 0x2) as u128));\n    let x19: u128 = (((arg1[7]) as u128) * ((x4 * 0x2) as u128));\n    let x20: u128 = (((arg1[6]) as u128) * ((x2 * 0x2) as u128));\n    let x21: u128 = (((arg1[6]) as u128) * ((x5 * 0x2) as u128));\n    let x22: u128 = (((arg1[6]) as u128) * ((x7 * 0x2) as u128));\n    let x23: u128 = (((arg1[5]) as u128) * ((x2 * 0x2) as u128));\n    let x24: u128 = (((arg1[5]) as u128) * ((x5 * 0x2) as u128));\n    let x25: u128 = (((arg1[5]) as u128) * ((x8 * 0x2) as u128));\n    let x26: u128 = (((arg1[5]) as u128) * ((x10 * 0x2) as u128));\n    let x27: u128 = (((arg1[4]) as u128) * ((x2 * 0x2) as u128));\n    let x28: u128 = (((arg1[4]) as u128) * ((x5 * 0x2) as u128));\n    let x29: u128 = (((arg1[4]) as u128) * ((x8 * 0x2) as u128));\n    let x30: u128 = (((arg1[4]) as u128) * ((x11 * 0x2) as u128));\n    let x31: u128 = (((arg1[4]) as u128) * ((arg1[4]) as u128));\n    let x32: u128 = (((arg1[3]) as u128) * ((x2 * 0x2) as u128));\n    let x33: u128 = (((arg1[3]) as u128) * ((x5 * 0x2) as u128));\n    let x34: u128 = (((arg1[3]) as u128) * ((x8 * 0x2) as u128));\n    let x35: u128 = (((arg1[3]) as u128) * (x12 as u128));\n    let x36: u128 = (((arg1[3]) as u128) * (x13 as u128));\n    let x37: u128 = (((arg1[3]) as u128) * ((arg1[3]) as u128));\n    let x38: u128 = (((arg1[2]) as u128) * ((x2 * 0x2) as u128));\n    let x39: u128 = (((arg1[2]) as u128) * ((x5 * 0x2) as u128));\n    let x40: u128 = (((arg1[2]) as u128) * (x9 as u128));\n    let x41: u128 = (((arg1[2]) as u128) * (x12 as u128));\n    let x42: u128 = (((arg1[2]) as u128) * (x13 as u128));\n    let x43: u128 = (((arg1[2]) as u128) * (x14 as u128));\n    let x44: u128 = (((arg1[2]) as u128) * ((arg1[2]) as u128));\n    let x45: u128 = (((arg1[1]) as u128) * ((x2 * 0x2) as u128));\n    let x46: u128 = (((arg1[1]) as u128) * (x6 as u128));\n    let x47: u128 = (((arg1[1]) as u128) * (x9 as u128));\n    let x48: u128 = (((arg1[1]) as u128) * (x12 as u128));\n    let x49: u128 = (((arg1[1]) as u128) * (x13 as u128));\n    let x50: u128 = (((arg1[1]) as u128) * (x14 as u128));\n    let x51: u128 = (((arg1[1]) as u128) * (x15 as u128));\n    let x52: u128 = (((arg1[1]) as u128) * ((arg1[1]) as u128));\n    let x53: u128 = (((arg1[0]) as u128) * (x3 as u128));\n    let x54: u128 = (((arg1[0]) as u128) * (x6 as u128));\n    let x55: u128 = (((arg1[0]) as u128) * (x9 as u128));\n    let x56: u128 = (((arg1[0]) as u128) * (x12 as u128));\n    let x57: u128 = (((arg1[0]) as u128) * (x13 as u128));\n    let x58: u128 = (((arg1[0]) as u128) * (x14 as u128));\n    let x59: u128 = (((arg1[0]) as u128) * (x15 as u128));\n    let x60: u128 = (((arg1[0]) as u128) * (x16 as u128));\n    let x61: u128 = (((arg1[0]) as u128) * ((arg1[0]) as u128));\n    let x62: u128 = (x61 + (x45 + (x39 + (x34 + x30))));\n    let x63: u128 = (x62 >> 58);\n    let x64: u64 = ((x62 & (0x3ffffffffffffff as u128)) as u64);\n    let x65: u128 = (x53 + (x46 + (x40 + (x35 + x31))));\n    let x66: u128 = (x54 + (x47 + (x41 + (x36 + x17))));\n    let x67: u128 = (x55 + (x48 + (x42 + (x37 + x18))));\n    let x68: u128 = (x56 + (x49 + (x43 + (x20 + x19))));\n    let x69: u128 = (x57 + (x50 + (x44 + (x23 + x21))));\n    let x70: u128 = (x58 + (x51 + (x27 + (x24 + x22))));\n    let x71: u128 = (x59 + (x52 + (x32 + (x28 + x25))));\n    let x72: u128 = (x60 + (x38 + (x33 + (x29 + x26))));\n    let x73: u128 = (x63 + x72);\n    let x74: u128 = (x73 >> 58);\n    let x75: u64 = ((x73 & (0x3ffffffffffffff as u128)) as u64);\n    let x76: u128 = (x74 + x71);\n    let x77: u128 = (x76 >> 58);\n    let x78: u64 = ((x76 & (0x3ffffffffffffff as u128)) as u64);\n    let x79: u128 = (x77 + x70);\n    let x80: u128 = (x79 >> 58);\n    let x81: u64 = ((x79 & (0x3ffffffffffffff as u128)) as u64);\n    let x82: u128 = (x80 + x69);\n    let x83: u128 = (x82 >> 58);\n    let x84: u64 = ((x82 & (0x3ffffffffffffff as u128)) as u64);\n    let x85: u128 = (x83 + x68);\n    let x86: u128 = (x85 >> 58);\n    let x87: u64 = ((x85 & (0x3ffffffffffffff as u128)) as u64);\n    let x88: u128 = (x86 + x67);\n    let x89: u128 = (x88 >> 58);\n    let x90: u64 = ((x88 & (0x3ffffffffffffff as u128)) as u64);\n    let x91: u128 = (x89 + x66);\n    let x92: u128 = (x91 >> 58);\n    let x93: u64 = ((x91 & (0x3ffffffffffffff as u128)) as u64);\n    let x94: u128 = (x92 + x65);\n    let x95: u128 = (x94 >> 57);\n    let x96: u64 = ((x94 & (0x1ffffffffffffff as u128)) as u64);\n    let x97: u128 = ((x64 as u128) + x95);\n    let x98: u64 = ((x97 >> 58) as u64);\n    let x99: u64 = ((x97 & (0x3ffffffffffffff as u128)) as u64);\n    let x100: u64 = (x98 + x75);\n    let x101: fiat_p521_u1 = ((x100 >> 58) as fiat_p521_u1);\n    let x102: u64 = (x100 & 0x3ffffffffffffff);\n    let x103: u64 = ((x101 as u64) + x78);\n    out1[0] = x99;\n    out1[1] = x102;\n    out1[2] = x103;\n    out1[3] = x81;\n    out1[4] = x84;\n    out1[5] = x87;\n    out1[6] = x90;\n    out1[7] = x93;\n    out1[8] = x96;\n}",
    "display_name": "fiat_p521_carry_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_basic_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/square"
    ],
    "body": "    fn test_basic_square() {\n        let a = Scalar(U448::from_be_hex(\n            \"3162081604b3273b930392e5d2391f9d21cc3078f22c69514bb395e08dccc4866f08f3311370f8b83fa50692f640922b7e56a34bcf5fac3d\",\n        ));\n        let expected_a_squared = Scalar(U448::from_be_hex(\n            \"1c1e32fc66b21c9c42d6e8e20487193cf6d49916421b290098f30de3713006cfe8ee9d21eeef7427f82a1fe036630c74b9acc2c2ede40f04\",\n        ));\n\n        assert_eq!(a.square(), expected_a_squared)\n    }",
    "display_name": "test_basic_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/Group/is_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl/DecafPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Self::IDENTITY)\n    }",
    "display_name": "is_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/GroupEncoding/from_bytes",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/GroupEncoding/from_bytes"
    ],
    "body": "    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        <AffinePoint<C> as GroupEncoding>::from_bytes(bytes).map(Into::into)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &AffinePoint, b: &AffinePoint, choice: Choice) -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n            infinity: u8::conditional_select(&a.infinity, &b.infinity, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "affine/impl/AffinePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y) & self.infinity.ct_eq(&other.infinity)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    fn from(p: ProjectivePoint<C>) -> AffinePoint<C> {\n        p.to_affine()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/compress",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine",
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes",
      "0.14.0_pre.1 field/element/impl/FieldElement/is_negative"
    ],
    "body": "    pub fn compress(&self) -> CompressedEdwardsY {\n        let affine = self.to_affine();\n\n        let affine_x = affine.x;\n        let affine_y = affine.y;\n\n        let mut compressed_bytes = [0u8; 57];\n\n        let sign = affine_x.is_negative().unwrap_u8();\n\n        let y_bytes = affine_y.to_bytes();\n        compressed_bytes[..y_bytes.len()].copy_from_slice(&y_bytes[..]);\n        *compressed_bytes.last_mut().expect(\"at least one byte\") = sign << 7;\n        CompressedEdwardsY(compressed_bytes)\n    }",
    "display_name": "compress",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/get_overflow",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/from_bytes_unchecked"
    ],
    "body": "    pub fn from_bytes(bytes: &FieldBytes) -> CtOption<Self> {\n        let res = Self::from_bytes_unchecked(bytes.as_ref());\n        let overflow = res.get_overflow();\n        CtOption::new(res, !overflow)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre dummy_cert_builder",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/new"
    ],
    "body": "    fn dummy_cert_builder<S, Signature>(_signer: &S)\n    where\n        S: Signer<Signature>,\n        S: Keypair + DynSignatureAlgorithmIdentifier,\n        S::VerifyingKey: EncodePublicKey,\n        Signature: SignatureBitStringEncoding,\n    {\n        // we just want to check the trait bounds here\n    }",
    "display_name": "dummy_cert_builder",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_square<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"square\", |b| b.iter(|| black_box(x).square()));\n}",
    "display_name": "bench_field_element_square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/field.rs",
    "relative_path": "k256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0.as_words()[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/root_of_unity_inv_constant",
    "statement_type": "function",
    "deps": [],
    "body": "    fn root_of_unity_inv_constant() {\n        assert_eq!(\n            Scalar::ROOT_OF_UNITY * Scalar::ROOT_OF_UNITY_INV,\n            Scalar::ONE\n        );\n    }",
    "display_name": "root_of_unity_inv_constant",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/Vec/From/from"
    ],
    "body": "    fn from(value: EdwardsPoint) -> Self {\n        Self::from(&value)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_msat(out1: &mut [u64; 4]) {\n    out1[0] = 0x146bc9b1b4d22831;\n    out1[1] = 0xffffffff99def836;\n    out1[2] = 0xffffffffffffffff;\n    out1[3] = (0x0 as u64);\n}",
    "display_name": "fiat_p192_scalar_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/subtract_n_if_necessary",
    "statement_type": "function",
    "deps": [],
    "body": "const fn subtract_n_if_necessary(r: [Limb; 5]) -> [Limb; 5] {\n    let modulus = MODULUS.as_limbs();\n\n    let (w0, borrow) = r[0].borrowing_sub(modulus[0], Limb::ZERO);\n    let (w1, borrow) = r[1].borrowing_sub(modulus[1], borrow);\n    let (w2, borrow) = r[2].borrowing_sub(modulus[2], borrow);\n    let (w3, borrow) = r[3].borrowing_sub(modulus[3], borrow);\n    let (w4, borrow) = r[4].borrowing_sub(Limb::ZERO, borrow);\n\n    // If underflow occurred on the final limb, borrow = 0xfff...fff, otherwise\n    // borrow = 0x000...000. Thus, we use it as a mask to conditionally add the\n    // modulus.\n    let (w0, carry) = w0.carrying_add(modulus[0].bitand(borrow), Limb::ZERO);\n    let (w1, carry) = w1.carrying_add(modulus[1].bitand(borrow), carry);\n    let (w2, carry) = w2.carrying_add(modulus[2].bitand(borrow), carry);\n    let (w3, carry) = w3.carrying_add(modulus[3].bitand(borrow), carry);\n    let (w4, _carry) = w4.carrying_add(Limb::ZERO, carry);\n\n    [w0, w1, w2, w3, w4]\n}",
    "display_name": "subtract_n_if_necessary",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar/scalar64.rs",
    "relative_path": "p256/src/arithmetic/scalar/scalar64.rs",
    "file_name": "scalar64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_d",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_d() -> NonZeroScalar {\n    NonZeroScalar::new(\n        Scalar::from_repr(\n            [\n                0xbb, 0x48, 0x8a, 0xef, 0x41, 0x6a, 0x41, 0xd7, 0x68, 0x0d, 0x1c, 0xf0, 0x1d, 0x70,\n                0xf5, 0x9b, 0x60, 0xd7, 0xf5, 0xf7, 0x7e, 0x30, 0xe7, 0x8b, 0x8b, 0xf9, 0xd2, 0xd8,\n                0x82, 0xf1, 0x56, 0xa6,\n            ]\n            .into(),\n        )\n        .unwrap(),\n    )\n    .unwrap()\n}",
    "display_name": "test_scalar_d",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/ecdsa.rs",
    "relative_path": "k256/benches/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &SecretKey {\n        &self.secret.seed\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64"
    ],
    "body": "pub const fn fiat_bign256_sub(\n    out1: &mut fiat_bign256_montgomery_domain_field_element,\n    arg1: &fiat_bign256_montgomery_domain_field_element,\n    arg2: &fiat_bign256_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_bign256_u1 = 0;\n    fiat_bign256_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    fiat_bign256_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, (x9 & 0xffffffffffffff43));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x12, &mut x13, x11, x3, x9);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_bign256_u1 = 0;\n    fiat_bign256_addcarryx_u64(&mut x16, &mut x17, x15, x7, x9);\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_bign256_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/from_affine",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/new",
      "0.14.0_pre public_key/impl/PublicKey/from_affine"
    ],
    "body": "    pub fn from_affine(affine: AffinePoint) -> Result<Self> {\n        let public_key = PublicKey::from_affine(affine).map_err(|_| Error::new())?;\n        Self::new(public_key)\n    }",
    "display_name": "from_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/SignatureEncoding/encoded_len",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encoded_len(&self) -> usize {\n        Self::BYTE_SIZE\n    }",
    "display_name": "encoded_len",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/CompressedDecaf/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &[u8] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = &'a Scalar>>(iter: I) -> Self {\n        iter.copied().sum()\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_sm2_scalar_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.7.0_pre decode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_field_bytes(field_bytes: &FieldBytes) -> U256 {\n    U256::from_be_byte_array(*field_bytes)\n}",
    "display_name": "decode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp256/src/lib.rs",
    "relative_path": "bp256/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_divstep",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_divstep(\n    out1: &mut u64,\n    out2: &mut [u64; 5],\n    out3: &mut [u64; 5],\n    out4: &mut [u64; 4],\n    out5: &mut [u64; 4],\n    arg1: u64,\n    arg2: &[u64; 5],\n    arg3: &[u64; 5],\n    arg4: &[u64; 4],\n    arg5: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (!arg1), (0x1 as u64));\n    let x3: fiat_p224_scalar_u1 =\n        (((x1 >> 63) as fiat_p224_scalar_u1) & (((arg3[0]) & (0x1 as u64)) as fiat_p224_scalar_u1));\n    let mut x4: u64 = 0;\n    let mut x5: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x4, &mut x5, 0x0, (!arg1), (0x1 as u64));\n    let mut x6: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x6, x3, arg1, x4);\n    let mut x7: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x7, x3, (arg2[0]), (arg3[0]));\n    let mut x8: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x8, x3, (arg2[1]), (arg3[1]));\n    let mut x9: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x9, x3, (arg2[2]), (arg3[2]));\n    let mut x10: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x10, x3, (arg2[3]), (arg3[3]));\n    let mut x11: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x11, x3, (arg2[4]), (arg3[4]));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x12, &mut x13, 0x0, (0x1 as u64), (!(arg2[0])));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x14, &mut x15, x13, (0x0 as u64), (!(arg2[1])));\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), (!(arg2[2])));\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), (!(arg2[3])));\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), (!(arg2[4])));\n    let mut x22: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x22, x3, (arg3[0]), x12);\n    let mut x23: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x23, x3, (arg3[1]), x14);\n    let mut x24: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x24, x3, (arg3[2]), x16);\n    let mut x25: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x25, x3, (arg3[3]), x18);\n    let mut x26: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x26, x3, (arg3[4]), x20);\n    let mut x27: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x27, x3, (arg4[0]), (arg5[0]));\n    let mut x28: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x28, x3, (arg4[1]), (arg5[1]));\n    let mut x29: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x29, x3, (arg4[2]), (arg5[2]));\n    let mut x30: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x30, x3, (arg4[3]), (arg5[3]));\n    let mut x31: u64 = 0;\n    let mut x32: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x31, &mut x32, 0x0, x27, x27);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x33, &mut x34, x32, x28, x28);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x35, &mut x36, x34, x29, x29);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x37, &mut x38, x36, x30, x30);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x39, &mut x40, 0x0, x31, 0x13dd29455c5c2a3d);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x41, &mut x42, x40, x33, 0xffff16a2e0b8f03e);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x43, &mut x44, x42, x35, 0xffffffffffffffff);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x45, &mut x46, x44, x37, 0xffffffff);\n    let mut x47: u64 = 0;\n    let mut x48: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x47, &mut x48, x46, (x38 as u64), (0x0 as u64));\n    let x49: u64 = (arg4[3]);\n    let x50: u64 = (arg4[2]);\n    let x51: u64 = (arg4[1]);\n    let x52: u64 = (arg4[0]);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x53, &mut x54, 0x0, (0x0 as u64), x52);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x55, &mut x56, x54, (0x0 as u64), x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x57, &mut x58, x56, (0x0 as u64), x50);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x59, &mut x60, x58, (0x0 as u64), x49);\n    let mut x61: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x61, x60, (0x0 as u64), 0xffffffffffffffff);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x53, (x61 & 0x13dd29455c5c2a3d));\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x55, (x61 & 0xffff16a2e0b8f03e));\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x57, x61);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x59, (x61 & 0xffffffff));\n    let mut x70: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x70, x3, (arg5[0]), x62);\n    let mut x71: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x71, x3, (arg5[1]), x64);\n    let mut x72: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x72, x3, (arg5[2]), x66);\n    let mut x73: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x73, x3, (arg5[3]), x68);\n    let x74: fiat_p224_scalar_u1 = ((x22 & (0x1 as u64)) as fiat_p224_scalar_u1);\n    let mut x75: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x75, x74, (0x0 as u64), x7);\n    let mut x76: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x76, x74, (0x0 as u64), x8);\n    let mut x77: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x77, x74, (0x0 as u64), x9);\n    let mut x78: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x78, x74, (0x0 as u64), x10);\n    let mut x79: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x79, x74, (0x0 as u64), x11);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x80, &mut x81, 0x0, x22, x75);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x23, x76);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x24, x77);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x25, x78);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x26, x79);\n    let mut x90: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x90, x74, (0x0 as u64), x27);\n    let mut x91: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x91, x74, (0x0 as u64), x28);\n    let mut x92: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x92, x74, (0x0 as u64), x29);\n    let mut x93: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x93, x74, (0x0 as u64), x30);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x94, &mut x95, 0x0, x70, x90);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x71, x91);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x72, x92);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x73, x93);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x102, &mut x103, 0x0, x94, 0x13dd29455c5c2a3d);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x104, &mut x105, x103, x96, 0xffff16a2e0b8f03e);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x106, &mut x107, x105, x98, 0xffffffffffffffff);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x108, &mut x109, x107, x100, 0xffffffff);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x110, &mut x111, x109, (x101 as u64), (0x0 as u64));\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x112, &mut x113, 0x0, x6, (0x1 as u64));\n    let x114: u64 = ((x80 >> 1) | ((x82 << 63) & 0xffffffffffffffff));\n    let x115: u64 = ((x82 >> 1) | ((x84 << 63) & 0xffffffffffffffff));\n    let x116: u64 = ((x84 >> 1) | ((x86 << 63) & 0xffffffffffffffff));\n    let x117: u64 = ((x86 >> 1) | ((x88 << 63) & 0xffffffffffffffff));\n    let x118: u64 = ((x88 & 0x8000000000000000) | (x88 >> 1));\n    let mut x119: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x119, x48, x39, x31);\n    let mut x120: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x120, x48, x41, x33);\n    let mut x121: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x121, x48, x43, x35);\n    let mut x122: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x122, x48, x45, x37);\n    let mut x123: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x123, x111, x102, x94);\n    let mut x124: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x124, x111, x104, x96);\n    let mut x125: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x125, x111, x106, x98);\n    let mut x126: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x126, x111, x108, x100);\n    *out1 = x112;\n    out2[0] = x7;\n    out2[1] = x8;\n    out2[2] = x9;\n    out2[3] = x10;\n    out2[4] = x11;\n    out3[0] = x114;\n    out3[1] = x115;\n    out3[2] = x116;\n    out3[3] = x117;\n    out3[4] = x118;\n    out4[0] = x119;\n    out4[1] = x120;\n    out4[2] = x121;\n    out4[3] = x122;\n    out5[0] = x123;\n    out5[1] = x124;\n    out5[2] = x125;\n    out5[3] = x126;\n}",
    "display_name": "fiat_p224_scalar_divstep",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_hex",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint_unchecked"
    ],
    "body": "    pub(crate) const fn from_hex(hex: &str) -> Self {\n        Self::from_uint_unchecked(U576::from_be_hex(hex))\n    }",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/to_nonidentity",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_nonidentity(&self) -> NonIdentity<AffinePoint<BignP256>> {\n        NonIdentity::new(self.point).unwrap()\n    }",
    "display_name": "to_nonidentity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_bign256_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_sm2_scalar_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_from_montgomery(\n    out1: &mut fiat_sm2_scalar_non_montgomery_domain_field_element,\n    arg1: &fiat_sm2_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x2, &mut x3, x1, 0x327f9e8872350975);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x4, &mut x5, x2, 0xfffffffeffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x6, &mut x7, x2, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x8, &mut x9, x2, 0x7203df6b21c6052b);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x10, &mut x11, x2, 0x53bbf40939d54123);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x12, &mut x13, 0x0, x11, x8);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x9, x6);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, x4);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x18, &mut x19, 0x0, x1, x10);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), x12);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x22, &mut x23, x21, (0x0 as u64), x14);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x24, &mut x25, x23, (0x0 as u64), x16);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x26, &mut x27, 0x0, x20, (arg1[1]));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x28, &mut x29, x27, x22, (0x0 as u64));\n    let mut x30: u64 = 0;\n    let mut x31: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x24, (0x0 as u64));\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x32, &mut x33, x26, 0x327f9e8872350975);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x34, &mut x35, x32, 0xfffffffeffffffff);\n    let mut x36: u64 = 0;\n    let mut x37: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x36, &mut x37, x32, 0xffffffffffffffff);\n    let mut x38: u64 = 0;\n    let mut x39: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x38, &mut x39, x32, 0x7203df6b21c6052b);\n    let mut x40: u64 = 0;\n    let mut x41: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x40, &mut x41, x32, 0x53bbf40939d54123);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x42, &mut x43, 0x0, x41, x38);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x44, &mut x45, x43, x39, x36);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x46, &mut x47, x45, x37, x34);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x48, &mut x49, 0x0, x26, x40);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x50, &mut x51, x49, x28, x42);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x52, &mut x53, x51, x30, x44);\n    let mut x54: u64 = 0;\n    let mut x55: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(\n        &mut x54,\n        &mut x55,\n        x53,\n        ((x31 as u64) + ((x25 as u64) + ((x17 as u64) + x5))),\n        x46,\n    );\n    let mut x56: u64 = 0;\n    let mut x57: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x56, &mut x57, 0x0, x50, (arg1[2]));\n    let mut x58: u64 = 0;\n    let mut x59: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x58, &mut x59, x57, x52, (0x0 as u64));\n    let mut x60: u64 = 0;\n    let mut x61: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x60, &mut x61, x59, x54, (0x0 as u64));\n    let mut x62: u64 = 0;\n    let mut x63: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x62, &mut x63, x56, 0x327f9e8872350975);\n    let mut x64: u64 = 0;\n    let mut x65: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x64, &mut x65, x62, 0xfffffffeffffffff);\n    let mut x66: u64 = 0;\n    let mut x67: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x66, &mut x67, x62, 0xffffffffffffffff);\n    let mut x68: u64 = 0;\n    let mut x69: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x68, &mut x69, x62, 0x7203df6b21c6052b);\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x70, &mut x71, x62, 0x53bbf40939d54123);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x72, &mut x73, 0x0, x71, x68);\n    let mut x74: u64 = 0;\n    let mut x75: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x74, &mut x75, x73, x69, x66);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x76, &mut x77, x75, x67, x64);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x78, &mut x79, 0x0, x56, x70);\n    let mut x80: u64 = 0;\n    let mut x81: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x80, &mut x81, x79, x58, x72);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x82, &mut x83, x81, x60, x74);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(\n        &mut x84,\n        &mut x85,\n        x83,\n        ((x61 as u64) + ((x55 as u64) + ((x47 as u64) + x35))),\n        x76,\n    );\n    let mut x86: u64 = 0;\n    let mut x87: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x86, &mut x87, 0x0, x80, (arg1[3]));\n    let mut x88: u64 = 0;\n    let mut x89: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x82, (0x0 as u64));\n    let mut x90: u64 = 0;\n    let mut x91: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x84, (0x0 as u64));\n    let mut x92: u64 = 0;\n    let mut x93: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x92, &mut x93, x86, 0x327f9e8872350975);\n    let mut x94: u64 = 0;\n    let mut x95: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x94, &mut x95, x92, 0xfffffffeffffffff);\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x96, &mut x97, x92, 0xffffffffffffffff);\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x98, &mut x99, x92, 0x7203df6b21c6052b);\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x100, &mut x101, x92, 0x53bbf40939d54123);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x102, &mut x103, 0x0, x101, x98);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x104, &mut x105, x103, x99, x96);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x106, &mut x107, x105, x97, x94);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x86, x100);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x88, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x90, x104);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(\n        &mut x114,\n        &mut x115,\n        x113,\n        ((x91 as u64) + ((x85 as u64) + ((x77 as u64) + x65))),\n        x106,\n    );\n    let x116: u64 = ((x115 as u64) + ((x107 as u64) + x95));\n    let mut x117: u64 = 0;\n    let mut x118: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x117, &mut x118, 0x0, x110, 0x53bbf40939d54123);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x119, &mut x120, x118, x112, 0x7203df6b21c6052b);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x121, &mut x122, x120, x114, 0xffffffffffffffff);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x123, &mut x124, x122, x116, 0xfffffffeffffffff);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x125, &mut x126, x124, (0x0 as u64), (0x0 as u64));\n    let mut x127: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x127, x126, x117, x110);\n    let mut x128: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x128, x126, x119, x112);\n    let mut x129: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x129, x126, x121, x114);\n    let mut x130: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x130, x126, x123, x116);\n    out1[0] = x127;\n    out1[1] = x128;\n    out1[2] = x129;\n    out1[3] = x130;\n}",
    "display_name": "fiat_sm2_scalar_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 encode_pkcs8_public_key_to_der",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_public_key_to_der() {\n    let original_public_key =\n        p256::PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    let reencoded_public_key = original_public_key.to_public_key_der().unwrap();\n    assert_eq!(reencoded_public_key.as_ref(), &PKCS8_PUBLIC_KEY_DER[..]);\n}",
    "display_name": "encode_pkcs8_public_key_to_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/pkcs8.rs",
    "relative_path": "p256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From/from"
    ],
    "body": "    fn mul(self, scalar: Scalar) -> ProjectivePoint {\n        ProjectivePoint::from(self) * scalar\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p224_from_montgomery(\n    out1: &mut fiat_p224_non_montgomery_domain_field_element,\n    arg1: &fiat_p224_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_p224_mulx_u64(&mut x2, &mut x3, x1, 0xffffffffffffffff);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p224_mulx_u64(&mut x4, &mut x5, x2, 0xffffffff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p224_mulx_u64(&mut x6, &mut x7, x2, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p224_mulx_u64(&mut x8, &mut x9, x2, 0xffffffff00000000);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x10, &mut x11, 0x0, x9, x6);\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x12, &mut x13, x11, x7, x4);\n    let mut x14: u64 = 0;\n    let mut x15: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x14, &mut x15, 0x0, x1, x2);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x16, &mut x17, x15, (0x0 as u64), x8);\n    let mut x18: u64 = 0;\n    let mut x19: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x18, &mut x19, x17, (0x0 as u64), x10);\n    let mut x20: u64 = 0;\n    let mut x21: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x20, &mut x21, x19, (0x0 as u64), x12);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x22, &mut x23, 0x0, x16, (arg1[1]));\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x24, &mut x25, x23, x18, (0x0 as u64));\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x26, &mut x27, x25, x20, (0x0 as u64));\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_p224_mulx_u64(&mut x28, &mut x29, x22, 0xffffffffffffffff);\n    let mut x30: u64 = 0;\n    let mut x31: u64 = 0;\n    fiat_p224_mulx_u64(&mut x30, &mut x31, x28, 0xffffffff);\n    let mut x32: u64 = 0;\n    let mut x33: u64 = 0;\n    fiat_p224_mulx_u64(&mut x32, &mut x33, x28, 0xffffffffffffffff);\n    let mut x34: u64 = 0;\n    let mut x35: u64 = 0;\n    fiat_p224_mulx_u64(&mut x34, &mut x35, x28, 0xffffffff00000000);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x36, &mut x37, 0x0, x35, x32);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x38, &mut x39, x37, x33, x30);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x40, &mut x41, 0x0, x22, x28);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x42, &mut x43, x41, x24, x34);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x44, &mut x45, x43, x26, x36);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x46,\n        &mut x47,\n        x45,\n        ((x27 as u64) + ((x21 as u64) + ((x13 as u64) + x5))),\n        x38,\n    );\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x48, &mut x49, 0x0, x42, (arg1[2]));\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x50, &mut x51, x49, x44, (0x0 as u64));\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x52, &mut x53, x51, x46, (0x0 as u64));\n    let mut x54: u64 = 0;\n    let mut x55: u64 = 0;\n    fiat_p224_mulx_u64(&mut x54, &mut x55, x48, 0xffffffffffffffff);\n    let mut x56: u64 = 0;\n    let mut x57: u64 = 0;\n    fiat_p224_mulx_u64(&mut x56, &mut x57, x54, 0xffffffff);\n    let mut x58: u64 = 0;\n    let mut x59: u64 = 0;\n    fiat_p224_mulx_u64(&mut x58, &mut x59, x54, 0xffffffffffffffff);\n    let mut x60: u64 = 0;\n    let mut x61: u64 = 0;\n    fiat_p224_mulx_u64(&mut x60, &mut x61, x54, 0xffffffff00000000);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x62, &mut x63, 0x0, x61, x58);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x64, &mut x65, x63, x59, x56);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x66, &mut x67, 0x0, x48, x54);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x68, &mut x69, x67, x50, x60);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x70, &mut x71, x69, x52, x62);\n    let mut x72: u64 = 0;\n    let mut x73: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x72,\n        &mut x73,\n        x71,\n        ((x53 as u64) + ((x47 as u64) + ((x39 as u64) + x31))),\n        x64,\n    );\n    let mut x74: u64 = 0;\n    let mut x75: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x74, &mut x75, 0x0, x68, (arg1[3]));\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x76, &mut x77, x75, x70, (0x0 as u64));\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x78, &mut x79, x77, x72, (0x0 as u64));\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_p224_mulx_u64(&mut x80, &mut x81, x74, 0xffffffffffffffff);\n    let mut x82: u64 = 0;\n    let mut x83: u64 = 0;\n    fiat_p224_mulx_u64(&mut x82, &mut x83, x80, 0xffffffff);\n    let mut x84: u64 = 0;\n    let mut x85: u64 = 0;\n    fiat_p224_mulx_u64(&mut x84, &mut x85, x80, 0xffffffffffffffff);\n    let mut x86: u64 = 0;\n    let mut x87: u64 = 0;\n    fiat_p224_mulx_u64(&mut x86, &mut x87, x80, 0xffffffff00000000);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x88, &mut x89, 0x0, x87, x84);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x90, &mut x91, x89, x85, x82);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x92, &mut x93, 0x0, x74, x80);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x94, &mut x95, x93, x76, x86);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x96, &mut x97, x95, x78, x88);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(\n        &mut x98,\n        &mut x99,\n        x97,\n        ((x79 as u64) + ((x73 as u64) + ((x65 as u64) + x57))),\n        x90,\n    );\n    let x100: u64 = ((x99 as u64) + ((x91 as u64) + x83));\n    let mut x101: u64 = 0;\n    let mut x102: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x101, &mut x102, 0x0, x94, (0x1 as u64));\n    let mut x103: u64 = 0;\n    let mut x104: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x103, &mut x104, x102, x96, 0xffffffff00000000);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x105, &mut x106, x104, x98, 0xffffffffffffffff);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x107, &mut x108, x106, x100, 0xffffffff);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x109, &mut x110, x108, (0x0 as u64), (0x0 as u64));\n    let mut x111: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x111, x110, x101, x94);\n    let mut x112: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x112, x110, x103, x96);\n    let mut x113: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x113, x110, x105, x98);\n    let mut x114: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x114, x110, x107, x100);\n    out1[0] = x111;\n    out1[1] = x112;\n    out1[2] = x113;\n    out1[3] = x114;\n}",
    "display_name": "fiat_p224_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: FieldElement) {\n        *self = *self + -other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "    fn mul(self, other: &Scalar) -> Scalar {\n        Scalar::multiply(self, other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/fuzzy_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/ToBigUint/to_biguint",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/From/from",
      "0.14.0_pre.8 arithmetic/field/tests/field_element"
    ],
    "body": "        fn fuzzy_add(\n            a in field_element(),\n            b in field_element()\n        ) {\n            let a_bi = a.to_biguint().unwrap();\n            let b_bi = b.to_biguint().unwrap();\n            let res_bi = (&a_bi + &b_bi) % FieldElement::modulus_as_biguint();\n            let res_ref = FieldElement::from(&res_bi);\n            let res_test = (&a + &b).normalize();\n            assert_eq!(res_test, res_ref);\n        }",
    "display_name": "fuzzy_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/elliptic_curve::PublicKey/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(vk: &VerifyingKey) -> PublicKey {\n        vk.inner\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/to_vec",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/to_bytes"
    ],
    "body": "    pub fn to_vec(&self) -> Vec<u8> {\n        self.to_bytes().to_vec()\n    }",
    "display_name": "to_vec",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/&Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/addition"
    ],
    "body": "    fn add(self, rhs: &Scalar) -> Self::Output {\n        self.addition(rhs)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 recover_from_msg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 signing_key"
    ],
    "body": "    fn recover_from_msg(sk in signing_key()) {\n        let msg = b\"example\";\n        let (signature, v) = sk.sign_recoverable(msg).unwrap();\n        let recovered_vk = VerifyingKey::recover_from_msg(msg, &signature, v).unwrap();\n        prop_assert_eq!(sk.verifying_key(), &recovered_vk);\n    }",
    "display_name": "recover_from_msg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/ecdsa.rs",
    "relative_path": "p256/tests/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p192_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p192_sub(\n    out1: &mut fiat_p192_montgomery_domain_field_element,\n    arg1: &fiat_p192_montgomery_domain_field_element,\n    arg2: &fiat_p192_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p192_u1 = 0;\n    fiat_p192_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    fiat_p192_cmovznz_u64(&mut x7, x6, (0x0 as u64), 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x8, &mut x9, 0x0, x1, x7);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x10, &mut x11, x9, x3, (x7 & 0xfffffffffffffffe));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_p192_u1 = 0;\n    fiat_p192_addcarryx_u64(&mut x12, &mut x13, x11, x5, x7);\n    out1[0] = x8;\n    out1[1] = x10;\n    out1[2] = x12;\n}",
    "display_name": "fiat_p192_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/add",
    "statement_type": "function",
    "deps": [
      "point_arithmetic/sealed/PointArithmetic/add"
    ],
    "body": "    pub fn add(&self, other: &Self) -> Self {\n        C::PointArithmetic::add(self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add(self, other: Scalar) -> Scalar {\n        Scalar::add(self, &other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_msat(out1: &mut [u64; 5]) {\n    out1[0] = 0x7e5abf99263d6607;\n    out1[1] = 0xd95c8ed60dfb4dfc;\n    out1[2] = 0xffffffffffffffff;\n    out1[3] = 0xffffffffffffffff;\n    out1[4] = (0x0 as u64);\n}",
    "display_name": "fiat_bign256_scalar_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/negate",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn negate(&self) -> AffinePoint {\n        AffinePoint {\n            x: -self.x,\n            y: self.y,\n        }\n    }",
    "display_name": "negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn double(&self) -> Self {\n        self.add(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/signing_secret_key_equivalent",
    "statement_type": "function",
    "deps": [],
    "body": "    fn signing_secret_key_equivalent() {\n        let raw_sk: [u8; 48] = [\n            32, 52, 118, 9, 96, 116, 119, 172, 168, 251, 251, 197, 230, 33, 132, 85, 243, 25, 150,\n            105, 121, 46, 248, 180, 102, 250, 168, 123, 220, 103, 121, 129, 68, 200, 72, 221, 3,\n            102, 30, 237, 90, 198, 36, 97, 52, 12, 234, 150,\n        ];\n\n        let seck = SecretKey::from_bytes(&raw_sk.into()).unwrap();\n        let sigk = SigningKey::from_bytes(&raw_sk.into()).unwrap();\n\n        assert_eq!(seck.to_bytes().as_slice(), &raw_sk);\n        assert_eq!(sigk.to_bytes().as_slice(), &raw_sk);\n    }",
    "display_name": "signing_secret_key_equivalent",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/ecdsa.rs",
    "relative_path": "p384/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/context/impl/Context/key",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn key(&self) -> &'k K {\n        self.key\n    }",
    "display_name": "key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/context.rs",
    "relative_path": "ed448-goldilocks/src/sign/context.rs",
    "file_name": "context.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/projective_mixed_addition",
    "statement_type": "function",
    "deps": [],
    "body": "    fn projective_mixed_addition() {\n        let identity = ProjectivePoint::IDENTITY;\n        let basepoint_affine = AffinePoint::GENERATOR;\n        let basepoint_projective = ProjectivePoint::GENERATOR;\n\n        assert_eq!(identity + &basepoint_affine, basepoint_projective);\n        assert_eq!(\n            basepoint_projective + &basepoint_affine,\n            basepoint_projective + &basepoint_projective\n        );\n    }",
    "display_name": "projective_mixed_addition",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/impl/Signature/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> SignatureBytes {\n        let mut ret = [0; Self::BYTE_SIZE];\n        let (r_bytes, s_bytes) = ret.split_at_mut(Self::BYTE_SIZE / 2);\n        r_bytes.copy_from_slice(&self.r.to_bytes());\n        s_bytes.copy_from_slice(&self.s.to_bytes());\n        ret\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "point_arithmetic/impl/EquationAIsGeneric/PointArithmetic/double",
    "statement_type": "function",
    "deps": [],
    "body": "    fn double(point: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        let b3 = C::EQUATION_B * C::FieldElement::from(3);\n\n        let t0 = point.x * point.x; // 1\n        let t1 = point.y * point.y; // 2\n        let t2 = point.z * point.z; // 3\n        let t3 = point.x * point.y; // 4\n        let t3 = t3 + t3; // 5\n        let z3 = point.x * point.z; // 6\n        let z3 = z3 + z3; // 7\n        let x3 = C::EQUATION_A * z3; // 8\n        let y3 = b3 * t2; // 9\n        let y3 = x3 + y3; // 10\n        let x3 = t1 - y3; // 11\n        let y3 = t1 + y3; // 12\n        let y3 = x3 * y3; // 13\n        let x3 = t3 * x3; // 14\n        let z3 = b3 * z3; // 15\n        let t2 = C::EQUATION_A * t2; // 16\n        let t3 = t0 - t2; // 17\n        let t3 = C::EQUATION_A * t3; // 18\n        let t3 = t3 + z3; // 19\n        let z3 = t0 + t0; // 20\n        let t0 = z3 + t0; // 21\n        let t0 = t0 + t2; // 22\n        let t0 = t0 * t3; // 23\n        let y3 = y3 + t0; // 24\n        let t2 = point.y * point.z; // 25\n        let t2 = t2 + t2; // 26\n        let t0 = t2 * t3; // 27\n        let x3 = x3 - t0; // 28\n        let z3 = t2 * t1; // 29\n        let z3 = z3 + z3; // 30\n        let z3 = z3 + z3; // 31\n\n        ProjectivePoint {\n            x: x3,\n            y: y3,\n            z: z3,\n        }\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/point_arithmetic.rs",
    "relative_path": "primeorder/src/point_arithmetic.rs",
    "file_name": "point_arithmetic.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_from_canonical_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_canonical_bytes"
    ],
    "body": "    fn test_from_canonical_bytes() {\n        // ff..ff should fail\n        let mut bytes = ScalarBytes::from(hex!(\n            \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n        ));\n        bytes.reverse();\n        let s = Scalar::from_canonical_bytes(&bytes);\n        assert!(<Choice as Into<bool>>::into(s.is_none()));\n\n        // n should fail\n        let mut bytes = ScalarBytes::from(hex!(\n            \"003fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3\"\n        ));\n        bytes.reverse();\n        let s = Scalar::from_canonical_bytes(&bytes);\n        assert!(<Choice as Into<bool>>::into(s.is_none()));\n\n        // n-1 should work\n        let mut bytes = ScalarBytes::from(hex!(\n            \"003fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f2\"\n        ));\n        bytes.reverse();\n        let s = Scalar::from_canonical_bytes(&bytes);\n        match Option::<Scalar>::from(s) {\n            Some(s) => assert_eq!(s, Scalar::ZERO - Scalar::ONE),\n            None => panic!(\"should not return None\"),\n        };\n    }",
    "display_name": "test_from_canonical_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/montgomery/impl/MontgomeryPoint/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &[u8; 56] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/montgomery.rs",
    "relative_path": "ed448-goldilocks/src/curve/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "curve"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/decrypt_digest",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/decrypt"
    ],
    "body": "    pub fn decrypt_digest<D>(&self, ciphertext: &[u8]) -> Result<Vec<u8>>\n    where\n        D: 'static + Digest + DynDigest + Send + Sync,\n    {\n        let mut digest = D::new();\n        decrypt(&self.secret_scalar, self.mode, &mut digest, ciphertext)\n    }",
    "display_name": "decrypt_digest",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "    fn is_odd(&self) -> Choice {\n        self.0.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_field_element_sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_field_element_x"
    ],
    "body": "fn bench_field_element_sqrt<'a, M: Measurement>(group: &mut BenchmarkGroup<'a, M>) {\n    let x = test_field_element_x();\n    group.bench_function(\"sqrt\", |b| b.iter(|| x.sqrt()));\n}",
    "display_name": "bench_field_element_sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/field.rs",
    "relative_path": "p521/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/try_from_rng",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn try_from_rng<R: TryCryptoRng + ?Sized>(\n        rng: &mut R,\n    ) -> core::result::Result<Self, R::Error> {\n        Ok(Self {\n            inner: NonZeroScalar::try_from_rng(rng)?.into(),\n        })\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p521_selectznz(\n    out1: &mut [u64; 9],\n    arg1: fiat_p521_u1,\n    arg2: &[u64; 9],\n    arg3: &[u64; 9],\n) {\n    let mut x1: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    let mut x5: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x5, arg1, (arg2[4]), (arg3[4]));\n    let mut x6: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x6, arg1, (arg2[5]), (arg3[5]));\n    let mut x7: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x7, arg1, (arg2[6]), (arg3[6]));\n    let mut x8: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x8, arg1, (arg2[7]), (arg3[7]));\n    let mut x9: u64 = 0;\n    fiat_p521_cmovznz_u64(&mut x9, arg1, (arg2[8]), (arg3[8]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n    out1[4] = x5;\n    out1[5] = x6;\n    out1[6] = x7;\n    out1[7] = x8;\n    out1[8] = x9;\n}",
    "display_name": "fiat_p521_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p192_scalar_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_scalar_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p192_scalar_u1,\n    arg1: fiat_p192_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_p192_scalar_i1 = ((x1 >> 64) as fiat_p192_scalar_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p192_scalar_i2) - (x2 as fiat_p192_scalar_i2)) as fiat_p192_scalar_u1);\n}",
    "display_name": "fiat_p192_scalar_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: &PointBytes) -> Result<Self, Self::Error> {\n        Self::try_from(*value)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_from_bytes(out1: &mut [u64; 4], arg1: &[u8; 28]) {\n    let x1: u64 = (((arg1[27]) as u64) << 24);\n    let x2: u64 = (((arg1[26]) as u64) << 16);\n    let x3: u64 = (((arg1[25]) as u64) << 8);\n    let x4: u8 = (arg1[24]);\n    let x5: u64 = (((arg1[23]) as u64) << 56);\n    let x6: u64 = (((arg1[22]) as u64) << 48);\n    let x7: u64 = (((arg1[21]) as u64) << 40);\n    let x8: u64 = (((arg1[20]) as u64) << 32);\n    let x9: u64 = (((arg1[19]) as u64) << 24);\n    let x10: u64 = (((arg1[18]) as u64) << 16);\n    let x11: u64 = (((arg1[17]) as u64) << 8);\n    let x12: u8 = (arg1[16]);\n    let x13: u64 = (((arg1[15]) as u64) << 56);\n    let x14: u64 = (((arg1[14]) as u64) << 48);\n    let x15: u64 = (((arg1[13]) as u64) << 40);\n    let x16: u64 = (((arg1[12]) as u64) << 32);\n    let x17: u64 = (((arg1[11]) as u64) << 24);\n    let x18: u64 = (((arg1[10]) as u64) << 16);\n    let x19: u64 = (((arg1[9]) as u64) << 8);\n    let x20: u8 = (arg1[8]);\n    let x21: u64 = (((arg1[7]) as u64) << 56);\n    let x22: u64 = (((arg1[6]) as u64) << 48);\n    let x23: u64 = (((arg1[5]) as u64) << 40);\n    let x24: u64 = (((arg1[4]) as u64) << 32);\n    let x25: u64 = (((arg1[3]) as u64) << 24);\n    let x26: u64 = (((arg1[2]) as u64) << 16);\n    let x27: u64 = (((arg1[1]) as u64) << 8);\n    let x28: u8 = (arg1[0]);\n    let x29: u64 = (x27 + (x28 as u64));\n    let x30: u64 = (x26 + x29);\n    let x31: u64 = (x25 + x30);\n    let x32: u64 = (x24 + x31);\n    let x33: u64 = (x23 + x32);\n    let x34: u64 = (x22 + x33);\n    let x35: u64 = (x21 + x34);\n    let x36: u64 = (x19 + (x20 as u64));\n    let x37: u64 = (x18 + x36);\n    let x38: u64 = (x17 + x37);\n    let x39: u64 = (x16 + x38);\n    let x40: u64 = (x15 + x39);\n    let x41: u64 = (x14 + x40);\n    let x42: u64 = (x13 + x41);\n    let x43: u64 = (x11 + (x12 as u64));\n    let x44: u64 = (x10 + x43);\n    let x45: u64 = (x9 + x44);\n    let x46: u64 = (x8 + x45);\n    let x47: u64 = (x7 + x46);\n    let x48: u64 = (x6 + x47);\n    let x49: u64 = (x5 + x48);\n    let x50: u64 = (x3 + (x4 as u64));\n    let x51: u64 = (x2 + x50);\n    let x52: u64 = (x1 + x51);\n    out1[0] = x35;\n    out1[1] = x42;\n    out1[2] = x49;\n    out1[3] = x52;\n}",
    "display_name": "fiat_p224_from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "affine/impl/PublicKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(affine_point: AffinePoint<C>) -> Result<PublicKey<C>> {\n        PublicKey::from_affine(affine_point)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/Context/Signer/try_sign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_ctx"
    ],
    "body": "    fn try_sign(&self, msg: &[u8]) -> Result<Signature, Error> {\n        let sig = self.key.secret.sign_ctx(self.value, msg)?;\n        Ok(sig.into())\n    }",
    "display_name": "try_sign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/new_with_mode",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/new_with_mode"
    ],
    "body": "    pub fn new_with_mode(secret_scalar: NonZeroScalar, mode: Mode) -> Self {\n        Self {\n            secret_scalar,\n            encryting_key: EncryptingKey::new_with_mode(\n                PublicKey::from_secret_scalar(&secret_scalar),\n                mode,\n            ),\n            mode,\n        }\n    }",
    "display_name": "new_with_mode",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub fn is_zero(&self) -> Choice {\n        self.ct_eq(&Self::ZERO)\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_basic_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_basic_add() {\n        let five = Scalar::from(5u8);\n        let six = Scalar::from(6u8);\n\n        assert_eq!(five + six, Scalar::from(11u8))\n    }",
    "display_name": "test_basic_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/AffinePoint/x",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes_extended"
    ],
    "body": "    pub fn x(&self) -> [u8; 57] {\n        // TODO(RustCrypto/elliptic-curves#1229): fix this to be 56 bytes as per\n        // https://datatracker.ietf.org/doc/draft-irtf-cfrg-ristretto255-decaf448\n        // This might require creating a separate DecafScalar\n        self.0.x.to_bytes_extended()\n    }",
    "display_name": "x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Curve/batch_normalize",
    "statement_type": "function",
    "deps": [
      "projective/batch_normalize_generic"
    ],
    "body": "    fn batch_normalize(projective: &[Self], affine: &mut [Self::AffineRepr]) {\n        assert_eq!(projective.len(), affine.len());\n        let mut zs = vec![C::FieldElement::ONE; projective.len()];\n        batch_normalize_generic(projective, zs.as_mut_slice(), affine);\n    }",
    "display_name": "batch_normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_subborrowx_u57",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_subborrowx_u57(\n    out1: &mut u64,\n    out2: &mut fiat_p521_u1,\n    arg1: fiat_p521_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i64 = ((((((arg2 as i128) - (arg1 as i128)) as i64) as i128) - (arg3 as i128)) as i64);\n    let x2: fiat_p521_i1 = ((x1 >> 57) as fiat_p521_i1);\n    let x3: u64 = (((x1 as i128) & (0x1ffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p521_i2) - (x2 as fiat_p521_i2)) as fiat_p521_u1);\n}",
    "display_name": "fiat_p521_subborrowx_u57",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_on_curve",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    pub fn is_on_curve(&self) -> Choice {\n        let XY = self.X * self.Y;\n        let ZT = self.Z * self.T;\n\n        // Y^2 + X^2 == Z^2 - T^2 * D\n\n        let YY = self.Y.square();\n        let XX = self.X.square();\n        let ZZ = self.Z.square();\n        let TT = self.T.square();\n        let lhs = YY + XX;\n        let rhs = ZZ + TT * FieldElement::EDWARDS_D;\n\n        XY.ct_eq(&ZT) & lhs.ct_eq(&rhs)\n    }",
    "display_name": "is_on_curve",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: &AffinePoint) -> ProjectivePoint {\n        *rhs * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/invert_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert_vartime",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn invert_vartime() {\n        assert_eq!(Scalar::ONE, Scalar::ONE.invert_vartime().unwrap());\n\n        let three = Scalar::from(3u64);\n        let inv_three = three.invert_vartime().unwrap();\n        assert_eq!(three * inv_three, Scalar::ONE);\n\n        let minus_three = -three;\n        let inv_minus_three = minus_three.invert_vartime().unwrap();\n        assert_eq!(inv_minus_three, -inv_three);\n        assert_eq!(three * inv_minus_three, -Scalar::ONE);\n\n        assert!(bool::from(Scalar::ZERO.invert_vartime().is_none()));\n        assert_eq!(\n            Scalar::from(2u64).invert_vartime().unwrap(),\n            Scalar::TWO_INV\n        );\n        assert_eq!(\n            Scalar::ROOT_OF_UNITY.invert_vartime().unwrap(),\n            Scalar::ROOT_OF_UNITY_INV\n        );\n    }",
    "display_name": "invert_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_u64",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/from_u64"
    ],
    "body": "    pub const fn from_u64(w: u64) -> Self {\n        Self(FieldElementImpl::from_u64(w))\n    }",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, other: &FieldElement) {\n        *self = *self + -other;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&DecafAffinePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended"
    ],
    "body": "    fn add(self, rhs: &DecafPoint) -> Self::Output {\n        DecafPoint(self.0.to_extended()) + rhs\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.7.0_pre encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_field_bytes(uint: &U384) -> FieldBytes {\n    uint.to_be_byte_array()\n}",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp384/src/lib.rs",
    "relative_path": "bp384/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_mulx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p224_mul(\n    out1: &mut fiat_p224_montgomery_domain_field_element,\n    arg1: &fiat_p224_montgomery_domain_field_element,\n    arg2: &fiat_p224_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_p224_mulx_u64(&mut x5, &mut x6, x4, (arg2[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_p224_mulx_u64(&mut x7, &mut x8, x4, (arg2[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_p224_mulx_u64(&mut x9, &mut x10, x4, (arg2[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_p224_mulx_u64(&mut x11, &mut x12, x4, (arg2[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p224_mulx_u64(&mut x20, &mut x21, x11, 0xffffffffffffffff);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_p224_mulx_u64(&mut x22, &mut x23, x20, 0xffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_p224_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p224_mulx_u64(&mut x26, &mut x27, x20, 0xffffffff00000000);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x28, &mut x29, 0x0, x27, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x30, &mut x31, x29, x25, x22);\n    let x32: u64 = ((x31 as u64) + x23);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x33, &mut x34, 0x0, x11, x20);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x35, &mut x36, x34, x13, x26);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x37, &mut x38, x36, x15, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x39, &mut x40, x38, x17, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x41, &mut x42, x40, x19, x32);\n    let mut x43: u64 = 0;\n    let mut x44: u64 = 0;\n    fiat_p224_mulx_u64(&mut x43, &mut x44, x1, (arg2[3]));\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_p224_mulx_u64(&mut x45, &mut x46, x1, (arg2[2]));\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_p224_mulx_u64(&mut x47, &mut x48, x1, (arg2[1]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_p224_mulx_u64(&mut x49, &mut x50, x1, (arg2[0]));\n    let mut x51: u64 = 0;\n    let mut x52: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x51, &mut x52, 0x0, x50, x47);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x53, &mut x54, x52, x48, x45);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x55, &mut x56, x54, x46, x43);\n    let x57: u64 = ((x56 as u64) + x44);\n    let mut x58: u64 = 0;\n    let mut x59: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x58, &mut x59, 0x0, x35, x49);\n    let mut x60: u64 = 0;\n    let mut x61: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x60, &mut x61, x59, x37, x51);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x62, &mut x63, x61, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x66, &mut x67, x65, (x42 as u64), x57);\n    let mut x68: u64 = 0;\n    let mut x69: u64 = 0;\n    fiat_p224_mulx_u64(&mut x68, &mut x69, x58, 0xffffffffffffffff);\n    let mut x70: u64 = 0;\n    let mut x71: u64 = 0;\n    fiat_p224_mulx_u64(&mut x70, &mut x71, x68, 0xffffffff);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_p224_mulx_u64(&mut x72, &mut x73, x68, 0xffffffffffffffff);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_p224_mulx_u64(&mut x74, &mut x75, x68, 0xffffffff00000000);\n    let mut x76: u64 = 0;\n    let mut x77: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x76, &mut x77, 0x0, x75, x72);\n    let mut x78: u64 = 0;\n    let mut x79: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x78, &mut x79, x77, x73, x70);\n    let x80: u64 = ((x79 as u64) + x71);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x81, &mut x82, 0x0, x58, x68);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x83, &mut x84, x82, x60, x74);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x85, &mut x86, x84, x62, x76);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x87, &mut x88, x86, x64, x78);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x89, &mut x90, x88, x66, x80);\n    let x91: u64 = ((x90 as u64) + (x67 as u64));\n    let mut x92: u64 = 0;\n    let mut x93: u64 = 0;\n    fiat_p224_mulx_u64(&mut x92, &mut x93, x2, (arg2[3]));\n    let mut x94: u64 = 0;\n    let mut x95: u64 = 0;\n    fiat_p224_mulx_u64(&mut x94, &mut x95, x2, (arg2[2]));\n    let mut x96: u64 = 0;\n    let mut x97: u64 = 0;\n    fiat_p224_mulx_u64(&mut x96, &mut x97, x2, (arg2[1]));\n    let mut x98: u64 = 0;\n    let mut x99: u64 = 0;\n    fiat_p224_mulx_u64(&mut x98, &mut x99, x2, (arg2[0]));\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x100, &mut x101, 0x0, x99, x96);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x102, &mut x103, x101, x97, x94);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x104, &mut x105, x103, x95, x92);\n    let x106: u64 = ((x105 as u64) + x93);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x107, &mut x108, 0x0, x83, x98);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x109, &mut x110, x108, x85, x100);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x111, &mut x112, x110, x87, x102);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x113, &mut x114, x112, x89, x104);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x115, &mut x116, x114, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: u64 = 0;\n    fiat_p224_mulx_u64(&mut x117, &mut x118, x107, 0xffffffffffffffff);\n    let mut x119: u64 = 0;\n    let mut x120: u64 = 0;\n    fiat_p224_mulx_u64(&mut x119, &mut x120, x117, 0xffffffff);\n    let mut x121: u64 = 0;\n    let mut x122: u64 = 0;\n    fiat_p224_mulx_u64(&mut x121, &mut x122, x117, 0xffffffffffffffff);\n    let mut x123: u64 = 0;\n    let mut x124: u64 = 0;\n    fiat_p224_mulx_u64(&mut x123, &mut x124, x117, 0xffffffff00000000);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x125, &mut x126, 0x0, x124, x121);\n    let mut x127: u64 = 0;\n    let mut x128: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x127, &mut x128, x126, x122, x119);\n    let x129: u64 = ((x128 as u64) + x120);\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x130, &mut x131, 0x0, x107, x117);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x132, &mut x133, x131, x109, x123);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x134, &mut x135, x133, x111, x125);\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x136, &mut x137, x135, x113, x127);\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x138, &mut x139, x137, x115, x129);\n    let x140: u64 = ((x139 as u64) + (x116 as u64));\n    let mut x141: u64 = 0;\n    let mut x142: u64 = 0;\n    fiat_p224_mulx_u64(&mut x141, &mut x142, x3, (arg2[3]));\n    let mut x143: u64 = 0;\n    let mut x144: u64 = 0;\n    fiat_p224_mulx_u64(&mut x143, &mut x144, x3, (arg2[2]));\n    let mut x145: u64 = 0;\n    let mut x146: u64 = 0;\n    fiat_p224_mulx_u64(&mut x145, &mut x146, x3, (arg2[1]));\n    let mut x147: u64 = 0;\n    let mut x148: u64 = 0;\n    fiat_p224_mulx_u64(&mut x147, &mut x148, x3, (arg2[0]));\n    let mut x149: u64 = 0;\n    let mut x150: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x149, &mut x150, 0x0, x148, x145);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x151, &mut x152, x150, x146, x143);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x153, &mut x154, x152, x144, x141);\n    let x155: u64 = ((x154 as u64) + x142);\n    let mut x156: u64 = 0;\n    let mut x157: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x156, &mut x157, 0x0, x132, x147);\n    let mut x158: u64 = 0;\n    let mut x159: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x158, &mut x159, x157, x134, x149);\n    let mut x160: u64 = 0;\n    let mut x161: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x160, &mut x161, x159, x136, x151);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x162, &mut x163, x161, x138, x153);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x164, &mut x165, x163, x140, x155);\n    let mut x166: u64 = 0;\n    let mut x167: u64 = 0;\n    fiat_p224_mulx_u64(&mut x166, &mut x167, x156, 0xffffffffffffffff);\n    let mut x168: u64 = 0;\n    let mut x169: u64 = 0;\n    fiat_p224_mulx_u64(&mut x168, &mut x169, x166, 0xffffffff);\n    let mut x170: u64 = 0;\n    let mut x171: u64 = 0;\n    fiat_p224_mulx_u64(&mut x170, &mut x171, x166, 0xffffffffffffffff);\n    let mut x172: u64 = 0;\n    let mut x173: u64 = 0;\n    fiat_p224_mulx_u64(&mut x172, &mut x173, x166, 0xffffffff00000000);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x174, &mut x175, 0x0, x173, x170);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x176, &mut x177, x175, x171, x168);\n    let x178: u64 = ((x177 as u64) + x169);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x179, &mut x180, 0x0, x156, x166);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x181, &mut x182, x180, x158, x172);\n    let mut x183: u64 = 0;\n    let mut x184: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x183, &mut x184, x182, x160, x174);\n    let mut x185: u64 = 0;\n    let mut x186: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x185, &mut x186, x184, x162, x176);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x187, &mut x188, x186, x164, x178);\n    let x189: u64 = ((x188 as u64) + (x165 as u64));\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x190, &mut x191, 0x0, x181, (0x1 as u64));\n    let mut x192: u64 = 0;\n    let mut x193: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x192, &mut x193, x191, x183, 0xffffffff00000000);\n    let mut x194: u64 = 0;\n    let mut x195: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x194, &mut x195, x193, x185, 0xffffffffffffffff);\n    let mut x196: u64 = 0;\n    let mut x197: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x196, &mut x197, x195, x187, 0xffffffff);\n    let mut x198: u64 = 0;\n    let mut x199: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x198, &mut x199, x197, x189, (0x0 as u64));\n    let mut x200: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x200, x199, x190, x181);\n    let mut x201: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x201, x199, x192, x183);\n    let mut x202: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x202, x199, x194, x185);\n    let mut x203: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x203, x199, x196, x187);\n    out1[0] = x200;\n    out1[1] = x201;\n    out1[2] = x202;\n    out1[3] = x203;\n}",
    "display_name": "fiat_p224_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_sub(\n    out1: &mut fiat_sm2_scalar_montgomery_domain_field_element,\n    arg1: &fiat_sm2_scalar_montgomery_domain_field_element,\n    arg2: &fiat_sm2_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x9, x8, (0x0 as u64), 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x10, &mut x11, 0x0, x1, (x9 & 0x53bbf40939d54123));\n    let mut x12: u64 = 0;\n    let mut x13: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x12, &mut x13, x11, x3, (x9 & 0x7203df6b21c6052b));\n    let mut x14: u64 = 0;\n    let mut x15: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x14, &mut x15, x13, x5, x9);\n    let mut x16: u64 = 0;\n    let mut x17: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x16, &mut x17, x15, x7, (x9 & 0xfffffffeffffffff));\n    out1[0] = x10;\n    out1[1] = x12;\n    out1[2] = x14;\n    out1[3] = x16;\n}",
    "display_name": "fiat_sm2_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/rfc6979",
    "statement_type": "function",
    "deps": [],
    "body": "    fn rfc6979() {\n        let x = hex!(\"c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\");\n        let signer = SigningKey::from_bytes(&x.into()).unwrap();\n        let signature: Signature = signer.sign(b\"sample\");\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"efd48b2aacb6a8fd1140dd9cd45e81d69d2c877b56aaf991c34d0ea84eaf3716\n                 f7cb1c942d657c41d436c7a1b6e29f65f3e900dbb9aff4064dc4ab2f843acda8\"\n            )\n        );\n        let signature: Signature = signer.sign(b\"test\");\n        assert_eq!(\n            signature.to_bytes().as_slice(),\n            &hex!(\n                \"f1abb023518351cd71d881567b1ea663ed3efcf6c5132b354f28d3b0b7d38367\n                 019f4113742a2b14bd25926b49c649155f267e60d3814b4c0cc84250e46f0083\"\n            )\n        );\n    }",
    "display_name": "rfc6979",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/ecdsa.rs",
    "relative_path": "p256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_selectznz(\n    out1: &mut [u64; 4],\n    arg1: fiat_p224_scalar_u1,\n    arg2: &[u64; 4],\n    arg3: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n}",
    "display_name": "fiat_p224_scalar_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        write!(f, \"FieldElement({:x})\", self.0.retrieve())\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_scalar_add",
      "0.14.0_pre.8 bench_scalar_sub",
      "0.14.0_pre.8 bench_scalar_negate",
      "0.14.0_pre.8 bench_scalar_mul",
      "0.14.0_pre.8 bench_scalar_invert"
    ],
    "body": "fn bench_scalar(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"scalar operations\");\n    bench_scalar_sub(&mut group);\n    bench_scalar_add(&mut group);\n    bench_scalar_mul(&mut group);\n    bench_scalar_negate(&mut group);\n    bench_scalar_invert(&mut group);\n    group.finish();\n}",
    "display_name": "bench_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/delta_constant",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn delta_constant() {\n        // DELTA^{t} mod m == 1\n        assert_eq!(\n            FieldElement::DELTA.pow_vartime(T).normalize(),\n            FieldElement::ONE\n        );\n    }",
    "display_name": "delta_constant",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/SharedSecret/From::FieldBytesSize>>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(secret_bytes: FieldBytes) -> Self {\n        Self { secret_bytes }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add_assign(&mut self, rhs: &Scalar) {\n        *self = Scalar::add(self, rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_cmovznz_u64(\n    out1: &mut u64,\n    arg1: fiat_p384_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: fiat_p384_scalar_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_p384_scalar_i2) - (x1 as fiat_p384_scalar_i2))\n        as fiat_p384_scalar_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_p384_scalar_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/mul_single",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/new",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/max_magnitude",
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/mul_single"
    ],
    "body": "    pub fn mul_single(&self, rhs: u32) -> Self {\n        let new_magnitude = self.magnitude * rhs;\n        debug_assert!(new_magnitude <= FieldElementUnsafeImpl::max_magnitude());\n        Self::new(&(self.value.mul_single(rhs)), new_magnitude)\n    }",
    "display_name": "mul_single",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: &FieldElement) {\n        *self = *self + other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_selectznz",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p224_selectznz(\n    out1: &mut [u64; 4],\n    arg1: fiat_p224_u1,\n    arg2: &[u64; 4],\n    arg3: &[u64; 4],\n) {\n    let mut x1: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x1, arg1, (arg2[0]), (arg3[0]));\n    let mut x2: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x2, arg1, (arg2[1]), (arg3[1]));\n    let mut x3: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x3, arg1, (arg2[2]), (arg3[2]));\n    let mut x4: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x4, arg1, (arg2[3]), (arg3[3]));\n    out1[0] = x1;\n    out1[1] = x2;\n    out1[2] = x3;\n    out1[3] = x4;\n}",
    "display_name": "fiat_p224_selectznz",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/From/from"
    ],
    "body": "    fn from(p: &AffinePoint) -> Self {\n        Self::from(*p)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.7.0_pre r1/impl/elliptic_curve::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [
      "0.7.0_pre encode_field_bytes"
    ],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        crate::encode_field_bytes(self)\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp256/src/r1.rs",
    "relative_path": "bp256/src/r1.rs",
    "file_name": "r1.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: FieldElement) {\n        *self = *self + &other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/pow2k",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square"
    ],
    "body": "    fn pow2k(&self, k: usize) -> Self {\n        let mut x = *self;\n        for _j in 0..k {\n            x = x.square();\n        }\n        x\n    }",
    "display_name": "pow2k",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/AffineCoordinates/y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn y(&self) -> FieldBytes {\n        self.y.to_bytes()\n    }",
    "display_name": "y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/tests/test_point_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/double",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/add_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended"
    ],
    "body": "    fn test_point_add() {\n        let a = TWISTED_EDWARDS_BASE_POINT;\n        let b = a.double();\n\n        // A + B = B + A = C\n        let c_1 = a.to_extensible().add_extended(&b).to_extended();\n        let c_2 = b.to_extensible().add_extended(&a).to_extended();\n        assert!(c_1 == c_2);\n\n        // Adding identity point should not change result\n        let c = c_1.to_extensible().add_extended(&ExtendedPoint::IDENTITY);\n        assert!(c.to_extended() == c_1);\n    }",
    "display_name": "test_point_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/from_sec1_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/new"
    ],
    "body": "    pub fn from_sec1_bytes(distid: &DistId, bytes: &[u8]) -> Result<Self> {\n        let public_key = PublicKey::from_sec1_bytes(bytes).map_err(|_| Error::new())?;\n        Self::new(distid, public_key)\n    }",
    "display_name": "from_sec1_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_mulx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_mul(\n    out1: &mut fiat_bign256_scalar_montgomery_domain_field_element,\n    arg1: &fiat_bign256_scalar_montgomery_domain_field_element,\n    arg2: &fiat_bign256_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x5, &mut x6, x4, (arg2[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x7, &mut x8, x4, (arg2[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x9, &mut x10, x4, (arg2[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x11, &mut x12, x4, (arg2[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x20, &mut x21, x11, 0x8d64dbd30858d849);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x22, &mut x23, x20, 0xffffffffffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x26, &mut x27, x20, 0xd95c8ed60dfb4dfc);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x28, &mut x29, x20, 0x7e5abf99263d6607);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x30, &mut x31, 0x0, x29, x26);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x27, x24);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x25, x22);\n    let x36: u64 = ((x35 as u64) + x23);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x37, &mut x38, 0x0, x11, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x13, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x15, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x43, &mut x44, x42, x17, x34);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x45, &mut x46, x44, x19, x36);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x47, &mut x48, x1, (arg2[3]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x49, &mut x50, x1, (arg2[2]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x51, &mut x52, x1, (arg2[1]));\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x53, &mut x54, x1, (arg2[0]));\n    let mut x55: u64 = 0;\n    let mut x56: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x55, &mut x56, 0x0, x54, x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x52, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x50, x47);\n    let x61: u64 = ((x60 as u64) + x48);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x45, x59);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x70, &mut x71, x69, (x46 as u64), x61);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x72, &mut x73, x62, 0x8d64dbd30858d849);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x74, &mut x75, x72, 0xffffffffffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x78, &mut x79, x72, 0xd95c8ed60dfb4dfc);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x80, &mut x81, x72, 0x7e5abf99263d6607);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x82, &mut x83, 0x0, x81, x78);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x79, x76);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x77, x74);\n    let x88: u64 = ((x87 as u64) + x75);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x89, &mut x90, 0x0, x62, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x91, &mut x92, x90, x64, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x93, &mut x94, x92, x66, x84);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x95, &mut x96, x94, x68, x86);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x97, &mut x98, x96, x70, x88);\n    let x99: u64 = ((x98 as u64) + (x71 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x100, &mut x101, x2, (arg2[3]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x102, &mut x103, x2, (arg2[2]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x104, &mut x105, x2, (arg2[1]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x106, &mut x107, x2, (arg2[0]));\n    let mut x108: u64 = 0;\n    let mut x109: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x107, x104);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x105, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x103, x100);\n    let x114: u64 = ((x113 as u64) + x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x115, &mut x116, 0x0, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x121, &mut x122, x120, x97, x112);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x123, &mut x124, x122, x99, x114);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x125, &mut x126, x115, 0x8d64dbd30858d849);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x127, &mut x128, x125, 0xffffffffffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x129, &mut x130, x125, 0xffffffffffffffff);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x131, &mut x132, x125, 0xd95c8ed60dfb4dfc);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x133, &mut x134, x125, 0x7e5abf99263d6607);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let x141: u64 = ((x140 as u64) + x128);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x142, &mut x143, 0x0, x115, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x144, &mut x145, x143, x117, x135);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x146, &mut x147, x145, x119, x137);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x148, &mut x149, x147, x121, x139);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x150, &mut x151, x149, x123, x141);\n    let x152: u64 = ((x151 as u64) + (x124 as u64));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x153, &mut x154, x3, (arg2[3]));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x155, &mut x156, x3, (arg2[2]));\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x157, &mut x158, x3, (arg2[1]));\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x159, &mut x160, x3, (arg2[0]));\n    let mut x161: u64 = 0;\n    let mut x162: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x161, &mut x162, 0x0, x160, x157);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x163, &mut x164, x162, x158, x155);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x165, &mut x166, x164, x156, x153);\n    let x167: u64 = ((x166 as u64) + x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x168, &mut x169, 0x0, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x148, x163);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x150, x165);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x152, x167);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x178, &mut x179, x168, 0x8d64dbd30858d849);\n    let mut x180: u64 = 0;\n    let mut x181: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x180, &mut x181, x178, 0xffffffffffffffff);\n    let mut x182: u64 = 0;\n    let mut x183: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x182, &mut x183, x178, 0xffffffffffffffff);\n    let mut x184: u64 = 0;\n    let mut x185: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x184, &mut x185, x178, 0xd95c8ed60dfb4dfc);\n    let mut x186: u64 = 0;\n    let mut x187: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x186, &mut x187, x178, 0x7e5abf99263d6607);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x188, &mut x189, 0x0, x187, x184);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x190, &mut x191, x189, x185, x182);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x183, x180);\n    let x194: u64 = ((x193 as u64) + x181);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x195, &mut x196, 0x0, x168, x186);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x197, &mut x198, x196, x170, x188);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x172, x190);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x174, x192);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x176, x194);\n    let x205: u64 = ((x204 as u64) + (x177 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x206, &mut x207, 0x0, x197, 0x7e5abf99263d6607);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x208, &mut x209, x207, x199, 0xd95c8ed60dfb4dfc);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x210, &mut x211, x209, x201, 0xffffffffffffffff);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x212, &mut x213, x211, x203, 0xffffffffffffffff);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x214, &mut x215, x213, x205, (0x0 as u64));\n    let mut x216: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x216, x215, x206, x197);\n    let mut x217: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x217, x215, x208, x199);\n    let mut x218: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x218, x215, x210, x201);\n    let mut x219: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x219, x215, x212, x203);\n    out1[0] = x216;\n    out1[1] = x217;\n    out1[2] = x218;\n    out1[3] = x219;\n}",
    "display_name": "fiat_bign256_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_mulx_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_mul(\n    out1: &mut fiat_p521_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p521_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p521_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[4]);\n    let x5: u64 = (arg1[5]);\n    let x6: u64 = (arg1[6]);\n    let x7: u64 = (arg1[7]);\n    let x8: u64 = (arg1[8]);\n    let x9: u64 = (arg1[0]);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x10, &mut x11, x9, (arg2[8]));\n    let mut x12: u64 = 0;\n    let mut x13: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x12, &mut x13, x9, (arg2[7]));\n    let mut x14: u64 = 0;\n    let mut x15: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x14, &mut x15, x9, (arg2[6]));\n    let mut x16: u64 = 0;\n    let mut x17: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x16, &mut x17, x9, (arg2[5]));\n    let mut x18: u64 = 0;\n    let mut x19: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x18, &mut x19, x9, (arg2[4]));\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x20, &mut x21, x9, (arg2[3]));\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x22, &mut x23, x9, (arg2[2]));\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x24, &mut x25, x9, (arg2[1]));\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x26, &mut x27, x9, (arg2[0]));\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x28, &mut x29, 0x0, x27, x24);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x25, x22);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x23, x20);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x21, x18);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x36, &mut x37, x35, x19, x16);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x38, &mut x39, x37, x17, x14);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x40, &mut x41, x39, x15, x12);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x42, &mut x43, x41, x13, x10);\n    let x44: u64 = ((x43 as u64) + x11);\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x45, &mut x46, x26, 0x1d2f5ccd79a995c7);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x47, &mut x48, x45, 0x1ff);\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x49, &mut x50, x45, 0xffffffffffffffff);\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x51, &mut x52, x45, 0xffffffffffffffff);\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x53, &mut x54, x45, 0xffffffffffffffff);\n    let mut x55: u64 = 0;\n    let mut x56: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x55, &mut x56, x45, 0xfffffffffffffffa);\n    let mut x57: u64 = 0;\n    let mut x58: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x57, &mut x58, x45, 0x51868783bf2f966b);\n    let mut x59: u64 = 0;\n    let mut x60: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x59, &mut x60, x45, 0x7fcc0148f709a5d0);\n    let mut x61: u64 = 0;\n    let mut x62: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x61, &mut x62, x45, 0x3bb5c9b8899c47ae);\n    let mut x63: u64 = 0;\n    let mut x64: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x63, &mut x64, x45, 0xbb6fb71e91386409);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x65, &mut x66, 0x0, x64, x61);\n    let mut x67: u64 = 0;\n    let mut x68: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x67, &mut x68, x66, x62, x59);\n    let mut x69: u64 = 0;\n    let mut x70: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x69, &mut x70, x68, x60, x57);\n    let mut x71: u64 = 0;\n    let mut x72: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x71, &mut x72, x70, x58, x55);\n    let mut x73: u64 = 0;\n    let mut x74: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x73, &mut x74, x72, x56, x53);\n    let mut x75: u64 = 0;\n    let mut x76: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x75, &mut x76, x74, x54, x51);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x77, &mut x78, x76, x52, x49);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x79, &mut x80, x78, x50, x47);\n    let x81: u64 = ((x80 as u64) + x48);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x82, &mut x83, 0x0, x26, x63);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x28, x65);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x30, x67);\n    let mut x88: u64 = 0;\n    let mut x89: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x88, &mut x89, x87, x32, x69);\n    let mut x90: u64 = 0;\n    let mut x91: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x90, &mut x91, x89, x34, x71);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x92, &mut x93, x91, x36, x73);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x38, x75);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x40, x77);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x42, x79);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x44, x81);\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x102, &mut x103, x1, (arg2[8]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x104, &mut x105, x1, (arg2[7]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x106, &mut x107, x1, (arg2[6]));\n    let mut x108: u64 = 0;\n    let mut x109: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x108, &mut x109, x1, (arg2[5]));\n    let mut x110: u64 = 0;\n    let mut x111: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x110, &mut x111, x1, (arg2[4]));\n    let mut x112: u64 = 0;\n    let mut x113: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x112, &mut x113, x1, (arg2[3]));\n    let mut x114: u64 = 0;\n    let mut x115: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x114, &mut x115, x1, (arg2[2]));\n    let mut x116: u64 = 0;\n    let mut x117: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x116, &mut x117, x1, (arg2[1]));\n    let mut x118: u64 = 0;\n    let mut x119: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x118, &mut x119, x1, (arg2[0]));\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x120, &mut x121, 0x0, x119, x116);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x117, x114);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x124, &mut x125, x123, x115, x112);\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x126, &mut x127, x125, x113, x110);\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x128, &mut x129, x127, x111, x108);\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x130, &mut x131, x129, x109, x106);\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x132, &mut x133, x131, x107, x104);\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x134, &mut x135, x133, x105, x102);\n    let x136: u64 = ((x135 as u64) + x103);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x137, &mut x138, 0x0, x84, x118);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x86, x120);\n    let mut x141: u64 = 0;\n    let mut x142: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x141, &mut x142, x140, x88, x122);\n    let mut x143: u64 = 0;\n    let mut x144: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x143, &mut x144, x142, x90, x124);\n    let mut x145: u64 = 0;\n    let mut x146: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x145, &mut x146, x144, x92, x126);\n    let mut x147: u64 = 0;\n    let mut x148: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x147, &mut x148, x146, x94, x128);\n    let mut x149: u64 = 0;\n    let mut x150: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x149, &mut x150, x148, x96, x130);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x151, &mut x152, x150, x98, x132);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x153, &mut x154, x152, x100, x134);\n    let mut x155: u64 = 0;\n    let mut x156: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x155, &mut x156, x154, (x101 as u64), x136);\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x157, &mut x158, x137, 0x1d2f5ccd79a995c7);\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x159, &mut x160, x157, 0x1ff);\n    let mut x161: u64 = 0;\n    let mut x162: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x161, &mut x162, x157, 0xffffffffffffffff);\n    let mut x163: u64 = 0;\n    let mut x164: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x163, &mut x164, x157, 0xffffffffffffffff);\n    let mut x165: u64 = 0;\n    let mut x166: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x165, &mut x166, x157, 0xffffffffffffffff);\n    let mut x167: u64 = 0;\n    let mut x168: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x167, &mut x168, x157, 0xfffffffffffffffa);\n    let mut x169: u64 = 0;\n    let mut x170: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x169, &mut x170, x157, 0x51868783bf2f966b);\n    let mut x171: u64 = 0;\n    let mut x172: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x171, &mut x172, x157, 0x7fcc0148f709a5d0);\n    let mut x173: u64 = 0;\n    let mut x174: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x173, &mut x174, x157, 0x3bb5c9b8899c47ae);\n    let mut x175: u64 = 0;\n    let mut x176: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x175, &mut x176, x157, 0xbb6fb71e91386409);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x177, &mut x178, 0x0, x176, x173);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x179, &mut x180, x178, x174, x171);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x181, &mut x182, x180, x172, x169);\n    let mut x183: u64 = 0;\n    let mut x184: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x183, &mut x184, x182, x170, x167);\n    let mut x185: u64 = 0;\n    let mut x186: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x185, &mut x186, x184, x168, x165);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x187, &mut x188, x186, x166, x163);\n    let mut x189: u64 = 0;\n    let mut x190: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x189, &mut x190, x188, x164, x161);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x191, &mut x192, x190, x162, x159);\n    let x193: u64 = ((x192 as u64) + x160);\n    let mut x194: u64 = 0;\n    let mut x195: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x194, &mut x195, 0x0, x137, x175);\n    let mut x196: u64 = 0;\n    let mut x197: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x196, &mut x197, x195, x139, x177);\n    let mut x198: u64 = 0;\n    let mut x199: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x198, &mut x199, x197, x141, x179);\n    let mut x200: u64 = 0;\n    let mut x201: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x200, &mut x201, x199, x143, x181);\n    let mut x202: u64 = 0;\n    let mut x203: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x202, &mut x203, x201, x145, x183);\n    let mut x204: u64 = 0;\n    let mut x205: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x204, &mut x205, x203, x147, x185);\n    let mut x206: u64 = 0;\n    let mut x207: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x206, &mut x207, x205, x149, x187);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x208, &mut x209, x207, x151, x189);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x210, &mut x211, x209, x153, x191);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x212, &mut x213, x211, x155, x193);\n    let x214: u64 = ((x213 as u64) + (x156 as u64));\n    let mut x215: u64 = 0;\n    let mut x216: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x215, &mut x216, x2, (arg2[8]));\n    let mut x217: u64 = 0;\n    let mut x218: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x217, &mut x218, x2, (arg2[7]));\n    let mut x219: u64 = 0;\n    let mut x220: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x219, &mut x220, x2, (arg2[6]));\n    let mut x221: u64 = 0;\n    let mut x222: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x221, &mut x222, x2, (arg2[5]));\n    let mut x223: u64 = 0;\n    let mut x224: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x223, &mut x224, x2, (arg2[4]));\n    let mut x225: u64 = 0;\n    let mut x226: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x225, &mut x226, x2, (arg2[3]));\n    let mut x227: u64 = 0;\n    let mut x228: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x227, &mut x228, x2, (arg2[2]));\n    let mut x229: u64 = 0;\n    let mut x230: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x229, &mut x230, x2, (arg2[1]));\n    let mut x231: u64 = 0;\n    let mut x232: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x231, &mut x232, x2, (arg2[0]));\n    let mut x233: u64 = 0;\n    let mut x234: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x233, &mut x234, 0x0, x232, x229);\n    let mut x235: u64 = 0;\n    let mut x236: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x235, &mut x236, x234, x230, x227);\n    let mut x237: u64 = 0;\n    let mut x238: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x237, &mut x238, x236, x228, x225);\n    let mut x239: u64 = 0;\n    let mut x240: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x239, &mut x240, x238, x226, x223);\n    let mut x241: u64 = 0;\n    let mut x242: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x241, &mut x242, x240, x224, x221);\n    let mut x243: u64 = 0;\n    let mut x244: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x243, &mut x244, x242, x222, x219);\n    let mut x245: u64 = 0;\n    let mut x246: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x245, &mut x246, x244, x220, x217);\n    let mut x247: u64 = 0;\n    let mut x248: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x247, &mut x248, x246, x218, x215);\n    let x249: u64 = ((x248 as u64) + x216);\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x250, &mut x251, 0x0, x196, x231);\n    let mut x252: u64 = 0;\n    let mut x253: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x252, &mut x253, x251, x198, x233);\n    let mut x254: u64 = 0;\n    let mut x255: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x254, &mut x255, x253, x200, x235);\n    let mut x256: u64 = 0;\n    let mut x257: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x256, &mut x257, x255, x202, x237);\n    let mut x258: u64 = 0;\n    let mut x259: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x258, &mut x259, x257, x204, x239);\n    let mut x260: u64 = 0;\n    let mut x261: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x260, &mut x261, x259, x206, x241);\n    let mut x262: u64 = 0;\n    let mut x263: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x262, &mut x263, x261, x208, x243);\n    let mut x264: u64 = 0;\n    let mut x265: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x264, &mut x265, x263, x210, x245);\n    let mut x266: u64 = 0;\n    let mut x267: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x266, &mut x267, x265, x212, x247);\n    let mut x268: u64 = 0;\n    let mut x269: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x268, &mut x269, x267, x214, x249);\n    let mut x270: u64 = 0;\n    let mut x271: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x270, &mut x271, x250, 0x1d2f5ccd79a995c7);\n    let mut x272: u64 = 0;\n    let mut x273: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x272, &mut x273, x270, 0x1ff);\n    let mut x274: u64 = 0;\n    let mut x275: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x274, &mut x275, x270, 0xffffffffffffffff);\n    let mut x276: u64 = 0;\n    let mut x277: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x276, &mut x277, x270, 0xffffffffffffffff);\n    let mut x278: u64 = 0;\n    let mut x279: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x278, &mut x279, x270, 0xffffffffffffffff);\n    let mut x280: u64 = 0;\n    let mut x281: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x280, &mut x281, x270, 0xfffffffffffffffa);\n    let mut x282: u64 = 0;\n    let mut x283: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x282, &mut x283, x270, 0x51868783bf2f966b);\n    let mut x284: u64 = 0;\n    let mut x285: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x284, &mut x285, x270, 0x7fcc0148f709a5d0);\n    let mut x286: u64 = 0;\n    let mut x287: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x286, &mut x287, x270, 0x3bb5c9b8899c47ae);\n    let mut x288: u64 = 0;\n    let mut x289: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x288, &mut x289, x270, 0xbb6fb71e91386409);\n    let mut x290: u64 = 0;\n    let mut x291: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x290, &mut x291, 0x0, x289, x286);\n    let mut x292: u64 = 0;\n    let mut x293: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x292, &mut x293, x291, x287, x284);\n    let mut x294: u64 = 0;\n    let mut x295: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x294, &mut x295, x293, x285, x282);\n    let mut x296: u64 = 0;\n    let mut x297: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x296, &mut x297, x295, x283, x280);\n    let mut x298: u64 = 0;\n    let mut x299: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x298, &mut x299, x297, x281, x278);\n    let mut x300: u64 = 0;\n    let mut x301: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x300, &mut x301, x299, x279, x276);\n    let mut x302: u64 = 0;\n    let mut x303: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x302, &mut x303, x301, x277, x274);\n    let mut x304: u64 = 0;\n    let mut x305: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x304, &mut x305, x303, x275, x272);\n    let x306: u64 = ((x305 as u64) + x273);\n    let mut x307: u64 = 0;\n    let mut x308: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x307, &mut x308, 0x0, x250, x288);\n    let mut x309: u64 = 0;\n    let mut x310: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x309, &mut x310, x308, x252, x290);\n    let mut x311: u64 = 0;\n    let mut x312: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x311, &mut x312, x310, x254, x292);\n    let mut x313: u64 = 0;\n    let mut x314: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x313, &mut x314, x312, x256, x294);\n    let mut x315: u64 = 0;\n    let mut x316: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x315, &mut x316, x314, x258, x296);\n    let mut x317: u64 = 0;\n    let mut x318: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x317, &mut x318, x316, x260, x298);\n    let mut x319: u64 = 0;\n    let mut x320: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x319, &mut x320, x318, x262, x300);\n    let mut x321: u64 = 0;\n    let mut x322: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x321, &mut x322, x320, x264, x302);\n    let mut x323: u64 = 0;\n    let mut x324: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x323, &mut x324, x322, x266, x304);\n    let mut x325: u64 = 0;\n    let mut x326: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x325, &mut x326, x324, x268, x306);\n    let x327: u64 = ((x326 as u64) + (x269 as u64));\n    let mut x328: u64 = 0;\n    let mut x329: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x328, &mut x329, x3, (arg2[8]));\n    let mut x330: u64 = 0;\n    let mut x331: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x330, &mut x331, x3, (arg2[7]));\n    let mut x332: u64 = 0;\n    let mut x333: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x332, &mut x333, x3, (arg2[6]));\n    let mut x334: u64 = 0;\n    let mut x335: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x334, &mut x335, x3, (arg2[5]));\n    let mut x336: u64 = 0;\n    let mut x337: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x336, &mut x337, x3, (arg2[4]));\n    let mut x338: u64 = 0;\n    let mut x339: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x338, &mut x339, x3, (arg2[3]));\n    let mut x340: u64 = 0;\n    let mut x341: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x340, &mut x341, x3, (arg2[2]));\n    let mut x342: u64 = 0;\n    let mut x343: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x342, &mut x343, x3, (arg2[1]));\n    let mut x344: u64 = 0;\n    let mut x345: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x344, &mut x345, x3, (arg2[0]));\n    let mut x346: u64 = 0;\n    let mut x347: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x346, &mut x347, 0x0, x345, x342);\n    let mut x348: u64 = 0;\n    let mut x349: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x348, &mut x349, x347, x343, x340);\n    let mut x350: u64 = 0;\n    let mut x351: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x350, &mut x351, x349, x341, x338);\n    let mut x352: u64 = 0;\n    let mut x353: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x352, &mut x353, x351, x339, x336);\n    let mut x354: u64 = 0;\n    let mut x355: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x354, &mut x355, x353, x337, x334);\n    let mut x356: u64 = 0;\n    let mut x357: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x356, &mut x357, x355, x335, x332);\n    let mut x358: u64 = 0;\n    let mut x359: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x358, &mut x359, x357, x333, x330);\n    let mut x360: u64 = 0;\n    let mut x361: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x360, &mut x361, x359, x331, x328);\n    let x362: u64 = ((x361 as u64) + x329);\n    let mut x363: u64 = 0;\n    let mut x364: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x363, &mut x364, 0x0, x309, x344);\n    let mut x365: u64 = 0;\n    let mut x366: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x365, &mut x366, x364, x311, x346);\n    let mut x367: u64 = 0;\n    let mut x368: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x367, &mut x368, x366, x313, x348);\n    let mut x369: u64 = 0;\n    let mut x370: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x369, &mut x370, x368, x315, x350);\n    let mut x371: u64 = 0;\n    let mut x372: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x371, &mut x372, x370, x317, x352);\n    let mut x373: u64 = 0;\n    let mut x374: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x373, &mut x374, x372, x319, x354);\n    let mut x375: u64 = 0;\n    let mut x376: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x375, &mut x376, x374, x321, x356);\n    let mut x377: u64 = 0;\n    let mut x378: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x377, &mut x378, x376, x323, x358);\n    let mut x379: u64 = 0;\n    let mut x380: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x379, &mut x380, x378, x325, x360);\n    let mut x381: u64 = 0;\n    let mut x382: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x381, &mut x382, x380, x327, x362);\n    let mut x383: u64 = 0;\n    let mut x384: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x383, &mut x384, x363, 0x1d2f5ccd79a995c7);\n    let mut x385: u64 = 0;\n    let mut x386: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x385, &mut x386, x383, 0x1ff);\n    let mut x387: u64 = 0;\n    let mut x388: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x387, &mut x388, x383, 0xffffffffffffffff);\n    let mut x389: u64 = 0;\n    let mut x390: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x389, &mut x390, x383, 0xffffffffffffffff);\n    let mut x391: u64 = 0;\n    let mut x392: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x391, &mut x392, x383, 0xffffffffffffffff);\n    let mut x393: u64 = 0;\n    let mut x394: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x393, &mut x394, x383, 0xfffffffffffffffa);\n    let mut x395: u64 = 0;\n    let mut x396: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x395, &mut x396, x383, 0x51868783bf2f966b);\n    let mut x397: u64 = 0;\n    let mut x398: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x397, &mut x398, x383, 0x7fcc0148f709a5d0);\n    let mut x399: u64 = 0;\n    let mut x400: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x399, &mut x400, x383, 0x3bb5c9b8899c47ae);\n    let mut x401: u64 = 0;\n    let mut x402: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x401, &mut x402, x383, 0xbb6fb71e91386409);\n    let mut x403: u64 = 0;\n    let mut x404: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x403, &mut x404, 0x0, x402, x399);\n    let mut x405: u64 = 0;\n    let mut x406: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x405, &mut x406, x404, x400, x397);\n    let mut x407: u64 = 0;\n    let mut x408: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x407, &mut x408, x406, x398, x395);\n    let mut x409: u64 = 0;\n    let mut x410: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x409, &mut x410, x408, x396, x393);\n    let mut x411: u64 = 0;\n    let mut x412: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x411, &mut x412, x410, x394, x391);\n    let mut x413: u64 = 0;\n    let mut x414: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x413, &mut x414, x412, x392, x389);\n    let mut x415: u64 = 0;\n    let mut x416: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x415, &mut x416, x414, x390, x387);\n    let mut x417: u64 = 0;\n    let mut x418: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x417, &mut x418, x416, x388, x385);\n    let x419: u64 = ((x418 as u64) + x386);\n    let mut x420: u64 = 0;\n    let mut x421: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x420, &mut x421, 0x0, x363, x401);\n    let mut x422: u64 = 0;\n    let mut x423: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x422, &mut x423, x421, x365, x403);\n    let mut x424: u64 = 0;\n    let mut x425: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x424, &mut x425, x423, x367, x405);\n    let mut x426: u64 = 0;\n    let mut x427: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x426, &mut x427, x425, x369, x407);\n    let mut x428: u64 = 0;\n    let mut x429: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x428, &mut x429, x427, x371, x409);\n    let mut x430: u64 = 0;\n    let mut x431: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x430, &mut x431, x429, x373, x411);\n    let mut x432: u64 = 0;\n    let mut x433: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x432, &mut x433, x431, x375, x413);\n    let mut x434: u64 = 0;\n    let mut x435: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x434, &mut x435, x433, x377, x415);\n    let mut x436: u64 = 0;\n    let mut x437: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x436, &mut x437, x435, x379, x417);\n    let mut x438: u64 = 0;\n    let mut x439: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x438, &mut x439, x437, x381, x419);\n    let x440: u64 = ((x439 as u64) + (x382 as u64));\n    let mut x441: u64 = 0;\n    let mut x442: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x441, &mut x442, x4, (arg2[8]));\n    let mut x443: u64 = 0;\n    let mut x444: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x443, &mut x444, x4, (arg2[7]));\n    let mut x445: u64 = 0;\n    let mut x446: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x445, &mut x446, x4, (arg2[6]));\n    let mut x447: u64 = 0;\n    let mut x448: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x447, &mut x448, x4, (arg2[5]));\n    let mut x449: u64 = 0;\n    let mut x450: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x449, &mut x450, x4, (arg2[4]));\n    let mut x451: u64 = 0;\n    let mut x452: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x451, &mut x452, x4, (arg2[3]));\n    let mut x453: u64 = 0;\n    let mut x454: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x453, &mut x454, x4, (arg2[2]));\n    let mut x455: u64 = 0;\n    let mut x456: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x455, &mut x456, x4, (arg2[1]));\n    let mut x457: u64 = 0;\n    let mut x458: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x457, &mut x458, x4, (arg2[0]));\n    let mut x459: u64 = 0;\n    let mut x460: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x459, &mut x460, 0x0, x458, x455);\n    let mut x461: u64 = 0;\n    let mut x462: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x461, &mut x462, x460, x456, x453);\n    let mut x463: u64 = 0;\n    let mut x464: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x463, &mut x464, x462, x454, x451);\n    let mut x465: u64 = 0;\n    let mut x466: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x465, &mut x466, x464, x452, x449);\n    let mut x467: u64 = 0;\n    let mut x468: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x467, &mut x468, x466, x450, x447);\n    let mut x469: u64 = 0;\n    let mut x470: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x469, &mut x470, x468, x448, x445);\n    let mut x471: u64 = 0;\n    let mut x472: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x471, &mut x472, x470, x446, x443);\n    let mut x473: u64 = 0;\n    let mut x474: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x473, &mut x474, x472, x444, x441);\n    let x475: u64 = ((x474 as u64) + x442);\n    let mut x476: u64 = 0;\n    let mut x477: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x476, &mut x477, 0x0, x422, x457);\n    let mut x478: u64 = 0;\n    let mut x479: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x478, &mut x479, x477, x424, x459);\n    let mut x480: u64 = 0;\n    let mut x481: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x480, &mut x481, x479, x426, x461);\n    let mut x482: u64 = 0;\n    let mut x483: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x482, &mut x483, x481, x428, x463);\n    let mut x484: u64 = 0;\n    let mut x485: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x484, &mut x485, x483, x430, x465);\n    let mut x486: u64 = 0;\n    let mut x487: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x486, &mut x487, x485, x432, x467);\n    let mut x488: u64 = 0;\n    let mut x489: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x488, &mut x489, x487, x434, x469);\n    let mut x490: u64 = 0;\n    let mut x491: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x490, &mut x491, x489, x436, x471);\n    let mut x492: u64 = 0;\n    let mut x493: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x492, &mut x493, x491, x438, x473);\n    let mut x494: u64 = 0;\n    let mut x495: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x494, &mut x495, x493, x440, x475);\n    let mut x496: u64 = 0;\n    let mut x497: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x496, &mut x497, x476, 0x1d2f5ccd79a995c7);\n    let mut x498: u64 = 0;\n    let mut x499: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x498, &mut x499, x496, 0x1ff);\n    let mut x500: u64 = 0;\n    let mut x501: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x500, &mut x501, x496, 0xffffffffffffffff);\n    let mut x502: u64 = 0;\n    let mut x503: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x502, &mut x503, x496, 0xffffffffffffffff);\n    let mut x504: u64 = 0;\n    let mut x505: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x504, &mut x505, x496, 0xffffffffffffffff);\n    let mut x506: u64 = 0;\n    let mut x507: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x506, &mut x507, x496, 0xfffffffffffffffa);\n    let mut x508: u64 = 0;\n    let mut x509: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x508, &mut x509, x496, 0x51868783bf2f966b);\n    let mut x510: u64 = 0;\n    let mut x511: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x510, &mut x511, x496, 0x7fcc0148f709a5d0);\n    let mut x512: u64 = 0;\n    let mut x513: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x512, &mut x513, x496, 0x3bb5c9b8899c47ae);\n    let mut x514: u64 = 0;\n    let mut x515: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x514, &mut x515, x496, 0xbb6fb71e91386409);\n    let mut x516: u64 = 0;\n    let mut x517: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x516, &mut x517, 0x0, x515, x512);\n    let mut x518: u64 = 0;\n    let mut x519: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x518, &mut x519, x517, x513, x510);\n    let mut x520: u64 = 0;\n    let mut x521: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x520, &mut x521, x519, x511, x508);\n    let mut x522: u64 = 0;\n    let mut x523: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x522, &mut x523, x521, x509, x506);\n    let mut x524: u64 = 0;\n    let mut x525: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x524, &mut x525, x523, x507, x504);\n    let mut x526: u64 = 0;\n    let mut x527: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x526, &mut x527, x525, x505, x502);\n    let mut x528: u64 = 0;\n    let mut x529: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x528, &mut x529, x527, x503, x500);\n    let mut x530: u64 = 0;\n    let mut x531: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x530, &mut x531, x529, x501, x498);\n    let x532: u64 = ((x531 as u64) + x499);\n    let mut x533: u64 = 0;\n    let mut x534: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x533, &mut x534, 0x0, x476, x514);\n    let mut x535: u64 = 0;\n    let mut x536: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x535, &mut x536, x534, x478, x516);\n    let mut x537: u64 = 0;\n    let mut x538: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x537, &mut x538, x536, x480, x518);\n    let mut x539: u64 = 0;\n    let mut x540: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x539, &mut x540, x538, x482, x520);\n    let mut x541: u64 = 0;\n    let mut x542: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x541, &mut x542, x540, x484, x522);\n    let mut x543: u64 = 0;\n    let mut x544: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x543, &mut x544, x542, x486, x524);\n    let mut x545: u64 = 0;\n    let mut x546: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x545, &mut x546, x544, x488, x526);\n    let mut x547: u64 = 0;\n    let mut x548: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x547, &mut x548, x546, x490, x528);\n    let mut x549: u64 = 0;\n    let mut x550: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x549, &mut x550, x548, x492, x530);\n    let mut x551: u64 = 0;\n    let mut x552: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x551, &mut x552, x550, x494, x532);\n    let x553: u64 = ((x552 as u64) + (x495 as u64));\n    let mut x554: u64 = 0;\n    let mut x555: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x554, &mut x555, x5, (arg2[8]));\n    let mut x556: u64 = 0;\n    let mut x557: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x556, &mut x557, x5, (arg2[7]));\n    let mut x558: u64 = 0;\n    let mut x559: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x558, &mut x559, x5, (arg2[6]));\n    let mut x560: u64 = 0;\n    let mut x561: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x560, &mut x561, x5, (arg2[5]));\n    let mut x562: u64 = 0;\n    let mut x563: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x562, &mut x563, x5, (arg2[4]));\n    let mut x564: u64 = 0;\n    let mut x565: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x564, &mut x565, x5, (arg2[3]));\n    let mut x566: u64 = 0;\n    let mut x567: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x566, &mut x567, x5, (arg2[2]));\n    let mut x568: u64 = 0;\n    let mut x569: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x568, &mut x569, x5, (arg2[1]));\n    let mut x570: u64 = 0;\n    let mut x571: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x570, &mut x571, x5, (arg2[0]));\n    let mut x572: u64 = 0;\n    let mut x573: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x572, &mut x573, 0x0, x571, x568);\n    let mut x574: u64 = 0;\n    let mut x575: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x574, &mut x575, x573, x569, x566);\n    let mut x576: u64 = 0;\n    let mut x577: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x576, &mut x577, x575, x567, x564);\n    let mut x578: u64 = 0;\n    let mut x579: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x578, &mut x579, x577, x565, x562);\n    let mut x580: u64 = 0;\n    let mut x581: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x580, &mut x581, x579, x563, x560);\n    let mut x582: u64 = 0;\n    let mut x583: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x582, &mut x583, x581, x561, x558);\n    let mut x584: u64 = 0;\n    let mut x585: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x584, &mut x585, x583, x559, x556);\n    let mut x586: u64 = 0;\n    let mut x587: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x586, &mut x587, x585, x557, x554);\n    let x588: u64 = ((x587 as u64) + x555);\n    let mut x589: u64 = 0;\n    let mut x590: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x589, &mut x590, 0x0, x535, x570);\n    let mut x591: u64 = 0;\n    let mut x592: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x591, &mut x592, x590, x537, x572);\n    let mut x593: u64 = 0;\n    let mut x594: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x593, &mut x594, x592, x539, x574);\n    let mut x595: u64 = 0;\n    let mut x596: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x595, &mut x596, x594, x541, x576);\n    let mut x597: u64 = 0;\n    let mut x598: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x597, &mut x598, x596, x543, x578);\n    let mut x599: u64 = 0;\n    let mut x600: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x599, &mut x600, x598, x545, x580);\n    let mut x601: u64 = 0;\n    let mut x602: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x601, &mut x602, x600, x547, x582);\n    let mut x603: u64 = 0;\n    let mut x604: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x603, &mut x604, x602, x549, x584);\n    let mut x605: u64 = 0;\n    let mut x606: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x605, &mut x606, x604, x551, x586);\n    let mut x607: u64 = 0;\n    let mut x608: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x607, &mut x608, x606, x553, x588);\n    let mut x609: u64 = 0;\n    let mut x610: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x609, &mut x610, x589, 0x1d2f5ccd79a995c7);\n    let mut x611: u64 = 0;\n    let mut x612: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x611, &mut x612, x609, 0x1ff);\n    let mut x613: u64 = 0;\n    let mut x614: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x613, &mut x614, x609, 0xffffffffffffffff);\n    let mut x615: u64 = 0;\n    let mut x616: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x615, &mut x616, x609, 0xffffffffffffffff);\n    let mut x617: u64 = 0;\n    let mut x618: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x617, &mut x618, x609, 0xffffffffffffffff);\n    let mut x619: u64 = 0;\n    let mut x620: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x619, &mut x620, x609, 0xfffffffffffffffa);\n    let mut x621: u64 = 0;\n    let mut x622: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x621, &mut x622, x609, 0x51868783bf2f966b);\n    let mut x623: u64 = 0;\n    let mut x624: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x623, &mut x624, x609, 0x7fcc0148f709a5d0);\n    let mut x625: u64 = 0;\n    let mut x626: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x625, &mut x626, x609, 0x3bb5c9b8899c47ae);\n    let mut x627: u64 = 0;\n    let mut x628: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x627, &mut x628, x609, 0xbb6fb71e91386409);\n    let mut x629: u64 = 0;\n    let mut x630: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x629, &mut x630, 0x0, x628, x625);\n    let mut x631: u64 = 0;\n    let mut x632: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x631, &mut x632, x630, x626, x623);\n    let mut x633: u64 = 0;\n    let mut x634: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x633, &mut x634, x632, x624, x621);\n    let mut x635: u64 = 0;\n    let mut x636: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x635, &mut x636, x634, x622, x619);\n    let mut x637: u64 = 0;\n    let mut x638: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x637, &mut x638, x636, x620, x617);\n    let mut x639: u64 = 0;\n    let mut x640: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x639, &mut x640, x638, x618, x615);\n    let mut x641: u64 = 0;\n    let mut x642: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x641, &mut x642, x640, x616, x613);\n    let mut x643: u64 = 0;\n    let mut x644: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x643, &mut x644, x642, x614, x611);\n    let x645: u64 = ((x644 as u64) + x612);\n    let mut x646: u64 = 0;\n    let mut x647: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x646, &mut x647, 0x0, x589, x627);\n    let mut x648: u64 = 0;\n    let mut x649: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x648, &mut x649, x647, x591, x629);\n    let mut x650: u64 = 0;\n    let mut x651: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x650, &mut x651, x649, x593, x631);\n    let mut x652: u64 = 0;\n    let mut x653: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x652, &mut x653, x651, x595, x633);\n    let mut x654: u64 = 0;\n    let mut x655: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x654, &mut x655, x653, x597, x635);\n    let mut x656: u64 = 0;\n    let mut x657: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x656, &mut x657, x655, x599, x637);\n    let mut x658: u64 = 0;\n    let mut x659: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x658, &mut x659, x657, x601, x639);\n    let mut x660: u64 = 0;\n    let mut x661: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x660, &mut x661, x659, x603, x641);\n    let mut x662: u64 = 0;\n    let mut x663: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x662, &mut x663, x661, x605, x643);\n    let mut x664: u64 = 0;\n    let mut x665: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x664, &mut x665, x663, x607, x645);\n    let x666: u64 = ((x665 as u64) + (x608 as u64));\n    let mut x667: u64 = 0;\n    let mut x668: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x667, &mut x668, x6, (arg2[8]));\n    let mut x669: u64 = 0;\n    let mut x670: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x669, &mut x670, x6, (arg2[7]));\n    let mut x671: u64 = 0;\n    let mut x672: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x671, &mut x672, x6, (arg2[6]));\n    let mut x673: u64 = 0;\n    let mut x674: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x673, &mut x674, x6, (arg2[5]));\n    let mut x675: u64 = 0;\n    let mut x676: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x675, &mut x676, x6, (arg2[4]));\n    let mut x677: u64 = 0;\n    let mut x678: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x677, &mut x678, x6, (arg2[3]));\n    let mut x679: u64 = 0;\n    let mut x680: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x679, &mut x680, x6, (arg2[2]));\n    let mut x681: u64 = 0;\n    let mut x682: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x681, &mut x682, x6, (arg2[1]));\n    let mut x683: u64 = 0;\n    let mut x684: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x683, &mut x684, x6, (arg2[0]));\n    let mut x685: u64 = 0;\n    let mut x686: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x685, &mut x686, 0x0, x684, x681);\n    let mut x687: u64 = 0;\n    let mut x688: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x687, &mut x688, x686, x682, x679);\n    let mut x689: u64 = 0;\n    let mut x690: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x689, &mut x690, x688, x680, x677);\n    let mut x691: u64 = 0;\n    let mut x692: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x691, &mut x692, x690, x678, x675);\n    let mut x693: u64 = 0;\n    let mut x694: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x693, &mut x694, x692, x676, x673);\n    let mut x695: u64 = 0;\n    let mut x696: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x695, &mut x696, x694, x674, x671);\n    let mut x697: u64 = 0;\n    let mut x698: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x697, &mut x698, x696, x672, x669);\n    let mut x699: u64 = 0;\n    let mut x700: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x699, &mut x700, x698, x670, x667);\n    let x701: u64 = ((x700 as u64) + x668);\n    let mut x702: u64 = 0;\n    let mut x703: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x702, &mut x703, 0x0, x648, x683);\n    let mut x704: u64 = 0;\n    let mut x705: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x704, &mut x705, x703, x650, x685);\n    let mut x706: u64 = 0;\n    let mut x707: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x706, &mut x707, x705, x652, x687);\n    let mut x708: u64 = 0;\n    let mut x709: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x708, &mut x709, x707, x654, x689);\n    let mut x710: u64 = 0;\n    let mut x711: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x710, &mut x711, x709, x656, x691);\n    let mut x712: u64 = 0;\n    let mut x713: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x712, &mut x713, x711, x658, x693);\n    let mut x714: u64 = 0;\n    let mut x715: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x714, &mut x715, x713, x660, x695);\n    let mut x716: u64 = 0;\n    let mut x717: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x716, &mut x717, x715, x662, x697);\n    let mut x718: u64 = 0;\n    let mut x719: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x718, &mut x719, x717, x664, x699);\n    let mut x720: u64 = 0;\n    let mut x721: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x720, &mut x721, x719, x666, x701);\n    let mut x722: u64 = 0;\n    let mut x723: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x722, &mut x723, x702, 0x1d2f5ccd79a995c7);\n    let mut x724: u64 = 0;\n    let mut x725: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x724, &mut x725, x722, 0x1ff);\n    let mut x726: u64 = 0;\n    let mut x727: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x726, &mut x727, x722, 0xffffffffffffffff);\n    let mut x728: u64 = 0;\n    let mut x729: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x728, &mut x729, x722, 0xffffffffffffffff);\n    let mut x730: u64 = 0;\n    let mut x731: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x730, &mut x731, x722, 0xffffffffffffffff);\n    let mut x732: u64 = 0;\n    let mut x733: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x732, &mut x733, x722, 0xfffffffffffffffa);\n    let mut x734: u64 = 0;\n    let mut x735: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x734, &mut x735, x722, 0x51868783bf2f966b);\n    let mut x736: u64 = 0;\n    let mut x737: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x736, &mut x737, x722, 0x7fcc0148f709a5d0);\n    let mut x738: u64 = 0;\n    let mut x739: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x738, &mut x739, x722, 0x3bb5c9b8899c47ae);\n    let mut x740: u64 = 0;\n    let mut x741: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x740, &mut x741, x722, 0xbb6fb71e91386409);\n    let mut x742: u64 = 0;\n    let mut x743: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x742, &mut x743, 0x0, x741, x738);\n    let mut x744: u64 = 0;\n    let mut x745: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x744, &mut x745, x743, x739, x736);\n    let mut x746: u64 = 0;\n    let mut x747: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x746, &mut x747, x745, x737, x734);\n    let mut x748: u64 = 0;\n    let mut x749: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x748, &mut x749, x747, x735, x732);\n    let mut x750: u64 = 0;\n    let mut x751: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x750, &mut x751, x749, x733, x730);\n    let mut x752: u64 = 0;\n    let mut x753: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x752, &mut x753, x751, x731, x728);\n    let mut x754: u64 = 0;\n    let mut x755: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x754, &mut x755, x753, x729, x726);\n    let mut x756: u64 = 0;\n    let mut x757: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x756, &mut x757, x755, x727, x724);\n    let x758: u64 = ((x757 as u64) + x725);\n    let mut x759: u64 = 0;\n    let mut x760: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x759, &mut x760, 0x0, x702, x740);\n    let mut x761: u64 = 0;\n    let mut x762: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x761, &mut x762, x760, x704, x742);\n    let mut x763: u64 = 0;\n    let mut x764: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x763, &mut x764, x762, x706, x744);\n    let mut x765: u64 = 0;\n    let mut x766: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x765, &mut x766, x764, x708, x746);\n    let mut x767: u64 = 0;\n    let mut x768: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x767, &mut x768, x766, x710, x748);\n    let mut x769: u64 = 0;\n    let mut x770: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x769, &mut x770, x768, x712, x750);\n    let mut x771: u64 = 0;\n    let mut x772: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x771, &mut x772, x770, x714, x752);\n    let mut x773: u64 = 0;\n    let mut x774: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x773, &mut x774, x772, x716, x754);\n    let mut x775: u64 = 0;\n    let mut x776: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x775, &mut x776, x774, x718, x756);\n    let mut x777: u64 = 0;\n    let mut x778: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x777, &mut x778, x776, x720, x758);\n    let x779: u64 = ((x778 as u64) + (x721 as u64));\n    let mut x780: u64 = 0;\n    let mut x781: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x780, &mut x781, x7, (arg2[8]));\n    let mut x782: u64 = 0;\n    let mut x783: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x782, &mut x783, x7, (arg2[7]));\n    let mut x784: u64 = 0;\n    let mut x785: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x784, &mut x785, x7, (arg2[6]));\n    let mut x786: u64 = 0;\n    let mut x787: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x786, &mut x787, x7, (arg2[5]));\n    let mut x788: u64 = 0;\n    let mut x789: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x788, &mut x789, x7, (arg2[4]));\n    let mut x790: u64 = 0;\n    let mut x791: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x790, &mut x791, x7, (arg2[3]));\n    let mut x792: u64 = 0;\n    let mut x793: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x792, &mut x793, x7, (arg2[2]));\n    let mut x794: u64 = 0;\n    let mut x795: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x794, &mut x795, x7, (arg2[1]));\n    let mut x796: u64 = 0;\n    let mut x797: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x796, &mut x797, x7, (arg2[0]));\n    let mut x798: u64 = 0;\n    let mut x799: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x798, &mut x799, 0x0, x797, x794);\n    let mut x800: u64 = 0;\n    let mut x801: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x800, &mut x801, x799, x795, x792);\n    let mut x802: u64 = 0;\n    let mut x803: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x802, &mut x803, x801, x793, x790);\n    let mut x804: u64 = 0;\n    let mut x805: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x804, &mut x805, x803, x791, x788);\n    let mut x806: u64 = 0;\n    let mut x807: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x806, &mut x807, x805, x789, x786);\n    let mut x808: u64 = 0;\n    let mut x809: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x808, &mut x809, x807, x787, x784);\n    let mut x810: u64 = 0;\n    let mut x811: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x810, &mut x811, x809, x785, x782);\n    let mut x812: u64 = 0;\n    let mut x813: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x812, &mut x813, x811, x783, x780);\n    let x814: u64 = ((x813 as u64) + x781);\n    let mut x815: u64 = 0;\n    let mut x816: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x815, &mut x816, 0x0, x761, x796);\n    let mut x817: u64 = 0;\n    let mut x818: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x817, &mut x818, x816, x763, x798);\n    let mut x819: u64 = 0;\n    let mut x820: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x819, &mut x820, x818, x765, x800);\n    let mut x821: u64 = 0;\n    let mut x822: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x821, &mut x822, x820, x767, x802);\n    let mut x823: u64 = 0;\n    let mut x824: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x823, &mut x824, x822, x769, x804);\n    let mut x825: u64 = 0;\n    let mut x826: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x825, &mut x826, x824, x771, x806);\n    let mut x827: u64 = 0;\n    let mut x828: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x827, &mut x828, x826, x773, x808);\n    let mut x829: u64 = 0;\n    let mut x830: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x829, &mut x830, x828, x775, x810);\n    let mut x831: u64 = 0;\n    let mut x832: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x831, &mut x832, x830, x777, x812);\n    let mut x833: u64 = 0;\n    let mut x834: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x833, &mut x834, x832, x779, x814);\n    let mut x835: u64 = 0;\n    let mut x836: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x835, &mut x836, x815, 0x1d2f5ccd79a995c7);\n    let mut x837: u64 = 0;\n    let mut x838: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x837, &mut x838, x835, 0x1ff);\n    let mut x839: u64 = 0;\n    let mut x840: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x839, &mut x840, x835, 0xffffffffffffffff);\n    let mut x841: u64 = 0;\n    let mut x842: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x841, &mut x842, x835, 0xffffffffffffffff);\n    let mut x843: u64 = 0;\n    let mut x844: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x843, &mut x844, x835, 0xffffffffffffffff);\n    let mut x845: u64 = 0;\n    let mut x846: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x845, &mut x846, x835, 0xfffffffffffffffa);\n    let mut x847: u64 = 0;\n    let mut x848: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x847, &mut x848, x835, 0x51868783bf2f966b);\n    let mut x849: u64 = 0;\n    let mut x850: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x849, &mut x850, x835, 0x7fcc0148f709a5d0);\n    let mut x851: u64 = 0;\n    let mut x852: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x851, &mut x852, x835, 0x3bb5c9b8899c47ae);\n    let mut x853: u64 = 0;\n    let mut x854: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x853, &mut x854, x835, 0xbb6fb71e91386409);\n    let mut x855: u64 = 0;\n    let mut x856: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x855, &mut x856, 0x0, x854, x851);\n    let mut x857: u64 = 0;\n    let mut x858: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x857, &mut x858, x856, x852, x849);\n    let mut x859: u64 = 0;\n    let mut x860: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x859, &mut x860, x858, x850, x847);\n    let mut x861: u64 = 0;\n    let mut x862: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x861, &mut x862, x860, x848, x845);\n    let mut x863: u64 = 0;\n    let mut x864: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x863, &mut x864, x862, x846, x843);\n    let mut x865: u64 = 0;\n    let mut x866: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x865, &mut x866, x864, x844, x841);\n    let mut x867: u64 = 0;\n    let mut x868: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x867, &mut x868, x866, x842, x839);\n    let mut x869: u64 = 0;\n    let mut x870: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x869, &mut x870, x868, x840, x837);\n    let x871: u64 = ((x870 as u64) + x838);\n    let mut x872: u64 = 0;\n    let mut x873: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x872, &mut x873, 0x0, x815, x853);\n    let mut x874: u64 = 0;\n    let mut x875: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x874, &mut x875, x873, x817, x855);\n    let mut x876: u64 = 0;\n    let mut x877: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x876, &mut x877, x875, x819, x857);\n    let mut x878: u64 = 0;\n    let mut x879: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x878, &mut x879, x877, x821, x859);\n    let mut x880: u64 = 0;\n    let mut x881: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x880, &mut x881, x879, x823, x861);\n    let mut x882: u64 = 0;\n    let mut x883: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x882, &mut x883, x881, x825, x863);\n    let mut x884: u64 = 0;\n    let mut x885: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x884, &mut x885, x883, x827, x865);\n    let mut x886: u64 = 0;\n    let mut x887: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x886, &mut x887, x885, x829, x867);\n    let mut x888: u64 = 0;\n    let mut x889: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x888, &mut x889, x887, x831, x869);\n    let mut x890: u64 = 0;\n    let mut x891: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x890, &mut x891, x889, x833, x871);\n    let x892: u64 = ((x891 as u64) + (x834 as u64));\n    let mut x893: u64 = 0;\n    let mut x894: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x893, &mut x894, x8, (arg2[8]));\n    let mut x895: u64 = 0;\n    let mut x896: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x895, &mut x896, x8, (arg2[7]));\n    let mut x897: u64 = 0;\n    let mut x898: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x897, &mut x898, x8, (arg2[6]));\n    let mut x899: u64 = 0;\n    let mut x900: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x899, &mut x900, x8, (arg2[5]));\n    let mut x901: u64 = 0;\n    let mut x902: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x901, &mut x902, x8, (arg2[4]));\n    let mut x903: u64 = 0;\n    let mut x904: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x903, &mut x904, x8, (arg2[3]));\n    let mut x905: u64 = 0;\n    let mut x906: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x905, &mut x906, x8, (arg2[2]));\n    let mut x907: u64 = 0;\n    let mut x908: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x907, &mut x908, x8, (arg2[1]));\n    let mut x909: u64 = 0;\n    let mut x910: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x909, &mut x910, x8, (arg2[0]));\n    let mut x911: u64 = 0;\n    let mut x912: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x911, &mut x912, 0x0, x910, x907);\n    let mut x913: u64 = 0;\n    let mut x914: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x913, &mut x914, x912, x908, x905);\n    let mut x915: u64 = 0;\n    let mut x916: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x915, &mut x916, x914, x906, x903);\n    let mut x917: u64 = 0;\n    let mut x918: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x917, &mut x918, x916, x904, x901);\n    let mut x919: u64 = 0;\n    let mut x920: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x919, &mut x920, x918, x902, x899);\n    let mut x921: u64 = 0;\n    let mut x922: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x921, &mut x922, x920, x900, x897);\n    let mut x923: u64 = 0;\n    let mut x924: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x923, &mut x924, x922, x898, x895);\n    let mut x925: u64 = 0;\n    let mut x926: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x925, &mut x926, x924, x896, x893);\n    let x927: u64 = ((x926 as u64) + x894);\n    let mut x928: u64 = 0;\n    let mut x929: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x928, &mut x929, 0x0, x874, x909);\n    let mut x930: u64 = 0;\n    let mut x931: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x930, &mut x931, x929, x876, x911);\n    let mut x932: u64 = 0;\n    let mut x933: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x932, &mut x933, x931, x878, x913);\n    let mut x934: u64 = 0;\n    let mut x935: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x934, &mut x935, x933, x880, x915);\n    let mut x936: u64 = 0;\n    let mut x937: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x936, &mut x937, x935, x882, x917);\n    let mut x938: u64 = 0;\n    let mut x939: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x938, &mut x939, x937, x884, x919);\n    let mut x940: u64 = 0;\n    let mut x941: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x940, &mut x941, x939, x886, x921);\n    let mut x942: u64 = 0;\n    let mut x943: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x942, &mut x943, x941, x888, x923);\n    let mut x944: u64 = 0;\n    let mut x945: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x944, &mut x945, x943, x890, x925);\n    let mut x946: u64 = 0;\n    let mut x947: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x946, &mut x947, x945, x892, x927);\n    let mut x948: u64 = 0;\n    let mut x949: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x948, &mut x949, x928, 0x1d2f5ccd79a995c7);\n    let mut x950: u64 = 0;\n    let mut x951: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x950, &mut x951, x948, 0x1ff);\n    let mut x952: u64 = 0;\n    let mut x953: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x952, &mut x953, x948, 0xffffffffffffffff);\n    let mut x954: u64 = 0;\n    let mut x955: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x954, &mut x955, x948, 0xffffffffffffffff);\n    let mut x956: u64 = 0;\n    let mut x957: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x956, &mut x957, x948, 0xffffffffffffffff);\n    let mut x958: u64 = 0;\n    let mut x959: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x958, &mut x959, x948, 0xfffffffffffffffa);\n    let mut x960: u64 = 0;\n    let mut x961: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x960, &mut x961, x948, 0x51868783bf2f966b);\n    let mut x962: u64 = 0;\n    let mut x963: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x962, &mut x963, x948, 0x7fcc0148f709a5d0);\n    let mut x964: u64 = 0;\n    let mut x965: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x964, &mut x965, x948, 0x3bb5c9b8899c47ae);\n    let mut x966: u64 = 0;\n    let mut x967: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x966, &mut x967, x948, 0xbb6fb71e91386409);\n    let mut x968: u64 = 0;\n    let mut x969: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x968, &mut x969, 0x0, x967, x964);\n    let mut x970: u64 = 0;\n    let mut x971: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x970, &mut x971, x969, x965, x962);\n    let mut x972: u64 = 0;\n    let mut x973: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x972, &mut x973, x971, x963, x960);\n    let mut x974: u64 = 0;\n    let mut x975: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x974, &mut x975, x973, x961, x958);\n    let mut x976: u64 = 0;\n    let mut x977: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x976, &mut x977, x975, x959, x956);\n    let mut x978: u64 = 0;\n    let mut x979: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x978, &mut x979, x977, x957, x954);\n    let mut x980: u64 = 0;\n    let mut x981: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x980, &mut x981, x979, x955, x952);\n    let mut x982: u64 = 0;\n    let mut x983: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x982, &mut x983, x981, x953, x950);\n    let x984: u64 = ((x983 as u64) + x951);\n    let mut x985: u64 = 0;\n    let mut x986: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x985, &mut x986, 0x0, x928, x966);\n    let mut x987: u64 = 0;\n    let mut x988: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x987, &mut x988, x986, x930, x968);\n    let mut x989: u64 = 0;\n    let mut x990: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x989, &mut x990, x988, x932, x970);\n    let mut x991: u64 = 0;\n    let mut x992: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x991, &mut x992, x990, x934, x972);\n    let mut x993: u64 = 0;\n    let mut x994: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x993, &mut x994, x992, x936, x974);\n    let mut x995: u64 = 0;\n    let mut x996: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x995, &mut x996, x994, x938, x976);\n    let mut x997: u64 = 0;\n    let mut x998: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x997, &mut x998, x996, x940, x978);\n    let mut x999: u64 = 0;\n    let mut x1000: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x999, &mut x1000, x998, x942, x980);\n    let mut x1001: u64 = 0;\n    let mut x1002: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x1001, &mut x1002, x1000, x944, x982);\n    let mut x1003: u64 = 0;\n    let mut x1004: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x1003, &mut x1004, x1002, x946, x984);\n    let x1005: u64 = ((x1004 as u64) + (x947 as u64));\n    let mut x1006: u64 = 0;\n    let mut x1007: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1006, &mut x1007, 0x0, x987, 0xbb6fb71e91386409);\n    let mut x1008: u64 = 0;\n    let mut x1009: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1008, &mut x1009, x1007, x989, 0x3bb5c9b8899c47ae);\n    let mut x1010: u64 = 0;\n    let mut x1011: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1010, &mut x1011, x1009, x991, 0x7fcc0148f709a5d0);\n    let mut x1012: u64 = 0;\n    let mut x1013: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1012, &mut x1013, x1011, x993, 0x51868783bf2f966b);\n    let mut x1014: u64 = 0;\n    let mut x1015: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1014, &mut x1015, x1013, x995, 0xfffffffffffffffa);\n    let mut x1016: u64 = 0;\n    let mut x1017: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1016, &mut x1017, x1015, x997, 0xffffffffffffffff);\n    let mut x1018: u64 = 0;\n    let mut x1019: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1018, &mut x1019, x1017, x999, 0xffffffffffffffff);\n    let mut x1020: u64 = 0;\n    let mut x1021: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1020, &mut x1021, x1019, x1001, 0xffffffffffffffff);\n    let mut x1022: u64 = 0;\n    let mut x1023: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1022, &mut x1023, x1021, x1003, 0x1ff);\n    let mut x1024: u64 = 0;\n    let mut x1025: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x1024, &mut x1025, x1023, x1005, (0x0 as u64));\n    let mut x1026: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1026, x1025, x1006, x987);\n    let mut x1027: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1027, x1025, x1008, x989);\n    let mut x1028: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1028, x1025, x1010, x991);\n    let mut x1029: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1029, x1025, x1012, x993);\n    let mut x1030: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1030, x1025, x1014, x995);\n    let mut x1031: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1031, x1025, x1016, x997);\n    let mut x1032: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1032, x1025, x1018, x999);\n    let mut x1033: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1033, x1025, x1020, x1001);\n    let mut x1034: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x1034, x1025, x1022, x1003);\n    out1[0] = x1026;\n    out1[1] = x1027;\n    out1[2] = x1028;\n    out1[3] = x1029;\n    out1[4] = x1030;\n    out1[5] = x1031;\n    out1[6] = x1032;\n    out1[7] = x1033;\n    out1[8] = x1034;\n}",
    "display_name": "fiat_p521_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_cmovznz_u64(\n    out1: &mut u64,\n    arg1: fiat_p224_scalar_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: fiat_p224_scalar_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_p224_scalar_i2) - (x1 as fiat_p224_scalar_i2))\n        as fiat_p224_scalar_i1) as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_p224_scalar_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom/try_from"
    ],
    "body": "    fn try_from(value: &Vec<u8>) -> Result<Self, Self::Error> {\n        Self::try_from(value.as_slice())\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn shr_vartime(&self, shift: u32) -> Scalar {\n        Self(self.0.wrapping_shr_vartime(shift))\n    }",
    "display_name": "shr_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_p224_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_scalar_msat(out1: &mut [u64; 5]) {\n    out1[0] = 0x53bbf40939d54123;\n    out1[1] = 0x7203df6b21c6052b;\n    out1[2] = 0xffffffffffffffff;\n    out1[3] = 0xfffffffeffffffff;\n    out1[4] = (0x0 as u64);\n}",
    "display_name": "fiat_sm2_scalar_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/split_scalars",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/r",
      "0.14.0_pre dsa/impl/Signature/s"
    ],
    "body": "    pub fn split_scalars(&self) -> (NonZeroScalar, NonZeroScalar) {\n        (self.r(), self.s())\n    }",
    "display_name": "split_scalars",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_point_mul"
    ],
    "body": "fn bench_point(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"point operations\");\n    bench_point_mul(&mut group);\n    group.finish();\n}",
    "display_name": "bench_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p384_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.secret.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/verifying_key",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn verifying_key(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }",
    "display_name": "verifying_key",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/invert_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "invert_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_bign256_scalar_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/tests/bip340_verify_vectors",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/from_bytes",
      "0.14.0_pre.8 schnorr/impl/Signature/TryFrom/try_from",
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/PrehashVerifier/verify_prehash"
    ],
    "body": "    fn bip340_verify_vectors() {\n        for vector in BIP340_VERIFY_VECTORS {\n            let valid = match (\n                VerifyingKey::from_bytes(&vector.public_key),\n                Signature::try_from(vector.signature.as_slice()),\n            ) {\n                (Ok(pk), Ok(sig)) => pk.verify_prehash(&vector.message, &sig).is_ok(),\n                _ => false,\n            };\n\n            assert_eq!(\n                vector.valid, valid,\n                \"incorrect validation for index {}\",\n                vector.index\n            );\n        }\n    }",
    "display_name": "bip340_verify_vectors",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr.rs",
    "relative_path": "k256/src/schnorr.rs",
    "file_name": "schnorr.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/modulus_as_biguint",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/ToBigUint/to_biguint"
    ],
    "body": "    pub fn modulus_as_biguint() -> BigUint {\n        Self::ONE.negate(1).to_biguint().unwrap() + 1.to_biguint().unwrap()\n    }",
    "display_name": "modulus_as_biguint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(k: u128) -> Self {\n        Scalar(k.into())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/zero_is_additive_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize"
    ],
    "body": "    fn zero_is_additive_identity() {\n        let zero = FieldElement::ZERO;\n        let one = FieldElement::ONE;\n        assert_eq!((zero + &zero).normalize(), zero);\n        assert_eq!((one + &zero).normalize(), one);\n    }",
    "display_name": "zero_is_additive_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {\n        let bytes = <PointBytes>::try_from(value).map_err(|_| \"Invalid length\")?;\n        Ok(CompressedEdwardsY(bytes))\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/normalizes_to_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/normalizes_to_zero"
    ],
    "body": "    pub fn normalizes_to_zero(&self) -> Choice {\n        self.value.normalizes_to_zero()\n    }",
    "display_name": "normalizes_to_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_addcarryx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_addcarryx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_bign256_u1,\n    arg1: fiat_bign256_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: u128 = (((arg1 as u128) + (arg2 as u128)) + (arg3 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: fiat_bign256_u1 = ((x1 >> 64) as fiat_bign256_u1);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_bign256_addcarryx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/get_overflow",
    "statement_type": "function",
    "deps": [],
    "body": "    fn get_overflow(&self) -> Choice {\n        let m = self.0[1] & self.0[2] & self.0[3];\n        let x = (self.0[4] >> 48 != 0)\n            | ((self.0[4] == 0x0FFFFFFFFFFFFu64)\n                & (m == 0xFFFFFFFFFFFFFu64)\n                & (self.0[0] >= 0xFFFFEFFFFFC2Fu64));\n        Choice::from(x as u8)\n    }",
    "display_name": "get_overflow",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_bign256_cmovznz_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_cmovznz_u64(out1: &mut u64, arg1: fiat_bign256_u1, arg2: u64, arg3: u64) {\n    let x1: fiat_bign256_u1 = (!(!arg1));\n    let x2: u64 = ((((((0x0 as fiat_bign256_i2) - (x1 as fiat_bign256_i2)) as fiat_bign256_i1)\n        as i128)\n        & (0xffffffffffffffff as i128)) as u64);\n    let x3: u64 = ((x2 & arg3) | ((!x2) & arg2));\n    *out1 = x3;\n}",
    "display_name": "fiat_bign256_cmovznz_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field/bign256_64.rs",
    "relative_path": "bign256/src/arithmetic/field/bign256_64.rs",
    "file_name": "bign256_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "affine/impl/AffinePoint/AffineCoordinates/y_is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "    fn y_is_odd(&self) -> Choice {\n        self.y.is_odd()\n    }",
    "display_name": "y_is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &ExtendedPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(U256::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from_uint_unchecked(uint: Self::Uint) -> Self {\n        Self::from_uint_unchecked(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_square"
    ],
    "body": "    pub const fn square(&self) -> FieldElement {\n        let mut out = fiat_p521_tight_field_element([0; 9]);\n        fiat_p521_carry_square(&mut out, &self.0);\n        FieldElement(out)\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/loose.rs",
    "relative_path": "p521/src/arithmetic/field/loose.rs",
    "file_name": "loose.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/from_affine",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/Group/is_identity",
      "projective/impl/ProjectivePoint/From>/from"
    ],
    "body": "    pub fn from_affine(point: AffinePoint<BignP256>) -> Result<Self, Error> {\n        if ProjectivePoint::from(point).is_identity().into() {\n            Err(Error)\n        } else {\n            Ok(Self { point })\n        }\n    }",
    "display_name": "from_affine",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 test_field_element_x",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_field_element_x() -> FieldElement {\n    FieldElement::from_bytes(\n        hex!(\"1ccbe91c075fc7f4f033bfa248db8fccd3565de94bbfb12f3c59ff46c271bf83\").as_ref(),\n    )\n    .unwrap()\n}",
    "display_name": "test_field_element_x",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/field.rs",
    "relative_path": "p256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(affine_point: NonIdentity<AffinePoint>) -> Self {\n        affine_point.to_point()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/from_canonical_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/from_bytes",
      "0.14.0_pre.1 field/scalar/is_zero"
    ],
    "body": "    pub fn from_canonical_bytes(bytes: &ScalarBytes) -> CtOption<Self> {\n        // Check that the 10 high bits are not set\n        let is_valid = is_zero(bytes[56]) | is_zero(bytes[55] >> 6);\n        let bytes: [u8; 56] = core::array::from_fn(|i| bytes[i]);\n        let candidate = Scalar::from_bytes(&bytes);\n\n        // underflow means candidate < ORDER, thus canonical\n        let (_, underflow) = candidate.0.borrowing_sub(&ORDER, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        CtOption::new(candidate, underflow & is_valid)\n    }",
    "display_name": "from_canonical_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/double",
      "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_extended",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible"
    ],
    "body": "    pub(crate) fn double(&self) -> ExtendedPoint {\n        self.to_extensible().double().to_extended()\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/SharedSecret/Drop/drop",
    "statement_type": "function",
    "deps": [],
    "body": "    fn drop(&mut self) {\n        self.secret_bytes.zeroize()\n    }",
    "display_name": "drop",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "projective/batch_normalize_generic",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ConditionallySelectable/conditional_select"
    ],
    "body": "fn batch_normalize_generic<C, P, Z, I, O>(points: &P, mut zs: Z, out: &mut O)\nwhere\n    C: PrimeCurveParams,\n    C::FieldElement: BatchInvert<Z, Output = CtOption<I>>,\n    C::ProjectivePoint: Double,\n    P: AsRef<[ProjectivePoint<C>]> + ?Sized,\n    Z: AsMut<[C::FieldElement]>,\n    I: AsRef<[C::FieldElement]>,\n    O: AsMut<[AffinePoint<C>]> + ?Sized,\n{\n    let points = points.as_ref();\n    let out = out.as_mut();\n\n    for i in 0..points.len() {\n        // Even a single zero value will fail inversion for the entire batch.\n        // Put a dummy value (above `FieldElement::ONE`) so inversion succeeds\n        // and treat that case specially later-on.\n        zs.as_mut()[i].conditional_assign(&points[i].z, !points[i].z.ct_eq(&C::FieldElement::ZERO));\n    }\n\n    // This is safe to unwrap since we assured that all elements are non-zero\n    let zs_inverses = <C::FieldElement as BatchInvert<Z>>::batch_invert(zs)\n        .expect(\"all elements should be non-zero\");\n\n    for i in 0..out.len() {\n        // If the `z` coordinate is non-zero, we can use it to invert;\n        // otherwise it defaults to the `IDENTITY` value.\n        out[i] = C::AffinePoint::conditional_select(\n            &points[i].to_affine_internal(zs_inverses.as_ref()[i]),\n            &C::AffinePoint::IDENTITY,\n            points[i].z.ct_eq(&C::FieldElement::ZERO),\n        );\n    }\n}",
    "display_name": "batch_normalize_generic",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre public_key/impl/PublicKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    pub fn to_bytes(&self) -> Box<[u8]> {\n        let mut bytes = self.point.to_encoded_point(false).to_bytes();\n        bytes[1..32 + 1].reverse();\n        bytes[33..].reverse();\n        bytes[1..].to_vec().into_boxed_slice()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/public_key.rs",
    "relative_path": "bign256/src/public_key.rs",
    "file_name": "public_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/MultipartSigner/try_multipart_sign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/PrehashSigner/sign_prehash",
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/hash_msg"
    ],
    "body": "    fn try_multipart_sign(&self, msg: &[&[u8]]) -> Result<Signature> {\n        // A1: set M~=ZA || M\n        let hash = self.verifying_key.hash_msg(msg);\n        self.sign_prehash(&hash)\n    }",
    "display_name": "try_multipart_sign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, rhs: Self) {\n        *self = *self * rhs\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 ecdsa/tests/normalize/s_high",
    "statement_type": "function",
    "deps": [],
    "body": "        fn s_high() {\n            let sig_hi = Signature::try_from([\n                0x20, 0xc0, 0x1a, 0x91, 0x0e, 0xbb, 0x26, 0x10,\n                0xaf, 0x2d, 0x76, 0x3f, 0xa0, 0x9b, 0x3b, 0x30,\n                0x92, 0x3c, 0x8e, 0x40, 0x8b, 0x11, 0xdf, 0x2c,\n                0x61, 0xad, 0x76, 0xd9, 0x70, 0xa2, 0xf1, 0xbc,\n                0xee, 0x2f, 0x11, 0xef, 0x8c, 0xb0, 0x0a, 0x49,\n                0x61, 0x7d, 0x13, 0x57, 0xf4, 0xd5, 0x56, 0x41,\n                0x09, 0x0a, 0x48, 0xf2, 0x01, 0xe9, 0xb9, 0x59,\n                0xc4, 0x8f, 0x6f, 0x6b, 0xec, 0x6f, 0x93, 0x8f,\n            ].as_slice()).unwrap();\n\n            let sig_lo = Signature::try_from([\n                0x20, 0xc0, 0x1a, 0x91, 0x0e, 0xbb, 0x26, 0x10,\n                0xaf, 0x2d, 0x76, 0x3f, 0xa0, 0x9b, 0x3b, 0x30,\n                0x92, 0x3c, 0x8e, 0x40, 0x8b, 0x11, 0xdf, 0x2c,\n                0x61, 0xad, 0x76, 0xd9, 0x70, 0xa2, 0xf1, 0xbc,\n                0x11, 0xd0, 0xee, 0x10, 0x73, 0x4f, 0xf5, 0xb6,\n                0x9e, 0x82, 0xec, 0xa8, 0x0b, 0x2a, 0xa9, 0xbd,\n                0xb1, 0xa4, 0x93, 0xf4, 0xad, 0x5e, 0xe6, 0xe1,\n                0xfb, 0x42, 0xef, 0x20, 0xe3, 0xc6, 0xad, 0xb2,\n            ].as_slice()).unwrap();\n\n            let sig_normalized = sig_hi.normalize_s();\n            assert_eq!(sig_lo, sig_normalized);\n        }",
    "display_name": "s_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/ecdsa.rs",
    "relative_path": "k256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &Scalar {\n        self\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/encrypt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint",
      "0.14.0_pre pke/encrypting/next_k",
      "projective/impl/ProjectivePoint/Group/is_identity",
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
      "projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre pke/kdf",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "fn encrypt<R: TryCryptoRng + ?Sized>(\n    rng: &mut R,\n    public_key: &PublicKey,\n    mode: Mode,\n    digest: &mut dyn DynDigest,\n    msg: &[u8],\n) -> Result<Vec<u8>> {\n    const N_BYTES: u32 = Sm2::ORDER.bits().div_ceil(8);\n    let mut c1 = vec![0; (N_BYTES * 2 + 1) as usize];\n    let mut c2 = msg.to_owned();\n    let mut hpb: AffinePoint;\n    loop {\n        // A1: generate a random number 𝑘 ∈ [1, 𝑛 − 1] with the random number generator\n        let k = Scalar::from_uint(next_k(rng, N_BYTES)?).unwrap();\n\n        // A2: compute point 𝐶1 = [𝑘]𝐺 = (𝑥1, 𝑦1)\n        let kg = ProjectivePoint::mul_by_generator(&k).to_affine();\n\n        // A3: compute point 𝑆 = [ℎ]𝑃𝐵 of the elliptic curve\n        let pb_point = public_key.as_affine();\n        let s = *pb_point * Scalar::reduce(U256::from_u32(FieldElement::S));\n        if s.is_identity().into() {\n            return Err(Error);\n        }\n\n        // A4: compute point [𝑘]𝑃𝐵 = (𝑥2, 𝑦2)\n        hpb = (s * k).to_affine();\n\n        // A5: compute 𝑡 = 𝐾𝐷𝐹(𝑥2||𝑦2, 𝑘𝑙𝑒𝑛)\n        // A6: compute 𝐶2 = 𝑀 ⊕ t\n        kdf(digest, hpb, &mut c2)?;\n\n        // // If 𝑡 is an all-zero bit string, go to A1.\n        // if all of t are 0, xor(c2) == c2\n        if c2.iter().zip(msg).any(|(pre, cur)| pre != cur) {\n            let uncompress_kg = kg.to_encoded_point(false);\n            c1.copy_from_slice(uncompress_kg.as_bytes());\n            break;\n        }\n    }\n    let encode_point = hpb.to_encoded_point(false);\n\n    // A7: compute 𝐶3 = 𝐻𝑎𝑠ℎ(𝑥2||𝑀||𝑦2)\n    let mut c3 = vec![0; digest.output_size()];\n    digest.update(encode_point.x().ok_or(Error)?);\n    digest.update(msg);\n    digest.update(encode_point.y().ok_or(Error)?);\n    digest.finalize_into_reset(&mut c3).map_err(|_e| Error)?;\n\n    // A8: output the ciphertext 𝐶 = 𝐶1||𝐶2||𝐶3.\n    Ok(match mode {\n        Mode::C1C2C3 => [c1.as_slice(), &c2, &c3].concat(),\n        Mode::C1C3C2 => [c1.as_slice(), &c3, &c2].concat(),\n    })\n}",
    "display_name": "encrypt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.8 encode_pkcs8_private_key_to_der",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_private_key_to_der() {\n    let original_secret_key = p256::SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let reencoded_secret_key = original_secret_key.to_pkcs8_der().unwrap();\n    assert_eq!(reencoded_secret_key.as_bytes(), &PKCS8_PRIVATE_KEY_DER[..]);\n}",
    "display_name": "encode_pkcs8_private_key_to_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/pkcs8.rs",
    "relative_path": "p256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/normalize"
    ],
    "body": "    pub fn normalize(&self) -> Self {\n        Self(self.0.normalize())\n    }",
    "display_name": "normalize",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_extensible",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_extensible(self) -> ExtensiblePoint {\n        ExtensiblePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n            T1: self.T,\n            T2: FieldElement::ONE,\n        }\n    }",
    "display_name": "to_extensible",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Invert/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        self.invert()\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/impl/Signature/from_scalars",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_scalars(r: impl Into<FieldBytes>, s: impl Into<FieldBytes>) -> Result<Self> {\n        Self::try_from(r.into().concat(s.into()).as_slice())\n    }",
    "display_name": "from_scalars",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/batch_normalize_array",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/mul_by_generator",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/BatchNormalize/batch_normalize",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/Curve/batch_normalize"
    ],
    "body": "    fn batch_normalize_array() {\n        let k: Scalar = Scalar::random(&mut OsRng.unwrap_mut());\n        let l: Scalar = Scalar::random(&mut OsRng.unwrap_mut());\n        let g = ProjectivePoint::mul_by_generator(&k);\n        let h = ProjectivePoint::mul_by_generator(&l);\n\n        let mut res = [AffinePoint::IDENTITY; 2];\n        let expected = [g.to_affine(), h.to_affine()];\n        assert_eq!(\n            <ProjectivePoint as BatchNormalize<_>>::batch_normalize(&[g, h]),\n            expected\n        );\n\n        <ProjectivePoint as CurveGroup>::batch_normalize(&[g, h], &mut res);\n        assert_eq!(res, expected);\n\n        let mut res = [AffinePoint::IDENTITY; 3];\n        let non_normalized_identity =\n            ProjectivePoint::IDENTITY * Scalar::random(&mut OsRng.unwrap_mut());\n        let expected = [g.to_affine(), AffinePoint::IDENTITY, AffinePoint::IDENTITY];\n        assert_eq!(\n            <ProjectivePoint as BatchNormalize<_>>::batch_normalize(&[\n                g,\n                ProjectivePoint::IDENTITY,\n                non_normalized_identity,\n            ]),\n            expected\n        );\n\n        <ProjectivePoint as CurveGroup>::batch_normalize(\n            &[g, ProjectivePoint::IDENTITY, non_normalized_identity],\n            &mut res,\n        );\n        assert_eq!(res, expected);\n    }",
    "display_name": "batch_normalize_array",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 ristretto/points/impl/CompressedRistretto/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 ristretto/points/impl/CompressedRistretto/as_bytes"
    ],
    "body": "    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/ristretto/points.rs",
    "relative_path": "ed448-goldilocks/src/ristretto/points.rs",
    "file_name": "points.rs",
    "parent_folder": "ristretto"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_to_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_mulx_u64"
    ],
    "body": "pub const fn fiat_bign256_scalar_to_montgomery(\n    out1: &mut fiat_bign256_scalar_montgomery_domain_field_element,\n    arg1: &fiat_bign256_scalar_non_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x5, &mut x6, x4, 0x5d4edf1c149a55b);\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x7, &mut x8, x4, 0x4a6925c6a269dbf8);\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x9, &mut x10, x4, 0x1b5a5bc108b44a10);\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x11, &mut x12, x4, 0xfa44af61dbff9431);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let mut x19: u64 = 0;\n    let mut x20: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x19, &mut x20, x11, 0x8d64dbd30858d849);\n    let mut x21: u64 = 0;\n    let mut x22: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x21, &mut x22, x19, 0xffffffffffffffff);\n    let mut x23: u64 = 0;\n    let mut x24: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x23, &mut x24, x19, 0xffffffffffffffff);\n    let mut x25: u64 = 0;\n    let mut x26: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x25, &mut x26, x19, 0xd95c8ed60dfb4dfc);\n    let mut x27: u64 = 0;\n    let mut x28: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x27, &mut x28, x19, 0x7e5abf99263d6607);\n    let mut x29: u64 = 0;\n    let mut x30: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x29, &mut x30, 0x0, x28, x25);\n    let mut x31: u64 = 0;\n    let mut x32: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x31, &mut x32, x30, x26, x23);\n    let mut x33: u64 = 0;\n    let mut x34: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x33, &mut x34, x32, x24, x21);\n    let mut x35: u64 = 0;\n    let mut x36: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x35, &mut x36, 0x0, x11, x27);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x37, &mut x38, x36, x13, x29);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x15, x31);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x17, x33);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(\n        &mut x43,\n        &mut x44,\n        x42,\n        ((x18 as u64) + x6),\n        ((x34 as u64) + x22),\n    );\n    let mut x45: u64 = 0;\n    let mut x46: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x45, &mut x46, x1, 0x5d4edf1c149a55b);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x47, &mut x48, x1, 0x4a6925c6a269dbf8);\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x49, &mut x50, x1, 0x1b5a5bc108b44a10);\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x51, &mut x52, x1, 0xfa44af61dbff9431);\n    let mut x53: u64 = 0;\n    let mut x54: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x53, &mut x54, 0x0, x52, x49);\n    let mut x55: u64 = 0;\n    let mut x56: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x55, &mut x56, x54, x50, x47);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x48, x45);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x59, &mut x60, 0x0, x37, x51);\n    let mut x61: u64 = 0;\n    let mut x62: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x61, &mut x62, x60, x39, x53);\n    let mut x63: u64 = 0;\n    let mut x64: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x63, &mut x64, x62, x41, x55);\n    let mut x65: u64 = 0;\n    let mut x66: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x65, &mut x66, x64, x43, x57);\n    let mut x67: u64 = 0;\n    let mut x68: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x67, &mut x68, x59, 0x8d64dbd30858d849);\n    let mut x69: u64 = 0;\n    let mut x70: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x69, &mut x70, x67, 0xffffffffffffffff);\n    let mut x71: u64 = 0;\n    let mut x72: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x71, &mut x72, x67, 0xffffffffffffffff);\n    let mut x73: u64 = 0;\n    let mut x74: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x73, &mut x74, x67, 0xd95c8ed60dfb4dfc);\n    let mut x75: u64 = 0;\n    let mut x76: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x75, &mut x76, x67, 0x7e5abf99263d6607);\n    let mut x77: u64 = 0;\n    let mut x78: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x77, &mut x78, 0x0, x76, x73);\n    let mut x79: u64 = 0;\n    let mut x80: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x79, &mut x80, x78, x74, x71);\n    let mut x81: u64 = 0;\n    let mut x82: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x81, &mut x82, x80, x72, x69);\n    let mut x83: u64 = 0;\n    let mut x84: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x83, &mut x84, 0x0, x59, x75);\n    let mut x85: u64 = 0;\n    let mut x86: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x85, &mut x86, x84, x61, x77);\n    let mut x87: u64 = 0;\n    let mut x88: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x87, &mut x88, x86, x63, x79);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x89, &mut x90, x88, x65, x81);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(\n        &mut x91,\n        &mut x92,\n        x90,\n        (((x66 as u64) + (x44 as u64)) + ((x58 as u64) + x46)),\n        ((x82 as u64) + x70),\n    );\n    let mut x93: u64 = 0;\n    let mut x94: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x93, &mut x94, x2, 0x5d4edf1c149a55b);\n    let mut x95: u64 = 0;\n    let mut x96: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x95, &mut x96, x2, 0x4a6925c6a269dbf8);\n    let mut x97: u64 = 0;\n    let mut x98: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x97, &mut x98, x2, 0x1b5a5bc108b44a10);\n    let mut x99: u64 = 0;\n    let mut x100: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x99, &mut x100, x2, 0xfa44af61dbff9431);\n    let mut x101: u64 = 0;\n    let mut x102: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x101, &mut x102, 0x0, x100, x97);\n    let mut x103: u64 = 0;\n    let mut x104: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x103, &mut x104, x102, x98, x95);\n    let mut x105: u64 = 0;\n    let mut x106: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x105, &mut x106, x104, x96, x93);\n    let mut x107: u64 = 0;\n    let mut x108: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x107, &mut x108, 0x0, x85, x99);\n    let mut x109: u64 = 0;\n    let mut x110: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x109, &mut x110, x108, x87, x101);\n    let mut x111: u64 = 0;\n    let mut x112: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x111, &mut x112, x110, x89, x103);\n    let mut x113: u64 = 0;\n    let mut x114: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x113, &mut x114, x112, x91, x105);\n    let mut x115: u64 = 0;\n    let mut x116: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x115, &mut x116, x107, 0x8d64dbd30858d849);\n    let mut x117: u64 = 0;\n    let mut x118: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x117, &mut x118, x115, 0xffffffffffffffff);\n    let mut x119: u64 = 0;\n    let mut x120: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x119, &mut x120, x115, 0xffffffffffffffff);\n    let mut x121: u64 = 0;\n    let mut x122: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x121, &mut x122, x115, 0xd95c8ed60dfb4dfc);\n    let mut x123: u64 = 0;\n    let mut x124: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x123, &mut x124, x115, 0x7e5abf99263d6607);\n    let mut x125: u64 = 0;\n    let mut x126: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x125, &mut x126, 0x0, x124, x121);\n    let mut x127: u64 = 0;\n    let mut x128: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x127, &mut x128, x126, x122, x119);\n    let mut x129: u64 = 0;\n    let mut x130: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x129, &mut x130, x128, x120, x117);\n    let mut x131: u64 = 0;\n    let mut x132: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x131, &mut x132, 0x0, x107, x123);\n    let mut x133: u64 = 0;\n    let mut x134: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x133, &mut x134, x132, x109, x125);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x135, &mut x136, x134, x111, x127);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x113, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(\n        &mut x139,\n        &mut x140,\n        x138,\n        (((x114 as u64) + (x92 as u64)) + ((x106 as u64) + x94)),\n        ((x130 as u64) + x118),\n    );\n    let mut x141: u64 = 0;\n    let mut x142: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x141, &mut x142, x3, 0x5d4edf1c149a55b);\n    let mut x143: u64 = 0;\n    let mut x144: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x143, &mut x144, x3, 0x4a6925c6a269dbf8);\n    let mut x145: u64 = 0;\n    let mut x146: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x145, &mut x146, x3, 0x1b5a5bc108b44a10);\n    let mut x147: u64 = 0;\n    let mut x148: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x147, &mut x148, x3, 0xfa44af61dbff9431);\n    let mut x149: u64 = 0;\n    let mut x150: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x149, &mut x150, 0x0, x148, x145);\n    let mut x151: u64 = 0;\n    let mut x152: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x151, &mut x152, x150, x146, x143);\n    let mut x153: u64 = 0;\n    let mut x154: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x153, &mut x154, x152, x144, x141);\n    let mut x155: u64 = 0;\n    let mut x156: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x155, &mut x156, 0x0, x133, x147);\n    let mut x157: u64 = 0;\n    let mut x158: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x157, &mut x158, x156, x135, x149);\n    let mut x159: u64 = 0;\n    let mut x160: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x159, &mut x160, x158, x137, x151);\n    let mut x161: u64 = 0;\n    let mut x162: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x161, &mut x162, x160, x139, x153);\n    let mut x163: u64 = 0;\n    let mut x164: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x163, &mut x164, x155, 0x8d64dbd30858d849);\n    let mut x165: u64 = 0;\n    let mut x166: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x165, &mut x166, x163, 0xffffffffffffffff);\n    let mut x167: u64 = 0;\n    let mut x168: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x167, &mut x168, x163, 0xffffffffffffffff);\n    let mut x169: u64 = 0;\n    let mut x170: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x169, &mut x170, x163, 0xd95c8ed60dfb4dfc);\n    let mut x171: u64 = 0;\n    let mut x172: u64 = 0;\n    fiat_bign256_scalar_mulx_u64(&mut x171, &mut x172, x163, 0x7e5abf99263d6607);\n    let mut x173: u64 = 0;\n    let mut x174: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x173, &mut x174, 0x0, x172, x169);\n    let mut x175: u64 = 0;\n    let mut x176: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x175, &mut x176, x174, x170, x167);\n    let mut x177: u64 = 0;\n    let mut x178: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x177, &mut x178, x176, x168, x165);\n    let mut x179: u64 = 0;\n    let mut x180: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x179, &mut x180, 0x0, x155, x171);\n    let mut x181: u64 = 0;\n    let mut x182: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x181, &mut x182, x180, x157, x173);\n    let mut x183: u64 = 0;\n    let mut x184: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x183, &mut x184, x182, x159, x175);\n    let mut x185: u64 = 0;\n    let mut x186: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(&mut x185, &mut x186, x184, x161, x177);\n    let mut x187: u64 = 0;\n    let mut x188: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_addcarryx_u64(\n        &mut x187,\n        &mut x188,\n        x186,\n        (((x162 as u64) + (x140 as u64)) + ((x154 as u64) + x142)),\n        ((x178 as u64) + x166),\n    );\n    let mut x189: u64 = 0;\n    let mut x190: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x189, &mut x190, 0x0, x181, 0x7e5abf99263d6607);\n    let mut x191: u64 = 0;\n    let mut x192: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x191, &mut x192, x190, x183, 0xd95c8ed60dfb4dfc);\n    let mut x193: u64 = 0;\n    let mut x194: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x193, &mut x194, x192, x185, 0xffffffffffffffff);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x195, &mut x196, x194, x187, 0xffffffffffffffff);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_bign256_scalar_u1 = 0;\n    fiat_bign256_scalar_subborrowx_u64(&mut x197, &mut x198, x196, (x188 as u64), (0x0 as u64));\n    let mut x199: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x199, x198, x189, x181);\n    let mut x200: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x200, x198, x191, x183);\n    let mut x201: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x201, x198, x193, x185);\n    let mut x202: u64 = 0;\n    fiat_bign256_scalar_cmovznz_u64(&mut x202, x198, x195, x187);\n    out1[0] = x199;\n    out1[1] = x200;\n    out1[2] = x201;\n    out1[3] = x202;\n}",
    "display_name": "fiat_bign256_scalar_to_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extensible",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn to_extensible(self) -> ExtensiblePoint {\n        ExtensiblePoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T1: self.x,\n            T2: self.y,\n        }\n    }",
    "display_name": "to_extensible",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/PreHasherXmd/new",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn new(hasher: HashT) -> Self {\n        Self { hasher }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes"
    ],
    "body": "    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        // NOTE: can't use ScalarPrimitive::random due to CryptoRng bound\n        let mut bytes = <FieldBytes>::default();\n\n        loop {\n            rng.try_fill_bytes(&mut bytes)?;\n            if let Some(fe) = Self::from_bytes(&bytes).into() {\n                return Ok(fe);\n            }\n        }\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p192_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/multiply"
    ],
    "body": "    fn mul(self, other: &Scalar) -> Scalar {\n        Scalar::multiply(&self, other)\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/edwards_isogeny",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/invert",
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_affine"
    ],
    "body": "    fn edwards_isogeny(&self, a: FieldElement) -> EdwardsExtendedPoint {\n        // Convert to affine now, then derive extended version later\n        let affine = self.to_affine();\n        let x = affine.x;\n        let y = affine.y;\n\n        // Compute x\n        let xy = x * y;\n        let x_numerator = xy + xy;\n        let x_denom = y.square() - (a * x.square());\n        let new_x = x_numerator * x_denom.invert();\n\n        // Compute y\n        let y_numerator = y.square() + (a * x.square());\n        let y_denom = (FieldElement::ONE + FieldElement::ONE) - y.square() - (a * x.square());\n        let new_y = y_numerator * y_denom.invert();\n\n        EdwardsExtendedPoint {\n            X: new_x,\n            Y: new_y,\n            Z: FieldElement::ONE,\n            T: new_x * new_y,\n        }\n    }",
    "display_name": "edwards_isogeny",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre encode_pkcs8_private_key_to_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_private_key_to_pem() {\n    let original_secret_key = sm2::SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let reencoded_secret_key = original_secret_key\n        .to_pkcs8_pem(Default::default())\n        .unwrap();\n    assert_eq!(reencoded_secret_key.as_str(), PKCS8_PRIVATE_KEY_PEM);\n}",
    "display_name": "encode_pkcs8_private_key_to_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/tests/pkcs8.rs",
    "relative_path": "sm2/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/PrehashVerifier/verify_prehash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/s0",
      "projective/impl/ProjectivePoint/Group/generator",
      "projective/impl/ProjectivePoint/Group/is_identity",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
      "0.14.0_pre ecdsa/impl/Signature/s1",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_u64",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes",
      "0.14.0_pre public_key/impl/PublicKey/to_projective",
      "projective/impl/ProjectivePoint/GroupEncoding/to_bytes"
    ],
    "body": "    fn verify_prehash(&self, prehash: &[u8], signature: &Signature) -> Result<()> {\n        // 1. If |𝑆| != 3𝑙, return NO.\n        if prehash.len() != <BignP256 as Curve>::FieldBytesSize::USIZE {\n            return Err(Error::new());\n        }\n        // 2. Assume 𝑆 as 𝑆 = 𝑆0 ‖ 𝑆1, где 𝑆0 ∈ {0, 1}^𝑙, 𝑆1 ∈ {0, 1}^2𝑙.\n        let s0 = signature.s0();\n        // 3. If 𝑆1 ⩾ 𝑞, return NO.\n        let s1 = signature.s1();\n\n        let mut hash: Array<u8, U32> = Array::clone_from_slice(prehash);\n        hash.reverse();\n\n        let hw = Scalar::reduce_bytes(FieldBytes::from_slice(&hash));\n        let left = s1.add(&hw);\n\n        let right = s0.add(&Scalar::from_u64(2).pow([128, 0, 0, 0]));\n\n        // 5. Set 𝑅 ← (︀(𝑆1 + 𝐻) mod 𝑞)︀𝐺 + (𝑆0 + 2𝑙)𝑄.\n        let r = ProjectivePoint::lincomb(&[\n            (ProjectivePoint::generator(), left),\n            (self.public_key.to_projective(), right),\n        ]);\n\n        // 6. If 𝑅 = 𝑂, return NO.\n        if r.is_identity().into() {\n            return Err(Error::new());\n        }\n\n        let mut r_bytes = r.to_bytes();\n        r_bytes.reverse();\n\n        let mut hasher = BeltHash::new();\n        hasher.update(BELT_OID);\n        hasher.update(&r_bytes[0..32]);\n        hasher.update(prehash);\n\n        // 7. Set 𝑡 ← ⟨︀belt-hash(OID(ℎ) ‖ ⟨𝑅⟩^2𝑙 ‖ 𝐻) ⟩︀^𝑙.\n        let t = hasher.finalize();\n\n        let s0 = &mut s0.to_bytes()[16..];\n        s0.reverse();\n\n        // 8. If 𝑆0 != 𝑡, return NO.\n        if s0 == &t.as_slice()[..16] {\n            // 9. Return YES.\n            Ok(())\n        } else {\n            Err(Error::new())\n        }\n    }",
    "display_name": "verify_prehash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/SharedSecret/new",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/AffineCoordinates/x"
    ],
    "body": "    fn new(point: AffinePoint) -> Self {\n        Self {\n            secret_bytes: point.x(),\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul"
    ],
    "body": "    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(Mul::mul).unwrap_or(Self::ONE)\n    }",
    "display_name": "product",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/primeorder::array::Array::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/to_repr"
    ],
    "body": "    fn from(scalar: Scalar) -> Self {\n        scalar.to_repr()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/is_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn is_zero(&self) -> Choice {\n        Self::ZERO.ct_eq(self)\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sub"
    ],
    "body": "    fn sub(self, rhs: FieldElement) -> FieldElement {\n        Self::sub(&self, &rhs)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_point_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn bench_point_mul<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let p = ProjectivePoint::GENERATOR;\n    let m = test_scalar_x();\n    let s = Scalar::from_repr(m.into()).unwrap();\n    group.bench_function(\"point-scalar mul\", |b| b.iter(|| p * s));\n}",
    "display_name": "bench_point_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/IsHigh/is_high",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_canonical",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_u64",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_hex",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert_unchecked"
    ],
    "body": "    fn is_high(&self) -> Choice {\n        const MODULUS_SHR1: U384 = NistP384::ORDER.shr_vartime(1);\n        self.to_canonical().ct_gt(&MODULUS_SHR1)\n    }",
    "display_name": "is_high",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_u64",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_uint_unchecked"
    ],
    "body": "    pub const fn from_u64(w: u64) -> Self {\n        Self::from_uint_unchecked(U576::from_u64(w))\n    }",
    "display_name": "from_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 test_scalar_y",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "fn test_scalar_y() -> Scalar {\n    Scalar::from_repr(\n        hex!(\"23d9f4ea6d87b7d6163d64256e3449255db14786401a51daa7847161bf56d494325ad2ac8ba928394e01061d882c3528\").into()\n    ).unwrap()\n}",
    "display_name": "test_scalar_y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p384_scalar_msat",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_scalar_msat(out1: &mut [u64; 7]) {\n    out1[0] = 0xecec196accc52973;\n    out1[1] = 0x581a0db248b0a77a;\n    out1[2] = 0xc7634d81f4372ddf;\n    out1[3] = 0xffffffffffffffff;\n    out1[4] = 0xffffffffffffffff;\n    out1[5] = 0xffffffffffffffff;\n    out1[6] = (0x0 as u64);\n}",
    "display_name": "fiat_p384_scalar_msat",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/new",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/new_with_mode"
    ],
    "body": "    pub fn new(secret_key: SecretKey) -> Self {\n        Self::new_with_mode(secret_key.to_nonzero_scalar(), Mode::C1C3C2)\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/square",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "fn bench_scalar_invert<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"invert\", |b| b.iter(|| black_box(x).invert()));\n}",
    "display_name": "bench_scalar_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_scalar_sub",
      "0.14.0_pre.8 bench_scalar_mul",
      "0.14.0_pre.8 bench_scalar_negate",
      "0.14.0_pre.8 bench_scalar_add",
      "0.14.0_pre.8 bench_scalar_invert"
    ],
    "body": "fn bench_scalar(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"scalar operations\");\n    bench_scalar_sub(&mut group);\n    bench_scalar_add(&mut group);\n    bench_scalar_mul(&mut group);\n    bench_scalar_negate(&mut group);\n    bench_scalar_invert(&mut group);\n    group.finish();\n}",
    "display_name": "bench_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/benches/scalar.rs",
    "relative_path": "k256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/KeypairBytes/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/to_bytes",
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/to_bytes",
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/verifying_key"
    ],
    "body": "    fn from(signing_key: &SigningKey) -> Self {\n        KeypairBytes {\n            secret_key: PointBytes::from(signing_key.to_bytes()),\n            verifying_key: Some(PointBytes::from(signing_key.verifying_key().to_bytes())),\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/pow_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/field_element",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/modulus_as_biguint",
      "0.14.0_pre.8 arithmetic/dev/bytes_to_biguint",
      "0.14.0_pre.8 arithmetic/field/tests/impl/FieldElement/From/from"
    ],
    "body": "        fn field_element()(bytes in any::<[u8; 32]>()) -> FieldElement {\n            let mut res = bytes_to_biguint(&bytes);\n            let m = FieldElement::modulus_as_biguint();\n            // Modulus is 256 bit long, same as the maximum `res`,\n            // so this is guaranteed to land us in the correct range.\n            if res >= m {\n                res -= m;\n            }\n            FieldElement::from(&res)\n        }",
    "display_name": "field_element",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/reduce"
    ],
    "body": "    fn reduce(w: U512) -> Self {\n        WideScalar(w).reduce()\n    }",
    "display_name": "reduce",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 affine_negation",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/PrimeCurveAffine/generator"
    ],
    "body": "fn affine_negation() {\n    let basepoint = AffinePoint::generator();\n    assert_eq!(-(-basepoint), basepoint);\n}",
    "display_name": "affine_negation",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(U448::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/edwards_isogeny",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine",
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/invert"
    ],
    "body": "    fn edwards_isogeny(&self, a: FieldElement) -> TwistedExtendedPoint {\n        // Convert to affine now, then derive extended version later\n        let affine = self.to_affine();\n        let x = affine.x;\n        let y = affine.y;\n\n        // Compute x\n        let xy = x * y;\n        let x_numerator = xy + xy;\n        let x_denom = y.square() - (a * x.square());\n        let new_x = x_numerator * x_denom.invert();\n\n        // Compute y\n        let y_numerator = y.square() + (a * x.square());\n        let y_denom = (FieldElement::ONE + FieldElement::ONE) - y.square() - (a * x.square());\n        let new_y = y_numerator * y_denom.invert();\n\n        TwistedExtendedPoint {\n            X: new_x,\n            Y: new_y,\n            Z: FieldElement::ONE,\n            T: new_x * new_y,\n        }\n    }",
    "display_name": "edwards_isogeny",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/ToEncodedPoint/to_encoded_point",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point",
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/as_affine"
    ],
    "body": "    fn to_encoded_point(&self, compress: bool) -> EncodedPoint {\n        self.as_affine().to_encoded_point(compress)\n    }",
    "display_name": "to_encoded_point",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &[u8] {\n        &self.0[..]\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt"
    ],
    "body": "    fn sqrt(&self) -> CtOption<Self> {\n        self.sqrt()\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre pke/decrypting/impl/DecryptingKey/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/decrypting/impl/DecryptingKey/encrypting_key"
    ],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"DecryptingKey\")\n            .field(\"private_key\", &self.secret_scalar.as_ref())\n            .field(\"encrypting_key\", &self.encrypting_key())\n            .finish_non_exhaustive()\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/decrypting.rs",
    "relative_path": "sm2/src/pke/decrypting.rs",
    "file_name": "decrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "affine/impl/AffinePoint/AffineCoordinates/y",
    "statement_type": "function",
    "deps": [],
    "body": "    fn y(&self) -> FieldBytes<C> {\n        self.y.to_repr()\n    }",
    "display_name": "y",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from(n: u32) -> Scalar {\n        Self::from_uint_unchecked(U576::from(n))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/affine/impl/&AffinePoint/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, scalar: Scalar) -> DecafPoint {\n        self * &scalar\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/affine.rs",
    "relative_path": "ed448-goldilocks/src/decaf/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint"
    ],
    "body": "    pub fn from_bytes(repr: &FieldBytes) -> CtOption<Self> {\n        Self::from_uint(FieldBytesEncoding::<NistP521>::decode_field_bytes(repr))\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    fn from_repr(bytes: FieldBytes) -> CtOption<Self> {\n        Self::from_bytes(&bytes)\n    }",
    "display_name": "from_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr"
    ],
    "body": "    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        // Uses rejection sampling as the default random generation method,\n        // which produces a uniformly random distribution of scalars.\n        //\n        // This method is not constant time, but should be secure so long as\n        // rejected RNG outputs are unrelated to future ones (which is a\n        // necessary property of a `CryptoRng`).\n        //\n        // With an unbiased RNG, the probability of failing to complete after 4\n        // iterations is vanishingly small.\n        let mut bytes = FieldBytes::default();\n\n        // TODO: pre-generate several scalars to bring the probability of non-constant-timeness down?\n        loop {\n            rng.try_fill_bytes(&mut bytes)?;\n            if let Some(scalar) = Scalar::from_repr(bytes).into() {\n                return Ok(scalar);\n            }\n        }\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/top_half",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/bot_half"
    ],
    "body": "        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }",
    "display_name": "top_half",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p224_scalar_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: &AffinePoint) -> ProjectivePoint {\n        *rhs * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/to_canonical",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_canonical",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "projective/impl/PublicKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/From>/from"
    ],
    "body": "    fn try_from(point: ProjectivePoint<C>) -> Result<PublicKey<C>> {\n        AffinePoint::<C>::from(point).try_into()\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/impl/fiat_p192_scalar_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "relative_path": "p192/src/arithmetic/scalar/p192_scalar_64.rs",
    "file_name": "p192_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {\n        NonZeroScalar::try_from(bytes)\n            .map(Into::into)\n            .map_err(|_| Error::new())\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/shr_vartime",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/into_limbs"
    ],
    "body": "    pub const fn shr_vartime(&self, shift: u32) -> Scalar {\n        Self(fiat_p521_scalar_montgomery_domain_field_element(\n            U576::from_words(self.into_limbs())\n                .wrapping_shr_vartime(shift)\n                .to_words(),\n        ))\n    }",
    "display_name": "shr_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/try_from_rng",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_bytes"
    ],
    "body": "    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> core::result::Result<Self, R::Error> {\n        // NOTE: can't use ScalarPrimitive::random due to CryptoRng bound\n        let mut bytes = <FieldBytes>::default();\n\n        loop {\n            rng.try_fill_bytes(&mut bytes)?;\n            if let Some(fe) = Self::from_bytes(&bytes).into() {\n                return Ok(fe);\n            }\n        }\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &fiat_p521_scalar_montgomery_domain_field_element {\n        &self.0\n    }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p192_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p192_nonzero(out1: &mut u64, arg1: &[u64; 3]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | (arg1[2])));\n    *out1 = x1;\n}",
    "display_name": "fiat_p192_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field/p192_64.rs",
    "relative_path": "p192/src/arithmetic/field/p192_64.rs",
    "file_name": "p192_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sqrt",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn sqrt(&self) -> CtOption<Self> {\n        todo!(\"`sqrt` not yet implemented\")\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/field.rs",
    "relative_path": "p256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_set_one",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_sm2_set_one(out1: &mut fiat_sm2_montgomery_domain_field_element) {\n    let out1 = &mut out1.0;\n    out1[0] = (0x1 as u64);\n    out1[1] = 0xffffffff;\n    out1[2] = (0x0 as u64);\n    out1[3] = 0x100000000;\n}",
    "display_name": "fiat_sm2_set_one",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_y",
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_sub<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"sub\", |b| b.iter(|| x - y));\n}",
    "display_name": "bench_scalar_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/hash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/isogeny",
      "0.14.0_pre.1 field/element/impl/FieldElement/map_to_curve_elligator2",
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/double",
      "0.14.0_pre.1 field/element/impl/FieldElement/FromOkm/from_okm"
    ],
    "body": "    pub fn hash<X>(msg: &[u8], dst: &[u8]) -> Self\n    where\n        X: ExpandMsg<U28>,\n    {\n        type RandomLen = U84;\n        let mut random_bytes = Array::<u8, RandomLen>::default();\n        let dst = [dst];\n        let mut expander = X::expand_message(\n            &[msg],\n            &dst,\n            core::num::NonZero::new(RandomLen::U16 * 2)\n                .expect(\"invariant violation: random is non zero length\"),\n        )\n        .expect(\"bad dst\");\n        expander.fill_bytes(&mut random_bytes);\n        let u0 = FieldElement::from_okm(&random_bytes);\n        expander.fill_bytes(&mut random_bytes);\n        let u1 = FieldElement::from_okm(&random_bytes);\n        let mut q0 = u0.map_to_curve_elligator2();\n        let mut q1 = u1.map_to_curve_elligator2();\n        q0 = q0.isogeny();\n        q1 = q1.isogeny();\n\n        (q0.to_edwards() + q1.to_edwards()).double().double()\n    }",
    "display_name": "hash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 encode_pkcs8_private_key_to_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_private_key_to_pem() {\n    let original_secret_key = p256::SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let reencoded_secret_key = original_secret_key\n        .to_pkcs8_pem(Default::default())\n        .unwrap();\n    assert_eq!(reencoded_secret_key.as_str(), PKCS8_PRIVATE_KEY_PEM);\n}",
    "display_name": "encode_pkcs8_private_key_to_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/pkcs8.rs",
    "relative_path": "p256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_cmovznz_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_p224_subborrowx_u64"
    ],
    "body": "pub const fn fiat_p224_add(\n    out1: &mut fiat_p224_montgomery_domain_field_element,\n    arg1: &fiat_p224_montgomery_domain_field_element,\n    arg2: &fiat_p224_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p224_u1 = 0;\n    fiat_p224_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x9, &mut x10, 0x0, x1, (0x1 as u64));\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x11, &mut x12, x10, x3, 0xffffffff00000000);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x13, &mut x14, x12, x5, 0xffffffffffffffff);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x15, &mut x16, x14, x7, 0xffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p224_u1 = 0;\n    fiat_p224_subborrowx_u64(&mut x17, &mut x18, x16, (x8 as u64), (0x0 as u64));\n    let mut x19: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x19, x18, x9, x1);\n    let mut x20: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x20, x18, x11, x3);\n    let mut x21: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x21, x18, x13, x5);\n    let mut x22: u64 = 0;\n    fiat_p224_cmovznz_u64(&mut x22, x18, x15, x7);\n    out1[0] = x19;\n    out1[1] = x20;\n    out1[2] = x21;\n    out1[3] = x22;\n}",
    "display_name": "fiat_p224_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre pke/zero_pad_byte_slice",
    "statement_type": "function",
    "deps": [],
    "body": "pub(crate) fn zero_pad_byte_slice<const N: usize>(\n    bytes: &[u8],\n) -> elliptic_curve::pkcs8::der::Result<[u8; N]> {\n    let num_zeroes = N\n        .checked_sub(bytes.len())\n        .ok_or_else(|| Tag::Integer.length_error())?;\n\n    // Copy input into `N`-sized output buffer with leading zeroes\n    let mut output = [0u8; N];\n    output[num_zeroes..].copy_from_slice(bytes);\n    Ok(output)\n}",
    "display_name": "zero_pad_byte_slice",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke.rs",
    "relative_path": "sm2/src/pke.rs",
    "file_name": "pke.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/to_sec1_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_sec1_bytes(&self) -> Box<[u8]> {\n        self.public_key.to_sec1_bytes()\n    }",
    "display_name": "to_sec1_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_uint_unchecked(uint: U448) -> Self {\n        Self(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "primefield::field_op!(Scalar, Add, add, add);\nprimefield::field_op!(Scalar, Sub, sub, sub);\nprimefield::field_op!(Scalar, Mul, mul, multiply);\nelliptic_curve::scalar_impls!(NistP521, Scalar);\n\nimpl AddAssign<Scalar> for Scalar {\n    #[inline]\n    fn add_assign(&mut self, other: Scalar) {\n        *self = *self + other;\n    }\n}",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/SharedSecret/extract",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn extract(&self, salt: Option<&[u8]>) -> Hkdf<BeltHash, SimpleHmac<BeltHash>> {\n        Hkdf::new(salt, &self.secret_bytes)\n    }",
    "display_name": "extract",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/wide/impl/WideScalar/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn from_bytes(bytes: &[u8; 64]) -> Self {\n        Self(U512::from_be_slice(bytes))\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar/wide64.rs",
    "relative_path": "k256/src/arithmetic/scalar/wide64.rs",
    "file_name": "wide64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/Vec/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(compressed: &CompressedDecaf) -> Vec<u8> {\n        compressed.0.to_vec()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, point: &DecafPoint) -> DecafPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add_assign(&mut self, rhs: Scalar) {\n        *self = Scalar::add(self, &rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "conditional_select",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/&FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/relax",
      "0.14.0_pre.8 arithmetic/field/loose/impl/LooseFieldElement/Mul/mul"
    ],
    "body": "    fn mul(self, rhs: &FieldElement) -> FieldElement {\n        self.relax().mul(&rhs.relax())\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/pow_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field.rs",
    "relative_path": "sm2/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sub_loose",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_sub"
    ],
    "body": "    pub const fn sub_loose(&self, rhs: &Self) -> LooseFieldElement {\n        let mut out = fiat_p521_loose_field_element([0; 9]);\n        fiat_p521_sub(&mut out, &self.0, &rhs.0);\n        LooseFieldElement(out)\n    }",
    "display_name": "sub_loose",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "    fn reduce_nonzero(w: U256) -> Self {\n        const ORDER_MINUS_ONE: U256 = NistP256::ORDER.wrapping_sub(&U256::ONE);\n        let (r, underflow) = w.borrowing_sub(&ORDER_MINUS_ONE, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self(U256::conditional_select(&w, &r, !underflow).wrapping_add(&U256::ONE))\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_add"
    ],
    "body": "    pub const fn add(&self, rhs: &Self) -> Self {\n        let mut out = fiat_p521_scalar_montgomery_domain_field_element([0; 9]);\n        fiat_p521_scalar_add(&mut out, &self.0, &rhs.0);\n        Self(out)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 ristretto/points/impl/CompressedRistretto/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &[u8] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/ristretto/points.rs",
    "relative_path": "ed448-goldilocks/src/ristretto/points.rs",
    "file_name": "points.rs",
    "parent_folder": "ristretto"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/elliptic_curve::array::Array::FieldBytesSize>/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn from(scalar: Scalar) -> Self {\n        scalar.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(k: u64) -> Self {\n        Scalar(k.into())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from_uint_unchecked(uint: Self::Uint) -> Self {\n        Self::from_uint_unchecked(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/test_vector_scalar_mult",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/PrimeField/from_repr",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_vector_scalar_mult() {\n        let generator = ProjectivePoint::GENERATOR;\n\n        for (k, coords) in ADD_TEST_VECTORS\n            .iter()\n            .enumerate()\n            .map(|(k, coords)| (Scalar::from(k as u32 + 1), *coords))\n            .chain(\n                MUL_TEST_VECTORS\n                    .iter()\n                    .cloned()\n                    .map(|(k, x, y)| (Scalar::from_repr(k.into()).unwrap(), (x, y))),\n            )\n        {\n            let res = (generator * &k).to_affine();\n            assert_eq!(res.x.to_bytes(), coords.0);\n            assert_eq!(res.y.to_bytes(), coords.1);\n        }\n    }",
    "display_name": "test_vector_scalar_mult",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/hash_msg",
      "0.14.0_pre ecdsa/verifying/impl/VerifyingKey/PrehashVerifier/verify_prehash"
    ],
    "body": "    fn multipart_verify(&self, msg: &[&[u8]], signature: &Signature) -> Result<()> {\n        // 4. Set 𝐻 ← ℎ(𝑋).\n        let hash = self.hash_msg(msg);\n        self.verify_prehash(&hash, signature)\n    }",
    "display_name": "multipart_verify",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa/verifying.rs",
    "relative_path": "bign256/src/ecdsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "ecdsa"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/random",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        NonZeroScalar::random(rng).into()\n    }",
    "display_name": "random",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre ecdh/impl/EphemeralSecret/Drop/drop",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdh/impl/EphemeralSecret/Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        self.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdh.rs",
    "relative_path": "bign256/src/ecdh.rs",
    "file_name": "ecdh.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/impl/InnerSignature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/impl/InnerSignature/TryFrom/try_from"
    ],
    "body": "    fn try_from(signature: Signature) -> Result<Self, Self::Error> {\n        Self::try_from(&signature)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign.rs",
    "relative_path": "ed448-goldilocks/src/sign.rs",
    "file_name": "sign.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "fn bench_scalar_invert<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    group.bench_function(\"invert\", |b| b.iter(|| x.invert()));\n}",
    "display_name": "bench_scalar_invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_y",
      "0.14.0_pre.8 test_scalar_x"
    ],
    "body": "fn bench_scalar_add<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"add\", |b| b.iter(|| x + y));\n}",
    "display_name": "bench_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/benches/scalar.rs",
    "relative_path": "p256/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "projective/impl/&ProjectivePoint/Add/add",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add(self, other: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::add(self, other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/unnormalized_is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/from_bytes_unchecked"
    ],
    "body": "    fn unnormalized_is_odd() {\n        // This is a regression test for https://github.com/RustCrypto/elliptic-curves/issues/529\n        // where `is_odd()` in debug mode force-normalized its argument\n        // instead of checking that it is already normalized.\n        // As a result, in release (where normalization didn't happen) `is_odd()`\n        // could return an incorrect value.\n\n        let x = FieldElement::from_bytes_unchecked(&[\n            61, 128, 156, 189, 241, 12, 174, 4, 80, 52, 238, 78, 188, 251, 9, 188, 95, 115, 38, 6,\n            212, 168, 175, 174, 211, 232, 208, 14, 182, 45, 59, 122,\n        ]);\n        // Produces an unnormalized FieldElement with magnitude 1\n        // (we cannot create one directly).\n        let y = x.sqrt().unwrap();\n\n        // This is fine.\n        assert!(y.normalize().is_odd().unwrap_u8() == 0);\n\n        // This panics since `y` is not normalized.\n        let _result = y.is_odd();\n    }",
    "display_name": "unnormalized_is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/elliptic_curve::PublicKey/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(verifying_key: &VerifyingKey) -> PublicKey {\n        verifying_key.public_key\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Field/is_zero",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn is_zero(&self) -> Choice {\n        Self::ZERO.ct_eq(self)\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field.rs",
    "relative_path": "p521/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/PrehashVerifier/verify_prehash",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/s",
      "affine/impl/AffinePoint/AffineCoordinates/x",
      "projective/impl/ProjectivePoint/Group/generator",
      "projective/impl/ProjectivePoint/to_affine",
      "0.14.0_pre arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
      "projective/impl/ProjectivePoint/From>/from",
      "0.14.0_pre dsa/impl/Signature/r"
    ],
    "body": "    fn verify_prehash(&self, prehash: &[u8], signature: &Signature) -> Result<()> {\n        if prehash.len() != <Sm2 as Curve>::FieldBytesSize::USIZE {\n            return Err(Error::new());\n        }\n\n        // B1: verify whether r' in [1,n-1], verification failed if not\n        let r = signature.r(); // NonZeroScalar checked at signature parse time\n\n        // B2: verify whether s' in [1,n-1], verification failed if not\n        let s = signature.s(); // NonZeroScalar checked at signature parse time\n\n        // B4: calculate e'=Hv(M'~)\n        #[allow(deprecated)] // from_slice\n        let e = Scalar::reduce_bytes(FieldBytes::from_slice(prehash));\n\n        // B5: calculate t = (r' + s') modn, verification failed if t=0\n        let t = *r + *s;\n        if t.is_zero().into() {\n            return Err(Error::new());\n        }\n\n        // B6: calculate the point (x1', y1')=[s']G + [t]PA\n        let x = ProjectivePoint::lincomb(&[\n            (ProjectivePoint::generator(), *s),\n            (ProjectivePoint::from(&self.public_key), t),\n        ])\n        .to_affine()\n        .x();\n\n        // B7: calculate R=(e'+x1') modn, verification pass if yes, otherwise failed\n        if *r == e + Scalar::reduce_bytes(&x) {\n            Ok(())\n        } else {\n            Err(Error::new())\n        }\n    }",
    "display_name": "verify_prehash",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/FromUintUnchecked/from_uint_unchecked",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/from_uint_unchecked"
    ],
    "body": "    fn from_uint_unchecked(uint: Self::Uint) -> Self {\n        Self::from_uint_unchecked(uint)\n    }",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/hash_with_defaults",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/hash"
    ],
    "body": "    pub fn hash_with_defaults(msg: &[u8]) -> Self {\n        Self::hash::<ExpandMsgXof<sha3::Shake256>>(msg, DEFAULT_HASH_TO_CURVE_SUITE)\n    }",
    "display_name": "hash_with_defaults",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/is_zero",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_zero(&self) -> Choice {\n        Choice::from(((self.0[0] | self.0[1] | self.0[2] | self.0[3] | self.0[4]) == 0) as u8)\n    }",
    "display_name": "is_zero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_5x52.rs",
    "relative_path": "k256/src/arithmetic/field/field_5x52.rs",
    "file_name": "field_5x52.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/impl/Scalar/ToBigUint/to_biguint",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/dev/bytes_to_biguint",
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "        fn to_biguint(&self) -> Option<BigUint> {\n            Some(bytes_to_biguint(self.to_bytes().as_ref()))\n        }",
    "display_name": "to_biguint",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/pow_vartime",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow_vartime",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/field.rs",
    "relative_path": "bign256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/impl/fiat_sm2_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\n        write!(\n            f,\n            \"{{ X: {}, Y: {}, Z: {}, T: {} }}\",\n            self.X, self.Y, self.Z, self.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/verifying_key/impl/VerifyingKey/from_bytes",
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/From, elliptic_curve::consts::B1>, elliptic_curve::consts::B1>, elliptic_curve::co",
      "0.14.0_pre.1 sign/signing_key/impl/SigningKey/verifying_key"
    ],
    "body": "    fn try_from(value: &KeypairBytes) -> Result<Self, Self::Error> {\n        let signing_key =\n            SigningKey::from(SecretKey::try_from(&value.secret_key[..]).expect(\"invalid length\"));\n\n        if let Some(public_bytes) = value.verifying_key {\n            let verifying_key =\n                VerifyingKey::from_bytes(&public_bytes).map_err(|_| pkcs8::Error::KeyMalformed)?;\n            if signing_key.verifying_key() != verifying_key {\n                return Err(pkcs8::Error::KeyMalformed);\n            }\n        }\n        Ok(signing_key)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/impl/fiat_p384_scalar_non_montgomery_domain_field_element/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, index: usize) -> &Self::Output {\n        &self.0[index]\n    }",
    "display_name": "index",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "relative_path": "p384/src/arithmetic/scalar/p384_scalar_64.rs",
    "file_name": "p384_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes"
    ],
    "body": "        fn scalar()(bytes in any::<[u8; 32]>()) -> Scalar {\n            <Scalar as Reduce<U256>>::reduce_bytes(&bytes.into())\n        }",
    "display_name": "scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/to_untwisted",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/edwards_isogeny"
    ],
    "body": "    pub fn to_untwisted(self) -> EdwardsExtendedPoint {\n        self.edwards_isogeny(FieldElement::MINUS_ONE)\n    }",
    "display_name": "to_untwisted",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.8 impl/primefield::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        self.to_be_byte_array()\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/lib.rs",
    "relative_path": "p256/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/verify_raw",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/mul/impl/ProjectivePoint/LinearCombination/lincomb",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 schnorr/impl/Signature/split",
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/to_bytes",
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/is_identity",
      "0.14.0_pre.8 schnorr/tagged_hash",
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/to_affine"
    ],
    "body": "    pub fn verify_raw(\n        &self,\n        message: &[u8],\n        signature: &Signature,\n    ) -> core::result::Result<(), Error> {\n        let (r, s) = signature.split();\n\n        let e = <Scalar as Reduce<U256>>::reduce_bytes(\n            &tagged_hash(CHALLENGE_TAG)\n                .chain_update(signature.r.to_bytes())\n                .chain_update(self.to_bytes())\n                .chain_update(message)\n                .finalize(),\n        );\n\n        let R = ProjectivePoint::lincomb(&[\n            (ProjectivePoint::GENERATOR, **s),\n            (self.inner.to_projective(), -e),\n        ])\n        .to_affine();\n\n        if R.is_identity().into() || R.y.normalize().is_odd().into() || R.x.normalize() != *r {\n            return Err(Error::new());\n        }\n\n        Ok(())\n    }",
    "display_name": "verify_raw",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    pub const fn double(&self) -> Self {\n        self.add(self)\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/SigningKey/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.secret.seed.ct_eq(&other.secret.seed)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/elliptic_curve::bigint::Uint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/elliptic_curve::bigint::Uint/From/from"
    ],
    "body": "    fn from(scalar: &Scalar) -> Self {\n        Self::from(*scalar)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: AffinePoint) -> EdwardsPoint {\n        self * &rhs\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_from_montgomery",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_addcarryx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_subborrowx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_mulx_u64",
      "0.14.0_pre.8 arithmetic/scalar/scalar_impl/fiat_p521_scalar_cmovznz_u64"
    ],
    "body": "pub const fn fiat_p521_scalar_from_montgomery(\n    out1: &mut fiat_p521_scalar_non_montgomery_domain_field_element,\n    arg1: &fiat_p521_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let x1: u64 = (arg1[0]);\n    let mut x2: u64 = 0;\n    let mut x3: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x2, &mut x3, x1, 0x1d2f5ccd79a995c7);\n    let mut x4: u64 = 0;\n    let mut x5: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x4, &mut x5, x2, 0x1ff);\n    let mut x6: u64 = 0;\n    let mut x7: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x6, &mut x7, x2, 0xffffffffffffffff);\n    let mut x8: u64 = 0;\n    let mut x9: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x8, &mut x9, x2, 0xffffffffffffffff);\n    let mut x10: u64 = 0;\n    let mut x11: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x10, &mut x11, x2, 0xffffffffffffffff);\n    let mut x12: u64 = 0;\n    let mut x13: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x12, &mut x13, x2, 0xfffffffffffffffa);\n    let mut x14: u64 = 0;\n    let mut x15: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x14, &mut x15, x2, 0x51868783bf2f966b);\n    let mut x16: u64 = 0;\n    let mut x17: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x16, &mut x17, x2, 0x7fcc0148f709a5d0);\n    let mut x18: u64 = 0;\n    let mut x19: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x18, &mut x19, x2, 0x3bb5c9b8899c47ae);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x20, &mut x21, x2, 0xbb6fb71e91386409);\n    let mut x22: u64 = 0;\n    let mut x23: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x22, &mut x23, 0x0, x21, x18);\n    let mut x24: u64 = 0;\n    let mut x25: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x24, &mut x25, x23, x19, x16);\n    let mut x26: u64 = 0;\n    let mut x27: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x26, &mut x27, x25, x17, x14);\n    let mut x28: u64 = 0;\n    let mut x29: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x28, &mut x29, x27, x15, x12);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x30, &mut x31, x29, x13, x10);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x11, x8);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x9, x6);\n    let mut x36: u64 = 0;\n    let mut x37: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x36, &mut x37, x35, x7, x4);\n    let mut x38: u64 = 0;\n    let mut x39: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x38, &mut x39, 0x0, x1, x20);\n    let mut x40: u64 = 0;\n    let mut x41: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x40, &mut x41, x39, (0x0 as u64), x22);\n    let mut x42: u64 = 0;\n    let mut x43: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x42, &mut x43, x41, (0x0 as u64), x24);\n    let mut x44: u64 = 0;\n    let mut x45: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x44, &mut x45, x43, (0x0 as u64), x26);\n    let mut x46: u64 = 0;\n    let mut x47: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x46, &mut x47, x45, (0x0 as u64), x28);\n    let mut x48: u64 = 0;\n    let mut x49: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x48, &mut x49, x47, (0x0 as u64), x30);\n    let mut x50: u64 = 0;\n    let mut x51: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x50, &mut x51, x49, (0x0 as u64), x32);\n    let mut x52: u64 = 0;\n    let mut x53: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x52, &mut x53, x51, (0x0 as u64), x34);\n    let mut x54: u64 = 0;\n    let mut x55: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x54, &mut x55, x53, (0x0 as u64), x36);\n    let mut x56: u64 = 0;\n    let mut x57: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x56, &mut x57, 0x0, x40, (arg1[1]));\n    let mut x58: u64 = 0;\n    let mut x59: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x58, &mut x59, x57, x42, (0x0 as u64));\n    let mut x60: u64 = 0;\n    let mut x61: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x60, &mut x61, x59, x44, (0x0 as u64));\n    let mut x62: u64 = 0;\n    let mut x63: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x62, &mut x63, x61, x46, (0x0 as u64));\n    let mut x64: u64 = 0;\n    let mut x65: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x48, (0x0 as u64));\n    let mut x66: u64 = 0;\n    let mut x67: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x50, (0x0 as u64));\n    let mut x68: u64 = 0;\n    let mut x69: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x52, (0x0 as u64));\n    let mut x70: u64 = 0;\n    let mut x71: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x70, &mut x71, x69, x54, (0x0 as u64));\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x72, &mut x73, x56, 0x1d2f5ccd79a995c7);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x74, &mut x75, x72, 0x1ff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x78, &mut x79, x72, 0xffffffffffffffff);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x80, &mut x81, x72, 0xffffffffffffffff);\n    let mut x82: u64 = 0;\n    let mut x83: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x82, &mut x83, x72, 0xfffffffffffffffa);\n    let mut x84: u64 = 0;\n    let mut x85: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x84, &mut x85, x72, 0x51868783bf2f966b);\n    let mut x86: u64 = 0;\n    let mut x87: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x86, &mut x87, x72, 0x7fcc0148f709a5d0);\n    let mut x88: u64 = 0;\n    let mut x89: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x88, &mut x89, x72, 0x3bb5c9b8899c47ae);\n    let mut x90: u64 = 0;\n    let mut x91: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x90, &mut x91, x72, 0xbb6fb71e91386409);\n    let mut x92: u64 = 0;\n    let mut x93: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x92, &mut x93, 0x0, x91, x88);\n    let mut x94: u64 = 0;\n    let mut x95: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x94, &mut x95, x93, x89, x86);\n    let mut x96: u64 = 0;\n    let mut x97: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x96, &mut x97, x95, x87, x84);\n    let mut x98: u64 = 0;\n    let mut x99: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x98, &mut x99, x97, x85, x82);\n    let mut x100: u64 = 0;\n    let mut x101: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x100, &mut x101, x99, x83, x80);\n    let mut x102: u64 = 0;\n    let mut x103: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x102, &mut x103, x101, x81, x78);\n    let mut x104: u64 = 0;\n    let mut x105: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x104, &mut x105, x103, x79, x76);\n    let mut x106: u64 = 0;\n    let mut x107: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x106, &mut x107, x105, x77, x74);\n    let mut x108: u64 = 0;\n    let mut x109: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x56, x90);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x58, x92);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x60, x94);\n    let mut x114: u64 = 0;\n    let mut x115: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x114, &mut x115, x113, x62, x96);\n    let mut x116: u64 = 0;\n    let mut x117: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x116, &mut x117, x115, x64, x98);\n    let mut x118: u64 = 0;\n    let mut x119: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x118, &mut x119, x117, x66, x100);\n    let mut x120: u64 = 0;\n    let mut x121: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x120, &mut x121, x119, x68, x102);\n    let mut x122: u64 = 0;\n    let mut x123: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x122, &mut x123, x121, x70, x104);\n    let mut x124: u64 = 0;\n    let mut x125: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x124,\n        &mut x125,\n        x123,\n        ((x71 as u64) + ((x55 as u64) + ((x37 as u64) + x5))),\n        x106,\n    );\n    let mut x126: u64 = 0;\n    let mut x127: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x126, &mut x127, 0x0, x110, (arg1[2]));\n    let mut x128: u64 = 0;\n    let mut x129: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x128, &mut x129, x127, x112, (0x0 as u64));\n    let mut x130: u64 = 0;\n    let mut x131: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x130, &mut x131, x129, x114, (0x0 as u64));\n    let mut x132: u64 = 0;\n    let mut x133: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x132, &mut x133, x131, x116, (0x0 as u64));\n    let mut x134: u64 = 0;\n    let mut x135: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x134, &mut x135, x133, x118, (0x0 as u64));\n    let mut x136: u64 = 0;\n    let mut x137: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x136, &mut x137, x135, x120, (0x0 as u64));\n    let mut x138: u64 = 0;\n    let mut x139: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x138, &mut x139, x137, x122, (0x0 as u64));\n    let mut x140: u64 = 0;\n    let mut x141: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x140, &mut x141, x139, x124, (0x0 as u64));\n    let mut x142: u64 = 0;\n    let mut x143: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x142, &mut x143, x126, 0x1d2f5ccd79a995c7);\n    let mut x144: u64 = 0;\n    let mut x145: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x144, &mut x145, x142, 0x1ff);\n    let mut x146: u64 = 0;\n    let mut x147: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x146, &mut x147, x142, 0xffffffffffffffff);\n    let mut x148: u64 = 0;\n    let mut x149: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x148, &mut x149, x142, 0xffffffffffffffff);\n    let mut x150: u64 = 0;\n    let mut x151: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x150, &mut x151, x142, 0xffffffffffffffff);\n    let mut x152: u64 = 0;\n    let mut x153: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x152, &mut x153, x142, 0xfffffffffffffffa);\n    let mut x154: u64 = 0;\n    let mut x155: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x154, &mut x155, x142, 0x51868783bf2f966b);\n    let mut x156: u64 = 0;\n    let mut x157: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x156, &mut x157, x142, 0x7fcc0148f709a5d0);\n    let mut x158: u64 = 0;\n    let mut x159: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x158, &mut x159, x142, 0x3bb5c9b8899c47ae);\n    let mut x160: u64 = 0;\n    let mut x161: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x160, &mut x161, x142, 0xbb6fb71e91386409);\n    let mut x162: u64 = 0;\n    let mut x163: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x162, &mut x163, 0x0, x161, x158);\n    let mut x164: u64 = 0;\n    let mut x165: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x164, &mut x165, x163, x159, x156);\n    let mut x166: u64 = 0;\n    let mut x167: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x166, &mut x167, x165, x157, x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x168, &mut x169, x167, x155, x152);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x153, x150);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x151, x148);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x149, x146);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x147, x144);\n    let mut x178: u64 = 0;\n    let mut x179: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x178, &mut x179, 0x0, x126, x160);\n    let mut x180: u64 = 0;\n    let mut x181: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x180, &mut x181, x179, x128, x162);\n    let mut x182: u64 = 0;\n    let mut x183: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x182, &mut x183, x181, x130, x164);\n    let mut x184: u64 = 0;\n    let mut x185: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x184, &mut x185, x183, x132, x166);\n    let mut x186: u64 = 0;\n    let mut x187: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x186, &mut x187, x185, x134, x168);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x188, &mut x189, x187, x136, x170);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x190, &mut x191, x189, x138, x172);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x140, x174);\n    let mut x194: u64 = 0;\n    let mut x195: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x194,\n        &mut x195,\n        x193,\n        ((x141 as u64) + ((x125 as u64) + ((x107 as u64) + x75))),\n        x176,\n    );\n    let mut x196: u64 = 0;\n    let mut x197: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x196, &mut x197, 0x0, x180, (arg1[3]));\n    let mut x198: u64 = 0;\n    let mut x199: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x198, &mut x199, x197, x182, (0x0 as u64));\n    let mut x200: u64 = 0;\n    let mut x201: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x200, &mut x201, x199, x184, (0x0 as u64));\n    let mut x202: u64 = 0;\n    let mut x203: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x202, &mut x203, x201, x186, (0x0 as u64));\n    let mut x204: u64 = 0;\n    let mut x205: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x204, &mut x205, x203, x188, (0x0 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x206, &mut x207, x205, x190, (0x0 as u64));\n    let mut x208: u64 = 0;\n    let mut x209: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x208, &mut x209, x207, x192, (0x0 as u64));\n    let mut x210: u64 = 0;\n    let mut x211: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x210, &mut x211, x209, x194, (0x0 as u64));\n    let mut x212: u64 = 0;\n    let mut x213: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x212, &mut x213, x196, 0x1d2f5ccd79a995c7);\n    let mut x214: u64 = 0;\n    let mut x215: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x214, &mut x215, x212, 0x1ff);\n    let mut x216: u64 = 0;\n    let mut x217: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x216, &mut x217, x212, 0xffffffffffffffff);\n    let mut x218: u64 = 0;\n    let mut x219: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x218, &mut x219, x212, 0xffffffffffffffff);\n    let mut x220: u64 = 0;\n    let mut x221: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x220, &mut x221, x212, 0xffffffffffffffff);\n    let mut x222: u64 = 0;\n    let mut x223: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x222, &mut x223, x212, 0xfffffffffffffffa);\n    let mut x224: u64 = 0;\n    let mut x225: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x224, &mut x225, x212, 0x51868783bf2f966b);\n    let mut x226: u64 = 0;\n    let mut x227: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x226, &mut x227, x212, 0x7fcc0148f709a5d0);\n    let mut x228: u64 = 0;\n    let mut x229: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x228, &mut x229, x212, 0x3bb5c9b8899c47ae);\n    let mut x230: u64 = 0;\n    let mut x231: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x230, &mut x231, x212, 0xbb6fb71e91386409);\n    let mut x232: u64 = 0;\n    let mut x233: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x232, &mut x233, 0x0, x231, x228);\n    let mut x234: u64 = 0;\n    let mut x235: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x234, &mut x235, x233, x229, x226);\n    let mut x236: u64 = 0;\n    let mut x237: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x236, &mut x237, x235, x227, x224);\n    let mut x238: u64 = 0;\n    let mut x239: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x238, &mut x239, x237, x225, x222);\n    let mut x240: u64 = 0;\n    let mut x241: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x240, &mut x241, x239, x223, x220);\n    let mut x242: u64 = 0;\n    let mut x243: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x242, &mut x243, x241, x221, x218);\n    let mut x244: u64 = 0;\n    let mut x245: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x244, &mut x245, x243, x219, x216);\n    let mut x246: u64 = 0;\n    let mut x247: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x246, &mut x247, x245, x217, x214);\n    let mut x248: u64 = 0;\n    let mut x249: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x248, &mut x249, 0x0, x196, x230);\n    let mut x250: u64 = 0;\n    let mut x251: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x250, &mut x251, x249, x198, x232);\n    let mut x252: u64 = 0;\n    let mut x253: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x252, &mut x253, x251, x200, x234);\n    let mut x254: u64 = 0;\n    let mut x255: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x254, &mut x255, x253, x202, x236);\n    let mut x256: u64 = 0;\n    let mut x257: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x256, &mut x257, x255, x204, x238);\n    let mut x258: u64 = 0;\n    let mut x259: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x258, &mut x259, x257, x206, x240);\n    let mut x260: u64 = 0;\n    let mut x261: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x260, &mut x261, x259, x208, x242);\n    let mut x262: u64 = 0;\n    let mut x263: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x262, &mut x263, x261, x210, x244);\n    let mut x264: u64 = 0;\n    let mut x265: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x264,\n        &mut x265,\n        x263,\n        ((x211 as u64) + ((x195 as u64) + ((x177 as u64) + x145))),\n        x246,\n    );\n    let mut x266: u64 = 0;\n    let mut x267: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x266, &mut x267, 0x0, x250, (arg1[4]));\n    let mut x268: u64 = 0;\n    let mut x269: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x268, &mut x269, x267, x252, (0x0 as u64));\n    let mut x270: u64 = 0;\n    let mut x271: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x270, &mut x271, x269, x254, (0x0 as u64));\n    let mut x272: u64 = 0;\n    let mut x273: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x272, &mut x273, x271, x256, (0x0 as u64));\n    let mut x274: u64 = 0;\n    let mut x275: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x274, &mut x275, x273, x258, (0x0 as u64));\n    let mut x276: u64 = 0;\n    let mut x277: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x276, &mut x277, x275, x260, (0x0 as u64));\n    let mut x278: u64 = 0;\n    let mut x279: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x278, &mut x279, x277, x262, (0x0 as u64));\n    let mut x280: u64 = 0;\n    let mut x281: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x280, &mut x281, x279, x264, (0x0 as u64));\n    let mut x282: u64 = 0;\n    let mut x283: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x282, &mut x283, x266, 0x1d2f5ccd79a995c7);\n    let mut x284: u64 = 0;\n    let mut x285: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x284, &mut x285, x282, 0x1ff);\n    let mut x286: u64 = 0;\n    let mut x287: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x286, &mut x287, x282, 0xffffffffffffffff);\n    let mut x288: u64 = 0;\n    let mut x289: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x288, &mut x289, x282, 0xffffffffffffffff);\n    let mut x290: u64 = 0;\n    let mut x291: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x290, &mut x291, x282, 0xffffffffffffffff);\n    let mut x292: u64 = 0;\n    let mut x293: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x292, &mut x293, x282, 0xfffffffffffffffa);\n    let mut x294: u64 = 0;\n    let mut x295: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x294, &mut x295, x282, 0x51868783bf2f966b);\n    let mut x296: u64 = 0;\n    let mut x297: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x296, &mut x297, x282, 0x7fcc0148f709a5d0);\n    let mut x298: u64 = 0;\n    let mut x299: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x298, &mut x299, x282, 0x3bb5c9b8899c47ae);\n    let mut x300: u64 = 0;\n    let mut x301: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x300, &mut x301, x282, 0xbb6fb71e91386409);\n    let mut x302: u64 = 0;\n    let mut x303: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x302, &mut x303, 0x0, x301, x298);\n    let mut x304: u64 = 0;\n    let mut x305: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x304, &mut x305, x303, x299, x296);\n    let mut x306: u64 = 0;\n    let mut x307: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x306, &mut x307, x305, x297, x294);\n    let mut x308: u64 = 0;\n    let mut x309: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x308, &mut x309, x307, x295, x292);\n    let mut x310: u64 = 0;\n    let mut x311: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x310, &mut x311, x309, x293, x290);\n    let mut x312: u64 = 0;\n    let mut x313: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x312, &mut x313, x311, x291, x288);\n    let mut x314: u64 = 0;\n    let mut x315: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x314, &mut x315, x313, x289, x286);\n    let mut x316: u64 = 0;\n    let mut x317: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x316, &mut x317, x315, x287, x284);\n    let mut x318: u64 = 0;\n    let mut x319: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x318, &mut x319, 0x0, x266, x300);\n    let mut x320: u64 = 0;\n    let mut x321: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x320, &mut x321, x319, x268, x302);\n    let mut x322: u64 = 0;\n    let mut x323: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x322, &mut x323, x321, x270, x304);\n    let mut x324: u64 = 0;\n    let mut x325: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x324, &mut x325, x323, x272, x306);\n    let mut x326: u64 = 0;\n    let mut x327: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x326, &mut x327, x325, x274, x308);\n    let mut x328: u64 = 0;\n    let mut x329: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x328, &mut x329, x327, x276, x310);\n    let mut x330: u64 = 0;\n    let mut x331: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x330, &mut x331, x329, x278, x312);\n    let mut x332: u64 = 0;\n    let mut x333: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x332, &mut x333, x331, x280, x314);\n    let mut x334: u64 = 0;\n    let mut x335: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x334,\n        &mut x335,\n        x333,\n        ((x281 as u64) + ((x265 as u64) + ((x247 as u64) + x215))),\n        x316,\n    );\n    let mut x336: u64 = 0;\n    let mut x337: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x336, &mut x337, 0x0, x320, (arg1[5]));\n    let mut x338: u64 = 0;\n    let mut x339: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x338, &mut x339, x337, x322, (0x0 as u64));\n    let mut x340: u64 = 0;\n    let mut x341: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x340, &mut x341, x339, x324, (0x0 as u64));\n    let mut x342: u64 = 0;\n    let mut x343: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x342, &mut x343, x341, x326, (0x0 as u64));\n    let mut x344: u64 = 0;\n    let mut x345: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x344, &mut x345, x343, x328, (0x0 as u64));\n    let mut x346: u64 = 0;\n    let mut x347: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x346, &mut x347, x345, x330, (0x0 as u64));\n    let mut x348: u64 = 0;\n    let mut x349: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x348, &mut x349, x347, x332, (0x0 as u64));\n    let mut x350: u64 = 0;\n    let mut x351: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x350, &mut x351, x349, x334, (0x0 as u64));\n    let mut x352: u64 = 0;\n    let mut x353: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x352, &mut x353, x336, 0x1d2f5ccd79a995c7);\n    let mut x354: u64 = 0;\n    let mut x355: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x354, &mut x355, x352, 0x1ff);\n    let mut x356: u64 = 0;\n    let mut x357: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x356, &mut x357, x352, 0xffffffffffffffff);\n    let mut x358: u64 = 0;\n    let mut x359: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x358, &mut x359, x352, 0xffffffffffffffff);\n    let mut x360: u64 = 0;\n    let mut x361: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x360, &mut x361, x352, 0xffffffffffffffff);\n    let mut x362: u64 = 0;\n    let mut x363: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x362, &mut x363, x352, 0xfffffffffffffffa);\n    let mut x364: u64 = 0;\n    let mut x365: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x364, &mut x365, x352, 0x51868783bf2f966b);\n    let mut x366: u64 = 0;\n    let mut x367: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x366, &mut x367, x352, 0x7fcc0148f709a5d0);\n    let mut x368: u64 = 0;\n    let mut x369: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x368, &mut x369, x352, 0x3bb5c9b8899c47ae);\n    let mut x370: u64 = 0;\n    let mut x371: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x370, &mut x371, x352, 0xbb6fb71e91386409);\n    let mut x372: u64 = 0;\n    let mut x373: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x372, &mut x373, 0x0, x371, x368);\n    let mut x374: u64 = 0;\n    let mut x375: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x374, &mut x375, x373, x369, x366);\n    let mut x376: u64 = 0;\n    let mut x377: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x376, &mut x377, x375, x367, x364);\n    let mut x378: u64 = 0;\n    let mut x379: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x378, &mut x379, x377, x365, x362);\n    let mut x380: u64 = 0;\n    let mut x381: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x380, &mut x381, x379, x363, x360);\n    let mut x382: u64 = 0;\n    let mut x383: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x382, &mut x383, x381, x361, x358);\n    let mut x384: u64 = 0;\n    let mut x385: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x384, &mut x385, x383, x359, x356);\n    let mut x386: u64 = 0;\n    let mut x387: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x386, &mut x387, x385, x357, x354);\n    let mut x388: u64 = 0;\n    let mut x389: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x388, &mut x389, 0x0, x336, x370);\n    let mut x390: u64 = 0;\n    let mut x391: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x390, &mut x391, x389, x338, x372);\n    let mut x392: u64 = 0;\n    let mut x393: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x392, &mut x393, x391, x340, x374);\n    let mut x394: u64 = 0;\n    let mut x395: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x394, &mut x395, x393, x342, x376);\n    let mut x396: u64 = 0;\n    let mut x397: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x396, &mut x397, x395, x344, x378);\n    let mut x398: u64 = 0;\n    let mut x399: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x398, &mut x399, x397, x346, x380);\n    let mut x400: u64 = 0;\n    let mut x401: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x400, &mut x401, x399, x348, x382);\n    let mut x402: u64 = 0;\n    let mut x403: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x402, &mut x403, x401, x350, x384);\n    let mut x404: u64 = 0;\n    let mut x405: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x404,\n        &mut x405,\n        x403,\n        ((x351 as u64) + ((x335 as u64) + ((x317 as u64) + x285))),\n        x386,\n    );\n    let mut x406: u64 = 0;\n    let mut x407: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x406, &mut x407, 0x0, x390, (arg1[6]));\n    let mut x408: u64 = 0;\n    let mut x409: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x408, &mut x409, x407, x392, (0x0 as u64));\n    let mut x410: u64 = 0;\n    let mut x411: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x410, &mut x411, x409, x394, (0x0 as u64));\n    let mut x412: u64 = 0;\n    let mut x413: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x412, &mut x413, x411, x396, (0x0 as u64));\n    let mut x414: u64 = 0;\n    let mut x415: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x414, &mut x415, x413, x398, (0x0 as u64));\n    let mut x416: u64 = 0;\n    let mut x417: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x416, &mut x417, x415, x400, (0x0 as u64));\n    let mut x418: u64 = 0;\n    let mut x419: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x418, &mut x419, x417, x402, (0x0 as u64));\n    let mut x420: u64 = 0;\n    let mut x421: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x420, &mut x421, x419, x404, (0x0 as u64));\n    let mut x422: u64 = 0;\n    let mut x423: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x422, &mut x423, x406, 0x1d2f5ccd79a995c7);\n    let mut x424: u64 = 0;\n    let mut x425: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x424, &mut x425, x422, 0x1ff);\n    let mut x426: u64 = 0;\n    let mut x427: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x426, &mut x427, x422, 0xffffffffffffffff);\n    let mut x428: u64 = 0;\n    let mut x429: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x428, &mut x429, x422, 0xffffffffffffffff);\n    let mut x430: u64 = 0;\n    let mut x431: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x430, &mut x431, x422, 0xffffffffffffffff);\n    let mut x432: u64 = 0;\n    let mut x433: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x432, &mut x433, x422, 0xfffffffffffffffa);\n    let mut x434: u64 = 0;\n    let mut x435: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x434, &mut x435, x422, 0x51868783bf2f966b);\n    let mut x436: u64 = 0;\n    let mut x437: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x436, &mut x437, x422, 0x7fcc0148f709a5d0);\n    let mut x438: u64 = 0;\n    let mut x439: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x438, &mut x439, x422, 0x3bb5c9b8899c47ae);\n    let mut x440: u64 = 0;\n    let mut x441: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x440, &mut x441, x422, 0xbb6fb71e91386409);\n    let mut x442: u64 = 0;\n    let mut x443: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x442, &mut x443, 0x0, x441, x438);\n    let mut x444: u64 = 0;\n    let mut x445: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x444, &mut x445, x443, x439, x436);\n    let mut x446: u64 = 0;\n    let mut x447: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x446, &mut x447, x445, x437, x434);\n    let mut x448: u64 = 0;\n    let mut x449: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x448, &mut x449, x447, x435, x432);\n    let mut x450: u64 = 0;\n    let mut x451: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x450, &mut x451, x449, x433, x430);\n    let mut x452: u64 = 0;\n    let mut x453: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x452, &mut x453, x451, x431, x428);\n    let mut x454: u64 = 0;\n    let mut x455: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x454, &mut x455, x453, x429, x426);\n    let mut x456: u64 = 0;\n    let mut x457: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x456, &mut x457, x455, x427, x424);\n    let mut x458: u64 = 0;\n    let mut x459: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x458, &mut x459, 0x0, x406, x440);\n    let mut x460: u64 = 0;\n    let mut x461: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x460, &mut x461, x459, x408, x442);\n    let mut x462: u64 = 0;\n    let mut x463: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x462, &mut x463, x461, x410, x444);\n    let mut x464: u64 = 0;\n    let mut x465: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x464, &mut x465, x463, x412, x446);\n    let mut x466: u64 = 0;\n    let mut x467: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x466, &mut x467, x465, x414, x448);\n    let mut x468: u64 = 0;\n    let mut x469: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x468, &mut x469, x467, x416, x450);\n    let mut x470: u64 = 0;\n    let mut x471: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x470, &mut x471, x469, x418, x452);\n    let mut x472: u64 = 0;\n    let mut x473: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x472, &mut x473, x471, x420, x454);\n    let mut x474: u64 = 0;\n    let mut x475: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x474,\n        &mut x475,\n        x473,\n        ((x421 as u64) + ((x405 as u64) + ((x387 as u64) + x355))),\n        x456,\n    );\n    let mut x476: u64 = 0;\n    let mut x477: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x476, &mut x477, 0x0, x460, (arg1[7]));\n    let mut x478: u64 = 0;\n    let mut x479: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x478, &mut x479, x477, x462, (0x0 as u64));\n    let mut x480: u64 = 0;\n    let mut x481: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x480, &mut x481, x479, x464, (0x0 as u64));\n    let mut x482: u64 = 0;\n    let mut x483: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x482, &mut x483, x481, x466, (0x0 as u64));\n    let mut x484: u64 = 0;\n    let mut x485: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x484, &mut x485, x483, x468, (0x0 as u64));\n    let mut x486: u64 = 0;\n    let mut x487: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x486, &mut x487, x485, x470, (0x0 as u64));\n    let mut x488: u64 = 0;\n    let mut x489: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x488, &mut x489, x487, x472, (0x0 as u64));\n    let mut x490: u64 = 0;\n    let mut x491: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x490, &mut x491, x489, x474, (0x0 as u64));\n    let mut x492: u64 = 0;\n    let mut x493: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x492, &mut x493, x476, 0x1d2f5ccd79a995c7);\n    let mut x494: u64 = 0;\n    let mut x495: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x494, &mut x495, x492, 0x1ff);\n    let mut x496: u64 = 0;\n    let mut x497: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x496, &mut x497, x492, 0xffffffffffffffff);\n    let mut x498: u64 = 0;\n    let mut x499: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x498, &mut x499, x492, 0xffffffffffffffff);\n    let mut x500: u64 = 0;\n    let mut x501: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x500, &mut x501, x492, 0xffffffffffffffff);\n    let mut x502: u64 = 0;\n    let mut x503: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x502, &mut x503, x492, 0xfffffffffffffffa);\n    let mut x504: u64 = 0;\n    let mut x505: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x504, &mut x505, x492, 0x51868783bf2f966b);\n    let mut x506: u64 = 0;\n    let mut x507: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x506, &mut x507, x492, 0x7fcc0148f709a5d0);\n    let mut x508: u64 = 0;\n    let mut x509: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x508, &mut x509, x492, 0x3bb5c9b8899c47ae);\n    let mut x510: u64 = 0;\n    let mut x511: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x510, &mut x511, x492, 0xbb6fb71e91386409);\n    let mut x512: u64 = 0;\n    let mut x513: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x512, &mut x513, 0x0, x511, x508);\n    let mut x514: u64 = 0;\n    let mut x515: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x514, &mut x515, x513, x509, x506);\n    let mut x516: u64 = 0;\n    let mut x517: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x516, &mut x517, x515, x507, x504);\n    let mut x518: u64 = 0;\n    let mut x519: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x518, &mut x519, x517, x505, x502);\n    let mut x520: u64 = 0;\n    let mut x521: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x520, &mut x521, x519, x503, x500);\n    let mut x522: u64 = 0;\n    let mut x523: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x522, &mut x523, x521, x501, x498);\n    let mut x524: u64 = 0;\n    let mut x525: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x524, &mut x525, x523, x499, x496);\n    let mut x526: u64 = 0;\n    let mut x527: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x526, &mut x527, x525, x497, x494);\n    let mut x528: u64 = 0;\n    let mut x529: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x528, &mut x529, 0x0, x476, x510);\n    let mut x530: u64 = 0;\n    let mut x531: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x530, &mut x531, x529, x478, x512);\n    let mut x532: u64 = 0;\n    let mut x533: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x532, &mut x533, x531, x480, x514);\n    let mut x534: u64 = 0;\n    let mut x535: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x534, &mut x535, x533, x482, x516);\n    let mut x536: u64 = 0;\n    let mut x537: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x536, &mut x537, x535, x484, x518);\n    let mut x538: u64 = 0;\n    let mut x539: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x538, &mut x539, x537, x486, x520);\n    let mut x540: u64 = 0;\n    let mut x541: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x540, &mut x541, x539, x488, x522);\n    let mut x542: u64 = 0;\n    let mut x543: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x542, &mut x543, x541, x490, x524);\n    let mut x544: u64 = 0;\n    let mut x545: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x544,\n        &mut x545,\n        x543,\n        ((x491 as u64) + ((x475 as u64) + ((x457 as u64) + x425))),\n        x526,\n    );\n    let mut x546: u64 = 0;\n    let mut x547: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x546, &mut x547, 0x0, x530, (arg1[8]));\n    let mut x548: u64 = 0;\n    let mut x549: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x548, &mut x549, x547, x532, (0x0 as u64));\n    let mut x550: u64 = 0;\n    let mut x551: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x550, &mut x551, x549, x534, (0x0 as u64));\n    let mut x552: u64 = 0;\n    let mut x553: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x552, &mut x553, x551, x536, (0x0 as u64));\n    let mut x554: u64 = 0;\n    let mut x555: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x554, &mut x555, x553, x538, (0x0 as u64));\n    let mut x556: u64 = 0;\n    let mut x557: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x556, &mut x557, x555, x540, (0x0 as u64));\n    let mut x558: u64 = 0;\n    let mut x559: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x558, &mut x559, x557, x542, (0x0 as u64));\n    let mut x560: u64 = 0;\n    let mut x561: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x560, &mut x561, x559, x544, (0x0 as u64));\n    let mut x562: u64 = 0;\n    let mut x563: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x562, &mut x563, x546, 0x1d2f5ccd79a995c7);\n    let mut x564: u64 = 0;\n    let mut x565: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x564, &mut x565, x562, 0x1ff);\n    let mut x566: u64 = 0;\n    let mut x567: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x566, &mut x567, x562, 0xffffffffffffffff);\n    let mut x568: u64 = 0;\n    let mut x569: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x568, &mut x569, x562, 0xffffffffffffffff);\n    let mut x570: u64 = 0;\n    let mut x571: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x570, &mut x571, x562, 0xffffffffffffffff);\n    let mut x572: u64 = 0;\n    let mut x573: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x572, &mut x573, x562, 0xfffffffffffffffa);\n    let mut x574: u64 = 0;\n    let mut x575: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x574, &mut x575, x562, 0x51868783bf2f966b);\n    let mut x576: u64 = 0;\n    let mut x577: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x576, &mut x577, x562, 0x7fcc0148f709a5d0);\n    let mut x578: u64 = 0;\n    let mut x579: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x578, &mut x579, x562, 0x3bb5c9b8899c47ae);\n    let mut x580: u64 = 0;\n    let mut x581: u64 = 0;\n    fiat_p521_scalar_mulx_u64(&mut x580, &mut x581, x562, 0xbb6fb71e91386409);\n    let mut x582: u64 = 0;\n    let mut x583: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x582, &mut x583, 0x0, x581, x578);\n    let mut x584: u64 = 0;\n    let mut x585: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x584, &mut x585, x583, x579, x576);\n    let mut x586: u64 = 0;\n    let mut x587: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x586, &mut x587, x585, x577, x574);\n    let mut x588: u64 = 0;\n    let mut x589: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x588, &mut x589, x587, x575, x572);\n    let mut x590: u64 = 0;\n    let mut x591: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x590, &mut x591, x589, x573, x570);\n    let mut x592: u64 = 0;\n    let mut x593: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x592, &mut x593, x591, x571, x568);\n    let mut x594: u64 = 0;\n    let mut x595: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x594, &mut x595, x593, x569, x566);\n    let mut x596: u64 = 0;\n    let mut x597: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x596, &mut x597, x595, x567, x564);\n    let mut x598: u64 = 0;\n    let mut x599: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x598, &mut x599, 0x0, x546, x580);\n    let mut x600: u64 = 0;\n    let mut x601: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x600, &mut x601, x599, x548, x582);\n    let mut x602: u64 = 0;\n    let mut x603: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x602, &mut x603, x601, x550, x584);\n    let mut x604: u64 = 0;\n    let mut x605: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x604, &mut x605, x603, x552, x586);\n    let mut x606: u64 = 0;\n    let mut x607: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x606, &mut x607, x605, x554, x588);\n    let mut x608: u64 = 0;\n    let mut x609: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x608, &mut x609, x607, x556, x590);\n    let mut x610: u64 = 0;\n    let mut x611: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x610, &mut x611, x609, x558, x592);\n    let mut x612: u64 = 0;\n    let mut x613: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(&mut x612, &mut x613, x611, x560, x594);\n    let mut x614: u64 = 0;\n    let mut x615: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_addcarryx_u64(\n        &mut x614,\n        &mut x615,\n        x613,\n        ((x561 as u64) + ((x545 as u64) + ((x527 as u64) + x495))),\n        x596,\n    );\n    let x616: u64 = ((x615 as u64) + ((x597 as u64) + x565));\n    let mut x617: u64 = 0;\n    let mut x618: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x617, &mut x618, 0x0, x600, 0xbb6fb71e91386409);\n    let mut x619: u64 = 0;\n    let mut x620: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x619, &mut x620, x618, x602, 0x3bb5c9b8899c47ae);\n    let mut x621: u64 = 0;\n    let mut x622: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x621, &mut x622, x620, x604, 0x7fcc0148f709a5d0);\n    let mut x623: u64 = 0;\n    let mut x624: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x623, &mut x624, x622, x606, 0x51868783bf2f966b);\n    let mut x625: u64 = 0;\n    let mut x626: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x625, &mut x626, x624, x608, 0xfffffffffffffffa);\n    let mut x627: u64 = 0;\n    let mut x628: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x627, &mut x628, x626, x610, 0xffffffffffffffff);\n    let mut x629: u64 = 0;\n    let mut x630: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x629, &mut x630, x628, x612, 0xffffffffffffffff);\n    let mut x631: u64 = 0;\n    let mut x632: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x631, &mut x632, x630, x614, 0xffffffffffffffff);\n    let mut x633: u64 = 0;\n    let mut x634: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x633, &mut x634, x632, x616, 0x1ff);\n    let mut x635: u64 = 0;\n    let mut x636: fiat_p521_scalar_u1 = 0;\n    fiat_p521_scalar_subborrowx_u64(&mut x635, &mut x636, x634, (0x0 as u64), (0x0 as u64));\n    let mut x637: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x637, x636, x617, x600);\n    let mut x638: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x638, x636, x619, x602);\n    let mut x639: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x639, x636, x621, x604);\n    let mut x640: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x640, x636, x623, x606);\n    let mut x641: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x641, x636, x625, x608);\n    let mut x642: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x642, x636, x627, x610);\n    let mut x643: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x643, x636, x629, x612);\n    let mut x644: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x644, x636, x631, x614);\n    let mut x645: u64 = 0;\n    fiat_p521_scalar_cmovznz_u64(&mut x645, x636, x633, x616);\n    out1[0] = x637;\n    out1[1] = x638;\n    out1[2] = x639;\n    out1[3] = x640;\n    out1[4] = x641;\n    out1[5] = x642;\n    out1[6] = x643;\n    out1[7] = x644;\n    out1[8] = x645;\n}",
    "display_name": "fiat_p521_scalar_from_montgomery",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/add"
    ],
    "body": "    fn add_assign(&mut self, rhs: ProjectivePoint<C>) {\n        *self = ProjectivePoint::add(self, &rhs);\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_ctx",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_inner"
    ],
    "body": "    pub fn sign_ctx(&self, ctx: &[u8], m: &[u8]) -> Result<InnerSignature, SigningError> {\n        self.sign_inner(0, ctx, m)\n    }",
    "display_name": "sign_ctx",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/expanded.rs",
    "relative_path": "ed448-goldilocks/src/sign/expanded.rs",
    "file_name": "expanded.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 bench_scalar_add",
      "0.14.0_pre.8 bench_scalar_negate",
      "0.14.0_pre.8 bench_scalar_invert",
      "0.14.0_pre.8 bench_scalar_sub",
      "0.14.0_pre.8 bench_scalar_mul"
    ],
    "body": "fn bench_scalar(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"scalar operations\");\n    bench_scalar_sub(&mut group);\n    bench_scalar_add(&mut group);\n    bench_scalar_mul(&mut group);\n    bench_scalar_negate(&mut group);\n    bench_scalar_invert(&mut group);\n    group.finish();\n}",
    "display_name": "bench_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/benches/scalar.rs",
    "relative_path": "p521/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/tests/hash_with_test_vectors",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_on_curve",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/to_affine",
      "0.14.0_pre.1 field/element/impl/FieldElement/to_bytes",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/hash"
    ],
    "body": "    fn hash_with_test_vectors() {\n        const DST: &[u8] = b\"QUUX-V01-CS02-with-edwards448_XOF:SHAKE256_ELL2_RO_\";\n        const MSGS: &[(&[u8], [u8; 56], [u8; 56])] = &[\n            (b\"\", hex!(\"73036d4a88949c032f01507005c133884e2f0d81f9a950826245dda9e844fc78186c39daaa7147ead3e462cff60e9c6340b58134480b4d17\"), hex!(\"94c1d61b43728e5d784ef4fcb1f38e1075f3aef5e99866911de5a234f1aafdc26b554344742e6ba0420b71b298671bbeb2b7736618634610\")),\n            (b\"abc\", hex!(\"4e0158acacffa545adb818a6ed8e0b870e6abc24dfc1dc45cf9a052e98469275d9ff0c168d6a5ac7ec05b742412ee090581f12aa398f9f8c\"), hex!(\"894d3fa437b2d2e28cdc3bfaade035430f350ec5239b6b406b5501da6f6d6210ff26719cad83b63e97ab26a12df6dec851d6bf38e294af9a\")),\n            (b\"abcdef0123456789\", hex!(\"2c25b4503fadc94b27391933b557abdecc601c13ed51c5de68389484f93dbd6c22e5f962d9babf7a39f39f994312f8ca23344847e1fbf176\"), hex!(\"d5e6f5350f430e53a110f5ac7fcc82a96cb865aeca982029522d32601e41c042a9dfbdfbefa2b0bdcdc3bc58cca8a7cd546803083d3a8548\")),\n            (b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\", hex!(\"a1861a9464ae31249a0e60bf38791f3663049a3f5378998499a83292e159a2fecff838eb9bc6939e5c6ae76eb074ad4aae39b55b72ca0b9a\"), hex!(\"580a2798c5b904f8adfec5bd29fb49b4633cd9f8c2935eb4a0f12e5dfa0285680880296bb729c6405337525fb5ed3dff930c137314f60401\")),\n            (b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", hex!(\"987c5ac19dd4b47835466a50b2d9feba7c8491b8885a04edf577e15a9f2c98b203ec2cd3e5390b3d20bba0fa6fc3eecefb5029a317234401\"), hex!(\"5e273fcfff6b007bb6771e90509275a71ff1480c459ded26fc7b10664db0a68aaa98bc7ecb07e49cf05b80ae5ac653fbdd14276bbd35ccbc\")),\n        ];\n\n        for (msg, x, y) in MSGS {\n            let p = EdwardsPoint::hash::<ExpandMsgXof<sha3::Shake256>>(msg, DST);\n            assert_eq!(p.is_on_curve().unwrap_u8(), 1u8);\n            let p = p.to_affine();\n            let mut xx = [0u8; 56];\n            xx.copy_from_slice(&x[..]);\n            xx.reverse();\n            let mut yy = [0u8; 56];\n            yy.copy_from_slice(&y[..]);\n            yy.reverse();\n            assert_eq!(p.x.to_bytes(), xx);\n            assert_eq!(p.y.to_bytes(), yy);\n        }\n    }",
    "display_name": "hash_with_test_vectors",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre impl/primefield::bigint::Uint/FieldBytesEncoding/encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encode_field_bytes(&self) -> FieldBytes {\n        self.to_be_byte_array()\n    }",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/lib.rs",
    "relative_path": "sm2/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/DecafPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, other: &DecafAffinePoint) {\n        *self = *self + *other;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_addcarryx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_sm2_scalar_mulx_u64"
    ],
    "body": "pub const fn fiat_sm2_scalar_mul(\n    out1: &mut fiat_sm2_scalar_montgomery_domain_field_element,\n    arg1: &fiat_sm2_scalar_montgomery_domain_field_element,\n    arg2: &fiat_sm2_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = (arg1[1]);\n    let x2: u64 = (arg1[2]);\n    let x3: u64 = (arg1[3]);\n    let x4: u64 = (arg1[0]);\n    let mut x5: u64 = 0;\n    let mut x6: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x5, &mut x6, x4, (arg2[3]));\n    let mut x7: u64 = 0;\n    let mut x8: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x7, &mut x8, x4, (arg2[2]));\n    let mut x9: u64 = 0;\n    let mut x10: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x9, &mut x10, x4, (arg2[1]));\n    let mut x11: u64 = 0;\n    let mut x12: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x11, &mut x12, x4, (arg2[0]));\n    let mut x13: u64 = 0;\n    let mut x14: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x13, &mut x14, 0x0, x12, x9);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x15, &mut x16, x14, x10, x7);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x17, &mut x18, x16, x8, x5);\n    let x19: u64 = ((x18 as u64) + x6);\n    let mut x20: u64 = 0;\n    let mut x21: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x20, &mut x21, x11, 0x327f9e8872350975);\n    let mut x22: u64 = 0;\n    let mut x23: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x22, &mut x23, x20, 0xfffffffeffffffff);\n    let mut x24: u64 = 0;\n    let mut x25: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x24, &mut x25, x20, 0xffffffffffffffff);\n    let mut x26: u64 = 0;\n    let mut x27: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x26, &mut x27, x20, 0x7203df6b21c6052b);\n    let mut x28: u64 = 0;\n    let mut x29: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x28, &mut x29, x20, 0x53bbf40939d54123);\n    let mut x30: u64 = 0;\n    let mut x31: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x30, &mut x31, 0x0, x29, x26);\n    let mut x32: u64 = 0;\n    let mut x33: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x32, &mut x33, x31, x27, x24);\n    let mut x34: u64 = 0;\n    let mut x35: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x34, &mut x35, x33, x25, x22);\n    let x36: u64 = ((x35 as u64) + x23);\n    let mut x37: u64 = 0;\n    let mut x38: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x37, &mut x38, 0x0, x11, x28);\n    let mut x39: u64 = 0;\n    let mut x40: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x39, &mut x40, x38, x13, x30);\n    let mut x41: u64 = 0;\n    let mut x42: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x41, &mut x42, x40, x15, x32);\n    let mut x43: u64 = 0;\n    let mut x44: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x43, &mut x44, x42, x17, x34);\n    let mut x45: u64 = 0;\n    let mut x46: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x45, &mut x46, x44, x19, x36);\n    let mut x47: u64 = 0;\n    let mut x48: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x47, &mut x48, x1, (arg2[3]));\n    let mut x49: u64 = 0;\n    let mut x50: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x49, &mut x50, x1, (arg2[2]));\n    let mut x51: u64 = 0;\n    let mut x52: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x51, &mut x52, x1, (arg2[1]));\n    let mut x53: u64 = 0;\n    let mut x54: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x53, &mut x54, x1, (arg2[0]));\n    let mut x55: u64 = 0;\n    let mut x56: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x55, &mut x56, 0x0, x54, x51);\n    let mut x57: u64 = 0;\n    let mut x58: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x57, &mut x58, x56, x52, x49);\n    let mut x59: u64 = 0;\n    let mut x60: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x59, &mut x60, x58, x50, x47);\n    let x61: u64 = ((x60 as u64) + x48);\n    let mut x62: u64 = 0;\n    let mut x63: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x62, &mut x63, 0x0, x39, x53);\n    let mut x64: u64 = 0;\n    let mut x65: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x64, &mut x65, x63, x41, x55);\n    let mut x66: u64 = 0;\n    let mut x67: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x66, &mut x67, x65, x43, x57);\n    let mut x68: u64 = 0;\n    let mut x69: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x68, &mut x69, x67, x45, x59);\n    let mut x70: u64 = 0;\n    let mut x71: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x70, &mut x71, x69, (x46 as u64), x61);\n    let mut x72: u64 = 0;\n    let mut x73: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x72, &mut x73, x62, 0x327f9e8872350975);\n    let mut x74: u64 = 0;\n    let mut x75: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x74, &mut x75, x72, 0xfffffffeffffffff);\n    let mut x76: u64 = 0;\n    let mut x77: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x76, &mut x77, x72, 0xffffffffffffffff);\n    let mut x78: u64 = 0;\n    let mut x79: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x78, &mut x79, x72, 0x7203df6b21c6052b);\n    let mut x80: u64 = 0;\n    let mut x81: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x80, &mut x81, x72, 0x53bbf40939d54123);\n    let mut x82: u64 = 0;\n    let mut x83: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x82, &mut x83, 0x0, x81, x78);\n    let mut x84: u64 = 0;\n    let mut x85: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x84, &mut x85, x83, x79, x76);\n    let mut x86: u64 = 0;\n    let mut x87: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x86, &mut x87, x85, x77, x74);\n    let x88: u64 = ((x87 as u64) + x75);\n    let mut x89: u64 = 0;\n    let mut x90: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x89, &mut x90, 0x0, x62, x80);\n    let mut x91: u64 = 0;\n    let mut x92: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x91, &mut x92, x90, x64, x82);\n    let mut x93: u64 = 0;\n    let mut x94: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x93, &mut x94, x92, x66, x84);\n    let mut x95: u64 = 0;\n    let mut x96: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x95, &mut x96, x94, x68, x86);\n    let mut x97: u64 = 0;\n    let mut x98: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x97, &mut x98, x96, x70, x88);\n    let x99: u64 = ((x98 as u64) + (x71 as u64));\n    let mut x100: u64 = 0;\n    let mut x101: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x100, &mut x101, x2, (arg2[3]));\n    let mut x102: u64 = 0;\n    let mut x103: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x102, &mut x103, x2, (arg2[2]));\n    let mut x104: u64 = 0;\n    let mut x105: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x104, &mut x105, x2, (arg2[1]));\n    let mut x106: u64 = 0;\n    let mut x107: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x106, &mut x107, x2, (arg2[0]));\n    let mut x108: u64 = 0;\n    let mut x109: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x108, &mut x109, 0x0, x107, x104);\n    let mut x110: u64 = 0;\n    let mut x111: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x110, &mut x111, x109, x105, x102);\n    let mut x112: u64 = 0;\n    let mut x113: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x112, &mut x113, x111, x103, x100);\n    let x114: u64 = ((x113 as u64) + x101);\n    let mut x115: u64 = 0;\n    let mut x116: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x115, &mut x116, 0x0, x91, x106);\n    let mut x117: u64 = 0;\n    let mut x118: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x117, &mut x118, x116, x93, x108);\n    let mut x119: u64 = 0;\n    let mut x120: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x119, &mut x120, x118, x95, x110);\n    let mut x121: u64 = 0;\n    let mut x122: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x121, &mut x122, x120, x97, x112);\n    let mut x123: u64 = 0;\n    let mut x124: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x123, &mut x124, x122, x99, x114);\n    let mut x125: u64 = 0;\n    let mut x126: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x125, &mut x126, x115, 0x327f9e8872350975);\n    let mut x127: u64 = 0;\n    let mut x128: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x127, &mut x128, x125, 0xfffffffeffffffff);\n    let mut x129: u64 = 0;\n    let mut x130: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x129, &mut x130, x125, 0xffffffffffffffff);\n    let mut x131: u64 = 0;\n    let mut x132: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x131, &mut x132, x125, 0x7203df6b21c6052b);\n    let mut x133: u64 = 0;\n    let mut x134: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x133, &mut x134, x125, 0x53bbf40939d54123);\n    let mut x135: u64 = 0;\n    let mut x136: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x135, &mut x136, 0x0, x134, x131);\n    let mut x137: u64 = 0;\n    let mut x138: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x137, &mut x138, x136, x132, x129);\n    let mut x139: u64 = 0;\n    let mut x140: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x139, &mut x140, x138, x130, x127);\n    let x141: u64 = ((x140 as u64) + x128);\n    let mut x142: u64 = 0;\n    let mut x143: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x142, &mut x143, 0x0, x115, x133);\n    let mut x144: u64 = 0;\n    let mut x145: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x144, &mut x145, x143, x117, x135);\n    let mut x146: u64 = 0;\n    let mut x147: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x146, &mut x147, x145, x119, x137);\n    let mut x148: u64 = 0;\n    let mut x149: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x148, &mut x149, x147, x121, x139);\n    let mut x150: u64 = 0;\n    let mut x151: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x150, &mut x151, x149, x123, x141);\n    let x152: u64 = ((x151 as u64) + (x124 as u64));\n    let mut x153: u64 = 0;\n    let mut x154: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x153, &mut x154, x3, (arg2[3]));\n    let mut x155: u64 = 0;\n    let mut x156: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x155, &mut x156, x3, (arg2[2]));\n    let mut x157: u64 = 0;\n    let mut x158: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x157, &mut x158, x3, (arg2[1]));\n    let mut x159: u64 = 0;\n    let mut x160: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x159, &mut x160, x3, (arg2[0]));\n    let mut x161: u64 = 0;\n    let mut x162: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x161, &mut x162, 0x0, x160, x157);\n    let mut x163: u64 = 0;\n    let mut x164: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x163, &mut x164, x162, x158, x155);\n    let mut x165: u64 = 0;\n    let mut x166: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x165, &mut x166, x164, x156, x153);\n    let x167: u64 = ((x166 as u64) + x154);\n    let mut x168: u64 = 0;\n    let mut x169: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x168, &mut x169, 0x0, x144, x159);\n    let mut x170: u64 = 0;\n    let mut x171: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x170, &mut x171, x169, x146, x161);\n    let mut x172: u64 = 0;\n    let mut x173: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x172, &mut x173, x171, x148, x163);\n    let mut x174: u64 = 0;\n    let mut x175: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x174, &mut x175, x173, x150, x165);\n    let mut x176: u64 = 0;\n    let mut x177: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x176, &mut x177, x175, x152, x167);\n    let mut x178: u64 = 0;\n    let mut x179: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x178, &mut x179, x168, 0x327f9e8872350975);\n    let mut x180: u64 = 0;\n    let mut x181: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x180, &mut x181, x178, 0xfffffffeffffffff);\n    let mut x182: u64 = 0;\n    let mut x183: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x182, &mut x183, x178, 0xffffffffffffffff);\n    let mut x184: u64 = 0;\n    let mut x185: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x184, &mut x185, x178, 0x7203df6b21c6052b);\n    let mut x186: u64 = 0;\n    let mut x187: u64 = 0;\n    fiat_sm2_scalar_mulx_u64(&mut x186, &mut x187, x178, 0x53bbf40939d54123);\n    let mut x188: u64 = 0;\n    let mut x189: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x188, &mut x189, 0x0, x187, x184);\n    let mut x190: u64 = 0;\n    let mut x191: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x190, &mut x191, x189, x185, x182);\n    let mut x192: u64 = 0;\n    let mut x193: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x192, &mut x193, x191, x183, x180);\n    let x194: u64 = ((x193 as u64) + x181);\n    let mut x195: u64 = 0;\n    let mut x196: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x195, &mut x196, 0x0, x168, x186);\n    let mut x197: u64 = 0;\n    let mut x198: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x197, &mut x198, x196, x170, x188);\n    let mut x199: u64 = 0;\n    let mut x200: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x199, &mut x200, x198, x172, x190);\n    let mut x201: u64 = 0;\n    let mut x202: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x201, &mut x202, x200, x174, x192);\n    let mut x203: u64 = 0;\n    let mut x204: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_addcarryx_u64(&mut x203, &mut x204, x202, x176, x194);\n    let x205: u64 = ((x204 as u64) + (x177 as u64));\n    let mut x206: u64 = 0;\n    let mut x207: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x206, &mut x207, 0x0, x197, 0x53bbf40939d54123);\n    let mut x208: u64 = 0;\n    let mut x209: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x208, &mut x209, x207, x199, 0x7203df6b21c6052b);\n    let mut x210: u64 = 0;\n    let mut x211: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x210, &mut x211, x209, x201, 0xffffffffffffffff);\n    let mut x212: u64 = 0;\n    let mut x213: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x212, &mut x213, x211, x203, 0xfffffffeffffffff);\n    let mut x214: u64 = 0;\n    let mut x215: fiat_sm2_scalar_u1 = 0;\n    fiat_sm2_scalar_subborrowx_u64(&mut x214, &mut x215, x213, x205, (0x0 as u64));\n    let mut x216: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x216, x215, x206, x197);\n    let mut x217: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x217, x215, x208, x199);\n    let mut x218: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x218, x215, x210, x201);\n    let mut x219: u64 = 0;\n    fiat_sm2_scalar_cmovznz_u64(&mut x219, x215, x212, x203);\n    out1[0] = x216;\n    out1[1] = x217;\n    out1[2] = x218;\n    out1[3] = x219;\n}",
    "display_name": "fiat_sm2_scalar_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "relative_path": "sm2/src/arithmetic/scalar/sm2_scalar_64.rs",
    "file_name": "sm2_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 decode_pkcs8_private_key_from_der",
    "statement_type": "function",
    "deps": [],
    "body": "fn decode_pkcs8_private_key_from_der() {\n    let secret_key = p256::SecretKey::from_pkcs8_der(&PKCS8_PRIVATE_KEY_DER[..]).unwrap();\n    let expected_scalar = hex!(\"69624171561A63340DE0E7D869F2A05492558E1A04868B6A9F854A866788188D\");\n    assert_eq!(secret_key.to_bytes().as_slice(), &expected_scalar[..]);\n}",
    "display_name": "decode_pkcs8_private_key_from_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/pkcs8.rs",
    "relative_path": "p256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 uncompact_to_compact",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point",
      "affine/impl/AffinePoint/ToCompactEncodedPoint/to_compact_encoded_point"
    ],
    "body": "fn uncompact_to_compact() {\n    let pubkey = EncodedPoint::from_bytes(UNCOMPACT_BASEPOINT).unwrap();\n    assert!(!pubkey.is_compact());\n\n    let point = AffinePoint::from_encoded_point(&pubkey).unwrap();\n    let res = point.to_compact_encoded_point().unwrap();\n    assert_eq!(res.as_bytes(), COMPACT_BASEPOINT)\n}",
    "display_name": "uncompact_to_compact",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/affine.rs",
    "relative_path": "p256/tests/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(secret_key: &SecretKey) -> SigningKey {\n        secret_key.to_nonzero_scalar().into()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl//u8; 56//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 decaf/points/impl//u8; 56//From/from"
    ],
    "body": "    fn from(compressed: &DecafPoint) -> DecafPointBytes {\n        Self::from(*compressed)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/NonIdentity/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(affine_point: AffinePoint) -> Result<Self> {\n        NonIdentity::new(affine_point).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/ConditionallyNegatable/conditional_negate",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_negate(&mut self, choice: Choice) {\n        FieldElement::conditional_swap(&mut self.Y_minus_X, &mut self.Y_plus_X, choice);\n        self.Td.conditional_negate(choice);\n    }",
    "display_name": "conditional_negate",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/projective.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.7.0_pre encode_field_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_field_bytes(uint: &U256) -> FieldBytes {\n    uint.to_be_byte_array()\n}",
    "display_name": "encode_field_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bp256/src/lib.rs",
    "relative_path": "bp256/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/DecafPoint/From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended"
    ],
    "body": "    fn from(point: &DecafAffinePoint) -> Self {\n        Self(point.0.to_extended())\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "affine/impl/AffinePoint/DecompactPoint/decompact",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/to_compact",
      "affine/impl/AffinePoint/DecompressPoint/decompress"
    ],
    "body": "    fn decompact(x_bytes: &FieldBytes<C>) -> CtOption<Self> {\n        Self::decompress(x_bytes, Choice::from(0)).map(|point| point.to_compact())\n    }",
    "display_name": "decompact",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "affine/impl/AffinePoint/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/FromEncodedPoint/from_encoded_point"
    ],
    "body": "    fn try_from(point: &EncodedPoint<C>) -> Result<AffinePoint<C>> {\n        Option::from(AffinePoint::<C>::from_encoded_point(point)).ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub_assign(&mut self, rhs: Scalar) {\n        *self = Scalar::sub(self, &rhs);\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes"
    ],
    "body": "    fn to_bytes() {\n        assert_eq!(FieldElement::ZERO.to_bytes(), [0; 32]);\n        assert_eq!(\n            FieldElement::ONE.to_bytes(),\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 1\n            ]\n        );\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &AffinePoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/new",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/signing/impl/SigningKey/from_nonzero_scalar"
    ],
    "body": "    pub fn new(distid: &DistId, secret_key: &SecretKey) -> Result<Self> {\n        Self::from_nonzero_scalar(distid, secret_key.to_nonzero_scalar())\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/scalar_impl/impl/fiat_p521_scalar_non_montgomery_domain_field_element/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.0[index]\n    }",
    "display_name": "index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "relative_path": "p521/src/arithmetic/scalar/p521_scalar_64.rs",
    "file_name": "p521_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_divstep_precomp",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_divstep_precomp(out1: &mut [u64; 4]) {\n    out1[0] = 0x74ecb6e5a4954cc;\n    out1[1] = 0x26a7844030955df6;\n    out1[2] = 0xef16fedba3350f94;\n    out1[3] = 0x4704d6d8;\n}",
    "display_name": "fiat_p224_scalar_divstep_precomp",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field.rs",
    "relative_path": "p224/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/affine/impl/AffineNielsPoint/equals",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn equals(&self, other: &AffineNielsPoint) -> bool {\n        (self.y_minus_x == other.y_minus_x)\n            && (self.y_plus_x == other.y_plus_x)\n            && (self.td == other.td)\n    }",
    "display_name": "equals",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "affine/impl/AffinePoint/GroupEncoding/to_bytes",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/ToEncodedPoint/to_encoded_point"
    ],
    "body": "    fn to_bytes(&self) -> Self::Repr {\n        let encoded = self.to_encoded_point(true);\n        let mut result = CompressedPoint::<C>::default();\n        result[..encoded.len()].copy_from_slice(encoded.as_bytes());\n        result\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/as_limbs",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn as_limbs(&self) -> &[u64; 9] {\n        &self.0.0\n    }",
    "display_name": "as_limbs",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar.rs",
    "relative_path": "p224/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/from_uint_unchecked",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_uint_unchecked",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/Mul/mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/mul"
    ],
    "body": "    fn mul(self, other: FieldElement) -> FieldElement {\n        FieldElement(self.0.mul(&(other.0)))\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre dsa/impl//u8; _//From/from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/impl/Signature/to_bytes"
    ],
    "body": "    fn from(signature: Signature) -> SignatureBytes {\n        signature.to_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa.rs",
    "relative_path": "sm2/src/dsa.rs",
    "file_name": "dsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre bench_field_element_mul",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre test_field_element_x",
      "0.14.0_pre test_field_element_y"
    ],
    "body": "fn bench_field_element_mul<M: Measurement>(group: &mut BenchmarkGroup<M>) {\n    let x = test_field_element_x();\n    let y = test_field_element_y();\n    group.bench_function(\"mul\", |b| b.iter(|| x * y));\n}",
    "display_name": "bench_field_element_mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/benches/field.rs",
    "relative_path": "bign256/benches/field.rs",
    "file_name": "field.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/scalar.rs",
    "relative_path": "sm2/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p521_carry_add",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p521_carry_add(\n    out1: &mut fiat_p521_tight_field_element,\n    arg1: &fiat_p521_tight_field_element,\n    arg2: &fiat_p521_tight_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let x1: u64 = ((arg1[0]) + (arg2[0]));\n    let x2: u64 = ((x1 >> 58) + ((arg1[1]) + (arg2[1])));\n    let x3: u64 = ((x2 >> 58) + ((arg1[2]) + (arg2[2])));\n    let x4: u64 = ((x3 >> 58) + ((arg1[3]) + (arg2[3])));\n    let x5: u64 = ((x4 >> 58) + ((arg1[4]) + (arg2[4])));\n    let x6: u64 = ((x5 >> 58) + ((arg1[5]) + (arg2[5])));\n    let x7: u64 = ((x6 >> 58) + ((arg1[6]) + (arg2[6])));\n    let x8: u64 = ((x7 >> 58) + ((arg1[7]) + (arg2[7])));\n    let x9: u64 = ((x8 >> 58) + ((arg1[8]) + (arg2[8])));\n    let x10: u64 = ((x1 & 0x3ffffffffffffff) + (x9 >> 57));\n    let x11: u64 = ((((x10 >> 58) as fiat_p521_u1) as u64) + (x2 & 0x3ffffffffffffff));\n    let x12: u64 = (x10 & 0x3ffffffffffffff);\n    let x13: u64 = (x11 & 0x3ffffffffffffff);\n    let x14: u64 = ((((x11 >> 58) as fiat_p521_u1) as u64) + (x3 & 0x3ffffffffffffff));\n    let x15: u64 = (x4 & 0x3ffffffffffffff);\n    let x16: u64 = (x5 & 0x3ffffffffffffff);\n    let x17: u64 = (x6 & 0x3ffffffffffffff);\n    let x18: u64 = (x7 & 0x3ffffffffffffff);\n    let x19: u64 = (x8 & 0x3ffffffffffffff);\n    let x20: u64 = (x9 & 0x1ffffffffffffff);\n    out1[0] = x12;\n    out1[1] = x13;\n    out1[2] = x14;\n    out1[3] = x15;\n    out1[4] = x16;\n    out1[5] = x17;\n    out1[6] = x18;\n    out1[7] = x19;\n    out1[8] = x20;\n}",
    "display_name": "fiat_p521_carry_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/field/p521_64.rs",
    "relative_path": "p521/src/arithmetic/field/p521_64.rs",
    "file_name": "p521_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/scalar_mod_four",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Add/add",
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/double"
    ],
    "body": "    pub(crate) fn scalar_mod_four(&self, scalar: &Scalar) -> Self {\n        // Compute compute (scalar mod 4)\n        let s_mod_four = scalar[0] & 3;\n\n        // Compute all possible values of (scalar mod 4) * P\n        let zero_p = EdwardsPoint::IDENTITY;\n        let one_p = self;\n        let two_p = one_p.double();\n        let three_p = two_p.add(self);\n\n        // Under the reasonable assumption that `==` is constant time\n        // Then the whole function is constant time.\n        // This should be cheaper than calling double_and_add or a scalar mul operation\n        // as the number of possibilities are so small.\n        // XXX: This claim has not been tested (although it sounds intuitive to me)\n        let mut result = EdwardsPoint::IDENTITY;\n        result.conditional_assign(&zero_p, Choice::from((s_mod_four == 0) as u8));\n        result.conditional_assign(one_p, Choice::from((s_mod_four == 1) as u8));\n        result.conditional_assign(&two_p, Choice::from((s_mod_four == 2) as u8));\n        result.conditional_assign(&three_p, Choice::from((s_mod_four == 3) as u8));\n\n        result\n    }",
    "display_name": "scalar_mod_four",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/tests/sqrt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/sqrt",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/normalize",
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/square"
    ],
    "body": "    fn sqrt() {\n        let one = FieldElement::ONE;\n        let two = one + &one;\n        let four = two.square();\n        assert_eq!(four.sqrt().unwrap().normalize(), two.normalize());\n    }",
    "display_name": "sqrt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/extended/impl/ExtendedPoint/PartialEq/eq",
      "0.14.0_pre.1 curve/twedwards/projective/impl/ProjectiveNielsPoint/to_extended"
    ],
    "body": "    fn eq(&self, other: &ProjectiveNielsPoint) -> bool {\n        self.to_extended().eq(&other.to_extended())\n    }",
    "display_name": "eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/projective.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/encode_with_defaults",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/encode"
    ],
    "body": "    pub fn encode_with_defaults(msg: &[u8]) -> Self {\n        Self::encode::<ExpandMsgXof<sha3::Shake256>>(msg, DEFAULT_ENCODE_TO_CURVE_SUITE)\n    }",
    "display_name": "encode_with_defaults",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/CofactorGroup/is_torsion_free",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/is_torsion_free"
    ],
    "body": "    fn is_torsion_free(&self) -> Choice {\n        self.is_torsion_free()\n    }",
    "display_name": "is_torsion_free",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/elliptic_curve::PublicKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/affine/impl/elliptic_curve::PublicKey/TryFrom/try_from"
    ],
    "body": "    fn try_from(affine_point: &AffinePoint) -> Result<PublicKey> {\n        PublicKey::try_from(*affine_point)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/fiat_p384_subborrowx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p384_subborrowx_u64(\n    out1: &mut u64,\n    out2: &mut fiat_p384_u1,\n    arg1: fiat_p384_u1,\n    arg2: u64,\n    arg3: u64,\n) {\n    let x1: i128 = (((arg2 as i128) - (arg1 as i128)) - (arg3 as i128));\n    let x2: fiat_p384_i1 = ((x1 >> 64) as fiat_p384_i1);\n    let x3: u64 = ((x1 & (0xffffffffffffffff as i128)) as u64);\n    *out1 = x3;\n    *out2 = (((0x0 as fiat_p384_i2) - (x2 as fiat_p384_i2)) as fiat_p384_u1);\n}",
    "display_name": "fiat_p384_subborrowx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field/p384_64.rs",
    "relative_path": "p384/src/arithmetic/field/p384_64.rs",
    "file_name": "p384_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_subborrowx_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_cmovznz_u64",
      "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_addcarryx_u64"
    ],
    "body": "pub const fn fiat_p224_scalar_add(\n    out1: &mut fiat_p224_scalar_montgomery_domain_field_element,\n    arg1: &fiat_p224_scalar_montgomery_domain_field_element,\n    arg2: &fiat_p224_scalar_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x9, &mut x10, 0x0, x1, 0x13dd29455c5c2a3d);\n    let mut x11: u64 = 0;\n    let mut x12: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x11, &mut x12, x10, x3, 0xffff16a2e0b8f03e);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x13, &mut x14, x12, x5, 0xffffffffffffffff);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x15, &mut x16, x14, x7, 0xffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_p224_scalar_u1 = 0;\n    fiat_p224_scalar_subborrowx_u64(&mut x17, &mut x18, x16, (x8 as u64), (0x0 as u64));\n    let mut x19: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x19, x18, x9, x1);\n    let mut x20: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x20, x18, x11, x3);\n    let mut x21: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x21, x18, x13, x5);\n    let mut x22: u64 = 0;\n    fiat_p224_scalar_cmovznz_u64(&mut x22, x18, x15, x7);\n    out1[0] = x19;\n    out1[1] = x20;\n    out1[2] = x21;\n    out1[3] = x22;\n}",
    "display_name": "fiat_p224_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/to_repr",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes"
    ],
    "body": "    fn to_repr(&self) -> FieldBytes {\n        self.to_bytes()\n    }",
    "display_name": "to_repr",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&AffinePoint/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &EdwardsPoint) -> EdwardsPoint {\n        *self - other\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/From>/from",
    "statement_type": "function",
    "deps": [
      "affine/impl/AffinePoint/From>/from"
    ],
    "body": "    fn from(public_key: &PublicKey<C>) -> ProjectivePoint<C> {\n        AffinePoint::<C>::from(public_key).into()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "affine/impl/AffinePoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> Self {\n        AffinePoint {\n            x: self.x,\n            y: -self.y,\n            infinity: self.infinity,\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Reduce>/reduce"
    ],
    "body": "    fn reduce_bytes(bytes: &FieldBytes) -> Self {\n        let w = <U576 as FieldBytesEncoding<NistP521>>::decode_field_bytes(bytes);\n        Self::reduce(w)\n    }",
    "display_name": "reduce_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/points/impl/NonIdentity/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn try_from(point: DecafPoint) -> Result<Self, Error> {\n        NonIdentity::new(point).into_option().ok_or(Error)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/points.rs",
    "relative_path": "ed448-goldilocks/src/decaf/points.rs",
    "file_name": "points.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/CompressedEdwardsY/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Self {\n        Self([0u8; 57])\n    }",
    "display_name": "default",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Group/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/double"
    ],
    "body": "    fn double(&self) -> Self {\n        self.double()\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: &NonZeroScalar) -> SecretKey {\n        SecretKey {\n            inner: scalar.into(),\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/EncodePublicKey/to_public_key_der",
    "statement_type": "function",
    "deps": [],
    "body": "    fn to_public_key_der(&self) -> spki::Result<pkcs8::Document> {\n        self.public_key.to_public_key_der()\n    }",
    "display_name": "to_public_key_der",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/tests/root_of_unity_constant",
    "statement_type": "function",
    "deps": [],
    "body": "    fn root_of_unity_constant() {\n        // ROOT_OF_UNITY^{2^s} mod m == 1\n        assert_eq!(\n            Scalar::ROOT_OF_UNITY.pow_vartime([1u64 << Scalar::S, 0, 0, 0]),\n            Scalar::ONE\n        );\n\n        // MULTIPLICATIVE_GENERATOR^{t} mod m == ROOT_OF_UNITY\n        assert_eq!(\n            Scalar::MULTIPLICATIVE_GENERATOR.pow_vartime(T),\n            Scalar::ROOT_OF_UNITY\n        )\n    }",
    "display_name": "root_of_unity_constant",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/field_impl/impl/FieldElementImpl/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/field_5x52/impl/FieldElement5x52/is_odd"
    ],
    "body": "    pub fn is_odd(&self) -> Choice {\n        debug_assert!(self.normalized);\n        self.value.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field/field_impl.rs",
    "relative_path": "k256/src/arithmetic/field/field_impl.rs",
    "file_name": "field_impl.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "affine/impl/&AffinePoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> AffinePoint<C> {\n        -(*self)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/negate"
    ],
    "body": "    fn neg(self) -> Scalar {\n        self.negate()\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_prehashed",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 sign/expanded/impl/ExpandedSecretKey/sign_inner"
    ],
    "body": "    pub fn sign_prehashed(&self, ctx: &[u8], m: &[u8]) -> Result<InnerSignature, SigningError> {\n        self.sign_inner(1, ctx, m)\n    }",
    "display_name": "sign_prehashed",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/expanded.rs",
    "relative_path": "ed448-goldilocks/src/sign/expanded.rs",
    "file_name": "expanded.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/double",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/double"
    ],
    "body": "    fn double(&self) -> Self {\n        self.double()\n    }",
    "display_name": "double",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p521/src/arithmetic/scalar.rs",
    "relative_path": "p521/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_p224_mulx_u64",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_mulx_u64(out1: &mut u64, out2: &mut u64, arg1: u64, arg2: u64) {\n    let x1: u128 = ((arg1 as u128) * (arg2 as u128));\n    let x2: u64 = ((x1 & (0xffffffffffffffff as u128)) as u64);\n    let x3: u64 = ((x1 >> 64) as u64);\n    *out1 = x2;\n    *out2 = x3;\n}",
    "display_name": "fiat_p224_mulx_u64",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/field/p224_64.rs",
    "relative_path": "p224/src/arithmetic/field/p224_64.rs",
    "file_name": "p224_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero"
    ],
    "body": "    fn reduce_nonzero_bytes(bytes: &WideBytes) -> Self {\n        Self::reduce_nonzero(U512::from_be_byte_array(*bytes))\n    }",
    "display_name": "reduce_nonzero_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/signing/impl/SigningKey/try_from_rng",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn try_from_rng<R: TryCryptoRng + ?Sized>(\n        rng: &mut R,\n    ) -> core::result::Result<Self, R::Error> {\n        Ok(NonZeroScalar::try_from_rng(rng)?.into())\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/signing.rs",
    "relative_path": "k256/src/schnorr/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&EdwardsPoint/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/add"
    ],
    "body": "    fn add(self, other: &EdwardsPoint) -> EdwardsPoint {\n        self.add(other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 bench_scalar_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 test_scalar_x",
      "0.14.0_pre.8 test_scalar_y"
    ],
    "body": "fn bench_scalar_add<M: Measurement>(group: &mut BenchmarkGroup<'_, M>) {\n    let x = test_scalar_x();\n    let y = test_scalar_y();\n    group.bench_function(\"add\", |b| b.iter(|| x + y));\n}",
    "display_name": "bench_scalar_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/benches/scalar.rs",
    "relative_path": "p384/benches/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/add"
    ],
    "body": "    fn add(self, other: Scalar) -> Scalar {\n        Scalar::add(&self, &other)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/src/arithmetic/scalar.rs",
    "relative_path": "p256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/ReduceNonZero>/reduce_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "    fn reduce_nonzero(w: U384) -> Self {\n        const ORDER_MINUS_ONE: U384 = NistP384::ORDER.wrapping_sub(&U384::ONE);\n        let (r, underflow) = w.borrowing_sub(&ORDER_MINUS_ONE, Limb::ZERO);\n        let underflow = Choice::from((underflow.0 >> (Limb::BITS - 1)) as u8);\n        Self(U384::conditional_select(&w, &r, !underflow).wrapping_add(&U384::ONE))\n    }",
    "display_name": "reduce_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/scalar.rs",
    "relative_path": "p384/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre ecdsa/impl/Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre ecdsa/impl/Signature/from_bytes"
    ],
    "body": "    fn try_from(signature: SignatureBytes) -> Result<Signature> {\n        Signature::from_bytes(&signature)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/ecdsa.rs",
    "relative_path": "bign256/src/ecdsa.rs",
    "file_name": "ecdsa.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p384/src/arithmetic/field.rs",
    "relative_path": "p384/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/twedwards/extensible/impl/ExtensiblePoint/to_projective_niels",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_projective_niels(&self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: self.X + self.Y,\n            Y_minus_X: self.Y - self.X,\n            Z: self.Z + self.Z,\n            Td: self.T1 * self.T2 * FieldElement::TWO_TIMES_TWISTED_D,\n        }\n    }",
    "display_name": "to_projective_niels",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "relative_path": "ed448-goldilocks/src/curve/twedwards/extensible.rs",
    "file_name": "extensible.rs",
    "parent_folder": "twedwards"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_add",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_addcarryx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_subborrowx_u64",
      "0.14.0_pre arithmetic/field/field_impl/fiat_sm2_cmovznz_u64"
    ],
    "body": "pub const fn fiat_sm2_add(\n    out1: &mut fiat_sm2_montgomery_domain_field_element,\n    arg1: &fiat_sm2_montgomery_domain_field_element,\n    arg2: &fiat_sm2_montgomery_domain_field_element,\n) {\n    let out1 = &mut out1.0;\n    let arg1 = &arg1.0;\n    let arg2 = &arg2.0;\n    let mut x1: u64 = 0;\n    let mut x2: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x1, &mut x2, 0x0, (arg1[0]), (arg2[0]));\n    let mut x3: u64 = 0;\n    let mut x4: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x3, &mut x4, x2, (arg1[1]), (arg2[1]));\n    let mut x5: u64 = 0;\n    let mut x6: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x5, &mut x6, x4, (arg1[2]), (arg2[2]));\n    let mut x7: u64 = 0;\n    let mut x8: fiat_sm2_u1 = 0;\n    fiat_sm2_addcarryx_u64(&mut x7, &mut x8, x6, (arg1[3]), (arg2[3]));\n    let mut x9: u64 = 0;\n    let mut x10: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x9, &mut x10, 0x0, x1, 0xffffffffffffffff);\n    let mut x11: u64 = 0;\n    let mut x12: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x11, &mut x12, x10, x3, 0xffffffff00000000);\n    let mut x13: u64 = 0;\n    let mut x14: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x13, &mut x14, x12, x5, 0xffffffffffffffff);\n    let mut x15: u64 = 0;\n    let mut x16: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x15, &mut x16, x14, x7, 0xfffffffeffffffff);\n    let mut x17: u64 = 0;\n    let mut x18: fiat_sm2_u1 = 0;\n    fiat_sm2_subborrowx_u64(&mut x17, &mut x18, x16, (x8 as u64), (0x0 as u64));\n    let mut x19: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x19, x18, x9, x1);\n    let mut x20: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x20, x18, x11, x3);\n    let mut x21: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x21, x18, x13, x5);\n    let mut x22: u64 = 0;\n    fiat_sm2_cmovznz_u64(&mut x22, x18, x15, x7);\n    out1[0] = x19;\n    out1[1] = x20;\n    out1[2] = x21;\n    out1[3] = x22;\n}",
    "display_name": "fiat_sm2_add",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/arithmetic/field/sm2_64.rs",
    "relative_path": "sm2/src/arithmetic/field/sm2_64.rs",
    "file_name": "sm2_64.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_p224_scalar_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_p224_scalar_nonzero(out1: &mut u64, arg1: &[u64; 4]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | ((arg1[2]) | (arg1[3]))));\n    *out1 = x1;\n}",
    "display_name": "fiat_p224_scalar_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "relative_path": "p224/src/arithmetic/scalar/p224_scalar_64.rs",
    "file_name": "p224_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 encode_pkcs8_public_key_to_pem",
    "statement_type": "function",
    "deps": [],
    "body": "fn encode_pkcs8_public_key_to_pem() {\n    let original_public_key =\n        p256::PublicKey::from_public_key_der(&PKCS8_PUBLIC_KEY_DER[..]).unwrap();\n    let reencoded_public_key = original_public_key.to_string();\n    assert_eq!(reencoded_public_key.as_str(), PKCS8_PUBLIC_KEY_PEM);\n}",
    "display_name": "encode_pkcs8_public_key_to_pem",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p256/tests/pkcs8.rs",
    "relative_path": "p256/tests/pkcs8.rs",
    "file_name": "pkcs8.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/sub"
    ],
    "body": "    fn sub(self, other: &Scalar) -> Scalar {\n        Scalar::sub(&self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/square",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/square"
    ],
    "body": "    fn square(&self) -> Self {\n        Scalar::square(self)\n    }",
    "display_name": "square",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/field/impl/&FieldElement/Neg/neg",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/negate"
    ],
    "body": "    fn neg(self) -> FieldElement {\n        self.negate(1)\n    }",
    "display_name": "neg",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/field.rs",
    "relative_path": "k256/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [],
    "body": "    fn is_odd(&self) -> Choice {\n        Choice::from((self.0.to_words()[0] & 1) as u8)\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre secret_key/impl/SecretKey/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> FieldBytes {\n        self.inner.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/secret_key.rs",
    "relative_path": "bign256/src/secret_key.rs",
    "file_name": "secret_key.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar.rs",
    "relative_path": "bign256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/impl/Scalar/PrimeField/is_odd",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre arithmetic/scalar/impl/Scalar/is_odd"
    ],
    "body": "    fn is_odd(&self) -> Choice {\n        self.is_odd()\n    }",
    "display_name": "is_odd",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/scalar.rs",
    "relative_path": "p192/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/TryFrom>/try_from",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/TryFrom>/try_from"
    ],
    "body": "    fn try_from(public_key: &PublicKey) -> Result<VerifyingKey> {\n        Self::try_from(*public_key)\n    }",
    "display_name": "try_from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre arithmetic/scalar/scalar_impl/fiat_bign256_scalar_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn fiat_bign256_scalar_nonzero(out1: &mut u64, arg1: &[u64; 4]) {\n    let x1: u64 = ((arg1[0]) | ((arg1[1]) | ((arg1[2]) | (arg1[3]))));\n    *out1 = x1;\n}",
    "display_name": "fiat_bign256_scalar_nonzero",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "relative_path": "bign256/src/arithmetic/scalar/bign256_scalar_64.rs",
    "file_name": "bign256_scalar_64.rs",
    "parent_folder": "scalar"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/Field/invert",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert(&self) -> CtOption<Self> {\n        Scalar::invert(self)\n    }",
    "display_name": "invert",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 decaf/ops/impl/&DecafPoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/twedwards/affine/impl/AffinePoint/to_extended"
    ],
    "body": "    fn sub(self, rhs: &DecafAffinePoint) -> Self::Output {\n        self - DecafPoint(rhs.0.to_extended())\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/decaf/ops.rs",
    "relative_path": "ed448-goldilocks/src/decaf/ops.rs",
    "file_name": "ops.rs",
    "parent_folder": "decaf"
  },
  {
    "identifier": "0.14.0_pre dsa/verifying/impl/VerifyingKey/to_sec1_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_sec1_bytes(&self) -> Box<[u8]> {\n        self.public_key.to_sec1_bytes()\n    }",
    "display_name": "to_sec1_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/verifying.rs",
    "relative_path": "sm2/src/dsa/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(ProjectivePoint::IDENTITY, |a, b| a + b)\n    }",
    "display_name": "sum",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "affine/impl/AffinePoint/From>>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(affine: NonIdentity<AffinePoint<C>>) -> Self {\n        affine.to_point()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/affine.rs",
    "relative_path": "primeorder/src/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/inverse_square_root",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square_n",
      "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq",
      "0.14.0_pre.1 field/element/impl/FieldElement/square"
    ],
    "body": "    pub(crate) fn inverse_square_root(&self) -> (FieldElement, Choice) {\n        let (mut l0, mut l1, mut l2);\n\n        l1 = self.square();\n        l2 = l1 * self;\n        l1 = l2.square();\n        l2 = l1 * self;\n        l1 = l2.square_n(3);\n        l0 = l2 * l1;\n        l1 = l0.square_n(3);\n        l0 = l2 * l1;\n        l2 = l0.square_n(9);\n        l1 = l0 * l2;\n        l0 = l1 * l1;\n        l2 = l0 * self;\n        l0 = l2.square_n(18);\n        l2 = l1 * l0;\n        l0 = l2.square_n(37);\n        l1 = l2 * l0;\n        l0 = l1.square_n(37);\n        l1 = l2 * l0;\n        l0 = l1.square_n(111);\n        l2 = l1 * l0;\n        l0 = l2.square();\n        l1 = l0 * self;\n        l0 = l1.square_n(223);\n        l1 = l2 * l0;\n        l2 = l1.square();\n        l0 = l2 * self;\n\n        let is_residue = l0.ct_eq(&FieldElement::ONE);\n        (l1, is_residue)\n    }",
    "display_name": "inverse_square_root",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: ProjectivePoint) -> ProjectivePoint {\n        rhs * self\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/scalar/test/test_sanity_check_index_mut",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_sanity_check_index_mut() {\n        let mut x = Scalar::ONE;\n        x[0] = 2;\n        assert_eq!(x, Scalar::from(2u8))\n    }",
    "display_name": "test_sanity_check_index_mut",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/scalar.rs",
    "relative_path": "ed448-goldilocks/src/field/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre.1 sign/signing_key/impl/PreHasherXof/new",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn new(hasher: HashT) -> Self {\n        Self {\n            reader: hasher.finalize_xof(),\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/sign/signing_key.rs",
    "relative_path": "ed448-goldilocks/src/sign/signing_key.rs",
    "file_name": "signing_key.rs",
    "parent_folder": "sign"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/Group/is_identity",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/extended/impl/EdwardsPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Self::IDENTITY)\n    }",
    "display_name": "is_identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre dsa/signing/impl/SigningKey/from_nonzero_scalar",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre dsa/verifying/impl/VerifyingKey/new"
    ],
    "body": "    pub fn from_nonzero_scalar(distid: &DistId, secret_scalar: NonZeroScalar) -> Result<Self> {\n        let public_key = PublicKey::from_secret_scalar(&secret_scalar);\n        let verifying_key = VerifyingKey::new(distid, public_key)?;\n        Ok(Self {\n            secret_scalar,\n            verifying_key,\n        })\n    }",
    "display_name": "from_nonzero_scalar",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/dsa/signing.rs",
    "relative_path": "sm2/src/dsa/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "dsa"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/affine/impl/AffinePoint/PrimeCurveAffine/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> Self {\n        Self::IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/affine.rs",
    "relative_path": "k256/src/arithmetic/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 field/element/impl/FieldElement/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.0.ct_eq(&other.0)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/field/element.rs",
    "relative_path": "ed448-goldilocks/src/field/element.rs",
    "file_name": "element.rs",
    "parent_folder": "field"
  },
  {
    "identifier": "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre pke/encrypting/impl/EncryptingKey/encrypt_digest"
    ],
    "body": "    pub fn encrypt<R: TryCryptoRng + ?Sized>(&self, rng: &mut R, msg: &[u8]) -> Result<Vec<u8>> {\n        self.encrypt_digest::<R, Sm3>(rng, msg)\n    }",
    "display_name": "encrypt",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/sm2/src/pke/encrypting.rs",
    "relative_path": "sm2/src/pke/encrypting.rs",
    "file_name": "encrypting.rs",
    "parent_folder": "pke"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/isogeny",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 field/element/impl/FieldElement/square",
      "0.14.0_pre.1 field/element/impl/FieldElement/double",
      "0.14.0_pre.1 field/element/impl/FieldElement/invert"
    ],
    "body": "    pub(crate) fn isogeny(&self) -> Self {\n        let x = self.x;\n        let y = self.y;\n        let mut t0 = x.square(); // x^2\n        let t1 = t0 + FieldElement::ONE; // x^2+1\n        t0 -= FieldElement::ONE; // x^2-1\n        let mut t2 = y.square(); // y^2\n        t2 = t2.double(); // 2y^2\n        let t3 = x.double(); // 2x\n\n        let mut t4 = t0 * y; // y(x^2-1)\n        t4 = t4.double(); // 2y(x^2-1)\n        let xNum = t4.double(); // xNum = 4y(x^2-1)\n\n        let mut t5 = t0.square(); // x^4-2x^2+1\n        t4 = t5 + t2; // x^4-2x^2+1+2y^2\n        let xDen = t4 + t2; // xDen = x^4-2x^2+1+4y^2\n\n        t5 *= x; // x^5-2x^3+x\n        t4 = t2 * t3; // 4xy^2\n        let yNum = t4 - t5; // yNum = -(x^5-2x^3+x-4xy^2)\n\n        t4 = t1 * t2; // 2x^2y^2+2y^2\n        let yDen = t5 - t4; // yDen = x^5-2x^3+x-2x^2y^2-2y^2\n\n        Self {\n            x: xNum * xDen.invert(),\n            y: yNum * yDen.invert(),\n        }\n    }",
    "display_name": "isogeny",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/affine.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/projective/tests/projective_double_and_sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/projective/impl/ProjectivePoint/double"
    ],
    "body": "    fn projective_double_and_sub() {\n        let generator = ProjectivePoint::GENERATOR;\n        assert_eq!(generator.double() - &generator, generator);\n    }",
    "display_name": "projective_double_and_sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/projective.rs",
    "relative_path": "k256/src/arithmetic/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 arithmetic/scalar/impl/Scalar/From>/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(scalar: NonZeroScalar) -> Self {\n        *scalar.as_ref()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/arithmetic/scalar.rs",
    "relative_path": "k256/src/arithmetic/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.8 arithmetic/field/impl/FieldElement/to_bytes",
      "0.14.0_pre.8 schnorr/verifying/impl/VerifyingKey/as_affine"
    ],
    "body": "    pub fn to_bytes(&self) -> FieldBytes {\n        self.as_affine().x.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/k256/src/schnorr/verifying.rs",
    "relative_path": "k256/src/schnorr/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "schnorr"
  },
  {
    "identifier": "0.14.0_pre arithmetic/field/impl/FieldElement/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/p192/src/arithmetic/field.rs",
    "relative_path": "p192/src/arithmetic/field.rs",
    "file_name": "field.rs",
    "parent_folder": "arithmetic"
  },
  {
    "identifier": "0.14.0_pre.1 curve/edwards/extended/impl/&EdwardsPoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "0.14.0_pre.1 curve/edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    fn sub(self, other: &AffinePoint) -> EdwardsPoint {\n        *self - other.to_edwards()\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/ed448-goldilocks/src/curve/edwards/extended.rs",
    "relative_path": "ed448-goldilocks/src/curve/edwards/extended.rs",
    "file_name": "extended.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "projective/impl/ProjectivePoint/Sub>/sub",
    "statement_type": "function",
    "deps": [
      "projective/impl/ProjectivePoint/sub"
    ],
    "body": "    fn sub(self, other: &ProjectivePoint<C>) -> ProjectivePoint<C> {\n        ProjectivePoint::sub(&self, other)\n    }",
    "display_name": "sub",
    "full_path": "file:///home/lacra/git_repos/elliptic-curves/primeorder/src/projective.rs",
    "relative_path": "primeorder/src/projective.rs",
    "file_name": "projective.rs",
    "parent_folder": "src"
  }
]