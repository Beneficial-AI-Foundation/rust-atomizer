[
  {
    "identifier": "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Return the number of static points in the precomputation.\n    fn len(&self) -> usize;\n\n    /// Determine if the precomputation is empty.\n    fn is_empty(&self) -> bool;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\).\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/reduce",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order"
    ],
    "body": "    fn reduce() {\n        let biggest = Scalar::from_bytes_mod_order([0xff; 32]);\n        assert_eq!(biggest, CANONICAL_2_256_MINUS_1);\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/raw_sign_byupdate",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/ExpandedSecretKey/raw_sign_byupdate"
    ],
    "body": "pub fn raw_sign_byupdate<CtxDigest, F>(\n    esk: &ExpandedSecretKey,\n    msg_update: F,\n    verifying_key: &VerifyingKey,\n) -> Result<Signature, SignatureError>\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n    F: Fn(&mut CtxDigest) -> Result<(), SignatureError>,\n{\n    esk.raw_sign_byupdate::<CtxDigest, F>(msg_update, verifying_key)\n}",
    "display_name": "raw_sign_byupdate",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> Self;\n}\n\n/// Trait for testing if a curve point is equivalent to the identity point.\npub trait IsIdentity {\n    /// Return true if this element is the identity element of the curve.\n    fn is_identity(&self) -> bool;\n}",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> RistrettoPoint {\n        -&self\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &SecretKey {\n        &self.secret_key\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/&EdwardsPoint/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.y_plus_x;\n        let MM = &Y_minus_X * &other.y_minus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &Z2 + &Txy2d,\n            T: &Z2 - &Txy2d,\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/scalarmult_extended_point_works_both_ways",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/to_bytes"
    ],
    "body": "    fn scalarmult_extended_point_works_both_ways() {\n        let G: EdwardsPoint = constants::ED25519_BASEPOINT_POINT;\n        let s: Scalar = A_SCALAR;\n\n        let P1 = G * s;\n        let P2 = s * G;\n\n        assert!(P1.compress().to_bytes() == P2.compress().to_bytes());\n    }",
    "display_name": "scalarmult_extended_point_works_both_ways",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/add"
    ],
    "body": "    fn add() {\n        let res = Scalar52::add(&A, &B);\n        let zero = Scalar52::ZERO;\n        for i in 0..5 {\n            assert!(res[i] == zero[i]);\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/straus/impl/Straus/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 window/impl/NafLookupTable5/From/from",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_projective",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/as_extended",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/double"
    ],
    "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::backend::serial::curve_models::{\n            CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n        };\n        use crate::traits::Identity;\n        use crate::window::NafLookupTable5;\n\n        let nafs: Vec<_> = scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect();\n\n        let lookup_tables = points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let mut r = ProjectivePoint::identity();\n\n        for i in (0..256).rev() {\n            let mut t: CompletedPoint = r.double();\n\n            for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                match naf[i].cmp(&0) {\n                    Ordering::Greater => {\n                        t = &t.as_extended() + &lookup_table.select(naf[i] as usize)\n                    }\n                    Ordering::Less => t = &t.as_extended() - &lookup_table.select(-naf[i] as usize),\n                    Ordering::Equal => {}\n                }\n            }\n\n            r = t.as_projective();\n        }\n\n        Some(r.as_extended())\n    }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/optional_mixed_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/scalar_mul/precomputed_straus/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/optional"
    ],
    "body": "    pub fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: core::borrow::Borrow<Scalar>,\n        K: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.y_plus_x.zeroize();\n        self.y_minus_x.zeroize();\n        self.xy2d.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/from_bytes_highbit_is_ignored",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes"
    ],
    "body": "    fn from_bytes_highbit_is_ignored() {\n        let mut cleared_bytes = B_BYTES;\n        cleared_bytes[31] &= 127u8;\n        let with_highbit_set = FieldElement::from_bytes(&B_BYTES);\n        let without_highbit_set = FieldElement::from_bytes(&cleared_bytes);\n        assert_eq!(without_highbit_set, with_highbit_set);\n    }",
    "display_name": "from_bytes_highbit_is_ignored",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/SharedSecret/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/as_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_mul"
    ],
    "body": "    pub fn as_montgomery(&self) -> (result: Scalar52)\n    requires\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n    ensures\n        // TODO: Add proper specification for Montgomery form conversion\n        true,\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        Scalar52::montgomery_mul(self, &RR)\n    }",
    "display_name": "as_montgomery",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/PublicKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/decompress/step_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_zero",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invsqrt"
    ],
    "body": "    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as²\n        let u2 = &one + &ss; //  1 - as²    where a=-1\n        let u2_sqr = u2.square(); // (1 - as²)²\n\n        // v == ad(1+as²)² - (1-as²)²            where d=-121665/121666\n        let v = &(&(-&constants::EDWARDS_D) * &u1.square()) - &u2_sqr;\n\n        let (ok, I) = (&v * &u2_sqr).invsqrt(); // 1/sqrt(v*u_2²)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dy = &I * &(&Dx * &v); // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s²/(ad(1+as²)² - (1-as²)²))\n        let mut x = &(&s + &s) * &Dx;\n        let x_neg = x.is_negative();\n        x.conditional_negate(x_neg);\n\n        // y == (1-as²)/(1+as²)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as²) sqrt(4s²/(ad(1+as²)² - (1-as²)²)))/(1-as²)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }",
    "display_name": "step_2",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify"
    ],
    "body": "    fn verify(&self, message: &[u8], signature: &ed25519::Signature) -> Result<(), SignatureError> {\n        self.multipart_verify(&[message], signature)\n    }",
    "display_name": "verify",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/split",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn split(&self) -> [FieldElement51; 4] {\n        let mut out = [FieldElement51::ZERO; 4];\n        for i in 0..5 {\n            let a_2i   = self.0[i].extract::<0>() as u64; //\n            let b_2i   = self.0[i].extract::<1>() as u64; //\n            let a_2i_1 = self.0[i].extract::<2>() as u64; // `.\n            let b_2i_1 = self.0[i].extract::<3>() as u64; //  | pre-swapped to avoid\n            let c_2i   = self.0[i].extract::<4>() as u64; //  | a cross lane shuffle\n            let d_2i   = self.0[i].extract::<5>() as u64; // .'\n            let c_2i_1 = self.0[i].extract::<6>() as u64; //\n            let d_2i_1 = self.0[i].extract::<7>() as u64; //\n\n            out[0].0[i] = a_2i + (a_2i_1 << 26);\n            out[1].0[i] = b_2i + (b_2i_1 << 26);\n            out[2].0[i] = c_2i + (c_2i_1 << 26);\n            out[3].0[i] = d_2i + (d_2i_1 << 26);\n        }\n\n        out\n    }",
    "display_name": "split",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/variable_base/spec/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/LookupTable/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/as_radix_16",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Identity/identity",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/mul_by_pow_2"
    ],
    "body": "    pub fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n        // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n        let lookup_table = LookupTable::<CachedPoint>::from(point);\n        // Setting s = scalar, compute\n        //\n        //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n        //\n        // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n        let scalar_digits = scalar.as_radix_16();\n        // Compute s*P as\n        //\n        //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n        //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n        //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n        //\n        // We sum right-to-left.\n        let mut Q = ExtendedPoint::identity();\n        for i in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            Q = &Q + &lookup_table.select(scalar_digits[i]);\n        }\n        Q.into()\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/variable_base.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/raw_verify"
    ],
    "body": "    fn multipart_verify(\n        &self,\n        message: &[&[u8]],\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError> {\n        self.raw_verify::<Sha512>(message, signature)\n    }",
    "display_name": "multipart_verify",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/cpuid_avx2/init",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "init",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(x: u64) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/non_adjacent_form_random",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/test/non_adjacent_form_iter",
      "5.0.0_pre.0 scalar/impl/Scalar/random"
    ],
    "body": "    fn non_adjacent_form_random() {\n        let mut rng = rand::rng();\n        for _ in 0..1_000 {\n            let x = Scalar::random(&mut rng);\n            for w in &[5, 6, 7, 8] {\n                non_adjacent_form_iter(*w, &x);\n            }\n        }\n    }",
    "display_name": "non_adjacent_form_random",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/is_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/is_empty"
    ],
    "body": "    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }",
    "display_name": "is_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/test_scalar_from_int",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_scalar_from_int() {\n        let s1 = Scalar::ONE;\n\n        // For `x` in `u8`, `u16`, `u32`, `u64`, and `u128`, check that\n        // `Scalar::from(x + 1) == Scalar::from(x) + Scalar::from(1)`\n\n        let x = 0x23u8;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323u16;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323u32;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323_2323_2323u64;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323_2323_2323_2323_2323_2323_2323u128;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n    }",
    "display_name": "test_scalar_from_int",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/splat",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/reduce",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/new"
    ],
    "body": "    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> FieldElement2625x4 {\n        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }\n\n        // We don't know that the original `FieldElement51`s were\n        // fully reduced, so the odd limbs may exceed 2^25.\n        // Reduce them to be sure.\n        FieldElement2625x4(buf).reduce()\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_limbs",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51(limbs)\n    }",
    "display_name": "from_limbs",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/precomputed_straus/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/is_empty",
    "statement_type": "function",
    "deps": [],
    "body": "    fn is_empty(&self) -> bool {\n        self.static_lookup_tables.is_empty()\n    }",
    "display_name": "is_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    pub(crate) fn is_negative(&self) -> Choice {\n        let bytes = self.to_bytes();\n        (bytes[0] & 1).into()\n    }",
    "display_name": "is_negative",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/scalar_mul_by_one",
    "statement_type": "function",
    "deps": [],
    "body": "    fn scalar_mul_by_one() {\n        let test_scalar = X * Scalar::ONE;\n        for i in 0..32 {\n            assert!(test_scalar[i] == X[i]);\n        }\n    }",
    "display_name": "scalar_mul_by_one",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/SharedSecret/Drop/drop",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/vartime_double_base/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/double",
      "5.0.0_pre.0 window/impl/NafLookupTable5/select",
      "5.0.0_pre.0 scalar/impl/Scalar/non_adjacent_form",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_projective",
      "5.0.0_pre.0 window/impl/NafLookupTable8/select",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/as_extended",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 window/impl/NafLookupTable5/From/from"
    ],
    "body": "pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    let a_naf = a.non_adjacent_form(5);\n\n    #[cfg(feature = \"precomputed-tables\")]\n    let b_naf = b.non_adjacent_form(8);\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let b_naf = b.non_adjacent_form(5);\n\n    // Find starting index\n    let mut i: usize = 255;\n    for j in (0..256).rev() {\n        i = j;\n        if a_naf[i] != 0 || b_naf[i] != 0 {\n            break;\n        }\n    }\n\n    let table_A = NafLookupTable5::<ProjectiveNielsPoint>::from(A);\n    #[cfg(feature = \"precomputed-tables\")]\n    let table_B = &constants::AFFINE_ODD_MULTIPLES_OF_BASEPOINT;\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let table_B =\n        &NafLookupTable5::<ProjectiveNielsPoint>::from(&constants::ED25519_BASEPOINT_POINT);\n\n    let mut r = ProjectivePoint::identity();\n    loop {\n        let mut t = r.double();\n\n        match a_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_A.select(a_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_A.select(-a_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        match b_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_B.select(b_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_B.select(-b_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        r = t.as_projective();\n\n        if i == 0 {\n            break;\n        }\n        i -= 1;\n    }\n\n    r.as_extended()\n}",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
    "file_name": "vartime_double_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/decompress_negative_s_fails",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/decompress",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    fn decompress_negative_s_fails() {\n        // constants::d is neg, so decompression should fail as |d| != d.\n        let bad_compressed = CompressedRistretto(constants::EDWARDS_D.to_bytes());\n        assert!(bad_compressed.decompress().is_none());\n    }",
    "display_name": "decompress_negative_s_fails",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/vartime_precomputed_helper",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 multiscalar_benches/construct_points",
      "5.0.0_pre.0 multiscalar_benches/construct_scalars",
      "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul"
    ],
    "body": "    fn vartime_precomputed_helper<M: Measurement>(\n        c: &mut BenchmarkGroup<M>,\n        dynamic_fraction: f64,\n    ) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            let bench_id = BenchmarkId::new(\n                \"Variable-time mixed-base\",\n                format!(\n                    \"(size: {:?}), ({:.0}pct dyn)\",\n                    multiscalar_size,\n                    100.0 * dynamic_fraction\n                ),\n            );\n\n            c.bench_with_input(bench_id, &multiscalar_size, move |b, &&total_size| {\n                let dynamic_size = ((total_size as f64) * dynamic_fraction) as usize;\n                let static_size = total_size - dynamic_size;\n\n                let static_points = construct_points(static_size);\n                let dynamic_points = construct_points(dynamic_size);\n                let precomp = VartimeEdwardsPrecomputation::new(static_points);\n                // Rerandomize the scalars for every call to prevent\n                // false timings from better caching (e.g., the CPU\n                // cache lifts exactly the right table entries for the\n                // benchmark into the highest cache levels).  Timings\n                // should be independent of points so we don't\n                // randomize them.\n                b.iter_batched(\n                    || {\n                        (\n                            construct_scalars(static_size),\n                            construct_scalars(dynamic_size),\n                        )\n                    },\n                    |(static_scalars, dynamic_scalars)| {\n                        precomp.vartime_mixed_multiscalar_mul(\n                            &static_scalars,\n                            &dynamic_scalars,\n                            &dynamic_points,\n                        )\n                    },\n                    BatchSize::SmallInput,\n                );\n            });\n        }\n    }",
    "display_name": "vartime_precomputed_helper",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/square_and_negate_D",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn square_and_negate_D(&self) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let x0_2 = x0.shl::<1>();\n        let x1_2 = x1.shl::<1>();\n        let x2_2 = x2.shl::<1>();\n        let x3_2 = x3.shl::<1>();\n        let x4_2 = x4.shl::<1>();\n        let x5_2 = x5.shl::<1>();\n        let x6_2 = x6.shl::<1>();\n        let x7_2 = x7.shl::<1>();\n\n        let x5_19 = m_lo(v19, x5);\n        let x6_19 = m_lo(v19, x6);\n        let x7_19 = m_lo(v19, x7);\n        let x8_19 = m_lo(v19, x8);\n        let x9_19 = m_lo(v19, x9);\n\n        let mut z0 = m(x0,   x0) + m(x2_2, x8_19) + m(x4_2, x6_19) + ((m(x1_2, x9_19) +   m(x3_2, x7_19) +    m(x5,   x5_19)).shl::<1>());\n        let mut z1 = m(x0_2, x1) + m(x3_2, x8_19) + m(x5_2, x6_19) +                    ((m(x2,   x9_19) +    m(x4,   x7_19)).shl::<1>());\n        let mut z2 = m(x0_2, x2) + m(x1_2,    x1) + m(x4_2, x8_19) +   m(x6,   x6_19) + ((m(x3_2, x9_19) +    m(x5_2, x7_19)).shl::<1>());\n        let mut z3 = m(x0_2, x3) + m(x1_2,    x2) + m(x5_2, x8_19) +                    ((m(x4,   x9_19) +    m(x6,   x7_19)).shl::<1>());\n        let mut z4 = m(x0_2, x4) + m(x1_2,  x3_2) + m(x2,      x2) +   m(x6_2, x8_19) + ((m(x5_2, x9_19) +    m(x7,   x7_19)).shl::<1>());\n        let mut z5 = m(x0_2, x5) + m(x1_2,    x4) + m(x2_2,    x3) +   m(x7_2, x8_19)                    +  ((m(x6,   x9_19)).shl::<1>());\n        let mut z6 = m(x0_2, x6) + m(x1_2,  x5_2) + m(x2_2,    x4) +   m(x3_2,    x3) +   m(x8,   x8_19) +  ((m(x7_2, x9_19)).shl::<1>());\n        let mut z7 = m(x0_2, x7) + m(x1_2,    x6) + m(x2_2,    x5) +   m(x3_2,    x4)                    +  ((m(x8,   x9_19)).shl::<1>());\n        let mut z8 = m(x0_2, x8) + m(x1_2,  x7_2) + m(x2_2,    x6) +   m(x3_2,  x5_2) +   m(x4,      x4) +  ((m(x9,   x9_19)).shl::<1>());\n        let mut z9 = m(x0_2, x9) + m(x1_2,    x8) + m(x2_2,    x7) +   m(x3_2,    x6) +   m(x4_2,    x5)                                 ;\n\n        // The biggest z_i is bounded as z_i < 249*2^(51 + 2*b);\n        // if b < 1.5 we get z_i < 4485585228861014016.\n        //\n        // The limbs of the multiples of p are bounded above by\n        //\n        // 0x3fffffff << 37 = 9223371899415822336 < 2^63\n        //\n        // and below by\n        //\n        // 0x1fffffff << 37 = 4611685880988434432\n        //                  > 4485585228861014016\n        //\n        // So these multiples of p are big enough to avoid underflow\n        // in subtraction, and small enough to fit within u64\n        // with room for a carry.\n\n        let low__p37 = u64x4::splat(0x3ffffed << 37);\n        let even_p37 = u64x4::splat(0x3ffffff << 37);\n        let odd__p37 = u64x4::splat(0x1ffffff << 37);\n\n        let negate_D = |x: u64x4, p: u64x4| -> u64x4 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(x.into(), (p - x).into(), D_LANES64 as i32).into()\n            }\n        };\n\n        z0 = negate_D(z0, low__p37);\n        z1 = negate_D(z1, odd__p37);\n        z2 = negate_D(z2, even_p37);\n        z3 = negate_D(z3, odd__p37);\n        z4 = negate_D(z4, even_p37);\n        z5 = negate_D(z5, odd__p37);\n        z6 = negate_D(z6, even_p37);\n        z7 = negate_D(z7, odd__p37);\n        z8 = negate_D(z8, even_p37);\n        z9 = negate_D(z9, odd__p37);\n\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }",
    "display_name": "square_and_negate_D",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/is_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/scalar_mul/precomputed_straus/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/is_empty"
    ],
    "body": "    pub fn is_empty(&self) -> bool {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.is_empty(),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.is_empty(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.is_empty(),\n        }\n    }",
    "display_name": "is_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto_benches/ristretto_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto_benches/decompress",
      "5.0.0_pre.0 ristretto_benches/double_and_compress_batch",
      "5.0.0_pre.0 ristretto_benches/compress"
    ],
    "body": "    pub(crate) fn ristretto_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"ristretto benches\");\n\n        compress(&mut g);\n        decompress(&mut g);\n        double_and_compress_batch(&mut g);\n    }",
    "display_name": "ristretto_benches",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectiveNielsPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectiveNielsPoint{{\\n\\tY_plus_X: {:?},\\n\\tY_minus_X: {:?},\\n\\tZ: {:?},\\n\\tT2d: {:?}\\n}}\",\n            &self.Y_plus_X, &self.Y_minus_X, &self.Z, &self.T2d\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/double",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_projective"
    ],
    "body": "    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        for _ in 0..(k - 1) {\n            r = s.double();\n            s = r.as_projective();\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        s.double().as_extended()\n    }",
    "display_name": "mul_by_pow_2",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/rand_prime_order_point",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base"
    ],
    "body": "    fn rand_prime_order_point<R: CryptoRng + ?Sized>(rng: &mut R) -> EdwardsPoint {\n        let s: Scalar = Scalar::random(rng);\n        EdwardsPoint::mul_base(&s)\n    }",
    "display_name": "rand_prime_order_point",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/invert"
    ],
    "body": "    fn invert() {\n        let inv_X = X.invert();\n        assert_eq!(inv_X, XINV);\n        let should_be_one = inv_X * X;\n        assert_eq!(should_be_one, Scalar::ONE);\n    }",
    "display_name": "invert",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul"
    ],
    "body": "    fn mul() {\n        let res = Scalar52::mul(&X, &Y);\n        for i in 0..5 {\n            assert!(res[i] == XY[i]);\n        }\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/conditional_negate",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_negate() {\n        let one = FieldElement::ONE;\n        let minus_one = FieldElement::MINUS_ONE;\n        let mut x = one;\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(0));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, one);\n    }",
    "display_name": "conditional_negate",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, _index: usize) -> &u64 {\n        &(self.0[_index])\n    }",
    "display_name": "index",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/VartimeMultiscalarMul/optional_multiscalar_mul"
    ],
    "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<RistrettoPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<RistrettoPoint>>,\n    {\n        let extended_points = points.into_iter().map(|opt_P| opt_P.map(|P| P.0));\n\n        EdwardsPoint::optional_multiscalar_mul(scalars, extended_points).map(RistrettoPoint)\n    }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/Neg/neg",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/reduce"
    ],
    "body": "    fn neg(self) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            P_TIMES_16_LO - self.0[0],\n            P_TIMES_16_HI - self.0[1],\n            P_TIMES_16_HI - self.0[2],\n            P_TIMES_16_HI - self.0[3],\n            P_TIMES_16_HI - self.0[4],\n        ])\n        .reduce()\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/Verifier/verify"
    ],
    "body": "    fn verify(&self, message: &[u8], signature: &Signature) -> Result<(), SignatureError> {\n        self.verifying_key.verify(message, signature)\n    }",
    "display_name": "verify",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Identity/identity"
    ],
    "body": "    fn default() -> ExtendedPoint {\n        ExtendedPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(x: u8) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        s_bytes[0] = x;\n        Scalar { bytes: s_bytes }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> EdwardsPoint {\n        -&self\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/negate_lazy",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn negate_lazy(&self) -> FieldElement2625x4 {\n        // The limbs of self are bounded with b < 0.999, while the\n        // smallest limb of 2*p is 67108845 > 2^{26+0.9999}, so\n        // underflows are not possible.\n        FieldElement2625x4([\n            P_TIMES_2_LO - self.0[0],\n            P_TIMES_2_HI - self.0[1],\n            P_TIMES_2_HI - self.0[2],\n            P_TIMES_2_HI - self.0[3],\n            P_TIMES_2_HI - self.0[4],\n        ])\n    }",
    "display_name": "negate_lazy",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/vartime_precomputed_vs_nonprecomputed_multiscalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/is_empty",
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/len"
    ],
    "body": "    fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let static_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let check_scalar: Scalar = static_scalars\n            .iter()\n            .chain(dynamic_scalars.iter())\n            .map(|s| s * s)\n            .sum();\n\n        let static_points = static_scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n        let dynamic_points = dynamic_scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let precomputation = VartimeEdwardsPrecomputation::new(static_points.iter());\n\n        assert_eq!(precomputation.len(), 128);\n        assert!(!precomputation.is_empty());\n\n        let P = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        use crate::traits::VartimeMultiscalarMul;\n        let Q = EdwardsPoint::vartime_multiscalar_mul(\n            static_scalars.iter().chain(dynamic_scalars.iter()),\n            static_points.iter().chain(dynamic_points.iter()),\n        );\n\n        let R = EdwardsPoint::mul_base(&check_scalar);\n\n        assert_eq!(P.compress(), R.compress());\n        assert_eq!(Q.compress(), R.compress());\n    }",
    "display_name": "vartime_precomputed_vs_nonprecomputed_multiscalar",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/m",
    "statement_type": "function",
    "deps": [],
    "body": "        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }",
    "display_name": "m",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/coset4",
    "statement_type": "function",
    "deps": [],
    "body": "    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
    "display_name": "coset4",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/ValidityCheck/is_valid",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/ValidityCheck/is_valid"
    ],
    "body": "    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }",
    "display_name": "is_valid",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint16_vs_mul_by_pow_2_4",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint16_vs_mul_by_pow_2_4() {\n        let bp16 = constants::ED25519_BASEPOINT_POINT.mul_by_pow_2(4);\n        assert_eq!(bp16.compress(), BASE16_CMPRSSD);\n    }",
    "display_name": "basepoint16_vs_mul_by_pow_2_4",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/decompress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    fn decompress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B_comp = &constants::ED25519_BASEPOINT_COMPRESSED;\n        c.bench_function(\"EdwardsPoint decompression\", move |b| {\n            b.iter(|| B_comp.decompress().unwrap())\n        });\n    }",
    "display_name": "decompress",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::ED25519_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::ED25519_BASEPOINT_TABLE\n        }\n    }",
    "display_name": "mul_base",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/edwards_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards_benches/decompress",
      "5.0.0_pre.0 edwards_benches/consttime_fixed_base_scalar_mul",
      "5.0.0_pre.0 edwards_benches/compress",
      "5.0.0_pre.0 edwards_benches/consttime_variable_base_scalar_mul",
      "5.0.0_pre.0 edwards_benches/vartime_double_base_scalar_mul",
      "5.0.0_pre.0 edwards_benches/hash_to_curve",
      "5.0.0_pre.0 edwards_benches/compress_batch"
    ],
    "body": "    pub(crate) fn edwards_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"edwards benches\");\n\n        compress(&mut g);\n        decompress(&mut g);\n        #[cfg(feature = \"alloc\")]\n        compress_batch(&mut g);\n        consttime_fixed_base_scalar_mul(&mut g);\n        consttime_variable_base_scalar_mul(&mut g);\n        vartime_double_base_scalar_mul(&mut g);\n        hash_to_curve(&mut g);\n    }",
    "display_name": "edwards_benches",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/main",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/invert",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/from_bytes"
    ],
    "body": "fn main()\n{\n    // Test scalar creation from bytes\n    let test_bytes: [u8; 32] = [\n        42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n\n    let scalar = Scalar52::from_bytes(&test_bytes);\n    let inv_scalar = scalar.invert();\n}",
    "display_name": "main",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/encoding_is_canonical",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    fn encoding_is_canonical() {\n        // Encode 1 wrongly as 1 + (2^255 - 19) = 2^255 - 18\n        let one_encoded_wrongly_bytes: [u8; 32] = [\n            0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0x7f,\n        ];\n        // Decode to a field element\n        let one = FieldElement::from_bytes(&one_encoded_wrongly_bytes);\n        // .. then check that the encoding is correct\n        let one_bytes = one.to_bytes();\n        assert_eq!(one_bytes[0], 1);\n        for byte in &one_bytes[1..] {\n            assert_eq!(*byte, 0);\n        }\n    }",
    "display_name": "encoding_is_canonical",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 function_with_where_clause",
    "statement_type": "function",
    "deps": [],
    "body": "fn function_with_where_clause<T>(a: T, b: T) -> T::Output\nwhere\n    T: Copy + core::ops::Sub,\n{\n    a - b\n}",
    "display_name": "function_with_where_clause",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/compress_batch",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/random",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress_batch"
    ],
    "body": "    fn compress_batch<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch EdwardsPoint compression\", batch_size),\n                &batch_size,\n                |b, &size| {\n                    let mut rng = OsRng.unwrap_err();\n                    let points: Vec<EdwardsPoint> =\n                        (0..size).map(|_| EdwardsPoint::random(&mut rng)).collect();\n                    b.iter(|| EdwardsPoint::compress_batch(&points));\n                },\n            );\n        }\n    }",
    "display_name": "compress_batch",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/&ExtendedPoint/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &CachedPoint) -> ExtendedPoint {\n        self + &(-other)\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/&FieldElement2625x4/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: &FieldElement2625x4) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let (y0, y1) = unpack_pair(rhs.0[0]);\n        let (y2, y3) = unpack_pair(rhs.0[1]);\n        let (y4, y5) = unpack_pair(rhs.0[2]);\n        let (y6, y7) = unpack_pair(rhs.0[3]);\n        let (y8, y9) = unpack_pair(rhs.0[4]);\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let y1_19 = m_lo(v19, y1); // This fits in a u32\n        let y2_19 = m_lo(v19, y2); // iff 26 + b + lg(19) < 32\n        let y3_19 = m_lo(v19, y3); // if  b < 32 - 26 - 4.248 = 1.752\n        let y4_19 = m_lo(v19, y4);\n        let y5_19 = m_lo(v19, y5);\n        let y6_19 = m_lo(v19, y6);\n        let y7_19 = m_lo(v19, y7);\n        let y8_19 = m_lo(v19, y8);\n        let y9_19 = m_lo(v19, y9);\n\n        let x1_2 = x1 + x1; // This fits in a u32 iff 25 + b + 1 < 32\n        let x3_2 = x3 + x3; //                    iff b < 6\n        let x5_2 = x5 + x5;\n        let x7_2 = x7 + x7;\n        let x9_2 = x9 + x9;\n\n        let z0 = m(x0, y0) + m(x1_2, y9_19) + m(x2, y8_19) + m(x3_2, y7_19) + m(x4, y6_19) + m(x5_2, y5_19) + m(x6, y4_19) + m(x7_2, y3_19) + m(x8, y2_19) + m(x9_2, y1_19);\n        let z1 = m(x0, y1) + m(x1,      y0) + m(x2, y9_19) + m(x3,   y8_19) + m(x4, y7_19) + m(x5,   y6_19) + m(x6, y5_19) + m(x7,   y4_19) + m(x8, y3_19) + m(x9,   y2_19);\n        let z2 = m(x0, y2) + m(x1_2,    y1) + m(x2,    y0) + m(x3_2, y9_19) + m(x4, y8_19) + m(x5_2, y7_19) + m(x6, y6_19) + m(x7_2, y5_19) + m(x8, y4_19) + m(x9_2, y3_19);\n        let z3 = m(x0, y3) + m(x1,      y2) + m(x2,    y1) + m(x3,      y0) + m(x4, y9_19) + m(x5,   y8_19) + m(x6, y7_19) + m(x7,   y6_19) + m(x8, y5_19) + m(x9,   y4_19);\n        let z4 = m(x0, y4) + m(x1_2,    y3) + m(x2,    y2) + m(x3_2,    y1) + m(x4,    y0) + m(x5_2, y9_19) + m(x6, y8_19) + m(x7_2, y7_19) + m(x8, y6_19) + m(x9_2, y5_19);\n        let z5 = m(x0, y5) + m(x1,      y4) + m(x2,    y3) + m(x3,      y2) + m(x4,    y1) + m(x5,      y0) + m(x6, y9_19) + m(x7,   y8_19) + m(x8, y7_19) + m(x9,   y6_19);\n        let z6 = m(x0, y6) + m(x1_2,    y5) + m(x2,    y4) + m(x3_2,    y3) + m(x4,    y2) + m(x5_2,    y1) + m(x6,    y0) + m(x7_2, y9_19) + m(x8, y8_19) + m(x9_2, y7_19);\n        let z7 = m(x0, y7) + m(x1,      y6) + m(x2,    y5) + m(x3,      y4) + m(x4,    y3) + m(x5,      y2) + m(x6,    y1) + m(x7,      y0) + m(x8, y9_19) + m(x9,   y8_19);\n        let z8 = m(x0, y8) + m(x1_2,    y7) + m(x2,    y6) + m(x3_2,    y5) + m(x4,    y4) + m(x5_2,    y3) + m(x6,    y2) + m(x7_2,    y1) + m(x8,    y0) + m(x9_2, y9_19);\n        let z9 = m(x0, y9) + m(x1,      y8) + m(x2,    y7) + m(x3,      y6) + m(x4,    y5) + m(x5,      y4) + m(x6,    y3) + m(x7,      y2) + m(x8,    y1) + m(x9,      y0);\n\n        // The bounds on z[i] are the same as in the serial 32-bit code\n        // and the comment below is copied from there:\n\n        // How big is the contribution to z[i+j] from x[i], y[j]?\n        //\n        // Using the bounds above, we get:\n        //\n        // i even, j even:   x[i]*y[j] <   2^(26+b)*2^(26+b) = 2*2^(51+2*b)\n        // i  odd, j even:   x[i]*y[j] <   2^(25+b)*2^(26+b) = 1*2^(51+2*b)\n        // i even, j  odd:   x[i]*y[j] <   2^(26+b)*2^(25+b) = 1*2^(51+2*b)\n        // i  odd, j  odd: 2*x[i]*y[j] < 2*2^(25+b)*2^(25+b) = 1*2^(51+2*b)\n        //\n        // We perform inline reduction mod p by replacing 2^255 by 19\n        // (since 2^255 - 19 = 0 mod p).  This adds a factor of 19, so\n        // we get the bounds (z0 is the biggest one, but calculated for\n        // posterity here in case finer estimation is needed later):\n        //\n        //  z0 < ( 2 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 249*2^(51 + 2*b)\n        //  z1 < ( 1 +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 154*2^(51 + 2*b)\n        //  z2 < ( 2 +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 195*2^(51 + 2*b)\n        //  z3 < ( 1 +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 118*2^(51 + 2*b)\n        //  z4 < ( 2 +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 141*2^(51 + 2*b)\n        //  z5 < ( 1 +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) =  82*2^(51 + 2*b)\n        //  z6 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) =  87*2^(51 + 2*b)\n        //  z7 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 )*2^(51 + 2b) =  46*2^(51 + 2*b)\n        //  z8 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 )*2^(51 + 2b) =  33*2^(51 + 2*b)\n        //  z9 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   )*2^(51 + 2b) =  10*2^(51 + 2*b)\n        //\n        // So z[0] fits into a u64 if 51 + 2*b + lg(249) < 64\n        //                         if b < 2.5.\n\n        // In fact this bound is slightly sloppy, since it treats both\n        // inputs x and y as being bounded by the same parameter b,\n        // while they are in fact bounded by b_x and b_y, and we\n        // already require that b_y < 1.75 in order to fit the\n        // multiplications by 19 into a u32.  The tighter bound on b_y\n        // means we could get a tighter bound on the outputs, or a\n        // looser bound on b_x.\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/&CachedPoint/Neg/neg",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/shuffle",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/blend",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/negate_lazy"
    ],
    "body": "    fn neg(self) -> CachedPoint {\n        let swapped = self.0.shuffle(Shuffle::BACD);\n        CachedPoint(swapped.blend(swapped.negate_lazy(), Lanes::D))\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_base",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery"
    ],
    "body": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        EdwardsPoint::mul_base(scalar).to_montgomery()\n    }",
    "display_name": "mul_base",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/&FieldElement51/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.0;\n        let b: &[u64; 5] = &_rhs.0;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        // Multiply to get 128-bit coefficients of output\n        let     c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(a[1], b4_19);\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0],  b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(a[2], b4_19);\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1],  b[1]) + m(a[0],  b[2]) + m(a[4], b3_19) + m(a[3], b4_19);\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2],  b[1]) + m(a[1],  b[2]) + m(a[0],  b[3]) + m(a[4], b4_19);\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3],  b[1]) + m(a[2],  b[2]) + m(a[1],  b[3]) + m(a[0] , b[4]);\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));\n        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));\n        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));\n        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));\n        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n        let mut out = [0u64; 5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51(out)\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/&RistrettoPoint/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, scalar: &'a Scalar) -> RistrettoPoint {\n        RistrettoPoint(self.0 * scalar)\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/optional_mixed_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/optional_mixed_multiscalar_mul"
    ],
    "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/extended_point_equality_handles_scaling",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn extended_point_equality_handles_scaling() {\n        let mut two_bytes = [0u8; 32];\n        two_bytes[0] = 2;\n        let id1 = EdwardsPoint::identity();\n        let id2 = EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::from_bytes(&two_bytes),\n            Z: FieldElement::from_bytes(&two_bytes),\n            T: FieldElement::ZERO,\n        };\n        assert!(bool::from(id1.ct_eq(&id2)));\n    }",
    "display_name": "extended_point_equality_handles_scaling",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/SharedSecret/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/impl/SharedSecret/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix32/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/&Scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/add",
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack"
    ],
    "body": "    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/ExpandedSecretKey/raw_sign",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/ExpandedSecretKey/raw_sign_byupdate"
    ],
    "body": "    pub(crate) fn raw_sign<CtxDigest>(\n        &self,\n        message: &[&[u8]],\n        verifying_key: &VerifyingKey,\n    ) -> Signature\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n    {\n        // OK unwrap, update can't fail.\n        self.raw_sign_byupdate(\n            |h: &mut CtxDigest| {\n                message.iter().for_each(|slice| h.update(slice));\n                Ok(())\n            },\n            verifying_key,\n        )\n        .unwrap()\n    }",
    "display_name": "raw_sign",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/consttime_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 multiscalar_benches/construct_points",
      "5.0.0_pre.0 multiscalar_benches/construct_scalars",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/MultiscalarMul/multiscalar_mul"
    ],
    "body": "    fn consttime_multiscalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Constant-time variable-base multiscalar multiplication\",\n                    *multiscalar_size,\n                ),\n                &multiscalar_size,\n                |b, &&size| {\n                    let points = construct_points(size);\n                    // This is supposed to be constant-time, but we might as well\n                    // rerandomize the scalars for every call just in case.\n                    b.iter_batched(\n                        || construct_scalars(size),\n                        |scalars| EdwardsPoint::multiscalar_mul(&scalars, &points),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }",
    "display_name": "consttime_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce"
    ],
    "body": "    pub fn from_montgomery(&self) -> Scalar52 {\n        let mut limbs = [0u128; 9];\n        for i in 0..5 {\n            limbs[i] = self[i] as u128;\n        }\n        Scalar52::montgomery_reduce(&limbs)\n    }",
    "display_name": "from_montgomery",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/precomputed_straus/spec/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/NafLookupTable8/From/from"
    ],
    "body": "        fn new<I>(static_points: I) -> Self\n        where\n            I: IntoIterator,\n            I::Item: Borrow<EdwardsPoint>,\n        {\n            Self {\n                static_lookup_tables: static_points\n                    .into_iter()\n                    .map(|P| NafLookupTable8::<CachedPoint>::from(P.borrow()))\n                    .collect(),\n            }\n        }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/ValidityCheck/is_valid",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "    fn is_valid(&self) -> bool {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        let ZZZZ = ZZ.square();\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n\n        lhs == rhs\n    }",
    "display_name": "is_valid",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/StaticSecret/random_from_rng",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn random_from_rng<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {\n        // The secret key is random bytes. Clamping is done later.\n        let mut bytes = [0u8; 32];\n        csprng.fill_bytes(&mut bytes);\n        StaticSecret(bytes)\n    }",
    "display_name": "random_from_rng",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/generate",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/from_bytes"
    ],
    "body": "    pub fn generate<R: CryptoRng + ?Sized>(csprng: &mut R) -> SigningKey {\n        let mut secret = SecretKey::default();\n        csprng.fill_bytes(&mut secret);\n        Self::from_bytes(&secret)\n    }",
    "display_name": "generate",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/pow2k",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/pow22501"
    ],
    "body": "    pub(crate) fn invert(&self) -> FieldElement {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);            // 254..5\n        let t21 = &t20 * &t3;              // 254..5,3,1,0\n\n        t21\n    }",
    "display_name": "invert",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_benches/scalar_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards_benches/edwards_benches",
      "5.0.0_pre.0 montgomery_benches/montgomery_benches",
      "5.0.0_pre.0 ristretto_benches/ristretto_benches",
      "5.0.0_pre.0 multiscalar_benches/multiscalar_benches",
      "5.0.0_pre.0 scalar_benches/scalar_arith",
      "5.0.0_pre.0 scalar_benches/batch_scalar_inversion"
    ],
    "body": "    pub(crate) fn scalar_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"scalar benches\");\n\n        scalar_arith(&mut g);\n        batch_scalar_inversion(&mut g);\n    }",
    "display_name": "scalar_benches",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
    "display_name": "mul_clamped",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/is_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/is_empty"
    ],
    "body": "    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }",
    "display_name": "is_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/is_torsion_free",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity"
    ],
    "body": "    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER).is_identity()\n    }",
    "display_name": "is_torsion_free",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_benches/scalar_arith",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/invert",
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn scalar_arith<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let mut rng = rng();\n\n        c.bench_function(\"Scalar inversion\", |b| {\n            let s = Scalar::from(897987897u64).invert();\n            b.iter(|| s.invert());\n        });\n        c.bench_function(\"Scalar addition\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a + b,\n                BatchSize::SmallInput,\n            );\n        });\n        c.bench_function(\"Scalar subtraction\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a - b,\n                BatchSize::SmallInput,\n            );\n        });\n        c.bench_function(\"Scalar multiplication\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a * b,\n                BatchSize::SmallInput,\n            );\n        });\n    }",
    "display_name": "scalar_arith",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/square_internal"
    ],
    "body": "    pub fn montgomery_square(&self) -> (result: Scalar52)\n    requires\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }",
    "display_name": "montgomery_square",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/mul_by_pow_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/double"
    ],
    "body": "    pub fn mul_by_pow_2(&self, k: u32) -> ExtendedPoint {\n        let mut tmp: ExtendedPoint = *self;\n        for _ in 0..k {\n            tmp = tmp.double();\n        }\n        tmp\n    }",
    "display_name": "mul_by_pow_2",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn vartime_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator,\n        K::Item: Borrow<Self::Point>,\n    {\n        Self::optional_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            dynamic_scalars,\n            dynamic_points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
    "display_name": "vartime_mixed_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/straus_optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/scalar_mul/straus/impl/Straus/VartimeMultiscalarMul/optional_multiscalar_mul",
      "5.0.0_pre.0 backend/get_selected_backend"
    ],
    "body": "pub fn straus_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => {\n            vector::scalar_mul::straus::spec_avx2::Straus::optional_multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::optional_multiscalar_mul::<\n                I,\n                J,\n            >(scalars, points)\n        }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::optional_multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
    "display_name": "straus_optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/&Scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack",
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/sub"
    ],
    "body": "    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base"
    ],
    "body": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/is_identity",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity"
    ],
    "body": "    fn is_identity() {\n        assert!(EdwardsPoint::identity().is_identity());\n        assert!(!constants::ED25519_BASEPOINT_POINT.is_identity());\n    }",
    "display_name": "is_identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/raw_verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signature/impl/InternalSignature/TryFrom/try_from",
      "3.0.0_pre.0 verifying/impl/RCompute/compute"
    ],
    "body": "    pub(crate) fn raw_verify<CtxDigest>(\n        &self,\n        message: &[&[u8]],\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError>\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n    {\n        let signature = InternalSignature::try_from(signature)?;\n\n        let expected_R = RCompute::<CtxDigest>::compute(self, signature, None, message);\n        if expected_R == signature.R {\n            Ok(())\n        } else {\n            Err(InternalError::Verify.into())\n        }\n    }",
    "display_name": "raw_verify",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(self) -> (s: [u8; 32])\n    // DIFF-SPEC-3: we give a name to the output: \"s\"\n    // SPECIFICATION: packing keeps the same nat value\n    ensures bytes_to_nat(&s) == to_nat(&self.limbs)\n    {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.limbs[ 0] >>  0)                      as u8;\n        s[ 1] =  (self.limbs[ 0] >>  8)                      as u8;\n        s[ 2] =  (self.limbs[ 0] >> 16)                      as u8;\n        s[ 3] =  (self.limbs[ 0] >> 24)                      as u8;\n        s[ 4] =  (self.limbs[ 0] >> 32)                      as u8;\n        s[ 5] =  (self.limbs[ 0] >> 40)                      as u8;\n        s[ 6] = ((self.limbs[ 0] >> 48) | (self.limbs[ 1] << 4)) as u8;\n        s[ 7] =  (self.limbs[ 1] >>  4)                      as u8;\n        s[ 8] =  (self.limbs[ 1] >> 12)                      as u8;\n        s[ 9] =  (self.limbs[ 1] >> 20)                      as u8;\n        s[10] =  (self.limbs[ 1] >> 28)                      as u8;\n        s[11] =  (self.limbs[ 1] >> 36)                      as u8;\n        s[12] =  (self.limbs[ 1] >> 44)                      as u8;\n        s[13] =  (self.limbs[ 2] >>  0)                      as u8;\n        s[14] =  (self.limbs[ 2] >>  8)                      as u8;\n        s[15] =  (self.limbs[ 2] >> 16)                      as u8;\n        s[16] =  (self.limbs[ 2] >> 24)                      as u8;\n        s[17] =  (self.limbs[ 2] >> 32)                      as u8;\n        s[18] =  (self.limbs[ 2] >> 40)                      as u8;\n        s[19] = ((self.limbs[ 2] >> 48) | (self.limbs[ 3] << 4)) as u8;\n        s[20] =  (self.limbs[ 3] >>  4)                      as u8;\n        s[21] =  (self.limbs[ 3] >> 12)                      as u8;\n        s[22] =  (self.limbs[ 3] >> 20)                      as u8;\n        s[23] =  (self.limbs[ 3] >> 28)                      as u8;\n        s[24] =  (self.limbs[ 3] >> 36)                      as u8;\n        s[25] =  (self.limbs[ 3] >> 44)                      as u8;\n        s[26] =  (self.limbs[ 4] >>  0)                      as u8;\n        s[27] =  (self.limbs[ 4] >>  8)                      as u8;\n        s[28] =  (self.limbs[ 4] >> 16)                      as u8;\n        s[29] =  (self.limbs[ 4] >> 24)                      as u8;\n        s[30] =  (self.limbs[ 4] >> 32)                      as u8;\n        s[31] =  (self.limbs[ 4] >> 40)                      as u8;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 impl/Struct/member_function_with_const_arg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn member_function_with_const_arg<const N: u32>(self) -> u32 {\n        self.a - N\n    }",
    "display_name": "member_function_with_const_arg",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/Drop/drop",
    "statement_type": "function",
    "deps": [],
    "body": "    fn drop(&mut self) {\n        self.secret_key.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/&EdwardsPoint/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.y_minus_x;\n        let MP = &Y_minus_X * &other.y_plus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &Z2 - &Txy2d,\n            T: &Z2 + &Txy2d,\n        }\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/scalarmult_ristrettopoint_works_both_ways",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/as_bytes",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress"
    ],
    "body": "    fn scalarmult_ristrettopoint_works_both_ways() {\n        let P = constants::RISTRETTO_BASEPOINT_POINT;\n        let s = Scalar::from(999u64);\n\n        let P1 = P * s;\n        let P2 = s * P;\n\n        assert!(P1.compress().as_bytes() == P2.compress().as_bytes());\n    }",
    "display_name": "scalarmult_ristrettopoint_works_both_ways",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/encodings_of_small_multiples_of_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity"
    ],
    "body": "    fn encodings_of_small_multiples_of_basepoint() {\n        // Table of encodings of i*basepoint\n        // Generated using ristretto.sage\n        let compressed = [\n            CompressedRistretto([\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0,\n            ]),\n            CompressedRistretto([\n                226, 242, 174, 10, 106, 188, 78, 113, 168, 132, 169, 97, 197, 0, 81, 95, 88, 227,\n                11, 106, 165, 130, 221, 141, 182, 166, 89, 69, 224, 141, 45, 118,\n            ]),\n            CompressedRistretto([\n                106, 73, 50, 16, 247, 73, 156, 209, 127, 236, 181, 16, 174, 12, 234, 35, 161, 16,\n                232, 213, 185, 1, 248, 172, 173, 211, 9, 92, 115, 163, 185, 25,\n            ]),\n            CompressedRistretto([\n                148, 116, 31, 93, 93, 82, 117, 94, 206, 79, 35, 240, 68, 238, 39, 213, 209, 234,\n                30, 43, 209, 150, 180, 98, 22, 107, 22, 21, 42, 157, 2, 89,\n            ]),\n            CompressedRistretto([\n                218, 128, 134, 39, 115, 53, 139, 70, 111, 250, 223, 224, 179, 41, 58, 179, 217,\n                253, 83, 197, 234, 108, 149, 83, 88, 245, 104, 50, 45, 175, 106, 87,\n            ]),\n            CompressedRistretto([\n                232, 130, 177, 49, 1, 107, 82, 193, 211, 51, 112, 128, 24, 124, 247, 104, 66, 62,\n                252, 203, 181, 23, 187, 73, 90, 184, 18, 196, 22, 15, 244, 78,\n            ]),\n            CompressedRistretto([\n                246, 71, 70, 211, 201, 43, 19, 5, 14, 216, 216, 2, 54, 167, 240, 0, 124, 59, 63,\n                150, 47, 91, 167, 147, 209, 154, 96, 30, 187, 29, 244, 3,\n            ]),\n            CompressedRistretto([\n                68, 245, 53, 32, 146, 110, 200, 31, 189, 90, 56, 120, 69, 190, 183, 223, 133, 169,\n                106, 36, 236, 225, 135, 56, 189, 207, 166, 167, 130, 42, 23, 109,\n            ]),\n            CompressedRistretto([\n                144, 50, 147, 216, 242, 40, 126, 190, 16, 226, 55, 77, 193, 165, 62, 11, 200, 135,\n                229, 146, 105, 159, 2, 208, 119, 213, 38, 60, 221, 85, 96, 28,\n            ]),\n            CompressedRistretto([\n                2, 98, 42, 206, 143, 115, 3, 163, 28, 175, 198, 63, 143, 196, 143, 220, 22, 225,\n                200, 200, 210, 52, 178, 240, 214, 104, 82, 130, 169, 7, 96, 49,\n            ]),\n            CompressedRistretto([\n                32, 112, 111, 215, 136, 178, 114, 10, 30, 210, 165, 218, 212, 149, 43, 1, 244, 19,\n                188, 240, 231, 86, 77, 232, 205, 200, 22, 104, 158, 45, 185, 95,\n            ]),\n            CompressedRistretto([\n                188, 232, 63, 139, 165, 221, 47, 165, 114, 134, 76, 36, 186, 24, 16, 249, 82, 43,\n                198, 0, 74, 254, 149, 135, 122, 199, 50, 65, 202, 253, 171, 66,\n            ]),\n            CompressedRistretto([\n                228, 84, 158, 225, 107, 154, 160, 48, 153, 202, 32, 140, 103, 173, 175, 202, 250,\n                76, 63, 62, 78, 83, 3, 222, 96, 38, 227, 202, 143, 248, 68, 96,\n            ]),\n            CompressedRistretto([\n                170, 82, 224, 0, 223, 46, 22, 245, 95, 177, 3, 47, 195, 59, 196, 39, 66, 218, 214,\n                189, 90, 143, 192, 190, 1, 103, 67, 108, 89, 72, 80, 31,\n            ]),\n            CompressedRistretto([\n                70, 55, 107, 128, 244, 9, 178, 157, 194, 181, 246, 240, 197, 37, 145, 153, 8, 150,\n                229, 113, 111, 65, 71, 124, 211, 0, 133, 171, 127, 16, 48, 30,\n            ]),\n            CompressedRistretto([\n                224, 196, 24, 247, 200, 217, 196, 205, 215, 57, 91, 147, 234, 18, 79, 58, 217, 144,\n                33, 187, 104, 29, 252, 51, 2, 169, 217, 154, 46, 83, 230, 78,\n            ]),\n        ];\n        let mut bp = RistrettoPoint::identity();\n        for point in compressed {\n            assert_eq!(bp.compress(), point);\n            bp += constants::RISTRETTO_BASEPOINT_POINT;\n        }\n    }",
    "display_name": "encodings_of_small_multiples_of_basepoint",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_affine",
      "5.0.0_pre.0 edwards/affine/impl/AffinePoint/compress"
    ],
    "body": "    pub fn compress(&self) -> CompressedEdwardsY {\n        self.to_affine().compress()\n    }",
    "display_name": "compress",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/from_hash",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    pub fn from_hash<D>(hash: D) -> Scalar\n    where\n        D: Digest<OutputSize = U64>,\n    {\n        let mut output = [0u8; 64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }",
    "display_name": "from_hash",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/splat_const",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/new_const"
    ],
    "body": "    pub const fn splat_const<const N: u32>() -> Self {\n        Self::new_const(N, N, N, N, N, N, N, N)\n    }",
    "display_name": "splat_const",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/mul_base",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }",
    "display_name": "mul_base",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/multiscalar_consistency_n_500",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/test/multiscalar_consistency_iter"
    ],
    "body": "    fn multiscalar_consistency_n_500() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(500);\n        }\n    }",
    "display_name": "multiscalar_consistency_n_500",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.bytes.ct_eq(&other.bytes)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/tests/generator_round_trip",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/affine/impl/AffinePoint/to_edwards",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_affine"
    ],
    "body": "    fn generator_round_trip() {\n        let basepoint = constants::ED25519_BASEPOINT_POINT;\n        assert_eq!(basepoint.to_affine().to_edwards(), basepoint);\n    }",
    "display_name": "generator_round_trip",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/montgomery_invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_mul",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_square"
    ],
    "body": "    pub fn montgomery_invert(&self) -> UnpackedScalar {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let    _1 = *self;\n        let   _10 = _1.montgomery_square();\n        let  _100 = _10.montgomery_square();\n        let   _11 = UnpackedScalar::montgomery_mul(&_10,     &_1);\n        let  _101 = UnpackedScalar::montgomery_mul(&_10,    &_11);\n        let  _111 = UnpackedScalar::montgomery_mul(&_10,   &_101);\n        let _1001 = UnpackedScalar::montgomery_mul(&_10,   &_111);\n        let _1011 = UnpackedScalar::montgomery_mul(&_10,  &_1001);\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n\n        #[inline]\n        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,       4, &_1001);\n        square_multiply(&mut y,       2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 3, &_101);\n        square_multiply(&mut y,   3 + 3, &_101);\n        square_multiply(&mut y,       3, &_111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   2 + 3, &_111);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,   2 + 4, &_1011);\n        square_multiply(&mut y,   6 + 4, &_1001);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1001);\n        square_multiply(&mut y,   1 + 3, &_111);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   1 + 2, &_11);\n\n        y\n    }",
    "display_name": "montgomery_invert",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 test_unset_target_feature",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_unset_target_feature() {\n    compile_error!(\"When an unknown target_feature is set on a test, unsafe_target_feature is expected remove the function\");\n}",
    "display_name": "test_unset_target_feature",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_zero",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    pub(crate) fn is_zero(&self) -> Choice {\n        let zero = [0u8; 32];\n        let bytes = self.to_bytes();\n\n        bytes.ct_eq(&zero)\n    }",
    "display_name": "is_zero",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 constants/test/test_sqrt_constants_sign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invsqrt"
    ],
    "body": "    fn test_sqrt_constants_sign() {\n        let minus_one = FieldElement::MINUS_ONE;\n        let (was_nonzero_square, invsqrt_m1) = minus_one.invsqrt();\n        assert!(bool::from(was_nonzero_square));\n        let sign_test_sqrt = &invsqrt_m1 * &constants::SQRT_M1;\n        assert_eq!(sign_test_sqrt, minus_one);\n    }",
    "display_name": "test_sqrt_constants_sign",
    "full_path": "file:///work/3118/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/StaticSecret/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(bytes: [u8; 32]) -> StaticSecret {\n        StaticSecret(bytes)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/serialize_signature",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 scalar/impl/Scalar/as_bytes",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn serialize_signature(r: &EdwardsPoint, s: &Scalar) -> Vec<u8> {\n        [&r.compress().as_bytes()[..], &s.as_bytes()[..]].concat()\n    }",
    "display_name": "serialize_signature",
    "full_path": "file:///work/3118/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/pippenger_optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 backend/serial/scalar_mul/pippenger/impl/Pippenger/VartimeMultiscalarMul/optional_multiscalar_mul"
    ],
    "body": "pub fn pippenger_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 =>\n            vector::scalar_mul::pippenger::spec_avx2::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 =>\n            vector::scalar_mul::pippenger::spec_avx512ifma_avx512vl::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        BackendKind::Serial =>\n            serial::scalar_mul::pippenger::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n    }\n}",
    "display_name": "pippenger_optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/m",
    "statement_type": "function",
    "deps": [],
    "body": "fn m(x: u64, y: u64) -> u128 {\n    (x as u128) * (y as u128)\n}",
    "display_name": "m",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/blend_lanes",
    "statement_type": "function",
    "deps": [],
    "body": "        fn blend_lanes(x: u32x8, y: u32x8, control: Lanes) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n\n                // This would be much cleaner if we could factor out the match\n                // statement on the control. Unfortunately, rustc forgets\n                // constant-info very quickly, so we can't even write\n                // ```\n                // match control {\n                //     Lanes::C => {\n                //         let imm = C_LANES as i32;\n                //         _mm256_blend_epi32(..., imm)\n                // ```\n                // let alone\n                // ```\n                // let imm = match control {\n                //     Lanes::C => C_LANES as i32,\n                // }\n                // _mm256_blend_epi32(..., imm)\n                // ```\n                // even though both of these would be constant-folded by LLVM\n                // at a lower level (as happens in the shuffle implementation,\n                // which does not require a shuffle immediate but *is* lowered\n                // to immediate shuffles anyways).\n                match control {\n                    Lanes::C => _mm256_blend_epi32(x.into(), y.into(), C_LANES as i32).into(),\n                    Lanes::D => _mm256_blend_epi32(x.into(), y.into(), D_LANES as i32).into(),\n                    Lanes::AD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::AB => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | B_LANES) as i32).into()\n                    }\n                    Lanes::AC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::CD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (C_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::BC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (B_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::ABCD => _mm256_blend_epi32(\n                        x.into(),\n                        y.into(),\n                        (A_LANES | B_LANES | C_LANES | D_LANES) as i32,\n                    )\n                    .into(),\n                }\n            }\n        }\n\n        FieldElement2625x4([\n            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n\n    /// Convenience wrapper around `new(x,x,x,x)`.\n    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }\n\n    /// Create a `FieldElement2625x4` from four `FieldElement51`s.\n    ///\n    /// # Postconditions\n    ///\n    /// The resulting `FieldElement2625x4` is bounded with \\\\( b < 0.0002 \\\\).\n    #[rustfmt::skip] // keep alignment of computed lanes\n    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> FieldElement2625x4 {\n        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }\n\n        // We don't know that the original `FieldElement51`s were\n        // fully reduced, so the odd limbs may exceed 2^25.\n        // Reduce them to be sure.\n        FieldElement2625x4(buf).reduce()\n    }\n\n    /// Given \\\\((A,B,C,D)\\\\), compute \\\\((-A,-B,-C,-D)\\\\), without\n    /// performing a reduction.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.999 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1 \\\\).\n    #[inline]\n    pub fn negate_lazy(&self) -> FieldElement2625x4 {\n        // The limbs of self are bounded with b < 0.999, while the\n        // smallest limb of 2*p is 67108845 > 2^{26+0.9999}, so\n        // underflows are not possible.\n        FieldElement2625x4([\n            P_TIMES_2_LO - self.0[0],\n            P_TIMES_2_HI - self.0[1],\n            P_TIMES_2_HI - self.0[2],\n            P_TIMES_2_HI - self.0[3],\n            P_TIMES_2_HI - self.0[4],\n        ])\n    }\n\n    /// Given `self = (A,B,C,D)`, compute `(B - A, B + A, D - C, D + C)`.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.01 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1.6 \\\\).\n    #[inline]\n    pub fn diff_sum(&self) -> FieldElement2625x4 {\n        // tmp1 = (B, A, D, C)\n        let tmp1 = self.shuffle(Shuffle::BADC);\n        // tmp2 = (-A, B, -C, D)\n        let tmp2 = self.blend(self.negate_lazy(), Lanes::AC);\n        // (B - A, B + A, D - C, D + C) bounded with b < 1.6\n        tmp1 + tmp2\n    }\n\n    /// Reduce this vector of field elements \\\\(\\mathrm{mod} p\\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.0002 \\\\).\n    #[inline]\n    pub fn reduce(&self) -> FieldElement2625x4 {\n        let shifts = u32x8::new(26, 26, 25, 25, 26, 26, 25, 25);\n        let masks = u32x8::new(\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n        );\n\n        // Let c(x) denote the carryout of the coefficient x.\n        //\n        // Given    (   x0,    y0,    x1,    y1,    z0,    w0,    z1,    w1),\n        // compute  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0)).\n        //\n        // The carryouts are bounded by 2^(32 - 25) = 2^7.\n        let rotated_carryout = |v: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_shuffle_epi32;\n                use core::arch::x86_64::_mm256_srlv_epi32;\n\n                let c = _mm256_srlv_epi32(v.into(), shifts.into());\n                _mm256_shuffle_epi32(c, 0b01_00_11_10).into()\n            }\n        };\n\n        // Combine (lo, lo, lo, lo, lo, lo, lo, lo)\n        //    with (hi, hi, hi, hi, hi, hi, hi, hi)\n        //      to (lo, lo, hi, hi, lo, lo, hi, hi)\n        //\n        // This allows combining carryouts, e.g.,\n        //\n        // lo  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0))\n        // hi  (c(x3), c(y3), c(x2), c(y2), c(z3), c(w3), c(z2), c(w2))\n        // ->  (c(x1), c(y1), c(x2), c(y2), c(z1), c(w1), c(z2), c(w2))\n        //\n        // which is exactly the vector of carryins for\n        //\n        //     (   x2,    y2,    x3,    y3,    z2,    w2,    z3,    w3).\n        //\n        let combine = |v_lo: u32x8, v_hi: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(v_lo.into(), v_hi.into(), 0b11_00_11_00).into()\n            }\n        };\n\n        let mut v = self.0;\n\n        let c10 = rotated_carryout(v[0]);\n        v[0] = (v[0] & masks) + combine(u32x8::splat(0), c10);\n\n        let c32 = rotated_carryout(v[1]);\n        v[1] = (v[1] & masks) + combine(c10, c32);\n\n        let c54 = rotated_carryout(v[2]);\n        v[2] = (v[2] & masks) + combine(c32, c54);\n\n        let c76 = rotated_carryout(v[3]);\n        v[3] = (v[3] & masks) + combine(c54, c76);\n\n        let c98 = rotated_carryout(v[4]);\n        v[4] = (v[4] & masks) + combine(c76, c98);\n\n        let c9_19: u32x8 = unsafe {\n            use core::arch::x86_64::_mm256_mul_epu32;\n            use core::arch::x86_64::_mm256_shuffle_epi32;\n\n            // Need to rearrange c98, since vpmuludq uses the low\n            // 32-bits of each 64-bit lane to compute the product:\n            //\n            // c98       = (c(x9), c(y9), c(x8), c(y8), c(z9), c(w9), c(z8), c(w8));\n            // c9_spread = (c(x9), c(x8), c(y9), c(y8), c(z9), c(z8), c(w9), c(w8)).\n            let c9_spread = _mm256_shuffle_epi32(c98.into(), 0b11_01_10_00);\n\n            // Since the carryouts are bounded by 2^7, their products with 19\n            // are bounded by 2^11.25.  This means that\n            //\n            // c9_19_spread = (19*c(x9), 0, 19*c(y9), 0, 19*c(z9), 0, 19*c(w9), 0).\n            let c9_19_spread = _mm256_mul_epu32(c9_spread, u64x4::splat(19).into());\n\n            // Unshuffle:\n            // c9_19 = (19*c(x9), 19*c(y9), 0, 0, 19*c(z9), 19*c(w9), 0, 0).\n            _mm256_shuffle_epi32(c9_19_spread, 0b11_01_10_00).into()\n        };\n\n        // Add the final carryin.\n        v[0] += c9_19;\n\n        // Each output coefficient has exactly one carryin, which is\n        // bounded by 2^11.25, so they are bounded as\n        //\n        // c_even < 2^26 + 2^11.25 < 26.00006 < 2^{26+b}\n        // c_odd  < 2^25 + 2^11.25 < 25.0001  < 2^{25+b}\n        //\n        // where b = 0.0002.\n        FieldElement2625x4(v)\n    }\n\n    /// Given an array of wide coefficients, reduce them to a `FieldElement2625x4`.\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[inline]\n    #[rustfmt::skip] // keep alignment of carry chain\n    fn reduce64(mut z: [u64x4; 10]) -> FieldElement2625x4 {\n        // These aren't const because splat isn't a const fn\n        let LOW_25_BITS: u64x4 = u64x4::splat((1 << 25) - 1);\n        let LOW_26_BITS: u64x4 = u64x4::splat((1 << 26) - 1);\n\n        // Carry the value from limb i = 0..8 to limb i+1\n        let carry = |z: &mut [u64x4; 10], i: usize| {\n            debug_assert!(i < 9);\n            if i % 2 == 0 {\n                // Even limbs have 26 bits\n                z[i + 1] += z[i].shr::<26>();\n                z[i] &= LOW_26_BITS;\n            } else {\n                // Odd limbs have 25 bits\n                z[i + 1] += z[i].shr::<25>();\n                z[i] &= LOW_25_BITS;\n            }\n        };\n\n        // Perform two halves of the carry chain in parallel.\n        carry(&mut z, 0); carry(&mut z, 4);\n        carry(&mut z, 1); carry(&mut z, 5);\n        carry(&mut z, 2); carry(&mut z, 6);\n        carry(&mut z, 3); carry(&mut z, 7);\n        // Since z[3] < 2^64, c < 2^(64-25) = 2^39,\n        // so    z[4] < 2^26 + 2^39 < 2^39.0002\n        carry(&mut z, 4); carry(&mut z, 8);\n        // Now z[4] < 2^26\n        // and z[5] < 2^25 + 2^13.0002 < 2^25.0004 (good enough)\n\n        // Last carry has a multiplication by 19.  In the serial case we\n        // do a 64-bit multiplication by 19, but here we want to do a\n        // 32-bit multiplication.  However, if we only know z[9] < 2^64,\n        // the carry is bounded as c < 2^(64-25) = 2^39, which is too\n        // big.  To ensure c < 2^32, we would need z[9] < 2^57.\n        // Instead, we split the carry in two, with c = c_0 + c_1*2^26.\n\n        let c = z[9].shr::<25>();\n        z[9] &= LOW_25_BITS;\n        let mut c0: u64x4 = c & LOW_26_BITS; // c0 < 2^26;\n        let mut c1: u64x4 = c.shr::<26>();         // c1 < 2^(39-26) = 2^13;\n\n        let x19 = u64x4::splat(19);\n        c0 = u32x8::from(c0).mul32(u32x8::from(x19));\n        c1 = u32x8::from(c1).mul32(u32x8::from(x19));\n\n        z[0] += c0; // z0 < 2^26 + 2^30.25 < 2^30.33\n        z[1] += c1; // z1 < 2^25 + 2^17.25 < 2^25.0067\n        carry(&mut z, 0); // z0 < 2^26, z1 < 2^25.0067 + 2^4.33 = 2^25.007\n\n        // The output coefficients are bounded with\n        //\n        // b = 0.007  for z[1]\n        // b = 0.0004 for z[5]\n        // b = 0      for other z[i].\n        //\n        // So the packed result is bounded with b = 0.007.\n        FieldElement2625x4([\n            repack_pair(z[0].into(), z[1].into()),\n            repack_pair(z[2].into(), z[3].into()),\n            repack_pair(z[4].into(), z[5].into()),\n            repack_pair(z[6].into(), z[7].into()),\n            repack_pair(z[8].into(), z[9].into()),\n        ])\n    }\n\n    /// Square this field element, and negate the result's \\\\(D\\\\) value.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 1.5 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[rustfmt::skip] // keep alignment of z* calculations\n    pub fn square_and_negate_D(&self) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let x0_2 = x0.shl::<1>();\n        let x1_2 = x1.shl::<1>();\n        let x2_2 = x2.shl::<1>();\n        let x3_2 = x3.shl::<1>();\n        let x4_2 = x4.shl::<1>();\n        let x5_2 = x5.shl::<1>();\n        let x6_2 = x6.shl::<1>();\n        let x7_2 = x7.shl::<1>();\n\n        let x5_19 = m_lo(v19, x5);\n        let x6_19 = m_lo(v19, x6);\n        let x7_19 = m_lo(v19, x7);\n        let x8_19 = m_lo(v19, x8);\n        let x9_19 = m_lo(v19, x9);\n\n        let mut z0 = m(x0,   x0) + m(x2_2, x8_19) + m(x4_2, x6_19) + ((m(x1_2, x9_19) +   m(x3_2, x7_19) +    m(x5,   x5_19)).shl::<1>());\n        let mut z1 = m(x0_2, x1) + m(x3_2, x8_19) + m(x5_2, x6_19) +                    ((m(x2,   x9_19) +    m(x4,   x7_19)).shl::<1>());\n        let mut z2 = m(x0_2, x2) + m(x1_2,    x1) + m(x4_2, x8_19) +   m(x6,   x6_19) + ((m(x3_2, x9_19) +    m(x5_2, x7_19)).shl::<1>());\n        let mut z3 = m(x0_2, x3) + m(x1_2,    x2) + m(x5_2, x8_19) +                    ((m(x4,   x9_19) +    m(x6,   x7_19)).shl::<1>());\n        let mut z4 = m(x0_2, x4) + m(x1_2,  x3_2) + m(x2,      x2) +   m(x6_2, x8_19) + ((m(x5_2, x9_19) +    m(x7,   x7_19)).shl::<1>());\n        let mut z5 = m(x0_2, x5) + m(x1_2,    x4) + m(x2_2,    x3) +   m(x7_2, x8_19)                    +  ((m(x6,   x9_19)).shl::<1>());\n        let mut z6 = m(x0_2, x6) + m(x1_2,  x5_2) + m(x2_2,    x4) +   m(x3_2,    x3) +   m(x8,   x8_19) +  ((m(x7_2, x9_19)).shl::<1>());\n        let mut z7 = m(x0_2, x7) + m(x1_2,    x6) + m(x2_2,    x5) +   m(x3_2,    x4)                    +  ((m(x8,   x9_19)).shl::<1>());\n        let mut z8 = m(x0_2, x8) + m(x1_2,  x7_2) + m(x2_2,    x6) +   m(x3_2,  x5_2) +   m(x4,      x4) +  ((m(x9,   x9_19)).shl::<1>());\n        let mut z9 = m(x0_2, x9) + m(x1_2,    x8) + m(x2_2,    x7) +   m(x3_2,    x6) +   m(x4_2,    x5)                                 ;\n\n        // The biggest z_i is bounded as z_i < 249*2^(51 + 2*b);\n        // if b < 1.5 we get z_i < 4485585228861014016.\n        //\n        // The limbs of the multiples of p are bounded above by\n        //\n        // 0x3fffffff << 37 = 9223371899415822336 < 2^63\n        //\n        // and below by\n        //\n        // 0x1fffffff << 37 = 4611685880988434432\n        //                  > 4485585228861014016\n        //\n        // So these multiples of p are big enough to avoid underflow\n        // in subtraction, and small enough to fit within u64\n        // with room for a carry.\n\n        let low__p37 = u64x4::splat(0x3ffffed << 37);\n        let even_p37 = u64x4::splat(0x3ffffff << 37);\n        let odd__p37 = u64x4::splat(0x1ffffff << 37);\n\n        let negate_D = |x: u64x4, p: u64x4| -> u64x4 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(x.into(), (p - x).into(), D_LANES64 as i32).into()\n            }\n        };\n\n        z0 = negate_D(z0, low__p37);\n        z1 = negate_D(z1, odd__p37);\n        z2 = negate_D(z2, even_p37);\n        z3 = negate_D(z3, odd__p37);\n        z4 = negate_D(z4, even_p37);\n        z5 = negate_D(z5, odd__p37);\n        z6 = negate_D(z6, even_p37);\n        z7 = negate_D(z7, odd__p37);\n        z8 = negate_D(z8, even_p37);\n        z9 = negate_D(z9, odd__p37);\n\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}",
    "display_name": "blend_lanes",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/MultiscalarMul/multiscalar_mul"
    ],
    "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> RistrettoPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<RistrettoPoint>,\n    {\n        let extended_points = points.into_iter().map(|P| P.borrow().0);\n        RistrettoPoint(EdwardsPoint::multiscalar_mul(scalars, extended_points))\n    }",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/square",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack"
    ],
    "body": "    fn square() {\n        let expected = X * X;\n        let actual = X.unpack().square().pack();\n        for i in 0..32 {\n            assert!(expected[i] == actual[i]);\n        }\n    }",
    "display_name": "square",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/optional_multiscalar_mul"
    ],
    "body": "    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
    "display_name": "vartime_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 function_with_const_arg",
    "statement_type": "function",
    "deps": [],
    "body": "fn function_with_const_arg<const N: u32>(b: u32) -> u32 {\n    N - b\n}",
    "display_name": "function_with_const_arg",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/RCompute/update",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn update(&mut self, m: &[u8]) {\n        self.h.update(m)\n    }",
    "display_name": "update",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/PublicKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/impl/PublicKey/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/sub"
    ],
    "body": "    fn sub() {\n        let res = Scalar52::sub(&A, &B);\n        for i in 0..5 {\n            assert!(res[i] == AB[i]);\n        }\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 kw/conditional",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "conditional",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/diff_sum",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/blend"
    ],
    "body": "    fn from(P: ExtendedPoint) -> CachedPoint {\n        let mut x = P.0;\n\n        x = x.blend(x.diff_sum(), Lanes::AB);\n        // x = (Y2 - X2, Y2 + X2, Z2, T2) = (S2 S3 Z2 T2)\n\n        x = x * (121666, 121666, 2 * 121666, 2 * 121665);\n        // x = (121666*S2 121666*S3 2*121666*Z2 2*121665*T2)\n\n        x = x.blend(-x, Lanes::D);\n        // x = (121666*S2 121666*S3 2*121666*Z2 -2*121665*T2)\n\n        // The coefficients of the output are bounded with b < 0.007.\n        CachedPoint(x)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/diff_sum",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/blend",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/negate_lazy",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/shuffle"
    ],
    "body": "    pub fn diff_sum(&self) -> FieldElement2625x4 {\n        // tmp1 = (B, A, D, C)\n        let tmp1 = self.shuffle(Shuffle::BADC);\n        // tmp2 = (-A, B, -C, D)\n        let tmp2 = self.blend(self.negate_lazy(), Lanes::AC);\n        // (B - A, B + A, D - C, D + C) bounded with b < 1.6\n        tmp1 + tmp2\n    }",
    "display_name": "diff_sum",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto_benches/decompress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/decompress"
    ],
    "body": "    fn decompress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"RistrettoPoint decompression\", |b| {\n            let B_comp = &constants::RISTRETTO_BASEPOINT_COMPRESSED;\n            b.iter(|| B_comp.decompress().unwrap())\n        });\n    }",
    "display_name": "decompress",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 window/impl/NafLookupTable5/select",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 16);\n\n        self.0[x / 2]\n    }",
    "display_name": "select",
    "full_path": "file:///work/3118/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/montgomery_square_max",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_square"
    ],
    "body": "    fn montgomery_square_max() {\n        let res = X.montgomery_square();\n        for i in 0..5 {\n            assert!(res[i] == XX_MONT[i]);\n        }\n    }",
    "display_name": "montgomery_square_max",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 constants/test/test_sqrt_ad_minus_one",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "    fn test_sqrt_ad_minus_one() {\n        let a = FieldElement::MINUS_ONE;\n        let ad_minus_one = &(&a * &constants::EDWARDS_D) + &a;\n        let should_be_ad_minus_one = constants::SQRT_AD_MINUS_ONE.square();\n        assert_eq!(should_be_ad_minus_one, ad_minus_one);\n    }",
    "display_name": "test_sqrt_ad_minus_one",
    "full_path": "file:///work/3118/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/elligator_vs_ristretto_sage",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/elligator_ristretto_flavor"
    ],
    "body": "    fn elligator_vs_ristretto_sage() {\n        // Test vectors extracted from ristretto.sage.\n        //\n        // Notice that all of the byte sequences have bit 255 set to 0; this is because\n        // ristretto.sage does not mask the high bit of a field element.  When the high bit is set,\n        // the ristretto.sage elligator implementation gives different results, since it takes a\n        // different field element as input.\n        let bytes: [[u8; 32]; 16] = [\n            [\n                184, 249, 135, 49, 253, 123, 89, 113, 67, 160, 6, 239, 7, 105, 211, 41, 192, 249,\n                185, 57, 9, 102, 70, 198, 15, 127, 7, 26, 160, 102, 134, 71,\n            ],\n            [\n                229, 14, 241, 227, 75, 9, 118, 60, 128, 153, 226, 21, 183, 217, 91, 136, 98, 0,\n                231, 156, 124, 77, 82, 139, 142, 134, 164, 169, 169, 62, 250, 52,\n            ],\n            [\n                115, 109, 36, 220, 180, 223, 99, 6, 204, 169, 19, 29, 169, 68, 84, 23, 21, 109,\n                189, 149, 127, 205, 91, 102, 172, 35, 112, 35, 134, 69, 186, 34,\n            ],\n            [\n                16, 49, 96, 107, 171, 199, 164, 9, 129, 16, 64, 62, 241, 63, 132, 173, 209, 160,\n                112, 215, 105, 50, 157, 81, 253, 105, 1, 154, 229, 25, 120, 83,\n            ],\n            [\n                156, 131, 161, 162, 236, 251, 5, 187, 167, 171, 17, 178, 148, 210, 90, 207, 86, 21,\n                79, 161, 167, 215, 234, 1, 136, 242, 182, 248, 38, 85, 79, 86,\n            ],\n            [\n                251, 177, 124, 54, 18, 101, 75, 235, 245, 186, 19, 46, 133, 157, 229, 64, 10, 136,\n                181, 185, 78, 144, 254, 167, 137, 49, 107, 10, 61, 10, 21, 25,\n            ],\n            [\n                232, 193, 20, 68, 240, 77, 186, 77, 183, 40, 44, 86, 150, 31, 198, 212, 76, 81, 3,\n                217, 197, 8, 126, 128, 126, 152, 164, 208, 153, 44, 189, 77,\n            ],\n            [\n                173, 229, 149, 177, 37, 230, 30, 69, 61, 56, 172, 190, 219, 115, 167, 194, 71, 134,\n                59, 75, 28, 244, 118, 26, 162, 97, 64, 16, 15, 189, 30, 64,\n            ],\n            [\n                106, 71, 61, 107, 250, 117, 42, 151, 91, 202, 212, 100, 52, 188, 190, 21, 125, 218,\n                31, 18, 253, 241, 160, 133, 57, 242, 3, 164, 189, 68, 111, 75,\n            ],\n            [\n                112, 204, 182, 90, 220, 198, 120, 73, 173, 107, 193, 17, 227, 40, 162, 36, 150,\n                141, 235, 55, 172, 183, 12, 39, 194, 136, 43, 153, 244, 118, 91, 89,\n            ],\n            [\n                111, 24, 203, 123, 254, 189, 11, 162, 51, 196, 163, 136, 204, 143, 10, 222, 33,\n                112, 81, 205, 34, 35, 8, 66, 90, 6, 164, 58, 170, 177, 34, 25,\n            ],\n            [\n                225, 183, 30, 52, 236, 82, 6, 183, 109, 25, 227, 181, 25, 82, 41, 193, 80, 77, 161,\n                80, 242, 203, 79, 204, 136, 245, 131, 110, 237, 106, 3, 58,\n            ],\n            [\n                207, 246, 38, 56, 30, 86, 176, 90, 27, 200, 61, 42, 221, 27, 56, 210, 79, 178, 189,\n                120, 68, 193, 120, 167, 77, 185, 53, 197, 124, 128, 191, 126,\n            ],\n            [\n                1, 136, 215, 80, 240, 46, 63, 147, 16, 244, 230, 207, 82, 189, 74, 50, 106, 169,\n                138, 86, 30, 131, 214, 202, 166, 125, 251, 228, 98, 24, 36, 21,\n            ],\n            [\n                210, 207, 228, 56, 155, 116, 207, 54, 84, 195, 251, 215, 249, 199, 116, 75, 109,\n                239, 196, 251, 194, 246, 252, 228, 70, 146, 156, 35, 25, 39, 241, 4,\n            ],\n            [\n                34, 116, 123, 9, 8, 40, 93, 189, 9, 103, 57, 103, 66, 227, 3, 2, 157, 107, 134,\n                219, 202, 74, 230, 154, 78, 107, 219, 195, 214, 14, 84, 80,\n            ],\n        ];\n        let encoded_images: [CompressedRistretto; 16] = [\n            CompressedRistretto([\n                176, 157, 237, 97, 66, 29, 140, 166, 168, 94, 26, 157, 212, 216, 229, 160, 195,\n                246, 232, 239, 169, 112, 63, 193, 64, 32, 152, 69, 11, 190, 246, 86,\n            ]),\n            CompressedRistretto([\n                234, 141, 77, 203, 181, 225, 250, 74, 171, 62, 15, 118, 78, 212, 150, 19, 131, 14,\n                188, 238, 194, 244, 141, 138, 166, 162, 83, 122, 228, 201, 19, 26,\n            ]),\n            CompressedRistretto([\n                232, 231, 51, 92, 5, 168, 80, 36, 173, 179, 104, 68, 186, 149, 68, 40, 140, 170,\n                27, 103, 99, 140, 21, 242, 43, 62, 250, 134, 208, 255, 61, 89,\n            ]),\n            CompressedRistretto([\n                208, 120, 140, 129, 177, 179, 237, 159, 252, 160, 28, 13, 206, 5, 211, 241, 192,\n                218, 1, 97, 130, 241, 20, 169, 119, 46, 246, 29, 79, 80, 77, 84,\n            ]),\n            CompressedRistretto([\n                202, 11, 236, 145, 58, 12, 181, 157, 209, 6, 213, 88, 75, 147, 11, 119, 191, 139,\n                47, 142, 33, 36, 153, 193, 223, 183, 178, 8, 205, 120, 248, 110,\n            ]),\n            CompressedRistretto([\n                26, 66, 231, 67, 203, 175, 116, 130, 32, 136, 62, 253, 215, 46, 5, 214, 166, 248,\n                108, 237, 216, 71, 244, 173, 72, 133, 82, 6, 143, 240, 104, 41,\n            ]),\n            CompressedRistretto([\n                40, 157, 102, 96, 201, 223, 200, 197, 150, 181, 106, 83, 103, 126, 143, 33, 145,\n                230, 78, 6, 171, 146, 210, 143, 112, 5, 245, 23, 183, 138, 18, 120,\n            ]),\n            CompressedRistretto([\n                220, 37, 27, 203, 239, 196, 176, 131, 37, 66, 188, 243, 185, 250, 113, 23, 167,\n                211, 154, 243, 168, 215, 54, 171, 159, 36, 195, 81, 13, 150, 43, 43,\n            ]),\n            CompressedRistretto([\n                232, 121, 176, 222, 183, 196, 159, 90, 238, 193, 105, 52, 101, 167, 244, 170, 121,\n                114, 196, 6, 67, 152, 80, 185, 221, 7, 83, 105, 176, 208, 224, 121,\n            ]),\n            CompressedRistretto([\n                226, 181, 183, 52, 241, 163, 61, 179, 221, 207, 220, 73, 245, 242, 25, 236, 67, 84,\n                179, 222, 167, 62, 167, 182, 32, 9, 92, 30, 165, 127, 204, 68,\n            ]),\n            CompressedRistretto([\n                226, 119, 16, 242, 200, 139, 240, 87, 11, 222, 92, 146, 156, 243, 46, 119, 65, 59,\n                1, 248, 92, 183, 50, 175, 87, 40, 206, 53, 208, 220, 148, 13,\n            ]),\n            CompressedRistretto([\n                70, 240, 79, 112, 54, 157, 228, 146, 74, 122, 216, 88, 232, 62, 158, 13, 14, 146,\n                115, 117, 176, 222, 90, 225, 244, 23, 94, 190, 150, 7, 136, 96,\n            ]),\n            CompressedRistretto([\n                22, 71, 241, 103, 45, 193, 195, 144, 183, 101, 154, 50, 39, 68, 49, 110, 51, 44,\n                62, 0, 229, 113, 72, 81, 168, 29, 73, 106, 102, 40, 132, 24,\n            ]),\n            CompressedRistretto([\n                196, 133, 107, 11, 130, 105, 74, 33, 204, 171, 133, 221, 174, 193, 241, 36, 38,\n                179, 196, 107, 219, 185, 181, 253, 228, 47, 155, 42, 231, 73, 41, 78,\n            ]),\n            CompressedRistretto([\n                58, 255, 225, 197, 115, 208, 160, 143, 39, 197, 82, 69, 143, 235, 92, 170, 74, 40,\n                57, 11, 171, 227, 26, 185, 217, 207, 90, 185, 197, 190, 35, 60,\n            ]),\n            CompressedRistretto([\n                88, 43, 92, 118, 223, 136, 105, 145, 238, 186, 115, 8, 214, 112, 153, 253, 38, 108,\n                205, 230, 157, 130, 11, 66, 101, 85, 253, 110, 110, 14, 148, 112,\n            ]),\n        ];\n        for i in 0..16 {\n            let r_0 = FieldElement::from_bytes(&bytes[i]);\n            let Q = RistrettoPoint::elligator_ristretto_flavor(&r_0);\n            assert_eq!(Q.compress(), encoded_images[i]);\n        }\n    }",
    "display_name": "elligator_vs_ristretto_sage",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/montgomery_ladder_matches_edwards_scalarmult",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 montgomery/test/rand_prime_order_point"
    ],
    "body": "    fn montgomery_ladder_matches_edwards_scalarmult() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            let p_edwards = rand_prime_order_point(&mut csprng);\n            let p_montgomery: MontgomeryPoint = p_edwards.to_montgomery();\n\n            let s: Scalar = Scalar::random(&mut csprng);\n            let expected = s * p_edwards;\n            let result = s * p_montgomery;\n\n            assert_eq!(result, expected.to_montgomery())\n        }\n    }",
    "display_name": "montgomery_ladder_matches_edwards_scalarmult",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective_niels",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn as_projective_niels(&self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: &self.Y + &self.X,\n            Y_minus_X: &self.Y - &self.X,\n            Z: self.Z,\n            T2d: &self.T * &constants::EDWARDS_D2,\n        }\n    }",
    "display_name": "as_projective_niels",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/vartime/double_scalar_mul_basepoint_vs_ed25519py",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/vartime_double_scalar_mul_basepoint"
    ],
    "body": "        fn double_scalar_mul_basepoint_vs_ed25519py() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result =\n                EdwardsPoint::vartime_double_scalar_mul_basepoint(&A_SCALAR, &A, &B_SCALAR);\n            assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n        }",
    "display_name": "double_scalar_mul_basepoint_vs_ed25519py",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/bot_half",
    "statement_type": "function",
    "deps": [],
    "body": "        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }",
    "display_name": "bot_half",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.0.conditional_assign(&other.0, choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/to_bytes"
    ],
    "body": "    fn pack(&self) -> Scalar {\n        Scalar {\n            bytes: self.to_bytes(),\n        }\n    }",
    "display_name": "pack",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 inner_spec/test_specialized",
    "statement_type": "function",
    "deps": [],
    "body": "    fn test_specialized() {\n        assert!(!IS_AVX2);\n    }",
    "display_name": "test_specialized",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/random",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/try_from_rng"
    ],
    "body": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self::try_from_rng(rng)\n            .map_err(|_: Infallible| {})\n            .expect(\"[bug] unfallible rng failed\")\n    }",
    "display_name": "random",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(<[u8; 32]>::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signature/impl/ed25519::Signature/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/as_bytes",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn from(sig: InternalSignature) -> ed25519::Signature {\n        ed25519::Signature::from_components(*sig.R.as_bytes(), *sig.s.as_bytes())\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 process_mod",
    "statement_type": "function",
    "deps": [
      "0.1.1 is_path_eq",
      "0.1.1 process_item"
    ],
    "body": "fn process_mod(\n    attributes: &syn::LitStr,\n    mut item_mod: syn::ItemMod,\n    spec_features: Option<Vec<String>>,\n) -> TokenStream2 {\n    if let Some((_, ref mut content)) = item_mod.content {\n        'next_item: for item in content {\n            if let Some(ref spec_features) = spec_features {\n                match item {\n                    syn::Item::Const(syn::ItemConst { ref mut attrs, .. })\n                    | syn::Item::Enum(syn::ItemEnum { ref mut attrs, .. })\n                    | syn::Item::ExternCrate(syn::ItemExternCrate { ref mut attrs, .. })\n                    | syn::Item::Fn(syn::ItemFn { ref mut attrs, .. })\n                    | syn::Item::ForeignMod(syn::ItemForeignMod { ref mut attrs, .. })\n                    | syn::Item::Impl(syn::ItemImpl { ref mut attrs, .. })\n                    | syn::Item::Macro(syn::ItemMacro { ref mut attrs, .. })\n                    | syn::Item::Mod(syn::ItemMod { ref mut attrs, .. })\n                    | syn::Item::Static(syn::ItemStatic { ref mut attrs, .. })\n                    | syn::Item::Struct(syn::ItemStruct { ref mut attrs, .. })\n                    | syn::Item::Trait(syn::ItemTrait { ref mut attrs, .. })\n                    | syn::Item::TraitAlias(syn::ItemTraitAlias { ref mut attrs, .. })\n                    | syn::Item::Type(syn::ItemType { ref mut attrs, .. })\n                    | syn::Item::Union(syn::ItemUnion { ref mut attrs, .. })\n                    | syn::Item::Use(syn::ItemUse { ref mut attrs, .. }) => {\n                        let mut index = 0;\n                        while index < attrs.len() {\n                            let attr = &attrs[index];\n                            if matches!(attr.style, syn::AttrStyle::Outer) {\n                                match attr.meta {\n                                    syn::Meta::List(ref list)\n                                        if is_path_eq(&list.path, \"for_target_feature\") =>\n                                    {\n                                        let feature: syn::LitStr = match list.parse_args() {\n                                            Ok(feature) => feature,\n                                            Err(error) => {\n                                                return error.into_compile_error();\n                                            }\n                                        };\n\n                                        let feature = feature.value();\n                                        if !spec_features.contains(&feature) {\n                                            *item = syn::Item::Verbatim(Default::default());\n                                            continue 'next_item;\n                                        }\n\n                                        attrs.remove(index);\n                                        continue;\n                                    }\n                                    _ => {}\n                                }\n                            }\n\n                            index += 1;\n                            continue;\n                        }\n                    }\n                    _ => {\n                        unsupported!(item_mod);\n                    }\n                }\n            }\n\n            *item = syn::Item::Verbatim(\n                process_item(\n                    attributes,\n                    std::mem::replace(item, syn::Item::Verbatim(Default::default())),\n                    false,\n                )\n                .into(),\n            );\n        }\n    }\n\n    quote::quote! {\n        #item_mod\n    }\n}",
    "display_name": "process_mod",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/mul32",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn mul32(self, rhs: u32x8) -> u64x4 {\n        // NOTE: This ignores the upper 32-bits from each packed 64-bits.\n        unsafe { core::arch::x86_64::_mm256_mul_epu32(self.0, rhs.0).into() }\n    }",
    "display_name": "mul32",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/pow_p58",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/pow22501",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/pow2k"
    ],
    "body": "    fn pow_p58(&self) -> FieldElement {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();    // 249..0\n        let t20 = t19.pow2k(2);            // 251..2\n        let t21 = self * &t20;             // 251..2,0\n\n        t21\n    }",
    "display_name": "pow_p58",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_affine",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert"
    ],
    "body": "    pub(crate) fn to_affine(self) -> AffinePoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        AffinePoint { x, y }\n    }",
    "display_name": "to_affine",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/decompress_id",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/Identity/identity",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/Identity/identity",
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/decompress",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/coset4"
    ],
    "body": "    fn decompress_id() {\n        let compressed_id = CompressedRistretto::identity();\n        let id = compressed_id.decompress().unwrap();\n        let mut identity_in_coset = false;\n        for P in &id.coset4() {\n            if P.compress() == CompressedEdwardsY::identity() {\n                identity_in_coset = true;\n            }\n        }\n        assert!(identity_in_coset);\n    }",
    "display_name": "decompress_id",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/decompress/step_1",
      "5.0.0_pre.0 edwards/decompress/step_2"
    ],
    "body": "    pub fn decompress(&self) -> Option<EdwardsPoint> {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        if is_valid_y_coord.into() {\n            Some(decompress::step_2(self, X, Y, Z))\n        } else {\n            None\n        }\n    }",
    "display_name": "decompress",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/StaticSecret/diffie_hellman",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_clamped"
    ],
    "body": "    pub fn diffie_hellman(&self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }",
    "display_name": "diffie_hellman",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 impl/TestVector/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/from_bytes"
    ],
    "body": "    fn from(tv: IntermediateTestVector) -> Self {\n        let number = tv.number;\n        let pubkey = {\n            let mut buf = [0u8; 32];\n            buf.copy_from_slice(&tv.pubkey);\n            VerifyingKey::from_bytes(&buf).unwrap()\n        };\n        let sig = {\n            let mut buf = [0u8; 64];\n            buf.copy_from_slice(&tv.sig);\n            Signature::from_bytes(&buf)\n        };\n        let msg = tv.msg.as_bytes().to_vec();\n\n        // Unwrap the Option<Set<Flag>>\n        let flags = tv.flags.unwrap_or_default();\n\n        Self {\n            number,\n            pubkey,\n            sig,\n            msg,\n            flags,\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signature/impl/InternalSignature/from_bytes",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signature/check_scalar"
    ],
    "body": "    pub fn from_bytes(bytes: &[u8; SIGNATURE_LENGTH]) -> Result<InternalSignature, SignatureError> {\n        // TODO: Use bytes.split_array_ref once it’s in MSRV.\n        let mut R_bytes: [u8; 32] = [0u8; 32];\n        let mut s_bytes: [u8; 32] = [0u8; 32];\n        R_bytes.copy_from_slice(&bytes[00..32]);\n        s_bytes.copy_from_slice(&bytes[32..64]);\n\n        Ok(InternalSignature {\n            R: CompressedEdwardsY(R_bytes),\n            s: check_scalar(s_bytes)?,\n        })\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_plus_basepoint_affine_niels_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_affine_niels"
    ],
    "body": "    fn basepoint_plus_basepoint_affine_niels_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_affine_niels = bp.as_affine_niels();\n        let bp_added = (&bp + &bp_affine_niels).as_extended();\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }",
    "display_name": "basepoint_plus_basepoint_affine_niels_vs_basepoint2",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectiveNielsPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectiveNielsPoint/Identity/identity"
    ],
    "body": "    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> CachedPoint {\n        constants::CACHEDPOINT_IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto_benches/compress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress"
    ],
    "body": "    fn compress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"RistrettoPoint compression\", |b| {\n            let B = &constants::RISTRETTO_BASEPOINT_POINT;\n            b.iter(|| B.compress())\n        });\n    }",
    "display_name": "compress",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/EphemeralSecret/random_from_rng",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn random_from_rng<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {\n        // The secret key is random bytes. Clamping is done later.\n        let mut bytes = [0u8; 32];\n        csprng.fill_bytes(&mut bytes);\n        EphemeralSecret(bytes)\n    }",
    "display_name": "random_from_rng",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 inner_spec/tests/test_specialized_inner",
    "statement_type": "function",
    "deps": [],
    "body": "        fn test_specialized_inner() {\n            assert!(!super::IS_AVX2);\n        }",
    "display_name": "test_specialized_inner",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/&ProjectiveNielsPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: self.Y_minus_X,\n            Y_minus_X: self.Y_plus_X,\n            Z: self.Z,\n            T2d: -(&self.T2d),\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "0.1.1 impl/Struct/member_function",
    "statement_type": "function",
    "deps": [],
    "body": "    fn member_function(&self, mut b: u32) -> u32 {\n        self.a - b\n    }",
    "display_name": "member_function",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 constants/test/test_two_torsion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/ValidityCheck/is_valid",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity"
    ],
    "body": "    fn test_two_torsion() {\n        for i in (0..8).filter(|i| i % 4 == 0) {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(1);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }",
    "display_name": "test_two_torsion",
    "full_path": "file:///work/3118/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/from_slice",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        bytes.try_into().map(CompressedEdwardsY)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/to_affine_niels_clears_denominators",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_affine_niels",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended"
    ],
    "body": "    fn to_affine_niels_clears_denominators() {\n        // construct a point as aB so it has denominators (ie. Z != 1)\n        let aB = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n        let aB_affine_niels = aB.as_affine_niels();\n        let also_aB = (&EdwardsPoint::identity() + &aB_affine_niels).as_extended();\n        assert_eq!(aB.compress(), also_aB.compress());\n    }",
    "display_name": "to_affine_niels_clears_denominators",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/bytestring_bits_le",
    "statement_type": "function",
    "deps": [],
    "body": "    fn bytestring_bits_le(x: &[u8]) -> impl DoubleEndedIterator<Item = bool> + Clone + '_ {\n        let bitlen = x.len() * 8;\n        (0..bitlen).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((x[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }",
    "display_name": "bytestring_bits_le",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 do_rfc7748_ladder_test1",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/x25519"
    ],
    "body": "fn do_rfc7748_ladder_test1(input_scalar: [u8; 32], input_point: [u8; 32], expected: [u8; 32]) {\n    let result = x25519(input_scalar, input_point);\n\n    assert_eq!(result, expected);\n}",
    "display_name": "do_rfc7748_ladder_test1",
    "full_path": "file:///work/3118/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u64x4/splat",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn splat(x: u64) -> u64x4 {\n        unsafe { u64x4(core::arch::x86_64::_mm256_set1_epi64x(x as i64)) }\n    }",
    "display_name": "splat",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: AffinePoint) -> EdwardsPoint {\n        self * &rhs\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/against_reference_implementation",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/verify",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/verify_strict",
      "3.0.0_pre.0 signing/impl/SigningKey/verifying_key",
      "3.0.0_pre.0 signing/impl/SigningKey/from_bytes",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/from_bytes"
    ],
    "body": "    fn against_reference_implementation() {\n        // TestGolden\n        let mut line: String;\n        let mut lineno: usize = 0;\n\n        let f = File::open(\"TESTVECTORS\");\n        if f.is_err() {\n            println!(\n                \"This test is only available when the code has been cloned \\\n                 from the git repository, since the TESTVECTORS file is large \\\n                 and is therefore not included within the distributed crate.\"\n            );\n            panic!();\n        }\n        let file = BufReader::new(f.unwrap());\n\n        for l in file.lines() {\n            lineno += 1;\n            line = l.unwrap();\n\n            let parts: Vec<&str> = line.split(':').collect();\n            assert_eq!(parts.len(), 5, \"wrong number of fields in line {}\", lineno);\n\n            let sec_bytes: Vec<u8> = FromHex::from_hex(parts[0]).unwrap();\n            let pub_bytes: Vec<u8> = FromHex::from_hex(parts[1]).unwrap();\n            let msg_bytes: Vec<u8> = FromHex::from_hex(parts[2]).unwrap();\n            let sig_bytes: Vec<u8> = FromHex::from_hex(parts[3]).unwrap();\n\n            let sec_bytes = &sec_bytes[..SECRET_KEY_LENGTH].try_into().unwrap();\n            let pub_bytes = &pub_bytes[..PUBLIC_KEY_LENGTH].try_into().unwrap();\n\n            let signing_key = SigningKey::from_bytes(sec_bytes);\n            let expected_verifying_key = VerifyingKey::from_bytes(pub_bytes).unwrap();\n            assert_eq!(expected_verifying_key, signing_key.verifying_key());\n\n            // The signatures in the test vectors also include the message\n            // at the end, but we just want R and S.\n            let sig1: Signature = Signature::try_from(&sig_bytes[..64]).unwrap();\n            let sig2: Signature = signing_key.sign(&msg_bytes);\n\n            assert!(sig1 == sig2, \"Signature bytes not equal on line {}\", lineno);\n            assert!(\n                signing_key.verify(&msg_bytes, &sig2).is_ok(),\n                \"Signature verification failed on line {}\",\n                lineno\n            );\n            assert!(\n                expected_verifying_key\n                    .verify_strict(&msg_bytes, &sig2)\n                    .is_ok(),\n                \"Signature strict verification failed on line {}\",\n                lineno\n            );\n        }\n    }",
    "display_name": "against_reference_implementation",
    "full_path": "file:///work/3118/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, rhs: FieldElement2625x4) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            self.0[0] + rhs.0[0],\n            self.0[1] + rhs.0[1],\n            self.0[2] + rhs.0[2],\n            self.0[3] + rhs.0[3],\n            self.0[4] + rhs.0[4],\n        ])\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/sqrt_ratio_behavior",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/sqrt_ratio_i",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "    fn sqrt_ratio_behavior() {\n        let zero = FieldElement::ZERO;\n        let one = FieldElement::ONE;\n        let i = constants::SQRT_M1;\n        let two = &one + &one; // 2 is nonsquare mod p.\n        let four = &two + &two; // 4 is square mod p.\n\n        // 0/0 should return (1, 0) since u is 0\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&zero, &zero);\n        assert!(bool::from(choice));\n        assert_eq!(sqrt, zero);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 1/0 should return (0, 0) since v is 0, u is nonzero\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&one, &zero);\n        assert!(bool::from(!choice));\n        assert_eq!(sqrt, zero);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 2/1 is nonsquare, so we expect (0, sqrt(i*2))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&two, &one);\n        assert!(bool::from(!choice));\n        assert_eq!(sqrt.square(), &two * &i);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 4/1 is square, so we expect (1, sqrt(4))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&four, &one);\n        assert!(bool::from(choice));\n        assert_eq!(sqrt.square(), four);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 1/4 is square, so we expect (1, 1/sqrt(4))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&one, &four);\n        assert!(bool::from(choice));\n        assert_eq!(&sqrt.square() * &four, one);\n        assert!(bool::from(!sqrt.is_negative()));\n    }",
    "display_name": "sqrt_ratio_behavior",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    fn from_bytes_mod_order_wide() {\n        let mut bignum = [0u8; 64];\n        // set bignum = x + 2^256x\n        for i in 0..32 {\n            bignum[i] = X[i];\n            bignum[32 + i] = X[i];\n        }\n        // 3958878930004874126169954872055634648693766179881526445624823978500314864344\n        // = x + 2^256x (mod l)\n        let reduced = Scalar {\n            bytes: [\n                216, 154, 179, 139, 210, 121, 2, 71, 69, 99, 158, 216, 23, 173, 63, 100, 204, 0,\n                91, 50, 219, 153, 57, 249, 28, 82, 31, 197, 100, 165, 192, 8,\n            ],\n        };\n        let test_red = Scalar::from_bytes_mod_order_wide(&bignum);\n        for i in 0..32 {\n            assert!(test_red[i] == reduced[i]);\n        }\n    }",
    "display_name": "from_bytes_mod_order_wide",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/precomputed_straus/spec/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/len",
    "statement_type": "function",
    "deps": [],
    "body": "        fn len(&self) -> usize {\n            self.static_lookup_tables.len()\n        }",
    "display_name": "len",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "3.0.0_pre.0 rand_core/ephemeral_from_rng",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/impl/EphemeralSecret/random_from_rng"
    ],
    "body": "    fn ephemeral_from_rng() {\n        EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err());\n    }",
    "display_name": "ephemeral_from_rng",
    "full_path": "file:///work/3118/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery_benches/montgomery_ladder",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/invert"
    ],
    "body": "    fn montgomery_ladder<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"Montgomery pseudomultiplication\", |b| {\n            let B = constants::X25519_BASEPOINT;\n            let s = Scalar::from(897987897u64).invert();\n            b.iter(|| B * s);\n        });\n    }",
    "display_name": "montgomery_ladder",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/double_and_compress_batch",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.to_bytes())\n            })\n            .collect()\n    }",
    "display_name": "double_and_compress_batch",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/AffinePoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::ZERO,\n            y: FieldElement::ONE,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/new",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn new(x0: u32, x1: u32, x2: u32, x3: u32, x4: u32, x5: u32, x6: u32, x7: u32) -> u32x8 {\n        unsafe {\n            // _mm256_set_epi32 sets the underlying vector in reverse order of the args\n            u32x8(core::arch::x86_64::_mm256_set_epi32(\n                x7 as i32, x6 as i32, x5 as i32, x4 as i32, x3 as i32, x2 as i32, x1 as i32,\n                x0 as i32,\n            ))\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/from_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_reduce"
    ],
    "body": "    pub fn from_montgomery(&self) -> (result: Scalar52)\n    requires\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n    ensures\n        // TODO: Add proper specification for Montgomery form conversion\n        true,\n    {\n        let mut limbs = [0u128; 9];\n        for i in 0..5 {\n            limbs[i] = self.limbs[i] as u128;\n        }\n        Scalar52::montgomery_reduce(&limbs)\n    }",
    "display_name": "from_montgomery",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", &self.0[..])\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectivePoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/a_invert_vs_inverse_of_a_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert"
    ],
    "body": "    fn a_invert_vs_inverse_of_a_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        let should_be_inverse = a.invert();\n        assert_eq!(ainv, should_be_inverse);\n        assert_eq!(FieldElement::ONE, &a * &should_be_inverse);\n    }",
    "display_name": "a_invert_vs_inverse_of_a_constant",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/Identity/identity"
    ],
    "body": "    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/&FieldElement51/Neg/neg",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/negate"
    ],
    "body": "    fn neg(self) -> FieldElement51 {\n        let mut output = *self;\n        output.negate();\n        output\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/pippenger/impl/Pippenger/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 scalar/impl/Scalar/to_radix_2w_size_hint"
    ],
    "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::Identity;\n\n        let mut scalars = scalars.into_iter();\n        let size = scalars.by_ref().size_hint().0;\n\n        // Digit width in bits. As digit width grows,\n        // number of point additions goes down, but amount of\n        // buckets and bucket additions grows exponentially.\n        let w = if size < 500 {\n            6\n        } else if size < 800 {\n            7\n        } else {\n            8\n        };\n\n        let max_digit: usize = 1 << w;\n        let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n        let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n        // Collect optimized scalars and points in buffers for repeated access\n        // (scanning the whole set per digit position).\n        let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n        let points = points\n            .into_iter()\n            .map(|p| p.map(|P| P.as_projective_niels()));\n\n        let scalars_points = scalars\n            .zip(points)\n            .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n            .collect::<Option<Vec<_>>>()?;\n\n        // Prepare 2^w/2 buckets.\n        // buckets[i] corresponds to a multiplication factor (i+1).\n        let mut buckets: Vec<_> = (0..buckets_count)\n            .map(|_| EdwardsPoint::identity())\n            .collect();\n\n        let mut columns = (0..digits_count).rev().map(|digit_index| {\n            // Clear the buckets when processing another digit.\n            for bucket in &mut buckets {\n                *bucket = EdwardsPoint::identity();\n            }\n\n            // Iterate over pairs of (point, scalar)\n            // and add/sub the point to the corresponding bucket.\n            // Note: if we add support for precomputed lookup tables,\n            // we'll be adding/subtracting point premultiplied by `digits[i]` to buckets[0].\n            for (digits, pt) in scalars_points.iter() {\n                // Widen digit so that we don't run into edge cases when w=8.\n                let digit = digits[digit_index] as i16;\n                match digit.cmp(&0) {\n                    Ordering::Greater => {\n                        let b = (digit - 1) as usize;\n                        buckets[b] = (&buckets[b] + pt).as_extended();\n                    }\n                    Ordering::Less => {\n                        let b = (-digit - 1) as usize;\n                        buckets[b] = (&buckets[b] - pt).as_extended();\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            // Add the buckets applying the multiplication factor to each bucket.\n            // The most efficient way to do that is to have a single sum with two running sums:\n            // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n            //\n            // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n            //   C\n            //   C B\n            //   C B A   Sum = C + (C+B) + (C+B+A)\n            let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n            let mut buckets_sum = buckets[buckets_count - 1];\n            for i in (0..(buckets_count - 1)).rev() {\n                buckets_intermediate_sum += buckets[i];\n                buckets_sum += buckets_intermediate_sum;\n            }\n\n            buckets_sum\n        });\n\n        // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n        let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n        Some(columns.fold(hi_column, |total, p| total.mul_by_pow_2(w as u32) + p))\n    }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> Scalar {\n        -&self\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/Hash/hash",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    fn hash<H: Hasher>(&self, state: &mut H) {\n        // Do a round trip through a `FieldElement`. `as_bytes` is guaranteed to give a canonical\n        // 32-byte encoding\n        let canonical_bytes = FieldElement::from_bytes(&self.0).to_bytes();\n        canonical_bytes.hash(state);\n    }",
    "display_name": "hash",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/cpuid_avx2/impl/InitToken/get",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "get",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_mult_one_vs_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_mult_one_vs_basepoint() {\n        let bp = ED25519_BASEPOINT_TABLE * &Scalar::ONE;\n        let compressed = bp.compress();\n        assert_eq!(compressed, constants::ED25519_BASEPOINT_COMPRESSED);\n    }",
    "display_name": "basepoint_mult_one_vs_basepoint",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/non_adjacent_form",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/read_le_u64_into"
    ],
    "body": "    pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {\n        // required by the NAF definition\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        debug_assert!(w <= 8);\n\n        let mut naf = [0i8; 256];\n\n        let mut x_u64 = [0u64; 5];\n        read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }\n\n        naf\n    }",
    "display_name": "non_adjacent_form",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/double",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/double",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended"
    ],
    "body": "    pub(crate) fn double(&self) -> EdwardsPoint {\n        self.as_projective().double().as_extended()\n    }",
    "display_name": "double",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/Verifier/verify"
    ],
    "body": "    pub fn verify(&self, message: &[u8], signature: &Signature) -> Result<(), SignatureError> {\n        self.verifying_key.verify(message, signature)\n    }",
    "display_name": "verify",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/montgomery_to_edwards_rejects_twist",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_edwards",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    fn montgomery_to_edwards_rejects_twist() {\n        let one = FieldElement::ONE;\n\n        // u = 2 corresponds to a point on the twist.\n        let two = MontgomeryPoint((&one + &one).to_bytes());\n\n        assert!(two.to_edwards(0).is_none());\n\n        // u = -1 corresponds to a point on the twist, but should be\n        // checked explicitly because it's an exceptional point for the\n        // birational map.  For instance, libsignal will accept it.\n        let minus_one = MontgomeryPoint((-&one).to_bytes());\n\n        assert!(minus_one.to_edwards(0).is_none());\n    }",
    "display_name": "montgomery_to_edwards_rejects_twist",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/len",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/scalar_mul/precomputed_straus/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/len"
    ],
    "body": "    pub fn len(&self) -> usize {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.len(),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.len(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.len(),\n        }\n    }",
    "display_name": "len",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/multiscalar_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 multiscalar_benches/consttime_multiscalar_mul",
      "5.0.0_pre.0 multiscalar_benches/vartime_precomputed_pure_static",
      "5.0.0_pre.0 multiscalar_benches/vartime_multiscalar_mul",
      "5.0.0_pre.0 multiscalar_benches/vartime_precomputed_helper"
    ],
    "body": "    pub(crate) fn multiscalar_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"multiscalar benches\");\n\n        consttime_multiscalar_mul(&mut g);\n        vartime_multiscalar_mul(&mut g);\n        vartime_precomputed_pure_static(&mut g);\n\n        let dynamic_fracs = [0.0, 0.2, 0.5];\n\n        for frac in dynamic_fracs.iter() {\n            vartime_precomputed_helper(&mut g, *frac);\n        }\n    }",
    "display_name": "multiscalar_benches",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/crate::EdwardsPoint/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/split"
    ],
    "body": "    fn from(P: ExtendedPoint) -> edwards::EdwardsPoint {\n        let tmp = P.0.split();\n        edwards::EdwardsPoint {\n            X: tmp[0],\n            Y: tmp[1],\n            Z: tmp[2],\n            T: tmp[3],\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.X.zeroize();\n        self.Y = FieldElement::ONE;\n        self.Z = FieldElement::ONE;\n        self.T.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 rfc7748_ladder_test2",
    "statement_type": "function",
    "deps": [],
    "body": "fn rfc7748_ladder_test2() {\n    use curve25519_dalek::constants::X25519_BASEPOINT;\n\n    let mut k: [u8; 32] = X25519_BASEPOINT.0;\n    let mut u: [u8; 32] = X25519_BASEPOINT.0;\n    let mut result: [u8; 32];\n\n    macro_rules! do_iterations {\n        ($n:expr) => {\n            for _ in 0..$n {\n                result = x25519(k, u);\n                // OBVIOUS THING THAT I'M GOING TO NOTE ANYWAY BECAUSE I'VE\n                // SEEN PEOPLE DO THIS WITH GOLANG'S STDLIB AND YOU SURE AS\n                // HELL SHOULDN'T DO HORRIBLY STUPID THINGS LIKE THIS WITH\n                // MY LIBRARY:\n                //\n                // NEVER EVER TREAT SCALARS AS POINTS AND/OR VICE VERSA.\n                //\n                //                ↓↓ DON'T DO THIS ↓↓\n                u = k.clone();\n                k = result;\n            }\n        };\n    }\n\n    // After one iteration:\n    //     422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079\n    // After 1,000 iterations:\n    //     684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51\n    // After 1,000,000 iterations:\n    //     7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424\n\n    do_iterations!(1);\n    assert_eq!(\n        k,\n        [\n            0x42, 0x2c, 0x8e, 0x7a, 0x62, 0x27, 0xd7, 0xbc, 0xa1, 0x35, 0x0b, 0x3e, 0x2b, 0xb7,\n            0x27, 0x9f, 0x78, 0x97, 0xb8, 0x7b, 0xb6, 0x85, 0x4b, 0x78, 0x3c, 0x60, 0xe8, 0x03,\n            0x11, 0xae, 0x30, 0x79,\n        ]\n    );\n    do_iterations!(999);\n    assert_eq!(\n        k,\n        [\n            0x68, 0x4c, 0xf5, 0x9b, 0xa8, 0x33, 0x09, 0x55, 0x28, 0x00, 0xef, 0x56, 0x6f, 0x2f,\n            0x4d, 0x3c, 0x1c, 0x38, 0x87, 0xc4, 0x93, 0x60, 0xe3, 0x87, 0x5f, 0x2e, 0xb9, 0x4d,\n            0x99, 0x53, 0x2c, 0x51,\n        ]\n    );\n    do_iterations!(999_000);\n    assert_eq!(\n        k,\n        [\n            0x7c, 0x39, 0x11, 0xe0, 0xab, 0x25, 0x86, 0xfd, 0x86, 0x44, 0x97, 0x29, 0x7e, 0x57,\n            0x5e, 0x6f, 0x3b, 0xc6, 0x01, 0xc0, 0x88, 0x3c, 0x30, 0xdf, 0x5f, 0x4d, 0xd2, 0xd2,\n            0x4f, 0x66, 0x54, 0x24,\n        ]\n    );\n}",
    "display_name": "rfc7748_ladder_test2",
    "full_path": "file:///work/3118/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/from_bytes"
    ],
    "body": "    fn from(secret: SecretKey) -> Self {\n        Self::from_bytes(&secret)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/compressed_identity",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/Identity/identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress_batch"
    ],
    "body": "    fn compressed_identity() {\n        assert_eq!(\n            EdwardsPoint::identity().compress(),\n            CompressedEdwardsY::identity()\n        );\n\n        #[cfg(feature = \"alloc\")]\n        {\n            let compressed = EdwardsPoint::compress_batch(&[EdwardsPoint::identity()]);\n            assert_eq!(&compressed, &[CompressedEdwardsY::identity()]);\n        }\n    }",
    "display_name": "compressed_identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/to_bytes_from_bytes_roundtrips",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_bytes",
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/to_bytes"
    ],
    "body": "    fn to_bytes_from_bytes_roundtrips() {\n        let unpacked = X.unpack();\n        let bytes = unpacked.to_bytes();\n        let should_be_unpacked = UnpackedScalar::from_bytes(&bytes);\n\n        assert_eq!(should_be_unpacked.0, unpacked.0);\n    }",
    "display_name": "to_bytes_from_bytes_roundtrips",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/reduce"
    ],
    "body": "    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> Scalar {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }",
    "display_name": "from_bytes_mod_order",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/StaticSecret/Drop/drop",
    "statement_type": "function",
    "deps": [],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/pippenger/test/test_vartime_pippenger",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/invert",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn test_vartime_pippenger() {\n        // Reuse points across different tests\n        let mut n = 512;\n        let x = Scalar::from(2128506u64).invert();\n        let y = Scalar::from(4443282u64).invert();\n        let points: Vec<_> = (0..n)\n            .map(|i| constants::ED25519_BASEPOINT_POINT * Scalar::from(1 + i as u64))\n            .collect();\n        let scalars: Vec<_> = (0..n)\n            .map(|i| x + (Scalar::from(i as u64) * y)) // fast way to make ~random but deterministic scalars\n            .collect();\n\n        let premultiplied: Vec<EdwardsPoint> = scalars\n            .iter()\n            .zip(points.iter())\n            .map(|(sc, pt)| sc * pt)\n            .collect();\n\n        while n > 0 {\n            let scalars = &scalars[0..n].to_vec();\n            let points = &points[0..n].to_vec();\n            let control: EdwardsPoint = premultiplied[0..n].iter().sum();\n\n            let subject = Pippenger::vartime_multiscalar_mul(scalars.clone(), points.clone());\n\n            assert_eq!(subject.compress(), control.compress());\n\n            n /= 2;\n        }\n    }",
    "display_name": "test_vartime_pippenger",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_projective",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n        }\n    }",
    "display_name": "as_projective",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 impl/DalekBits/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let w_bits = match self {\n            DalekBits::Dalek32 => \"32\",\n            DalekBits::Dalek64 => \"64\",\n        };\n        write!(f, \"{}\", w_bits)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/new"
    ],
    "body": "    fn from(P: edwards::EdwardsPoint) -> ExtendedPoint {\n        ExtendedPoint(FieldElement2625x4::new(&P.X, &P.Y, &P.Z, &P.T))\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/is_small_order",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/is_small_order"
    ],
    "body": "    fn is_small_order() {\n        // The basepoint has large prime order\n        assert!(!constants::ED25519_BASEPOINT_POINT.is_small_order());\n        // constants::EIGHT_TORSION has all points of small order.\n        for torsion_point in &constants::EIGHT_TORSION {\n            assert!(torsion_point.is_small_order());\n        }\n    }",
    "display_name": "is_small_order",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/SharedSecret/was_contributory",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity"
    ],
    "body": "    pub fn was_contributory(&self) -> bool {\n        !self.0.is_identity()\n    }",
    "display_name": "was_contributory",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/non_adjacent_form_iter",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/non_adjacent_form",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn non_adjacent_form_iter(w: usize, x: &Scalar) {\n        let naf = x.non_adjacent_form(w);\n\n        // Reconstruct the scalar from the computed NAF\n        let mut y = Scalar::ZERO;\n        for i in (0..256).rev() {\n            y += y;\n            let digit = if naf[i] < 0 {\n                -Scalar::from((-naf[i]) as u64)\n            } else {\n                Scalar::from(naf[i] as u64)\n            };\n            y += digit;\n        }\n\n        assert_eq!(*x, y);\n    }",
    "display_name": "non_adjacent_form_iter",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/RCompute/compute",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/RCompute/update",
      "3.0.0_pre.0 verifying/impl/RCompute/finish",
      "3.0.0_pre.0 verifying/impl/RCompute/new"
    ],
    "body": "    pub(crate) fn compute(\n        key: &VerifyingKey,\n        signature: InternalSignature,\n        prehash_ctx: Option<&[u8]>,\n        message: &[&[u8]],\n    ) -> CompressedEdwardsY {\n        let mut c = Self::new(key, signature, prehash_ctx);\n        message.iter().for_each(|slice| c.update(slice));\n        c.finish()\n    }",
    "display_name": "compute",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u64x4/splat_const",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u64x4/new_const"
    ],
    "body": "    pub const fn splat_const<const N: u64>() -> Self {\n        Self::new_const(N, N, N, N)\n    }",
    "display_name": "splat_const",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/PublicKey/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base_clamped"
    ],
    "body": "    fn from(secret: &'a StaticSecret) -> PublicKey {\n        PublicKey(EdwardsPoint::mul_base_clamped(secret.0).to_montgomery())\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Sum/sum",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity"
    ],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/m",
    "statement_type": "function",
    "deps": [],
    "body": "        fn m(x: u64, y: u64) -> (z: u128)\n        requires\n            x < (1u64 << 52),\n            y < (1u64 << 52),\n        ensures\n            z < (1u128 << 104),\n            z == x * y\n        {\n            proof {\n                assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n                assert((x as u128) < (1u128 << 52));\n                assert((y as u128) < (1u128 << 52));\n                calc! {\n                    (<)\n                    (x as u128) * (y as u128); (<=) {\n                        if x > 0 {\n                            lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                        } else {\n                            assert(x == 0);\n                            assert((x as u128) * (y as u128) == 0);\n                            assert((x as u128) * (1u128 << 52) == 0);\n                        }\n                    }\n                    (x as u128) * (1u128 << 52); (<) {\n                        lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n                    }\n                    (1u128 << 52) * (1u128 << 52);\n                }\n                assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n            }\n            (x as u128) * (y as u128)\n        }",
    "display_name": "m",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/ExpandedSecretKey/raw_sign_byupdate",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 scalar/impl/Scalar/from_hash",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/as_bytes"
    ],
    "body": "    pub(crate) fn raw_sign_byupdate<CtxDigest, F>(\n        &self,\n        msg_update: F,\n        verifying_key: &VerifyingKey,\n    ) -> Result<Signature, SignatureError>\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n        F: Fn(&mut CtxDigest) -> Result<(), SignatureError>,\n    {\n        let mut h = CtxDigest::new();\n\n        h.update(self.hash_prefix);\n        msg_update(&mut h)?;\n\n        let r = Scalar::from_hash(h);\n        let R: CompressedEdwardsY = EdwardsPoint::mul_base(&r).compress();\n\n        h = CtxDigest::new();\n        h.update(R.as_bytes());\n        h.update(verifying_key.as_bytes());\n        msg_update(&mut h)?;\n\n        let k = Scalar::from_hash(h);\n        let s: Scalar = (k * self.scalar) + r;\n\n        Ok(InternalSignature { R, s }.into())\n    }",
    "display_name": "raw_sign_byupdate",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n            T: &self.X * &self.Y,\n        }\n    }",
    "display_name": "as_extended",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/test/impl/ExpandedSecretKey/random",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/from_bytes"
    ],
    "body": "        fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n            let mut bytes = [0u8; 64];\n            rng.fill_bytes(&mut bytes);\n            ExpandedSecretKey::from_bytes(&bytes)\n        }",
    "display_name": "random",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/vartime_double_base_scalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/vartime_double_scalar_mul_basepoint"
    ],
    "body": "    fn vartime_double_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"Variable-time aA+bB, A variable, B fixed\", |bench| {\n            let mut rng = rng();\n            let A = EdwardsPoint::mul_base(&Scalar::random(&mut rng));\n            bench.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| EdwardsPoint::vartime_double_scalar_mul_basepoint(&a, &A, &b),\n                BatchSize::SmallInput,\n            );\n        });\n    }",
    "display_name": "vartime_double_base_scalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/optional_mixed_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/optional_mixed_multiscalar_mul"
    ],
    "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points.into_iter().map(|P_opt| P_opt.map(|P| P.0)),\n            )\n            .map(RistrettoPoint)\n    }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/basepoint_roundtrip",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/decompress",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/Identity/identity"
    ],
    "body": "    fn basepoint_roundtrip() {\n        let bp_compressed_ristretto = constants::RISTRETTO_BASEPOINT_POINT.compress();\n        let bp_recaf = bp_compressed_ristretto.decompress().unwrap().0;\n        // Check that bp_recaf differs from bp by a point of order 4\n        let diff = constants::RISTRETTO_BASEPOINT_POINT.0 - bp_recaf;\n        let diff4 = diff.mul_by_pow_2(2);\n        assert_eq!(diff4.compress(), CompressedEdwardsY::identity());\n    }",
    "display_name": "basepoint_roundtrip",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/decompress/step_2",
      "5.0.0_pre.0 edwards/decompress/step_1"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/bits_le",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n        (0..256).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }",
    "display_name": "bits_le",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/vartime_precomputed_vs_nonprecomputed_multiscalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/len",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/mul_base",
      "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/is_empty",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul"
    ],
    "body": "    fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let static_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let check_scalar: Scalar = static_scalars\n            .iter()\n            .chain(dynamic_scalars.iter())\n            .map(|s| s * s)\n            .sum();\n\n        let static_points = static_scalars\n            .iter()\n            .map(RistrettoPoint::mul_base)\n            .collect::<Vec<_>>();\n        let dynamic_points = dynamic_scalars\n            .iter()\n            .map(RistrettoPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n\n        assert_eq!(precomputation.len(), 128);\n        assert!(!precomputation.is_empty());\n\n        let P = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        use crate::traits::VartimeMultiscalarMul;\n        let Q = RistrettoPoint::vartime_multiscalar_mul(\n            static_scalars.iter().chain(dynamic_scalars.iter()),\n            static_points.iter().chain(dynamic_points.iter()),\n        );\n\n        let R = RistrettoPoint::mul_base(&check_scalar);\n\n        assert_eq!(P.compress(), R.compress());\n        assert_eq!(Q.compress(), R.compress());\n    }",
    "display_name": "vartime_precomputed_vs_nonprecomputed_multiscalar",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/pick_r",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Neg/neg",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    fn pick_r(s: Scalar) -> EdwardsPoint {\n        let r0 = s * ED25519_BASEPOINT_POINT;\n        // Pick a torsion point of order 2\n        r0 + WEAK_PUBKEY.decompress().unwrap().neg()\n    }",
    "display_name": "pick_r",
    "full_path": "file:///work/3118/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_affine_niels",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert"
    ],
    "body": "    pub(crate) fn as_affine_niels(&self) -> AffineNielsPoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let xy2d = &(&x * &y) * &constants::EDWARDS_D2;\n        AffineNielsPoint {\n            y_plus_x: &y + &x,\n            y_minus_x: &y - &x,\n            xy2d,\n        }\n    }",
    "display_name": "as_affine_niels",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/is_weak",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/is_small_order"
    ],
    "body": "    pub fn is_weak(&self) -> bool {\n        self.point.is_small_order()\n    }",
    "display_name": "is_weak",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/verifying_key",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn verifying_key(&self) -> VerifyingKey {\n        self.verifying_key\n    }",
    "display_name": "verifying_key",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/new"
    ],
    "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(static_points))\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/precomputed_straus/spec/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/is_",
    "statement_type": "function",
    "deps": [],
    "body": "        fn is_empty(&self) -> bool {\n            self.static_lookup_tables.is_empty()\n        }",
    "display_name": "is_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/pippenger/spec/impl/Pippenger/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Identity/identity",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/to_radix_2w_size_hint"
    ],
    "body": "        fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let mut scalars = scalars.into_iter();\n            let size = scalars.by_ref().size_hint().0;\n            let w = if size < 500 {\n                6\n            } else if size < 800 {\n                7\n            } else {\n                8\n            };\n\n            let max_digit: usize = 1 << w;\n            let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n            let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n            // Collect optimized scalars and points in a buffer for repeated access\n            // (scanning the whole collection per each digit position).\n            let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n            let points = points\n                .into_iter()\n                .map(|p| p.map(|P| CachedPoint::from(ExtendedPoint::from(P))));\n\n            let scalars_points = scalars\n                .zip(points)\n                .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n                .collect::<Option<Vec<_>>>()?;\n\n            // Prepare 2^w/2 buckets.\n            // buckets[i] corresponds to a multiplication factor (i+1).\n            let mut buckets: Vec<ExtendedPoint> = (0..buckets_count)\n                .map(|_| ExtendedPoint::identity())\n                .collect();\n\n            let mut columns = (0..digits_count).rev().map(|digit_index| {\n                // Clear the buckets when processing another digit.\n                for bucket in &mut buckets {\n                    *bucket = ExtendedPoint::identity();\n                }\n\n                // Iterate over pairs of (point, scalar)\n                // and add/sub the point to the corresponding bucket.\n                // Note: if we add support for precomputed lookup tables,\n                // we'll be adding/subtractiong point premultiplied by `digits[i]` to buckets[0].\n                for (digits, pt) in scalars_points.iter() {\n                    // Widen digit so that we don't run into edge cases when w=8.\n                    let digit = digits[digit_index] as i16;\n                    match digit.cmp(&0) {\n                        Ordering::Greater => {\n                            let b = (digit - 1) as usize;\n                            buckets[b] = &buckets[b] + pt;\n                        }\n                        Ordering::Less => {\n                            let b = (-digit - 1) as usize;\n                            buckets[b] = &buckets[b] - pt;\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n\n                // Add the buckets applying the multiplication factor to each bucket.\n                // The most efficient way to do that is to have a single sum with two running sums:\n                // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n                //\n                // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n                //   C\n                //   C B\n                //   C B A   Sum = C + (C+B) + (C+B+A)\n                let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n                let mut buckets_sum = buckets[buckets_count - 1];\n                for i in (0..(buckets_count - 1)).rev() {\n                    buckets_intermediate_sum =\n                        &buckets_intermediate_sum + &CachedPoint::from(buckets[i]);\n                    buckets_sum = &buckets_sum + &CachedPoint::from(buckets_intermediate_sum);\n                }\n\n                buckets_sum\n            });\n\n            // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n            let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n            Some(\n                columns\n                    .fold(hi_column, |total, p| {\n                        &total.mul_by_pow_2(w as u32) + &CachedPoint::from(p)\n                    })\n                    .into(),\n            )\n        }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.0.conditional_assign(&other.0, choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/get_selected_backend",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/cpuid_avx2/init",
      "5.0.0_pre.0 backend/cpuid_avx2/impl/InitToken/get"
    ],
    "body": "fn get_selected_backend() -> BackendKind {\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    {\n        cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n        let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n        if token_avx512.get() {\n            return BackendKind::Avx512;\n        }\n    }\n\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    {\n        cpufeatures::new!(cpuid_avx2, \"avx2\");\n        let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n        if token_avx2.get() {\n            return BackendKind::Avx2;\n        }\n    }\n\n    BackendKind::Serial\n}",
    "display_name": "get_selected_backend",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/impl_sum",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let BASE = constants::RISTRETTO_BASEPOINT_POINT;\n\n        let s1 = Scalar::from(999u64);\n        let P1 = BASE * s1;\n\n        let s2 = Scalar::from(333u64);\n        let P2 = BASE * s2;\n\n        let vec = vec![P1, P2];\n        let sum: RistrettoPoint = vec.iter().sum();\n\n        assert_eq!(sum, P1 + P2);\n\n        // Test that sum works for the empty iterator\n        let empty_vector: Vec<RistrettoPoint> = vec![];\n        let sum: RistrettoPoint = empty_vector.iter().sum();\n\n        assert_eq!(sum, RistrettoPoint::identity());\n\n        // Test that sum works on owning iterators\n        let s = Scalar::from(2u64);\n        let mapped = vec.iter().map(|x| x * s);\n        let sum: RistrettoPoint = mapped.sum();\n\n        assert_eq!(sum, P1 * s + P2 * s);\n    }",
    "display_name": "impl_sum",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/partial_precomputed_multiscalar_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/random",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity"
    ],
    "body": "    fn partial_precomputed_multiscalar_empty() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use zero scalars\n        let static_scalars = Vec::new();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_multiscalar_mul(&static_scalars);\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }",
    "display_name": "partial_precomputed_multiscalar_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 rfc7748_ladder_test1_vectorset1",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 do_rfc7748_ladder_test1"
    ],
    "body": "fn rfc7748_ladder_test1_vectorset1() {\n    let input_scalar: [u8; 32] = [\n        0xa5, 0x46, 0xe3, 0x6b, 0xf0, 0x52, 0x7c, 0x9d, 0x3b, 0x16, 0x15, 0x4b, 0x82, 0x46, 0x5e,\n        0xdd, 0x62, 0x14, 0x4c, 0x0a, 0xc1, 0xfc, 0x5a, 0x18, 0x50, 0x6a, 0x22, 0x44, 0xba, 0x44,\n        0x9a, 0xc4,\n    ];\n    let input_point: [u8; 32] = [\n        0xe6, 0xdb, 0x68, 0x67, 0x58, 0x30, 0x30, 0xdb, 0x35, 0x94, 0xc1, 0xa4, 0x24, 0xb1, 0x5f,\n        0x7c, 0x72, 0x66, 0x24, 0xec, 0x26, 0xb3, 0x35, 0x3b, 0x10, 0xa9, 0x03, 0xa6, 0xd0, 0xab,\n        0x1c, 0x4c,\n    ];\n    let expected: [u8; 32] = [\n        0xc3, 0xda, 0x55, 0x37, 0x9d, 0xe9, 0xc6, 0x90, 0x8e, 0x94, 0xea, 0x4d, 0xf2, 0x8d, 0x08,\n        0x4f, 0x32, 0xec, 0xcf, 0x03, 0x49, 0x1c, 0x71, 0xf7, 0x54, 0xb4, 0x07, 0x55, 0x77, 0xa2,\n        0x85, 0x52,\n    ];\n\n    do_rfc7748_ladder_test1(input_scalar, input_point, expected);\n}",
    "display_name": "rfc7748_ladder_test1_vectorset1",
    "full_path": "file:///work/3118/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/square_internal",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/mul_internal"
    ],
    "body": "    pub fn square(&self) -> (result: Scalar52)\n    requires\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &RR))\n    }",
    "display_name": "square",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectiveNielsPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "0.1.1 inner_spec/spec_function",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn spec_function(a: u32, b: u32) -> u32 {\n        a - b - CONST\n    }",
    "display_name": "spec_function",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/new_const",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn new_const(\n        x0: u32,\n        x1: u32,\n        x2: u32,\n        x3: u32,\n        x4: u32,\n        x5: u32,\n        x6: u32,\n        x7: u32,\n    ) -> Self {\n        // SAFETY: Transmuting between an array and a SIMD type is safe\n        // https://rust-lang.github.io/unsafe-code-guidelines/layout/packed-simd-vectors.html\n        unsafe {\n            Self(\n                core::mem::transmute::<[u32; 8], core::arch::x86_64::__m256i>([\n                    x0, x1, x2, x3, x4, x5, x6, x7,\n                ]),\n            )\n        }\n    }",
    "display_name": "new_const",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"ExpandedSecretKey\").finish_non_exhaustive() // avoids printing secrets\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"CompletedPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "3.0.0_pre.0 rfc7748_ladder_test1_vectorset2",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 do_rfc7748_ladder_test1"
    ],
    "body": "fn rfc7748_ladder_test1_vectorset2() {\n    let input_scalar: [u8; 32] = [\n        0x4b, 0x66, 0xe9, 0xd4, 0xd1, 0xb4, 0x67, 0x3c, 0x5a, 0xd2, 0x26, 0x91, 0x95, 0x7d, 0x6a,\n        0xf5, 0xc1, 0x1b, 0x64, 0x21, 0xe0, 0xea, 0x01, 0xd4, 0x2c, 0xa4, 0x16, 0x9e, 0x79, 0x18,\n        0xba, 0x0d,\n    ];\n    let input_point: [u8; 32] = [\n        0xe5, 0x21, 0x0f, 0x12, 0x78, 0x68, 0x11, 0xd3, 0xf4, 0xb7, 0x95, 0x9d, 0x05, 0x38, 0xae,\n        0x2c, 0x31, 0xdb, 0xe7, 0x10, 0x6f, 0xc0, 0x3c, 0x3e, 0xfc, 0x4c, 0xd5, 0x49, 0xc7, 0x15,\n        0xa4, 0x93,\n    ];\n    let expected: [u8; 32] = [\n        0x95, 0xcb, 0xde, 0x94, 0x76, 0xe8, 0x90, 0x7d, 0x7a, 0xad, 0xe4, 0x5c, 0xb4, 0xb8, 0x73,\n        0xf8, 0x8b, 0x59, 0x5a, 0x68, 0x79, 0x9f, 0xa1, 0x52, 0xe6, 0xf8, 0xf7, 0x64, 0x7a, 0xac,\n        0x79, 0x57,\n    ];\n\n    do_rfc7748_ladder_test1(input_scalar, input_point, expected);\n}",
    "display_name": "rfc7748_ladder_test1_vectorset2",
    "full_path": "file:///work/3118/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> CompressedEdwardsY {\n        CompressedEdwardsY([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ])\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery_batch",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/batch_invert",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    pub fn to_montgomery_batch(eds: &[Self]) -> Vec<MontgomeryPoint> {\n        // Do the same thing as the above function. u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        // We will do this in a batch, ie compute (Z-Y) for all the input\n        // points, then invert them all at once\n\n        // Compute the denominators in a batch\n        let mut denominators = eds.iter().map(|p| &p.Z - &p.Y).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut denominators);\n\n        // Now compute the Montgomery u coordinate for every point\n        let mut ret = Vec::with_capacity(eds.len());\n        for (ed, d) in eds.iter().zip(denominators.iter()) {\n            let u = &(&ed.Z + &ed.Y) * d;\n            ret.push(MontgomeryPoint(u.to_bytes()));\n        }\n\n        ret\n    }",
    "display_name": "to_montgomery_batch",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/&EdwardsPoint/Sub/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective_niels"
    ],
    "body": "    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/multiscalar_consistency_n_250",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/test/multiscalar_consistency_iter"
    ],
    "body": "    fn multiscalar_consistency_n_250() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(250);\n        }\n    }",
    "display_name": "multiscalar_consistency_n_250",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/try_from_rng",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/from_uniform_bytes"
    ],
    "body": "    pub fn try_from_rng<R: TryCryptoRng + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut uniform_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n\n        Ok(RistrettoPoint::from_uniform_bytes(&uniform_bytes))\n    }",
    "display_name": "try_from_rng",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/elligator_encode",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/sqrt_ratio_i",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_select",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square2"
    ],
    "body": "pub(crate) fn elligator_encode(r_0: &FieldElement) -> (MontgomeryPoint, Choice) {\n    let one = FieldElement::ONE;\n    let d_1 = &one + &r_0.square2(); /* 2r^2 */\n\n    let d = &MONTGOMERY_A_NEG * &(d_1.invert()); /* A/(1+2r^2) */\n\n    let d_sq = &d.square();\n    let au = &MONTGOMERY_A * &d;\n\n    let inner = &(d_sq + &au) + &one;\n    let eps = &d * &inner; /* eps = d^3 + Ad^2 + d */\n\n    let (eps_is_sq, _eps) = FieldElement::sqrt_ratio_i(&eps, &one);\n\n    let zero = FieldElement::ZERO;\n    let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/\n    let mut u = &d + &Atemp; /* d, or d+A if nonsquare */\n    u.conditional_negate(!eps_is_sq); /* d, or -d-A if nonsquare */\n\n    (MontgomeryPoint(u.to_bytes()), eps_is_sq)\n}",
    "display_name": "elligator_encode",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/&RistrettoBasepointTable/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, scalar: &'b Scalar) -> RistrettoPoint {\n        RistrettoPoint(&self.0 * scalar)\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/mul32",
      "5.0.0_pre.0 backend/vector/avx2/field/unpack_pair",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/reduce64",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/new"
    ],
    "body": "    fn mul(self, scalars: (u32, u32, u32, u32)) -> FieldElement2625x4 {\n        let consts = u32x8::new(scalars.0, 0, scalars.1, 0, scalars.2, 0, scalars.3, 0);\n\n        let (b0, b1) = unpack_pair(self.0[0]);\n        let (b2, b3) = unpack_pair(self.0[1]);\n        let (b4, b5) = unpack_pair(self.0[2]);\n        let (b6, b7) = unpack_pair(self.0[3]);\n        let (b8, b9) = unpack_pair(self.0[4]);\n\n        FieldElement2625x4::reduce64([\n            b0.mul32(consts),\n            b1.mul32(consts),\n            b2.mul32(consts),\n            b3.mul32(consts),\n            b4.mul32(consts),\n            b5.mul32(consts),\n            b6.mul32(consts),\n            b7.mul32(consts),\n            b8.mul32(consts),\n            b9.mul32(consts),\n        ])\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/mul_internal",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_reduce"
    ],
    "body": "    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        forall|i: int| 0 <= i < 5 ==> a.limbs[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b.limbs[i] < (1u64 << 52),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }",
    "display_name": "montgomery_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 traits/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "    fn create(basepoint: &Self::Point) -> Self;\n\n    /// Retrieve the original basepoint from this table.\n    fn basepoint(&self) -> Self::Point;\n\n    /// Multiply a `scalar` by this precomputed basepoint table, in constant time.\n    fn mul_base(&self, scalar: &Scalar) -> Self::Point;\n\n    /// Multiply `clamp_integer(bytes)` by this precomputed basepoint table, in constant time. For\n    /// a description of clamping, see [`clamp_integer`].\n    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
    "display_name": "create",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/scalar_mul_vs_ed25519py",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn scalar_mul_vs_ed25519py() {\n        let aB = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n        assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n    }",
    "display_name": "scalar_mul_vs_ed25519py",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, point: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self * point.0)\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/affine/impl/AffinePoint/to_edwards"
    ],
    "body": "    fn mul(self, rhs: &AffinePoint) -> EdwardsPoint {\n        rhs.to_edwards() * self\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul_internal",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/m"
    ],
    "body": "    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9] {\n        let mut z = [0u128; 9];\n\n        z[0] = m(a[0], b[0]);\n        z[1] = m(a[0], b[1]) + m(a[1], b[0]);\n        z[2] = m(a[0], b[2]) + m(a[1], b[1]) + m(a[2], b[0]);\n        z[3] = m(a[0], b[3]) + m(a[1], b[2]) + m(a[2], b[1]) + m(a[3], b[0]);\n        z[4] = m(a[0], b[4]) + m(a[1], b[3]) + m(a[2], b[2]) + m(a[3], b[1]) + m(a[4], b[0]);\n        z[5] =                 m(a[1], b[4]) + m(a[2], b[3]) + m(a[3], b[2]) + m(a[4], b[1]);\n        z[6] =                                 m(a[2], b[4]) + m(a[3], b[3]) + m(a[4], b[2]);\n        z[7] =                                                 m(a[3], b[4]) + m(a[4], b[3]);\n        z[8] =                                                                 m(a[4], b[4]);\n\n        z\n    }",
    "display_name": "mul_internal",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoBasepointTable/basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTable/BasepointTable/basepoint"
    ],
    "body": "    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }",
    "display_name": "basepoint",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 impl/StructWithGenerics/member_function",
    "statement_type": "function",
    "deps": [],
    "body": "    fn member_function(&self, b: T) -> T::Output {\n        self.a - b\n    }",
    "display_name": "member_function",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/&Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/sub",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul_internal"
    ],
    "body": "    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/test_scalar_clamp",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    fn test_scalar_clamp() {\n        let input = A_SCALAR.bytes;\n        let expected = [\n            0x18, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n            0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n            0x23, 0x76, 0xef, 0x49,\n        ];\n        let actual = clamp_integer(input);\n        assert_eq!(actual, expected);\n\n        let expected = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0x40,\n        ];\n        let actual = clamp_integer([0; 32]);\n        assert_eq!(expected, actual);\n        let expected = [\n            0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0x7f,\n        ];\n        let actual = clamp_integer([0xff; 32]);\n        assert_eq!(actual, expected);\n\n        assert_eq!(\n            LARGEST_CLAMPED_INTEGER,\n            clamp_integer(LARGEST_CLAMPED_INTEGER)\n        );\n    }",
    "display_name": "test_scalar_clamp",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 byte_basepoint_matches_edwards_scalar_mul",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/x25519",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base_clamped",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_bytes"
    ],
    "body": "fn byte_basepoint_matches_edwards_scalar_mul() {\n    let mut scalar_bytes = [0x37; 32];\n\n    for i in 0..32 {\n        scalar_bytes[i] += 2;\n\n        let result = x25519(scalar_bytes, X25519_BASEPOINT_BYTES);\n        let expected = EdwardsPoint::mul_base_clamped(scalar_bytes)\n            .to_montgomery()\n            .to_bytes();\n\n        assert_eq!(result, expected);\n    }\n}",
    "display_name": "byte_basepoint_matches_edwards_scalar_mul",
    "full_path": "file:///work/3118/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 constants/test/test_sqrt_a_minus_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "    fn test_sqrt_a_minus_2() {\n        let one = FieldElement::ONE;\n        let a_minus_two = &(&constants::MONTGOMERY_A_NEG - &one) - &one;\n\n        assert_eq!(constants::ED25519_SQRTAM2.square(), a_minus_two)\n    }",
    "display_name": "test_sqrt_a_minus_2",
    "full_path": "file:///work/3118/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/hash_to_curve",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_edwards",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/hash_to_field",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_bytes",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_cofactor",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
      "5.0.0_pre.0 montgomery/elligator_encode"
    ],
    "body": "    pub fn hash_to_curve<D>(bytes: &[&[u8]], domain_sep: &[&[u8]]) -> EdwardsPoint\n    where\n        D: BlockSizeUser + Default + FixedOutput<OutputSize = U64> + HashMarker,\n        D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    {\n        // For reference see\n        // https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method-2\n\n        let fe = FieldElement::hash_to_field::<D>(bytes, domain_sep);\n        let (M1, is_sq) = crate::montgomery::elligator_encode(&fe);\n\n        // The `to_edwards` conversion we're performing takes as input the sign of the Edwards\n        // `y` coordinate. However, the specification uses `is_sq` to determine the sign of the\n        // Montgomery `v` coordinate. Our approach reconciles this mismatch as follows:\n        //\n        // * We arbitrarily fix the sign of the Edwards `y` coordinate (we choose 0).\n        // * Using the Montgomery `u` coordinate and the Edwards `X` coordinate, we recover `v`.\n        // * We verify that the sign of `v` matches the expected one, i.e., `is_sq == mont_v.is_negative()`.\n        // * If it does not match, we conditionally negate to correct the sign.\n        //\n        // Note: This logic aligns with the RFC draft specification:\n        //     https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method-2\n        // followed by the mapping\n        //     https://www.rfc-editor.org/rfc/rfc9380.html#name-mappings-for-twisted-edward\n        // The only difference is that our `elligator_encode` returns only the Montgomery `u` coordinate,\n        // so we apply this workaround to reconstruct and validate the sign.\n\n        let mut E1_opt = M1\n            .to_edwards(0)\n            .expect(\"Montgomery conversion to Edwards point in Elligator failed\");\n\n        // Now we recover v, to ensure that we got the sign right.\n        let mont_v =\n            &(&ED25519_SQRTAM2 * &FieldElement::from_bytes(&M1.to_bytes())) * &E1_opt.X.invert();\n        E1_opt.X.conditional_negate(is_sq ^ mont_v.is_negative());\n        E1_opt.mul_by_cofactor()\n    }",
    "display_name": "hash_to_curve",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Scalar {\n        Scalar::ZERO\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/tests/identity_conversion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/affine/impl/AffinePoint/Identity/identity",
      "5.0.0_pre.0 edwards/affine/impl/AffinePoint/to_edwards",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity"
    ],
    "body": "    fn identity_conversion() {\n        assert_eq!(\n            AffinePoint::identity().to_edwards(),\n            EdwardsPoint::identity()\n        );\n    }",
    "display_name": "identity_conversion",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/hash_from_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/from_hash"
    ],
    "body": "    pub fn hash_from_bytes<D>(input: &[u8]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        RistrettoPoint::from_hash(hash)\n    }",
    "display_name": "hash_from_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/Sum/sum",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity"
    ],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/From/from",
      "3.0.0_pre.0 signing/impl/ExpandedSecretKey/From/from"
    ],
    "body": "    pub fn from_bytes(secret_key: &SecretKey) -> Self {\n        let verifying_key = VerifyingKey::from(&ExpandedSecretKey::from(secret_key));\n        Self {\n            secret_key: *secret_key,\n            verifying_key,\n        }\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base_clamped",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix256/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_clamped",
      "5.0.0_pre.0 traits/BasepointTable/mul_base_clamped"
    ],
    "body": "    fn mul_base_clamped() {\n        let mut csprng = rand_core::OsRng;\n\n        // Make a random curve point in the curve. Give it torsion to make things interesting.\n        #[cfg(feature = \"precomputed-tables\")]\n        let random_point = {\n            let mut b = [0u8; 32];\n            csprng.try_fill_bytes(&mut b).unwrap();\n            EdwardsPoint::mul_base_clamped(b) + constants::EIGHT_TORSION[1]\n        };\n        // Make a basepoint table from the random point. We'll use this with mul_base_clamped\n        #[cfg(feature = \"precomputed-tables\")]\n        let random_table = EdwardsBasepointTableRadix256::create(&random_point);\n\n        // Now test scalar mult. agreement on the default basepoint as well as random_point\n\n        // Test that mul_base_clamped and mul_clamped agree on a large integer. Even after\n        // clamping, this integer is not reduced mod l.\n        let a_bytes = [0xff; 32];\n        assert_eq!(\n            EdwardsPoint::mul_base_clamped(a_bytes),\n            constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n        );\n        #[cfg(feature = \"precomputed-tables\")]\n        assert_eq!(\n            random_table.mul_base_clamped(a_bytes),\n            random_point.mul_clamped(a_bytes)\n        );\n\n        // Test agreement on random integers\n        for _ in 0..100 {\n            // This will be reduced mod l with probability l / 2^256 ≈ 6.25%\n            let mut a_bytes = [0u8; 32];\n            csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n            assert_eq!(\n                EdwardsPoint::mul_base_clamped(a_bytes),\n                constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n            );\n            #[cfg(feature = \"precomputed-tables\")]\n            assert_eq!(\n                random_table.mul_base_clamped(a_bytes),\n                random_point.mul_clamped(a_bytes)\n            );\n        }\n    }",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/as_bytes"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedRistretto: {:?}\", self.as_bytes())\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 constants/test/test_sqrt_minus_one",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative"
    ],
    "body": "    fn test_sqrt_minus_one() {\n        let minus_one = FieldElement::MINUS_ONE;\n        let sqrt_m1_sq = &constants::SQRT_M1 * &constants::SQRT_M1;\n        assert_eq!(minus_one, sqrt_m1_sq);\n        assert!(bool::from(!constants::SQRT_M1.is_negative()));\n    }",
    "display_name": "test_sqrt_minus_one",
    "full_path": "file:///work/3118/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/as_radix_2w",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/read_le_u64_into",
      "5.0.0_pre.0 scalar/impl/Scalar/as_radix_16"
    ],
    "body": "    pub(crate) fn as_radix_2w(&self, w: usize) -> [i8; 64] {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        if w == 4 {\n            return self.as_radix_16();\n        }\n\n        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.\n        let mut scalar64x4 = [0u64; 4];\n        read_le_u64_into(&self.bytes, &mut scalar64x4[0..4]);\n\n        let radix: u64 = 1 << w;\n        let window_mask: u64 = radix - 1;\n\n        let mut carry = 0u64;\n        let mut digits = [0i8; 64];\n        let digits_count = 256_usize.div_ceil(w);\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }\n\n        // When 4 < w < 8, we can fold the final carry onto the last digit d,\n        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.\n        //\n        // When w = 8, we can't fit carry*2^w into an i8.  This should\n        // not happen anyways, because the final carry will be 0 for\n        // reduced scalars, but Scalar invariant #1 allows 255-bit scalars.\n        // To handle this, we expand the size_hint by 1 when w=8,\n        // and accumulate the final carry onto another digit.\n        match w {\n            8 => digits[digits_count] += carry as i8,\n            _ => digits[digits_count - 1] += (carry << w) as i8,\n        }\n\n        digits\n    }",
    "display_name": "as_radix_2w",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/to_edwards",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_edwards(&self) -> EdwardsPoint {\n        self.point\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    fn ct_eq(&self, other: &FieldElement) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/BatchCompressState/efgh",
    "statement_type": "function",
    "deps": [],
    "body": "            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }",
    "display_name": "efgh",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/ProjectivePoint/as_affine",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes"
    ],
    "body": "    pub fn as_affine(&self) -> MontgomeryPoint {\n        let u = &self.U * &self.W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
    "display_name": "as_affine",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/square_max",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/square"
    ],
    "body": "    fn square_max() {\n        let res = X.square();\n        for i in 0..5 {\n            assert!(res[i] == XX[i]);\n        }\n    }",
    "display_name": "square_max",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce",
    "statement_type": "function",
    "deps": [],
    "body": "    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> Scalar52 {\n\n        #[inline(always)]\n        fn part1(sum: u128) -> (u128, u64) {\n            let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n            ((sum + m(p, constants::L[0])) >> 52, p)\n        }\n\n        #[inline(always)]\n        fn part2(sum: u128) -> (u128, u64) {\n            let w = (sum as u64) & ((1u64 << 52) - 1);\n            (sum >> 52, w)\n        }\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = part1(        limbs[0]);\n        let (carry, n1) = part1(carry + limbs[1] + m(n0, l[1]));\n        let (carry, n2) = part1(carry + limbs[2] + m(n0, l[2]) + m(n1, l[1]));\n        let (carry, n3) = part1(carry + limbs[3]               + m(n1, l[2]) + m(n2, l[1]));\n        let (carry, n4) = part1(carry + limbs[4] + m(n0, l[4])               + m(n2, l[2]) + m(n3, l[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = part2(carry + limbs[5]               + m(n1, l[4])               + m(n3, l[2])   + m(n4, l[1]));\n        let (carry, r1) = part2(carry + limbs[6]                             + m(n2,l[4])                  + m(n4, l[2]));\n        let (carry, r2) = part2(carry + limbs[7]                                           + m(n3, l[4])                );\n        let (carry, r3) = part2(carry + limbs[8]                                                           + m(n4, l[4]));\n        let         r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52([r0, r1, r2, r3, r4]), l)\n    }",
    "display_name": "montgomery_reduce",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/EphemeralSecret/Drop/drop",
    "statement_type": "function",
    "deps": [],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/decompress/step_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> EdwardsPoint {\n         // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n         // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n        X.conditional_negate(compressed_sign_bit);\n\n        EdwardsPoint {\n            X,\n            Y,\n            Z,\n            T: &X * &Y,\n        }\n    }",
    "display_name": "step_2",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectiveNielsPoint/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_bytes_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_mul",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/add"
    ],
    "body": "    pub fn from_bytes_wide(bytes: &[u8; 64]) -> Scalar52 {\n        let mut words = [0u64; 8];\n        for i in 0..8 {\n            for j in 0..8 {\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52::ZERO;\n        let mut hi = Scalar52::ZERO;\n\n        lo[0] =   words[0]                             & mask;\n        lo[1] = ((words[0] >> 52) | (words[ 1] << 12)) & mask;\n        lo[2] = ((words[1] >> 40) | (words[ 2] << 24)) & mask;\n        lo[3] = ((words[2] >> 28) | (words[ 3] << 36)) & mask;\n        lo[4] = ((words[3] >> 16) | (words[ 4] << 48)) & mask;\n        hi[0] =  (words[4] >>  4)                      & mask;\n        hi[1] = ((words[4] >> 56) | (words[ 5] <<  8)) & mask;\n        hi[2] = ((words[5] >> 44) | (words[ 6] << 20)) & mask;\n        hi[3] = ((words[6] >> 32) | (words[ 7] << 32)) & mask;\n        hi[4] =   words[7] >> 20                             ;\n\n        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar52::add(&hi, &lo)\n    }",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 constants/test/test_d_vs_ratio",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert"
    ],
    "body": "    fn test_d_vs_ratio() {\n        use crate::backend::serial::u64::field::FieldElement51;\n        let a = -&FieldElement51([121665, 0, 0, 0, 0]);\n        let b = FieldElement51([121666, 0, 0, 0, 0]);\n        let d = &a * &b.invert();\n        let d2 = &d + &d;\n        assert_eq!(d, constants::EDWARDS_D);\n        assert_eq!(d2, constants::EDWARDS_D2);\n    }",
    "display_name": "test_d_vs_ratio",
    "full_path": "file:///work/3118/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/BatchCompressState/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/BatchCompressState/efgh",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_assign",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/batch_invert",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    pub fn from_bytes(bytes: &[u8; PUBLIC_KEY_LENGTH]) -> Result<VerifyingKey, SignatureError> {\n        let compressed = CompressedEdwardsY(*bytes);\n        let point = compressed\n            .decompress()\n            .ok_or(InternalError::PointDecompression)?;\n\n        // Invariant: VerifyingKey.1 is always the decompression of VerifyingKey.0\n        Ok(VerifyingKey { compressed, point })\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/montgomery_mul_bits_be_twist",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_bits_be",
      "5.0.0_pre.0 montgomery/test/bytestring_bits_le"
    ],
    "body": "    fn montgomery_mul_bits_be_twist() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            // Make a random point P on the curve or its twist\n            let p_montgomery = {\n                let mut buf = [0u8; 32];\n                csprng.fill_bytes(&mut buf);\n                MontgomeryPoint(buf)\n            };\n\n            // Compute two big integers b₁ and b₂\n            let mut bigint1 = [0u8; 64];\n            let mut bigint2 = [0u8; 64];\n            csprng.fill_bytes(&mut bigint1[..]);\n            csprng.fill_bytes(&mut bigint2[..]);\n\n            // Compute b₁P and b₂P\n            let bigint1_bits_be = bytestring_bits_le(&bigint1).rev();\n            let bigint2_bits_be = bytestring_bits_le(&bigint2).rev();\n            let prod1 = p_montgomery.mul_bits_be(bigint1_bits_be.clone());\n            let prod2 = p_montgomery.mul_bits_be(bigint2_bits_be.clone());\n\n            // Check that b₁(b₂P) == b₂(b₁P)\n            assert_eq!(\n                prod1.mul_bits_be(bigint2_bits_be),\n                prod2.mul_bits_be(bigint1_bits_be)\n            );\n        }\n    }",
    "display_name": "montgomery_mul_bits_be_twist",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/from_bytes_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_bytes_wide"
    ],
    "body": "    fn from_bytes_wide() {\n        let bignum = [255u8; 64]; // 2^512 - 1\n        let reduced = Scalar52::from_bytes_wide(&bignum);\n        for i in 0..5 {\n            assert!(reduced[i] == C[i]);\n        }\n    }",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/four_torsion_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/coset4"
    ],
    "body": "    fn four_torsion_basepoint() {\n        let bp = constants::RISTRETTO_BASEPOINT_POINT;\n        let bp_coset = bp.coset4();\n        for point in bp_coset {\n            assert_eq!(bp, RistrettoPoint(point));\n        }\n    }",
    "display_name": "four_torsion_basepoint",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/load8_at",
    "statement_type": "function",
    "deps": [],
    "body": "        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }",
    "display_name": "load8_at",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_bytes_wide"
    ],
    "body": "    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }",
    "display_name": "from_bytes_mod_order_wide",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/a_square2_vs_a_squared_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square2"
    ],
    "body": "    fn a_square2_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(a.square2(), &asq + &asq);\n    }",
    "display_name": "a_square2_vs_a_squared_constant",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/montgomery_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_mul"
    ],
    "body": "    fn montgomery_mul() {\n        let res = Scalar52::montgomery_mul(&X, &Y);\n        for i in 0..5 {\n            assert!(res[i] == XY_MONT[i]);\n        }\n    }",
    "display_name": "montgomery_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/vartime_precomputed_pure_static",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 multiscalar_benches/construct_points",
      "5.0.0_pre.0 multiscalar_benches/construct_scalars"
    ],
    "body": "    fn vartime_precomputed_pure_static<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Variable-time fixed-base multiscalar multiplication\",\n                    multiscalar_size,\n                ),\n                &multiscalar_size,\n                move |b, &&total_size| {\n                    let static_size = total_size;\n\n                    let static_points = construct_points(static_size);\n                    let precomp = VartimeEdwardsPrecomputation::new(static_points);\n                    // Rerandomize the scalars for every call to prevent\n                    // false timings from better caching (e.g., the CPU\n                    // cache lifts exactly the right table entries for the\n                    // benchmark into the highest cache levels).\n                    b.iter_batched(\n                        || construct_scalars(static_size),\n                        |scalars| precomp.vartime_multiscalar_mul(scalars),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }",
    "display_name": "vartime_precomputed_pure_static",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"VerifyingKey({:?}), {:?})\", self.compressed, self.point)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(x: u128) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/compute_challenge",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 scalar/impl/Scalar/from_hash"
    ],
    "body": "    fn compute_challenge(\n        message: &[u8],\n        pub_key: &EdwardsPoint,\n        signature_r: &EdwardsPoint,\n        context: Option<&[u8]>,\n    ) -> Scalar {\n        let mut h = Sha512::default();\n        if let Some(c) = context {\n            h.update(b\"SigEd25519 no Ed25519 collisions\");\n            h.update([1]);\n            h.update([c.len() as u8]);\n            h.update(c);\n        }\n        h.update(signature_r.compress().as_bytes());\n        h.update(&pub_key.compress().as_bytes()[..]);\n        h.update(message);\n        Scalar::from_hash(h)\n    }",
    "display_name": "compute_challenge",
    "full_path": "file:///work/3118/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 main",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 is_capable_simd",
      "5.0.0_pre.0 deterministic/determine_curve25519_dalek_bits"
    ],
    "body": "fn main() {\n    let target_arch = match std::env::var(\"CARGO_CFG_TARGET_ARCH\") {\n        Ok(arch) => arch,\n        _ => \"\".to_string(),\n    };\n\n    let curve25519_dalek_bits = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BITS\").as_deref() {\n        Ok(\"32\") => DalekBits::Dalek32,\n        Ok(\"64\") => DalekBits::Dalek64,\n        _ => deterministic::determine_curve25519_dalek_bits(&target_arch),\n    };\n\n    println!(\"cargo:rustc-cfg=curve25519_dalek_bits=\\\"{curve25519_dalek_bits}\\\"\");\n\n    let nightly = if rustc_version::version_meta()\n        .expect(\"failed to detect rustc version\")\n        .channel\n        == rustc_version::Channel::Nightly\n    {\n        println!(\"cargo:rustc-cfg=nightly\");\n        true\n    } else {\n        false\n    };\n\n    let rustc_version = rustc_version::version().expect(\"failed to detect rustc version\");\n    if rustc_version.major == 1 && rustc_version.minor <= 64 {\n        // Old versions of Rust complain when you have an `unsafe fn` and you use `unsafe {}` inside,\n        // so for those we want to apply the `#[allow(unused_unsafe)]` attribute to get rid of that warning.\n        println!(\"cargo:rustc-cfg=allow_unused_unsafe\");\n    }\n\n    // Backend overrides / defaults\n    let curve25519_dalek_backend = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BACKEND\")\n        .as_deref()\n    {\n        Ok(\"fiat\") => \"fiat\",\n        Ok(\"serial\") => \"serial\",\n        Ok(\"simd\") => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => \"simd\",\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to simd\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if nightly => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => {\n                    // In addition enable Avx2 fallback through simd stable backend\n                    // NOTE: Compiler permits duplicate / multi value on the same key\n                    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"simd\\\"\");\n\n                    \"unstable_avx512\"\n                }\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to unstable_avx512\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if !nightly => {\n            panic!(\n                \"Could not override curve25519_dalek_backend to unstable_avx512, as this is nightly only\"\n            );\n        }\n        // default between serial / simd (if potentially capable)\n        _ => match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n            true => \"simd\",\n            false => \"serial\",\n        },\n    };\n    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"{curve25519_dalek_backend}\\\"\");\n}",
    "display_name": "main",
    "full_path": "file:///work/3118/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/vartime/multiscalar_mul_vs_ed25519py",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress"
    ],
    "body": "        fn multiscalar_mul_vs_ed25519py() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result = EdwardsPoint::vartime_multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n            assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n        }",
    "display_name": "multiscalar_mul_vs_ed25519py",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/four_torsion_random",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/mul_base",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/coset4",
      "5.0.0_pre.0 scalar/impl/Scalar/random"
    ],
    "body": "    fn four_torsion_random() {\n        let mut rng = OsRng.unwrap_err();\n        let P = RistrettoPoint::mul_base(&Scalar::random(&mut rng));\n        let P_coset = P.coset4();\n        for point in P_coset {\n            assert_eq!(P, RistrettoPoint(point));\n        }\n    }",
    "display_name": "four_torsion_random",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order",
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    pub fn from_bytes(bytes: &[u8; 64]) -> Self {\n        // TODO: Use bytes.split_array_ref once it’s in MSRV.\n        let mut scalar_bytes: [u8; 32] = [0u8; 32];\n        let mut hash_prefix: [u8; 32] = [0u8; 32];\n        scalar_bytes.copy_from_slice(&bytes[00..32]);\n        hash_prefix.copy_from_slice(&bytes[32..64]);\n\n        // For signing, we'll need the integer, clamped, and converted to a Scalar. See\n        // PureEdDSA.keygen in RFC 8032 Appendix A.\n        let scalar = Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes));\n\n        ExpandedSecretKey {\n            scalar,\n            hash_prefix,\n        }\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/non_adjacent_form_test_vector",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/non_adjacent_form"
    ],
    "body": "    fn non_adjacent_form_test_vector() {\n        let naf = A_SCALAR.non_adjacent_form(5);\n        for i in 0..256 {\n            assert_eq!(naf[i], A_NAF[i]);\n        }\n    }",
    "display_name": "non_adjacent_form_test_vector",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/len",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/len"
    ],
    "body": "    fn len(&self) -> usize {\n        self.0.len()\n    }",
    "display_name": "len",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_mult_two_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base"
    ],
    "body": "    fn basepoint_mult_two_vs_basepoint2() {\n        let two = Scalar::from(2u64);\n        let bp2 = EdwardsPoint::mul_base(&two);\n        assert_eq!(bp2.compress(), BASE2_CMPRSSD);\n    }",
    "display_name": "basepoint_mult_two_vs_basepoint2",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/&FieldElement51/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/test_read_le_u64_into",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/read_le_u64_into"
    ],
    "body": "    fn test_read_le_u64_into() {\n        let cases: &[(&[u8], &[u64])] = &[\n            (\n                &[0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F, 0xF0],\n                &[0xF00F_F11F_0110_EFFE],\n            ),\n            (\n                &[\n                    0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A,\n                    0xBC, 0xDE, 0xF0,\n                ],\n                &[0xF00F_F11F_0110_EFFE, 0xF0DE_BC9A_7856_3412],\n            ),\n        ];\n\n        for (src, expected) in cases {\n            let mut dst = vec![0; expected.len()];\n            read_le_u64_into(src, &mut dst);\n\n            assert_eq!(&dst, expected, \"Expected {:x?} got {:x?}\", expected, dst);\n        }\n    }",
    "display_name": "test_read_le_u64_into",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/NafLookupTable5/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/double",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/From/from",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/From/from"
    ],
    "body": "    fn from(point: &edwards::EdwardsPoint) -> Self {\n        let A = ExtendedPoint::from(*point);\n        let mut Ai = [CachedPoint::from(A); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).into();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_projective_extended_round_trip",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/as_extended",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective"
    ],
    "body": "    fn basepoint_projective_extended_round_trip() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT\n                .as_projective()\n                .as_extended()\n                .compress(),\n            constants::ED25519_BASEPOINT_COMPRESSED\n        );\n    }",
    "display_name": "basepoint_projective_extended_round_trip",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/verifying_key"
    ],
    "body": "    fn from(signing_key: &SigningKey) -> VerifyingKey {\n        signing_key.verifying_key()\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/montgomery_elligator_correct",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_bytes",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 montgomery/elligator_encode"
    ],
    "body": "    fn montgomery_elligator_correct() {\n        let bytes: Vec<u8> = (0u8..32u8).collect();\n        let bits_in: [u8; 32] = (&bytes[..]).try_into().expect(\"Range invariant broken\");\n\n        let fe = FieldElement::from_bytes(&bits_in);\n        let (eg, _) = elligator_encode(&fe);\n        assert_eq!(eg.to_bytes(), ELLIGATOR_CORRECT_OUTPUT);\n    }",
    "display_name": "montgomery_elligator_correct",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.secret_key.ct_eq(&other.secret_key)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/from_slice",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/from_bytes"
    ],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<Self, SignatureError> {\n        // Try to coerce bytes to a [u8; 64]\n        bytes.try_into().map(Self::from_bytes).map_err(|_| {\n            InternalError::BytesLength {\n                name: \"ExpandedSecretKey\",\n                length: 64,\n            }\n            .into()\n        })\n    }",
    "display_name": "from_slice",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_benches/batch_scalar_inversion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/batch_invert",
      "5.0.0_pre.0 scalar/impl/Scalar/random"
    ],
    "body": "    fn batch_scalar_inversion<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in &BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch scalar inversion\", *batch_size),\n                &batch_size,\n                |b, &&size| {\n                    let mut rng = OsRng.unwrap_err();\n                    let scalars: Vec<Scalar> =\n                        (0..size).map(|_| Scalar::random(&mut rng)).collect();\n                    b.iter(|| {\n                        let mut s = scalars.clone();\n                        Scalar::batch_invert(&mut s);\n                    });\n                },\n            );\n        }\n    }",
    "display_name": "batch_scalar_inversion",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/variable_base_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 backend/serial/scalar_mul/variable_base/mul"
    ],
    "body": "pub fn variable_base_mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => vector::scalar_mul::variable_base::spec_avx2::mul(point, scalar),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::variable_base::spec_avx512ifma_avx512vl::mul(point, scalar)\n        }\n        BackendKind::Serial => serial::scalar_mul::variable_base::mul(point, scalar),\n    }\n}",
    "display_name": "variable_base_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invsqrt",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_assign"
    ],
    "body": "    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let u1 = &(Z + &Y) * &(Z - &Y);\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let (_, invsqrt) = (&u1 * &u2.square()).invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let z_inv = &i1 * &(&i2 * T);\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let rotate = (T * &z_inv).is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        Y.conditional_negate((&X * &z_inv).is_negative());\n\n        let mut s = &den_inv * &(Z - &Y);\n        let s_is_negative = s.is_negative();\n        s.conditional_negate(s_is_negative);\n\n        CompressedRistretto(s.to_bytes())\n    }",
    "display_name": "compress",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity"
    ],
    "body": "    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/decompression_sign_handling",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress"
    ],
    "body": "    fn decompression_sign_handling() {\n        // Manually set the high bit of the last byte to flip the sign\n        let mut minus_basepoint_bytes = *constants::ED25519_BASEPOINT_COMPRESSED.as_bytes();\n        minus_basepoint_bytes[31] |= 1 << 7;\n        let minus_basepoint = CompressedEdwardsY(minus_basepoint_bytes)\n            .decompress()\n            .unwrap();\n        // Test projective coordinates exactly since we know they should\n        // only differ by a flipped sign.\n        assert_eq!(minus_basepoint.X, -(&constants::ED25519_BASEPOINT_POINT.X));\n        assert_eq!(minus_basepoint.Y, constants::ED25519_BASEPOINT_POINT.Y);\n        assert_eq!(minus_basepoint.Z, constants::ED25519_BASEPOINT_POINT.Z);\n        assert_eq!(minus_basepoint.T, -(&constants::ED25519_BASEPOINT_POINT.T));\n    }",
    "display_name": "decompression_sign_handling",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/straus_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 backend/serial/scalar_mul/straus/impl/Straus/MultiscalarMul/multiscalar_mul"
    ],
    "body": "pub fn straus_multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator,\n    J::Item: core::borrow::Borrow<EdwardsPoint>,\n{\n    use crate::traits::MultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => {\n            vector::scalar_mul::straus::spec_avx2::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
    "display_name": "straus_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.bytes\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/hash_to_field",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/hash_to_field"
    ],
    "body": "    fn hash_to_field() {\n        use sha2::Sha512;\n        let dst = \"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n\n        for (msg, expected_hash_hex) in RFC_HASH_TO_FIELD_KAT {\n            let fe = FieldElement::hash_to_field::<Sha512>(&[msg], &[dst.as_bytes()]);\n            let expected_fe = {\n                let mut expected_hash = hex::decode(expected_hash_hex).unwrap();\n                expected_hash.reverse();\n                FieldElement::from_bytes(&expected_hash.try_into().unwrap())\n            };\n\n            assert_eq!(fe, expected_fe);\n        }\n    }",
    "display_name": "hash_to_field",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> ExtendedPoint {\n        constants::EXTENDEDPOINT_IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u64x4/new_const",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn new_const(x0: u64, x1: u64, x2: u64, x3: u64) -> Self {\n        // SAFETY: Transmuting between an array and a SIMD type is safe\n        // https://rust-lang.github.io/unsafe-code-guidelines/layout/packed-simd-vectors.html\n        unsafe {\n            Self(core::mem::transmute::<[u64; 4], core::arch::x86_64::__m256i>([x0, x1, x2, x3]))\n        }\n    }",
    "display_name": "new_const",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/m_lo",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/mul32",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/reduce64",
      "5.0.0_pre.0 backend/vector/avx2/field/unpack_pair",
      "5.0.0_pre.0 backend/vector/avx2/field/m",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/new",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u64x4/splat",
      "5.0.0_pre.0 backend/vector/avx2/field/repack_pair"
    ],
    "body": "        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }",
    "display_name": "m_lo",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/as_radix_16",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn as_radix_16(&self) -> [i8; 64] {\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8; 64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[allow(clippy::identity_op)]\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        for i in 0..32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        output\n    }",
    "display_name": "as_radix_16",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/precomputed_straus/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 window/impl/NafLookupTable8/From/from"
    ],
    "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self {\n            static_lookup_tables: static_points\n                .into_iter()\n                .map(|P| NafLookupTable8::<AffineNielsPoint>::from(P.borrow()))\n                .collect(),\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 window/impl/NafLookupTable8/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective_niels",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/double"
    ],
    "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.0[..])\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/From/from"
    ],
    "body": "    fn from(expanded_secret_key: &ExpandedSecretKey) -> VerifyingKey {\n        VerifyingKey::from(EdwardsPoint::mul_base(&expanded_secret_key.scalar))\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/ExpandedSecretKey/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/from_bytes"
    ],
    "body": "    fn from(secret_key: &SecretKey) -> ExpandedSecretKey {\n        let hash = Sha512::default().chain_update(secret_key).finalize();\n        ExpandedSecretKey::from_bytes(hash.as_ref())\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul_internal",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce"
    ],
    "body": "    pub fn mul(a: &Scalar52, b: &Scalar52) -> Scalar52 {\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR))\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/montgomery_mul_max",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_mul"
    ],
    "body": "    fn montgomery_mul_max() {\n        let res = Scalar52::montgomery_mul(&X, &X);\n        for i in 0..5 {\n            assert!(res[i] == XX_MONT[i]);\n        }\n    }",
    "display_name": "montgomery_mul_max",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/to_scalar_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_scalar_bytes(&self) -> [u8; 32] {\n        // Per the spec, the ed25519 secret key sk is expanded to\n        //     (scalar_bytes, hash_prefix) = SHA-512(sk)\n        // where the two outputs are both 32 bytes. scalar_bytes is what we return. Its clamped and\n        // reduced form is what we use for signing (see impl ExpandedSecretKey)\n        let mut buf = [0u8; 32];\n        let scalar_and_hash_prefix = Sha512::default().chain_update(self.secret_key).finalize();\n        buf.copy_from_slice(&scalar_and_hash_prefix[..32]);\n        buf\n    }",
    "display_name": "to_scalar_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/RCompute/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    pub(crate) fn new(\n        key: &VerifyingKey,\n        signature: InternalSignature,\n        prehash_ctx: Option<&[u8]>,\n    ) -> Self {\n        let R = &signature.R;\n        let A = &key.compressed;\n\n        let mut h = CtxDigest::new();\n        if let Some(c) = prehash_ctx {\n            h.update(b\"SigEd25519 no Ed25519 collisions\");\n            h.update([1]); // Ed25519ph\n            h.update([c.len() as u8]);\n            h.update(c);\n        }\n\n        h.update(R.as_bytes());\n        h.update(A.as_bytes());\n        Self {\n            key: *key,\n            signature,\n            h,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/pow2k",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn pow2k(&self, mut k: u32) -> FieldElement51 {\n\n        debug_assert!( k > 0 );\n\n        /// Multiply two 64-bit integers with 128 bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }\n\n        let mut a: [u64; 5] = self.0;\n\n        loop {\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n\n            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n\n            k -= 1;\n            if k == 0 {\n                break;\n            }\n        }\n\n        FieldElement51(a)\n    }",
    "display_name": "pow2k",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/mul_internal",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/m"
    ],
    "body": "    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9]\n    requires\n        forall|i: int| 0 <= i < 5 ==> a.limbs[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b.limbs[i] < (1u64 << 52),\n    {\n        let mut z = [0u128; 9];\n\n        z[0] = m(a.limbs[0], b.limbs[0]);\n        assume(false);\n        z[1] = m(a.limbs[0], b.limbs[1]) + m(a.limbs[1], b.limbs[0]);\n        z[2] = m(a.limbs[0], b.limbs[2]) + m(a.limbs[1], b.limbs[1]) + m(a.limbs[2], b.limbs[0]);\n        z[3] = m(a.limbs[0], b.limbs[3]) + m(a.limbs[1], b.limbs[2]) + m(a.limbs[2], b.limbs[1]) + m(a.limbs[3], b.limbs[0]);\n        z[4] = m(a.limbs[0], b.limbs[4]) + m(a.limbs[1], b.limbs[3]) + m(a.limbs[2], b.limbs[2]) + m(a.limbs[3], b.limbs[1]) + m(a.limbs[4], b.limbs[0]);\n        z[5] =                 m(a.limbs[1], b.limbs[4]) + m(a.limbs[2], b.limbs[3]) + m(a.limbs[3], b.limbs[2]) + m(a.limbs[4], b.limbs[1]);\n        z[6] =                                 m(a.limbs[2], b.limbs[4]) + m(a.limbs[3], b.limbs[3]) + m(a.limbs[4], b.limbs[2]);\n        z[7] =                                                 m(a.limbs[3], b.limbs[4]) + m(a.limbs[4], b.limbs[3]);\n        z[8] =                                                                 m(a.limbs[4], b.limbs[4]);\n\n        z\n    }",
    "display_name": "mul_internal",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 constants/test/test_eight_torsion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/ValidityCheck/is_valid",
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity"
    ],
    "body": "    fn test_eight_torsion() {\n        for i in 0..8 {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(3);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }",
    "display_name": "test_eight_torsion",
    "full_path": "file:///work/3118/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 function",
    "statement_type": "function",
    "deps": [],
    "body": "fn function(a: u32, b: u32) -> u32 {\n    a - b\n}",
    "display_name": "function",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/compress_id",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity",
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/Identity/identity",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress"
    ],
    "body": "    fn compress_id() {\n        let id = RistrettoPoint::identity();\n        assert_eq!(id.compress(), CompressedRistretto::identity());\n    }",
    "display_name": "compress_id",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 deterministic/determine_curve25519_dalek_bits",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 deterministic/determine_curve25519_dalek_bits_warning"
    ],
    "body": "    pub(super) fn determine_curve25519_dalek_bits(target_arch: &String) -> DalekBits {\n        let target_pointer_width = match std::env::var(\"CARGO_CFG_TARGET_POINTER_WIDTH\") {\n            Ok(pw) => pw,\n            Err(_) => {\n                determine_curve25519_dalek_bits_warning(ERR_MSG_NO_POINTER_WIDTH);\n                return DalekBits::Dalek32;\n            }\n        };\n\n        #[allow(clippy::match_single_binding)]\n        match &target_arch {\n            //Issues: 449 and 456\n            //TODO: When adding arch defaults use proper types not String match\n            //TODO(Arm): Needs tests + benchmarks to back this up\n            //TODO(Wasm32): Needs tests + benchmarks to back this up\n            _ => match target_pointer_width.as_ref() {\n                \"64\" => DalekBits::Dalek64,\n                \"32\" => DalekBits::Dalek32,\n                // Intended default solely for non-32/64 target pointer widths\n                // Otherwise known target platforms only.\n                _ => {\n                    determine_curve25519_dalek_bits_warning(ERR_MSG_UNKNOWN_POINTER_WIDTH);\n                    DalekBits::Dalek32\n                }\n            },\n        }\n    }",
    "display_name": "determine_curve25519_dalek_bits",
    "full_path": "file:///work/3118/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/batch_to_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery_batch"
    ],
    "body": "    fn batch_to_montgomery() {\n        let mut rng = rand::rng();\n\n        let scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let points = scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let single_monts = points\n            .iter()\n            .map(EdwardsPoint::to_montgomery)\n            .collect::<Vec<_>>();\n\n        for i in [0, 1, 2, 3, 10, 50, 128] {\n            let invs = EdwardsPoint::to_montgomery_batch(&points[..i]);\n            assert_eq!(&invs, &single_monts[..i]);\n        }\n    }",
    "display_name": "batch_to_montgomery",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/double",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/blend",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/square_and_negate_D",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/shuffle",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/negate_lazy"
    ],
    "body": "    pub fn double(&self) -> ExtendedPoint {\n        // Want to compute (X1 Y1 Z1 X1+Y1).\n        // Not sure how to do this less expensively than computing\n        // (X1 Y1 Z1 T1) --(256bit shuffle)--> (X1 Y1 X1 Y1)\n        // (X1 Y1 X1 Y1) --(2x128b shuffle)--> (Y1 X1 Y1 X1)\n        // and then adding.\n\n        // Set tmp0 = (X1 Y1 X1 Y1)\n        let mut tmp0 = self.0.shuffle(Shuffle::ABAB);\n\n        // Set tmp1 = (Y1 X1 Y1 X1)\n        let mut tmp1 = tmp0.shuffle(Shuffle::BADC);\n\n        // Set tmp0 = (X1 Y1 Z1 X1+Y1)\n        tmp0 = self.0.blend(tmp0 + tmp1, Lanes::D);\n\n        // Set tmp1 = tmp0^2, negating the D values\n        tmp1 = tmp0.square_and_negate_D();\n        // Now tmp1 = (S1 S2 S3 -S4) with b < 0.007\n\n        // See discussion of bounds in the module-level documentation.\n        // We want to compute\n        //\n        //    + | S1 | S1 | S1 | S1 |\n        //    + | S2 |    |    | S2 |\n        //    + |    |    | S3 |    |\n        //    + |    |    | S3 |    |\n        //    + |    |    |    |-S4 |\n        //    + |    | 2p | 2p |    |\n        //    - |    | S2 | S2 |    |\n        //    =======================\n        //        S5   S6   S8   S9\n\n        let zero = FieldElement2625x4::ZERO;\n        let S_1 = tmp1.shuffle(Shuffle::AAAA);\n        let S_2 = tmp1.shuffle(Shuffle::BBBB);\n\n        tmp0 = zero.blend(tmp1 + tmp1, Lanes::C);\n        // tmp0 = (0, 0,  2S_3, 0)\n        tmp0 = tmp0.blend(tmp1, Lanes::D);\n        // tmp0 = (0, 0,  2S_3, -S_4)\n        tmp0 = tmp0 + S_1;\n        // tmp0 = (  S_1,   S_1, S_1 + 2S_3, S_1 - S_4)\n        tmp0 = tmp0 + zero.blend(S_2, Lanes::AD);\n        // tmp0 = (S_1 + S_2,   S_1, S_1 + 2S_3, S_1 + S_2 - S_4)\n        tmp0 = tmp0 + zero.blend(S_2.negate_lazy(), Lanes::BC);\n        // tmp0 = (S_1 + S_2, S_1 - S_2, S_1 - S_2 + 2S_3, S_1 + S_2 - S_4)\n        //    b < (     1.01,       1.6,             2.33,             1.6)\n        // Now tmp0 = (S_5, S_6, S_8, S_9)\n\n        // Set tmp1 = ( S_9,  S_6,  S_6,  S_9)\n        //        b < ( 1.6,  1.6,  1.6,  1.6)\n        tmp1 = tmp0.shuffle(Shuffle::DBBD);\n        // Set tmp0 = ( S_8,  S_5,  S_8,  S_5)\n        //        b < (2.33, 1.01, 2.33, 1.01)\n        tmp0 = tmp0.shuffle(Shuffle::CACA);\n\n        // Bounds on (tmp0, tmp1) are (2.33, 1.6) < (2.5, 1.75).\n        ExtendedPoint(&tmp0 * &tmp1)\n    }",
    "display_name": "double",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/reduce",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul_internal"
    ],
    "body": "    fn reduce(&self) -> Scalar {\n        let x = self.unpack();\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        x_mod_l.pack()\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/sqrt_ratio_i",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_assign",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/ConstantTimeEq/ct_eq",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/pow_p58"
    ],
    "body": "    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (Choice, FieldElement) {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n        let flipped_sign_sqrt = check.ct_eq(&(-u));\n        let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        r.conditional_negate(r_is_negative);\n\n        let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n\n        (was_nonzero_square, r)\n    }",
    "display_name": "sqrt_ratio_i",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/from_hash",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/from_uniform_bytes"
    ],
    "body": "    pub fn from_hash<D>(hash: D) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        // dealing with generic arrays is clumsy, until const generics land\n        let output = hash.finalize();\n        let mut output_bytes = [0u8; 64];\n        output_bytes.copy_from_slice(output.as_slice());\n\n        RistrettoPoint::from_uniform_bytes(&output_bytes)\n    }",
    "display_name": "from_hash",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/square_internal",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/m"
    ],
    "body": "    pub (crate) fn square_internal(a: &Scalar52) -> [u128; 9]\n    requires\n        forall|i: int| 0 <= i < 5 ==> a.limbs[i] < (1u64 << 52),\n    {\n        let mut z = [0u128; 9];\n\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        assume(false);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(a.limbs[2], a.limbs[2]);\n        z[5] =                 m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] =                                 m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] =                                                 m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] =                                                                 m(a.limbs[4], a.limbs[4]);\n\n        z\n    }",
    "display_name": "square_internal",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/raw_sign",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/ExpandedSecretKey/raw_sign"
    ],
    "body": "pub fn raw_sign<CtxDigest>(\n    esk: &ExpandedSecretKey,\n    message: &[u8],\n    verifying_key: &VerifyingKey,\n) -> Signature\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    esk.raw_sign::<CtxDigest>(&[message], verifying_key)\n}",
    "display_name": "raw_sign",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_part1",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/m"
    ],
    "body": "    fn montgomery_part1(sum: u128) -> (u128, u64)\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let p = (sum as u64).wrapping_mul(LFACTOR) & ((1u64 << 52) - 1);\n        let carry = (sum + m(p, L.limbs[0])) >> 52;\n        (carry, p)\n    }",
    "display_name": "montgomery_part1",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/&FieldElement51/Sub/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/reduce"
    ],
    "body": "    fn sub(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        FieldElement51::reduce([\n            (self.0[0] + 36028797018963664u64) - _rhs.0[0],\n            (self.0[1] + 36028797018963952u64) - _rhs.0[1],\n            (self.0[2] + 36028797018963952u64) - _rhs.0[2],\n            (self.0[3] + 36028797018963952u64) - _rhs.0[3],\n            (self.0[4] + 36028797018963952u64) - _rhs.0[4],\n        ])\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/test_mul_reduction_invariance",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/reduce",
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    fn test_mul_reduction_invariance() {\n        let mut rng = rand::rng();\n\n        for _ in 0..10 {\n            // Also define c that's clamped. We'll make sure that clamping doesn't affect\n            // computation\n            let (a, b, c) = {\n                let mut a_bytes = [0u8; 32];\n                let mut b_bytes = [0u8; 32];\n                let mut c_bytes = [0u8; 32];\n                rng.fill_bytes(&mut a_bytes);\n                rng.fill_bytes(&mut b_bytes);\n                rng.fill_bytes(&mut c_bytes);\n                (\n                    Scalar { bytes: a_bytes },\n                    Scalar { bytes: b_bytes },\n                    Scalar {\n                        bytes: clamp_integer(c_bytes),\n                    },\n                )\n            };\n\n            // Make sure this is the same product no matter how you cut it\n            let reduced_mul_ab = a.reduce() * b.reduce();\n            let reduced_mul_ac = a.reduce() * c.reduce();\n            assert_eq!(a * b, reduced_mul_ab);\n            assert_eq!(a.reduce() * b, reduced_mul_ab);\n            assert_eq!(a * b.reduce(), reduced_mul_ab);\n            assert_eq!(a * c, reduced_mul_ac);\n            assert_eq!(a.reduce() * c, reduced_mul_ac);\n            assert_eq!(a * c.reduce(), reduced_mul_ac);\n        }\n    }",
    "display_name": "test_mul_reduction_invariance",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signature/check_scalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_canonical_bytes"
    ],
    "body": "fn check_scalar(bytes: [u8; 32]) -> Result<Scalar, SignatureError> {\n    match Scalar::from_canonical_bytes(bytes).into() {\n        None => Err(InternalError::ScalarFormat.into()),\n        Some(x) => Ok(x),\n    }\n}",
    "display_name": "check_scalar",
    "full_path": "file:///work/3118/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/MultipartSigner/try_multipart_sign",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/ExpandedSecretKey/raw_sign"
    ],
    "body": "    fn try_multipart_sign(&self, message: &[&[u8]]) -> Result<Signature, SignatureError> {\n        let expanded: ExpandedSecretKey = (&self.secret_key).into();\n        Ok(expanded.raw_sign::<Sha512>(message, &self.verifying_key))\n    }",
    "display_name": "try_multipart_sign",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/pow2k"
    ],
    "body": "    pub fn square2(&self) -> FieldElement51 {\n        let mut square = self.pow2k(1);\n        for i in 0..5 {\n            square.0[i] *= 2;\n        }\n\n        square\n    }",
    "display_name": "square2",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/elligator_hash_to_curve_test_vectors",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/hash_to_curve"
    ],
    "body": "    fn elligator_hash_to_curve_test_vectors() {\n        let dst = b\"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n        for (index, vector) in RFC_HASH_TO_CURVE_KAT.iter().enumerate() {\n            let input = vector.0;\n\n            let expected_output = {\n                let mut x_bytes = hex::decode(vector.1).unwrap();\n                x_bytes.reverse();\n                let x = FieldElement::from_bytes(&x_bytes.try_into().unwrap());\n\n                let mut y_bytes = hex::decode(vector.2).unwrap();\n                y_bytes.reverse();\n                let y = FieldElement::from_bytes(&y_bytes.try_into().unwrap());\n\n                EdwardsPoint {\n                    X: x,\n                    Y: y,\n                    Z: FieldElement::ONE,\n                    T: &x * &y,\n                }\n            };\n\n            let computed = EdwardsPoint::hash_to_curve::<sha2::Sha512>(&[&input], &[dst]);\n            assert_eq!(computed, expected_output, \"Failed in test {}\", index);\n        }\n    }",
    "display_name": "elligator_hash_to_curve_test_vectors",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/&RistrettoPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery_benches/montgomery_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery_benches/montgomery_ladder",
      "5.0.0_pre.0 montgomery_benches/consttime_fixed_base_scalar_mul"
    ],
    "body": "    pub(crate) fn montgomery_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"montgomery benches\");\n\n        montgomery_ladder(&mut g);\n        consttime_fixed_base_scalar_mul(&mut g);\n    }",
    "display_name": "montgomery_benches",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/Identity/identity"
    ],
    "body": "    fn default() -> CachedPoint {\n        CachedPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/negate",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/reduce"
    ],
    "body": "    pub fn negate(&mut self) {\n        // See commentary in the Sub impl\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.0[0],\n            36028797018963952u64 - self.0[1],\n            36028797018963952u64 - self.0[2],\n            36028797018963952u64 - self.0[3],\n            36028797018963952u64 - self.0[4],\n        ]);\n        self.0 = neg.0;\n    }",
    "display_name": "negate",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/non_null_scalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/random"
    ],
    "body": "    fn non_null_scalar() -> Scalar {\n        let mut rng = rand::rngs::OsRng.unwrap_err();\n        let mut s_candidate = Scalar::random(&mut rng);\n        while s_candidate == Scalar::ZERO {\n            s_candidate = Scalar::random(&mut rng);\n        }\n        s_candidate\n    }",
    "display_name": "non_null_scalar",
    "full_path": "file:///work/3118/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/as_bytes"
    ],
    "body": "    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, basepoint_table: &'a RistrettoBasepointTable) -> RistrettoPoint {\n        RistrettoPoint(self * &basepoint_table.0)\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/is_small_order",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_cofactor",
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity"
    ],
    "body": "    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }",
    "display_name": "is_small_order",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_mult_by_basepoint_order",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base"
    ],
    "body": "    fn basepoint_mult_by_basepoint_order() {\n        let should_be_id = EdwardsPoint::mul_base(&constants::BASEPOINT_ORDER);\n        assert!(should_be_id.is_identity());\n    }",
    "display_name": "basepoint_mult_by_basepoint_order",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/splat"
    ],
    "body": "    fn conditional_select(\n        a: &FieldElement2625x4,\n        b: &FieldElement2625x4,\n        choice: Choice,\n    ) -> FieldElement2625x4 {\n        let mask = (-(choice.unwrap_u8() as i32)) as u32;\n        let mask_vec = u32x8::splat(mask);\n        FieldElement2625x4([\n            a.0[0] ^ (mask_vec & (a.0[0] ^ b.0[0])),\n            a.0[1] ^ (mask_vec & (a.0[1] ^ b.0[1])),\n            a.0[2] ^ (mask_vec & (a.0[2] ^ b.0[2])),\n            a.0[3] ^ (mask_vec & (a.0[3] ^ b.0[3])),\n            a.0[4] ^ (mask_vec & (a.0[4] ^ b.0[4])),\n        ])\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/test_pippenger_radix_iter",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/reduce",
      "5.0.0_pre.0 scalar/impl/Scalar/as_radix_2w",
      "5.0.0_pre.0 scalar/impl/Scalar/to_radix_2w_size_hint"
    ],
    "body": "    fn test_pippenger_radix_iter(scalar: Scalar, w: usize) {\n        let digits_count = Scalar::to_radix_2w_size_hint(w);\n        let digits = scalar.as_radix_2w(w);\n\n        let radix = Scalar::from((1 << w) as u64);\n        let mut term = Scalar::ONE;\n        let mut recovered_scalar = Scalar::ZERO;\n        for digit in &digits[0..digits_count] {\n            let digit = *digit;\n            if digit != 0 {\n                let sdigit = if digit < 0 {\n                    -Scalar::from((-(digit as i64)) as u64)\n                } else {\n                    Scalar::from(digit as u64)\n                };\n                recovered_scalar += term * sdigit;\n            }\n            term *= radix;\n        }\n        // When the input is unreduced, we may only recover the scalar mod l.\n        assert_eq!(recovered_scalar, scalar.reduce());\n    }",
    "display_name": "test_pippenger_radix_iter",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/&RistrettoPoint/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 is_path_eq",
    "statement_type": "function",
    "deps": [],
    "body": "fn is_path_eq(path: &syn::Path, ident: &str) -> bool {\n    let segments: Vec<_> = ident.split(\"::\").collect();\n    path.segments.len() == segments.len()\n        && path\n            .segments\n            .iter()\n            .zip(segments.iter())\n            .all(|(segment, expected)| segment.ident == expected && segment.arguments.is_none())\n}",
    "display_name": "is_path_eq",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/PublicKey/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(bytes: [u8; 32]) -> PublicKey {\n        PublicKey(MontgomeryPoint(bytes))\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/add_reduces",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_reduces() {\n        // Check that addition wraps around the modulus\n        assert_eq!(BASEPOINT_ORDER_MINUS_ONE + Scalar::ONE, Scalar::ZERO);\n    }",
    "display_name": "add_reduces",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/Hash/hash",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/as_bytes"
    ],
    "body": "    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.as_bytes().hash(state);\n    }",
    "display_name": "hash",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/to_keypair_bytes",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/as_bytes"
    ],
    "body": "    pub fn to_keypair_bytes(&self) -> [u8; KEYPAIR_LENGTH] {\n        let mut bytes: [u8; KEYPAIR_LENGTH] = [0u8; KEYPAIR_LENGTH];\n\n        bytes[..SECRET_KEY_LENGTH].copy_from_slice(&self.secret_key);\n        bytes[SECRET_KEY_LENGTH..].copy_from_slice(self.verifying_key.as_bytes());\n        bytes\n    }",
    "display_name": "to_keypair_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/select"
    ],
    "body": "    pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        forall|i: int| 0 <= i < 5 ==> a.limbs[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b.limbs[i] < (1u64 << 52),\n    ensures\n        to_nat(&s.limbs) == to_nat(&a.limbs) - to_nat(&b.limbs),\n    {\n        //let mut difference = Scalar52::ZERO;\n         let mut difference = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof {\n            assert(Scalar52::ZERO == Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] });\n            assert(difference == Scalar52::ZERO);\n            assert(1u64 << 52 > 0) by (bit_vector);\n        }\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        for i in 0..5\n            invariant 0 <= i <= 5,\n                      forall|j: int| 0 <= j < 5 ==> b.limbs[j] < (1u64 << 52),\n        {\n            proof {\n                assert ((borrow >> 63) < 2) by (bit_vector);\n            }\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            difference.limbs[i] = borrow & mask;\n        }\n\n        // conditionally add l if the difference is negative\n        let mut carry: u64 = 0;\n        for i in 0..5 {\n            let underflow = Choice::from((borrow >> 63) as u8);\n          /*** BEGIN: ADAPTED CODE BLOCK ***/\n          // ORIGINAL CODE\n         //   let addend = u64::conditional_select(&0, &constants::L[i], underflow);\n        // OUR ADAPTED CODE FOR VERUS\n            let addend = select(&0, &L.limbs[i], underflow);\n        /*** END: ADAPTED CODE BLOCK ***/\n            assume (carry >> 52 < 2);\n            assume (difference.limbs[i as int] < 1 << 52);\n            assume (L.limbs[i as int] < 1 << 52);\n            carry = (carry >> 52) + difference.limbs[i] + addend;\n            difference.limbs[i] = carry & mask;\n        }\n        assume(false); // TODO: complete the proof\n        difference\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/verify_strict",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/verify_strict",
      "3.0.0_pre.0 signing/impl/SigningKey/generate"
    ],
    "body": "    fn verify_strict(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n        let sig: Signature = keypair.sign(msg);\n\n        c.bench_function(\"Ed25519 strict signature verification\", move |b| {\n            b.iter(|| keypair.verify_strict(msg, &sig))\n        });\n    }",
    "display_name": "verify_strict",
    "full_path": "file:///work/3118/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/shuffle_lanes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/new"
    ],
    "body": "        fn shuffle_lanes(x: u32x8, control: Shuffle) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_permutevar8x32_epi32;\n\n                let c: u32x8 = match control {\n                    Shuffle::AAAA => u32x8::new(0, 0, 2, 2, 0, 0, 2, 2),\n                    Shuffle::BBBB => u32x8::new(1, 1, 3, 3, 1, 1, 3, 3),\n                    Shuffle::CACA => u32x8::new(4, 0, 6, 2, 4, 0, 6, 2),\n                    Shuffle::DBBD => u32x8::new(5, 1, 7, 3, 1, 5, 3, 7),\n                    Shuffle::ADDA => u32x8::new(0, 5, 2, 7, 5, 0, 7, 2),\n                    Shuffle::CBCB => u32x8::new(4, 1, 6, 3, 4, 1, 6, 3),\n                    Shuffle::ABAB => u32x8::new(0, 1, 2, 3, 0, 1, 2, 3),\n                    Shuffle::BADC => u32x8::new(1, 0, 3, 2, 5, 4, 7, 6),\n                    Shuffle::BACD => u32x8::new(1, 0, 3, 2, 4, 5, 6, 7),\n                    Shuffle::ABDC => u32x8::new(0, 1, 2, 3, 5, 4, 7, 6),\n                };\n                // Note that this gets turned into a generic LLVM\n                // shuffle-by-constants, which can be lowered to a simpler\n                // instruction than a generic permute.\n                _mm256_permutevar8x32_epi32(x.into(), c.into()).into()\n            }\n        }",
    "display_name": "shuffle_lanes",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/sign",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/generate"
    ],
    "body": "    fn sign(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n\n        c.bench_function(\"Ed25519 signing\", move |b| b.iter(|| keypair.sign(msg)));\n    }",
    "display_name": "sign",
    "full_path": "file:///work/3118/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/StaticSecret/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/impl/NafLookupTable8/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_affine_niels",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/double"
    ],
    "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 backend/serial/scalar_mul/precomputed_straus/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/new"
    ],
    "body": "    pub fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<EdwardsPoint>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match get_selected_backend() {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            BackendKind::Avx2 =>\n                VartimePrecomputedStraus::Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus::new(static_points)),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            BackendKind::Avx512 =>\n                VartimePrecomputedStraus::Avx512ifma(vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus::new(static_points)),\n            BackendKind::Serial =>\n                VartimePrecomputedStraus::Scalar(serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus::new(static_points))\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vartime_double_base_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 backend/serial/scalar_mul/vartime_double_base/mul"
    ],
    "body": "pub fn vartime_double_base_mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => vector::scalar_mul::vartime_double_base::spec_avx2::mul(a, A, b),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::vartime_double_base::spec_avx512ifma_avx512vl::mul(a, A, b)\n        }\n        BackendKind::Serial => serial::scalar_mul::vartime_double_base::mul(a, A, b),\n    }\n}",
    "display_name": "vartime_double_base_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/len",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/len"
    ],
    "body": "    fn len(&self) -> usize {\n        self.0.len()\n    }",
    "display_name": "len",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_base_clamped",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_clamped"
    ],
    "body": "    fn mul_base_clamped() {\n        let mut csprng = rand_core::OsRng;\n\n        // Test agreement on a large integer. Even after clamping, this is not reduced mod l.\n        let a_bytes = [0xff; 32];\n        assert_eq!(\n            MontgomeryPoint::mul_base_clamped(a_bytes),\n            constants::X25519_BASEPOINT.mul_clamped(a_bytes)\n        );\n\n        // Test agreement on random integers\n        for _ in 0..100 {\n            // This will be reduced mod l with probability l / 2^256 ≈ 6.25%\n            let mut a_bytes = [0u8; 32];\n            csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n            assert_eq!(\n                MontgomeryPoint::mul_base_clamped(a_bytes),\n                constants::X25519_BASEPOINT.mul_clamped(a_bytes)\n            );\n        }\n    }",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/batch_invert_with_a_zero_input_panics",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/batch_invert"
    ],
    "body": "    fn batch_invert_with_a_zero_input_panics() {\n        let mut xs = vec![Scalar::ONE; 16];\n        xs[3] = Scalar::ZERO;\n        // This should panic in debug mode.\n        Scalar::batch_invert(&mut xs);\n    }",
    "display_name": "batch_invert_with_a_zero_input_panics",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/ProjectivePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/decompress/step_1",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/sqrt_ratio_i",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y²-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy²+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }",
    "display_name": "step_1",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/a_p58_vs_ap58_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/pow_p58",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes"
    ],
    "body": "    fn a_p58_vs_ap58_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ap58 = FieldElement::from_bytes(&AP58_BYTES);\n        assert_eq!(ap58, a.pow_p58());\n    }",
    "display_name": "a_p58_vs_ap58_constant",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/&AffineNielsPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: self.y_minus_x,\n            y_minus_x: self.y_plus_x,\n            xy2d: -(&self.xy2d),\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/&ExtendedPoint/Add/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/diff_sum",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/shuffle",
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/blend"
    ],
    "body": "    fn add(self, other: &CachedPoint) -> ExtendedPoint {\n        // The coefficients of an `ExtendedPoint` are reduced after\n        // every operation.  If the `CachedPoint` was negated, its\n        // coefficients grow by one bit.  So on input, `self` is\n        // bounded with `b < 0.007` and `other` is bounded with\n        // `b < 1.0`.\n\n        let mut tmp = self.0;\n\n        tmp = tmp.blend(tmp.diff_sum(), Lanes::AB);\n        // tmp = (Y1-X1 Y1+X1 Z1 T1) = (S0 S1 Z1 T1) with b < 1.6\n\n        // (tmp, other) bounded with b < (1.6, 1.0) < (2.5, 1.75).\n        tmp = &tmp * &other.0;\n        // tmp = (S0*S2' S1*S3' Z1*Z2' T1*T2') = (S8 S9 S10 S11)\n\n        tmp = tmp.shuffle(Shuffle::ABDC);\n        // tmp = (S8 S9 S11 S10)\n\n        tmp = tmp.diff_sum();\n        // tmp = (S9-S8 S9+S8 S10-S11 S10+S11) = (S12 S13 S14 S15)\n\n        let t0 = tmp.shuffle(Shuffle::ADDA);\n        // t0 = (S12 S15 S15 S12)\n        let t1 = tmp.shuffle(Shuffle::CBCB);\n        // t1 = (S14 S13 S14 S13)\n\n        // All coefficients of t0, t1 are bounded with b < 1.6.\n        // Return (S12*S14 S15*S13 S15*S14 S12*S13) = (X3 Y3 Z3 T3)\n        ExtendedPoint(&t0 * &t1)\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/Identity/identity"
    ],
    "body": "    fn is_identity(&self) -> bool {\n        self.ct_eq(&T::identity()).into()\n    }",
    "display_name": "is_identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/unpack",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_bytes"
    ],
    "body": "    pub(crate) fn unpack(&self) -> UnpackedScalar {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }",
    "display_name": "unpack",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"SigningKey\")\n            .field(\"verifying_key\", &self.verifying_key)\n            .finish_non_exhaustive() // avoids printing `secret_key`\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/Drop/drop",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        self.scalar.zeroize();\n        self.hash_prefix.zeroize()\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/generate",
      "3.0.0_pre.0 signing/impl/SigningKey/verify"
    ],
    "body": "    fn verify(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n        let sig: Signature = keypair.sign(msg);\n\n        c.bench_function(\"Ed25519 signature verification\", move |b| {\n            b.iter(|| keypair.verify(msg, &sig))\n        });\n    }",
    "display_name": "verify",
    "full_path": "file:///work/3118/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        CachedPoint(FieldElement2625x4::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/straus/impl/Straus/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2"
    ],
    "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        use crate::backend::serial::curve_models::ProjectiveNielsPoint;\n        use crate::traits::Identity;\n        use crate::window::LookupTable;\n\n        let lookup_tables: Vec<_> = points\n            .into_iter()\n            .map(|point| LookupTable::<ProjectiveNielsPoint>::from(point.borrow()))\n            .collect();\n\n        // This puts the scalar digits into a heap-allocated Vec.\n        // To ensure that these are erased, pass ownership of the Vec into a\n        // Zeroizing wrapper.\n        #[cfg_attr(not(feature = \"zeroize\"), allow(unused_mut))]\n        let mut scalar_digits: Vec<_> = scalars\n            .into_iter()\n            .map(|s| s.borrow().as_radix_16())\n            .collect();\n\n        let mut Q = EdwardsPoint::identity();\n        for j in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            let it = scalar_digits.iter().zip(lookup_tables.iter());\n            for (s_i, lookup_table_i) in it {\n                // R_i = s_{i,j} * P_i\n                let R_i = lookup_table_i.select(s_i[j]);\n                // Q = Q + R_i\n                Q = (&Q + &R_i).as_extended();\n            }\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        zeroize::Zeroize::zeroize(&mut scalar_digits);\n\n        Q\n    }",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto_benches/double_and_compress_batch",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/try_from_rng",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/double_and_compress_batch"
    ],
    "body": "    fn double_and_compress_batch<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in &BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch Ristretto double-and-encode\", *batch_size),\n                &batch_size,\n                |b, &&size| {\n                    let mut rng = OsRng;\n                    let points: Vec<RistrettoPoint> = (0..size)\n                        .map(|_| RistrettoPoint::try_from_rng(&mut rng).unwrap())\n                        .collect();\n                    b.iter(|| RistrettoPoint::double_and_compress_batch(&points));\n                },\n            );\n        }\n    }",
    "display_name": "double_and_compress_batch",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/from_slice",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/random_roundtrip",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/mul_base",
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/decompress",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress",
      "5.0.0_pre.0 scalar/impl/Scalar/random"
    ],
    "body": "    fn random_roundtrip() {\n        let mut rng = OsRng.unwrap_err();\n        for _ in 0..100 {\n            let P = RistrettoPoint::mul_base(&Scalar::random(&mut rng));\n            let compressed_P = P.compress();\n            let Q = compressed_P.decompress().unwrap();\n            assert_eq!(P, Q);\n        }\n    }",
    "display_name": "random_roundtrip",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/from_u64",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn from_u64() {\n        let val: u64 = 0xdeadbeefdeadbeef;\n        let s = Scalar::from(val);\n        assert_eq!(s[7], 0xde);\n        assert_eq!(s[6], 0xad);\n        assert_eq!(s[5], 0xbe);\n        assert_eq!(s[4], 0xef);\n        assert_eq!(s[3], 0xde);\n        assert_eq!(s[2], 0xad);\n        assert_eq!(s[1], 0xbe);\n        assert_eq!(s[0], 0xef);\n    }",
    "display_name": "from_u64",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery_benches/consttime_fixed_base_scalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/invert",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_base"
    ],
    "body": "    fn consttime_fixed_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time fixed-base scalar mul\", move |b| {\n            b.iter(|| MontgomeryPoint::mul_base(&s))\n        });\n    }",
    "display_name": "consttime_fixed_base_scalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/RCompute/finish",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/vartime_double_scalar_mul_basepoint",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 scalar/impl/Scalar/from_hash"
    ],
    "body": "    pub(crate) fn finish(self) -> CompressedEdwardsY {\n        let k = Scalar::from_hash(self.h);\n\n        let minus_A: EdwardsPoint = -self.key.point;\n        // Recall the (non-batched) verification equation: -[k]A + [s]B = R\n        EdwardsPoint::vartime_double_scalar_mul_basepoint(&k, &(minus_A), &self.signature.s)\n            .compress()\n    }",
    "display_name": "finish",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/differential_add_and_double",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = &P.U + &P.W;\n    let t1 = &P.U - &P.W;\n    let t2 = &Q.U + &Q.W;\n    let t3 = &Q.U - &Q.W;\n\n    let t4 = t0.square();   // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square();   // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = &t4 - &t5;     // 4 U_P W_P\n\n    let t7 = &t0 * &t3;     // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = &t1 * &t2;     // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9  = &t7 + &t8;    // 2 (U_P U_Q - W_P W_Q)\n    let t10 = &t7 - &t8;    // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 =  t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n\n    let t13 = &APLUS2_OVER_FOUR * &t6; // (A + 2) U_P U_Q\n\n    let t14 = &t4 * &t5;    // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = &t13 + &t5;   // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = &t6 * &t15;   // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n\n    let t17 = affine_PmQ * &t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11;               // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14;  // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16;  // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18;  // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17;  // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}",
    "display_name": "differential_add_and_double",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/part1",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/m"
    ],
    "body": "        fn part1(sum: u128) -> (u128, u64) {\n            let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n            ((sum + m(p, constants::L[0])) >> 52, p)\n        }",
    "display_name": "part1",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/reduce",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u64x4/splat",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/splat",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/new"
    ],
    "body": "    pub fn reduce(&self) -> FieldElement2625x4 {\n        let shifts = u32x8::new(26, 26, 25, 25, 26, 26, 25, 25);\n        let masks = u32x8::new(\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n        );\n\n        // Let c(x) denote the carryout of the coefficient x.\n        //\n        // Given    (   x0,    y0,    x1,    y1,    z0,    w0,    z1,    w1),\n        // compute  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0)).\n        //\n        // The carryouts are bounded by 2^(32 - 25) = 2^7.\n        let rotated_carryout = |v: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_shuffle_epi32;\n                use core::arch::x86_64::_mm256_srlv_epi32;\n\n                let c = _mm256_srlv_epi32(v.into(), shifts.into());\n                _mm256_shuffle_epi32(c, 0b01_00_11_10).into()\n            }\n        };\n\n        // Combine (lo, lo, lo, lo, lo, lo, lo, lo)\n        //    with (hi, hi, hi, hi, hi, hi, hi, hi)\n        //      to (lo, lo, hi, hi, lo, lo, hi, hi)\n        //\n        // This allows combining carryouts, e.g.,\n        //\n        // lo  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0))\n        // hi  (c(x3), c(y3), c(x2), c(y2), c(z3), c(w3), c(z2), c(w2))\n        // ->  (c(x1), c(y1), c(x2), c(y2), c(z1), c(w1), c(z2), c(w2))\n        //\n        // which is exactly the vector of carryins for\n        //\n        //     (   x2,    y2,    x3,    y3,    z2,    w2,    z3,    w3).\n        //\n        let combine = |v_lo: u32x8, v_hi: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(v_lo.into(), v_hi.into(), 0b11_00_11_00).into()\n            }\n        };\n\n        let mut v = self.0;\n\n        let c10 = rotated_carryout(v[0]);\n        v[0] = (v[0] & masks) + combine(u32x8::splat(0), c10);\n\n        let c32 = rotated_carryout(v[1]);\n        v[1] = (v[1] & masks) + combine(c10, c32);\n\n        let c54 = rotated_carryout(v[2]);\n        v[2] = (v[2] & masks) + combine(c32, c54);\n\n        let c76 = rotated_carryout(v[3]);\n        v[3] = (v[3] & masks) + combine(c54, c76);\n\n        let c98 = rotated_carryout(v[4]);\n        v[4] = (v[4] & masks) + combine(c76, c98);\n\n        let c9_19: u32x8 = unsafe {\n            use core::arch::x86_64::_mm256_mul_epu32;\n            use core::arch::x86_64::_mm256_shuffle_epi32;\n\n            // Need to rearrange c98, since vpmuludq uses the low\n            // 32-bits of each 64-bit lane to compute the product:\n            //\n            // c98       = (c(x9), c(y9), c(x8), c(y8), c(z9), c(w9), c(z8), c(w8));\n            // c9_spread = (c(x9), c(x8), c(y9), c(y8), c(z9), c(z8), c(w9), c(w8)).\n            let c9_spread = _mm256_shuffle_epi32(c98.into(), 0b11_01_10_00);\n\n            // Since the carryouts are bounded by 2^7, their products with 19\n            // are bounded by 2^11.25.  This means that\n            //\n            // c9_19_spread = (19*c(x9), 0, 19*c(y9), 0, 19*c(z9), 0, 19*c(w9), 0).\n            let c9_19_spread = _mm256_mul_epu32(c9_spread, u64x4::splat(19).into());\n\n            // Unshuffle:\n            // c9_19 = (19*c(x9), 19*c(y9), 0, 0, 19*c(z9), 19*c(w9), 0, 0).\n            _mm256_shuffle_epi32(c9_19_spread, 0b11_01_10_00).into()\n        };\n\n        // Add the final carryin.\n        v[0] += c9_19;\n\n        // Each output coefficient has exactly one carryin, which is\n        // bounded by 2^11.25, so they are bounded as\n        //\n        // c_even < 2^26 + 2^11.25 < 26.00006 < 2^{26+b}\n        // c_odd  < 2^25 + 2^11.25 < 25.0001  < 2^{25+b}\n        //\n        // where b = 0.0002.\n        FieldElement2625x4(v)\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul",
      "5.0.0_pre.0 scalar/impl/Scalar/unpack"
    ],
    "body": "    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/sub_reduces",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_reduces() {\n        // Check that subtraction wraps around the modulus\n        assert_eq!(Scalar::ZERO - Scalar::ONE, BASEPOINT_ORDER_MINUS_ONE);\n    }",
    "display_name": "sub_reduces",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/SharedSecret/as_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/as_bytes"
    ],
    "body": "    pub fn as_bytes(&self) -> &[u8; 32] {\n        self.0.as_bytes()\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 impl/SpecializeArg/Parse/parse",
    "statement_type": "function",
    "deps": [
      "0.1.1 kw/conditional"
    ],
    "body": "    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        let lookahead = input.lookahead1();\n        if lookahead.peek(kw::conditional) {\n            input.parse::<kw::conditional>()?;\n\n            let content;\n            syn::parenthesized!(content in input);\n\n            let conditional = content.parse()?;\n            Ok(SpecializeArg::Conditional(conditional))\n        } else {\n            Ok(SpecializeArg::LitStr(input.parse()?))\n        }\n    }",
    "display_name": "parse",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/invert",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn invert(&self) -> Scalar52 {\n        // TODO\n        Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] }\n    }",
    "display_name": "invert",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/&MontgomeryPoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_bits_be",
      "5.0.0_pre.0 scalar/impl/Scalar/bits_le"
    ],
    "body": "    fn mul(self, scalar: &Scalar) -> MontgomeryPoint {\n        // We multiply by the integer representation of the given Scalar. By scalar invariant #1,\n        // the MSB is 0, so we can skip it.\n        self.mul_bits_be(scalar.bits_le().rev().skip(1))\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/from_bytes"
    ],
    "body": "    fn from(secret: &SecretKey) -> Self {\n        Self::from_bytes(secret)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invsqrt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/sqrt_ratio_i"
    ],
    "body": "    pub(crate) fn invsqrt(&self) -> (Choice, FieldElement) {\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }",
    "display_name": "invsqrt",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress_batch",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/batch_invert",
      "5.0.0_pre.0 edwards/affine/impl/AffinePoint/compress"
    ],
    "body": "    pub fn compress_batch(inputs: &[EdwardsPoint]) -> Vec<CompressedEdwardsY> {\n        let mut zs = inputs.iter().map(|input| input.Z).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut zs);\n\n        inputs\n            .iter()\n            .zip(&zs)\n            .map(|(input, recip)| {\n                let x = &input.X * recip;\n                let y = &input.Y * recip;\n                AffinePoint { x, y }.compress()\n            })\n            .collect()\n    }",
    "display_name": "compress_batch",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/PublicKey/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/identity_in_different_models",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/Identity/identity"
    ],
    "body": "    fn identity_in_different_models() {\n        assert!(EdwardsPoint::identity().to_montgomery() == MontgomeryPoint::identity());\n    }",
    "display_name": "identity_in_different_models",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(x: u32) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/square_multiply",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_square",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_mul"
    ],
    "body": "        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }",
    "display_name": "square_multiply",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/montgomery_reduce_matches_from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul_internal",
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order_wide",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_bytes_wide"
    ],
    "body": "    fn montgomery_reduce_matches_from_bytes_mod_order_wide() {\n        let mut bignum = [0u8; 64];\n\n        // set bignum = x + 2^256x\n        for i in 0..32 {\n            bignum[i] = X[i];\n            bignum[32 + i] = X[i];\n        }\n        // x + 2^256x (mod l)\n        //         = 3958878930004874126169954872055634648693766179881526445624823978500314864344\n        let expected = Scalar {\n            bytes: [\n                216, 154, 179, 139, 210, 121, 2, 71, 69, 99, 158, 216, 23, 173, 63, 100, 204, 0,\n                91, 50, 219, 153, 57, 249, 28, 82, 31, 197, 100, 165, 192, 8,\n            ],\n        };\n        let reduced = Scalar::from_bytes_mod_order_wide(&bignum);\n\n        // The reduced scalar should match the expected\n        assert_eq!(reduced.bytes, expected.bytes);\n\n        //  (x + 2^256x) * R\n        let interim =\n            UnpackedScalar::mul_internal(&UnpackedScalar::from_bytes_wide(&bignum), &constants::R);\n        // ((x + 2^256x) * R) / R  (mod l)\n        let montgomery_reduced = UnpackedScalar::montgomery_reduce(&interim);\n\n        // The Montgomery reduced scalar should match the reduced one, as well as the expected\n        assert_eq!(montgomery_reduced.0, reduced.unpack().0);\n        assert_eq!(montgomery_reduced.0, expected.unpack().0)\n    }",
    "display_name": "montgomery_reduce_matches_from_bytes_mod_order_wide",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/double",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square2",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "    pub fn double(&self) -> CompletedPoint {\n        // Double()\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ2 = self.Z.square2();\n        let X_plus_Y = &self.X + &self.Y;\n        let X_plus_Y_sq = X_plus_Y.square();\n        let YY_plus_XX = &YY + &XX;\n        let YY_minus_XX = &YY - &XX;\n\n        CompletedPoint {\n            X: &X_plus_Y_sq - &YY_plus_XX,\n            Y: YY_plus_XX,\n            Z: YY_minus_XX,\n            T: &ZZ2 - &YY_minus_XX,\n        }\n    }",
    "display_name": "double",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/decompress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/decompress/step_1",
      "5.0.0_pre.0 ristretto/decompress/step_2"
    ],
    "body": "    pub fn decompress(&self) -> Option<RistrettoPoint> {\n        let (s_encoding_is_canonical, s_is_negative, s) = decompress::step_1(self);\n\n        if (!s_encoding_is_canonical | s_is_negative).into() {\n            return None;\n        }\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        if (!ok | t_is_negative | y_is_zero).into() {\n            None\n        } else {\n            Some(res)\n        }\n    }",
    "display_name": "decompress",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/coset4",
      "5.0.0_pre.0 ristretto/decompress/step_2",
      "5.0.0_pre.0 ristretto/decompress/step_1"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let coset = self.coset4();\n        write!(\n            f,\n            \"RistrettoPoint: coset \\n{:?}\\n{:?}\\n{:?}\\n{:?}\",\n            coset[0], coset[1], coset[2], coset[3]\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/variable_base/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/double",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 scalar/impl/Scalar/as_radix_16",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_projective"
    ],
    "body": "pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n    let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);\n    // Setting s = scalar, compute\n    //\n    //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n    //\n    // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n    // This decomposition requires s < 2^255, which is guaranteed by Scalar invariant #1.\n    let scalar_digits = scalar.as_radix_16();\n    // Compute s*P as\n    //\n    //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n    //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n    //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n    //\n    // We sum right-to-left.\n\n    // Unwrap first loop iteration to save computing 16*identity\n    let mut tmp2;\n    let mut tmp3 = EdwardsPoint::identity();\n    let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);\n    // Now tmp1 = s_63*P in P1xP1 coords\n    for i in (0..63).rev() {\n        tmp2 = tmp1.as_projective(); // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();   // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }\n    tmp1.as_extended()\n}",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/batch_invert_a_matches_nonbatched",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/batch_invert",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert"
    ],
    "body": "    fn batch_invert_a_matches_nonbatched() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ap58 = FieldElement::from_bytes(&AP58_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        let a0 = &a - &a;\n        let a2 = &a + &a;\n        let a_list = vec![a, ap58, asq, ainv, a0, a2];\n        let mut ainv_list = a_list.clone();\n        FieldElement::batch_invert(&mut ainv_list[..]);\n        for i in 0..6 {\n            assert_eq!(a_list[i].invert(), ainv_list[i]);\n        }\n    }",
    "display_name": "batch_invert_a_matches_nonbatched",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/AffinePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_base",
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/&EdwardsPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/montgomery_mul_bits_be",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/test/rand_prime_order_point",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_bits_be",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order_wide",
      "5.0.0_pre.0 montgomery/test/bytestring_bits_le"
    ],
    "body": "    fn montgomery_mul_bits_be() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            // Make a random prime-order point P\n            let p_edwards = rand_prime_order_point(&mut csprng);\n            let p_montgomery: MontgomeryPoint = p_edwards.to_montgomery();\n\n            // Make a random integer b\n            let mut bigint = [0u8; 64];\n            csprng.fill_bytes(&mut bigint[..]);\n            let bigint_bits_be = bytestring_bits_le(&bigint).rev();\n\n            // Check that bP is the same whether calculated as scalar-times-edwards or\n            // integer-times-montgomery.\n            let expected = Scalar::from_bytes_mod_order_wide(&bigint) * p_edwards;\n            let result = p_montgomery.mul_bits_be(bigint_bits_be);\n            assert_eq!(result, expected.to_montgomery())\n        }\n    }",
    "display_name": "montgomery_mul_bits_be",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/raw_verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/raw_verify"
    ],
    "body": "pub fn raw_verify<CtxDigest>(\n    vk: &VerifyingKey,\n    message: &[u8],\n    signature: &ed25519::Signature,\n) -> Result<(), SignatureError>\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    vk.raw_verify::<CtxDigest>(&[message], signature)\n}",
    "display_name": "raw_verify",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        FieldElement51([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_montgomery",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/montgomery_invert",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/as_montgomery"
    ],
    "body": "    pub fn invert(&self) -> UnpackedScalar {\n        self.as_montgomery().montgomery_invert().from_montgomery()\n    }",
    "display_name": "invert",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/vartime_double_scalar_mul_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vartime_double_base_mul"
    ],
    "body": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &EdwardsPoint,\n        b: &Scalar,\n    ) -> EdwardsPoint {\n        crate::backend::vartime_double_base_mul(a, A, b)\n    }",
    "display_name": "vartime_double_scalar_mul_basepoint",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/reduce",
    "statement_type": "function",
    "deps": [],
    "body": "    fn reduce(mut limbs: [u64; 5]) -> FieldElement51 {\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        FieldElement51(limbs)\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 is_capable_simd",
    "statement_type": "function",
    "deps": [],
    "body": "fn is_capable_simd(arch: &str, bits: DalekBits) -> bool {\n    arch == \"x86_64\" && bits == DalekBits::Dalek64\n}",
    "display_name": "is_capable_simd",
    "full_path": "file:///work/3118/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/conditional_assign_for_affine_niels_point",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_affine_niels",
      "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign_for_affine_niels_point() {\n        let id = AffineNielsPoint::identity();\n        let mut p1 = AffineNielsPoint::identity();\n        let bp = constants::ED25519_BASEPOINT_POINT.as_affine_niels();\n\n        p1.conditional_assign(&bp, Choice::from(0));\n        assert_eq!(p1, id);\n        p1.conditional_assign(&bp, Choice::from(1));\n        assert_eq!(p1, bp);\n    }",
    "display_name": "conditional_assign_for_affine_niels_point",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/precomputed_straus/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/len",
    "statement_type": "function",
    "deps": [],
    "body": "    fn len(&self) -> usize {\n        self.static_lookup_tables.len()\n    }",
    "display_name": "len",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/AffinePoint/compress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative"
    ],
    "body": "    pub fn compress(self) -> CompressedEdwardsY {\n        let mut s = self.y.to_bytes();\n        s[31] ^= self.x.is_negative().unwrap_u8() << 7;\n        CompressedEdwardsY(s)\n    }",
    "display_name": "compress",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "        pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n        // SPECIFICATION: unpacking keeps the same nat value\n        ensures bytes_to_nat(bytes) == to_nat(&s.limbs)\n        {\n            let mut words = [0u64; 4];\n            for i in 0..4\n                invariant 0 <= i <= 4 // proof\n            {\n                for j in 0..8\n                    invariant 0 <= j <= 8 && i < 4\n                {\n                    proof {\n                        assert(i < 4 && j < 8);\n                        assert((i as u64)*8u64 < 32u64);\n                        let idx = (i as u64) * 8 + (j as u64);\n                        assert(idx < 32);\n                    }\n                    words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n                }\n            }\n            assume(bytes_to_nat(bytes) == words_to_nat(&words));\n            proof {\n                assert(1u64 << 52 > 0) by (bit_vector);\n                assert(1u64 << 48 > 0) by (bit_vector);\n                // TODO: prove property about words array\n            }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        // let mut s = Scalar52::ZERO; // ORIGINAL IMPLEMENTATION\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof {\n            assert(Scalar52::ZERO == Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] });\n            assert(s == Scalar52::ZERO); // PROVES EQUIVALENCE TO ORIGINAL IMPLEMENTATION\n        }\n\n        s.limbs[0] =   words[0]                            & mask;\n        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] =  (words[3] >> 16)                     & top_mask;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/from_uniform_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/elligator_ristretto_flavor"
    ],
    "body": "    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }",
    "display_name": "from_uniform_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/as_extended",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.Z,\n            Y: &self.Y * &self.Z,\n            Z: self.Z.square(),\n            T: &self.X * &self.Y,\n        }\n    }",
    "display_name": "as_extended",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "3.0.0_pre.0 get_test_vectors",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 impl/TestVector/From/from"
    ],
    "body": "fn get_test_vectors() -> impl Iterator<Item = TestVector> {\n    let f = File::open(\"VALIDATIONVECTORS\").expect(\n        \"This test is only available when the code has been cloned from the git repository, since\n        the VALIDATIONVECTORS file is large and is therefore not included within the distributed \\\n        crate.\",\n    );\n\n    serde_json::from_reader::<_, Vec<IntermediateTestVector>>(f)\n        .unwrap()\n        .into_iter()\n        .map(TestVector::from)\n}",
    "display_name": "get_test_vectors",
    "full_path": "file:///work/3118/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/pow2k"
    ],
    "body": "    pub fn square(&self) -> FieldElement51 {\n        self.pow2k(1)\n    }",
    "display_name": "square",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity"
    ],
    "body": "    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 inner/inner_function",
    "statement_type": "function",
    "deps": [],
    "body": "    fn inner_function(a: u32, b: u32) -> u32 {\n        a - b\n    }",
    "display_name": "inner_function",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/vartime_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 multiscalar_benches/construct_points",
      "5.0.0_pre.0 multiscalar_benches/construct_scalars",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul"
    ],
    "body": "    fn vartime_multiscalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Variable-time variable-base multiscalar multiplication\",\n                    *multiscalar_size,\n                ),\n                &multiscalar_size,\n                |b, &&size| {\n                    let points = construct_points(size);\n                    // Rerandomize the scalars for every call to prevent\n                    // false timings from better caching (e.g., the CPU\n                    // cache lifts exactly the right table entries for the\n                    // benchmark into the highest cache levels).\n                    b.iter_batched(\n                        || construct_scalars(size),\n                        |scalars| EdwardsPoint::vartime_multiscalar_mul(&scalars, &points),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }",
    "display_name": "vartime_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/square_internal",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/m"
    ],
    "body": "    fn square_internal(a: &Scalar52) -> [u128; 9] {\n        let aa = [\n            a[0] * 2,\n            a[1] * 2,\n            a[2] * 2,\n            a[3] * 2,\n        ];\n\n        [\n            m( a[0], a[0]),\n            m(aa[0], a[1]),\n            m(aa[0], a[2]) + m( a[1], a[1]),\n            m(aa[0], a[3]) + m(aa[1], a[2]),\n            m(aa[0], a[4]) + m(aa[1], a[3]) + m( a[2], a[2]),\n                             m(aa[1], a[4]) + m(aa[2], a[3]),\n                                              m(aa[2], a[4]) + m( a[3], a[3]),\n                                                               m(aa[3], a[4]),\n                                                                                m(a[4], a[4])\n        ]\n    }",
    "display_name": "square_internal",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/random",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress",
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity"
    ],
    "body": "    pub fn random<R: RngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.fill_bytes(&mut repr.0);\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break p;\n                }\n            }\n        }\n    }",
    "display_name": "random",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/repudiation",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Neg/neg",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/verify_strict",
      "3.0.0_pre.0 vectors/serialize_signature",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/is_weak",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress",
      "3.0.0_pre.0 vectors/non_null_scalar",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/Verifier/verify",
      "3.0.0_pre.0 vectors/compute_challenge",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/from_bytes",
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity",
      "3.0.0_pre.0 vectors/pick_r"
    ],
    "body": "    fn repudiation() {\n        let message1 = b\"Send 100 USD to Alice\";\n        let message2 = b\"Send 100000 USD to Alice\";\n\n        let mut s: Scalar = non_null_scalar();\n        let pubkey = WEAK_PUBKEY.decompress().unwrap();\n        let mut r = pick_r(s);\n\n        // Find an R such that\n        //     H(R || A || M₁) · A == A == H(R || A || M₂) · A\n        // This happens with high probability when A is low order.\n        while !(pubkey.neg() + compute_challenge(message1, &pubkey, &r, None) * pubkey)\n            .is_identity()\n            || !(pubkey.neg() + compute_challenge(message2, &pubkey, &r, None) * pubkey)\n                .is_identity()\n        {\n            // We pick an s and let R = sB - A where B is the basepoint\n            s = non_null_scalar();\n            r = pick_r(s);\n        }\n\n        // At this point, both verification equations hold:\n        //     sB = R + H(R || A || M₁) · A\n        //        = R + H(R || A || M₂) · A\n        // Check that this is true\n        let signature = serialize_signature(&r, &s);\n        let vk = VerifyingKey::from_bytes(pubkey.compress().as_bytes()).unwrap();\n        let sig = Signature::try_from(&signature[..]).unwrap();\n        assert!(vk.verify(message1, &sig).is_ok());\n        assert!(vk.verify(message2, &sig).is_ok());\n\n        // Check that this public key appears as weak\n        assert!(vk.is_weak());\n\n        // Now check that the sigs fail under verify_strict. This is because verify_strict rejects\n        // small order pubkeys.\n        assert!(vk.verify_strict(message1, &sig).is_err());\n        assert!(vk.verify_strict(message2, &sig).is_err());\n    }",
    "display_name": "repudiation",
    "full_path": "file:///work/3118/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/construct_points",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 scalar/impl/Scalar/random"
    ],
    "body": "    fn construct_points(n: usize) -> Vec<EdwardsPoint> {\n        let mut rng = rng();\n        (0..n)\n            .map(|_| EdwardsPoint::mul_base(&Scalar::random(&mut rng)))\n            .collect()\n    }",
    "display_name": "construct_points",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_plus_basepoint_projective_niels_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective_niels"
    ],
    "body": "    fn basepoint_plus_basepoint_projective_niels_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_added = (&bp + &bp.as_projective_niels()).as_extended();\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }",
    "display_name": "basepoint_plus_basepoint_projective_niels_vs_basepoint2",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix256/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/impl_mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn impl_mul() {\n        let should_be_X_times_Y = X * Y;\n        assert_eq!(should_be_X_times_Y, X_TIMES_Y);\n    }",
    "display_name": "impl_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/test_read_le_u64_into_should_panic_on_bad_input",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/read_le_u64_into"
    ],
    "body": "    fn test_read_le_u64_into_should_panic_on_bad_input() {\n        let mut dst = [0_u64; 1];\n        // One byte short\n        read_le_u64_into(&[0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F], &mut dst);\n    }",
    "display_name": "test_read_le_u64_into_should_panic_on_bad_input",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/MultipartVerifier/multipart_verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/MultipartVerifier/multipart_verify"
    ],
    "body": "    fn multipart_verify(\n        &self,\n        message: &[&[u8]],\n        signature: &Signature,\n    ) -> Result<(), SignatureError> {\n        self.verifying_key.multipart_verify(message, signature)\n    }",
    "display_name": "multipart_verify",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/impl/NafLookupTable8/select",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 128);\n\n        self.0[x / 2]\n    }",
    "display_name": "select",
    "full_path": "file:///work/3118/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 impl/SpecializeArgs/Parse/parse",
    "statement_type": "function",
    "deps": [
      "0.1.1 impl/SpecializeArg/lit",
      "0.1.1 process_item",
      "0.1.1 process_mod",
      "0.1.1 impl/SpecializeArg/condition"
    ],
    "body": "    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        Ok(Self(syn::punctuated::Punctuated::parse_terminated(input)?))\n    }",
    "display_name": "parse",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.0[_index])\n    }",
    "display_name": "index_mut",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 check_validation_criteria",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/Verifier/verify",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/verify_strict",
      "3.0.0_pre.0 get_test_vectors"
    ],
    "body": "fn check_validation_criteria() {\n    let verify_allowed_edgecases = Set::from_iter(VERIFY_ALLOWED_EDGECASES.to_vec());\n    let verify_strict_allowed_edgecases = Set::from_iter(VERIFY_STRICT_ALLOWED_EDGECASES.to_vec());\n\n    for TestVector {\n        number,\n        pubkey,\n        msg,\n        sig,\n        flags,\n    } in get_test_vectors()\n    {\n        // If all the verify-permitted flags here are ones we permit, then verify() should succeed.\n        // Otherwise, it should not.\n        let success = pubkey.verify(&msg, &sig).is_ok();\n        if flags.is_subset(&verify_allowed_edgecases) {\n            assert!(success, \"verify() expected success in testcase #{number}\",);\n        } else {\n            assert!(!success, \"verify() expected failure in testcase #{number}\",);\n        }\n\n        // If all the verify_strict-permitted flags here are ones we permit, then verify_strict()\n        // should succeed. Otherwise, it should not.\n        let success = pubkey.verify_strict(&msg, &sig).is_ok();\n        if flags.is_subset(&verify_strict_allowed_edgecases) {\n            assert!(\n                success,\n                \"verify_strict() expected success in testcase #{number}\",\n            );\n        } else {\n            assert!(\n                !success,\n                \"verify_strict() expected failure in testcase #{number}\",\n            );\n        }\n    }\n}",
    "display_name": "check_validation_criteria",
    "full_path": "file:///work/3118/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/StaticSecret/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/impl/StaticSecret/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/impl/NafLookupTable5/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_affine_niels",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/double"
    ],
    "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/reduce"
    ],
    "body": "    pub fn to_bytes(self) -> [u8; 32] {\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.0).0;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 test_function",
    "statement_type": "function",
    "deps": [
      "0.1.1 function_with_where_clause",
      "0.1.1 impl/StructWithGenericsNoWhere/member_function",
      "0.1.1 function_with_const_arg",
      "0.1.1 impl/Struct/member_function",
      "0.1.1 impl/StructWithGenerics/member_function",
      "0.1.1 function"
    ],
    "body": "fn test_function() {\n    assert_eq!(function(10, 3), 7);\n    assert_eq!(function_with_where_clause(10, 3), 7);\n    assert_eq!(function_with_const_arg::<10>(3), 7);\n    assert_eq!(Struct { a: 10 }.member_function(3), 7);\n    assert_eq!(StructWithGenerics { a: 10 }.member_function(3), 7);\n    assert_eq!(StructWithGenericsNoWhere { a: 10 }.member_function(3), 7);\n    assert_eq!(inner_spec_sse2::spec_function(10, 3), 6);\n    assert_eq!(inner_spec_avx2::spec_function(10, 3), 5);\n}",
    "display_name": "test_function",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 traits/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>;\n}\n\n/// A trait for variable-time multiscalar multiplication without precomputation.\npub trait VartimeMultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// `Option`s of points, compute either `Some(Q)`, where\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// if all points were `Some(P_i)`, or else return `None`.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    /// let abc = [a,b,c];\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    /// let PQR = [P, Q, R];\n    ///\n    /// let compressed = [P.compress(), Q.compress(), R.compress()];\n    ///\n    /// // Now we can compute A1 = a*P + b*Q + c*R using P, Q, R:\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &PQR);\n    ///\n    /// // Or using the compressed points:\n    /// let A2 = RistrettoPoint::optional_multiscalar_mul(\n    ///     &abc,\n    ///     compressed.iter().map(|pt| pt.decompress()),\n    /// );\n    ///\n    /// assert_eq!(A2, Some(A1));\n    ///\n    /// // It's also possible to mix compressed and uncompressed points:\n    /// let A3 = RistrettoPoint::optional_multiscalar_mul(\n    ///     abc.iter()\n    ///         .chain(abc.iter()),\n    ///     compressed.iter().map(|pt| pt.decompress())\n    ///         .chain(PQR.iter().map(|&pt| Some(pt))),\n    /// );\n    ///\n    /// assert_eq!(A3, Some(A1+A1));\n    /// # }\n    /// ```\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n}",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/StaticSecret/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/key_generation",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/generate"
    ],
    "body": "    fn key_generation(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n\n        c.bench_function(\"Ed25519 keypair generation\", move |b| {\n            b.iter(|| SigningKey::generate(&mut csprng))\n        });\n    }",
    "display_name": "key_generation",
    "full_path": "file:///work/3118/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/scalar_mul/precomputed_straus/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/optional",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 window/impl/NafLookupTable5/From/from",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/as_extended",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_projective",
      "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectivePoint/double",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended"
    ],
    "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        let static_nafs = static_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n        let dynamic_nafs: Vec<_> = dynamic_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n\n        let dynamic_lookup_tables = dynamic_points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let sp = self.static_lookup_tables.len();\n        let dp = dynamic_lookup_tables.len();\n        assert!(sp >= static_nafs.len());\n        assert_eq!(dp, dynamic_nafs.len());\n\n        // We could save some doublings by looking for the highest\n        // nonzero NAF coefficient, but since we might have a lot of\n        // them to search, it's not clear it's worthwhile to check.\n        let mut S = ProjectivePoint::identity();\n        for j in (0..256).rev() {\n            let mut R: CompletedPoint = S.double();\n\n            for i in 0..dp {\n                let t_ij = dynamic_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &dynamic_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &dynamic_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            #[allow(clippy::needless_range_loop)]\n            for i in 0..static_nafs.len() {\n                let t_ij = static_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &self.static_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &self.static_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            S = R.as_projective();\n        }\n\n        Some(S.as_extended())\n    }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/from_slice"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {\n        Self::from_slice(bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_tables_unreduced_scalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix32/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix64/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix128/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTable/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix256/BasepointTable/create"
    ],
    "body": "    fn basepoint_tables_unreduced_scalar() {\n        let P = &constants::ED25519_BASEPOINT_POINT;\n        let a = crate::scalar::test::LARGEST_UNREDUCED_SCALAR;\n\n        let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n        let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n        let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n        let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n        let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n        let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n        let aP16 = (&table_radix16 * &a).compress();\n        let aP32 = (&table_radix32 * &a).compress();\n        let aP64 = (&table_radix64 * &a).compress();\n        let aP128 = (&table_radix128 * &a).compress();\n        let aP256 = (&table_radix256 * &a).compress();\n\n        assert_eq!(aP, aP16);\n        assert_eq!(aP16, aP32);\n        assert_eq!(aP32, aP64);\n        assert_eq!(aP64, aP128);\n        assert_eq!(aP128, aP256);\n    }",
    "display_name": "basepoint_tables_unreduced_scalar",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/AffinePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/LookupTable/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/From/from",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/From/from"
    ],
    "body": "    fn from(point: &edwards::EdwardsPoint) -> Self {\n        let P = ExtendedPoint::from(*point);\n        let mut points = [CachedPoint::from(P); 8];\n        for i in 0..7 {\n            points[i + 1] = (&P + &points[i]).into();\n        }\n        LookupTable(points)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, point: &'a EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &[u8; PUBLIC_KEY_LENGTH] {\n        &(self.compressed).0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/repack_pair",
    "statement_type": "function",
    "deps": [],
    "body": "fn repack_pair(x: u32x8, y: u32x8) -> u32x8 {\n    unsafe {\n        use core::arch::x86_64::_mm256_blend_epi32;\n        use core::arch::x86_64::_mm256_shuffle_epi32;\n\n        // Input: x = (a0, 0, b0, 0, c0, 0, d0, 0)\n        // Input: y = (a1, 0, b1, 0, c1, 0, d1, 0)\n\n        let x_shuffled = _mm256_shuffle_epi32(x.into(), 0b11_01_10_00);\n        let y_shuffled = _mm256_shuffle_epi32(y.into(), 0b10_00_11_01);\n\n        // x' = (a0, b0,  0,  0, c0, d0,  0,  0)\n        // y' = ( 0,  0, a1, b1,  0,  0, c1, d1)\n\n        _mm256_blend_epi32(x_shuffled, y_shuffled, 0b11001100).into()\n    }\n}",
    "display_name": "repack_pair",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
    "display_name": "mul_clamped",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 function_with_rustfmt_skip",
    "statement_type": "function",
    "deps": [],
    "body": "fn function_with_rustfmt_skip() {}\n",
    "display_name": "function_with_rustfmt_skip",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/monte_carlo_overflow_underflow_debug_assert_test",
    "statement_type": "function",
    "deps": [],
    "body": "    fn monte_carlo_overflow_underflow_debug_assert_test() {\n        let mut P = constants::ED25519_BASEPOINT_POINT;\n        // N.B. each scalar_mul does 1407 field mults, 1024 field squarings,\n        // so this does ~ 1M of each operation.\n        for _ in 0..1_000 {\n            P *= &A_SCALAR;\n        }\n    }",
    "display_name": "monte_carlo_overflow_underflow_debug_assert_test",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/is_canonical",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/reduce",
      "5.0.0_pre.0 scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn is_canonical(&self) -> Choice {\n        self.ct_eq(&self.reduce())\n    }",
    "display_name": "is_canonical",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/to_radix_2w_size_hint",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        let digits_count = match w {\n            4..=7 => 256_usize.div_ceil(w),\n            // See comment in to_radix_2w on handling the terminal carry.\n            8 => 256_usize.div_ceil(w) + 1_usize,\n            _ => panic!(\"invalid radix parameter\"),\n        };\n\n        debug_assert!(digits_count <= 64);\n        digits_count\n    }",
    "display_name": "to_radix_2w_size_hint",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/m",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/mul32"
    ],
    "body": "        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }",
    "display_name": "m",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn sub(a: &Scalar52, b: &Scalar52) -> Scalar52 {\n        let mut difference = Scalar52::ZERO;\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        for i in 0..5 {\n            borrow = a[i].wrapping_sub(b[i] + (borrow >> 63));\n            difference[i] = borrow & mask;\n        }\n\n        // conditionally add l if the difference is negative\n        let mut carry: u64 = 0;\n        for i in 0..5 {\n            let underflow = Choice::from((borrow >> 63) as u8);\n            let addend = u64::conditional_select(&0, &constants::L[i], underflow);\n            carry = (carry >> 52) + difference[i] + addend;\n            difference[i] = carry & mask;\n        }\n\n        difference\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_cofactor",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2"
    ],
    "body": "    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }",
    "display_name": "mul_by_cofactor",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul"
    ],
    "body": "    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
    "display_name": "vartime_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsBasepointTable/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 constants/test/test_four_torsion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/ValidityCheck/is_valid",
      "5.0.0_pre.0 traits/impl/T/IsIdentity/is_identity",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_by_pow_2"
    ],
    "body": "    fn test_four_torsion() {\n        for i in (0..8).filter(|i| i % 2 == 0) {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(2);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }",
    "display_name": "test_four_torsion",
    "full_path": "file:///work/3118/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_double_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/double",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_double_vs_basepoint2() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT.double().compress(),\n            BASE2_CMPRSSD\n        );\n    }",
    "display_name": "basepoint_double_vs_basepoint2",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(self) -> [u8; 32] {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.0[ 0] >>  0)                      as u8;\n        s[ 1] =  (self.0[ 0] >>  8)                      as u8;\n        s[ 2] =  (self.0[ 0] >> 16)                      as u8;\n        s[ 3] =  (self.0[ 0] >> 24)                      as u8;\n        s[ 4] =  (self.0[ 0] >> 32)                      as u8;\n        s[ 5] =  (self.0[ 0] >> 40)                      as u8;\n        s[ 6] = ((self.0[ 0] >> 48) | (self.0[ 1] << 4)) as u8;\n        s[ 7] =  (self.0[ 1] >>  4)                      as u8;\n        s[ 8] =  (self.0[ 1] >> 12)                      as u8;\n        s[ 9] =  (self.0[ 1] >> 20)                      as u8;\n        s[10] =  (self.0[ 1] >> 28)                      as u8;\n        s[11] =  (self.0[ 1] >> 36)                      as u8;\n        s[12] =  (self.0[ 1] >> 44)                      as u8;\n        s[13] =  (self.0[ 2] >>  0)                      as u8;\n        s[14] =  (self.0[ 2] >>  8)                      as u8;\n        s[15] =  (self.0[ 2] >> 16)                      as u8;\n        s[16] =  (self.0[ 2] >> 24)                      as u8;\n        s[17] =  (self.0[ 2] >> 32)                      as u8;\n        s[18] =  (self.0[ 2] >> 40)                      as u8;\n        s[19] = ((self.0[ 2] >> 48) | (self.0[ 3] << 4)) as u8;\n        s[20] =  (self.0[ 3] >>  4)                      as u8;\n        s[21] =  (self.0[ 3] >> 12)                      as u8;\n        s[22] =  (self.0[ 3] >> 20)                      as u8;\n        s[23] =  (self.0[ 3] >> 28)                      as u8;\n        s[24] =  (self.0[ 3] >> 36)                      as u8;\n        s[25] =  (self.0[ 3] >> 44)                      as u8;\n        s[26] =  (self.0[ 4] >>  0)                      as u8;\n        s[27] =  (self.0[ 4] >>  8)                      as u8;\n        s[28] =  (self.0[ 4] >> 16)                      as u8;\n        s[29] =  (self.0[ 4] >> 24)                      as u8;\n        s[30] =  (self.0[ 4] >> 32)                      as u8;\n        s[31] =  (self.0[ 4] >> 40)                      as u8;\n\n        s\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/PublicKey/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base_clamped"
    ],
    "body": "    fn from(secret: &'a EphemeralSecret) -> PublicKey {\n        PublicKey(EdwardsPoint::mul_base_clamped(secret.0).to_montgomery())\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/x25519",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_bytes",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_clamped"
    ],
    "body": "pub fn x25519(k: [u8; 32], u: [u8; 32]) -> [u8; 32] {\n    MontgomeryPoint(u).mul_clamped(k).to_bytes()\n}",
    "display_name": "x25519",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 impl/StructWithGenericsNoWhere/member_function",
    "statement_type": "function",
    "deps": [],
    "body": "    fn member_function(&self, b: T) -> T::Output {\n        self.a - b\n    }",
    "display_name": "member_function",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/straus/spec/impl/Straus/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/LookupTable/From/from",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Identity/identity",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/mul_by_pow_2"
    ],
    "body": "        fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator,\n            J::Item: Borrow<EdwardsPoint>,\n        {\n            // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n            // for each input point P\n            let lookup_tables: Vec<_> = points\n                .into_iter()\n                .map(|point| LookupTable::<CachedPoint>::from(point.borrow()))\n                .collect();\n\n            let scalar_digits_vec: Vec<_> = scalars\n                .into_iter()\n                .map(|s| s.borrow().as_radix_16())\n                .collect();\n            // Pass ownership to a `Zeroizing` wrapper\n            #[cfg(feature = \"zeroize\")]\n            let scalar_digits_vec = Zeroizing::new(scalar_digits_vec);\n\n            let mut Q = ExtendedPoint::identity();\n            for j in (0..64).rev() {\n                Q = Q.mul_by_pow_2(4);\n                let it = scalar_digits_vec.iter().zip(lookup_tables.iter());\n                for (s_i, lookup_table_i) in it {\n                    // Q = Q + s_{i,j} * P_i\n                    Q = &Q + &lookup_table_i.select(s_i[j]);\n                }\n            }\n            Q.into()\n        }",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/hash_to_curve",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/hash_to_curve"
    ],
    "body": "    fn hash_to_curve<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let mut rng = rng();\n\n        let mut msg = [0u8; 32];\n        let mut domain_sep = [0u8; 32];\n        rng.fill_bytes(&mut msg);\n        rng.fill_bytes(&mut domain_sep);\n\n        c.bench_function(\n            \"Elligator2 hash to curve (SHA-512, input size 32 bytes)\",\n            |b| b.iter(|| EdwardsPoint::hash_to_curve::<Sha512>(&[&msg], &[&domain_sep])),\n        );\n    }",
    "display_name": "hash_to_curve",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/verify_strict",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/verify_strict"
    ],
    "body": "    pub fn verify_strict(\n        &self,\n        message: &[u8],\n        signature: &Signature,\n    ) -> Result<(), SignatureError> {\n        self.verifying_key.verify_strict(message, signature)\n    }",
    "display_name": "verify_strict",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signature/impl/InternalSignature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signature/impl/InternalSignature/from_bytes"
    ],
    "body": "    fn try_from(sig: &ed25519::Signature) -> Result<InternalSignature, SignatureError> {\n        InternalSignature::from_bytes(&sig.to_bytes())\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3118/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/square_internal",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul_internal"
    ],
    "body": "    pub fn square(&self) -> Scalar52 {\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR))\n    }",
    "display_name": "square",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/multiscalar_consistency_iter",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/MultiscalarMul/multiscalar_mul",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul"
    ],
    "body": "    fn multiscalar_consistency_iter(n: usize) {\n        let mut rng = rand::rng();\n\n        // Construct random coefficients x0, ..., x_{n-1},\n        // followed by some extra hardcoded ones.\n        let xs = (0..n).map(|_| Scalar::random(&mut rng)).collect::<Vec<_>>();\n        let check = xs.iter().map(|xi| xi * xi).sum::<Scalar>();\n\n        // Construct points G_i = x_i * B\n        let Gs = xs.iter().map(EdwardsPoint::mul_base).collect::<Vec<_>>();\n\n        // Compute H1 = <xs, Gs> (consttime)\n        let H1 = EdwardsPoint::multiscalar_mul(&xs, &Gs);\n        // Compute H2 = <xs, Gs> (vartime)\n        let H2 = EdwardsPoint::vartime_multiscalar_mul(&xs, &Gs);\n        // Compute H3 = <xs, Gs> = sum(xi^2) * B\n        let H3 = EdwardsPoint::mul_base(&check);\n\n        assert_eq!(H1, H3);\n        assert_eq!(H2, H3);\n    }",
    "display_name": "multiscalar_consistency_iter",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/compress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn compress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B = &constants::ED25519_BASEPOINT_POINT;\n        c.bench_function(\"EdwardsPoint compression\", move |b| b.iter(|| B.compress()));\n    }",
    "display_name": "compress",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/compress_batch",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress_batch",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/random"
    ],
    "body": "    fn compress_batch() {\n        let mut rng = rand::rng();\n\n        // TODO(tarcieri): proptests?\n        // Make some points deterministically then randomly\n        let mut points = (1u64..16)\n            .map(|n| constants::ED25519_BASEPOINT_POINT * Scalar::from(n))\n            .collect::<Vec<_>>();\n        points.extend(core::iter::repeat_with(|| EdwardsPoint::random(&mut rng)).take(100));\n        let compressed = EdwardsPoint::compress_batch(&points);\n\n        // Check that the batch-compressed points match the individually compressed ones\n        for (point, compressed) in points.iter().zip(&compressed) {\n            assert_eq!(&point.compress(), compressed);\n        }\n    }",
    "display_name": "compress_batch",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice) {\n        self.0[0].conditional_assign(&other.0[0], choice);\n        self.0[1].conditional_assign(&other.0[1], choice);\n        self.0[2].conditional_assign(&other.0[2], choice);\n        self.0[3].conditional_assign(&other.0[3], choice);\n        self.0[4].conditional_assign(&other.0[4], choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn ct_eq(&self, other: &CompressedEdwardsY) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/clamp_integer",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn clamp_integer(mut bytes: [u8; 32]) -> [u8; 32] {\n    bytes[0] &= 0b1111_1000;\n    bytes[31] &= 0b0111_1111;\n    bytes[31] |= 0b0100_0000;\n    bytes\n}",
    "display_name": "clamp_integer",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/&EdwardsPoint/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.Y_plus_X;\n        let MM = &Y_minus_X * &other.Y_minus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &ZZ2 + &TT2d,\n            T: &ZZ2 - &TT2d,\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/&RistrettoPoint/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/hash_from_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_hash"
    ],
    "body": "    pub fn hash_from_bytes<D>(input: &[u8]) -> Scalar\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }",
    "display_name": "hash_from_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n        }\n    }",
    "display_name": "as_projective",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 process_item",
    "statement_type": "function",
    "deps": [
      "0.1.1 process_mod",
      "0.1.1 process_function",
      "0.1.1 process_impl"
    ],
    "body": "fn process_item(attributes: &syn::LitStr, item: syn::Item, strict: bool) -> TokenStream {\n    match item {\n        syn::Item::Fn(function) => process_function(attributes, function, None),\n        syn::Item::Impl(item_impl) => process_impl(attributes, item_impl),\n        syn::Item::Mod(item_mod) => process_mod(attributes, item_mod, None).into(),\n        item => {\n            if strict {\n                unsupported!(item)\n            } else {\n                quote::quote! { #item }.into()\n            }\n        }\n    }\n}",
    "display_name": "process_item",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/ProjectivePoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/ProjectivePoint/Identity/identity"
    ],
    "body": "    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/test/sign_verify_nonspec",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/test/impl/ExpandedSecretKey/random",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/From/from",
      "3.0.0_pre.0 hazmat/raw_verify",
      "3.0.0_pre.0 hazmat/raw_sign"
    ],
    "body": "    fn sign_verify_nonspec() {\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        let msg = b\"Then one day, a piano fell on my head\";\n\n        // Sign and verify\n        let sig = raw_sign::<CtxDigest>(&esk, msg, &vk);\n        raw_verify::<CtxDigest>(&vk, msg, &sig).unwrap();\n    }",
    "display_name": "sign_verify_nonspec",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 bench_diffie_hellman",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/impl/PublicKey/From/from",
      "3.0.0_pre.0 x25519/impl/EphemeralSecret/random_from_rng",
      "3.0.0_pre.0 x25519/impl/EphemeralSecret/diffie_hellman"
    ],
    "body": "fn bench_diffie_hellman(c: &mut Criterion) {\n    let bob_secret = EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err());\n    let bob_public = PublicKey::from(&bob_secret);\n\n    c.bench_function(\"diffie_hellman\", move |b| {\n        b.iter_with_setup(\n            || EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err()),\n            |alice_secret| alice_secret.diffie_hellman(&bob_public),\n        )\n    });\n}",
    "display_name": "bench_diffie_hellman",
    "full_path": "file:///work/3118/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 deterministic/determine_curve25519_dalek_bits_warning",
    "statement_type": "function",
    "deps": [],
    "body": "    fn determine_curve25519_dalek_bits_warning(cause: &str) {\n        println!(\"cargo:warning=\\\"Defaulting to curve25519_dalek_bits=32: {cause}\\\"\");\n    }",
    "display_name": "determine_curve25519_dalek_bits_warning",
    "full_path": "file:///work/3118/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 window/impl/NafLookupTable5/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"NafLookupTable5({:?})\", self.0)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_decompression_compression",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/ValidityCheck/is_valid"
    ],
    "body": "    fn basepoint_decompression_compression() {\n        let base_X = FieldElement::from_bytes(&BASE_X_COORD_BYTES);\n        let bp = constants::ED25519_BASEPOINT_COMPRESSED\n            .decompress()\n            .unwrap();\n        assert!(bp.is_valid());\n        // Check that decompression actually gives the correct X coordinate\n        assert_eq!(base_X, bp.X);\n        assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n    }",
    "display_name": "basepoint_decompression_compression",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/basepoint_montgomery_to_edwards",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_edwards"
    ],
    "body": "    fn basepoint_montgomery_to_edwards() {\n        // sign bit = 0 => basepoint\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT,\n            constants::X25519_BASEPOINT.to_edwards(0).unwrap()\n        );\n        // sign bit = 1 => minus basepoint\n        assert_eq!(\n            -constants::ED25519_BASEPOINT_POINT,\n            constants::X25519_BASEPOINT.to_edwards(1).unwrap()\n        );\n    }",
    "display_name": "basepoint_montgomery_to_edwards",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &'a FieldElement51) {\n        for i in 0..5 {\n            self.0[i] += _rhs.0[i];\n        }\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/&EdwardsPoint/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/variable_base_mul"
    ],
    "body": "    fn mul(self, scalar: &'a Scalar) -> EdwardsPoint {\n        crate::backend::variable_base_mul(self, scalar)\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> [u8; PUBLIC_KEY_LENGTH] {\n        self.compressed.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/mul_internal"
    ],
    "body": "    pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        forall|i: int| 0 <= i < 5 ==> a.limbs[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b.limbs[i] < (1u64 << 52),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &RR))\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/square_internal",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce"
    ],
    "body": "    pub fn montgomery_square(&self) -> Scalar52 {\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }",
    "display_name": "montgomery_square",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/splat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/new"
    ],
    "body": "    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }",
    "display_name": "splat",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 rand_core/static_from_rng",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/impl/StaticSecret/random_from_rng"
    ],
    "body": "    fn static_from_rng() {\n        StaticSecret::random_from_rng(&mut OsRng.unwrap_err());\n    }",
    "display_name": "static_from_rng",
    "full_path": "file:///work/3118/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/consttime_fixed_base_scalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/invert"
    ],
    "body": "    fn consttime_fixed_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time fixed-base scalar mul\", move |b| {\n            b.iter(|| EdwardsPoint::mul_base(&s))\n        });\n    }",
    "display_name": "consttime_fixed_base_scalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/identity_in_different_coordinates",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/Identity/identity",
      "5.0.0_pre.0 montgomery/impl/ProjectivePoint/as_affine"
    ],
    "body": "    fn identity_in_different_coordinates() {\n        let id_projective = ProjectivePoint::identity();\n        let id_montgomery = id_projective.as_affine();\n\n        assert!(id_montgomery == MontgomeryPoint::identity());\n    }",
    "display_name": "identity_in_different_coordinates",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/decompress/step_1",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/as_bytes"
    ],
    "body": "    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.to_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }",
    "display_name": "step_1",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/read_le_u64_into",
    "statement_type": "function",
    "deps": [],
    "body": "fn read_le_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(\n        src.len() == 8 * dst.len(),\n        \"src.len() = {}, dst.len() = {}\",\n        src.len(),\n        dst.len()\n    );\n    for (bytes, val) in src.chunks(8).zip(dst.iter_mut()) {\n        *val = u64::from_le_bytes(\n            bytes\n                .try_into()\n                .expect(\"Incorrect src length, should be 8 * dst.len()\"),\n        );\n    }\n}",
    "display_name": "read_le_u64_into",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/impl_sum",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let two = Scalar::from(2u64);\n        let one_vector = [Scalar::ONE, Scalar::ONE];\n        let should_be_two: Scalar = one_vector.iter().sum();\n        assert_eq!(should_be_two, two);\n\n        // Test that sum works for the empty iterator\n        let zero = Scalar::ZERO;\n        let empty_vector = [];\n        let should_be_zero: Scalar = empty_vector.iter().sum();\n        assert_eq!(should_be_zero, zero);\n\n        // Test that sum works for owned types\n        let xs = [Scalar::from(1u64); 10];\n        let ys = [Scalar::from(2u64); 10];\n        // now zs is an iterator with Item = Scalar\n        let zs = xs.iter().zip(ys.iter()).map(|(x, y)| x + y);\n\n        let x_sum: Scalar = xs.iter().sum();\n        let y_sum: Scalar = ys.iter().sum();\n        let z_sum: Scalar = zs.sum();\n\n        assert_eq!(x_sum, Scalar::from(10u64));\n        assert_eq!(y_sum, Scalar::from(20u64));\n        assert_eq!(z_sum, Scalar::from(30u64));\n        assert_eq!(x_sum + y_sum, z_sum);\n    }",
    "display_name": "impl_sum",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/verify_strict",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/is_small_order",
      "3.0.0_pre.0 verifying/impl/RCompute/compute",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress",
      "3.0.0_pre.0 errors/impl/ed25519::Error/From/from",
      "3.0.0_pre.0 signature/impl/InternalSignature/TryFrom/try_from"
    ],
    "body": "    pub fn verify_strict(\n        &self,\n        message: &[u8],\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError> {\n        let signature = InternalSignature::try_from(signature)?;\n\n        let signature_R = signature\n            .R\n            .decompress()\n            .ok_or_else(|| SignatureError::from(InternalError::Verify))?;\n\n        // Logical OR is fine here as we're not trying to be constant time.\n        if signature_R.is_small_order() || self.point.is_small_order() {\n            return Err(InternalError::Verify.into());\n        }\n\n        let expected_R = RCompute::<Sha512>::compute(self, signature, None, &[message]);\n        if expected_R == signature.R {\n            Ok(())\n        } else {\n            Err(InternalError::Verify.into())\n        }\n    }",
    "display_name": "verify_strict",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes(bytes: &[u8; 32]) -> Scalar52 {\n        let mut words = [0u64; 4];\n        for i in 0..4 {\n            for j in 0..8 {\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52::ZERO;\n\n        s[0] =   words[0]                            & mask;\n        s[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s[4] =  (words[3] >> 16)                     & top_mask;\n\n        s\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/sub"
    ],
    "body": "    pub fn add(a: &Scalar52, b: &Scalar52) -> Scalar52 {\n        let mut sum = Scalar52::ZERO;\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        for i in 0..5 {\n            carry = a[i] + b[i] + (carry >> 52);\n            sum[i] = carry & mask;\n        }\n\n        // subtract l if the sum is >= l\n        Scalar52::sub(&sum, &constants::L)\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/partial_precomputed_mixed_multiscalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/random",
      "5.0.0_pre.0 scalar/impl/Scalar/random"
    ],
    "body": "    fn partial_precomputed_mixed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n        let n_dynamic = 8;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use one fewer scalars\n        let static_scalars = (0..n_static - 1)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_points = (0..n_dynamic)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..n_dynamic)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n        for i in 0..n_dynamic {\n            result_manual += dynamic_points[i] * dynamic_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }",
    "display_name": "partial_precomputed_mixed_multiscalar",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/ProjectivePoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/&EdwardsPoint/Add/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective_niels",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended"
    ],
    "body": "    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> SecretKey {\n        self.secret_key\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/straus_multiscalar_mul"
    ],
    "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.  When we do\n        // size-dependent algorithm dispatch, use this as the hint.\n        let _size = s_lo;\n\n        crate::backend::straus_multiscalar_mul(scalars, points)\n    }",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/as_bytes"
    ],
    "body": "    fn eq(&self, other: &VerifyingKey) -> bool {\n        self.as_bytes() == other.as_bytes()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/to_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery"
    ],
    "body": "    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        self.point.to_montgomery()\n    }",
    "display_name": "to_montgomery",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/impl/NafLookupTable8/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        writeln!(f, \"NafLookupTable8([\")?;\n        for i in 0..64 {\n            writeln!(f, \"\\t{:?},\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity"
    ],
    "body": "    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/Identity/identity"
    ],
    "body": "    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u64x4/new",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn new(x0: u64, x1: u64, x2: u64, x3: u64) -> u64x4 {\n        unsafe {\n            // _mm256_set_epi64 sets the underlying vector in reverse order of the args\n            u64x4(core::arch::x86_64::_mm256_set_epi64x(\n                x3 as i64, x2 as i64, x1 as i64, x0 as i64,\n            ))\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n        self.0[0] = 1;\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert"
    ],
    "body": "    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        let u = &U * &W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
    "display_name": "to_montgomery",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/test_precomputed_basepoint_mult",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn test_precomputed_basepoint_mult() {\n        let aB_1 = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n        let aB_2 = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n        assert_eq!(aB_1.compress(), aB_2.compress());\n    }",
    "display_name": "test_precomputed_basepoint_mult",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/impl/NafLookupTable5/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/as_projective_niels",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/double",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended"
    ],
    "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/part2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/part1",
      "5.0.0_pre.0 backend/serial/u64/scalar/m",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/sub"
    ],
    "body": "        fn part2(sum: u128) -> (u128, u64) {\n            let w = (sum as u64) & ((1u64 << 52) - 1);\n            (sum >> 52, w)\n        }",
    "display_name": "part2",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 process_impl",
    "statement_type": "function",
    "deps": [
      "0.1.1 process_function"
    ],
    "body": "fn process_impl(attributes: &syn::LitStr, mut item_impl: syn::ItemImpl) -> TokenStream {\n    unsupported_if_some!(item_impl.defaultness);\n    unsupported_if_some!(item_impl.unsafety);\n\n    let mut items = Vec::new();\n    for item in item_impl.items.drain(..) {\n        match item {\n            syn::ImplItem::Fn(function) => {\n                unsupported_if_some!(function.defaultness);\n                let function = syn::ItemFn {\n                    attrs: function.attrs,\n                    vis: function.vis,\n                    sig: function.sig,\n                    block: Box::new(function.block),\n                };\n                let output_item = process_function(\n                    attributes,\n                    function,\n                    Some((item_impl.generics.clone(), item_impl.self_ty.clone())),\n                );\n                items.push(syn::ImplItem::Verbatim(output_item.into()));\n            }\n            item => items.push(item),\n        }\n    }\n\n    item_impl.items = items;\n    quote::quote! {\n        #item_impl\n    }\n    .into()\n}",
    "display_name": "process_impl",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/impl/ExpandedSecretKey/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.scalar.ct_eq(&other.scalar) & self.hash_prefix.ct_eq(&other.hash_prefix)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/pow22501",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/pow2k"
    ],
    "body": "    fn pow22501(&self) -> (FieldElement, FieldElement) {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        let t0  = self.square();           // 1         e_0 = 2^1\n        let t1  = t0.square().square();    // 3         e_1 = 2^3\n        let t2  = self * &t1;              // 3,0       e_2 = 2^3 + 2^0\n        let t3  = &t0 * &t2;               // 3,1,0\n        let t4  = t3.square();             // 4,2,1\n        let t5  = &t2 * &t4;               // 4,3,2,1,0\n        let t6  = t5.pow2k(5);             // 9,8,7,6,5\n        let t7  = &t6 * &t5;               // 9,8,7,6,5,4,3,2,1,0\n        let t8  = t7.pow2k(10);            // 19..10\n        let t9  = &t8 * &t7;               // 19..0\n        let t10 = t9.pow2k(20);            // 39..20\n        let t11 = &t10 * &t9;              // 39..0\n        let t12 = t11.pow2k(10);           // 49..10\n        let t13 = &t12 * &t7;              // 49..0\n        let t14 = t13.pow2k(50);           // 99..50\n        let t15 = &t14 * &t13;             // 99..0\n        let t16 = t15.pow2k(100);          // 199..100\n        let t17 = &t16 * &t15;             // 199..0\n        let t18 = t17.pow2k(50);           // 249..50\n        let t19 = &t18 * &t13;             // 249..0\n\n        (t19, t3)\n    }",
    "display_name": "pow22501",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_edwards",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes"
    ],
    "body": "    pub fn to_edwards(&self, sign: u8) -> Option<EdwardsPoint> {\n        // To decompress the Montgomery u coordinate to an\n        // `EdwardsPoint`, we apply the birational map to obtain the\n        // Edwards y coordinate, then do Edwards decompression.\n        //\n        // The birational map is y = (u-1)/(u+1).\n        //\n        // The exceptional points are the zeros of the denominator,\n        // i.e., u = -1.\n        //\n        // But when u = -1, v^2 = u*(u^2+486662*u+1) = 486660.\n        //\n        // Since this is nonsquare mod p, u = -1 corresponds to a point\n        // on the twist, not the curve, so we can reject it early.\n\n        let u = FieldElement::from_bytes(&self.0);\n\n        if u == FieldElement::MINUS_ONE {\n            return None;\n        }\n\n        let one = FieldElement::ONE;\n\n        let y = &(&u - &one) * &(&u + &one).invert();\n\n        let mut y_bytes = y.to_bytes();\n        y_bytes[31] ^= sign << 7;\n\n        CompressedEdwardsY(y_bytes).decompress()\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 process_function",
    "statement_type": "function",
    "deps": [
      "0.1.1 is_path_eq"
    ],
    "body": "fn process_function(\n    attributes: &syn::LitStr,\n    function: syn::ItemFn,\n    outer: Option<(syn::Generics, Box<syn::Type>)>,\n) -> TokenStream {\n    if function.sig.unsafety.is_some() {\n        return quote::quote! {\n            #[target_feature(enable = #attributes)]\n            #function\n        }\n        .into();\n    }\n\n    unsupported_if_some!(function.sig.constness);\n    unsupported_if_some!(function.sig.asyncness);\n    unsupported_if_some!(function.sig.abi);\n    unsupported_if_some!(function.sig.variadic);\n\n    let function_visibility = function.vis;\n    let function_name = function.sig.ident;\n    let function_return = function.sig.output;\n    let function_inner_name =\n        syn::Ident::new(&format!(\"_impl_{}\", function_name), function_name.span());\n    let function_args = function.sig.inputs;\n    let function_body = function.block;\n    let mut function_call_args = Vec::new();\n    let mut function_args_outer = Vec::new();\n    let mut function_args_inner = Vec::new();\n    for (index, arg) in function_args.iter().enumerate() {\n        match arg {\n            syn::FnArg::Receiver(receiver) => {\n                unsupported_if_some!(receiver.attrs.first());\n                unsupported_if_some!(receiver.colon_token);\n\n                if outer.is_none() {\n                    return syn::Error::new(receiver.span(), \"unsupported by #[unsafe_target_feature(...)]; put the attribute on the outer `impl`\").into_compile_error().into();\n                }\n\n                function_args_inner.push(syn::FnArg::Receiver(receiver.clone()));\n                function_args_outer.push(syn::FnArg::Receiver(receiver.clone()));\n                function_call_args.push(syn::Ident::new(\"self\", receiver.self_token.span()));\n            }\n            syn::FnArg::Typed(ty) => {\n                unsupported_if_some!(ty.attrs.first());\n\n                match &*ty.pat {\n                    syn::Pat::Ident(pat_ident) => {\n                        unsupported_if_some!(pat_ident.attrs.first());\n\n                        function_args_inner.push(arg.clone());\n                        function_args_outer.push(syn::FnArg::Typed(syn::PatType {\n                            attrs: Vec::new(),\n                            pat: Box::new(syn::Pat::Ident(syn::PatIdent {\n                                attrs: Vec::new(),\n                                by_ref: None,\n                                mutability: None,\n                                ident: pat_ident.ident.clone(),\n                                subpat: None,\n                            })),\n                            colon_token: ty.colon_token,\n                            ty: ty.ty.clone(),\n                        }));\n                        function_call_args.push(pat_ident.ident.clone());\n                    }\n                    syn::Pat::Wild(pat_wild) => {\n                        unsupported_if_some!(pat_wild.attrs.first());\n\n                        let ident = syn::Ident::new(\n                            &format!(\"__arg_{}__\", index),\n                            pat_wild.underscore_token.span(),\n                        );\n                        function_args_inner.push(arg.clone());\n                        function_args_outer.push(syn::FnArg::Typed(syn::PatType {\n                            attrs: Vec::new(),\n                            pat: Box::new(syn::Pat::Ident(syn::PatIdent {\n                                attrs: Vec::new(),\n                                by_ref: None,\n                                mutability: None,\n                                ident: ident.clone(),\n                                subpat: None,\n                            })),\n                            colon_token: ty.colon_token,\n                            ty: ty.ty.clone(),\n                        }));\n                        function_call_args.push(ident);\n                    }\n                    _ => unsupported!(arg),\n                }\n            }\n        }\n    }\n\n    let mut maybe_inline = quote::quote! {};\n    let mut maybe_outer_attributes = Vec::new();\n    let mut maybe_cfg = quote::quote! {};\n    for attribute in function.attrs {\n        match &attribute.meta {\n            syn::Meta::Path(path) if is_path_eq(path, \"inline\") => {\n                maybe_inline = quote::quote! { #[inline] };\n            }\n            syn::Meta::Path(path) if is_path_eq(path, \"test\") => {\n                maybe_outer_attributes.push(attribute);\n                maybe_cfg = quote::quote! { #[cfg(target_feature = #attributes)] };\n            }\n            syn::Meta::List(syn::MetaList { path, tokens, .. })\n                if is_path_eq(path, \"inline\") && tokens.to_string() == \"always\" =>\n            {\n                maybe_inline = quote::quote! { #[inline] };\n            }\n            syn::Meta::NameValue(syn::MetaNameValue { path, .. }) if is_path_eq(path, \"doc\") => {\n                maybe_outer_attributes.push(attribute);\n            }\n            syn::Meta::List(syn::MetaList { path, .. })\n                if is_path_eq(path, \"cfg\")\n                    || is_path_eq(path, \"allow\")\n                    || is_path_eq(path, \"deny\") =>\n            {\n                maybe_outer_attributes.push(attribute);\n            }\n            syn::Meta::Path(path) if is_path_eq(path, \"rustfmt::skip\") => {\n                maybe_outer_attributes.push(attribute);\n            }\n            _ => unsupported!(attribute),\n        }\n    }\n\n    let (fn_impl_generics, fn_ty_generics, fn_where_clause) =\n        function.sig.generics.split_for_impl();\n    let fn_call_generics = fn_ty_generics.as_turbofish();\n\n    if let Some((generics, self_ty)) = outer {\n        let (outer_impl_generics, outer_ty_generics, outer_where_clause) =\n            generics.split_for_impl();\n        let trait_ident =\n            syn::Ident::new(&format!(\"__Impl_{}__\", function_name), function_name.span());\n        let item_trait = quote::quote! {\n            #[allow(non_camel_case_types)]\n            trait #trait_ident #outer_impl_generics #outer_where_clause {\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause;\n            }\n        };\n\n        let item_trait_impl = quote::quote! {\n            impl #outer_impl_generics #trait_ident #outer_ty_generics for #self_ty #outer_where_clause {\n                #[target_feature(enable = #attributes)]\n                #maybe_inline\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_inner),*) #function_return #fn_where_clause #function_body\n            }\n        };\n\n        quote::quote! {\n            #[inline(always)]\n            #(#maybe_outer_attributes)*\n            #function_visibility fn #function_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause {\n                #item_trait\n                #item_trait_impl\n                unsafe {\n                    <Self as #trait_ident #outer_ty_generics> ::#function_inner_name #fn_call_generics (#(#function_call_args),*)\n                }\n            }\n        }.into()\n    } else {\n        quote::quote! {\n            #[inline(always)]\n            #maybe_cfg\n            #(#maybe_outer_attributes)*\n            #function_visibility fn #function_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause {\n                #[target_feature(enable = #attributes)]\n                #maybe_inline\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_inner),*) #function_return #fn_where_clause #function_body\n                unsafe {\n                    #function_inner_name #fn_call_generics (#(#function_call_args),*)\n                }\n            }\n        }.into()\n    }\n}",
    "display_name": "process_function",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix128/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/NafLookupTable8/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/From/from",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/CachedPoint/From/from",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/double"
    ],
    "body": "    fn from(point: &edwards::EdwardsPoint) -> Self {\n        let A = ExtendedPoint::from(*point);\n        let mut Ai = [CachedPoint::from(A); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).into();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/from_bytes"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {\n        let bytes = bytes.try_into().map_err(|_| InternalError::BytesLength {\n            name: \"VerifyingKey\",\n            length: PUBLIC_KEY_LENGTH,\n        })?;\n        Self::from_bytes(bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 errors/impl/ed25519::Error/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(_err: InternalError) -> SignatureError {\n        SignatureError::new()\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/errors.rs",
    "relative_path": "ed25519-dalek/src/errors.rs",
    "file_name": "errors.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/equality",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes"
    ],
    "body": "    fn equality() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        assert!(a == a);\n        assert!(a != ainv);\n    }",
    "display_name": "equality",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoBasepointTable/create",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTable/BasepointTable/create"
    ],
    "body": "    pub fn create(basepoint: &RistrettoPoint) -> RistrettoBasepointTable {\n        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }",
    "display_name": "create",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/consttime_variable_base_scalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/invert",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn consttime_variable_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B = &constants::ED25519_BASEPOINT_POINT;\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time variable-base scalar mul\", move |b| {\n            b.iter(|| B * s)\n        });\n    }",
    "display_name": "consttime_variable_base_scalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul_internal",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_reduce"
    ],
    "body": "    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> Scalar52 {\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }",
    "display_name": "montgomery_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/from_keypair_bytes",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/verifying_key",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/TryFrom/try_from",
      "3.0.0_pre.0 signing/impl/SigningKey/TryFrom/try_from"
    ],
    "body": "    pub fn from_keypair_bytes(bytes: &[u8; 64]) -> Result<SigningKey, SignatureError> {\n        let (secret_key, verifying_key) = bytes.split_at(SECRET_KEY_LENGTH);\n        let signing_key = SigningKey::try_from(secret_key)?;\n        let verifying_key = VerifyingKey::try_from(verifying_key)?;\n\n        if signing_key.verifying_key() != verifying_key {\n            return Err(InternalError::MismatchedKeypair.into());\n        }\n\n        Ok(signing_key)\n    }",
    "display_name": "from_keypair_bytes",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/Signer/try_sign",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/MultipartSigner/try_multipart_sign"
    ],
    "body": "    fn try_sign(&self, message: &[u8]) -> Result<Signature, SignatureError> {\n        self.try_multipart_sign(&[message])\n    }",
    "display_name": "try_sign",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/splat",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/splat_const"
    ],
    "body": "    fn conditional_assign(&mut self, other: &FieldElement2625x4, choice: Choice) {\n        let mask = (-(choice.unwrap_u8() as i32)) as u32;\n        let mask_vec = u32x8::splat(mask);\n        self.0[0] ^= mask_vec & (self.0[0] ^ other.0[0]);\n        self.0[1] ^= mask_vec & (self.0[1] ^ other.0[1]);\n        self.0[2] ^= mask_vec & (self.0[2] ^ other.0[2]);\n        self.0[3] ^= mask_vec & (self.0[3] ^ other.0[3]);\n        self.0[4] ^= mask_vec & (self.0[4] ^ other.0[4]);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "0.1.1 impl//From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(_: &'a Struct) -> Self {}\n}",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/from_bytes_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/from_bytes_wide"
    ],
    "body": "    fn from_bytes_wide() {\n        // Do the 64-byte input ones first\n        for (input_bytes, expected_reduced) in FROM_BYTES_WIDE_KAT_BIG {\n            let reduce_fe = FieldElement::from_bytes_wide(\n                &hex::decode(input_bytes)\n                    .unwrap()\n                    .as_slice()\n                    .try_into()\n                    .unwrap(),\n            );\n            assert_eq!(\n                &reduce_fe.to_bytes(),\n                hex::decode(expected_reduced).unwrap().as_slice()\n            );\n        }\n\n        // Now do the 48-byte inputs\n        for (input_bytes, expected_reduced) in FROM_BYTES_WIDE_KAT_MEDIUM {\n            let mut padded_input_bytes = [0u8; 64];\n            padded_input_bytes[..48].copy_from_slice(&hex::decode(input_bytes).unwrap());\n            let reduce_fe = FieldElement::from_bytes_wide(&padded_input_bytes);\n            assert_eq!(\n                &reduce_fe.to_bytes(),\n                hex::decode(expected_reduced).unwrap().as_slice()\n            );\n        }\n    }",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }\n\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        FieldElement51(\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ])\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/top_half",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/bot_half"
    ],
    "body": "        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }",
    "display_name": "top_half",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/&EdwardsPoint/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.Y_minus_X;\n        let MP = &Y_minus_X * &other.Y_plus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &ZZ2 - &TT2d,\n            T: &ZZ2 + &TT2d,\n        }\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "3.0.0_pre.0 signature/impl/InternalSignature/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Signature( R: {:?}, s: {:?} )\", &self.R, &self.s)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/AffinePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/affine/impl/AffinePoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/eq_defined_mod_p",
    "statement_type": "function",
    "deps": [],
    "body": "    fn eq_defined_mod_p() {\n        let mut u18_bytes = [0u8; 32];\n        u18_bytes[0] = 18;\n        let u18 = MontgomeryPoint(u18_bytes);\n        let u18_unred = MontgomeryPoint([255; 32]);\n\n        assert_eq!(u18, u18_unred);\n    }",
    "display_name": "eq_defined_mod_p",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.bytes\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 impl/SpecializeArg/condition",
    "statement_type": "function",
    "deps": [],
    "body": "    fn condition(&self) -> Option<&TokenStream2> {\n        match self {\n            SpecializeArg::LitStr(..) => None,\n            SpecializeArg::Conditional(conditional) => Some(&conditional.attr),\n        }\n    }",
    "display_name": "condition",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/batch_invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_mul",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/montgomery_invert",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/as_montgomery",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack",
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/from_montgomery"
    ],
    "body": "    pub fn batch_invert(inputs: &mut [Scalar]) -> Scalar {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n\n        let n = inputs.len();\n        let one: UnpackedScalar = Scalar::ONE.unpack().as_montgomery();\n\n        let mut scratch = vec![one; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = Scalar::ONE.unpack().as_montgomery();\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n            *scratch = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        acc = acc.montgomery_invert().from_montgomery();\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        Zeroize::zeroize(&mut scratch);\n\n        ret\n    }",
    "display_name": "batch_invert",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/test/sign_byupdate",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/impl/VerifyingKey/From/from",
      "3.0.0_pre.0 hazmat/raw_sign",
      "3.0.0_pre.0 hazmat/test/impl/ExpandedSecretKey/random",
      "3.0.0_pre.0 hazmat/raw_sign_byupdate"
    ],
    "body": "    fn sign_byupdate() {\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        let msg = b\"realistic\";\n        // signatures are deterministic so we can compare with a good one\n        let good_sig = raw_sign::<CtxDigest>(&esk, msg, &vk);\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(msg);\n                Ok(())\n            },\n            &vk,\n        );\n        assert!(sig.unwrap() == good_sig, \"sign byupdate matches\");\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(msg);\n                Err(SignatureError::new())\n            },\n            &vk,\n        );\n        assert!(sig.is_err(), \"sign byupdate failure propagates\");\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(&msg[..1]);\n                h.update(&msg[1..]);\n                Ok(())\n            },\n            &vk,\n        );\n        assert!(sig.unwrap() == good_sig, \"sign byupdate two part\");\n    }",
    "display_name": "sign_byupdate",
    "full_path": "file:///work/3118/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }",
    "display_name": "index",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519_benches",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 bench_diffie_hellman"
    ],
    "body": "    name = x25519_benches;\n    config = Criterion::default();\n    targets =\n        bench_diffie_hellman,\n}\ncriterion_main! {\n    x25519_benches,\n}",
    "display_name": "x25519_benches",
    "full_path": "file:///work/3118/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/batch_invert_consistency",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/invert",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 scalar/impl/Scalar/batch_invert"
    ],
    "body": "    fn batch_invert_consistency() {\n        let mut x = Scalar::from(1u64);\n        let mut v1: Vec<_> = (0..16)\n            .map(|_| {\n                let tmp = x;\n                x = x + x;\n                tmp\n            })\n            .collect();\n        let v2 = v1.clone();\n\n        let expected: Scalar = v1.iter().product();\n        let expected = expected.invert();\n        let ret = Scalar::batch_invert(&mut v1);\n        assert_eq!(ret, expected);\n\n        for (a, b) in v1.iter().zip(v2.iter()) {\n            assert_eq!(a * b, Scalar::ONE);\n        }\n    }",
    "display_name": "batch_invert_consistency",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 errors/impl/InternalError/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            InternalError::PointDecompression => write!(f, \"Cannot decompress Edwards point\"),\n            InternalError::ScalarFormat => write!(f, \"Cannot use scalar with high-bit set\"),\n            InternalError::BytesLength { name: n, length: l } => {\n                write!(f, \"{} must be {} bytes in length\", n, l)\n            }\n            InternalError::Verify => write!(f, \"Verification equation was not satisfied\"),\n            #[cfg(feature = \"batch\")]\n            InternalError::ArrayLength {\n                name_a: na,\n                length_a: la,\n                name_b: nb,\n                length_b: lb,\n                name_c: nc,\n                length_c: lc,\n            } => write!(\n                f,\n                \"Arrays must be the same length: {} has length {},\n                              {} has length {}, {} has length {}.\",\n                na, la, nb, lb, nc, lc\n            ),\n            #[cfg(feature = \"digest\")]\n            InternalError::PrehashedContextLength => write!(\n                f,\n                \"An ed25519ph signature can only take up to 255 octets of context\"\n            ),\n            InternalError::MismatchedKeypair => write!(f, \"Mismatched Keypair detected\"),\n        }\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/ed25519-dalek/src/errors.rs",
    "relative_path": "ed25519-dalek/src/errors.rs",
    "file_name": "errors.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/EphemeralSecret/diffie_hellman",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_clamped"
    ],
    "body": "    pub fn diffie_hellman(self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }",
    "display_name": "diffie_hellman",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/precomputed_straus/spec/impl/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/opt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/NafLookupTable5/From/from",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/double",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Identity/identity"
    ],
    "body": "        fn optional_mixed_multiscalar_mul<I, J, K>(\n            &self,\n            static_scalars: I,\n            dynamic_scalars: J,\n            dynamic_points: K,\n        ) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator,\n            J::Item: Borrow<Scalar>,\n            K: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let static_nafs = static_scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect::<Vec<_>>();\n            let dynamic_nafs: Vec<_> = dynamic_scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect::<Vec<_>>();\n\n            let dynamic_lookup_tables = dynamic_points\n                .into_iter()\n                .map(|P_opt| P_opt.map(|P| NafLookupTable5::<CachedPoint>::from(&P)))\n                .collect::<Option<Vec<_>>>()?;\n\n            let sp = self.static_lookup_tables.len();\n            let dp = dynamic_lookup_tables.len();\n            assert!(sp >= static_nafs.len());\n            assert_eq!(dp, dynamic_nafs.len());\n\n            // We could save some doublings by looking for the highest\n            // nonzero NAF coefficient, but since we might have a lot of\n            // them to search, it's not clear it's worthwhile to check.\n            let mut R = ExtendedPoint::identity();\n            for j in (0..256).rev() {\n                R = R.double();\n\n                for i in 0..dp {\n                    let t_ij = dynamic_nafs[i][j];\n                    match t_ij.cmp(&0) {\n                        Ordering::Greater => {\n                            R = &R + &dynamic_lookup_tables[i].select(t_ij as usize);\n                        }\n                        Ordering::Less => {\n                            R = &R - &dynamic_lookup_tables[i].select(-t_ij as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..static_nafs.len() {\n                    let t_ij = static_nafs[i][j];\n                    match t_ij.cmp(&0) {\n                        Ordering::Greater => {\n                            R = &R + &self.static_lookup_tables[i].select(t_ij as usize);\n                        }\n                        Ordering::Less => {\n                            R = &R - &self.static_lookup_tables[i].select(-t_ij as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n            }\n\n            Some(R.into())\n        }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_part2",
    "statement_type": "function",
    "deps": [],
    "body": "    fn montgomery_part2(sum: u128) -> (u128, u64)\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let w = (sum as u64) & ((1u64 << 52) - 1);\n        let carry = sum >> 52;\n        (carry, w)\n    }",
    "display_name": "montgomery_part2",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/from_canonical_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/is_canonical"
    ],
    "body": "    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }",
    "display_name": "from_canonical_bytes",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/from_bytes"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<SigningKey, SignatureError> {\n        SecretKey::try_from(bytes)\n            .map(|bytes| Self::from_bytes(&bytes))\n            .map_err(|_| {\n                InternalError::BytesLength {\n                    name: \"SecretKey\",\n                    length: SECRET_KEY_LENGTH,\n                }\n                .into()\n            })\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signature/impl/InternalSignature/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "    fn clone(&self) -> Self {\n        *self\n    }",
    "display_name": "clone",
    "full_path": "file:///work/3118/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_mult_vs_ed25519py",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/mul_base",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_mult_vs_ed25519py() {\n        let aB = EdwardsPoint::mul_base(&A_SCALAR);\n        assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n    }",
    "display_name": "basepoint_mult_vs_ed25519py",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/elligator_ristretto_flavor",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_negative",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/sqrt_ratio_i",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_assign",
      "5.0.0_pre.0 backend/serial/curve_models/impl/CompletedPoint/as_extended",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square"
    ],
    "body": "    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }",
    "display_name": "elligator_ristretto_flavor",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/sub"
    ],
    "body": "    pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        forall|i: int| 0 <= i < 5 ==> a.limbs[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==>  b.limbs[i] < (1u64 << 52),\n    ensures\n        to_nat(&s.limbs) == to_nat(&a.limbs) + to_nat(&b.limbs),\n    {\n        //let mut sum = Scalar52::ZERO;\n        let mut sum = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof {\n            assert(Scalar52::ZERO == Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] });\n            assert(sum == Scalar52::ZERO);\n            assert(1u64 << 52 > 0) by (bit_vector);\n        }\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        proof {\n            assert(carry == 0u64);\n            assert(1u64 << 54 < u64::MAX) by (bit_vector);\n            assert(0u64 < (1u64 << 54)) by (bit_vector);\n        }\n        for i in 0..5\n           invariant //0 <= i <= 5,\n           // forall|j: int| 0 <= j < i ==> sum.limbs[j] < 1u64 << 52,\n            (0 <= i < 5) ==> a.limbs[i as int] < (1u64 << 52),\n            (0 <= i < 5) ==> b.limbs[i as int] < (1u64 << 52),\n            carry < (1u64 << 54),\n        {\n            proof {\n                assert(0 <= i < 5);\n                assert(a.limbs[i as int] < 1u64 << 52);\n                assert(b.limbs[i as int] < 1u64 << 52);\n                assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n                assert(a.limbs[i as int] + b.limbs[i as int] < 1u64 << 53);\n                assert(carry < (1u64 << 54));\n                assert(carry >> 52 >= 0u64);\n                assert((carry >> 52) < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 53) + 3 < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 53) + (1u64 << 54) <= (1u64 << 55)) by (bit_vector);\n                assert((a.limbs[i as int] + b.limbs[i as int] + (carry >> 52)) < (1u64 << 55));\n            }\n            carry = a.limbs[i] + b.limbs[i] + (carry >> 52);\n            sum.limbs[i] = carry & mask;\n            assume( (0 <= i < 5) ==> a.limbs[i as int] < (1u64 << 52));\n            assume( (0 <= i < 5) ==> b.limbs[i as int] < (1u64 << 52));\n            assume(false);\n        }\n\n        // subtract l if the sum is >= l\n\n        /*** BEGIN: ADAPTED CODE BLOCK ***/\n\n        /* ORIGINAL CODE */\n        /*let mut s = Scalar52::sub(&sum, &Self::L);*/\n        /* OUR ADAPTED CODE FOR VERUS; PROVED EQUIVALENT TO ORIGINAL CODE */\n        let l_value = Scalar52 { limbs: [0x0002631a5cf5d3ed, 0x000dea2f79cd6581, 0x000000000014def9, 0x0000000000000000, 0x0000100000000000] };\n        assert(to_nat(&l_value.limbs) == to_nat(&L.limbs));\n        assume(false); // TODO: complete the proof\n\n        Scalar52::sub(&sum, &l_value)\n\n        /*** END: ADAPTED CODE BLOCK ***/\n\n    }",
    "display_name": "add",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/vartime_double_base/spec/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/non_adjacent_form",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Identity/identity",
      "5.0.0_pre.0 window/impl/NafLookupTable8/select",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/double",
      "5.0.0_pre.0 window/impl/NafLookupTable5/select",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/NafLookupTable5/From/from"
    ],
    "body": "    pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n        let a_naf = a.non_adjacent_form(5);\n\n        #[cfg(feature = \"precomputed-tables\")]\n        let b_naf = b.non_adjacent_form(8);\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        let b_naf = b.non_adjacent_form(5);\n\n        // Find starting index\n        let mut i: usize = 255;\n        for j in (0..256).rev() {\n            i = j;\n            if a_naf[i] != 0 || b_naf[i] != 0 {\n                break;\n            }\n        }\n\n        let table_A = NafLookupTable5::<CachedPoint>::from(A);\n\n        #[cfg(feature = \"precomputed-tables\")]\n        let table_B = &BASEPOINT_ODD_LOOKUP_TABLE;\n\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        let table_B =\n            &NafLookupTable5::<CachedPoint>::from(&crate::constants::ED25519_BASEPOINT_POINT);\n\n        let mut Q = ExtendedPoint::identity();\n\n        loop {\n            Q = Q.double();\n\n            match a_naf[i].cmp(&0) {\n                Ordering::Greater => {\n                    Q = &Q + &table_A.select(a_naf[i] as usize);\n                }\n                Ordering::Less => {\n                    Q = &Q - &table_A.select(-a_naf[i] as usize);\n                }\n                Ordering::Equal => {}\n            }\n\n            match b_naf[i].cmp(&0) {\n                Ordering::Greater => {\n                    Q = &Q + &table_B.select(b_naf[i] as usize);\n                }\n                Ordering::Less => {\n                    Q = &Q - &table_B.select(-b_naf[i] as usize);\n                }\n                Ordering::Equal => {}\n            }\n\n            if i == 0 {\n                break;\n            }\n            i -= 1;\n        }\n\n        Q.into()\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/vartime_double_base.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/vartime_double_base.rs",
    "file_name": "vartime_double_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) * _rhs;\n        self.0 = result.0;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/construct_scalars",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/random"
    ],
    "body": "    fn construct_scalars(n: usize) -> Vec<Scalar> {\n        let mut rng = rng();\n        (0..n).map(|_| Scalar::random(&mut rng)).collect()\n    }",
    "display_name": "construct_scalars",
    "full_path": "file:///work/3118/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul",
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack"
    ],
    "body": "    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/montgomery_elligator_zero_zero",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/to_bytes",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 montgomery/elligator_encode"
    ],
    "body": "    fn montgomery_elligator_zero_zero() {\n        let zero = [0u8; 32];\n        let fe = FieldElement::from_bytes(&zero);\n        let (eg, _) = elligator_encode(&fe);\n        assert_eq!(eg.to_bytes(), zero);\n    }",
    "display_name": "montgomery_elligator_zero_zero",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/batch_invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_assign",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/is_zero",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/invert"
    ],
    "body": "    pub(crate) fn batch_invert(inputs: &mut [FieldElement]) {\n        // Montgomery’s Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        let n = inputs.len();\n        let mut scratch = vec![FieldElement::ONE; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = FieldElement::ONE;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        assert!(bool::from(!acc.is_zero()));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n    }",
    "display_name": "batch_invert",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/select",
    "statement_type": "function",
    "deps": [],
    "body": "        fn select(x: &u64, y: &u64, c: Choice) -> (res: u64)\n            ensures boolify(c) ==> res == x,\n                    ! boolify(c) ==> res == y\n        {\n            u64::conditional_select(x, y, c)\n        }",
    "display_name": "select",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectiveNielsPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.Y_plus_X.zeroize();\n        self.Y_minus_X.zeroize();\n        self.Z.zeroize();\n        self.T2d.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/CompressedRistretto/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/CompressedRistretto/from_slice"
    ],
    "body": "    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/impl/SigningKey/to_scalar",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/ExpandedSecretKey/From/from"
    ],
    "body": "    pub fn to_scalar(&self) -> Scalar {\n        // Per the spec, the ed25519 secret key sk is expanded to\n        //     (scalar_bytes, hash_prefix) = SHA-512(sk)\n        // where the two outputs are both 32 bytes. To use for signing, scalar_bytes must be\n        // clamped and reduced (see ExpandedSecretKey::from_bytes). We return the clamped and\n        // reduced form.\n        ExpandedSecretKey::from(&self.secret_key).scalar\n    }",
    "display_name": "to_scalar",
    "full_path": "file:///work/3118/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_swap",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }",
    "display_name": "conditional_swap",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 find_validation_criteria",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 get_test_vectors",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/verify_strict",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/Verifier/verify"
    ],
    "body": "fn find_validation_criteria() {\n    let mut verify_allowed_edgecases = Set::new();\n    let mut verify_strict_allowed_edgecases = Set::new();\n\n    // Counts the number of times a signature with a re-encoded k and a low-order A verified. This\n    // happens with 1/8 probability, assuming the usual verification equation(s).\n    let mut num_lucky_reencoded_k = 0;\n    let mut num_reencoded_k = 0;\n\n    for TestVector {\n        number: _,\n        pubkey,\n        msg,\n        sig,\n        flags,\n    } in get_test_vectors()\n    {\n        // If verify() was a success, add all the associated flags to verify-permitted set\n        let success = pubkey.verify(&msg, &sig).is_ok();\n\n        // If this is ReencodedK && LowOrderA, log some statistics\n        if flags.contains(&Flag::ReencodedK) && flags.contains(&Flag::LowOrderA) {\n            num_reencoded_k += 1;\n            num_lucky_reencoded_k += success as u8;\n        }\n\n        if success {\n            for flag in &flags {\n                // Don't count re-encoded k when A is low-order. This is because the\n                // re-encoded k might be a multiple of 8 by accident\n                if *flag == Flag::ReencodedK && flags.contains(&Flag::LowOrderA) {\n                    continue;\n                } else {\n                    verify_allowed_edgecases.insert(*flag);\n                }\n            }\n        }\n\n        // If verify_strict() was a success, add all the associated flags to\n        // verify_strict-permitted set\n        let success = pubkey.verify_strict(&msg, &sig).is_ok();\n        if success {\n            for flag in &flags {\n                verify_strict_allowed_edgecases.insert(*flag);\n            }\n        }\n    }\n\n    println!(\"VERIFY_ALLOWED_EDGECASES: {:?}\", verify_allowed_edgecases);\n    println!(\n        \"VERIFY_STRICT_ALLOWED_EDGECASES: {:?}\",\n        verify_strict_allowed_edgecases\n    );\n    println!(\n        \"re-encoded k && low-order A yielded a valid signature {}/{} of the time\",\n        num_lucky_reencoded_k, num_reencoded_k\n    );\n}",
    "display_name": "find_validation_criteria",
    "full_path": "file:///work/3118/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/ed25519_benches",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 ed25519_benches/key_generation",
      "3.0.0_pre.0 ed25519_benches/sign",
      "3.0.0_pre.0 ed25519_benches/verify_batch_signatures",
      "3.0.0_pre.0 ed25519_benches/verify",
      "3.0.0_pre.0 ed25519_benches/verify_strict"
    ],
    "body": "        name = ed25519_benches;\n        config = Criterion::default();\n        targets =\n            sign,\n            verify,\n            verify_strict,\n            verify_batch_signatures,\n            key_generation,\n    }\n}\n\ncriterion::criterion_main!(ed25519_benches::ed25519_benches);",
    "display_name": "ed25519_benches",
    "full_path": "file:///work/3118/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ExtendedPoint(FieldElement2625x4::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/blend",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn blend(&self, other: FieldElement2625x4, control: Lanes) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn blend_lanes(x: u32x8, y: u32x8, control: Lanes) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n\n                // This would be much cleaner if we could factor out the match\n                // statement on the control. Unfortunately, rustc forgets\n                // constant-info very quickly, so we can't even write\n                // ```\n                // match control {\n                //     Lanes::C => {\n                //         let imm = C_LANES as i32;\n                //         _mm256_blend_epi32(..., imm)\n                // ```\n                // let alone\n                // ```\n                // let imm = match control {\n                //     Lanes::C => C_LANES as i32,\n                // }\n                // _mm256_blend_epi32(..., imm)\n                // ```\n                // even though both of these would be constant-folded by LLVM\n                // at a lower level (as happens in the shuffle implementation,\n                // which does not require a shuffle immediate but *is* lowered\n                // to immediate shuffles anyways).\n                match control {\n                    Lanes::C => _mm256_blend_epi32(x.into(), y.into(), C_LANES as i32).into(),\n                    Lanes::D => _mm256_blend_epi32(x.into(), y.into(), D_LANES as i32).into(),\n                    Lanes::AD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::AB => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | B_LANES) as i32).into()\n                    }\n                    Lanes::AC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::CD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (C_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::BC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (B_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::ABCD => _mm256_blend_epi32(\n                        x.into(),\n                        y.into(),\n                        (A_LANES | B_LANES | C_LANES | D_LANES) as i32,\n                    )\n                    .into(),\n                }\n            }\n        }\n\n        FieldElement2625x4([\n            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n\n    /// Convenience wrapper around `new(x,x,x,x)`.\n    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }\n\n    /// Create a `FieldElement2625x4` from four `FieldElement51`s.\n    ///\n    /// # Postconditions\n    ///\n    /// The resulting `FieldElement2625x4` is bounded with \\\\( b < 0.0002 \\\\).\n    #[rustfmt::skip] // keep alignment of computed lanes\n    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> FieldElement2625x4 {\n        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }\n\n        // We don't know that the original `FieldElement51`s were\n        // fully reduced, so the odd limbs may exceed 2^25.\n        // Reduce them to be sure.\n        FieldElement2625x4(buf).reduce()\n    }\n\n    /// Given \\\\((A,B,C,D)\\\\), compute \\\\((-A,-B,-C,-D)\\\\), without\n    /// performing a reduction.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.999 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1 \\\\).\n    #[inline]\n    pub fn negate_lazy(&self) -> FieldElement2625x4 {\n        // The limbs of self are bounded with b < 0.999, while the\n        // smallest limb of 2*p is 67108845 > 2^{26+0.9999}, so\n        // underflows are not possible.\n        FieldElement2625x4([\n            P_TIMES_2_LO - self.0[0],\n            P_TIMES_2_HI - self.0[1],\n            P_TIMES_2_HI - self.0[2],\n            P_TIMES_2_HI - self.0[3],\n            P_TIMES_2_HI - self.0[4],\n        ])\n    }\n\n    /// Given `self = (A,B,C,D)`, compute `(B - A, B + A, D - C, D + C)`.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.01 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1.6 \\\\).\n    #[inline]\n    pub fn diff_sum(&self) -> FieldElement2625x4 {\n        // tmp1 = (B, A, D, C)\n        let tmp1 = self.shuffle(Shuffle::BADC);\n        // tmp2 = (-A, B, -C, D)\n        let tmp2 = self.blend(self.negate_lazy(), Lanes::AC);\n        // (B - A, B + A, D - C, D + C) bounded with b < 1.6\n        tmp1 + tmp2\n    }\n\n    /// Reduce this vector of field elements \\\\(\\mathrm{mod} p\\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.0002 \\\\).\n    #[inline]\n    pub fn reduce(&self) -> FieldElement2625x4 {\n        let shifts = u32x8::new(26, 26, 25, 25, 26, 26, 25, 25);\n        let masks = u32x8::new(\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n        );\n\n        // Let c(x) denote the carryout of the coefficient x.\n        //\n        // Given    (   x0,    y0,    x1,    y1,    z0,    w0,    z1,    w1),\n        // compute  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0)).\n        //\n        // The carryouts are bounded by 2^(32 - 25) = 2^7.\n        let rotated_carryout = |v: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_shuffle_epi32;\n                use core::arch::x86_64::_mm256_srlv_epi32;\n\n                let c = _mm256_srlv_epi32(v.into(), shifts.into());\n                _mm256_shuffle_epi32(c, 0b01_00_11_10).into()\n            }\n        };\n\n        // Combine (lo, lo, lo, lo, lo, lo, lo, lo)\n        //    with (hi, hi, hi, hi, hi, hi, hi, hi)\n        //      to (lo, lo, hi, hi, lo, lo, hi, hi)\n        //\n        // This allows combining carryouts, e.g.,\n        //\n        // lo  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0))\n        // hi  (c(x3), c(y3), c(x2), c(y2), c(z3), c(w3), c(z2), c(w2))\n        // ->  (c(x1), c(y1), c(x2), c(y2), c(z1), c(w1), c(z2), c(w2))\n        //\n        // which is exactly the vector of carryins for\n        //\n        //     (   x2,    y2,    x3,    y3,    z2,    w2,    z3,    w3).\n        //\n        let combine = |v_lo: u32x8, v_hi: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(v_lo.into(), v_hi.into(), 0b11_00_11_00).into()\n            }\n        };\n\n        let mut v = self.0;\n\n        let c10 = rotated_carryout(v[0]);\n        v[0] = (v[0] & masks) + combine(u32x8::splat(0), c10);\n\n        let c32 = rotated_carryout(v[1]);\n        v[1] = (v[1] & masks) + combine(c10, c32);\n\n        let c54 = rotated_carryout(v[2]);\n        v[2] = (v[2] & masks) + combine(c32, c54);\n\n        let c76 = rotated_carryout(v[3]);\n        v[3] = (v[3] & masks) + combine(c54, c76);\n\n        let c98 = rotated_carryout(v[4]);\n        v[4] = (v[4] & masks) + combine(c76, c98);\n\n        let c9_19: u32x8 = unsafe {\n            use core::arch::x86_64::_mm256_mul_epu32;\n            use core::arch::x86_64::_mm256_shuffle_epi32;\n\n            // Need to rearrange c98, since vpmuludq uses the low\n            // 32-bits of each 64-bit lane to compute the product:\n            //\n            // c98       = (c(x9), c(y9), c(x8), c(y8), c(z9), c(w9), c(z8), c(w8));\n            // c9_spread = (c(x9), c(x8), c(y9), c(y8), c(z9), c(z8), c(w9), c(w8)).\n            let c9_spread = _mm256_shuffle_epi32(c98.into(), 0b11_01_10_00);\n\n            // Since the carryouts are bounded by 2^7, their products with 19\n            // are bounded by 2^11.25.  This means that\n            //\n            // c9_19_spread = (19*c(x9), 0, 19*c(y9), 0, 19*c(z9), 0, 19*c(w9), 0).\n            let c9_19_spread = _mm256_mul_epu32(c9_spread, u64x4::splat(19).into());\n\n            // Unshuffle:\n            // c9_19 = (19*c(x9), 19*c(y9), 0, 0, 19*c(z9), 19*c(w9), 0, 0).\n            _mm256_shuffle_epi32(c9_19_spread, 0b11_01_10_00).into()\n        };\n\n        // Add the final carryin.\n        v[0] += c9_19;\n\n        // Each output coefficient has exactly one carryin, which is\n        // bounded by 2^11.25, so they are bounded as\n        //\n        // c_even < 2^26 + 2^11.25 < 26.00006 < 2^{26+b}\n        // c_odd  < 2^25 + 2^11.25 < 25.0001  < 2^{25+b}\n        //\n        // where b = 0.0002.\n        FieldElement2625x4(v)\n    }\n\n    /// Given an array of wide coefficients, reduce them to a `FieldElement2625x4`.\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[inline]\n    #[rustfmt::skip] // keep alignment of carry chain\n    fn reduce64(mut z: [u64x4; 10]) -> FieldElement2625x4 {\n        // These aren't const because splat isn't a const fn\n        let LOW_25_BITS: u64x4 = u64x4::splat((1 << 25) - 1);\n        let LOW_26_BITS: u64x4 = u64x4::splat((1 << 26) - 1);\n\n        // Carry the value from limb i = 0..8 to limb i+1\n        let carry = |z: &mut [u64x4; 10], i: usize| {\n            debug_assert!(i < 9);\n            if i % 2 == 0 {\n                // Even limbs have 26 bits\n                z[i + 1] += z[i].shr::<26>();\n                z[i] &= LOW_26_BITS;\n            } else {\n                // Odd limbs have 25 bits\n                z[i + 1] += z[i].shr::<25>();\n                z[i] &= LOW_25_BITS;\n            }\n        };\n\n        // Perform two halves of the carry chain in parallel.\n        carry(&mut z, 0); carry(&mut z, 4);\n        carry(&mut z, 1); carry(&mut z, 5);\n        carry(&mut z, 2); carry(&mut z, 6);\n        carry(&mut z, 3); carry(&mut z, 7);\n        // Since z[3] < 2^64, c < 2^(64-25) = 2^39,\n        // so    z[4] < 2^26 + 2^39 < 2^39.0002\n        carry(&mut z, 4); carry(&mut z, 8);\n        // Now z[4] < 2^26\n        // and z[5] < 2^25 + 2^13.0002 < 2^25.0004 (good enough)\n\n        // Last carry has a multiplication by 19.  In the serial case we\n        // do a 64-bit multiplication by 19, but here we want to do a\n        // 32-bit multiplication.  However, if we only know z[9] < 2^64,\n        // the carry is bounded as c < 2^(64-25) = 2^39, which is too\n        // big.  To ensure c < 2^32, we would need z[9] < 2^57.\n        // Instead, we split the carry in two, with c = c_0 + c_1*2^26.\n\n        let c = z[9].shr::<25>();\n        z[9] &= LOW_25_BITS;\n        let mut c0: u64x4 = c & LOW_26_BITS; // c0 < 2^26;\n        let mut c1: u64x4 = c.shr::<26>();         // c1 < 2^(39-26) = 2^13;\n\n        let x19 = u64x4::splat(19);\n        c0 = u32x8::from(c0).mul32(u32x8::from(x19));\n        c1 = u32x8::from(c1).mul32(u32x8::from(x19));\n\n        z[0] += c0; // z0 < 2^26 + 2^30.25 < 2^30.33\n        z[1] += c1; // z1 < 2^25 + 2^17.25 < 2^25.0067\n        carry(&mut z, 0); // z0 < 2^26, z1 < 2^25.0067 + 2^4.33 = 2^25.007\n\n        // The output coefficients are bounded with\n        //\n        // b = 0.007  for z[1]\n        // b = 0.0004 for z[5]\n        // b = 0      for other z[i].\n        //\n        // So the packed result is bounded with b = 0.007.\n        FieldElement2625x4([\n            repack_pair(z[0].into(), z[1].into()),\n            repack_pair(z[2].into(), z[3].into()),\n            repack_pair(z[4].into(), z[5].into()),\n            repack_pair(z[6].into(), z[7].into()),\n            repack_pair(z[8].into(), z[9].into()),\n        ])\n    }\n\n    /// Square this field element, and negate the result's \\\\(D\\\\) value.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 1.5 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[rustfmt::skip] // keep alignment of z* calculations\n    pub fn square_and_negate_D(&self) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let x0_2 = x0.shl::<1>();\n        let x1_2 = x1.shl::<1>();\n        let x2_2 = x2.shl::<1>();\n        let x3_2 = x3.shl::<1>();\n        let x4_2 = x4.shl::<1>();\n        let x5_2 = x5.shl::<1>();\n        let x6_2 = x6.shl::<1>();\n        let x7_2 = x7.shl::<1>();\n\n        let x5_19 = m_lo(v19, x5);\n        let x6_19 = m_lo(v19, x6);\n        let x7_19 = m_lo(v19, x7);\n        let x8_19 = m_lo(v19, x8);\n        let x9_19 = m_lo(v19, x9);\n\n        let mut z0 = m(x0,   x0) + m(x2_2, x8_19) + m(x4_2, x6_19) + ((m(x1_2, x9_19) +   m(x3_2, x7_19) +    m(x5,   x5_19)).shl::<1>());\n        let mut z1 = m(x0_2, x1) + m(x3_2, x8_19) + m(x5_2, x6_19) +                    ((m(x2,   x9_19) +    m(x4,   x7_19)).shl::<1>());\n        let mut z2 = m(x0_2, x2) + m(x1_2,    x1) + m(x4_2, x8_19) +   m(x6,   x6_19) + ((m(x3_2, x9_19) +    m(x5_2, x7_19)).shl::<1>());\n        let mut z3 = m(x0_2, x3) + m(x1_2,    x2) + m(x5_2, x8_19) +                    ((m(x4,   x9_19) +    m(x6,   x7_19)).shl::<1>());\n        let mut z4 = m(x0_2, x4) + m(x1_2,  x3_2) + m(x2,      x2) +   m(x6_2, x8_19) + ((m(x5_2, x9_19) +    m(x7,   x7_19)).shl::<1>());\n        let mut z5 = m(x0_2, x5) + m(x1_2,    x4) + m(x2_2,    x3) +   m(x7_2, x8_19)                    +  ((m(x6,   x9_19)).shl::<1>());\n        let mut z6 = m(x0_2, x6) + m(x1_2,  x5_2) + m(x2_2,    x4) +   m(x3_2,    x3) +   m(x8,   x8_19) +  ((m(x7_2, x9_19)).shl::<1>());\n        let mut z7 = m(x0_2, x7) + m(x1_2,    x6) + m(x2_2,    x5) +   m(x3_2,    x4)                    +  ((m(x8,   x9_19)).shl::<1>());\n        let mut z8 = m(x0_2, x8) + m(x1_2,  x7_2) + m(x2_2,    x6) +   m(x3_2,  x5_2) +   m(x4,      x4) +  ((m(x9,   x9_19)).shl::<1>());\n        let mut z9 = m(x0_2, x9) + m(x1_2,    x8) + m(x2_2,    x7) +   m(x3_2,    x6) +   m(x4_2,    x5)                                 ;\n\n        // The biggest z_i is bounded as z_i < 249*2^(51 + 2*b);\n        // if b < 1.5 we get z_i < 4485585228861014016.\n        //\n        // The limbs of the multiples of p are bounded above by\n        //\n        // 0x3fffffff << 37 = 9223371899415822336 < 2^63\n        //\n        // and below by\n        //\n        // 0x1fffffff << 37 = 4611685880988434432\n        //                  > 4485585228861014016\n        //\n        // So these multiples of p are big enough to avoid underflow\n        // in subtraction, and small enough to fit within u64\n        // with room for a carry.\n\n        let low__p37 = u64x4::splat(0x3ffffed << 37);\n        let even_p37 = u64x4::splat(0x3ffffff << 37);\n        let odd__p37 = u64x4::splat(0x1ffffff << 37);\n\n        let negate_D = |x: u64x4, p: u64x4| -> u64x4 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(x.into(), (p - x).into(), D_LANES64 as i32).into()\n            }\n        };\n\n        z0 = negate_D(z0, low__p37);\n        z1 = negate_D(z1, odd__p37);\n        z2 = negate_D(z2, even_p37);\n        z3 = negate_D(z3, odd__p37);\n        z4 = negate_D(z4, even_p37);\n        z5 = negate_D(z5, odd__p37);\n        z6 = negate_D(z6, even_p37);\n        z7 = negate_D(z7, odd__p37);\n        z8 = negate_D(z8, even_p37);\n        z9 = negate_D(z9, odd__p37);\n\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Neg for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n\n    /// Negate this field element, performing a reduction.\n    ///\n    /// If the coefficients are known to be small, use `negate_lazy`\n    /// to avoid performing a reduction.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 4.0 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.0002 \\\\).\n    #[inline]\n    fn neg(self) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            P_TIMES_16_LO - self.0[0],\n            P_TIMES_16_HI - self.0[1],\n            P_TIMES_16_HI - self.0[2],\n            P_TIMES_16_HI - self.0[3],\n            P_TIMES_16_HI - self.0[4],\n        ])\n        .reduce()\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Add<FieldElement2625x4> for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Add two `FieldElement2625x4`s, without performing a reduction.\n    #[inline]\n    fn add(self, rhs: FieldElement2625x4) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            self.0[0] + rhs.0[0],\n            self.0[1] + rhs.0[1],\n            self.0[2] + rhs.0[2],\n            self.0[3] + rhs.0[3],\n            self.0[4] + rhs.0[4],\n        ])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Mul<(u32, u32, u32, u32)> for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Perform a multiplication by a vector of small constants.\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[inline]\n    fn mul(self, scalars: (u32, u32, u32, u32)) -> FieldElement2625x4 {\n        let consts = u32x8::new(scalars.0, 0, scalars.1, 0, scalars.2, 0, scalars.3, 0);\n\n        let (b0, b1) = unpack_pair(self.0[0]);\n        let (b2, b3) = unpack_pair(self.0[1]);\n        let (b4, b5) = unpack_pair(self.0[2]);\n        let (b6, b7) = unpack_pair(self.0[3]);\n        let (b8, b9) = unpack_pair(self.0[4]);\n\n        FieldElement2625x4::reduce64([\n            b0.mul32(consts),\n            b1.mul32(consts),\n            b2.mul32(consts),\n            b3.mul32(consts),\n            b4.mul32(consts),\n            b5.mul32(consts),\n            b6.mul32(consts),\n            b7.mul32(consts),\n            b8.mul32(consts),\n            b9.mul32(consts),\n        ])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Mul<&FieldElement2625x4> for &FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Multiply `self` by `rhs`.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 2.5 \\\\).\n    ///\n    /// The coefficients of `rhs` must be bounded with \\\\( b < 1.75 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    ///\n    #[rustfmt::skip] // keep alignment of z* calculations\n    #[inline]\n    fn mul(self, rhs: &FieldElement2625x4) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let (y0, y1) = unpack_pair(rhs.0[0]);\n        let (y2, y3) = unpack_pair(rhs.0[1]);\n        let (y4, y5) = unpack_pair(rhs.0[2]);\n        let (y6, y7) = unpack_pair(rhs.0[3]);\n        let (y8, y9) = unpack_pair(rhs.0[4]);\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let y1_19 = m_lo(v19, y1); // This fits in a u32\n        let y2_19 = m_lo(v19, y2); // iff 26 + b + lg(19) < 32\n        let y3_19 = m_lo(v19, y3); // if  b < 32 - 26 - 4.248 = 1.752\n        let y4_19 = m_lo(v19, y4);\n        let y5_19 = m_lo(v19, y5);\n        let y6_19 = m_lo(v19, y6);\n        let y7_19 = m_lo(v19, y7);\n        let y8_19 = m_lo(v19, y8);\n        let y9_19 = m_lo(v19, y9);\n\n        let x1_2 = x1 + x1; // This fits in a u32 iff 25 + b + 1 < 32\n        let x3_2 = x3 + x3; //                    iff b < 6\n        let x5_2 = x5 + x5;\n        let x7_2 = x7 + x7;\n        let x9_2 = x9 + x9;\n\n        let z0 = m(x0, y0) + m(x1_2, y9_19) + m(x2, y8_19) + m(x3_2, y7_19) + m(x4, y6_19) + m(x5_2, y5_19) + m(x6, y4_19) + m(x7_2, y3_19) + m(x8, y2_19) + m(x9_2, y1_19);\n        let z1 = m(x0, y1) + m(x1,      y0) + m(x2, y9_19) + m(x3,   y8_19) + m(x4, y7_19) + m(x5,   y6_19) + m(x6, y5_19) + m(x7,   y4_19) + m(x8, y3_19) + m(x9,   y2_19);\n        let z2 = m(x0, y2) + m(x1_2,    y1) + m(x2,    y0) + m(x3_2, y9_19) + m(x4, y8_19) + m(x5_2, y7_19) + m(x6, y6_19) + m(x7_2, y5_19) + m(x8, y4_19) + m(x9_2, y3_19);\n        let z3 = m(x0, y3) + m(x1,      y2) + m(x2,    y1) + m(x3,      y0) + m(x4, y9_19) + m(x5,   y8_19) + m(x6, y7_19) + m(x7,   y6_19) + m(x8, y5_19) + m(x9,   y4_19);\n        let z4 = m(x0, y4) + m(x1_2,    y3) + m(x2,    y2) + m(x3_2,    y1) + m(x4,    y0) + m(x5_2, y9_19) + m(x6, y8_19) + m(x7_2, y7_19) + m(x8, y6_19) + m(x9_2, y5_19);\n        let z5 = m(x0, y5) + m(x1,      y4) + m(x2,    y3) + m(x3,      y2) + m(x4,    y1) + m(x5,      y0) + m(x6, y9_19) + m(x7,   y8_19) + m(x8, y7_19) + m(x9,   y6_19);\n        let z6 = m(x0, y6) + m(x1_2,    y5) + m(x2,    y4) + m(x3_2,    y3) + m(x4,    y2) + m(x5_2,    y1) + m(x6,    y0) + m(x7_2, y9_19) + m(x8, y8_19) + m(x9_2, y7_19);\n        let z7 = m(x0, y7) + m(x1,      y6) + m(x2,    y5) + m(x3,      y4) + m(x4,    y3) + m(x5,      y2) + m(x6,    y1) + m(x7,      y0) + m(x8, y9_19) + m(x9,   y8_19);\n        let z8 = m(x0, y8) + m(x1_2,    y7) + m(x2,    y6) + m(x3_2,    y5) + m(x4,    y4) + m(x5_2,    y3) + m(x6,    y2) + m(x7_2,    y1) + m(x8,    y0) + m(x9_2, y9_19);\n        let z9 = m(x0, y9) + m(x1,      y8) + m(x2,    y7) + m(x3,      y6) + m(x4,    y5) + m(x5,      y4) + m(x6,    y3) + m(x7,      y2) + m(x8,    y1) + m(x9,      y0);\n\n        // The bounds on z[i] are the same as in the serial 32-bit code\n        // and the comment below is copied from there:\n\n        // How big is the contribution to z[i+j] from x[i], y[j]?\n        //\n        // Using the bounds above, we get:\n        //\n        // i even, j even:   x[i]*y[j] <   2^(26+b)*2^(26+b) = 2*2^(51+2*b)\n        // i  odd, j even:   x[i]*y[j] <   2^(25+b)*2^(26+b) = 1*2^(51+2*b)\n        // i even, j  odd:   x[i]*y[j] <   2^(26+b)*2^(25+b) = 1*2^(51+2*b)\n        // i  odd, j  odd: 2*x[i]*y[j] < 2*2^(25+b)*2^(25+b) = 1*2^(51+2*b)\n        //\n        // We perform inline reduction mod p by replacing 2^255 by 19\n        // (since 2^255 - 19 = 0 mod p).  This adds a factor of 19, so\n        // we get the bounds (z0 is the biggest one, but calculated for\n        // posterity here in case finer estimation is needed later):\n        //\n        //  z0 < ( 2 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 249*2^(51 + 2*b)\n        //  z1 < ( 1 +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 154*2^(51 + 2*b)\n        //  z2 < ( 2 +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 195*2^(51 + 2*b)\n        //  z3 < ( 1 +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 118*2^(51 + 2*b)\n        //  z4 < ( 2 +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 141*2^(51 + 2*b)\n        //  z5 < ( 1 +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) =  82*2^(51 + 2*b)\n        //  z6 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) =  87*2^(51 + 2*b)\n        //  z7 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 )*2^(51 + 2b) =  46*2^(51 + 2*b)\n        //  z8 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 )*2^(51 + 2b) =  33*2^(51 + 2*b)\n        //  z9 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   )*2^(51 + 2b) =  10*2^(51 + 2*b)\n        //\n        // So z[0] fits into a u64 if 51 + 2*b + lg(249) < 64\n        //                         if b < 2.5.\n\n        // In fact this bound is slightly sloppy, since it treats both\n        // inputs x and y as being bounded by the same parameter b,\n        // while they are in fact bounded by b_x and b_y, and we\n        // already require that b_y < 1.75 in order to fit the\n        // multiplications by 19 into a u32.  The tighter bound on b_y\n        // means we could get a tighter bound on the outputs, or a\n        // looser bound on b_x.\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}\n\n#[cfg(target_feature = \"avx2\")]\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn scale_by_curve_constants() {\n        let mut x = FieldElement2625x4::splat(&FieldElement51::ONE);\n\n        x = x * (121666, 121666, 2 * 121666, 2 * 121665);\n\n        let xs = x.split();\n        assert_eq!(xs[0], FieldElement51([121666, 0, 0, 0, 0]));\n        assert_eq!(xs[1], FieldElement51([121666, 0, 0, 0, 0]));\n        assert_eq!(xs[2], FieldElement51([2 * 121666, 0, 0, 0, 0]));\n        assert_eq!(xs[3], FieldElement51([2 * 121665, 0, 0, 0, 0]));\n    }\n\n    #[test]\n    fn diff_sum_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3).diff_sum();\n\n        let result = vec.split();\n\n        assert_eq!(result[0], &x1 - &x0);\n        assert_eq!(result[1], &x1 + &x0);\n        assert_eq!(result[2], &x3 - &x2);\n        assert_eq!(result[3], &x3 + &x2);\n    }\n\n    #[test]\n    fn square_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let result = vec.square_and_negate_D().split();\n\n        assert_eq!(result[0], &x0 * &x0);\n        assert_eq!(result[1], &x1 * &x1);\n        assert_eq!(result[2], &x2 * &x2);\n        assert_eq!(result[3], -&(&x3 * &x3));\n    }\n\n    #[test]\n    fn multiply_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n        let vecprime = vec.clone();\n\n        let result = (&vec * &vecprime).split();\n\n        assert_eq!(result[0], &x0 * &x0);\n        assert_eq!(result[1], &x1 * &x1);\n        assert_eq!(result[2], &x2 * &x2);\n        assert_eq!(result[3], &x3 * &x3);\n    }\n\n    #[test]\n    fn test_unpack_repack_pair() {\n        let x0 = FieldElement51([10000 + (10001 << 26), 0, 0, 0, 0]);\n        let x1 = FieldElement51([10100 + (10101 << 26), 0, 0, 0, 0]);\n        let x2 = FieldElement51([10200 + (10201 << 26), 0, 0, 0, 0]);\n        let x3 = FieldElement51([10300 + (10301 << 26), 0, 0, 0, 0]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let src = vec.0[0];\n\n        let (a, b) = unpack_pair(src);\n\n        let expected_a = u32x8::new(10000, 0, 10100, 0, 10200, 0, 10300, 0);\n        let expected_b = u32x8::new(10001, 0, 10101, 0, 10201, 0, 10301, 0);\n\n        assert_eq!(a, expected_a);\n        assert_eq!(b, expected_b);\n\n        let expected_src = repack_pair(a, b);\n\n        assert_eq!(src, expected_src);\n    }\n\n    #[test]\n    fn new_split_roundtrips() {\n        let x0 = FieldElement51::from_bytes(&[0x10; 32]);\n        let x1 = FieldElement51::from_bytes(&[0x11; 32]);\n        let x2 = FieldElement51::from_bytes(&[0x12; 32]);\n        let x3 = FieldElement51::from_bytes(&[0x13; 32]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let splits = vec.split();\n\n        assert_eq!(x0, splits[0]);\n        assert_eq!(x1, splits[1]);\n        assert_eq!(x2, splits[2]);\n        assert_eq!(x3, splits[3]);\n    }\n}",
    "display_name": "blend",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/unpack",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/pack",
      "5.0.0_pre.0 scalar/impl/backend::serial::u64::scalar::Scalar52/invert"
    ],
    "body": "    pub fn invert(&self) -> Scalar {\n        self.unpack().invert().pack()\n    }",
    "display_name": "invert",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/splat",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn splat(x: u32) -> u32x8 {\n        unsafe { u32x8(core::arch::x86_64::_mm256_set1_epi32(x as i32)) }\n    }",
    "display_name": "splat",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/from_bytes_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes"
    ],
    "body": "    pub(crate) fn from_bytes_wide(bytes: &[u8; 64]) -> Self {\n        let mut fl = [0u8; 32];\n        let mut gl = [0u8; 32];\n        fl.copy_from_slice(&bytes[..32]);\n        gl.copy_from_slice(&bytes[32..]);\n        // Mask off the top bits of both halves, since from_bytes masks them off anyway. We'll add\n        // them back in later.\n        let fl_top_bit = (fl[31] >> 7) as u16;\n        let gl_top_bit = (gl[31] >> 7) as u16;\n        fl[31] &= 0x7f;\n        gl[31] &= 0x7f;\n\n        // Interpret both sides as field elements\n        let mut fe_f = Self::from_bytes(&fl);\n        let fe_g = Self::from_bytes(&gl);\n\n        // The full field elem is now fe_f + 2²⁵⁵ fl_top_bit + 2²⁵⁶ fe_g + 2⁵¹¹ gl_top_bit\n\n        // Add the masked off bits back to fe_f. fl_top_bit, if set, is 2^255 ≡ 19 (mod q).\n        // gl_top_bit, if set, is 2^511 ≡ 722 (mod q)\n        let top_bits_sum = {\n            // This only need to be a u16 because the max value is 741\n            let addend: u16 = fl_top_bit * 19 + gl_top_bit * 722;\n            let mut addend_bytes = [0u8; 32];\n            addend_bytes[..2].copy_from_slice(&addend.to_le_bytes());\n            Self::from_bytes(&addend_bytes)\n        };\n        fe_f += &top_bits_sum;\n\n        // Now add the high half into fe_f. The RHS is multiplied by 2^256 ≡ 38 (mod q)\n        const THIRTY_EIGHT: FieldElement = FieldElement::from_bytes(&[\n            38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        fe_f += &(&THIRTY_EIGHT * &fe_g);\n\n        fe_f\n    }",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/one_way_map",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/from_uniform_bytes",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/compress"
    ],
    "body": "    fn one_way_map() {\n        // These inputs are from\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#appendix-A.3\n        let test_vectors: &[([u8; 64], CompressedRistretto)] = &[\n            (\n                [\n                    0x5d, 0x1b, 0xe0, 0x9e, 0x3d, 0x0c, 0x82, 0xfc, 0x53, 0x81, 0x12, 0x49, 0x0e,\n                    0x35, 0x70, 0x19, 0x79, 0xd9, 0x9e, 0x06, 0xca, 0x3e, 0x2b, 0x5b, 0x54, 0xbf,\n                    0xfe, 0x8b, 0x4d, 0xc7, 0x72, 0xc1, 0x4d, 0x98, 0xb6, 0x96, 0xa1, 0xbb, 0xfb,\n                    0x5c, 0xa3, 0x2c, 0x43, 0x6c, 0xc6, 0x1c, 0x16, 0x56, 0x37, 0x90, 0x30, 0x6c,\n                    0x79, 0xea, 0xca, 0x77, 0x05, 0x66, 0x8b, 0x47, 0xdf, 0xfe, 0x5b, 0xb6,\n                ],\n                CompressedRistretto([\n                    0x30, 0x66, 0xf8, 0x2a, 0x1a, 0x74, 0x7d, 0x45, 0x12, 0x0d, 0x17, 0x40, 0xf1,\n                    0x43, 0x58, 0x53, 0x1a, 0x8f, 0x04, 0xbb, 0xff, 0xe6, 0xa8, 0x19, 0xf8, 0x6d,\n                    0xfe, 0x50, 0xf4, 0x4a, 0x0a, 0x46,\n                ]),\n            ),\n            (\n                [\n                    0xf1, 0x16, 0xb3, 0x4b, 0x8f, 0x17, 0xce, 0xb5, 0x6e, 0x87, 0x32, 0xa6, 0x0d,\n                    0x91, 0x3d, 0xd1, 0x0c, 0xce, 0x47, 0xa6, 0xd5, 0x3b, 0xee, 0x92, 0x04, 0xbe,\n                    0x8b, 0x44, 0xf6, 0x67, 0x8b, 0x27, 0x01, 0x02, 0xa5, 0x69, 0x02, 0xe2, 0x48,\n                    0x8c, 0x46, 0x12, 0x0e, 0x92, 0x76, 0xcf, 0xe5, 0x46, 0x38, 0x28, 0x6b, 0x9e,\n                    0x4b, 0x3c, 0xdb, 0x47, 0x0b, 0x54, 0x2d, 0x46, 0xc2, 0x06, 0x8d, 0x38,\n                ],\n                CompressedRistretto([\n                    0xf2, 0x6e, 0x5b, 0x6f, 0x7d, 0x36, 0x2d, 0x2d, 0x2a, 0x94, 0xc5, 0xd0, 0xe7,\n                    0x60, 0x2c, 0xb4, 0x77, 0x3c, 0x95, 0xa2, 0xe5, 0xc3, 0x1a, 0x64, 0xf1, 0x33,\n                    0x18, 0x9f, 0xa7, 0x6e, 0xd6, 0x1b,\n                ]),\n            ),\n            (\n                [\n                    0x84, 0x22, 0xe1, 0xbb, 0xda, 0xab, 0x52, 0x93, 0x8b, 0x81, 0xfd, 0x60, 0x2e,\n                    0xff, 0xb6, 0xf8, 0x91, 0x10, 0xe1, 0xe5, 0x72, 0x08, 0xad, 0x12, 0xd9, 0xad,\n                    0x76, 0x7e, 0x2e, 0x25, 0x51, 0x0c, 0x27, 0x14, 0x07, 0x75, 0xf9, 0x33, 0x70,\n                    0x88, 0xb9, 0x82, 0xd8, 0x3d, 0x7f, 0xcf, 0x0b, 0x2f, 0xa1, 0xed, 0xff, 0xe5,\n                    0x19, 0x52, 0xcb, 0xe7, 0x36, 0x5e, 0x95, 0xc8, 0x6e, 0xaf, 0x32, 0x5c,\n                ],\n                CompressedRistretto([\n                    0x00, 0x6c, 0xcd, 0x2a, 0x9e, 0x68, 0x67, 0xe6, 0xa2, 0xc5, 0xce, 0xa8, 0x3d,\n                    0x33, 0x02, 0xcc, 0x9d, 0xe1, 0x28, 0xdd, 0x2a, 0x9a, 0x57, 0xdd, 0x8e, 0xe7,\n                    0xb9, 0xd7, 0xff, 0xe0, 0x28, 0x26,\n                ]),\n            ),\n            (\n                [\n                    0xac, 0x22, 0x41, 0x51, 0x29, 0xb6, 0x14, 0x27, 0xbf, 0x46, 0x4e, 0x17, 0xba,\n                    0xee, 0x8d, 0xb6, 0x59, 0x40, 0xc2, 0x33, 0xb9, 0x8a, 0xfc, 0xe8, 0xd1, 0x7c,\n                    0x57, 0xbe, 0xeb, 0x78, 0x76, 0xc2, 0x15, 0x0d, 0x15, 0xaf, 0x1c, 0xb1, 0xfb,\n                    0x82, 0x4b, 0xbd, 0x14, 0x95, 0x5f, 0x2b, 0x57, 0xd0, 0x8d, 0x38, 0x8a, 0xab,\n                    0x43, 0x1a, 0x39, 0x1c, 0xfc, 0x33, 0xd5, 0xba, 0xfb, 0x5d, 0xbb, 0xaf,\n                ],\n                CompressedRistretto([\n                    0xf8, 0xf0, 0xc8, 0x7c, 0xf2, 0x37, 0x95, 0x3c, 0x58, 0x90, 0xae, 0xc3, 0x99,\n                    0x81, 0x69, 0x00, 0x5d, 0xae, 0x3e, 0xca, 0x1f, 0xbb, 0x04, 0x54, 0x8c, 0x63,\n                    0x59, 0x53, 0xc8, 0x17, 0xf9, 0x2a,\n                ]),\n            ),\n            (\n                [\n                    0x16, 0x5d, 0x69, 0x7a, 0x1e, 0xf3, 0xd5, 0xcf, 0x3c, 0x38, 0x56, 0x5b, 0xee,\n                    0xfc, 0xf8, 0x8c, 0x0f, 0x28, 0x2b, 0x8e, 0x7d, 0xbd, 0x28, 0x54, 0x4c, 0x48,\n                    0x34, 0x32, 0xf1, 0xce, 0xc7, 0x67, 0x5d, 0xeb, 0xea, 0x8e, 0xbb, 0x4e, 0x5f,\n                    0xe7, 0xd6, 0xf6, 0xe5, 0xdb, 0x15, 0xf1, 0x55, 0x87, 0xac, 0x4d, 0x4d, 0x4a,\n                    0x1d, 0xe7, 0x19, 0x1e, 0x0c, 0x1c, 0xa6, 0x66, 0x4a, 0xbc, 0xc4, 0x13,\n                ],\n                CompressedRistretto([\n                    0xae, 0x81, 0xe7, 0xde, 0xdf, 0x20, 0xa4, 0x97, 0xe1, 0x0c, 0x30, 0x4a, 0x76,\n                    0x5c, 0x17, 0x67, 0xa4, 0x2d, 0x6e, 0x06, 0x02, 0x97, 0x58, 0xd2, 0xd7, 0xe8,\n                    0xef, 0x7c, 0xc4, 0xc4, 0x11, 0x79,\n                ]),\n            ),\n            (\n                [\n                    0xa8, 0x36, 0xe6, 0xc9, 0xa9, 0xca, 0x9f, 0x1e, 0x8d, 0x48, 0x62, 0x73, 0xad,\n                    0x56, 0xa7, 0x8c, 0x70, 0xcf, 0x18, 0xf0, 0xce, 0x10, 0xab, 0xb1, 0xc7, 0x17,\n                    0x2d, 0xdd, 0x60, 0x5d, 0x7f, 0xd2, 0x97, 0x98, 0x54, 0xf4, 0x7a, 0xe1, 0xcc,\n                    0xf2, 0x04, 0xa3, 0x31, 0x02, 0x09, 0x5b, 0x42, 0x00, 0xe5, 0xbe, 0xfc, 0x04,\n                    0x65, 0xac, 0xcc, 0x26, 0x31, 0x75, 0x48, 0x5f, 0x0e, 0x17, 0xea, 0x5c,\n                ],\n                CompressedRistretto([\n                    0xe2, 0x70, 0x56, 0x52, 0xff, 0x9f, 0x5e, 0x44, 0xd3, 0xe8, 0x41, 0xbf, 0x1c,\n                    0x25, 0x1c, 0xf7, 0xdd, 0xdb, 0x77, 0xd1, 0x40, 0x87, 0x0d, 0x1a, 0xb2, 0xed,\n                    0x64, 0xf1, 0xa9, 0xce, 0x86, 0x28,\n                ]),\n            ),\n            (\n                [\n                    0x2c, 0xdc, 0x11, 0xea, 0xeb, 0x95, 0xda, 0xf0, 0x11, 0x89, 0x41, 0x7c, 0xdd,\n                    0xdb, 0xf9, 0x59, 0x52, 0x99, 0x3a, 0xa9, 0xcb, 0x9c, 0x64, 0x0e, 0xb5, 0x05,\n                    0x8d, 0x09, 0x70, 0x2c, 0x74, 0x62, 0x2c, 0x99, 0x65, 0xa6, 0x97, 0xa3, 0xb3,\n                    0x45, 0xec, 0x24, 0xee, 0x56, 0x33, 0x5b, 0x55, 0x6e, 0x67, 0x7b, 0x30, 0xe6,\n                    0xf9, 0x0a, 0xc7, 0x7d, 0x78, 0x10, 0x64, 0xf8, 0x66, 0xa3, 0xc9, 0x82,\n                ],\n                CompressedRistretto([\n                    0x80, 0xbd, 0x07, 0x26, 0x25, 0x11, 0xcd, 0xde, 0x48, 0x63, 0xf8, 0xa7, 0x43,\n                    0x4c, 0xef, 0x69, 0x67, 0x50, 0x68, 0x1c, 0xb9, 0x51, 0x0e, 0xea, 0x55, 0x70,\n                    0x88, 0xf7, 0x6d, 0x9e, 0x50, 0x65,\n                ]),\n            ),\n            (\n                [\n                    0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n        ];\n        // Check that onewaymap(input) == output for all the above vectors\n        for (input, output) in test_vectors {\n            let Q = RistrettoPoint::from_uniform_bytes(input);\n            assert_eq!(&Q.compress(), output);\n        }\n    }",
    "display_name": "one_way_map",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 impl/SpecializeArg/lit",
    "statement_type": "function",
    "deps": [],
    "body": "    fn lit(&self) -> &syn::LitStr {\n        match self {\n            SpecializeArg::LitStr(lit) => lit,\n            SpecializeArg::Conditional(conditional) => &conditional.lit,\n        }\n    }",
    "display_name": "lit",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/AffinePoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/affine/impl/AffinePoint/Identity/identity"
    ],
    "body": "    fn default() -> AffinePoint {\n        AffinePoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/partial_precomputed_multiscalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/random",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity"
    ],
    "body": "    fn partial_precomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use one fewer scalars\n        let static_scalars = (0..n_static - 1)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_multiscalar_mul(&static_scalars);\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }",
    "display_name": "partial_precomputed_multiscalar",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/impl/VartimePrecomputedStraus/new"
    ],
    "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(\n            static_points.into_iter().map(|P| P.borrow().0),\n        ))\n    }",
    "display_name": "new",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/impl/PublicKey/as_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/as_bytes"
    ],
    "body": "    pub fn as_bytes(&self) -> &[u8; 32] {\n        self.0.as_bytes()\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3118/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsPoint/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/straus_optional_multiscalar_mul",
      "5.0.0_pre.0 backend/pippenger_optional_multiscalar_mul"
    ],
    "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.\n        // Use this as the hint to decide which algorithm to use.\n        let size = s_lo;\n\n        if size < 190 {\n            crate::backend::straus_optional_multiscalar_mul(scalars, points)\n        } else {\n            crate::backend::pippenger_optional_multiscalar_mul(scalars, points)\n        }\n    }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/mul_bits_be",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/impl/ProjectivePoint/as_affine",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 montgomery/impl/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 montgomery/differential_add_and_double"
    ],
    "body": "    pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2\n        let mut prev_bit = false;\n        for cur_bit in bits {\n            let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        #[cfg(feature = \"zeroize\")]\n        prev_bit.zeroize();\n\n        x0.as_affine()\n    }",
    "display_name": "mul_bits_be",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/impl_add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn impl_add() {\n        let two = Scalar::from(2u64);\n        let one = Scalar::ONE;\n        let should_be_two = one + one;\n        assert_eq!(should_be_two, two);\n    }",
    "display_name": "impl_add",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 bytes_from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "fn bytes_from_hex<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    let mut hex_str = String::deserialize(deserializer)?;\n    // Prepend a 0 if it's not even length\n    if hex_str.len() % 2 == 1 {\n        hex_str.insert(0, '0');\n    }\n    hex::decode(hex_str).map_err(|e| SError::custom(format!(\"{:?}\", e)))\n}",
    "display_name": "bytes_from_hex",
    "full_path": "file:///work/3118/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_tables",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix128/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix32/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix64/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix256/BasepointTable/create",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTable/BasepointTable/create"
    ],
    "body": "    fn basepoint_tables() {\n        let P = &constants::ED25519_BASEPOINT_POINT;\n        let a = A_SCALAR;\n\n        let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n        let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n        let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n        let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n        let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n        let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n        let aP16 = (&table_radix16 * &a).compress();\n        let aP32 = (&table_radix32 * &a).compress();\n        let aP64 = (&table_radix64 * &a).compress();\n        let aP128 = (&table_radix128 * &a).compress();\n        let aP256 = (&table_radix256 * &a).compress();\n\n        assert_eq!(aP, aP16);\n        assert_eq!(aP16, aP32);\n        assert_eq!(aP32, aP64);\n        assert_eq!(aP64, aP128);\n        assert_eq!(aP128, aP256);\n    }",
    "display_name": "basepoint_tables",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/Product/product",
    "statement_type": "function",
    "deps": [],
    "body": "    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }",
    "display_name": "product",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/shuffle",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn shuffle(&self, control: Shuffle) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn shuffle_lanes(x: u32x8, control: Shuffle) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_permutevar8x32_epi32;\n\n                let c: u32x8 = match control {\n                    Shuffle::AAAA => u32x8::new(0, 0, 2, 2, 0, 0, 2, 2),\n                    Shuffle::BBBB => u32x8::new(1, 1, 3, 3, 1, 1, 3, 3),\n                    Shuffle::CACA => u32x8::new(4, 0, 6, 2, 4, 0, 6, 2),\n                    Shuffle::DBBD => u32x8::new(5, 1, 7, 3, 1, 5, 3, 7),\n                    Shuffle::ADDA => u32x8::new(0, 5, 2, 7, 5, 0, 7, 2),\n                    Shuffle::CBCB => u32x8::new(4, 1, 6, 3, 4, 1, 6, 3),\n                    Shuffle::ABAB => u32x8::new(0, 1, 2, 3, 0, 1, 2, 3),\n                    Shuffle::BADC => u32x8::new(1, 0, 3, 2, 5, 4, 7, 6),\n                    Shuffle::BACD => u32x8::new(1, 0, 3, 2, 4, 5, 6, 7),\n                    Shuffle::ABDC => u32x8::new(0, 1, 2, 3, 5, 4, 7, 6),\n                };\n                // Note that this gets turned into a generic LLVM\n                // shuffle-by-constants, which can be lowered to a simpler\n                // instruction than a generic permute.\n                _mm256_permutevar8x32_epi32(x.into(), c.into()).into()\n            }\n        }\n\n        FieldElement2625x4([\n            shuffle_lanes(self.0[0], control),\n            shuffle_lanes(self.0[1], control),\n            shuffle_lanes(self.0[2], control),\n            shuffle_lanes(self.0[3], control),\n            shuffle_lanes(self.0[4], control),\n        ])\n    }",
    "display_name": "shuffle",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/a_mul_a_vs_a_squared_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes"
    ],
    "body": "    fn a_mul_a_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(asq, &a * &a);\n    }",
    "display_name": "a_mul_a_vs_a_squared_constant",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/BasepointTable/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3118/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/AffineNielsPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"AffineNielsPoint{{\\n\\ty_plus_x: {:?},\\n\\ty_minus_x: {:?},\\n\\txy2d: {:?}\\n}}\",\n            &self.y_plus_x, &self.y_minus_x, &self.xy2d\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/random",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        let mut scalar_bytes = [0u8; 64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }",
    "display_name": "random",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/unpack_pair",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/splat"
    ],
    "body": "fn unpack_pair(src: u32x8) -> (u32x8, u32x8) {\n    let a: u32x8;\n    let b: u32x8;\n    let zero = u32x8::splat(0);\n    unsafe {\n        use core::arch::x86_64::_mm256_unpackhi_epi32;\n        use core::arch::x86_64::_mm256_unpacklo_epi32;\n        a = _mm256_unpacklo_epi32(src.into(), zero.into()).into();\n        b = _mm256_unpackhi_epi32(src.into(), zero.into()).into();\n    }\n    (a, b)\n}",
    "display_name": "unpack_pair",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/Identity/identity"
    ],
    "body": "    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/hash_to_field",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/from_bytes_wide"
    ],
    "body": "    pub fn hash_to_field<D>(bytes: &[&[u8]], domain_sep: &[&[u8]]) -> Self\n    where\n        D: BlockSizeUser + Default + FixedOutput<OutputSize = U64> + HashMarker,\n        D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    {\n        let l_i_b_str = 48u16.to_be_bytes();\n        let z_pad = Array::<u8, D::BlockSize>::default();\n\n        let mut hasher = D::new().chain_update(z_pad);\n\n        for slice in bytes {\n            hasher = hasher.chain_update(slice);\n        }\n\n        hasher = hasher.chain_update(l_i_b_str).chain_update([0u8]);\n\n        let mut domain_sep_len = 0usize;\n        for slice in domain_sep {\n            hasher = hasher.chain_update(slice);\n            domain_sep_len += slice.len();\n        }\n\n        let domain_sep_len = u8::try_from(domain_sep_len)\n            .expect(\"Unexpected overflow from domain separator's size.\");\n        assert_ne!(\n            domain_sep_len, 0,\n            \"Domain separator MUST have nonzero length.\"\n        );\n\n        let b_0 = hasher.chain_update([domain_sep_len]).finalize();\n\n        let mut hasher = D::new().chain_update(b_0.as_slice()).chain_update([1u8]);\n\n        for slice in domain_sep {\n            hasher = hasher.chain_update(slice)\n        }\n\n        let b_1 = hasher.chain_update([domain_sep_len]).finalize();\n\n        // §5.2, we only generate count * m * L = 1 * 1 * (256 + 128)/8 = 48 bytes\n        let mut bytes_wide = [0u8; 64];\n        bytes_wide[..48].copy_from_slice(&b_1.as_slice()[..48]);\n        bytes_wide[..48].reverse();\n\n        FieldElement::from_bytes_wide(&bytes_wide)\n    }",
    "display_name": "hash_to_field",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/from_slice"
    ],
    "body": "    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsBasepointTableRadix64/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 test_sse2_only",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_sse2_only() {}\n",
    "display_name": "test_sse2_only",
    "full_path": "file:///work/3118/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/VerifyingKey/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn from(point: EdwardsPoint) -> VerifyingKey {\n        VerifyingKey {\n            point,\n            compressed: point.compress(),\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/straus/spec/impl/Straus/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/Identity/identity",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/NafLookupTable5/From/from",
      "5.0.0_pre.0 backend/vector/avx2/edwards/impl/ExtendedPoint/double"
    ],
    "body": "        fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let nafs: Vec<_> = scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect();\n            let lookup_tables: Vec<_> = points\n                .into_iter()\n                .map(|P_opt| P_opt.map(|P| NafLookupTable5::<CachedPoint>::from(&P)))\n                .collect::<Option<Vec<_>>>()?;\n\n            let mut Q = ExtendedPoint::identity();\n\n            for i in (0..256).rev() {\n                Q = Q.double();\n\n                for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                    match naf[i].cmp(&0) {\n                        Ordering::Greater => {\n                            Q = &Q + &lookup_table.select(naf[i] as usize);\n                        }\n                        Ordering::Less => {\n                            Q = &Q - &lookup_table.select(-naf[i] as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n            }\n\n            Some(Q.into())\n        }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/neg_twice_is_identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg_twice_is_identity() {\n        let negative_X = -&X;\n        let should_be_X = -&negative_X;\n\n        assert_eq!(should_be_X, X);\n    }",
    "display_name": "neg_twice_is_identity",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/batch_invert_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/batch_invert"
    ],
    "body": "    fn batch_invert_empty() {\n        assert_eq!(Scalar::ONE, Scalar::batch_invert(&mut []));\n    }",
    "display_name": "batch_invert_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/from_bytes_wide",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes_wide(bytes: &[u8; 64]) -> Scalar52 {\n        // TODO; just signature for now\n        Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] }\n    }",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/avx2/field/impl/FieldElement2625x4/reduce64",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vector/avx2/field/repack_pair",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u32x8/mul32",
      "5.0.0_pre.0 backend/vector/packed_simd/impl/u64x4/splat"
    ],
    "body": "    fn reduce64(mut z: [u64x4; 10]) -> FieldElement2625x4 {\n        // These aren't const because splat isn't a const fn\n        let LOW_25_BITS: u64x4 = u64x4::splat((1 << 25) - 1);\n        let LOW_26_BITS: u64x4 = u64x4::splat((1 << 26) - 1);\n\n        // Carry the value from limb i = 0..8 to limb i+1\n        let carry = |z: &mut [u64x4; 10], i: usize| {\n            debug_assert!(i < 9);\n            if i % 2 == 0 {\n                // Even limbs have 26 bits\n                z[i + 1] += z[i].shr::<26>();\n                z[i] &= LOW_26_BITS;\n            } else {\n                // Odd limbs have 25 bits\n                z[i + 1] += z[i].shr::<25>();\n                z[i] &= LOW_25_BITS;\n            }\n        };\n\n        // Perform two halves of the carry chain in parallel.\n        carry(&mut z, 0); carry(&mut z, 4);\n        carry(&mut z, 1); carry(&mut z, 5);\n        carry(&mut z, 2); carry(&mut z, 6);\n        carry(&mut z, 3); carry(&mut z, 7);\n        // Since z[3] < 2^64, c < 2^(64-25) = 2^39,\n        // so    z[4] < 2^26 + 2^39 < 2^39.0002\n        carry(&mut z, 4); carry(&mut z, 8);\n        // Now z[4] < 2^26\n        // and z[5] < 2^25 + 2^13.0002 < 2^25.0004 (good enough)\n\n        // Last carry has a multiplication by 19.  In the serial case we\n        // do a 64-bit multiplication by 19, but here we want to do a\n        // 32-bit multiplication.  However, if we only know z[9] < 2^64,\n        // the carry is bounded as c < 2^(64-25) = 2^39, which is too\n        // big.  To ensure c < 2^32, we would need z[9] < 2^57.\n        // Instead, we split the carry in two, with c = c_0 + c_1*2^26.\n\n        let c = z[9].shr::<25>();\n        z[9] &= LOW_25_BITS;\n        let mut c0: u64x4 = c & LOW_26_BITS; // c0 < 2^26;\n        let mut c1: u64x4 = c.shr::<26>();         // c1 < 2^(39-26) = 2^13;\n\n        let x19 = u64x4::splat(19);\n        c0 = u32x8::from(c0).mul32(u32x8::from(x19));\n        c1 = u32x8::from(c1).mul32(u32x8::from(x19));\n\n        z[0] += c0; // z0 < 2^26 + 2^30.25 < 2^30.33\n        z[1] += c1; // z1 < 2^25 + 2^17.25 < 2^25.0067\n        carry(&mut z, 0); // z0 < 2^26, z1 < 2^25.0067 + 2^4.33 = 2^25.007\n\n        // The output coefficients are bounded with\n        //\n        // b = 0.007  for z[1]\n        // b = 0.0004 for z[5]\n        // b = 0      for other z[i].\n        //\n        // So the packed result is bounded with b = 0.007.\n        FieldElement2625x4([\n            repack_pair(z[0].into(), z[1].into()),\n            repack_pair(z[2].into(), z[3].into()),\n            repack_pair(z[4].into(), z[5].into()),\n            repack_pair(z[6].into(), z[7].into()),\n            repack_pair(z[8].into(), z[9].into()),\n        ])\n    }",
    "display_name": "reduce64",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/multiscalar_consistency_n_1000",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/test/multiscalar_consistency_iter"
    ],
    "body": "    fn multiscalar_consistency_n_1000() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(1000);\n        }\n    }",
    "display_name": "multiscalar_consistency_n_1000",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_reduce",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/m",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_part2",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/sub",
      "5.0.0_pre.0 backend/serial/u64/scalar_verus/impl/Scalar52/montgomery_part1"
    ],
    "body": "    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    ensures\n        // TODO: Add proper specification for Montgomery reduction\n        true,\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        // First half: compute Montgomery adjustment factor n and add n*L to make limbs divisible by R\n        let (carry, n0) = Scalar52::montgomery_part1(limbs[0]);\n        let (carry, n1) = Scalar52::montgomery_part1(carry + limbs[1] + m(n0, L.limbs[1]));\n        let (carry, n2) = Scalar52::montgomery_part1(carry + limbs[2] + m(n0, L.limbs[2]) + m(n1, L.limbs[1]));\n        let (carry, n3) = Scalar52::montgomery_part1(carry + limbs[3] + m(n1, L.limbs[2]) + m(n2, L.limbs[1]));\n        let (carry, n4) = Scalar52::montgomery_part1(carry + limbs[4] + m(n0, L.limbs[4]) + m(n2, L.limbs[2]) + m(n3, L.limbs[1]));\n\n        // Second half: limbs is now divisible by R, so divide by R by taking upper half\n        let (carry, r0) = Scalar52::montgomery_part2(carry + limbs[5] + m(n1, L.limbs[4]) + m(n3, L.limbs[2]) + m(n4, L.limbs[1]));\n        let (carry, r1) = Scalar52::montgomery_part2(carry + limbs[6] + m(n2, L.limbs[4]) + m(n4, L.limbs[2]));\n        let (carry, r2) = Scalar52::montgomery_part2(carry + limbs[7] + m(n3, L.limbs[4]));\n        let (carry, r3) = Scalar52::montgomery_part2(carry + limbs[8] + m(n4, L.limbs[4]));\n        let r4 = carry as u64;\n\n        // Result may be >= L, so attempt to subtract L\n        let result = Scalar52 { limbs: [r0, r1, r2, r3, r4] };\n        Scalar52::sub(&result, &L)\n    }",
    "display_name": "montgomery_reduce",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_verus.rs",
    "file_name": "scalar_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vector/scalar_mul/pippenger/spec/test/test_vartime_pippenger",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/invert",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul"
    ],
    "body": "        fn test_vartime_pippenger() {\n            use super::*;\n            use crate::constants;\n            use crate::scalar::Scalar;\n\n            // Reuse points across different tests\n            let mut n = 512;\n            let x = Scalar::from(2128506u64).invert();\n            let y = Scalar::from(4443282u64).invert();\n            let points: Vec<_> = (0..n)\n                .map(|i| constants::ED25519_BASEPOINT_POINT * Scalar::from(1 + i as u64))\n                .collect();\n            let scalars: Vec<_> = (0..n)\n                .map(|i| x + (Scalar::from(i as u64) * y)) // fast way to make ~random but deterministic scalars\n                .collect();\n\n            let premultiplied: Vec<EdwardsPoint> = scalars\n                .iter()\n                .zip(points.iter())\n                .map(|(sc, pt)| sc * pt)\n                .collect();\n\n            while n > 0 {\n                let scalars = &scalars[0..n].to_vec();\n                let points = &points[0..n].to_vec();\n                let control: EdwardsPoint = premultiplied[0..n].iter().sum();\n\n                let subject = Pippenger::vartime_multiscalar_mul(scalars.clone(), points.clone());\n\n                assert_eq!(subject.compress(), control.compress());\n\n                n = n / 2;\n            }\n        }",
    "display_name": "test_vartime_pippenger",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/impl_sum",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let BASE = constants::ED25519_BASEPOINT_POINT;\n\n        let s1 = Scalar::from(999u64);\n        let P1 = BASE * s1;\n\n        let s2 = Scalar::from(333u64);\n        let P2 = BASE * s2;\n\n        let vec = vec![P1, P2];\n        let sum: EdwardsPoint = vec.iter().sum();\n\n        assert_eq!(sum, P1 + P2);\n\n        // Test that sum works for the empty iterator\n        let empty_vector: Vec<EdwardsPoint> = vec![];\n        let sum: EdwardsPoint = empty_vector.iter().sum();\n\n        assert_eq!(sum, EdwardsPoint::identity());\n\n        // Test that sum works on owning iterators\n        let s = Scalar::from(2u64);\n        let mapped = vec.iter().map(|x| x * s);\n        let sum: EdwardsPoint = mapped.sum();\n\n        assert_eq!(sum, P1 * s + P2 * s);\n    }",
    "display_name": "impl_sum",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/a_square_vs_a_squared_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/square",
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/from_bytes"
    ],
    "body": "    fn a_square_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(asq, a.square());\n    }",
    "display_name": "a_square_vs_a_squared_constant",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_table_basepoint_function_correct",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/EdwardsBasepointTable/BasepointTable/basepoint"
    ],
    "body": "    fn basepoint_table_basepoint_function_correct() {\n        let bp = ED25519_BASEPOINT_TABLE.basepoint();\n        assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n    }",
    "display_name": "basepoint_table_basepoint_function_correct",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/basepoint_plus_basepoint_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_plus_basepoint_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_added = bp + bp;\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }",
    "display_name": "basepoint_plus_basepoint_vs_basepoint2",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/vartime/multiscalar_mul_vartime_vs_consttime",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/decompress",
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/MultiscalarMul/multiscalar_mul"
    ],
    "body": "        fn multiscalar_mul_vartime_vs_consttime() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result_vartime = EdwardsPoint::vartime_multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n            let result_consttime = EdwardsPoint::multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n\n            assert_eq!(result_vartime.compress(), result_consttime.compress());\n        }",
    "display_name": "multiscalar_mul_vartime_vs_consttime",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/impl/&Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, point: &MontgomeryPoint) -> MontgomeryPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/impl/EdwardsPoint/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(vk: VerifyingKey) -> EdwardsPoint {\n        vk.point\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/impl/RistrettoPoint/vartime_double_scalar_mul_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/vartime_double_scalar_mul_basepoint"
    ],
    "body": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &RistrettoPoint,\n        b: &Scalar,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::vartime_double_scalar_mul_basepoint(\n            a, &A.0, b,\n        ))\n    }",
    "display_name": "vartime_double_scalar_mul_basepoint",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/test/basepoint_edwards_to_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/EdwardsPoint/to_montgomery"
    ],
    "body": "    fn basepoint_edwards_to_montgomery() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT.to_montgomery(),\n            constants::X25519_BASEPOINT\n        );\n    }",
    "display_name": "basepoint_edwards_to_montgomery",
    "full_path": "file:///work/3118/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(x: u16) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/impl_product",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn impl_product() {\n        // Test that product works for non-empty iterators\n        let X_Y_vector = [X, Y];\n        let should_be_X_times_Y: Scalar = X_Y_vector.iter().product();\n        assert_eq!(should_be_X_times_Y, X_TIMES_Y);\n\n        // Test that product works for the empty iterator\n        let one = Scalar::ONE;\n        let empty_vector = [];\n        let should_be_one: Scalar = empty_vector.iter().product();\n        assert_eq!(should_be_one, one);\n\n        // Test that product works for iterators where Item = Scalar\n        let xs = [Scalar::from(2u64); 10];\n        let ys = [Scalar::from(3u64); 10];\n        // now zs is an iterator with Item = Scalar\n        let zs = xs.iter().zip(ys.iter()).map(|(x, y)| x * y);\n\n        let x_prod: Scalar = xs.iter().product();\n        let y_prod: Scalar = ys.iter().product();\n        let z_prod: Scalar = zs.product();\n\n        assert_eq!(x_prod, Scalar::from(1024u64));\n        assert_eq!(y_prod, Scalar::from(59049u64));\n        assert_eq!(z_prod, Scalar::from(60466176u64));\n        assert_eq!(x_prod * y_prod, z_prod);\n    }",
    "display_name": "impl_product",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/test_pippenger_radix",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/invert",
      "5.0.0_pre.0 scalar/test/test_pippenger_radix_iter",
      "5.0.0_pre.0 scalar/impl/Scalar/From/from"
    ],
    "body": "    fn test_pippenger_radix() {\n        use core::iter;\n        // For each valid radix it tests that 1000 random-ish scalars can be restored\n        // from the produced representation precisely.\n        let cases = (2..100)\n            .map(|s| Scalar::from(s as u64).invert())\n            // The largest unreduced scalar, s = 2^255-1. This is not reduced mod l. Scalar mult\n            // still works though.\n            .chain(iter::once(LARGEST_UNREDUCED_SCALAR));\n\n        for scalar in cases {\n            test_pippenger_radix_iter(scalar, 6);\n            test_pippenger_radix_iter(scalar, 7);\n            test_pippenger_radix_iter(scalar, 8);\n        }\n    }",
    "display_name": "test_pippenger_radix",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/test/batch_invert_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/impl/backend::serial::u64::field::FieldElement51/batch_invert"
    ],
    "body": "    fn batch_invert_empty() {\n        FieldElement::batch_invert(&mut []);\n    }",
    "display_name": "batch_invert_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/as_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/montgomery_mul"
    ],
    "body": "    pub fn as_montgomery(&self) -> Scalar52 {\n        Scalar52::montgomery_mul(self, &constants::RR)\n    }",
    "display_name": "as_montgomery",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 impl/Conditional/Parse/parse",
    "statement_type": "function",
    "deps": [],
    "body": "    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        let lit = input.parse()?;\n        input.parse::<syn::Token![,]>()?;\n        let attr = input.parse()?;\n\n        Ok(Conditional { lit, attr })\n    }",
    "display_name": "parse",
    "full_path": "file:///work/3118/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/verify_batch_signatures",
    "statement_type": "function",
    "deps": [],
    "body": "    fn verify_batch_signatures(_: &mut Criterion) {}\n",
    "display_name": "verify_batch_signatures",
    "full_path": "file:///work/3118/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/u64/scalar/test/mul_max",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/scalar/impl/Scalar52/mul"
    ],
    "body": "    fn mul_max() {\n        let res = Scalar52::mul(&X, &X);\n        for i in 0..5 {\n            assert!(res[i] == XX[i]);\n        }\n    }",
    "display_name": "mul_max",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/affine/impl/AffinePoint/to_edwards",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_edwards(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T: &self.x * &self.y,\n        }\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/impl/Scalar/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/fuzzer_testcase_reduction",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order",
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    fn fuzzer_testcase_reduction() {\n        // LE bytes of 24519928653854221733733552434404946937899825954937634815\n        let a_bytes = [\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n            255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        // LE bytes of 4975441334397345751130612518500927154628011511324180036903450236863266160640\n        let b_bytes = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 210, 210,\n            210, 255, 255, 255, 255, 10,\n        ];\n        // LE bytes of 6432735165214683820902750800207468552549813371247423777071615116673864412038\n        let c_bytes = [\n            134, 171, 119, 216, 180, 128, 178, 62, 171, 132, 32, 62, 34, 119, 104, 193, 47, 215,\n            181, 250, 14, 207, 172, 93, 75, 207, 211, 103, 144, 204, 56, 14,\n        ];\n\n        let a = Scalar::from_bytes_mod_order(a_bytes);\n        let b = Scalar::from_bytes_mod_order(b_bytes);\n        let c = Scalar::from_bytes_mod_order(c_bytes);\n\n        let mut tmp = [0u8; 64];\n\n        // also_a = (a mod l)\n        tmp[0..32].copy_from_slice(&a_bytes[..]);\n        let also_a = Scalar::from_bytes_mod_order_wide(&tmp);\n\n        // also_b = (b mod l)\n        tmp[0..32].copy_from_slice(&b_bytes[..]);\n        let also_b = Scalar::from_bytes_mod_order_wide(&tmp);\n\n        let expected_c = a * b;\n        let also_expected_c = also_a * also_b;\n\n        assert_eq!(c, expected_c);\n        assert_eq!(c, also_expected_c);\n    }",
    "display_name": "fuzzer_testcase_reduction",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/serial/curve_models/impl/ProjectiveNielsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/serial/u64/field/impl/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3118/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_to_x25519_dh",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/impl/SigningKey/to_scalar_bytes",
      "3.0.0_pre.0 x25519/impl/PublicKey/From/from",
      "3.0.0_pre.0 signing/impl/SigningKey/from_bytes",
      "3.0.0_pre.0 x25519/impl/StaticSecret/diffie_hellman",
      "3.0.0_pre.0 x25519/impl/SharedSecret/to_bytes",
      "3.0.0_pre.0 x25519/impl/PublicKey/as_bytes",
      "5.0.0_pre.0 scalar/impl/Scalar/from_bytes_mod_order",
      "3.0.0_pre.0 x25519/impl/PublicKey/to_bytes",
      "5.0.0_pre.0 montgomery/impl/MontgomeryPoint/as_bytes",
      "5.0.0_pre.0 scalar/clamp_integer",
      "3.0.0_pre.0 verifying/impl/VerifyingKey/to_montgomery",
      "3.0.0_pre.0 signing/impl/SigningKey/to_scalar",
      "3.0.0_pre.0 x25519/impl/StaticSecret/From/from",
      "3.0.0_pre.0 signing/impl/SigningKey/verifying_key"
    ],
    "body": "fn ed25519_to_x25519_dh() {\n    // Keys from RFC8032 test vectors (from section 7.1)\n    let ed_secret_key_a = hex!(\"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60\");\n    let ed_secret_key_b = hex!(\"4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb\");\n\n    let ed_signing_key_a = SigningKey::from_bytes(&ed_secret_key_a);\n    let ed_signing_key_b = SigningKey::from_bytes(&ed_secret_key_b);\n\n    // Create an x25519 static secret from the ed25519 signing key\n    let scalar_bytes_a = ed_signing_key_a.to_scalar_bytes();\n    let scalar_bytes_b = ed_signing_key_b.to_scalar_bytes();\n    let x_static_secret_a = XStaticSecret::from(scalar_bytes_a);\n    let x_static_secret_b = XStaticSecret::from(scalar_bytes_b);\n\n    // Compute the secret scalars too\n    let scalar_a = ed_signing_key_a.to_scalar();\n    let scalar_b = ed_signing_key_b.to_scalar();\n\n    // Compare the scalar bytes to the first 32 bytes of SHA-512(secret_key). We have to clamp and\n    // reduce the SHA-512 output because that's what the spec does before using the scalars for\n    // anything.\n    assert_eq!(scalar_bytes_a, &Sha512::digest(ed_secret_key_a)[..32]);\n    assert_eq!(scalar_bytes_b, &Sha512::digest(ed_secret_key_b)[..32]);\n\n    // Compare the scalar with the clamped and reduced scalar bytes\n    assert_eq!(\n        scalar_a,\n        Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes_a))\n    );\n    assert_eq!(\n        scalar_b,\n        Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes_b))\n    );\n\n    let x_public_key_a = XPublicKey::from(&x_static_secret_a);\n    let x_public_key_b = XPublicKey::from(&x_static_secret_b);\n    assert_eq!(\n        x_public_key_a.to_bytes(),\n        hex!(\"d85e07ec22b0ad881537c2f44d662d1a143cf830c57aca4305d85c7a90f6b62e\")\n    );\n    assert_eq!(\n        x_public_key_b.to_bytes(),\n        hex!(\"25c704c594b88afc00a76b69d1ed2b984d7e22550f3ed0802d04fbcd07d38d47\")\n    );\n\n    // Test the claim made in the comments of SigningKey::to_scalar_bytes, i.e., that the resulting\n    // scalar is a valid private key for the x25519 pubkey represented by\n    // `sk.verifying_key().to_montgomery()`\n    assert_eq!(\n        ed_signing_key_a.verifying_key().to_montgomery().as_bytes(),\n        x_public_key_a.as_bytes()\n    );\n    assert_eq!(\n        ed_signing_key_b.verifying_key().to_montgomery().as_bytes(),\n        x_public_key_b.as_bytes()\n    );\n\n    // Check that Diffie-Hellman works\n    let expected_shared_secret =\n        hex!(\"5166f24a6918368e2af831a4affadd97af0ac326bdf143596c045967cc00230e\");\n    assert_eq!(\n        x_static_secret_a.diffie_hellman(&x_public_key_b).to_bytes(),\n        expected_shared_secret,\n    );\n    assert_eq!(\n        x_static_secret_b.diffie_hellman(&x_public_key_a).to_bytes(),\n        expected_shared_secret,\n    );\n}",
    "display_name": "ed25519_to_x25519_dh",
    "full_path": "file:///work/3118/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/impl/CompressedEdwardsY/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/test/partial_precomputed_mixed_multiscalar_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/random",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/Identity/identity",
      "5.0.0_pre.0 ristretto/impl/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 ristretto/impl/RistrettoPoint/random"
    ],
    "body": "    fn partial_precomputed_mixed_multiscalar_empty() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n        let n_dynamic = 8;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use zero scalars\n        let static_scalars = Vec::new();\n\n        let dynamic_points = (0..n_dynamic)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..n_dynamic)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n        for i in 0..n_dynamic {\n            result_manual += dynamic_points[i] * dynamic_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }",
    "display_name": "partial_precomputed_mixed_multiscalar_empty",
    "full_path": "file:///work/3118/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/impl/EdwardsBasepointTable/BasepointTable/basepoint",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "basepoint",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/test/canonical_decoding",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/impl/Scalar/from_canonical_bytes"
    ],
    "body": "    fn canonical_decoding() {\n        // canonical encoding of 1667457891\n        let canonical_bytes = [\n            99, 99, 99, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0,\n        ];\n\n        // encoding of\n        //   7265385991361016183439748078976496179028704920197054998554201349516117938192\n        // = 28380414028753969466561515933501938171588560817147392552250411230663687203 (mod l)\n        // non_canonical because unreduced mod l\n        let non_canonical_bytes_because_unreduced = [16; 32];\n\n        // encoding with high bit set, to check that the parser isn't pre-masking the high bit\n        let non_canonical_bytes_because_highbit = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 128,\n        ];\n\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(canonical_bytes).is_some()\n        ));\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(non_canonical_bytes_because_unreduced).is_none()\n        ));\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(non_canonical_bytes_because_highbit).is_none()\n        ));\n    }",
    "display_name": "canonical_decoding",
    "full_path": "file:///work/3118/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/test/multiscalar_consistency_n_100",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/test/multiscalar_consistency_iter"
    ],
    "body": "    fn multiscalar_consistency_n_100() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(100);\n        }\n    }",
    "display_name": "multiscalar_consistency_n_100",
    "full_path": "file:///work/3118/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  }
]