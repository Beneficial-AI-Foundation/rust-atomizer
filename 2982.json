[
  {
    "identifier": "comb_sort/comb_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn comb_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let len = input.len();\n    let inv_shrink: f32 = 1.0 / 1.3;\n\n    let mut gap = len;\n    let mut sorted = len < 2;\n\n    while !sorted {\n        gap = (gap as f32 * inv_shrink).floor() as usize;\n\n        if gap <= 1 {\n            gap = 1;\n            sorted = true;\n        }\n\n        for i in 0..len - gap {\n            if input[i] > input[i + gap] {\n                input.swap(i, i + gap);\n                sorted = false;\n            }\n        }\n    }\n}",
    "display_name": "comb_sort",
    "full_path": "file:///work/2982/src/comb_sort.rs",
    "relative_path": "src/comb_sort.rs",
    "file_name": "comb_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "leonardo_generate",
    "statement_type": "function",
    "deps": [],
    "body": "fn leonardo_generate(mut n0: usize, mut n1: usize, add: usize) ->\nimpl std::iter::Iterator<Item = usize> {\n    std::iter::from_fn(move || {\n        let n = n0;\n        n0 = n1;\n        n1 += n + add;\n        Some(n)\n    })\n}",
    "display_name": "leonardo_generate",
    "full_path": "file:///work/2982/src/bin/leonardo_numbers.rs",
    "relative_path": "src/bin/leonardo_numbers.rs",
    "file_name": "leonardo_numbers.rs",
    "parent_folder": "bin"
  },
  {
    "identifier": "heap_sort/tests/test_heap",
    "statement_type": "function",
    "deps": [
      "heap_sort/heap_sort"
    ],
    "body": "    fn test_heap() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_heap",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cycle_sort/tests/test_cycle_len1",
    "statement_type": "function",
    "deps": [
      "cycle_sort/cycle_sort"
    ],
    "body": "    fn test_cycle_len1() {\n        let mut vector_in = vec![1];\n        cycle_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_cycle_len1",
    "full_path": "file:///work/2982/src/cycle_sort.rs",
    "relative_path": "src/cycle_sort.rs",
    "file_name": "cycle_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gnome_sort/gnome_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn gnome_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let mut i = 0;\n    \n    while i < input.len() {\n        if i == 0 || input[i - 1] < input[i] {\n            i += 1;\n        } else {\n            input.swap(i - 1, i);\n            i -= 1;\n        }\n    }\n}",
    "display_name": "gnome_sort",
    "full_path": "file:///work/2982/src/gnome_sort.rs",
    "relative_path": "src/gnome_sort.rs",
    "file_name": "gnome_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/tests/test_bitonic_char",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/bitonic_sort"
    ],
    "body": "    fn test_bitonic_char() {\n        let mut vector_in = vec!['r', 'u', 's', 't', 'c'];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec!['c', 'r', 's', 't', 'u']);\n    }",
    "display_name": "test_bitonic_char",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/tests/test_quick_dual",
    "statement_type": "function",
    "deps": [
      "quick_sort/quick_dual_sort"
    ],
    "body": "    fn test_quick_dual() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_quick_dual",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "insertion_sort/tests/test_insertion_len1",
    "statement_type": "function",
    "deps": [
      "insertion_sort/insertion_sort"
    ],
    "body": "    fn test_insertion_len1() {\n        let mut vector_in = vec![1];\n        insertion_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_insertion_len1",
    "full_path": "file:///work/2982/src/insertion_sort.rs",
    "relative_path": "src/insertion_sort.rs",
    "file_name": "insertion_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "pancake_sort/flip",
    "statement_type": "function",
    "deps": [],
    "body": "fn flip<T: PartialOrd + Copy>(input: &mut [T], index: usize) {\n    input[..=index].reverse();\n}",
    "display_name": "flip",
    "full_path": "file:///work/2982/src/pancake_sort.rs",
    "relative_path": "src/pancake_sort.rs",
    "file_name": "pancake_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/heap_sort",
    "statement_type": "function",
    "deps": [
      "heap_sort/heap_max"
    ],
    "body": "pub fn heap_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    for i in (0..input.len() / 2).rev() {\n        heap_max(input, i, input.len());\n    }\n\n    for i in (0..input.len()).rev() {\n        input.swap(0, i);\n        heap_max(input, 0, i);\n    }\n}",
    "display_name": "heap_sort",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/tests/test_quick_empty",
    "statement_type": "function",
    "deps": [
      "quick_sort/quick_sort"
    ],
    "body": "    fn test_quick_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        quick_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_quick_empty",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/compare_and_swap",
    "statement_type": "function",
    "deps": [],
    "body": "fn compare_and_swap<T: PartialOrd>(input: &mut [T], mode: bool) {\n    let mid_point = input.len() / 2;\n    for i in 0..mid_point {\n        if (input[i] > input[mid_point + i]) == mode {\n            input.swap(i, mid_point + i);\n        }\n    }\n}",
    "display_name": "compare_and_swap",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "selection_sort/tests/test_selection_double",
    "statement_type": "function",
    "deps": [
      "selection_sort/selection_double_sort"
    ],
    "body": "    fn test_selection_double() {\n        let mut vector_in = vec![11, 20, 21, 40, 11, 60, 5];\n        selection_double_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![5, 11, 11, 20, 21, 40, 60]);\n    }",
    "display_name": "test_selection_double",
    "full_path": "file:///work/2982/src/selection_sort.rs",
    "relative_path": "src/selection_sort.rs",
    "file_name": "selection_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "pancake_sort/pancake_sort",
    "statement_type": "function",
    "deps": [
      "pancake_sort/flip",
      "pancake_sort/largest_pancake"
    ],
    "body": "pub fn pancake_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let in_len = input.len() - 1;\n    for item in (0..in_len + 1).rev() {\n        let cut = largest_pancake(input, item);\n\n        flip(input, cut);\n        flip(input, item);\n    }\n}",
    "display_name": "pancake_sort",
    "full_path": "file:///work/2982/src/pancake_sort.rs",
    "relative_path": "src/pancake_sort.rs",
    "file_name": "pancake_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "slow_sort/tests/test_slow",
    "statement_type": "function",
    "deps": [
      "slow_sort/slow_sort"
    ],
    "body": "    fn test_slow() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        slow_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_slow",
    "full_path": "file:///work/2982/src/slow_sort.rs",
    "relative_path": "src/slow_sort.rs",
    "file_name": "slow_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "slow_sort/slow_sort_sorting",
    "statement_type": "function",
    "deps": [],
    "body": "fn slow_sort_sorting<T: PartialOrd>(input: &mut [T], start: usize, end: usize) {\n    if start >= end {return;}\n\n    let mid = (start + end) / 2;\n    slow_sort_sorting(input, start, mid);\n    slow_sort_sorting(input, mid + 1, end);\n    if input[end] < input[mid] {input.swap(end, mid);}\n    slow_sort_sorting(input, start, end - 1);\n}",
    "display_name": "slow_sort_sorting",
    "full_path": "file:///work/2982/src/slow_sort.rs",
    "relative_path": "src/slow_sort.rs",
    "file_name": "slow_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "smooth_sort/restore_heap",
    "statement_type": "function",
    "deps": [
      "smooth_sort/get_child_trees"
    ],
    "body": "fn restore_heap<T: PartialOrd>(input: &mut [T], index: usize, heap: &Vec<usize>)\n{\n    // Insertion sorting\n    let mut current = heap.len() - 1;\n    let mut i = index;\n    let mut k = heap[current];\n\n    while current > 0 {\n        let j = i - crate::LEO_NUMS[k];\n        if input[j] > input[i] &&\n        (k < 2 || input[j] > input[i - 1] && input[j] > input[i - 2]) {\n            input.swap(i, j);\n            i = j;\n            current -= 1;\n            k = heap[current];\n        } else {\n            break;\n        }\n    }\n\n    while k >= 2 {\n        let t = get_child_trees(i, k);\n        // tr kr tl kl\n        // 0  1  2  3\n        if input[i] < input[t[0]] || input[i] < input[t[2]] {\n            if input[t[0]] > input[t[2]] {\n                input.swap(i, t[0]);\n                i = t[0];\n                k = t[1];\n            } else {\n                input.swap(i, t[2]);\n                i = t[2];\n                k = t[3];\n            }\n        } else {\n            break;\n        }\n    }\n}",
    "display_name": "restore_heap",
    "full_path": "file:///work/2982/src/smooth_sort.rs",
    "relative_path": "src/smooth_sort.rs",
    "file_name": "smooth_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gnome_sort/tests/test_gnome_up_empty",
    "statement_type": "function",
    "deps": [
      "gnome_sort/gnome_up_sort"
    ],
    "body": "    fn test_gnome_up_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        gnome_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_gnome_up_empty",
    "full_path": "file:///work/2982/src/gnome_sort.rs",
    "relative_path": "src/gnome_sort.rs",
    "file_name": "gnome_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "calculate_powers_of_two",
    "statement_type": "function",
    "deps": [],
    "body": "fn calculate_powers_of_two(input: usize) {\n    let mut powers = Vec::<usize>::with_capacity(input);\n    for i in 1..input + 1 {\n        powers.push(2usize.pow(i as u32));\n    }\n    println!(\"{:?}\", powers);\n}",
    "display_name": "calculate_powers_of_two",
    "full_path": "file:///work/2982/src/bin/powers_of_two.rs",
    "relative_path": "src/bin/powers_of_two.rs",
    "file_name": "powers_of_two.rs",
    "parent_folder": "bin"
  },
  {
    "identifier": "heap_sort/tests/test_heap_bottom_up_empty",
    "statement_type": "function",
    "deps": [
      "heap_sort/heap_bottom_up_sort"
    ],
    "body": "    fn test_heap_bottom_up_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        heap_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_heap_bottom_up_empty",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/get_flag",
    "statement_type": "function",
    "deps": [],
    "body": "fn get_flag(r: &Vec<usize>, x: usize) -> usize {\n    (r[x >> 3] >> (x & 7)) & 1\n}",
    "display_name": "get_flag",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/tests/test_quick_dual_len1",
    "statement_type": "function",
    "deps": [
      "quick_sort/quick_dual_sort"
    ],
    "body": "    fn test_quick_dual_len1() {\n        let mut vector_in = vec![1];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_quick_dual_len1",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tests/test_heap_len1",
    "statement_type": "function",
    "deps": [
      "heap_sort/heap_sort"
    ],
    "body": "    fn test_heap_len1() {\n        let mut vector_in = vec![1];\n        heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_heap_len1",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tests/test_weak_heap_empty",
    "statement_type": "function",
    "deps": [
      "heap_sort/weak_heap_sort"
    ],
    "body": "    fn test_weak_heap_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        weak_heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_weak_heap_empty",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "nheap_sort/tests/test_heap_len1",
    "statement_type": "function",
    "deps": [
      "nheap_sort/nheap_sort"
    ],
    "body": "    fn test_heap_len1() {\n        let mut vector_in = vec![1];\n        nheap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_heap_len1",
    "full_path": "file:///work/2982/src/nheap_sort.rs",
    "relative_path": "src/nheap_sort.rs",
    "file_name": "nheap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ksort/ksort_lr",
    "statement_type": "function",
    "deps": [],
    "body": "fn ksort_lr<T: PartialOrd + Clone + Copy>(input: &mut [T], left: usize,\nright: usize) {\n    let key = input[left].clone();\n    // just init it, so no unsafe calls needed, otherwise use of uninit\n    // is prohibited by Rust compiler\n    let mut temp = key.clone();\n    let mut i = left;\n    let mut j = right + 1;\n    let mut k = i + 1;\n    let mut p = i + 1;\n    let mut flag = false;\n\n    while j - i >= 2 {\n        if key <= input[p] {\n            if p != j && j != right + 1 {\n                input.swap(j, p);\n            } else if j == right + 1 {\n                flag = true;\n                temp = input[p].clone();\n            }\n            j -= 1;\n            p = j;\n        } else {\n            input.swap(i, p);\n            i += 1;\n            k += 1;\n            p = k;\n        }\n    }\n\n    input[i] = key;\n    if flag {input[i + 1] = temp;}\n\n    if left < i.saturating_sub(1) {\n        ksort_lr(input, left, i - 1);\n    }\n    if right > i + 1 {\n        ksort_lr(input, i + 1, right);\n    }\n}",
    "display_name": "ksort_lr",
    "full_path": "file:///work/2982/src/ksort.rs",
    "relative_path": "src/ksort.rs",
    "file_name": "ksort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "pancake_sort/tests/test_pancake_len1",
    "statement_type": "function",
    "deps": [
      "pancake_sort/pancake_sort"
    ],
    "body": "    fn test_pancake_len1() {\n        let mut vector_in = vec![1];\n        pancake_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_pancake_len1",
    "full_path": "file:///work/2982/src/pancake_sort.rs",
    "relative_path": "src/pancake_sort.rs",
    "file_name": "pancake_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gnome_sort/tests/test_gnome_up",
    "statement_type": "function",
    "deps": [
      "gnome_sort/gnome_up_sort"
    ],
    "body": "    fn test_gnome_up() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        gnome_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_gnome_up",
    "full_path": "file:///work/2982/src/gnome_sort.rs",
    "relative_path": "src/gnome_sort.rs",
    "file_name": "gnome_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gnome_sort/gnome_up_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn gnome_up_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let mut i = 1;\n    let mut j = 2;\n    let in_len = input.len();\n\n    while i < in_len {\n        if input[i - 1] <= input[i] {\n            i = j;\n            j += 1;\n        }\n        else {\n            input.swap(i - 1, i);\n            i -= 1;\n            if i == 0 {\n                i = j;\n                j += 1;\n            }\n        }\n    }\n}",
    "display_name": "gnome_up_sort",
    "full_path": "file:///work/2982/src/gnome_sort.rs",
    "relative_path": "src/gnome_sort.rs",
    "file_name": "gnome_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "stooge_sort/tests/test_slow_len1",
    "statement_type": "function",
    "deps": [
      "stooge_sort/stooge_sort"
    ],
    "body": "    fn test_slow_len1() {\n        let mut vector_in = vec![1];\n        stooge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_slow_len1",
    "full_path": "file:///work/2982/src/stooge_sort.rs",
    "relative_path": "src/stooge_sort.rs",
    "file_name": "stooge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/tests/test_quick",
    "statement_type": "function",
    "deps": [
      "quick_sort/quick_sort"
    ],
    "body": "    fn test_quick() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        quick_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_quick",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/tests/test_merge_bu",
    "statement_type": "function",
    "deps": [
      "merge_sort/merge_bottom_up_sort"
    ],
    "body": "    fn test_merge_bu() {\n        let mut vector_in = vec![24, 20, 11, 13, 10];\n        merge_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 13, 20, 24]);\n    }",
    "display_name": "test_merge_bu",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/dual_pivot",
    "statement_type": "function",
    "deps": [],
    "body": "fn dual_pivot<T: PartialOrd + Copy>(input: &mut [T], start: usize,\nend: usize) {\n    if start >= end {return;}\n    if input[start] > input[end] {\n        input.swap(start, end);\n    }\n    let lpivot = input[start];\n    let rpivot = input[end];\n\n    let mut startm = start + 1;\n    let mut endm = end - 1;\n\n    let mut point = startm;\n\n    while point <= endm {\n        if input[point] < lpivot {\n            input.swap(point, startm);\n            startm += 1;\n        }\n        else if input[point] >= rpivot {\n            while input[endm] > rpivot && point < endm {\n                endm -= 1;\n            }\n            input.swap(point, endm);\n\n            if input[point] < lpivot {\n                input.swap(point, startm);\n                startm += 1;\n            }\n        }\n        point += 1;\n    }\n    startm -= 1;\n    endm += 1;\n    input.swap(start, startm);\n    input.swap(end, endm);\n\n    dual_pivot(input, start, startm);\n    dual_pivot(input, startm + 1, endm);\n    dual_pivot(input, endm, end);\n}",
    "display_name": "dual_pivot",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bench",
    "statement_type": "function",
    "deps": [
      "heap_sort/heap_bottom_up_sort",
      "cocktail_sort/cocktail_sort",
      "selection_sort/selection_double_sort",
      "shell_sort/shell_sort",
      "smooth_sort/smooth_sort",
      "quick_sort/quick_dual_sort",
      "pancake_sort/pancake_sort",
      "heap_sort/heap_sort",
      "oddeven_sort/oddeven_sort",
      "bubble_sort/bubble_sort",
      "nheap_sort/nheap_sort",
      "bitonic_sort/bitonic_sort",
      "selection_sort/selection_sort",
      "quick_sort/quick_sort",
      "merge_sort/merge_bottom_up_sort",
      "comb_sort/comb_sort",
      "bingo_sort/bingo_sort",
      "gnome_sort/gnome_up_sort",
      "merge_sort/merge_sort",
      "insertion_sort/insertion_sort",
      "cycle_sort/cycle_sort",
      "ksort/ksort",
      "gnome_sort/gnome_sort",
      "heap_sort/weak_heap_sort"
    ],
    "body": "fn bench(c: &mut Criterion) {\n    let sizes: Vec<usize> = vec![\n        2, 5, 8, 10, 16, 100, 128, 500, 512, 1000, 1024, 2000, 2048, 8000, 8192,\n        10_000, 16_000, 16_384, 32_000, 32_768, 50_000, /*65_000, 65_536,*/\n        100_000, /* 131_000, 131_072, 262_000, 262_144,*/ 500_000, /*524_288,*/\n        1_000_000, /*1_048_576,*/ 2_000_000, /*2_097_152, 8_388_608,*/\n        10_000_000, /*15_000_000, 16_777_216, 20_000_000,*/ 50_000_000,\n        100_000_000, 250_000_000\n    ];\n\n    let benchmark = create_bench! {\n        sizes,\n        bingo_sort,\n        bitonic_sort,\n        bubble_sort,\n        cocktail_sort,\n        comb_sort,\n        cycle_sort,\n        gnome_sort,\n        gnome_up_sort,\n        heap_sort,\n        heap_bottom_up_sort,\n        weak_heap_sort,\n        insertion_sort,\n        ksort,\n        merge_sort,\n        merge_bottom_up_sort,\n        nheap_sort,\n        oddeven_sort,\n        pancake_sort,\n        quick_sort,\n        quick_dual_sort,\n        selection_sort,\n        selection_double_sort,\n        shell_sort,\n        smooth_sort\n        // Exclude extremely slow sorts\n        // slow_sort,\n        // stooge_sort\n    };\n\n    c.bench(\"sort_bench\", benchmark);\n}",
    "display_name": "bench",
    "full_path": "file:///work/2982/benches/sort_benchmark.rs",
    "relative_path": "benches/sort_benchmark.rs",
    "file_name": "sort_benchmark.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "shell_sort/test/test_shell_len1",
    "statement_type": "function",
    "deps": [
      "shell_sort/shell_sort"
    ],
    "body": "    fn test_shell_len1() {\n        let mut vector_in = vec![1];\n        shell_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_shell_len1",
    "full_path": "file:///work/2982/src/shell_sort.rs",
    "relative_path": "src/shell_sort.rs",
    "file_name": "shell_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "main",
    "statement_type": "function",
    "deps": [
      "calculate_powers_of_two",
      "calculate_fibonacci",
      "calculate_leonardo"
    ],
    "body": "fn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read value\");\n    input = input.to_string().trim().to_string();\n    println!(\"Maximum number: {}\\n\", usize::MAX);\n    match input.parse::<usize>() {\n        Ok(input) => {calculate_leonardo(input); calculate_fibonacci(input);},\n        _ => {println!(\"Input is not a number!\"); main();}\n    }\n}",
    "display_name": "main",
    "full_path": "file:///work/2982/src/bin/leonardo_numbers.rs",
    "relative_path": "src/bin/leonardo_numbers.rs",
    "file_name": "leonardo_numbers.rs",
    "parent_folder": "bin"
  },
  {
    "identifier": "bitonic_sort/tests/test_bitonic_empty",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/bitonic_sort"
    ],
    "body": "    fn test_bitonic_empty() {\n        let mut vector_in:Vec<u8> = vec![];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![]);\n    }",
    "display_name": "test_bitonic_empty",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tests/test_heap_empty",
    "statement_type": "function",
    "deps": [
      "heap_sort/heap_sort"
    ],
    "body": "    fn test_heap_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_heap_empty",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bingo_sort/tests/test_bingo",
    "statement_type": "function",
    "deps": [
      "bingo_sort/bingo_sort"
    ],
    "body": "    fn test_bingo() {\n        let mut vector_in = vec![10, 20, 11, 24, 15];\n        bingo_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 15, 20, 24]);\n    }",
    "display_name": "test_bingo",
    "full_path": "file:///work/2982/src/bingo_sort.rs",
    "relative_path": "src/bingo_sort.rs",
    "file_name": "bingo_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "benches",
    "statement_type": "function",
    "deps": [
      "bench"
    ],
    "body": "criterion_group!(benches, bench);\ncriterion_main!(benches);",
    "display_name": "benches",
    "full_path": "file:///work/2982/benches/sort_benchmark.rs",
    "relative_path": "benches/sort_benchmark.rs",
    "file_name": "sort_benchmark.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "smooth_sort/tests/test_smooth_empty",
    "statement_type": "function",
    "deps": [
      "smooth_sort/smooth_sort"
    ],
    "body": "    fn test_smooth_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        smooth_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_smooth_empty",
    "full_path": "file:///work/2982/src/smooth_sort.rs",
    "relative_path": "src/smooth_sort.rs",
    "file_name": "smooth_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "shell_sort/impl/GapSequence/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(n: usize) -> Self {\n        Self { gap: n }\n    }",
    "display_name": "new",
    "full_path": "file:///work/2982/src/shell_sort.rs",
    "relative_path": "src/shell_sort.rs",
    "file_name": "shell_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tests/test_weak_heap_big",
    "statement_type": "function",
    "deps": [
      "heap_sort/weak_heap_sort"
    ],
    "body": "    fn test_weak_heap_big() {\n        let mut array = [10, 20, 11, 24, 22, 21, 19, 9, 7, 8, 6, 5];\n        weak_heap_sort(&mut array);\n        debug_assert_eq!(array, [5, 6, 7, 8, 9, 10, 11, 19, 20, 21, 22, 24]);\n    }",
    "display_name": "test_weak_heap_big",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "nheap_sort/nheap_sort",
    "statement_type": "function",
    "deps": [
      "nheap_sort/nheap_sift"
    ],
    "body": "pub fn nheap_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let children = 3;\n    for i in (0..=input.len()).rev() {\n        nheap_sift(input, children, i, input.len() - 1);\n    }\n\n    for i in (1..input.len()).rev() {\n        input.swap(i, 0);\n        nheap_sift(input, children, 0, i - 1);\n    }\n}",
    "display_name": "nheap_sort",
    "full_path": "file:///work/2982/src/nheap_sort.rs",
    "relative_path": "src/nheap_sort.rs",
    "file_name": "nheap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ksort/tests/test_ksort_empty",
    "statement_type": "function",
    "deps": [
      "ksort/ksort"
    ],
    "body": "    fn test_ksort_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        ksort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_ksort_empty",
    "full_path": "file:///work/2982/src/ksort.rs",
    "relative_path": "src/ksort.rs",
    "file_name": "ksort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "selection_sort/tests/test_selection_double_empty",
    "statement_type": "function",
    "deps": [
      "selection_sort/selection_double_sort"
    ],
    "body": "    fn test_selection_double_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        selection_double_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_selection_double_empty",
    "full_path": "file:///work/2982/src/selection_sort.rs",
    "relative_path": "src/selection_sort.rs",
    "file_name": "selection_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "slow_sort/slow_sort",
    "statement_type": "function",
    "deps": [
      "slow_sort/slow_sort_sorting"
    ],
    "body": "pub fn slow_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    slow_sort_sorting(input, 0, input.len() - 1);\n}",
    "display_name": "slow_sort",
    "full_path": "file:///work/2982/src/slow_sort.rs",
    "relative_path": "src/slow_sort.rs",
    "file_name": "slow_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/tests/test_quick_dual_longer",
    "statement_type": "function",
    "deps": [
      "quick_sort/quick_dual_sort"
    ],
    "body": "    fn test_quick_dual_longer() {\n        let mut vector_in = [10, 20, 11, 24, 22, 21, 19];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, [10, 11, 19, 20, 21, 22, 24]);\n    }",
    "display_name": "test_quick_dual_longer",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "smooth_sort/smooth_sort",
    "statement_type": "function",
    "deps": [
      "smooth_sort/restore_heap",
      "smooth_sort/get_child_trees"
    ],
    "body": "pub fn smooth_sort<T: PartialOrd>(input: &mut [T])\n{\n    if input.len() < 2 {return;}\n    \n    // Init addtitional index heap\n    let input = input;\n    let in_len = input.len();\n    let mut heap = Vec::<usize>::new();\n\n    for i in 0..in_len {\n        if heap.len() >= 2 && heap[heap.len() - 2] == heap[heap.len() - 1] + 1 {\n            heap.pop();\n            let len_leo = heap.len();\n            heap[len_leo - 1] += 1;\n        } else if heap.len() >= 1 && heap[heap.len() - 1] == 1 {\n            heap.push(0);\n        } else {\n            heap.push(1);\n        }\n        restore_heap(input, i, &heap);\n    }\n\n    for i in (0..in_len).rev() {\n        if heap[heap.len() - 1] < 2 {\n            heap.pop();\n        } else {\n            let k = heap.pop().unwrap();\n            let t = get_child_trees(i, k);\n            // tr kr tl kl\n            // 0  1  2  3\n            heap.push(t[3]);\n            restore_heap(input, t[2], &heap);\n            heap.push(t[1]);\n            restore_heap(input, t[0], &heap);\n        }\n    }\n}",
    "display_name": "smooth_sort",
    "full_path": "file:///work/2982/src/smooth_sort.rs",
    "relative_path": "src/smooth_sort.rs",
    "file_name": "smooth_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bubble_sort/tests/test_buble_len",
    "statement_type": "function",
    "deps": [
      "bubble_sort/bubble_sort"
    ],
    "body": "    fn test_buble_len() {\n        let mut vector_in = vec![1];\n        bubble_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_buble_len",
    "full_path": "file:///work/2982/src/bubble_sort.rs",
    "relative_path": "src/bubble_sort.rs",
    "file_name": "bubble_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/quick_dual_sort",
    "statement_type": "function",
    "deps": [
      "quick_sort/dual_pivot"
    ],
    "body": "pub fn quick_dual_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    dual_pivot(input, 0, input.len() - 1);\n}",
    "display_name": "quick_dual_sort",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "pancake_sort/largest_pancake",
    "statement_type": "function",
    "deps": [],
    "body": "fn largest_pancake<T: PartialOrd + Copy>(input: &[T], index: usize)\n-> usize {\n    let mut pancake = input[index];\n    let mut largest = index;\n\n    for i in 0..index {\n        if input[i] > pancake {\n            pancake = input[i];\n            largest = i;\n        }\n    }\n    largest\n}",
    "display_name": "largest_pancake",
    "full_path": "file:///work/2982/src/pancake_sort.rs",
    "relative_path": "src/pancake_sort.rs",
    "file_name": "pancake_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/oddeven_batcher_sort_ranges",
    "statement_type": "function",
    "deps": [
      "oddeven_sort/oddeven_batcher_merge"
    ],
    "body": "fn oddeven_batcher_sort_ranges<T: PartialOrd>(input: &mut [T], start:usize,\nend:usize) {\n    if end >= start {\n        let mid = start + (end - start) / 2;\n        oddeven_batcher_sort_ranges(input, end, mid);\n        oddeven_batcher_sort_ranges(input, mid + 1, start);\n        oddeven_batcher_merge(input, start, end, 1);\n    } \n}",
    "display_name": "oddeven_batcher_sort_ranges",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "calculate_leonardo",
    "statement_type": "function",
    "deps": [
      "leonardo_generate"
    ],
    "body": "fn calculate_leonardo(num: usize) {\n    println!(\"Leonardo numbers:\");\n    for i in leonardo_generate(1, 1, 1).take(num) {\n        print!(\"{}, \", i);\n    }\n    println!();\n}",
    "display_name": "calculate_leonardo",
    "full_path": "file:///work/2982/src/bin/leonardo_numbers.rs",
    "relative_path": "src/bin/leonardo_numbers.rs",
    "file_name": "leonardo_numbers.rs",
    "parent_folder": "bin"
  },
  {
    "identifier": "heap_sort/hbu_sift",
    "statement_type": "function",
    "deps": [
      "heap_sort/hbu_leaf_search"
    ],
    "body": "fn hbu_sift<T: PartialOrd>(input: &mut [T], start: usize, end: usize) {\n    let mut current = hbu_leaf_search(input, start, end);\n    \n    while input[start] > input[current] {\n        current = (current - 1) / 2;\n    }\n    input.swap(current, start);\n\n    while current > start {\n        current = (current - 1) / 2;\n        input.swap(current, start);\n    }\n}",
    "display_name": "hbu_sift",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "shell_sort/impl/GapSequence/Iterator/next",
    "statement_type": "function",
    "deps": [],
    "body": "    fn next(&mut self) -> Option<usize> {\n        self.gap /= 2;\n\n        if self.gap > 0 {\n            Some(self.gap)\n        } else {\n            None\n        }\n    }",
    "display_name": "next",
    "full_path": "file:///work/2982/src/shell_sort.rs",
    "relative_path": "src/shell_sort.rs",
    "file_name": "shell_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/lomuto_partition",
    "statement_type": "function",
    "deps": [],
    "body": "fn lomuto_partition<T: PartialOrd>(input: &mut [T]) -> usize {\n    let pivot = input.len() - 1;\n    let mut swap = 0;\n    for i in 0..pivot {\n        if input[i] < input[pivot] {\n            if swap != i {\n                input.swap(swap, i);\n            }\n            swap += 1;\n        }\n    }\n\n    if swap != pivot {\n        input.swap(swap, pivot);\n    }\n    swap\n}",
    "display_name": "lomuto_partition",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/tests/test_oddeven",
    "statement_type": "function",
    "deps": [
      "oddeven_sort/oddeven_sort"
    ],
    "body": "    fn test_oddeven() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        oddeven_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_oddeven",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cycle_sort/tests/test_cycle_empty",
    "statement_type": "function",
    "deps": [
      "cycle_sort/cycle_sort"
    ],
    "body": "    fn test_cycle_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        cycle_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_cycle_empty",
    "full_path": "file:///work/2982/src/cycle_sort.rs",
    "relative_path": "src/cycle_sort.rs",
    "file_name": "cycle_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/heap_bottom_up_sort",
    "statement_type": "function",
    "deps": [
      "heap_sort/hbu_sift"
    ],
    "body": "pub fn heap_bottom_up_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let in_len = input.len();\n    for start in (0..=(in_len - 2) / 2).rev() {\n        hbu_sift(input, start, in_len - 1);\n    }\n    for end in (1..in_len).rev() {\n        input.swap(end, 0);\n        hbu_sift(input, 0, end - 1);\n    }\n}",
    "display_name": "heap_bottom_up_sort",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ksort/tests/test_ksort_len1",
    "statement_type": "function",
    "deps": [
      "ksort/ksort"
    ],
    "body": "    fn test_ksort_len1() {\n        let mut vector_in = vec![1];\n        ksort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_ksort_len1",
    "full_path": "file:///work/2982/src/ksort.rs",
    "relative_path": "src/ksort.rs",
    "file_name": "ksort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/tests/test_quick_dual_empty",
    "statement_type": "function",
    "deps": [
      "quick_sort/quick_dual_sort"
    ],
    "body": "    fn test_quick_dual_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_quick_dual_empty",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "smooth_sort/tests/test_smooth_01",
    "statement_type": "function",
    "deps": [
      "smooth_sort/smooth_sort"
    ],
    "body": "    fn test_smooth_01() {\n        let mut vector_in = vec![20, 10, 11, 13, 24, 9, 2, 1, 8];\n        smooth_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[1, 2, 8, 9, 10, 11, 13, 20, 24]);\n    }",
    "display_name": "test_smooth_01",
    "full_path": "file:///work/2982/src/smooth_sort.rs",
    "relative_path": "src/smooth_sort.rs",
    "file_name": "smooth_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "selection_sort/selection_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn selection_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    for i in 0..input.len() {\n        let swap_val = {\n            let mut min = &input[i];\n            let mut index_min = i;\n            \n            for j in i + 1..input.len() {\n                if input[j] < *min {\n                    min = &input[j];\n                    index_min = j;\n                }\n            }\n            index_min\n        };\n\n        if i != swap_val {\n            input.swap(i, swap_val);\n        }\n    }\n}",
    "display_name": "selection_sort",
    "full_path": "file:///work/2982/src/selection_sort.rs",
    "relative_path": "src/selection_sort.rs",
    "file_name": "selection_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/merge",
    "statement_type": "function",
    "deps": [],
    "body": "fn merge<T: PartialOrd + Copy>(in1: &[T], in2: &[T], tmp: &mut [T]) {\n    let mut left = 0;\n    let mut right = 0;\n    let mut index = 0;\n\n    while left < in1.len() && right < in2.len() {\n        if in1[left] <= in2[right] {\n            tmp[index] = in1[left];\n            index += 1;\n            left += 1;\n        } else {\n            tmp[index] = in2[right];\n            index += 1;\n            right += 1;\n        }\n    }\n\n    if left < in1.len() {\n        tmp[index..].copy_from_slice(&in1[left..]);\n    }\n    if right < in2.len() {\n        tmp[index..].copy_from_slice(&in2[right..]);\n    }\n}",
    "display_name": "merge",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/tests/test_oddeven_batcher",
    "statement_type": "function",
    "deps": [
      "oddeven_sort/oddeven_batcher_sort"
    ],
    "body": "    fn test_oddeven_batcher() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        oddeven_batcher_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_oddeven_batcher",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/tests/test_merge_bu_len1",
    "statement_type": "function",
    "deps": [
      "merge_sort/merge_bottom_up_sort"
    ],
    "body": "    fn test_merge_bu_len1() {\n        let mut vector_in = vec![1];\n        merge_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_merge_bu_len1",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/weak_heap_sort",
    "statement_type": "function",
    "deps": [
      "heap_sort/get_flag",
      "heap_sort/weak_heap_merge"
    ],
    "body": "pub fn weak_heap_sort<T: PartialOrd>(input: &mut [T]) {\n    let n = input.len();\n\n    if n < 2 {return;}\n    else {\n        let mut r = vec![0; (n + 7) / 8];\n        for i in (1..n).rev() {\n            let mut j = i;\n            while j & 1 == get_flag(&r, j >> 1) {j >>= 1;}\n            let gparent = j >> 1;\n            weak_heap_merge(input, &mut r, gparent, i);\n        }\n\n        for i in (2..n).rev() {\n            input.swap(0, i);\n            let mut x = 1;\n            let mut y = 2 * x + get_flag(&r, x);\n            while y < i {\n                x = y;\n                y = 2 * x + get_flag(&r, x);\n            }\n            while x > 0 {\n                weak_heap_merge(input, &mut r, 0, x);\n                x >>= 1;\n            }\n        }\n        input.swap(0, 1);\n    }\n}",
    "display_name": "weak_heap_sort",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/tests/test_oddeven_batcher_len1",
    "statement_type": "function",
    "deps": [
      "oddeven_sort/oddeven_batcher_sort"
    ],
    "body": "    fn test_oddeven_batcher_len1() {\n        let mut vector_in = vec![1];\n        oddeven_batcher_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_oddeven_batcher_len1",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cycle_sort/cycle_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn cycle_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let in_len = input.len();\n    for index in 0..in_len {\n        let mut key = input[index];\n        let mut pos = index;\n\n        for i in index + 1..in_len {\n            if input[i] < key {pos += 1;}\n        }\n\n        if pos == index {continue;}\n\n        while key == input[pos] {\n            pos += 1;\n        }\n        // One does not simply swap by indexes, but copies item into buffer\n        let tmp = input[pos];\n        input[pos] = key;\n        key = tmp;\n\n        while pos != index {\n            pos = index;\n            for i in index + 1..in_len {\n                if input[i] < key {pos += 1;}\n            }\n            while key == input[pos] {\n                pos += 1;\n            }\n            let tmp = input[pos];\n            input[pos] = key;\n            key = tmp;\n        }\n    }\n}",
    "display_name": "cycle_sort",
    "full_path": "file:///work/2982/src/cycle_sort.rs",
    "relative_path": "src/cycle_sort.rs",
    "file_name": "cycle_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/tests/test_oddeven_batcher_empty",
    "statement_type": "function",
    "deps": [
      "oddeven_sort/oddeven_batcher_sort"
    ],
    "body": "    fn test_oddeven_batcher_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        oddeven_batcher_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_oddeven_batcher_empty",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/merge_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn merge_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let len = input.len();\n    let mid = len / 2;\n    merge_sort(&mut input[..mid]);\n    merge_sort(&mut input[mid..]);\n\n    let mut tmp = Vec::with_capacity(len);\n    let mut i = 0;\n    let mut j = mid;\n\n    while i < mid && j < len {\n        if input[i] < input[j] {\n            tmp.push(input[i]);\n            i += 1;\n        } else {\n            tmp.push(input[j]);\n            j += 1;\n        }\n    }\n    if i < mid {\n        tmp.extend_from_slice(&input[i..mid]);\n    } else if j < len {\n        tmp.extend_from_slice(&input[j..len]);\n    }\n\n    input.copy_from_slice(&tmp[..]);\n}",
    "display_name": "merge_sort",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/tests/test_quick_two_elem",
    "statement_type": "function",
    "deps": [
      "quick_sort/quick_dual_sort"
    ],
    "body": "    fn test_quick_two_elem() {\n        let mut vector_in = [20, 10];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, [10, 20]);\n    }",
    "display_name": "test_quick_two_elem",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "insertion_sort/tests/test_insertion",
    "statement_type": "function",
    "deps": [
      "insertion_sort/insertion_sort"
    ],
    "body": "    fn test_insertion() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        insertion_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_insertion",
    "full_path": "file:///work/2982/src/insertion_sort.rs",
    "relative_path": "src/insertion_sort.rs",
    "file_name": "insertion_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tests/test_heap_bottom_up_len1",
    "statement_type": "function",
    "deps": [
      "heap_sort/heap_bottom_up_sort"
    ],
    "body": "    fn test_heap_bottom_up_len1() {\n        let mut vector_in = vec![1];\n        heap_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_heap_bottom_up_len1",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "stooge_sort/tests/test_stooge",
    "statement_type": "function",
    "deps": [
      "stooge_sort/stooge_sort"
    ],
    "body": "    fn test_stooge() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        stooge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_stooge",
    "full_path": "file:///work/2982/src/stooge_sort.rs",
    "relative_path": "src/stooge_sort.rs",
    "file_name": "stooge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gnome_sort/tests/test_gnome_up_len1",
    "statement_type": "function",
    "deps": [
      "gnome_sort/gnome_up_sort"
    ],
    "body": "    fn test_gnome_up_len1() {\n        let mut vector_in = vec![1];\n        gnome_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_gnome_up_len1",
    "full_path": "file:///work/2982/src/gnome_sort.rs",
    "relative_path": "src/gnome_sort.rs",
    "file_name": "gnome_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/bitonic_sort",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/bit_sort"
    ],
    "body": "pub fn bitonic_sort<T: PartialOrd + Default + Clone>(input: &mut Vec<T>) {\n    if input.len() < 2 {return;}\n    else if input.len() > 9223372036854775808 {panic!(\"Array is too big\")}\n    \n    let in_len = input.len();\n\n    // Check if input array has length of power of 2 and add None to fill it up\n    let mut add_len = 0;\n    println!(\"{}\", add_len);\n\n    for (i, num) in crate::POWERS_OF_TWO.iter().enumerate() {\n        if in_len == *num {add_len = 0;}\n        if i > 0 {\n            if in_len < *num {if in_len > crate::POWERS_OF_TWO[i - 1] {\n                add_len = num - in_len;}\n            }\n        }\n    }\n\n    if add_len > 0 {\n        input.append(&mut vec![T::default(); add_len]);\n    }\n    \n    bit_sort(input, true);\n    input.drain(..add_len);\n}",
    "display_name": "bitonic_sort",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bingo_sort/tests/test_bingo_len1",
    "statement_type": "function",
    "deps": [
      "bingo_sort/bingo_sort"
    ],
    "body": "    fn test_bingo_len1() {\n        let mut vector_in = vec![1];\n        bingo_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_bingo_len1",
    "full_path": "file:///work/2982/src/bingo_sort.rs",
    "relative_path": "src/bingo_sort.rs",
    "file_name": "bingo_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "stooge_sort/stooge_sort",
    "statement_type": "function",
    "deps": [
      "stooge_sort/stooge_sort_sorting"
    ],
    "body": "pub fn stooge_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    stooge_sort_sorting(input, 0, input.len() - 1);\n}",
    "display_name": "stooge_sort",
    "full_path": "file:///work/2982/src/stooge_sort.rs",
    "relative_path": "src/stooge_sort.rs",
    "file_name": "stooge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "shell_sort/test/test_shell",
    "statement_type": "function",
    "deps": [
      "shell_sort/shell_sort"
    ],
    "body": "    fn test_shell() {\n        let mut vector_in = vec![11, 20, 21, 40, 11, 60, 5];\n        shell_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![5, 11, 11, 20, 21, 40, 60]);\n    }",
    "display_name": "test_shell",
    "full_path": "file:///work/2982/src/shell_sort.rs",
    "relative_path": "src/shell_sort.rs",
    "file_name": "shell_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/tests/test_oddeven_len1",
    "statement_type": "function",
    "deps": [
      "oddeven_sort/oddeven_sort"
    ],
    "body": "    fn test_oddeven_len1() {\n        let mut vector_in = vec![1];\n        oddeven_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_oddeven_len1",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ksort/tests/test_ksort_01",
    "statement_type": "function",
    "deps": [
      "ksort/ksort"
    ],
    "body": "    fn test_ksort_01() {\n        let mut vector_in = [10, 9, 20, 22, 11, 21, 12, 24, 4, 6, 3];\n        ksort(&mut vector_in);\n        debug_assert_eq!(vector_in, [3, 4, 6, 9, 10, 11, 12, 20, 21, 22, 24]);\n    }",
    "display_name": "test_ksort_01",
    "full_path": "file:///work/2982/src/ksort.rs",
    "relative_path": "src/ksort.rs",
    "file_name": "ksort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/tests/test_quick_len1",
    "statement_type": "function",
    "deps": [
      "quick_sort/quick_sort"
    ],
    "body": "    fn test_quick_len1() {\n        let mut vector_in = vec![1];\n        quick_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_quick_len1",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bubble_sort/tests/test_bubble_empty",
    "statement_type": "function",
    "deps": [
      "bubble_sort/bubble_sort"
    ],
    "body": "    fn test_bubble_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        bubble_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_bubble_empty",
    "full_path": "file:///work/2982/src/bubble_sort.rs",
    "relative_path": "src/bubble_sort.rs",
    "file_name": "bubble_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cocktail_sort/tests/test_cocktail",
    "statement_type": "function",
    "deps": [
      "cocktail_sort/cocktail_sort"
    ],
    "body": "    fn test_cocktail() {\n        let mut vector_in = vec![30, 10, 20, 11, 24, 44, 12, 11];\n        cocktail_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 11, 12, 20, 24, 30, 44]);\n    }",
    "display_name": "test_cocktail",
    "full_path": "file:///work/2982/src/cocktail_sort.rs",
    "relative_path": "src/cocktail_sort.rs",
    "file_name": "cocktail_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "smooth_sort/tests/test_smooth",
    "statement_type": "function",
    "deps": [
      "smooth_sort/smooth_sort"
    ],
    "body": "    fn test_smooth() {\n        let mut vector_in = vec![20, 10, 11, 13];\n        smooth_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[10, 11, 13, 20]);\n    }",
    "display_name": "test_smooth",
    "full_path": "file:///work/2982/src/smooth_sort.rs",
    "relative_path": "src/smooth_sort.rs",
    "file_name": "smooth_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "nheap_sort/tests/test_heap_01",
    "statement_type": "function",
    "deps": [
      "nheap_sort/nheap_sort"
    ],
    "body": "    fn test_heap_01() {\n        let mut vector_in = vec![10, 20, 11, 24, 13, 12];\n        nheap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 12, 13, 20, 24]);\n    }",
    "display_name": "test_heap_01",
    "full_path": "file:///work/2982/src/nheap_sort.rs",
    "relative_path": "src/nheap_sort.rs",
    "file_name": "nheap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/tests/test_oddeven_empty",
    "statement_type": "function",
    "deps": [
      "oddeven_sort/oddeven_sort"
    ],
    "body": "    fn test_oddeven_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        oddeven_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_oddeven_empty",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/merge_bottom_up_sort",
    "statement_type": "function",
    "deps": [
      "merge_sort/merge"
    ],
    "body": "pub fn merge_bottom_up_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    let mut width = 1;\n\n    let mut tmp = input.to_vec();\n    let len = input.len();\n\n    while width < len {\n        let mut i = 0;\n        while i < len {\n            let start = min(i + 2 * width, len);\n            let mid = min(i + width, len);\n\n            merge(&input[i..mid], &input[mid..start], &mut tmp[i..start]);\n            input[i..start].copy_from_slice(&tmp[i..start]);\n\n            i += 2 * width;\n        }\n        width *= 2;\n    }\n}",
    "display_name": "merge_bottom_up_sort",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/weak_heap_merge",
    "statement_type": "function",
    "deps": [
      "heap_sort/tog_flag"
    ],
    "body": "fn weak_heap_merge<T: PartialOrd>(input: &mut [T], r: &mut Vec<usize>,\ni: usize, j: usize) {\n    if input[i] < input[j] {\n        tog_flag(r, j);\n        input.swap(i, j);\n    }\n}",
    "display_name": "weak_heap_merge",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tog_flag",
    "statement_type": "function",
    "deps": [],
    "body": "fn tog_flag(r: &mut Vec<usize>, x: usize) {\n    r[x >> 3] ^= 1 << (x & 7)\n}",
    "display_name": "tog_flag",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "comb_sort/tests/test_comb_empty",
    "statement_type": "function",
    "deps": [
      "comb_sort/comb_sort"
    ],
    "body": "    fn test_comb_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        comb_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_comb_empty",
    "full_path": "file:///work/2982/src/comb_sort.rs",
    "relative_path": "src/comb_sort.rs",
    "file_name": "comb_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cocktail_sort/tests/test_cocktail_len1",
    "statement_type": "function",
    "deps": [
      "cocktail_sort/cocktail_sort"
    ],
    "body": "    fn test_cocktail_len1() {\n        let mut vector_in = vec![1];\n        cocktail_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_cocktail_len1",
    "full_path": "file:///work/2982/src/cocktail_sort.rs",
    "relative_path": "src/cocktail_sort.rs",
    "file_name": "cocktail_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "get_random_vec",
    "statement_type": "function",
    "deps": [],
    "body": "fn get_random_vec(n: usize) -> Vec<usize> {\n    let mut rng: StdRng = StdRng::seed_from_u64(42);\n    let mut vec: Vec<usize> = (0..n).collect();\n    vec.shuffle(&mut rng);\n    vec\n}",
    "display_name": "get_random_vec",
    "full_path": "file:///work/2982/benches/sort_benchmark.rs",
    "relative_path": "benches/sort_benchmark.rs",
    "file_name": "sort_benchmark.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "heap_sort/hbu_leaf_search",
    "statement_type": "function",
    "deps": [],
    "body": "fn hbu_leaf_search<T: PartialOrd>(input: &mut [T], start: usize, end: usize)\n-> usize {\n    let mut current = start;\n\n    loop {\n        let child = current * 2 + 1; // Left leaf\n\n        if (child + 1) > end {\n            break;\n        }\n        if input[child + 1] > input[child] {\n            current = child + 1;\n        }\n        else {\n            current = child;\n        }\n    }\n    let child = current * 2 + 1; // Only left leaf is present\n    if child <= end {\n        current = child;\n    }\n    current\n}",
    "display_name": "hbu_leaf_search",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "nheap_sort/tests/test_heap",
    "statement_type": "function",
    "deps": [
      "nheap_sort/nheap_sort"
    ],
    "body": "    fn test_heap() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        nheap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_heap",
    "full_path": "file:///work/2982/src/nheap_sort.rs",
    "relative_path": "src/nheap_sort.rs",
    "file_name": "nheap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/sub_sort",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/compare_and_swap"
    ],
    "body": "fn sub_sort<T: PartialOrd>(input: &mut [T], mode: bool) {\n    if input.len() > 1 {\n        compare_and_swap(input, mode);\n        let mid_point = input.len() / 2;\n        sub_sort(&mut input[..mid_point], mode);\n        sub_sort(&mut input[mid_point..], mode);\n    }\n}",
    "display_name": "sub_sort",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "shell_sort/shell_sort",
    "statement_type": "function",
    "deps": [
      "shell_sort/impl/GapSequence/new"
    ],
    "body": "pub fn shell_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let len = input.len();\n    let gaps = GapSequence::new(len);\n\n    for gap in gaps {\n        for i in gap..len {\n            let mut j = i;\n\n            while j >= gap && input[j - gap] > input[j] {\n                input.swap(j - gap, j);\n\n                j -= gap;\n            }\n        }\n    }\n}",
    "display_name": "shell_sort",
    "full_path": "file:///work/2982/src/shell_sort.rs",
    "relative_path": "src/shell_sort.rs",
    "file_name": "shell_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/tests/test_bitonic_usize_pow_2",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/bitonic_sort"
    ],
    "body": "    fn test_bitonic_usize_pow_2() {\n        let mut vector_in = vec![10, 20, 11, 24, 15];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 15, 20, 24]);\n    }",
    "display_name": "test_bitonic_usize_pow_2",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cocktail_sort/cocktail_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn cocktail_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let mut index_st = 0;\n    let mut index_end = input.len() - 1;\n\n    while index_st < index_end {\n        let slice = index_st..index_end;\n        index_end = index_st;\n        for i in slice {\n            if input[i] > input[i + 1] {\n                input.swap(i, i + 1);\n                index_end = i;\n            }\n        }\n        \n        let slice = (index_st..index_end).rev();\n        index_st = index_end;\n        for i in slice {\n            if input[i] > input[i + 1] {\n                input.swap(i, i + 1);\n                index_st = i;\n            }\n        }\n    }\n}",
    "display_name": "cocktail_sort",
    "full_path": "file:///work/2982/src/cocktail_sort.rs",
    "relative_path": "src/cocktail_sort.rs",
    "file_name": "cocktail_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/bit_sort",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/sub_sort"
    ],
    "body": "fn bit_sort<T: PartialOrd>(input: &mut [T], mode: bool) {\n    if input.len() > 1 {\n        let mid_point = input.len() / 2;\n        bit_sort(&mut input[..mid_point], true);\n        bit_sort(&mut input[mid_point..], false);\n        sub_sort(input, mode);\n    }\n}",
    "display_name": "bit_sort",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "pancake_sort/tests/test_pancake_empty",
    "statement_type": "function",
    "deps": [
      "pancake_sort/pancake_sort"
    ],
    "body": "    fn test_pancake_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        pancake_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_pancake_empty",
    "full_path": "file:///work/2982/src/pancake_sort.rs",
    "relative_path": "src/pancake_sort.rs",
    "file_name": "pancake_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "insertion_sort/tests/test_insertion_empty",
    "statement_type": "function",
    "deps": [
      "insertion_sort/insertion_sort"
    ],
    "body": "    fn test_insertion_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        insertion_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_insertion_empty",
    "full_path": "file:///work/2982/src/insertion_sort.rs",
    "relative_path": "src/insertion_sort.rs",
    "file_name": "insertion_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/tests/test_bitonic_bool",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/bitonic_sort"
    ],
    "body": "    fn test_bitonic_bool() {\n        let mut vector_in = vec![false, true, false, false, true];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![false, false, false, true, true]);\n    }",
    "display_name": "test_bitonic_bool",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bingo_sort/get_min_max",
    "statement_type": "function",
    "deps": [],
    "body": "fn get_min_max<T: PartialOrd + Copy>(input: &[T]) -> [T; 2] {\n    let mut min = input[0];\n    let mut max = input[0];\n    for i in 1..input.len() {\n        if input[i] < min {min = input[i];}\n        if input[i] > max {max = input[i];}\n    }\n    [min, max]\n}",
    "display_name": "get_min_max",
    "full_path": "file:///work/2982/src/bingo_sort.rs",
    "relative_path": "src/bingo_sort.rs",
    "file_name": "bingo_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/tests/test_merge_bu_empty",
    "statement_type": "function",
    "deps": [
      "merge_sort/merge_bottom_up_sort"
    ],
    "body": "    fn test_merge_bu_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        merge_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_merge_bu_empty",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bubble_sort/tests/test_bubble",
    "statement_type": "function",
    "deps": [
      "bubble_sort/bubble_sort"
    ],
    "body": "    fn test_bubble() {\n        let mut vector_in = vec![30, 10, 20, 11, 24, 44, 12, 11];\n        bubble_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 11, 12, 20, 24, 30, 44]);\n    }",
    "display_name": "test_bubble",
    "full_path": "file:///work/2982/src/bubble_sort.rs",
    "relative_path": "src/bubble_sort.rs",
    "file_name": "bubble_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "insertion_sort/insertion_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn insertion_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    for i in 1..input.len() {\n        let mut j = i;\n        while j > 0 && input[j - 1] > input[j] {\n            input.swap(j - 1, j);\n            j -= 1;\n        }\n    }\n}",
    "display_name": "insertion_sort",
    "full_path": "file:///work/2982/src/insertion_sort.rs",
    "relative_path": "src/insertion_sort.rs",
    "file_name": "insertion_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bingo_sort/bingo_sort",
    "statement_type": "function",
    "deps": [
      "bingo_sort/get_min_max"
    ],
    "body": "pub fn bingo_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let in_len = input.len();\n\n    let minmax = get_min_max(input);\n    let min = minmax[0];\n    let max = minmax[1];\n\n    let mut bingo = min;\n    let mut n_bingo = max;\n    let mut n_index = 0;\n\n    while bingo < max {\n        let start = n_index;\n        for i in start..in_len {\n            if input[i] == bingo {input.swap(i, n_index); n_index += 1;}\n            if input[i] < n_bingo {n_bingo = input[i];}\n        }\n        bingo = n_bingo;\n        n_bingo = max;\n    }\n}",
    "display_name": "bingo_sort",
    "full_path": "file:///work/2982/src/bingo_sort.rs",
    "relative_path": "src/bingo_sort.rs",
    "file_name": "bingo_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "pancake_sort/tests/test_pancake",
    "statement_type": "function",
    "deps": [
      "pancake_sort/pancake_sort"
    ],
    "body": "    fn test_pancake() {\n        let mut vector_in = vec![10, 20, 11, 24, 15];\n        pancake_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 15, 20, 24]);\n    }",
    "display_name": "test_pancake",
    "full_path": "file:///work/2982/src/pancake_sort.rs",
    "relative_path": "src/pancake_sort.rs",
    "file_name": "pancake_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tests/test_weak_heap_small",
    "statement_type": "function",
    "deps": [
      "heap_sort/weak_heap_sort"
    ],
    "body": "    fn test_weak_heap_small() {\n        let mut vector_in = vec![10, 20, 11, 24, 13];\n        weak_heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 13, 20, 24]);\n    }",
    "display_name": "test_weak_heap_small",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bubble_sort/bubble_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn bubble_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let input_len = input.len();\n\n    for i in (0..input_len).rev() {\n        let mut has_swapped = false;\n        for j in 0..i {\n            if input[j] > input[j + 1] {\n                input.swap(j, j + 1);\n                has_swapped = true;\n            }\n        }\n        if !has_swapped {\n            break;\n        }\n    }\n}",
    "display_name": "bubble_sort",
    "full_path": "file:///work/2982/src/bubble_sort.rs",
    "relative_path": "src/bubble_sort.rs",
    "file_name": "bubble_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gnome_sort/tests/test_gnome_len1",
    "statement_type": "function",
    "deps": [
      "gnome_sort/gnome_sort"
    ],
    "body": "    fn test_gnome_len1() {\n        let mut vector_in = vec![1];\n        gnome_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_gnome_len1",
    "full_path": "file:///work/2982/src/gnome_sort.rs",
    "relative_path": "src/gnome_sort.rs",
    "file_name": "gnome_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "selection_sort/tests/test_selection_len1",
    "statement_type": "function",
    "deps": [
      "selection_sort/selection_sort"
    ],
    "body": "    fn test_selection_len1() {\n        let mut vector_in = vec![1];\n        selection_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_selection_len1",
    "full_path": "file:///work/2982/src/selection_sort.rs",
    "relative_path": "src/selection_sort.rs",
    "file_name": "selection_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "nheap_sort/tests/test_heap_empty",
    "statement_type": "function",
    "deps": [
      "nheap_sort/nheap_sort"
    ],
    "body": "    fn test_heap_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        nheap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_heap_empty",
    "full_path": "file:///work/2982/src/nheap_sort.rs",
    "relative_path": "src/nheap_sort.rs",
    "file_name": "nheap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cocktail_sort/tests/test_cocktail_empty",
    "statement_type": "function",
    "deps": [
      "cocktail_sort/cocktail_sort"
    ],
    "body": "    fn test_cocktail_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        cocktail_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_cocktail_empty",
    "full_path": "file:///work/2982/src/cocktail_sort.rs",
    "relative_path": "src/cocktail_sort.rs",
    "file_name": "cocktail_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gnome_sort/tests/test_gnome",
    "statement_type": "function",
    "deps": [
      "gnome_sort/gnome_sort"
    ],
    "body": "    fn test_gnome() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        gnome_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }",
    "display_name": "test_gnome",
    "full_path": "file:///work/2982/src/gnome_sort.rs",
    "relative_path": "src/gnome_sort.rs",
    "file_name": "gnome_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "slow_sort/tests/test_slow_empty",
    "statement_type": "function",
    "deps": [
      "slow_sort/slow_sort"
    ],
    "body": "    fn test_slow_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        slow_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_slow_empty",
    "full_path": "file:///work/2982/src/slow_sort.rs",
    "relative_path": "src/slow_sort.rs",
    "file_name": "slow_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/oddeven_batcher_sort",
    "statement_type": "function",
    "deps": [
      "oddeven_sort/oddeven_batcher_sort_ranges"
    ],
    "body": "pub fn oddeven_batcher_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    oddeven_batcher_sort_ranges(input, 0, input.len() - 1);\n}",
    "display_name": "oddeven_batcher_sort",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "smooth_sort/tests/test_smooth_len1",
    "statement_type": "function",
    "deps": [
      "smooth_sort/smooth_sort"
    ],
    "body": "    fn test_smooth_len1() {\n        let mut vector_in = vec![1];\n        smooth_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[1]);\n    }",
    "display_name": "test_smooth_len1",
    "full_path": "file:///work/2982/src/smooth_sort.rs",
    "relative_path": "src/smooth_sort.rs",
    "file_name": "smooth_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/tests/test_bitonic_usize",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/bitonic_sort"
    ],
    "body": "    fn test_bitonic_usize() {\n        let mut vector_in = vec![10, 20, 11, 24, 15];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 15, 20, 24]);\n    }",
    "display_name": "test_bitonic_usize",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tests/test_weak_heap_len1",
    "statement_type": "function",
    "deps": [
      "heap_sort/weak_heap_sort"
    ],
    "body": "    fn test_weak_heap_len1() {\n        let mut vector_in = vec![1];\n        weak_heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_weak_heap_len1",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "stooge_sort/tests/test_slow_empty",
    "statement_type": "function",
    "deps": [
      "stooge_sort/stooge_sort"
    ],
    "body": "    fn test_slow_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        stooge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_slow_empty",
    "full_path": "file:///work/2982/src/stooge_sort.rs",
    "relative_path": "src/stooge_sort.rs",
    "file_name": "stooge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/oddeven_batcher_merge",
    "statement_type": "function",
    "deps": [],
    "body": "fn oddeven_batcher_merge<T: PartialOrd>(input: &mut [T], start:usize, end:usize,\nr: usize) {\n    let step = r * 2;\n    \n    if step < end - start {\n        oddeven_batcher_merge(input, start, end, step);\n        oddeven_batcher_merge(input, start + r, end, step);\n\n        for i in start + r..=end - r {\n            if input[i] > input[i + r] {input.swap(i, i + r);}\n        }\n    }\n    else {\n        if input[start] > input[start + r] {input.swap(start, start + r);}\n    }\n}",
    "display_name": "oddeven_batcher_merge",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "quick_sort/quick_sort",
    "statement_type": "function",
    "deps": [
      "quick_sort/lomuto_partition"
    ],
    "body": "pub fn quick_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() > 1 {\n        let pivot = lomuto_partition(input);\n        quick_sort(&mut input[..pivot]);\n        quick_sort(&mut input[pivot + 1..]);\n    }\n}",
    "display_name": "quick_sort",
    "full_path": "file:///work/2982/src/quick_sort.rs",
    "relative_path": "src/quick_sort.rs",
    "file_name": "quick_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/tests/test_merge_empty",
    "statement_type": "function",
    "deps": [
      "merge_sort/merge_sort"
    ],
    "body": "    fn test_merge_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        merge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_merge_empty",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "shell_sort/test/test_shell_empty",
    "statement_type": "function",
    "deps": [
      "shell_sort/shell_sort"
    ],
    "body": "    fn test_shell_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        shell_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_shell_empty",
    "full_path": "file:///work/2982/src/shell_sort.rs",
    "relative_path": "src/shell_sort.rs",
    "file_name": "shell_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "selection_sort/tests/test_selection_double_len1",
    "statement_type": "function",
    "deps": [
      "selection_sort/selection_double_sort"
    ],
    "body": "    fn test_selection_double_len1() {\n        let mut vector_in = vec![1];\n        selection_double_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_selection_double_len1",
    "full_path": "file:///work/2982/src/selection_sort.rs",
    "relative_path": "src/selection_sort.rs",
    "file_name": "selection_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "oddeven_sort/oddeven_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn oddeven_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let mut sorted = false;\n    let in_len = input.len();\n    while !sorted {\n        sorted = true;\n        \n        let mut i = 1;\n        while i < in_len - 1 {\n            if input[i] > input[i + 1] {\n                input.swap(i, i + 1);\n                sorted = false;\n            }\n            i += 2;\n        }\n\n        i = 0;\n        while i < in_len - 1 {\n            if input[i] > input[i + 1] {\n                input.swap(i, i + 1);\n                sorted = false;\n            }\n            i += 2;\n        }\n    }\n}",
    "display_name": "oddeven_sort",
    "full_path": "file:///work/2982/src/oddeven_sort.rs",
    "relative_path": "src/oddeven_sort.rs",
    "file_name": "oddeven_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "comb_sort/tests/test_comb_len1",
    "statement_type": "function",
    "deps": [
      "comb_sort/comb_sort"
    ],
    "body": "    fn test_comb_len1() {\n        let mut vector_in = vec![1];\n        comb_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_comb_len1",
    "full_path": "file:///work/2982/src/comb_sort.rs",
    "relative_path": "src/comb_sort.rs",
    "file_name": "comb_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "shell_sort/test/test_correct_gap_sequence",
    "statement_type": "function",
    "deps": [
      "shell_sort/impl/GapSequence/new"
    ],
    "body": "    fn test_correct_gap_sequence() {\n        let gaps: Vec<_> = GapSequence::new(10).collect();\n        debug_assert_eq!(gaps, &[5, 2, 1]);\n    }",
    "display_name": "test_correct_gap_sequence",
    "full_path": "file:///work/2982/src/shell_sort.rs",
    "relative_path": "src/shell_sort.rs",
    "file_name": "shell_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "selection_sort/tests/test_selection_empty",
    "statement_type": "function",
    "deps": [
      "selection_sort/selection_sort"
    ],
    "body": "    fn test_selection_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        selection_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_selection_empty",
    "full_path": "file:///work/2982/src/selection_sort.rs",
    "relative_path": "src/selection_sort.rs",
    "file_name": "selection_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "calculate_fibonacci",
    "statement_type": "function",
    "deps": [
      "leonardo_generate"
    ],
    "body": "fn calculate_fibonacci(num: usize) {\n    println!(\"Fibonacci numbers:\");\n    for i in leonardo_generate(0, 1, 0).take(num) {\n        print!(\"{}, \", i);\n    }\n    println!();\n}",
    "display_name": "calculate_fibonacci",
    "full_path": "file:///work/2982/src/bin/leonardo_numbers.rs",
    "relative_path": "src/bin/leonardo_numbers.rs",
    "file_name": "leonardo_numbers.rs",
    "parent_folder": "bin"
  },
  {
    "identifier": "bingo_sort/tests/test_bingo_empty",
    "statement_type": "function",
    "deps": [
      "bingo_sort/bingo_sort"
    ],
    "body": "    fn test_bingo_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        bingo_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![]);\n    }",
    "display_name": "test_bingo_empty",
    "full_path": "file:///work/2982/src/bingo_sort.rs",
    "relative_path": "src/bingo_sort.rs",
    "file_name": "bingo_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "comb_sort/tests/test_comb",
    "statement_type": "function",
    "deps": [
      "comb_sort/comb_sort"
    ],
    "body": "    fn test_comb() {\n        let mut vector_in = vec![30, 10, 20, 11, 24, 44, 12, 11];\n        comb_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 11, 12, 20, 24, 30, 44]);\n    }",
    "display_name": "test_comb",
    "full_path": "file:///work/2982/src/comb_sort.rs",
    "relative_path": "src/comb_sort.rs",
    "file_name": "comb_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/tests/test_merge",
    "statement_type": "function",
    "deps": [
      "merge_sort/merge_sort"
    ],
    "body": "    fn test_merge() {\n        let mut vector_in = vec![10, 20, 11, 13, 24];\n        merge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 13, 20, 24]);\n    }",
    "display_name": "test_merge",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ksort/tests/test_ksort",
    "statement_type": "function",
    "deps": [
      "ksort/ksort"
    ],
    "body": "    fn test_ksort() {\n        let mut vector_in = [10, 20, 11, 24];\n        ksort(&mut vector_in);\n        debug_assert_eq!(vector_in, [10, 11, 20, 24]);\n    }",
    "display_name": "test_ksort",
    "full_path": "file:///work/2982/src/ksort.rs",
    "relative_path": "src/ksort.rs",
    "file_name": "ksort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "merge_sort/tests/test_merge_len1",
    "statement_type": "function",
    "deps": [
      "merge_sort/merge_sort"
    ],
    "body": "    fn test_merge_len1() {\n        let mut vector_in = vec![1];\n        merge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_merge_len1",
    "full_path": "file:///work/2982/src/merge_sort.rs",
    "relative_path": "src/merge_sort.rs",
    "file_name": "merge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "selection_sort/tests/test_selection",
    "statement_type": "function",
    "deps": [
      "selection_sort/selection_sort"
    ],
    "body": "    fn test_selection() {\n        let mut vector_in = vec![11, 20, 21, 40, 11, 60, 5];\n        selection_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![5, 11, 11, 20, 21, 40, 60]);\n    }",
    "display_name": "test_selection",
    "full_path": "file:///work/2982/src/selection_sort.rs",
    "relative_path": "src/selection_sort.rs",
    "file_name": "selection_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ksort/ksort",
    "statement_type": "function",
    "deps": [
      "ksort/ksort_lr"
    ],
    "body": "pub fn ksort<T: PartialOrd + Clone + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    ksort_lr(input, 0, input.len() - 1);\n}",
    "display_name": "ksort",
    "full_path": "file:///work/2982/src/ksort.rs",
    "relative_path": "src/ksort.rs",
    "file_name": "ksort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/heap_max",
    "statement_type": "function",
    "deps": [],
    "body": "fn heap_max<T: PartialOrd>(input: &mut [T], i: usize, heap_len: usize) {\n    let left = 2 * i + 1;\n    let right = left + 1;\n\n    let mut largest = i;\n    if left < heap_len && input[left] > input[largest] {\n        largest = left;\n    }\n    if right < heap_len && input[right] > input[largest] {\n        largest = right;\n    }\n\n    if largest != i {\n        input.swap(i, largest);\n        heap_max(input, largest, heap_len);\n    }\n}",
    "display_name": "heap_max",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "stooge_sort/stooge_sort_sorting",
    "statement_type": "function",
    "deps": [],
    "body": "fn stooge_sort_sorting<T: PartialOrd>(input: &mut [T], start: usize,\nend: usize) {\n    if input[start] > input[end] {input.swap(start, end);}\n    if start <= end {\n        if (end - start + 1) > 2 {\n            let temp = (end - start + 1) / 3;\n            stooge_sort_sorting(input, start, end - temp);\n            stooge_sort_sorting(input, start + temp, end);\n            stooge_sort_sorting(input, start, end - temp);\n        }\n    }\n}",
    "display_name": "stooge_sort_sorting",
    "full_path": "file:///work/2982/src/stooge_sort.rs",
    "relative_path": "src/stooge_sort.rs",
    "file_name": "stooge_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gnome_sort/tests/test_gnome_empty",
    "statement_type": "function",
    "deps": [
      "gnome_sort/gnome_sort"
    ],
    "body": "    fn test_gnome_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        gnome_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }",
    "display_name": "test_gnome_empty",
    "full_path": "file:///work/2982/src/gnome_sort.rs",
    "relative_path": "src/gnome_sort.rs",
    "file_name": "gnome_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cycle_sort/tests/test_cycle",
    "statement_type": "function",
    "deps": [
      "cycle_sort/cycle_sort"
    ],
    "body": "    fn test_cycle() {\n        let mut vector_in = vec![11, 20, 21, 40, 11, 60, 5];\n        cycle_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![5, 11, 11, 20, 21, 40, 60]);\n    }",
    "display_name": "test_cycle",
    "full_path": "file:///work/2982/src/cycle_sort.rs",
    "relative_path": "src/cycle_sort.rs",
    "file_name": "cycle_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "heap_sort/tests/test_heap_bottom_up",
    "statement_type": "function",
    "deps": [
      "heap_sort/heap_bottom_up_sort"
    ],
    "body": "    fn test_heap_bottom_up() {\n        let mut array = [10, 20, 11, 24, 22, 21, 19];\n        heap_bottom_up_sort(&mut array);\n        debug_assert_eq!(array, [10, 11, 19, 20, 21, 22, 24]);\n    }",
    "display_name": "test_heap_bottom_up",
    "full_path": "file:///work/2982/src/heap_sort.rs",
    "relative_path": "src/heap_sort.rs",
    "file_name": "heap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "smooth_sort/get_child_trees",
    "statement_type": "function",
    "deps": [],
    "body": "fn get_child_trees(i: usize, k: usize) -> [usize; 4] {\n    let tr = i - 1;\n    let kr = k - 2;\n    let tl = tr - crate::LEO_NUMS[kr];\n    let kl = k - 1;\n    [tr, kr, tl, kl]\n}",
    "display_name": "get_child_trees",
    "full_path": "file:///work/2982/src/smooth_sort.rs",
    "relative_path": "src/smooth_sort.rs",
    "file_name": "smooth_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "selection_sort/selection_double_sort",
    "statement_type": "function",
    "deps": [],
    "body": "pub fn selection_double_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let mut left = 0;\n    let mut right = input.len() - 1;\n    let mut min = left;\n    let mut max = left;\n\n    while left <= right {\n        for i in left..=right {\n            if input[i] > input[max] {\n                max = i;\n            }\n            if input[i] < input[min] {\n                min = i;\n            }\n        }\n        if max == left {max = min;}\n        input.swap(left, min);\n        input.swap(right, max);\n\n        left += 1;\n        right -= 1;\n\n        min = left;\n        max = right;\n    }\n}",
    "display_name": "selection_double_sort",
    "full_path": "file:///work/2982/src/selection_sort.rs",
    "relative_path": "src/selection_sort.rs",
    "file_name": "selection_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "nheap_sort/nheap_sift",
    "statement_type": "function",
    "deps": [],
    "body": "fn nheap_sift<T: PartialOrd>(input: &mut [T], children: usize, start: usize,\nend: usize) {\n    let mut root = start;\n    \n    loop {\n        let child = root * children + 1;\n        if child > end {break;}\n        let mut max = child;\n\n        for k in 2..children + 1 {\n            let current = root * children + k;\n            if current > end {break;}\n\n            if input[current] > input[max] {\n                max = current;\n            }\n        }\n        if input[root] < input[max] {\n            input.swap(root, max);\n            root = max;\n        } else {break;}\n    }\n}",
    "display_name": "nheap_sift",
    "full_path": "file:///work/2982/src/nheap_sort.rs",
    "relative_path": "src/nheap_sort.rs",
    "file_name": "nheap_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "slow_sort/tests/test_slow_len1",
    "statement_type": "function",
    "deps": [
      "slow_sort/slow_sort"
    ],
    "body": "    fn test_slow_len1() {\n        let mut vector_in = vec![1];\n        slow_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_slow_len1",
    "full_path": "file:///work/2982/src/slow_sort.rs",
    "relative_path": "src/slow_sort.rs",
    "file_name": "slow_sort.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bitonic_sort/tests/test_bitonic_len1",
    "statement_type": "function",
    "deps": [
      "bitonic_sort/bitonic_sort"
    ],
    "body": "    fn test_bitonic_len1() {\n        let mut vector_in = vec![1];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }",
    "display_name": "test_bitonic_len1",
    "full_path": "file:///work/2982/src/bitonic_sort.rs",
    "relative_path": "src/bitonic_sort.rs",
    "file_name": "bitonic_sort.rs",
    "parent_folder": "src"
  }
]