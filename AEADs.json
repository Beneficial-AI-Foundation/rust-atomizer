[
  {
    "identifier": "ivlen8/encrypt",
    "statement_type": "function",
    "deps": [
      "impl/AesGcm/KeyInit/new"
    ],
    "body": "    fn encrypt() {\n        let key = hex!(\"15b2d414826453f9e1c7dd0b69d8d1eb\");\n        let nonce = hex!(\"b6\");\n        let plaintext = hex!(\"8cfa255530c6fbc19d51bd4aeb39c91b\");\n\n        let ciphertext = Aes128GcmWith8BitNonce::new(&key.into())\n            .encrypt(&Array(nonce), &plaintext[..])\n            .unwrap();\n\n        let (ct, tag) = ciphertext.split_at(ciphertext.len() - 16);\n        assert_eq!(hex!(\"4822cb98bd5f5d921ee19285c9032375\"), ct);\n        assert_eq!(hex!(\"8a40670ebac98cf4e9cc1bf8f803167d\"), tag);\n    }",
    "display_name": "encrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/tests/other_ivlen.rs",
    "relative_path": "aes-gcm/tests/other_ivlen.rs",
    "file_name": "other_ivlen.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes192_16_11",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_16_11",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/Encryptor/encrypt_last_in_place",
    "statement_type": "function",
    "deps": [
      "StreamPrimitive/encrypt"
    ],
    "body": "    encrypt_last_in_place,\n    encrypt,\n    encrypt_in_place,\n    \"encrypt\",\n    \"‚Ñ∞ STREAM encryptor\"\n);\n\nimpl_stream_object!(\n    Decryptor,\n    decrypt_next,\n    decrypt_next_in_place,\n    decrypt_last,\n    decrypt_last_in_place,\n    decrypt,\n    decrypt_in_place,\n    \"decrypt\",\n    \"ùíü STREAM decryptor\"\n);\n\n/// STREAM encryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type EncryptorBE32<A> = Encryptor<A, StreamBE32<A>>;\n\n/// STREAM decryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type DecryptorBE32<A> = Decryptor<A, StreamBE32<A>>;\n\n/// STREAM encryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type EncryptorLE31<A> = Encryptor<A, StreamLE31<A>>;\n\n/// STREAM decryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type DecryptorLE31<A> = Decryptor<A, StreamLE31<A>>;\n\n/// The original \"Rogaway-flavored\" STREAM as described in the paper\n/// [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance][1].\n///\n/// Uses a 32-bit big endian counter and 1-byte \"last block\" flag stored as\n/// the last 5-bytes of the AEAD nonce.\n///\n/// [1]: https://eprint.iacr.org/2015/189.pdf\n#[derive(Debug)]\npub struct StreamBE32<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<U5>,\n    <<A as AeadCore>::NonceSize as Sub<U5>>::Output: ArraySize,\n{\n    /// Underlying AEAD cipher\n    aead: A,\n\n    /// Nonce (sans STREAM overhead)\n    nonce: Nonce<A, Self>,\n}",
    "display_name": "encrypt_last_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/AesGcm/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &Key<Self>) -> Self {\n        Aes::new(key).into()\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/src/lib.rs",
    "relative_path": "aes-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ghash/impl/GHash/KeyInit/new",
    "statement_type": "function",
    "deps": [
      "ghash/impl/GHash/new_with_init_block"
    ],
    "body": "    fn new(h: &Key) -> Self {\n        Self::new_with_init_block(h, 0)\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/ghash.rs",
    "relative_path": "belt-dwp/src/ghash.rs",
    "file_name": "ghash.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/SivAead/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &Array<u8, Self::KeySize>) -> Self {\n        Self {\n            key: *key,\n            mac: PhantomData,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/lib.rs",
    "relative_path": "aes-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "decrypt_aad_only_16kb",
    "statement_type": "function",
    "deps": [
      "impl/Dwp/AeadInOut/encrypt_inout_detached",
      "impl/Dwp/AeadInOut/decrypt_inout_detached"
    ],
    "body": "fn decrypt_aad_only_16kb(b: &mut Bencher) {\n    let c = BeltDwp::new(&KEY);\n    let aad = vec![0; 16 * 1024];\n    let mut buf = [];\n    let tag = c\n        .encrypt_inout_detached(&NONCE, &aad, (&mut buf[..]).into())\n        .unwrap();\n\n    b.iter(|| {\n        let (aad, buf, nonce, tag) = test::black_box((&aad, &mut buf[..], &NONCE, &tag));\n        let res = c.decrypt_inout_detached(nonce, aad, buf.into(), tag);\n        let _ = test::black_box(res);\n    });\n\n    b.bytes = 16 * 1024;\n}",
    "display_name": "decrypt_aad_only_16kb",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/benches/mod.rs",
    "relative_path": "belt-dwp/benches/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "cavp_ccm_aes128_16_7",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_16_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "siv/impl/Siv/xor_with_keystream",
    "statement_type": "function",
    "deps": [],
    "body": "    fn xor_with_keystream(&mut self, mut iv: Tag, msg: InOutBuf<'_, '_, u8>) {\n        // \"We zero-out the top bit in each of the last two 32-bit words\n        // of the IV before assigning it to Ctr\"\n        //  ‚Äî http://web.cs.ucdavis.edu/~rogaway/papers/siv.pdf\n        iv[8] &= 0x7f;\n        iv[12] &= 0x7f;\n\n        Ctr128BE::<C>::inner_iv_init(C::new(&self.encryption_key), &iv)\n            .apply_keystream_partial(msg);\n    }",
    "display_name": "xor_with_keystream",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/AesGcmSiv/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key_bytes: &Key<Self>) -> Self {\n        Self {\n            key_generating_key: Aes::new(key_bytes),\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_8_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_8_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "online/impl/EaxImpl/encrypt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encrypt(&mut self, msg: &mut [u8]) {\n        self.ctr.apply_keystream(msg);\n        self.message.update(msg);\n    }",
    "display_name": "encrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes192_4_7",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_4_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "online/impl/EaxImpl/update_assoc",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn update_assoc(&mut self, aad: &[u8]) {\n        self.data.update(aad);\n    }",
    "display_name": "update_assoc",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_16_10",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_16_10",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/CbcMac/update",
    "statement_type": "function",
    "deps": [
      "impl/CbcMac/block_update"
    ],
    "body": "    fn update(&mut self, data: &[u8]) {\n        let (blocks, rem) = Block::<C>::slice_as_chunks(data);\n\n        for block in blocks {\n            self.block_update(block);\n        }\n\n        if !rem.is_empty() {\n            let mut bn = Block::<C>::default();\n            bn[..rem.len()].copy_from_slice(rem);\n            self.block_update(&bn);\n        }\n    }",
    "display_name": "update",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Ccm/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/Ccm/extend_nonce",
      "impl/Ccm/calc_mac"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce<N>,\n        adata: &[u8],\n        mut buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag<Self::TagSize>,\n    ) -> Result<(), Error> {\n        let ext_nonce = Self::extend_nonce(nonce);\n        // number of bytes left for counter (max 8)\n        let cb = C::BlockSize::USIZE - N::USIZE - 1;\n\n        if cb > 4 {\n            let mut ctr = Ctr64BE::from_core(CtrCore::inner_iv_init(&self.cipher, &ext_nonce));\n            ctr.seek(C::BlockSize::USIZE);\n            ctr.apply_keystream_inout(buffer.reborrow());\n        } else {\n            let mut ctr = Ctr32BE::from_core(CtrCore::inner_iv_init(&self.cipher, &ext_nonce));\n            ctr.seek(C::BlockSize::USIZE);\n            ctr.apply_keystream_inout(buffer.reborrow());\n        }\n\n        let mut full_tag = self.calc_mac(nonce, adata, buffer.get_out())?;\n\n        if cb > 4 {\n            let mut ctr = Ctr64BE::from_core(CtrCore::inner_iv_init(&self.cipher, &ext_nonce));\n            ctr.apply_keystream(&mut full_tag);\n        } else {\n            let mut ctr = Ctr32BE::from_core(CtrCore::inner_iv_init(&self.cipher, &ext_nonce));\n            ctr.apply_keystream(&mut full_tag);\n        }\n\n        if full_tag[..tag.len()].ct_eq(tag).into() {\n            Ok(())\n        } else {\n            buffer.get_out().fill(0);\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre impl/AsconAead128/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre impl/Ascon/AeadInOut/decrypt_inout_detached"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce<Self>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag<Self>,\n    ) -> Result<(), Error> {\n        self.0\n            .decrypt_inout_detached(nonce, associated_data, buffer, tag)\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/lib.rs",
    "relative_path": "ascon-aead128/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/process_final",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/impl/AsconCore/permute_12_and_apply_key"
    ],
    "body": "    fn process_final(&mut self) -> [u8; 16] {\n        self.state[2] ^= self.key.get_k1();\n        self.state[3] ^= self.key.get_k2();\n        self.permute_12_and_apply_key();\n\n        let mut tag = [0u8; 16];\n        tag[..8].copy_from_slice(&u64::to_le_bytes(self.state[3]));\n        tag[8..].copy_from_slice(&u64::to_le_bytes(self.state[4]));\n        tag\n    }",
    "display_name": "process_final",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre ntz",
      "0.2.0_pre impl/Ocb3/wide_encrypt",
      "0.2.0_pre inplace_xor",
      "0.2.0_pre impl/Ocb3/compute_tag"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce<NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> aead::Result<aead::Tag<Self>> {\n        if (buffer.len() > P_MAX) || (associated_data.len() > A_MAX) {\n            unimplemented!()\n        }\n\n        // First, try to process many blocks at once.\n        let (tail, index, mut offset_i, mut checksum_i) = self.wide_encrypt(nonce, buffer);\n\n        let mut i = index;\n\n        // Then, process the remaining blocks.\n        let (blocks, mut tail): (InOutBuf<'_, '_, Block>, _) = tail.into_chunks();\n\n        for p_i in blocks {\n            // offset_i = offset_{i-1} xor L_{ntz(i)}\n            inplace_xor(&mut offset_i, &self.ll[ntz(i)]);\n            // checksum_i = checksum_{i-1} xor p_i\n            inplace_xor(&mut checksum_i, p_i.get_in());\n            // c_i = offset_i xor ENCIPHER(K, p_i xor offset_i)\n            let mut c_i = p_i;\n            c_i.xor_in2out(&offset_i);\n            self.cipher.encrypt_block(c_i.get_out());\n            inplace_xor(c_i.get_out(), &offset_i);\n\n            i += 1;\n        }\n\n        // Process any partial blocks.\n        if !tail.is_empty() {\n            let remaining_bytes = tail.len();\n\n            // offset_* = offset_m xor L_*\n            inplace_xor(&mut offset_i, &self.ll_star);\n            // Pad = ENCIPHER(K, offset_*)\n            let mut pad = Block::default();\n            inplace_xor(&mut pad, &offset_i);\n            self.cipher.encrypt_block(&mut pad);\n            // checksum_* = checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*)))\n            let checksum_rhs = &mut [0u8; 16];\n            checksum_rhs[..remaining_bytes].copy_from_slice(tail.get_in());\n            checksum_rhs[remaining_bytes] = 0b1000_0000;\n            inplace_xor(&mut checksum_i, checksum_rhs.as_ref());\n            // C_* = P_* xor Pad[1..bitlen(P_*)]\n            let p_star = tail.get_out();\n            let pad = &mut pad[..p_star.len()];\n            tail.xor_in2out(pad);\n        }\n\n        let tag = self.compute_tag(associated_data, &mut checksum_i, &offset_i);\n\n        Ok(tag)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/StreamLE31/StreamPrimitive/decrypt_in_place",
    "statement_type": "function",
    "deps": [
      "impl/StreamLE31/aead_nonce"
    ],
    "body": "    fn decrypt_in_place(\n        &self,\n        position: Self::Counter,\n        last_block: bool,\n        associated_data: &[u8],\n        buffer: &mut dyn Buffer,\n    ) -> Result<()> {\n        let nonce = self.aead_nonce(position, last_block)?;\n        self.aead.decrypt_in_place(&nonce, associated_data, buffer)\n    }",
    "display_name": "decrypt_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "tests/impl/MockBuffer/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "        fn from(buf: &[u8]) -> Self {\n            let mut in_buf = [0u8; 33];\n            in_buf.copy_from_slice(buf);\n            Self {\n                in_buf,\n                out_buf: [0u8; 33],\n            }\n        }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Ccm/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/Ccm/calc_mac",
      "impl/Ccm/extend_nonce"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce<N>,\n        adata: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag<Self::TagSize>, Error> {\n        let mut full_tag = self.calc_mac(nonce, adata, buffer.get_in())?;\n\n        let ext_nonce = Self::extend_nonce(nonce);\n        // number of bytes left for counter (max 8)\n        let cb = C::BlockSize::USIZE - N::USIZE - 1;\n\n        if cb > 4 {\n            let mut ctr = Ctr64BE::from_core(CtrCore::inner_iv_init(&self.cipher, &ext_nonce));\n            ctr.apply_keystream(&mut full_tag);\n            ctr.apply_keystream_inout(buffer);\n        } else {\n            let mut ctr = Ctr32BE::from_core(CtrCore::inner_iv_init(&self.cipher, &ext_nonce));\n            ctr.apply_keystream(&mut full_tag);\n            ctr.apply_keystream_inout(buffer);\n        }\n\n        Ok(Tag::try_from(&full_tag[..M::to_usize()]).expect(\"tag size mismatch\"))\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "siv/impl/Siv/decrypt_in_place",
    "statement_type": "function",
    "deps": [
      "siv/impl/Siv/decrypt_inout_detached"
    ],
    "body": "    pub fn decrypt_in_place<I, T>(\n        &mut self,\n        headers: I,\n        buffer: &mut dyn Buffer,\n    ) -> Result<(), Error>\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,\n    {\n        if buffer.len() < IV_SIZE {\n            return Err(Error);\n        }\n\n        let siv_tag = Tag::try_from(&buffer.as_ref()[..IV_SIZE]).expect(\"tag size mismatch\");\n        self.decrypt_inout_detached(headers, (&mut buffer.as_mut()[IV_SIZE..]).into(), &siv_tag)?;\n\n        let pt_len = buffer.len() - IV_SIZE;\n\n        // TODO(tarcieri): add offset param to `encrypt_inout_detached`\n        buffer.as_mut().copy_within(IV_SIZE.., 0);\n        buffer.truncate(pt_len);\n        Ok(())\n    }",
    "display_name": "decrypt_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/pad",
    "statement_type": "function",
    "deps": [],
    "body": "const fn pad(n: usize) -> u64 {\n    0x01_u64 << (8 * n)\n}",
    "display_name": "pad",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/permute_12_and_apply_key",
    "statement_type": "function",
    "deps": [],
    "body": "    fn permute_12_and_apply_key(&mut self) {\n        self.state.permute_12();\n        self.state[3] ^= self.key.get_k1();\n        self.state[4] ^= self.key.get_k2();\n    }",
    "display_name": "permute_12_and_apply_key",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/From/from",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre key_dependent_variables"
    ],
    "body": "    fn from(cipher: Cipher) -> Self {\n        let (ll_star, ll_dollar, ll) = key_dependent_variables(&cipher);\n\n        Self {\n            cipher,\n            nonce_size: PhantomData,\n            tag_size: PhantomData,\n            ll_star,\n            ll_dollar,\n            ll,\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_128_2",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_128_2() {\n    let plaintext = Vec::new();\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"b507e4aee5f9d7cb9eaebd8370f25a98\");\n\n    let encrypted = DeoxysI128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_i_128_2",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_128.rs",
    "relative_path": "deoxys/tests/deoxys_i_128.rs",
    "file_name": "deoxys_i_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Element/Mul/mul",
    "statement_type": "function",
    "deps": [
      "gf/gf128_soft64/impl/Element/GfElement/mul_sum",
      "gf/gf128_soft64/impl/Element/GfElement/into_bytes",
      "gf/gf128_soft64/impl/Element/GfElement/new"
    ],
    "body": "    fn mul(self, rhs: Self) -> Self {\n        let mut res = Self::new();\n        res.mul_sum(&self.into_bytes(), &rhs.into_bytes());\n        res\n    }",
    "display_name": "mul",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "0.11.0_rc.0 wycheproof_xchacha20poly1305",
    "statement_type": "function",
    "deps": [],
    "body": "    wycheproof_xchacha20poly1305,\n    \"wycheproof_xchacha20poly1305\",\n    XChaCha20Poly1305\n);\n\nmacro_rules! impl_tests {\n    ($cipher:ty, $key:expr, $nonce:expr, $aad:expr, $plaintext:expr, $ciphertext:expr, $tag:expr) => {\n        #[test]\n        fn encrypt() {\n            let key = Array(*$key);\n            let nonce = Array(*$nonce);\n            let payload = Payload {\n                msg: $plaintext,\n                aad: $aad,\n            };\n\n            let ciphertext = <$cipher>::new(&key).encrypt(&nonce, payload).unwrap();\n\n            let tag_begins = ciphertext.len() - 16;\n            assert_eq!($ciphertext, &ciphertext[..tag_begins]);\n            assert_eq!($tag, &ciphertext[tag_begins..]);\n        }\n\n        #[test]\n        fn decrypt() {\n            let key = Array(*$key);\n            let nonce = Array(*$nonce);\n\n            let mut ciphertext = Vec::from($ciphertext);\n            ciphertext.extend_from_slice($tag);\n            let payload = Payload {\n                msg: &ciphertext,\n                aad: $aad,\n            };\n\n            let plaintext = <$cipher>::new(&key).decrypt(&nonce, payload).unwrap();\n\n            assert_eq!($plaintext, plaintext.as_slice());\n        }\n\n        #[test]\n        fn decrypt_modified() {\n            let key = Array(*$key);\n            let nonce = Array(*$nonce);\n\n            let mut ciphertext = Vec::from($ciphertext);\n            ciphertext.extend_from_slice($tag);\n\n            // Tweak the first byte\n            ciphertext[0] ^= 0xaa;\n\n            let payload = Payload {\n                msg: &ciphertext,\n                aad: $aad,\n            };\n\n            let cipher = <$cipher>::new(&key);\n            assert!(cipher.decrypt(&nonce, payload).is_err());\n        }\n    };\n}",
    "display_name": "wycheproof_xchacha20poly1305",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/tests/lib.rs",
    "relative_path": "chacha20poly1305/tests/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "deoxys_bc/impl/DeoxysBc256/DeoxysBcType/precompute_subkeys",
    "statement_type": "function",
    "deps": [
      "deoxys_bc/h_substitution",
      "deoxys_bc/lfsr2"
    ],
    "body": "    fn precompute_subkeys(key: &Array<u8, Self::KeySize>) -> Array<DeoxysKey, Self::SubkeysSize> {\n        let mut subkeys: Array<DeoxysKey, Self::SubkeysSize> = Default::default();\n\n        let mut tk2 = [0u8; 16];\n\n        tk2.copy_from_slice(key);\n\n        // First key\n        let rcon = RCON[0];\n\n        for i in 0..16 {\n            subkeys[0][i] = tk2[i] ^ rcon[i];\n        }\n\n        // Other keys\n        for (index, subkey) in subkeys[1..].iter_mut().enumerate() {\n            h_substitution(&mut tk2);\n            lfsr2(&mut tk2);\n\n            let rcon = RCON[index + 1];\n\n            for i in 0..16 {\n                subkey[i] = tk2[i] ^ rcon[i];\n            }\n        }\n\n        subkeys\n    }",
    "display_name": "precompute_subkeys",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/deoxys_bc.rs",
    "relative_path": "deoxys/src/deoxys_bc.rs",
    "file_name": "deoxys_bc.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/Eax/finish",
    "statement_type": "function",
    "deps": [
      "online/impl/EaxImpl/verify_ct"
    ],
    "body": "    pub fn finish(self, expected: &Tag<M>) -> Result<(), Error> {\n        self.imp.verify_ct(expected)\n    }",
    "display_name": "finish",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "aes128eax",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(aes128eax, \"aes128eax\", Eax<Aes128>);",
    "display_name": "aes128eax",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/tests/aes128eax.rs",
    "relative_path": "eax/tests/aes128eax.rs",
    "file_name": "aes128eax.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes192_12_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_12_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/hash",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre ntz",
      "0.2.0_pre inplace_xor"
    ],
    "body": "    fn hash(&self, associated_data: &[u8]) -> Block {\n        let mut offset_i = Block::default();\n        let mut sum_i = Block::default();\n\n        let mut i = 1;\n        let (blocks, remaining) = Block::slice_as_chunks(associated_data);\n        for a_i in blocks {\n            // offset_i = offset_{i-1} xor L_{ntz(i)}\n            inplace_xor(&mut offset_i, &self.ll[ntz(i)]);\n            // Sum_i = Sum_{i-1} xor ENCIPHER(K, A_i xor offset_i)\n            let mut a_i = *a_i;\n            inplace_xor(&mut a_i, &offset_i);\n            self.cipher.encrypt_block(&mut a_i);\n            inplace_xor(&mut sum_i, &a_i);\n\n            i += 1;\n        }\n\n        // Process any partial blocks.\n        if !remaining.is_empty() {\n            let processed_bytes = (i - 1) * 16;\n            let remaining_bytes = associated_data.len() - processed_bytes;\n\n            // offset_* = offset_m xor L_*\n            inplace_xor(&mut offset_i, &self.ll_star);\n            // CipherInput = (A_* || 1 || zeros(127-bitlen(A_*))) xor offset_*\n            let mut cipher_input = Block::default();\n            cipher_input[..remaining_bytes].copy_from_slice(&associated_data[processed_bytes..]);\n            cipher_input[remaining_bytes] = 0b1000_0000;\n            //let cipher_input = Block::from_mut_slice(cipher_input);\n            inplace_xor(&mut cipher_input, &offset_i);\n            // Sum = Sum_m xor ENCIPHER(K, CipherInput)\n            self.cipher.encrypt_block(&mut cipher_input);\n            inplace_xor(&mut sum_i, &cipher_input);\n        }\n\n        sum_i\n    }",
    "display_name": "hash",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_128_2",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_128_2() {\n    let plaintext = Vec::new();\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"3c197ca5317af5a2b95b178a60553132\");\n\n    let encrypted = DeoxysII128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_ii_128_2",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_128.rs",
    "relative_path": "deoxys/tests/deoxys_ii_128.rs",
    "file_name": "deoxys_ii_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/StreamBE32/StreamPrimitive/decrypt_in_place",
    "statement_type": "function",
    "deps": [
      "impl/StreamBE32/aead_nonce"
    ],
    "body": "    fn decrypt_in_place(\n        &self,\n        position: Self::Counter,\n        last_block: bool,\n        associated_data: &[u8],\n        buffer: &mut dyn Buffer,\n    ) -> Result<()> {\n        let nonce = self.aead_nonce(position, last_block);\n        self.aead.decrypt_in_place(&nonce, associated_data, buffer)\n    }",
    "display_name": "decrypt_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/test/clear_0to7",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/clear"
    ],
    "body": "    fn clear_0to7() {\n        assert_eq!(clear(0x0123456789abcdef, 1), 0x0123456789abcd00);\n        assert_eq!(clear(0x0123456789abcdef, 2), 0x0123456789ab0000);\n        assert_eq!(clear(0x0123456789abcdef, 3), 0x0123456789000000);\n        assert_eq!(clear(0x0123456789abcdef, 4), 0x0123456700000000);\n        assert_eq!(clear(0x0123456789abcdef, 5), 0x0123450000000000);\n        assert_eq!(clear(0x0123456789abcdef, 6), 0x0123000000000000);\n        assert_eq!(clear(0x0123456789abcdef, 7), 0x0100000000000000);\n    }",
    "display_name": "clear_0to7",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Decryptor/from_stream_primitive",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_stream_primitive",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/EaxImpl/with_key_and_nonce",
    "statement_type": "function",
    "deps": [],
    "body": "    fn with_key_and_nonce(key: &Key<Cipher>, nonce: &Nonce<Cipher::BlockSize>) -> Self {\n        let prepend_cmac = |key, init_val, data| {\n            let mut cmac = <Cmac<Cipher> as KeyInit>::new(key);\n            cmac.update(&[0; 15]);\n            cmac.update(&[init_val]);\n            cmac.update(data);\n            cmac\n        };\n\n        // https://crypto.stackexchange.com/questions/26948/eax-cipher-mode-with-nonce-equal-header\n        // has an explanation of eax.\n\n        // l = block cipher size = 128 (for AES-128) = 16 byte\n        // 1. n ‚Üê OMAC(0 || Nonce)\n        // (the 0 means the number zero in l bits)\n        let n = prepend_cmac(key, 0, nonce);\n        let n = n.finalize().into_bytes();\n\n        // NOTE: These can be updated online later\n        // 2. h ‚Üê OMAC(1 || associated data)\n        let h = prepend_cmac(key, 1, &[]);\n        // 3. c ‚Üê OMAC(2 || enc)\n        let c = prepend_cmac(key, 2, &[]);\n\n        let cipher = ctr::Ctr128BE::<Cipher>::new(key, &n);\n\n        Self {\n            nonce: n,\n            data: h,\n            message: c,\n            ctr: cipher,\n            _tag_size: Default::default(),\n        }\n    }",
    "display_name": "with_key_and_nonce",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/u64_from_bytes_partial",
    "statement_type": "function",
    "deps": [],
    "body": "fn u64_from_bytes_partial(input: &[u8]) -> u64 {\n    let mut tmp = [0u8; 8];\n    tmp[0..input.len()].copy_from_slice(input);\n    u64::from_le_bytes(tmp)\n}",
    "display_name": "u64_from_bytes_partial",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Element/From, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>>>/from",
    "statement_type": "function",
    "deps": [
      "gf/gf128_soft64/from_block"
    ],
    "body": "    fn from(block: Block) -> Self {\n        let [a, b] = from_block(&block);\n        Self(a, b)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "NewStream/from_aead",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_aead(aead: A, nonce: &Nonce<A, Self>) -> Self;\n}\n\n/// Low-level STREAM implementation.\n///\n/// This trait provides a particular \"flavor\" of STREAM, as there are\n/// different ways the specifics of the construction can be implemented.\n///\n/// Deliberately immutable and stateless to permit parallel operation.\npub trait StreamPrimitive<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<Self::NonceOverhead>,\n    NonceSize<A, Self>: ArraySize,\n{\n    /// Number of bytes this STREAM primitive requires from the nonce.\n    type NonceOverhead: ArraySize;\n\n    /// Type used as the STREAM counter.\n    type Counter: AddAssign + Copy + Default + Eq;\n\n    /// Value to use when incrementing the STREAM counter (i.e. one)\n    const COUNTER_INCR: Self::Counter;\n\n    /// Maximum value of the STREAM counter.\n    const COUNTER_MAX: Self::Counter;\n\n    /// Encrypt an AEAD message in-place at the given position in the STREAM.\n    fn encrypt_in_place(\n        &self,\n        position: Self::Counter,\n        last_block: bool,\n        associated_data: &[u8],\n        buffer: &mut dyn Buffer,\n    ) -> Result<()>;\n\n    /// Decrypt an AEAD message in-place at the given position in the STREAM.\n    fn decrypt_in_place(\n        &self,\n        position: Self::Counter,\n        last_block: bool,\n        associated_data: &[u8],\n        buffer: &mut dyn Buffer,\n    ) -> Result<()>;\n\n    /// Encrypt the given plaintext payload, and return the resulting\n    /// ciphertext as a vector of bytes.\n    #[cfg(feature = \"alloc\")]\n    fn encrypt<'msg, 'aad>(\n        &self,\n        position: Self::Counter,\n        last_block: bool,\n        plaintext: impl Into<Payload<'msg, 'aad>>,\n    ) -> Result<Vec<u8>> {\n        let payload = plaintext.into();\n        let mut buffer = Vec::with_capacity(payload.msg.len() + A::TagSize::to_usize());\n        buffer.extend_from_slice(payload.msg);\n        self.encrypt_in_place(position, last_block, payload.aad, &mut buffer)?;\n        Ok(buffer)\n    }\n\n    /// Decrypt the given ciphertext slice, and return the resulting plaintext\n    /// as a vector of bytes.\n    #[cfg(feature = \"alloc\")]\n    fn decrypt<'msg, 'aad>(\n        &self,\n        position: Self::Counter,\n        last_block: bool,\n        ciphertext: impl Into<Payload<'msg, 'aad>>,\n    ) -> Result<Vec<u8>> {\n        let payload = ciphertext.into();\n        let mut buffer = Vec::from(payload.msg);\n        self.decrypt_in_place(position, last_block, payload.aad, &mut buffer)?;\n        Ok(buffer)\n    }\n\n    /// Obtain [`Encryptor`] for this [`StreamPrimitive`].\n    fn encryptor(self) -> Encryptor<A, Self>\n    where\n        Self: Sized,\n    {\n        Encryptor::from_stream_primitive(self)\n    }\n\n    /// Obtain [`Decryptor`] for this [`StreamPrimitive`].\n    fn decryptor(self) -> Decryptor<A, Self>\n    where\n        Self: Sized,\n    {\n        Decryptor::from_stream_primitive(self)\n    }\n}",
    "display_name": "from_aead",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Dwp/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "get_sizes_block",
      "ghash/impl/GHash/new_with_init_block"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag<Self>,\n    ) -> aead::Result<()> {\n        let sizes_block = get_sizes_block(associated_data.len(), buffer.len());\n\n        // 2.1. ùë† ‚Üê belt-block(ùëÜ, ùêæ);\n        let mut s = *nonce;\n        self.cipher.encrypt_block(&mut s);\n\n        // 2.2. ùëü ‚Üê belt-block(ùë†, ùêæ);\n        let mut r = s;\n        self.cipher.encrypt_block(&mut r);\n\n        // Initialize GHash\n        let mut ghash = GHash::new_with_init_block(&r, T);\n\n        // 3. For ùëñ = 1, 2, . . . , ùëö do:\n        //  3.1 ùë° ‚Üê ùë° ‚äï (ùêºùëñ ‚Äñ 0^{128‚àí|ùêºùëñ|})\n        //  3.2 ùë° ‚Üê ùë° * ùëü.\n        ghash.update_padded(associated_data);\n\n        // 4. For ùëñ = 1, 2, . . . , ùëõ do:\n        //  4.1 ùë° ‚Üê ùë° ‚äï (ùëåùëñ ‚Äñ 0^{128‚àí|ùëåùëñ|})\n        //  4.2 ùë° ‚Üê ùë° * ùëü.\n        ghash.update_padded(buffer.get_in());\n\n        // 5. ùë° ‚Üê ùë° ‚äï (‚ü®|ùêº|‚ü©_64 ‚Äñ ‚ü®|ùëã|‚ü©_64)\n        ghash.update_padded(&sizes_block);\n\n        // 6. ùë° ‚Üê belt-block(ùë° * ùëü, ùêæ).\n        let mut tag_exact = ghash.finalize_reset();\n        self.cipher.encrypt_block(&mut tag_exact);\n\n        use subtle::ConstantTimeEq;\n        // 7. If ùëá != Lo(ùë°, 64), return ‚ä•\n        if tag_exact[..TagSize::USIZE].ct_eq(tag).into() {\n            // 8. For ùëñ = 1,2,...,ùëõ do:\n            // 8.1. ùë† ‚Üê ùë† ‚äû ‚ü®1‚ü©128;\n            // 8.2. ùëãùëñ ‚Üê ùëåùëñ ‚äï Lo(belt-block(ùë†, ùêæ), |ùëåùëñ|)\n            let core = BeltCtrCore::inner_iv_init(&self.cipher, nonce);\n            let mut enc_cipher = BeltCtr::from_core(core);\n            enc_cipher.apply_keystream_inout(buffer);\n            Ok(())\n        } else {\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/lib.rs",
    "relative_path": "belt-dwp/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Encryptor/encrypt_next_in_place",
    "statement_type": "function",
    "deps": [],
    "body": "    encrypt_next_in_place,\n    encrypt_last,\n    encrypt_last_in_place,\n    encrypt,\n    encrypt_in_place,\n    \"encrypt\",\n    \"‚Ñ∞ STREAM encryptor\"\n);\n\nimpl_stream_object!(\n    Decryptor,\n    decrypt_next,\n    decrypt_next_in_place,\n    decrypt_last,\n    decrypt_last_in_place,\n    decrypt,\n    decrypt_in_place,\n    \"decrypt\",\n    \"ùíü STREAM decryptor\"\n);\n\n/// STREAM encryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type EncryptorBE32<A> = Encryptor<A, StreamBE32<A>>;\n\n/// STREAM decryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type DecryptorBE32<A> = Decryptor<A, StreamBE32<A>>;\n\n/// STREAM encryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type EncryptorLE31<A> = Encryptor<A, StreamLE31<A>>;\n\n/// STREAM decryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type DecryptorLE31<A> = Decryptor<A, StreamLE31<A>>;\n\n/// The original \"Rogaway-flavored\" STREAM as described in the paper\n/// [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance][1].\n///\n/// Uses a 32-bit big endian counter and 1-byte \"last block\" flag stored as\n/// the last 5-bytes of the AEAD nonce.\n///\n/// [1]: https://eprint.iacr.org/2015/189.pdf\n#[derive(Debug)]\npub struct StreamBE32<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<U5>,\n    <<A as AeadCore>::NonceSize as Sub<U5>>::Output: ArraySize,\n{\n    /// Underlying AEAD cipher\n    aead: A,\n\n    /// Nonce (sans STREAM overhead)\n    nonce: Nonce<A, Self>,\n}",
    "display_name": "encrypt_next_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_12_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_12_13, \"cavp_ccm_aes128_12_13\", Ccm<Aes128, U12, U13>);\naead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_12_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/permute_state",
    "statement_type": "function",
    "deps": [],
    "body": "    fn permute_state(&mut self) {\n        self.state.permute_8();\n    }",
    "display_name": "permute_state",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "siv/impl/Siv/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "siv/s2v",
      "siv/impl/Siv/xor_with_keystream"
    ],
    "body": "    pub fn decrypt_inout_detached<I, T>(\n        &mut self,\n        headers: I,\n        mut ciphertext: InOutBuf<'_, '_, u8>,\n        siv_tag: &Tag,\n    ) -> Result<(), Error>\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,\n    {\n        self.xor_with_keystream(*siv_tag, ciphertext.reborrow());\n        let computed_siv_tag = s2v(&mut self.mac, headers, ciphertext.get_out())?;\n\n        // Note: `CtOutput` provides constant-time equality\n        if CtOutput::<M>::new(computed_siv_tag) == CtOutput::new(*siv_tag) {\n            Ok(())\n        } else {\n            // Re-encrypt the decrypted plaintext to avoid revealing it\n            self.xor_with_keystream(*siv_tag, ciphertext);\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_256_1",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_256_1() {\n    let plaintext = Vec::new();\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"0001020304050607\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"50b0deaa3c3129d1ea1ef96b7c8db67f\");\n\n    let encrypted = DeoxysI256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_i_256_1",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_256.rs",
    "relative_path": "deoxys/tests/deoxys_i_256.rs",
    "file_name": "deoxys_i_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/SivAead/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &Array<u8, Self::KeySize>) -> Self {\n        Self {\n            key: *key,\n            mac: PhantomData,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/lib.rs",
    "relative_path": "aes-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "deoxys_bc/lfsr3",
    "statement_type": "function",
    "deps": [],
    "body": "fn lfsr3(tk: &mut [u8; 16]) {\n    let mut data = u128::from_ne_bytes(*tk);\n    data = ((data >> 1) & 0x7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F)\n        | (((data << 7) ^ (data << 1)) & 0x80808080808080808080808080808080);\n\n    tk.copy_from_slice(&data.to_ne_bytes())\n}",
    "display_name": "lfsr3",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/deoxys_bc.rs",
    "relative_path": "deoxys/src/deoxys_bc.rs",
    "file_name": "deoxys_bc.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Encryptor/from_stream_primitive",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_stream_primitive",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Ccm/KeyInit/new",
    "statement_type": "function",
    "deps": [
      "impl/Ccm/From/from"
    ],
    "body": "    fn new(key: &Key<Self>) -> Self {\n        Self::from(C::new(key))\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "StreamPrimitive/decryptor",
    "statement_type": "function",
    "deps": [
      "impl/Decryptor/from_stream_primitive"
    ],
    "body": "    fn decryptor(self) -> Decryptor<A, Self>\n    where\n        Self: Sized,\n    {\n        Decryptor::from_stream_primitive(self)\n    }",
    "display_name": "decryptor",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_16_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_16_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "deoxys_bc/DeoxysBcInternal/key_schedule",
    "statement_type": "function",
    "deps": [
      "deoxys_bc/h_substitution"
    ],
    "body": "    fn key_schedule(\n        tweak: &Tweak,\n        subkeys: &Array<DeoxysKey, Self::SubkeysSize>,\n    ) -> Array<DeoxysKey, Self::SubkeysSize> {\n        let mut subtweakeys: Array<DeoxysKey, Self::SubkeysSize> = Default::default();\n        let mut tweak = *tweak;\n\n        // First key\n        for (i, (s, t)) in tweak.iter().zip(subkeys[0].iter()).enumerate() {\n            subtweakeys[0][i] = s ^ t\n        }\n\n        // Other keys\n        for (stk, sk) in subtweakeys[1..].iter_mut().zip(subkeys[1..].iter()) {\n            h_substitution((&mut tweak).into());\n\n            for i in 0..16 {\n                stk[i] = sk[i] ^ tweak[i];\n            }\n        }\n\n        subtweakeys\n    }",
    "display_name": "key_schedule",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/deoxys_bc.rs",
    "relative_path": "deoxys/src/deoxys_bc.rs",
    "file_name": "deoxys_bc.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.11.0_rc.0 impl/ChaChaPoly1305/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.11.0_rc.0 cipher/impl/Cipher/new",
      "0.11.0_rc.0 cipher/impl/Cipher/decrypt_inout_detached"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &aead::Nonce<Self>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n    ) -> Result<(), Error> {\n        Cipher::new(C::new(&self.key, nonce)).decrypt_inout_detached(associated_data, buffer, tag)\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/lib.rs",
    "relative_path": "chacha20poly1305/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/InternalKey16/InternalKey, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>>/",
    "statement_type": "function",
    "deps": [],
    "body": "    fn get_k2(&self) -> u64 {\n        self.1\n    }",
    "display_name": "get_k2",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/Eax/update_assoc",
    "statement_type": "function",
    "deps": [
      "online/impl/EaxImpl/update_assoc"
    ],
    "body": "    pub fn update_assoc(&mut self, aad: &[u8]) {\n        self.imp.update_assoc(aad);\n    }",
    "display_name": "update_assoc",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/CbcMac/from_cipher",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_cipher(cipher: &'a C) -> Self {\n        Self {\n            cipher,\n            state: Default::default(),\n        }\n    }",
    "display_name": "from_cipher",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "tests/impl/MockBuffer/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "        fn as_ref(&self) -> &[u8] {\n            &self.out_buf\n        }",
    "display_name": "as_ref",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "private/SealedNonce/get_max_len",
    "statement_type": "function",
    "deps": [
      "private/SealedNonce/get_l"
    ],
    "body": "    fn get_max_len() -> usize {\n        // a somewhat ugly code to prevent overflow.\n        // compiler should be able to completely optimize it out\n        let l = Self::get_l() as u128;\n        let v = (1 << (8 * l)) - 1;\n        core::cmp::min(v, usize::MAX as u128) as usize\n    }",
    "display_name": "get_max_len",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/private.rs",
    "relative_path": "ccm/src/private.rs",
    "file_name": "private.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "deoxys_bc/impl/DeoxysBc384/DeoxysBcType/precompute_subkeys",
    "statement_type": "function",
    "deps": [
      "deoxys_bc/lfsr2",
      "deoxys_bc/lfsr3",
      "deoxys_bc/h_substitution"
    ],
    "body": "    fn precompute_subkeys(key: &Array<u8, Self::KeySize>) -> Array<DeoxysKey, Self::SubkeysSize> {\n        let mut subkeys: Array<DeoxysKey, Self::SubkeysSize> = Default::default();\n\n        let mut tk3 = [0u8; 16];\n        let mut tk2 = [0u8; 16];\n\n        tk3.copy_from_slice(&key[..16]);\n        tk2.copy_from_slice(&key[16..]);\n\n        // First key\n        let rcon = RCON[0];\n\n        for i in 0..16 {\n            subkeys[0][i] = tk3[i] ^ tk2[i] ^ rcon[i];\n        }\n\n        // Other keys\n        for (index, subkey) in subkeys[1..].iter_mut().enumerate() {\n            h_substitution(&mut tk2);\n            lfsr2(&mut tk2);\n            h_substitution(&mut tk3);\n            lfsr3(&mut tk3);\n\n            let rcon = RCON[index + 1];\n\n            for i in 0..16 {\n                subkey[i] = tk3[i] ^ tk2[i] ^ rcon[i];\n            }\n        }\n\n        subkeys\n    }",
    "display_name": "precompute_subkeys",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/deoxys_bc.rs",
    "relative_path": "deoxys/src/deoxys_bc.rs",
    "file_name": "deoxys_bc.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Ccm/extend_nonce",
    "statement_type": "function",
    "deps": [
      "private/SealedNonce/get_l"
    ],
    "body": "    fn extend_nonce(nonce: &Nonce<N>) -> Block<C> {\n        let mut ext_nonce = Block::<C>::default();\n        ext_nonce[0] = N::get_l() - 1;\n        ext_nonce[1..][..nonce.len()].copy_from_slice(nonce);\n        ext_nonce\n    }",
    "display_name": "extend_nonce",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Ccm/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(cipher: C) -> Self {\n        Self {\n            cipher,\n            _pd: PhantomData,\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/process_encrypt_inout",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/impl/AsconCore/permute_state",
      "0.1.0_pre asconcore/pad",
      "0.1.0_pre asconcore/u64_from_bytes_partial",
      "0.1.0_pre asconcore/u64_from_bytes"
    ],
    "body": "    fn process_encrypt_inout(&mut self, message: InOutBuf<'_, '_, u8>) {\n        let (blocks, mut last_block) = message.into_chunks::<U16>();\n\n        for mut block in blocks {\n            // process full block of message\n            self.state[0] ^= u64_from_bytes(&block.get_in()[..8]);\n            block.get_out()[..8].copy_from_slice(&u64::to_le_bytes(self.state[0]));\n            self.state[1] ^= u64_from_bytes(&block.get_in()[8..16]);\n            block.get_out()[8..16].copy_from_slice(&u64::to_le_bytes(self.state[1]));\n            self.permute_state();\n        }\n\n        // process partial block if it exists\n        let sidx = if last_block.len() >= 8 {\n            self.state[0] ^= u64_from_bytes(&last_block.get_in()[..8]);\n            last_block.get_out()[..8].copy_from_slice(&u64::to_le_bytes(self.state[0]));\n            (_, last_block) = last_block.split_at(8);\n            1\n        } else {\n            0\n        };\n        self.state[sidx] ^= pad(last_block.len());\n        if !last_block.is_empty() {\n            self.state[sidx] ^= u64_from_bytes_partial(last_block.get_in());\n            let last_block_len = last_block.len();\n            last_block\n                .get_out()\n                .copy_from_slice(&u64::to_le_bytes(self.state[sidx])[0..last_block_len]);\n        }\n    }",
    "display_name": "process_encrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.11.0_rc.0 cipher/impl/Cipher/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.11.0_rc.0 cipher/impl/Cipher/authenticate_lengths"
    ],
    "body": "    pub(crate) fn encrypt_inout_detached(\n        mut self,\n        associated_data: &[u8],\n        mut buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag, Error> {\n        if buffer.len() / BLOCK_SIZE >= MAX_BLOCKS {\n            return Err(Error);\n        }\n\n        self.mac.update_padded(associated_data);\n\n        // TODO(tarcieri): interleave encryption with Poly1305\n        // See: <https://github.com/RustCrypto/AEADs/issues/74>\n        self.cipher.apply_keystream_inout(buffer.reborrow());\n        self.mac.update_padded(buffer.get_out());\n\n        self.authenticate_lengths(associated_data, buffer.get_out())?;\n        Ok(self.mac.finalize())\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/cipher.rs",
    "relative_path": "chacha20poly1305/src/cipher.rs",
    "file_name": "cipher.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "modes/impl/DeoxysII/DeoxysMode/encrypt_inout",
    "statement_type": "function",
    "deps": [
      "DeoxysBcType/encrypt_inout",
      "modes/impl/DeoxysII/encrypt_decrypt_message",
      "modes/impl/DeoxysII/authenticate_message",
      "modes/DeoxysModeInternal/compute_ad_tag"
    ],
    "body": "    fn encrypt_inout(\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n    ) -> Tag {\n        let mut tag = Tag::default();\n        let mut tweak = Tweak::default();\n\n        // Associated Data\n        <Self as DeoxysModeInternal<B>>::compute_ad_tag(\n            associated_data,\n            &mut tweak,\n            subkeys,\n            &mut tag,\n        );\n\n        // Message authentication\n        Self::authenticate_message(buffer.get_in(), &mut tweak, subkeys, &mut tag);\n\n        tweak[0] = TWEAK_TAG;\n        tweak[1..].copy_from_slice(nonce);\n        B::encrypt_inout((&mut tag).into(), &tweak, subkeys);\n\n        // Message encryption\n        Self::encrypt_decrypt_message(buffer, &mut tweak, subkeys, &tag, nonce);\n\n        tag\n    }",
    "display_name": "encrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/modes.rs",
    "relative_path": "deoxys/src/modes.rs",
    "file_name": "modes.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_256_6",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_256_6() {\n    let plaintext = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"0001020304050607\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: [u8; 32] =\n        hex!(\"2c36c041fa3b1436c5153214131d493be9d014689a6a1e93e4a50989f0342941\");\n\n    let tag: [u8; 16] = hex!(\"6da67607bad9cdd34d702325d52abcdd\");\n\n    let encrypted = DeoxysI256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_256_6",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_256.rs",
    "relative_path": "deoxys/tests/deoxys_i_256.rs",
    "file_name": "deoxys_i_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "fill_aad_header",
    "statement_type": "function",
    "deps": [],
    "body": "fn fill_aad_header(adata_len: usize) -> (usize, Array<u8, U16>) {\n    debug_assert_ne!(adata_len, 0);\n\n    let mut b = Array::<u8, U16>::default();\n    let n = if adata_len < 0xFF00 {\n        b[..2].copy_from_slice(&(adata_len as u16).to_be_bytes());\n        2\n    } else if adata_len <= u32::MAX as usize {\n        b[0] = 0xFF;\n        b[1] = 0xFE;\n        b[2..6].copy_from_slice(&(adata_len as u32).to_be_bytes());\n        6\n    } else {\n        b[0] = 0xFF;\n        b[1] = 0xFF;\n        b[2..10].copy_from_slice(&(adata_len as u64).to_be_bytes());\n        10\n    };\n    (n, b)\n}",
    "display_name": "fill_aad_header",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_256_2",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_256_2() {\n    let plaintext = Vec::new();\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"54708ae5565a71f147bdb94d7ba3aed7\");\n\n    let encrypted = DeoxysII256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_ii_256_2",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_256.rs",
    "relative_path": "deoxys/tests/deoxys_ii_256.rs",
    "file_name": "deoxys_ii_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_i_128_8",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_128_8() {\n    let plaintext = hex!(\n        \"1857d4edf080e8e2c83aa9e794ebf90d1ea0ccb977287a019aca3daa7af2ad5709d63f05\"\n        \"b5b00f4b004b56e802d298ea78afd5d21fd2619248a0897b8e141dc6e1f8b49056d57057\"\n        \"1a294152a7d7387dbac1ab9ff799dbe0e6c3ae23a14908a3e48eb224824eee8ea4ee3b4a\"\n        \"b1bd12a81e3a393ca1344fd9ca5309b116ab2e49e12020f1d6d3bbf608c4e33472c33c6a\"\n        \"8d088124c0de4161d94833d75a9bfde908d57d182675c992ad8545198ad2565bac43ce17\"\n        \"86e92ec01961c424c1b4c23bc97959ed185193c08e49c6741061e300c94216e505569bcc\"\n        \"528f4ced786d1939b4568be157a4b9231b1baf19fc90ee35e97dbfb2965468c2882f1706\"\n        \"c6ccec31be7759640c4a2a8a22ecac433eba2223d9685215a8e12bf262f4a72a8bb85ef4\"\n        \"181b1d513218a657a24f2903da166f06abd27fbd757ad87473deb844c24e7f7a92952995\"\n        \"80bdb1a99acf53a2cc3b1234fb9b0976b6b0ae42605536f46239d1ebd1283adf41f25076\"\n        \"1d54280e65d79e16200b16d899702530314c6eb5bcb0f1de6d61eaa7ea4c097075ac6917\"\n        \"54cb1eebbe7ff8cfc39000d9eca154ea37a9d635385b1e132ac3a0d3ffdc362b4333db6b\"\n        \"56960cd0d86d02f08ea6e6e1e20a12b7d0b0fe897ab2fcb43f44afb2d42326b2d8d0531e\"\n        \"6c9c64aae896caa74299c6d8e10a45360d67373aae7326a1b0484aa42e970510ecb02ca7\"\n        \"39c38183a43881e6\"\n    );\n\n    let aad = hex!(\n        \"d4e7fc007c9f462d3c2f3ee1c2b92597a838be68930fcc770d3f4a6e8d3f245567c28772\"\n        \"c7891c8a605e3f64dd584c264685794c23458c0faf8bbfc5925fe8278eaa1f35322b78c2\"\n        \"7fcfad42da7f1e9c4ab3aea98c236846690eeb63a26eb60f4cdaef83c3941b57b8152970\"\n        \"4e404444ed541269428baecd17f4e7f3bde62566b65b578eba069990e8fb10696d94e925\"\n        \"ec41b9142de25cd30750cabd41d0a100bebe5eeada44caabff9ede3c251bb57bb48dfb90\"\n        \"f7bb9f7d82f131ee20788ff3d9435f8c4f1590cd3cf2dbda143d8a6bcec5e95834578d46\"\n        \"561ea209b4d29b1bb74c2c5d1f1bb765cd1d3a1e95984e7f257f4a8a91b3d3d587b43a40\"\n        \"23593948d0a58fb1be920f493e5615abd2ecd38f45ed8c440c427a0d2eb76f91adee4c11\"\n        \"9ac980f28d87585a68039761dbea738a006ec0d9a7dde2ea873c4cf27c8b3565d776473f\"\n        \"247b30198e62d4bc722b84d6260bb9e4b8c36dbf1ce6a2b91211bc25d1c0797c5b992920\"\n        \"810e78ea6e474f69c9f14550eac375e896a2e5facebcf97bbf5bfdb547ef202222693b4c\"\n        \"3120fe8a9559bee514e0b6d9a711a632a7d55398ddd8de66ef3b6f8dd8fa468d27ca455a\"\n        \"5fcda20dd12aa426053e9f8454d9598e2d6a528aa4ffe272a4f1341e695dbb1b43bd720a\"\n        \"b87ba62290e2d3f78a497a20d1bb0ed72430698b857774d6414ca856019660aba783ff97\"\n        \"94d395c82de41a031a\"\n    );\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext = hex!(\n        \"f86ecad0d69d2c573cdeee96c90f37ac3c861bd5f4d82ac7396dda102adfa7a94f1daab1\"\n        \"e537f03b2a6665eaa8ee057eee403db7ced61adbd77b5c286b7afc5ec23f3f9333773f02\"\n        \"d533b0c49ecfc6bcd359bc8a3db6ab16b423efc93e2591e5485a5b21a8cf9312a10d76c8\"\n        \"40bd1a7e9f5a9954cb636b01ebc8e91a550a0123a50883627d5535f0f6a7960f005d5f34\"\n        \"0e054ea145dd756e37efd91bc774f93d385da7135372bc51d0401e6499784618da55c31e\"\n        \"0b7ad1aa09a3e002f3021ce02926c79741992d9d0252761a7ca6667a56f78e81eaf08cf3\"\n        \"6d4117d9b2349262d411bef955d7408562ed040e1ea85e3aa3dcf942ea5205edec164dbd\"\n        \"6304f90da59b9fb4f8fdeb2c2df473f90494cf09c6af69d191abd7baf97058a3694872d0\"\n        \"1f63afc225e3796251375a7520a5f755b24b8fd153f362ff09c7e85f02e789ed8cf8adab\"\n        \"fcde4c764ebdd703dee39b4e90a91ab0377e0bebc61b2ec9b3c4e3ac7fd893e13c5d0e30\"\n        \"3e7e625281c988a48dcfd9ee4b698a1c2a82927168e754c99338ea24d24b9bba11cdb447\"\n        \"2badc038ab01f250d359c4ade703329062c6260d8fcfda3a6b50b641f9e1e5f2107fd6ca\"\n        \"77140dba9048919cab4ea21e4178fde08e7213bf0b730c0415331775039e99f11146b0eb\"\n        \"b99a8f5f2d2c4e1767b6fed9c7140dfcf01c793e88889cf34b4ecb044fc740f3d4a2cad1\"\n        \"f93455cc36b9a0c6\"\n    );\n\n    let tag: [u8; 16] = hex!(\"5c89d78dbef3d727013b59af859f17da\");\n\n    let encrypted = DeoxysI128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_128_8",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_128.rs",
    "relative_path": "deoxys/tests/deoxys_i_128.rs",
    "file_name": "deoxys_i_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "ghash/impl/GHash/UhfBackend/proc_block",
    "statement_type": "function",
    "deps": [
      "gf/gf128_soft64/impl/Element/From, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>>>/from"
    ],
    "body": "    fn proc_block(&mut self, x: &Block) {\n        self.s = (self.s + Element::from(x)) * self.h;\n    }",
    "display_name": "proc_block",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/ghash.rs",
    "relative_path": "belt-dwp/src/ghash.rs",
    "file_name": "ghash.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "siv/impl/Siv/decrypt",
    "statement_type": "function",
    "deps": [
      "siv/impl/Siv/decrypt_in_place"
    ],
    "body": "    pub fn decrypt<I, T>(&mut self, headers: I, ciphertext: &[u8]) -> Result<Vec<u8>, Error>\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,\n    {\n        let mut buffer = ciphertext.to_vec();\n        self.decrypt_in_place(headers, &mut buffer)?;\n        Ok(buffer)\n    }",
    "display_name": "decrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/AesGcm/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/AesGcm/init_ctr",
      "impl/AesGcm/compute_tag"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce<NonceSize>,\n        associated_data: &[u8],\n        mut buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag<TagSize>, Error> {\n        if buffer.len() as u64 > P_MAX || associated_data.len() as u64 > A_MAX {\n            return Err(Error);\n        }\n\n        let (ctr, mask) = self.init_ctr(nonce);\n\n        // TODO(tarcieri): interleave encryption with GHASH\n        // See: <https://github.com/RustCrypto/AEADs/issues/74>\n        ctr.apply_keystream_partial(buffer.reborrow());\n\n        let full_tag = self.compute_tag(mask, associated_data, buffer.get_out());\n        Ok(Tag::try_from(&full_tag[..TagSize::to_usize()]).expect(\"tag size mismatch\"))\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/src/lib.rs",
    "relative_path": "aes-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Deoxys/KeyInit/new",
    "statement_type": "function",
    "deps": [
      "DeoxysBcType/precompute_subkeys"
    ],
    "body": "    fn new(key: &Key<Self>) -> Self {\n        Self {\n            subkeys: B::precompute_subkeys(key),\n            mode: PhantomData,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/CbcMac/finalize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn finalize(self) -> Block<C> {\n        self.state\n    }",
    "display_name": "finalize",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "modes/impl/DeoxysII/authenticate_message",
    "statement_type": "function",
    "deps": [
      "DeoxysBcType/encrypt_inout"
    ],
    "body": "    fn authenticate_message(\n        buffer: &[u8],\n        tweak: &mut Tweak,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n        tag: &mut Tag,\n    ) {\n        if buffer.is_empty() {\n            return;\n        }\n        tweak[0] = TWEAK_M;\n\n        let (chunks, tail) = Block::slice_as_chunks(buffer);\n\n        for (index, data) in chunks.iter().enumerate() {\n            // Copy block number\n            tweak[8..].copy_from_slice(&(index as u64).to_be_bytes());\n\n            let mut block = *data;\n\n            B::encrypt_inout((&mut block).into(), tweak, subkeys);\n\n            for (t, b) in tag.iter_mut().zip(block.iter()) {\n                *t ^= b;\n            }\n        }\n\n        let index = chunks.len();\n        let data = tail;\n        if data.is_empty() {\n            return;\n        }\n\n        // Copy block number\n        tweak[8..].copy_from_slice(&(index as u64).to_be_bytes());\n\n        // Last block\n        tweak[0] = TWEAK_M_LAST;\n\n        let mut block = Block::default();\n        block[0..data.len()].copy_from_slice(data);\n\n        block[data.len()] = 0x80;\n\n        B::encrypt_inout((&mut block).into(), tweak, subkeys);\n\n        for (t, b) in tag.iter_mut().zip(block.iter()) {\n            *t ^= b;\n        }\n    }",
    "display_name": "authenticate_message",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/modes.rs",
    "relative_path": "deoxys/src/modes.rs",
    "file_name": "modes.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre key_dependent_variables",
    "statement_type": "function",
    "deps": [],
    "body": "fn key_dependent_variables<Cipher: BlockSizeUser<BlockSize = U16> + BlockCipherEncrypt>(\n    cipher: &Cipher,\n) -> (Block, Block, [Block; L_TABLE_SIZE]) {\n    let mut ll_star = Block::default();\n    cipher.encrypt_block(&mut ll_star);\n    let ll_dollar = ll_star.dbl();\n\n    let mut ll = [Block::default(); L_TABLE_SIZE];\n    let mut ll_i = ll_dollar;\n    #[allow(clippy::needless_range_loop)]\n    for i in 0..L_TABLE_SIZE {\n        ll_i = ll_i.dbl();\n        ll[i] = ll_i\n    }\n    (ll_star, ll_dollar, ll)\n}",
    "display_name": "key_dependent_variables",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "DeoxysBcType/decrypt_inout",
    "statement_type": "function",
    "deps": [
      "deoxys_bc/DeoxysBcInternal/key_schedule"
    ],
    "body": "    fn decrypt_inout(\n        mut block: InOut<'_, '_, Block>,\n        tweak: &Tweak,\n        subkeys: &Array<DeoxysKey, Self::SubkeysSize>,\n    ) {\n        let mut keys = Self::key_schedule(tweak, subkeys);\n\n        let r = keys.len();\n\n        block.xor_in2out(&keys[r - 1]);\n\n        aes::hazmat::inv_mix_columns(block.get_out());\n\n        for k in keys[..r - 1].iter_mut().rev() {\n            aes::hazmat::inv_mix_columns(k);\n            aes::hazmat::equiv_inv_cipher_round(block.get_out(), k);\n        }\n\n        aes::hazmat::mix_columns(block.get_out());\n    }",
    "display_name": "decrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Encryptor/encrypt_last",
    "statement_type": "function",
    "deps": [],
    "body": "    encrypt_last,\n    encrypt_last_in_place,\n    encrypt,\n    encrypt_in_place,\n    \"encrypt\",\n    \"‚Ñ∞ STREAM encryptor\"\n);\n\nimpl_stream_object!(\n    Decryptor,\n    decrypt_next,\n    decrypt_next_in_place,\n    decrypt_last,\n    decrypt_last_in_place,\n    decrypt,\n    decrypt_in_place,\n    \"decrypt\",\n    \"ùíü STREAM decryptor\"\n);\n\n/// STREAM encryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type EncryptorBE32<A> = Encryptor<A, StreamBE32<A>>;\n\n/// STREAM decryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type DecryptorBE32<A> = Decryptor<A, StreamBE32<A>>;\n\n/// STREAM encryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type EncryptorLE31<A> = Encryptor<A, StreamLE31<A>>;\n\n/// STREAM decryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type DecryptorLE31<A> = Decryptor<A, StreamLE31<A>>;\n\n/// The original \"Rogaway-flavored\" STREAM as described in the paper\n/// [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance][1].\n///\n/// Uses a 32-bit big endian counter and 1-byte \"last block\" flag stored as\n/// the last 5-bytes of the AEAD nonce.\n///\n/// [1]: https://eprint.iacr.org/2015/189.pdf\n#[derive(Debug)]\npub struct StreamBE32<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<U5>,\n    <<A as AeadCore>::NonceSize as Sub<U5>>::Output: ArraySize,\n{\n    /// Underlying AEAD cipher\n    aead: A,\n\n    /// Nonce (sans STREAM overhead)\n    nonce: Nonce<A, Self>,\n}",
    "display_name": "encrypt_last",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Cipher/new",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn new(key_generating_key: &Aes, nonce: &Nonce) -> Self {\n        let mut mac_key = polyval::Key::default();\n        let mut enc_key = Array::default();\n        let mut block = cipher::Block::<Aes>::default();\n        let mut counter = 0u32;\n\n        // Derive subkeys from the master key-generating-key in counter mode.\n        //\n        // From RFC8452 ¬ß 4: <https://tools.ietf.org/html/rfc8452#section-4>\n        //\n        // > The message-authentication key is 128 bit, and the message-encryption\n        // > key is either 128 (for AES-128) or 256 bit (for AES-256).\n        // >\n        // > These keys are generated by encrypting a series of plaintext blocks\n        // > that contain a 32-bit, little-endian counter followed by the nonce,\n        // > and then discarding the second half of the resulting ciphertext.  In\n        // > the AES-128 case, 128 + 128 = 256 bits of key material need to be\n        // > generated, and, since encrypting each block yields 64 bits after\n        // > discarding half, four blocks need to be encrypted.  The counter\n        // > values for these blocks are 0, 1, 2, and 3.  For AES-256, six blocks\n        // > are needed in total, with counter values 0 through 5 (inclusive).\n        for derived_key in &mut [mac_key.as_mut_slice(), enc_key.as_mut_slice()] {\n            for chunk in derived_key.chunks_mut(8) {\n                block[..4].copy_from_slice(&counter.to_le_bytes());\n                block[4..].copy_from_slice(nonce.as_slice());\n\n                key_generating_key.encrypt_block(&mut block);\n                chunk.copy_from_slice(&block.as_slice()[..8]);\n\n                counter += 1;\n            }\n        }\n\n        let result = Self {\n            enc_cipher: Aes::new(&enc_key),\n            polyval: Polyval::new(&mac_key),\n            nonce: *nonce,\n        };\n\n        // Zeroize all intermediate buffers\n        // TODO(tarcieri): use `Zeroizing` when const generics land\n        #[cfg(feature = \"zeroize\")]\n        {\n            use zeroize::Zeroize;\n            mac_key.as_mut_slice().zeroize();\n            enc_key.as_mut_slice().zeroize();\n            block.as_mut_slice().zeroize();\n        }\n\n        result\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ghash/impl/GHash/Reset/reset",
    "statement_type": "function",
    "deps": [],
    "body": "    fn reset(&mut self) {\n        self.s = Element::default();\n    }",
    "display_name": "reset",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/ghash.rs",
    "relative_path": "belt-dwp/src/ghash.rs",
    "file_name": "ghash.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_256_4",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_256_4() {\n    let plaintext = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"0001020304050607\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext = hex!(\"2c36c041fa3b1436c5153214131d493be9d014689a6a1e93e4a50989f0342941\");\n\n    let tag: [u8; 16] = hex!(\"ae66f78a3abf1bb7608c6fe949effb57\");\n\n    let encrypted = DeoxysI256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_256_4",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_256.rs",
    "relative_path": "deoxys/tests/deoxys_i_256.rs",
    "file_name": "deoxys_i_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.1.0_pre impl/AsconAead128/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre impl/Ascon/AeadInOut/encrypt_inout_detached"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce<Self>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag<Self>, Error> {\n        self.0\n            .encrypt_inout_detached(nonce, associated_data, buffer)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/lib.rs",
    "relative_path": "ascon-aead128/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/SivAead/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "siv/impl/Siv/KeyInit/new",
      "siv/impl/Siv/encrypt_inout_detached"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Array<u8, Self::TagSize>, Error> {\n        Siv::<C, M>::new(&self.key)\n            .encrypt_inout_detached([associated_data, nonce.as_slice()], buffer)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/lib.rs",
    "relative_path": "aes-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/AesGcm/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/AesGcm/init_ctr",
      "impl/AesGcm/compute_tag"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce<NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag<TagSize>,\n    ) -> Result<(), Error> {\n        if buffer.len() as u64 > C_MAX || associated_data.len() as u64 > A_MAX {\n            return Err(Error);\n        }\n\n        let (ctr, mask) = self.init_ctr(nonce);\n\n        // TODO(tarcieri): interleave encryption with GHASH\n        // See: <https://github.com/RustCrypto/AEADs/issues/74>\n        let expected_tag = self.compute_tag(mask, associated_data, buffer.get_in());\n\n        use subtle::ConstantTimeEq;\n        if expected_tag[..TagSize::to_usize()].ct_eq(tag).into() {\n            ctr.apply_keystream_partial(buffer);\n            Ok(())\n        } else {\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/src/lib.rs",
    "relative_path": "aes-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_4_7",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_4_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes256_12_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_12_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/Dwp/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "get_sizes_block",
      "ghash/impl/GHash/new_with_init_block"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce,\n        associated_data: &[u8],\n        mut buffer: InOutBuf<'_, '_, u8>,\n    ) -> aead::Result<Tag<Self>> {\n        let sizes_block = get_sizes_block(associated_data.len(), buffer.len());\n\n        // 2.1. ùë† ‚Üê belt-block(ùëÜ, ùêæ);\n        let mut s = *nonce;\n        self.cipher.encrypt_block(&mut s);\n\n        // 2.2. ùëü ‚Üê belt-block(ùë†, ùêæ);\n        let mut r = s;\n        self.cipher.encrypt_block(&mut r);\n\n        // Initialize GHash\n        let mut ghash = GHash::new_with_init_block(&r, T);\n\n        // Initialize CTR mode\n        let core = BeltCtrCore::inner_iv_init(&self.cipher, nonce);\n        let mut enc_cipher = BeltCtr::from_core(core);\n\n        // 3. For ùëñ = 1, 2, . . . , ùëö do:\n        //  3.1 ùë° ‚Üê ùë° ‚äï (ùêºùëñ ‚Äñ 0^{128‚àí|ùêºùëñ|})\n        //  3.2 ùë° ‚Üê ùë° * ùëü.\n        ghash.update_padded(associated_data);\n\n        // 4. For ùëñ = 1, 2, . . . , ùëõ do:\n        //  4.1 ùë† ‚Üê ùë† ‚äû ‚ü®1‚ü©_128\n        //  4.2 ùëåùëñ ‚Üê ùëãùëñ ‚äï Lo(belt-block(ùë†, ùêæ), |ùëãùëñ|)\n        //  4.3 ùë° ‚Üê ùë° ‚äï (ùëåùëñ ‚Äñ 0^{128‚àí|ùëåùëñ|})\n        //  4.4 ùë° ‚Üê ùë° * ùëü.\n        enc_cipher.apply_keystream_inout(buffer.reborrow());\n        ghash.update_padded(buffer.get_out());\n\n        // 5. ùë° ‚Üê ùë° ‚äï (‚ü®|ùêº|‚ü©_64 ‚Äñ ‚ü®|ùëã|‚ü©_64)\n        ghash.update_padded(&sizes_block);\n\n        // 6. ùë° ‚Üê belt-block(ùë° * ùëü, ùêæ).\n        let mut tag = ghash.finalize_reset();\n        self.cipher.encrypt_block(&mut tag);\n\n        let tag = &tag[..TagSize::USIZE];\n        Ok(tag.try_into().expect(\"Tag is always 8 bytes\"))\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/lib.rs",
    "relative_path": "belt-dwp/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/process_decrypt_inout",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/clear",
      "0.1.0_pre asconcore/pad",
      "0.1.0_pre asconcore/impl/AsconCore/permute_state",
      "0.1.0_pre asconcore/u64_from_bytes",
      "0.1.0_pre asconcore/u64_from_bytes_partial"
    ],
    "body": "    fn process_decrypt_inout(&mut self, ciphertext: InOutBuf<'_, '_, u8>) {\n        let (blocks, mut last_block) = ciphertext.into_chunks::<U16>();\n        for mut block in blocks {\n            // process full block of ciphertext\n            let cx = u64_from_bytes(&block.get_in()[..8]);\n            block.get_out()[..8].copy_from_slice(&u64::to_le_bytes(self.state[0] ^ cx));\n            self.state[0] = cx;\n            let cx = u64_from_bytes(&block.get_in()[8..16]);\n            block.get_out()[8..16].copy_from_slice(&u64::to_le_bytes(self.state[1] ^ cx));\n            self.state[1] = cx;\n            self.permute_state();\n        }\n\n        // process partial block if it exists\n        let sidx = if last_block.len() >= 8 {\n            let cx = u64_from_bytes(&last_block.get_in()[..8]);\n            last_block.get_out()[..8].copy_from_slice(&u64::to_le_bytes(self.state[0] ^ cx));\n            self.state[0] = cx;\n            (_, last_block) = last_block.split_at(8);\n            1\n        } else {\n            0\n        };\n        self.state[sidx] ^= pad(last_block.len());\n        if !last_block.is_empty() {\n            let cx = u64_from_bytes_partial(last_block.get_in());\n            self.state[sidx] ^= cx;\n            let last_block_len = last_block.len();\n            last_block\n                .get_out()\n                .copy_from_slice(&u64::to_le_bytes(self.state[sidx])[0..last_block_len]);\n            self.state[sidx] = clear(self.state[sidx], last_block.len()) ^ cx;\n        }\n    }",
    "display_name": "process_decrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gf/utils/bmul64",
    "statement_type": "function",
    "deps": [],
    "body": "pub(super) fn bmul64(x: u64, y: u64) -> u128 {\n    let x0 = Wrapping((x & 0x1111_1111_1111_1111) as u128);\n    let x1 = Wrapping((x & 0x2222_2222_2222_2222) as u128);\n    let x2 = Wrapping((x & 0x4444_4444_4444_4444) as u128);\n    let x3 = Wrapping((x & 0x8888_8888_8888_8888) as u128);\n    let y0 = Wrapping((y & 0x1111_1111_1111_1111) as u128);\n    let y1 = Wrapping((y & 0x2222_2222_2222_2222) as u128);\n    let y2 = Wrapping((y & 0x4444_4444_4444_4444) as u128);\n    let y3 = Wrapping((y & 0x8888_8888_8888_8888) as u128);\n\n    let mut z0 = ((x0 * y0) ^ (x1 * y3) ^ (x2 * y2) ^ (x3 * y1)).0;\n    let mut z1 = ((x0 * y1) ^ (x1 * y0) ^ (x2 * y3) ^ (x3 * y2)).0;\n    let mut z2 = ((x0 * y2) ^ (x1 * y1) ^ (x2 * y0) ^ (x3 * y3)).0;\n    let mut z3 = ((x0 * y3) ^ (x1 * y2) ^ (x2 * y1) ^ (x3 * y0)).0;\n\n    z0 &= 0x1111_1111_1111_1111_1111_1111_1111_1111;\n    z1 &= 0x2222_2222_2222_2222_2222_2222_2222_2222;\n    z2 &= 0x4444_4444_4444_4444_4444_4444_4444_4444;\n    z3 &= 0x8888_8888_8888_8888_8888_8888_8888_8888;\n\n    z0 | z1 | z2 | z3\n}",
    "display_name": "bmul64",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/utils.rs",
    "relative_path": "belt-dwp/src/gf/utils.rs",
    "file_name": "utils.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Element/From, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>>>/from",
    "statement_type": "function",
    "deps": [
      "gf/gf128_soft64/from_block"
    ],
    "body": "    fn from(block: &Block) -> Self {\n        let [a, b] = from_block(block);\n        Self(a, b)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "cavp_ccm_aes192_10_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_10_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.1.0_pre impl/Ascon/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/impl/AsconCore/new",
      "0.1.0_pre asconcore/impl/AsconCore/encrypt_inout"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce<Self>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag<Self>, Error> {\n        if (buffer.len() as u64)\n            .checked_add(associated_data.len() as u64)\n            .is_none()\n        {\n            return Err(Error);\n        }\n\n        let mut core = AsconCore::<P>::new(&self.key, nonce);\n        Ok(core.encrypt_inout(buffer, associated_data))\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/lib.rs",
    "relative_path": "ascon-aead128/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_128_7",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_128_7() {\n    let plaintext = hex!(\"ee8f487e01f5a101dee6cfd5915d6b5b2c5b6305c782bc7e727bd08096e4208216\");\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f10\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: [u8; 33] =\n        hex!(\"09af865850abc0bce7d35f664a63e41b1475d0385e31a6551edf69ea9f2f8b8ed4\");\n\n    let tag: [u8; 16] = hex!(\"9326c6c2a0b7f065e591eb9050169603\");\n\n    let encrypted = DeoxysI128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_128_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_128.rs",
    "relative_path": "deoxys/tests/deoxys_i_128.rs",
    "file_name": "deoxys_i_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/AesGcmSiv/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/Cipher/encrypt_inout_detached",
      "impl/Cipher/new"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag, Error> {\n        Cipher::<Aes>::new(&self.key_generating_key, nonce)\n            .encrypt_inout_detached(associated_data, buffer)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "get_sizes_block",
    "statement_type": "function",
    "deps": [],
    "body": "fn get_sizes_block(aad_len: usize, msg_len: usize) -> Block<GHash> {\n    let aad_bit_len = aad_len as u64 * 8;\n    let msg_bit_len = msg_len as u64 * 8;\n\n    let mut sizes_block: Block<GHash> = Default::default();\n\n    sizes_block[..8].copy_from_slice(&aad_bit_len.to_le_bytes());\n    sizes_block[8..].copy_from_slice(&msg_bit_len.to_le_bytes());\n\n    sizes_block\n}",
    "display_name": "get_sizes_block",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/lib.rs",
    "relative_path": "belt-dwp/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "modes/impl/DeoxysI/DeoxysMode/encrypt_inout",
    "statement_type": "function",
    "deps": [
      "DeoxysBcType/encrypt_inout",
      "modes/DeoxysModeInternal/compute_ad_tag"
    ],
    "body": "    fn encrypt_inout(\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n    ) -> Tag {\n        let mut tag = Tag::default();\n        let mut checksum = Checksum::default();\n        let mut tweak = Tweak::default();\n\n        // Associated Data\n        <Self as DeoxysModeInternal<B>>::compute_ad_tag(\n            associated_data,\n            &mut tweak,\n            subkeys,\n            &mut tag,\n        );\n\n        // Add the nonce to the tweak\n        tweak[0] = nonce[0] >> 4;\n        for i in 1..nonce.len() {\n            tweak[i] = (nonce[i - 1] << 4) | (nonce[i] >> 4);\n        }\n\n        tweak[8] = nonce[7] << 4;\n\n        // Message authentication and encryption\n\n        tweak[0] = (tweak[0] & 0xf) | TWEAK_M;\n\n        let (data_blocks, mut tail) = buffer.into_chunks();\n        let mut data_blocks_len = data_blocks.len();\n\n        for (index, data) in data_blocks.into_iter().enumerate() {\n            // Copy block number\n            let tmp = tweak[8] & 0xf0;\n            tweak[8..].copy_from_slice(&(index as u64).to_be_bytes());\n            tweak[8] = (tweak[8] & 0xf) | tmp;\n\n            for (c, d) in checksum.iter_mut().zip(data.get_in().iter()) {\n                *c ^= d;\n            }\n\n            B::encrypt_inout(data, &tweak, subkeys);\n        }\n\n        // Process incomplete last block\n        if !tail.is_empty() {\n            // Copy block number\n            let tmp = tweak[8] & 0xf0;\n            tweak[8..].copy_from_slice(&(data_blocks_len as u64).to_be_bytes());\n            tweak[8] = (tweak[8] & 0xf) | tmp;\n\n            // Last block checksum\n            tweak[0] = (tweak[0] & 0xf) | TWEAK_M_LAST;\n\n            let mut block = Block::default();\n            block[..tail.len()].copy_from_slice(tail.get_in());\n\n            block[tail.len()] = 0x80;\n\n            for (c, d) in checksum.iter_mut().zip(block.iter()) {\n                *c ^= d;\n            }\n\n            block.fill(0);\n\n            // Last block encryption\n            B::encrypt_inout((&mut block).into(), &tweak, subkeys);\n\n            tail.xor_in2out((block[..tail.len()]).into());\n\n            data_blocks_len += 1;\n        };\n\n        // Tag computing.\n        let t = if tail.is_empty() {\n            TWEAK_TAG\n        } else {\n            TWEAK_CHKSUM\n        };\n        tweak[0] = (tweak[0] & 0xf) | t;\n        let tmp = tweak[8] & 0xf0;\n        tweak[8..].copy_from_slice(&(data_blocks_len as u64).to_be_bytes());\n        tweak[8] = (tweak[8] & 0xf) | tmp;\n\n        B::encrypt_inout((&mut checksum).into(), tweak.as_ref(), subkeys);\n        for (t, c) in tag.iter_mut().zip(checksum.iter()) {\n            *t ^= c;\n        }\n\n        tag\n    }",
    "display_name": "encrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/modes.rs",
    "relative_path": "deoxys/src/modes.rs",
    "file_name": "modes.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/AesGcmSiv/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(key_generating_key: Aes) -> Self {\n        Self { key_generating_key }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Encryptor/encrypt_next",
    "statement_type": "function",
    "deps": [],
    "body": "    encrypt_next,\n    encrypt_next_in_place,\n    encrypt_last,\n    encrypt_last_in_place,\n    encrypt,\n    encrypt_in_place,\n    \"encrypt\",\n    \"‚Ñ∞ STREAM encryptor\"\n);\n\nimpl_stream_object!(\n    Decryptor,\n    decrypt_next,\n    decrypt_next_in_place,\n    decrypt_last,\n    decrypt_last_in_place,\n    decrypt,\n    decrypt_in_place,\n    \"decrypt\",\n    \"ùíü STREAM decryptor\"\n);\n\n/// STREAM encryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type EncryptorBE32<A> = Encryptor<A, StreamBE32<A>>;\n\n/// STREAM decryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type DecryptorBE32<A> = Decryptor<A, StreamBE32<A>>;\n\n/// STREAM encryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type EncryptorLE31<A> = Encryptor<A, StreamLE31<A>>;\n\n/// STREAM decryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type DecryptorLE31<A> = Decryptor<A, StreamLE31<A>>;\n\n/// The original \"Rogaway-flavored\" STREAM as described in the paper\n/// [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance][1].\n///\n/// Uses a 32-bit big endian counter and 1-byte \"last block\" flag stored as\n/// the last 5-bytes of the AEAD nonce.\n///\n/// [1]: https://eprint.iacr.org/2015/189.pdf\n#[derive(Debug)]\npub struct StreamBE32<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<U5>,\n    <<A as AeadCore>::NonceSize as Sub<U5>>::Output: ArraySize,\n{\n    /// Underlying AEAD cipher\n    aead: A,\n\n    /// Nonce (sans STREAM overhead)\n    nonce: Nonce<A, Self>,\n}",
    "display_name": "encrypt_next",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_256_1",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_256_1() {\n    let plaintext = Vec::new();\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"2b97bd77712f0cde975309959dfe1d7c\");\n\n    let encrypted = DeoxysII256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_ii_256_1",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_256.rs",
    "relative_path": "deoxys/tests/deoxys_ii_256.rs",
    "file_name": "deoxys_ii_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.1.0_pre impl/Ascon/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &Key<Self>) -> Self {\n        Self {\n            key: P::InternalKey::from(key),\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/lib.rs",
    "relative_path": "ascon-aead128/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_128_6",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_128_6() {\n    let plaintext = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: [u8; 32] =\n        hex!(\"9cdb554dfc03bff4feeb94df7736038361a76532b6b5a9c0bdb64a74dee983ff\");\n\n    let tag: [u8; 16] = hex!(\"bc1a7b5b8e961e65ceff6877ef9e4a98\");\n\n    let encrypted = DeoxysII128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_128_6",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_128.rs",
    "relative_path": "deoxys/tests/deoxys_ii_128.rs",
    "file_name": "deoxys_ii_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/AesGcm/init_ctr",
    "statement_type": "function",
    "deps": [],
    "body": "    fn init_ctr(&self, nonce: &Nonce<NonceSize>) -> (Ctr32BE<&Aes>, Block) {\n        let j0 = if NonceSize::to_usize() == 12 {\n            let mut block = ghash::Block::default();\n            block[..12].copy_from_slice(nonce);\n            block[15] = 1;\n            block\n        } else {\n            let mut ghash = self.ghash.clone();\n            ghash.update_padded(nonce);\n\n            let mut block = ghash::Block::default();\n            let nonce_bits = (NonceSize::to_usize() as u64) * 8;\n            block[8..].copy_from_slice(&nonce_bits.to_be_bytes());\n            ghash.update(&[block]);\n            ghash.finalize()\n        };\n\n        let mut ctr = Ctr32BE::inner_iv_init(&self.cipher, &j0);\n        let mut tag_mask = Block::default();\n        ctr.write_keystream_block(&mut tag_mask);\n        (ctr, tag_mask)\n    }",
    "display_name": "init_ctr",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/src/lib.rs",
    "relative_path": "aes-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/EaxImpl/tag_clone",
    "statement_type": "function",
    "deps": [],
    "body": "    fn tag_clone(&self) -> Tag<M> {\n        let h = self.data.clone().finalize().into_bytes();\n        let c = self.message.clone().finalize().into_bytes();\n\n        let full_tag: Array<_, Cipher::BlockSize> = self\n            .nonce\n            .into_iter()\n            .zip(h)\n            .map(|(a, b)| a ^ b)\n            .zip(c)\n            .map(|(a, b)| a ^ b)\n            .take(Cipher::BlockSize::to_usize())\n            .collect();\n\n        Tag::<M>::try_from(&full_tag[..M::to_usize()]).expect(\"tag size mismatch\")\n    }",
    "display_name": "tag_clone",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_16_9",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_16_9",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.1.0_pre impl/AsconAead128/KeyInit/new",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre impl/Ascon/KeyInit/new"
    ],
    "body": "    fn new(key: &Key<Self>) -> Self {\n        Self(Ascon::<Parameters128>::new(key))\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/lib.rs",
    "relative_path": "ascon-aead128/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre tests/rfc7253_key_dependent_constants",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre key_dependent_variables"
    ],
    "body": "    fn rfc7253_key_dependent_constants() {\n        // Test vector from page 17 of https://www.rfc-editor.org/rfc/rfc7253.html\n        let key = hex!(\"000102030405060708090A0B0C0D0E0F\");\n        let expected_ll_star = Block::from(hex!(\"C6A13B37878F5B826F4F8162A1C8D879\"));\n        let expected_ll_dollar = Block::from(hex!(\"8D42766F0F1EB704DE9F02C54391B075\"));\n        let expected_ll0 = Block::from(hex!(\"1A84ECDE1E3D6E09BD3E058A8723606D\"));\n        let expected_ll1 = Block::from(hex!(\"3509D9BC3C7ADC137A7C0B150E46C0DA\"));\n\n        let cipher = aes::Aes128::new(key.as_ref());\n        let (ll_star, ll_dollar, ll) = key_dependent_variables(&cipher);\n\n        assert_eq!(ll_star, expected_ll_star);\n        assert_eq!(ll_dollar, expected_ll_dollar);\n        assert_eq!(ll[0], expected_ll0);\n        assert_eq!(ll[1], expected_ll1);\n    }",
    "display_name": "rfc7253_key_dependent_constants",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes192_16_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_16_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.1.0_pre asconcore/clear",
    "statement_type": "function",
    "deps": [],
    "body": "const fn clear(word: u64, n: usize) -> u64 {\n    word & (0x00ffffffffffffff << (n * 8))\n}",
    "display_name": "clear",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/InternalKey16/InternalKey, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>>/",
    "statement_type": "function",
    "deps": [],
    "body": "    fn get_k1(&self) -> u64 {\n        self.0\n    }",
    "display_name": "get_k1",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_6_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_6_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/Eax/cmac_with_iv",
    "statement_type": "function",
    "deps": [],
    "body": "    fn cmac_with_iv(key: &Array<u8, Cipher::KeySize>, iv: u8, data: &[u8]) -> Output<Cmac<Cipher>> {\n        let mut mac = <Cmac<Cipher> as KeyInit>::new(key);\n        mac.update(&[0; 15]);\n        mac.update(&[iv]);\n        mac.update(data);\n\n        mac.finalize().into_bytes()\n    }",
    "display_name": "cmac_with_iv",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/lib.rs",
    "relative_path": "eax/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Deoxys/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "DeoxysMode/encrypt_inout"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce<M::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag, Error> {\n        Ok(Tag::from(M::encrypt_inout(\n            nonce,\n            associated_data,\n            buffer,\n            &self.subkeys,\n        )))\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "DeoxysBcType/encrypt_inout",
    "statement_type": "function",
    "deps": [
      "deoxys_bc/DeoxysBcInternal/key_schedule"
    ],
    "body": "    fn encrypt_inout(\n        mut block: InOut<'_, '_, Block>,\n        tweak: &Tweak,\n        subkeys: &Array<DeoxysKey, Self::SubkeysSize>,\n    ) {\n        let keys = Self::key_schedule(tweak, subkeys);\n\n        block.xor_in2out(&keys[0]);\n\n        for k in &keys[1..] {\n            aes::hazmat::cipher_round(block.get_out(), k);\n        }\n    }",
    "display_name": "encrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_128_6",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_128_6() {\n    let plaintext = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: [u8; 32] =\n        hex!(\"4bf8c5ecec375b25acabd687aa605f1a8bb296face74f82527d4944dbb11b757\");\n\n    let tag: [u8; 16] = hex!(\"a1b897f1901e5d98e17936ec1b4d85b3\");\n\n    let encrypted = DeoxysI128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_128_6",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_128.rs",
    "relative_path": "deoxys/tests/deoxys_i_128.rs",
    "file_name": "deoxys_i_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes192_16_7",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_16_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.0.1_pre.0 impl/Xaes256Gcm/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/AesGcm/AeadInOut/decrypt_inout_detached",
      "0.0.1_pre.0 impl/Xaes256Gcm/derive_key",
      "impl/AesGcm/KeyInit/new"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n    ) -> Result<(), Error> {\n        if buffer.len() as u64 > C_MAX || associated_data.len() as u64 > A_MAX {\n            return Err(Error);\n        }\n\n        let (n1, n) = nonce.split_ref::<<NonceSize as Div<U2>>::Output>();\n        let k = self.derive_key(n1);\n        Aes256Gcm::new(&k).decrypt_inout_detached(n, associated_data, buffer, tag)\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/xaes-256-gcm/src/lib.rs",
    "relative_path": "xaes-256-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_4_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_4_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Element/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(x: u128) -> Self {\n        Self((x >> 64) as u64, x as u64)\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "0.1.0_pre ascon_aead_reference_kats",
    "statement_type": "function",
    "deps": [],
    "body": "new_pass_test!(ascon_aead_reference_kats, \"reference_kats\", AsconAead128);",
    "display_name": "ascon_aead_reference_kats",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/tests/reference_kats.rs",
    "relative_path": "ascon-aead128/tests/reference_kats.rs",
    "file_name": "reference_kats.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/wide_decrypt",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre ntz",
      "0.2.0_pre split_into_two_blocks",
      "0.2.0_pre inplace_xor",
      "0.2.0_pre initial_offset"
    ],
    "body": "    fn wide_decrypt<'i, 'o>(\n        &self,\n        nonce: &Nonce<NonceSize>,\n        buffer: InOutBuf<'i, 'o, u8>,\n    ) -> (InOutBuf<'i, 'o, u8>, usize, Block, Block) {\n        const WIDTH: usize = 2;\n\n        let mut i = 1;\n\n        let mut offset_i = [Block::default(); WIDTH];\n        offset_i[1] = initial_offset(&self.cipher, nonce, TagSize::to_u32());\n        let mut checksum_i = Block::default();\n\n        let (wide_blocks, tail): (InOutBuf<'_, '_, DoubleBlock>, _) = buffer.into_chunks();\n        for wide_block in wide_blocks.into_iter() {\n            let mut c_i = split_into_two_blocks(wide_block);\n\n            // offset_i = offset_{i-1} xor L_{ntz(i)}\n            offset_i[0] = offset_i[1];\n            inplace_xor(&mut offset_i[0], &self.ll[ntz(i)]);\n            offset_i[1] = offset_i[0];\n            inplace_xor(&mut offset_i[1], &self.ll[ntz(i + 1)]);\n\n            // p_i = offset_i xor DECIPHER(K, c_i xor offset_i)\n            // checksum_i = checksum_{i-1} xor p_i\n            for j in 0..c_i.len() {\n                c_i[j].xor_in2out(&offset_i[j]);\n                self.cipher.decrypt_block(c_i[j].get_out());\n                inplace_xor(c_i[j].get_out(), &offset_i[j]);\n                inplace_xor(&mut checksum_i, c_i[j].get_out());\n            }\n\n            i += WIDTH;\n        }\n\n        (tail, i, offset_i[offset_i.len() - 1], checksum_i)\n    }",
    "display_name": "wide_decrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_128_3",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_128_3() {\n    let plaintext = Vec::new();\n\n    let aad = hex!(\"0429974cda6665fb9bb4b67d50859258dd69883d50c1eff4bd5962bf4038ad0497\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"fbb9c589e3a54df11e8573d94e6b1000\");\n\n    let encrypted = DeoxysI128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_i_128_3",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_128.rs",
    "relative_path": "deoxys/tests/deoxys_i_128.rs",
    "file_name": "deoxys_i_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "siv/impl/Siv/Drop/drop",
    "statement_type": "function",
    "deps": [],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        {\n            use zeroize::Zeroize;\n            self.encryption_key.zeroize()\n        }\n    }",
    "display_name": "drop",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Eax/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/Eax/cmac_with_iv"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce<Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag<M>,\n    ) -> Result<(), Error> {\n        if buffer.len() as u64 > C_MAX || associated_data.len() as u64 > A_MAX {\n            return Err(Error);\n        }\n\n        // 1. n ‚Üê OMAC(0 || Nonce)\n        let n = Self::cmac_with_iv(&self.key, 0, nonce);\n\n        // 2. h ‚Üê OMAC(1 || associated data)\n        let h = Self::cmac_with_iv(&self.key, 1, associated_data);\n\n        // 4. c ‚Üê OMAC(2 || enc)\n        let c = Self::cmac_with_iv(&self.key, 2, buffer.get_in());\n\n        // 5. tag ‚Üê n ^ h ^ c\n        // (^ means xor)\n        let expected_tag: Array<_, OutputSize<Cmac<Cipher>>> = n\n            .into_iter()\n            .zip(h)\n            .map(|(a, b)| a ^ b)\n            .zip(c)\n            .map(|(a, b)| a ^ b)\n            .take(OutputSize::<Cmac<Cipher>>::to_usize())\n            .collect();\n\n        let expected_tag = &expected_tag[..tag.len()];\n\n        // Constant-time MAC comparison\n        use subtle::ConstantTimeEq;\n        if expected_tag.ct_eq(tag).into() {\n            // Decrypt\n            Ctr128BE::<Cipher>::inner_iv_init(Cipher::new(&self.key), &n)\n                .apply_keystream_partial(buffer);\n\n            Ok(())\n        } else {\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/lib.rs",
    "relative_path": "eax/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ghash/impl/GHash/UniversalHash/finalize",
    "statement_type": "function",
    "deps": [],
    "body": "    fn finalize(self) -> Tag {\n        self.s.into()\n    }",
    "display_name": "finalize",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/ghash.rs",
    "relative_path": "belt-dwp/src/ghash.rs",
    "file_name": "ghash.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/EaxImpl/tag",
    "statement_type": "function",
    "deps": [],
    "body": "    fn tag(self) -> Tag<M> {\n        let h = self.data.finalize().into_bytes();\n        let c = self.message.finalize().into_bytes();\n\n        let full_tag: Array<_, Cipher::BlockSize> = self\n            .nonce\n            .into_iter()\n            .zip(h)\n            .map(|(a, b)| a ^ b)\n            .zip(c)\n            .map(|(a, b)| a ^ b)\n            .take(Cipher::BlockSize::to_usize())\n            .collect();\n\n        Tag::<M>::try_from(&full_tag[..M::to_usize()]).expect(\"tag size mismatch\")\n    }",
    "display_name": "tag",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Decryptor/decrypt_next",
    "statement_type": "function",
    "deps": [],
    "body": "    decrypt_next,\n    decrypt_next_in_place,\n    decrypt_last,\n    decrypt_last_in_place,\n    decrypt,\n    decrypt_in_place,\n    \"decrypt\",\n    \"ùíü STREAM decryptor\"\n);\n\n/// STREAM encryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type EncryptorBE32<A> = Encryptor<A, StreamBE32<A>>;\n\n/// STREAM decryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type DecryptorBE32<A> = Decryptor<A, StreamBE32<A>>;\n\n/// STREAM encryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type EncryptorLE31<A> = Encryptor<A, StreamLE31<A>>;\n\n/// STREAM decryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type DecryptorLE31<A> = Decryptor<A, StreamLE31<A>>;\n\n/// The original \"Rogaway-flavored\" STREAM as described in the paper\n/// [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance][1].\n///\n/// Uses a 32-bit big endian counter and 1-byte \"last block\" flag stored as\n/// the last 5-bytes of the AEAD nonce.\n///\n/// [1]: https://eprint.iacr.org/2015/189.pdf\n#[derive(Debug)]\npub struct StreamBE32<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<U5>,\n    <<A as AeadCore>::NonceSize as Sub<U5>>::Output: ArraySize,\n{\n    /// Underlying AEAD cipher\n    aead: A,\n\n    /// Nonce (sans STREAM overhead)\n    nonce: Nonce<A, Self>,\n}",
    "display_name": "decrypt_next",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/Eax/decrypt_unauthenticated_hazmat",
    "statement_type": "function",
    "deps": [
      "online/impl/EaxImpl/decrypt"
    ],
    "body": "    pub fn decrypt_unauthenticated_hazmat(&mut self, msg: &mut [u8]) {\n        self.imp.decrypt(msg)\n    }",
    "display_name": "decrypt_unauthenticated_hazmat",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_10_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_10_13, \"cavp_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\naead::new_test!(cavp_ccm_aes128_12_13, \"cavp_ccm_aes128_12_13\", Ccm<Aes128, U12, U13>);\naead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_10_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes192_4_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_4_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/CbcMac/block_update",
    "statement_type": "function",
    "deps": [],
    "body": "    fn block_update(&mut self, block: &Block<C>) {\n        self.state\n            .iter_mut()\n            .zip(block.iter())\n            .for_each(|(a, b)| *a ^= b);\n        self.cipher.encrypt_block(&mut self.state);\n    }",
    "display_name": "block_update",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "aes256cmacsiv/wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "    wycheproof_tests!(Aes256Siv, wycheproof, \"wycheproof-512\");\n}\n\n#[cfg(feature = \"pmac\")]\nmod aes128pmaccsiv {\n    use super::{Array, TestVector};\n    use aes_siv::{KeyInit, siv::Aes128PmacSiv};\n    use hex_literal::hex;\n\n    /// AES-128-PMAC-SIV test vectors\n    const TEST_VECTORS: &[TestVector<[u8; 32]>] = &[\n        TestVector {\n            key: &hex!(\"fffefdfcfbfaf9f8f7f6f5f4f3f2f1f0f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"),\n            aad: &[&hex!(\"101112131415161718191a1b1c1d1e1f2021222324252627\")],\n            plaintext: &hex!(\"112233445566778899aabbccddee\"),\n            ciphertext: &hex!(\"8c4b814216140fc9b34a41716aa61633ea66abe16b2f6e4bceeda6e9077f\"),\n        },\n        TestVector {\n            key: &hex!(\"7f7e7d7c7b7a79787776757473727170404142434445464748494a4b4c4d4e4f\"),\n            aad: &[\n                &hex!(\n                    \"00112233445566778899aabbccddeeffdeaddadadeaddadaffeeddccbbaa99887766554433221100\"\n                ),\n                &hex!(\"102030405060708090a0\"),\n                &hex!(\"09f911029d74e35bd84156c5635688c0\"),\n            ],\n            plaintext: &hex!(\n                \"7468697320697320736f6d6520706c61696e7465787420746f20656e6372797074207573696e67205349562d414553\"\n            ),\n            ciphertext: &hex!(\n                \"acb9cbc95dbed8e766d25ad59deb65bcda7aff9214153273f88e89ebe580c77defc15d28448f420e0a17d42722e6d42776849aa3bec375c5a05e54f519e9fd\"\n            ),\n        },\n        TestVector {\n            key: &hex!(\"fffefdfcfbfaf9f8f7f6f5f4f3f2f1f0f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"),\n            aad: &[],\n            plaintext: &hex!(\"\"),\n            ciphertext: &hex!(\"19f25e5ea8a96ef27067d4626fdd3677\"),\n        },\n        TestVector {\n            key: &hex!(\"fffefdfcfbfaf9f8f7f6f5f4f3f2f1f0f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"),\n            aad: &[&hex!(\"101112131415161718191a1b1c1d1e1f2021222324252627\")],\n            plaintext: &hex!(\n                \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f70\"\n            ),\n            ciphertext: &hex!(\n                \"34cbb315120924e6ad05240a1582018b3dc965941308e0535680344cf9cf40cb5aa00b449548f9a4d9718fd22057d19f5ea89450d2d3bf905e858aaec4fc594aa27948ea205ca90102fc463f5c1cbbfb171d296d727ec77f892fb192a4eb9897b7d48d50e474a1238f02a82b122a7b16aa5cc1c04b10b839e478662ff1cec7cabc\"\n            ),\n        },\n    ];\n\n    tests!(Aes128PmacSiv, TEST_VECTORS);\n}",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/tests/siv.rs",
    "relative_path": "aes-siv/tests/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_ii_256_8",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_256_8() {\n    let plaintext = hex!(\n        \"83dab23b1379e090755c99079cfe918cb737e989f2d720ccaff493a744927644fec3653211\"\n        \"fa75306a83486e5c34ecfe63870c97251a73e4b9033ae374809711b211ed5d293a592e466a\"\n        \"81170f1d85750b5ca025ccd4579947edbae9ec132bfb1a7233ad79fae30006a6699f143893\"\n        \"861b975226ed9d3cfb8a240be232fbf4e83755d59d20bc2faa2ea5e5b0428427485cca5e76\"\n        \"a89fe32bdd59ab4177ad7cb1899c101e3c4f7535129591390ebdf30140846078b13867bbb2\"\n        \"efd6cf434afe356eb18d716b21fd664c26c908496534bf2cde6d6b897799016594fb6d9f83\"\n        \"0ae5f44ccec26d42ff0d1a21b80cdbe8c8c170a5f766fad884abcc781b5b8ebc0f559bfeaa\"\n        \"4557b04d977d51411a7f47bf437d0280cf9f92bc4f9cd6226337a492320851955adae2cafe\"\n        \"a22a89c3132dd252e4728328eda05555dff3241404341b8aa502d45c456113af42a8e91a85\"\n        \"e4b4e9555028982ec3d144722af0eb04a6d3b8127c3040629de53f5fd187048198e8f8e8cc\"\n        \"857afcbae45c693fec12fc2149d5e7587d0121b1717d0147f6979f75e8f085293f705c3399\"\n        \"a6cc8df7057bf481e6c374edf0a0af7479f858045357b7fe21021c3fabdaf012652bf2e5db\"\n        \"257bd9490ce637a81477bd3f9814a2198fdb9afa9344321f2393798670e588c47a1924d592\"\n        \"cda3eb5a96754dfd92d87ee1ffa9d4ee586c85d7518c5d2db57d0451c33de0\"\n    );\n\n    let aad = hex!(\n        \"3290bb8441279dc6083a43e9048c3dc08966ab30d7a6b35759e7a13339f124918f3b5ab1af\"\n        \"fa65e6c0e3680eb33a6ec82424ab1ce5a40b8654e13d845c29b13896a1466a75fc875acba4\"\n        \"527ded37ed00c600a357c9a6e586c74cf3d85cd3258c813218f319d12b82480e5124ff19ec\"\n        \"00bda1fbb8bd25eeb3de9fcbf3296deba250caf7e9f4ef0be1918e24221dd0be888c59c166\"\n        \"ad761d7b58462a1b1d44b04265b45827172c133dd5b6c870b9af7b21368d12a88f4efa1751\"\n        \"047543d584382d9ec22e7550d50ecddba27d1f65453f1f3398de54ee8c1f4ac8e16f5523d8\"\n        \"9641e99a632380af0f0b1e6b0e192ec29bf1d8714978ff9fbfb93604142393e9a82c3aaebb\"\n        \"be15e3b4e5cfd18bdfe309315c9f9f830deebe2edcdc24f8eca90fda49f6646e789c5041fb\"\n        \"5be933fa843278e95f3a54f8eb41f14777ea949d5ea442b01249e64816151a325769e264ed\"\n        \"4acd5c3f21700ca755d5bc0c2c5f9453419510bc74f2d71621dcecb9efc9c24791b4bb560f\"\n        \"b70a8231521d6560af89d8d50144d9c080863f043781153bcd59030e60bd17a6d7aa083211\"\n        \"b67b581fa4f74cce4d030d1e8f9429fd725c110040d41eb6989ffb1595c72cbe3c9b78a8ab\"\n        \"80d71a6a5283da77b89cae295bb13c14fbe466b617f4da8ad60b085e2ea153f6713ae0046a\"\n        \"a31e0ba44e43ef36a111bf05c073a4e3624cd35f63a546f9142b35aa81b8826d\"\n    );\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext = hex!(\n        \"88294fcef65a1bdfd7baaa472816c64ef5bef2622b88c1ec5a739396157ef4935f3aa76449\"\n        \"e391c32da28ee2857f399ac3dd95aed30cfb26cc0063cd4cd8f7431108176fbf3701238566\"\n        \"62b000a8348e5925fbb97c9ec0c737758330a7983f06b51590c1d2f5e5faaf0eb58e34e19e\"\n        \"5fc85cec03d3926dd46a79ba7026e83dec24e07484c9103dd0cdb0edb505500caca5e1d5db\"\n        \"c71348cf00648821488ebaab7f9d84bbbf91b3c521dbef30110e7bd94f8dad5ab8e0cc5411\"\n        \"ca9682d210d5d80c0c4bdbba8181789a4273d6deb80899fdcd976ca6f3a9770b54305f586a\"\n        \"04256cfbeb4c11254e88559f294db3b9a94b80ab9f9a02cb4c0748de0af7818685521691db\"\n        \"a5738be546dba13a56016fb8635af9dff50f25d1b17ad21707db2640a76a741e65e559b2af\"\n        \"aaec0f37e18436bf02008f84dbd7b2698687a22376b65dc7524fca8a28709eee3f3caee3b2\"\n        \"8ed1173d1e08ee849e2ca63d2c90d555755c8fbafd5d2f4b37f06a1dbd6852ee2ffcfe79d5\"\n        \"10152e98fc4f3094f740a4aede9ee378b606d34576776bf5f1269f5385a84b3928433bfca1\"\n        \"77550ccfcd22cd0331bbc595e38c2758b2662476fa66354c4e84c7b360405aa3f5b2a48621\"\n        \"bdca1a90c69b21789c91b5b8c568e3c741d99e22f6d7e26f2abed045f1d578b782ab4a5cf2\"\n        \"af636d842b3012e180e4b045d8d15b057b69c92398a517053daf9be7c2935e\"\n    );\n\n    let tag: [u8; 16] = hex!(\"a616f0c218e18b526cf2a3f8c115e262\");\n\n    let encrypted = DeoxysII256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_256_8",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_256.rs",
    "relative_path": "deoxys/tests/deoxys_ii_256.rs",
    "file_name": "deoxys_ii_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(wycheproof, \"wycheproof-128\", Aes128GcmSiv);",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/tests/aes128gcmsiv.rs",
    "relative_path": "aes-gcm-siv/tests/aes128gcmsiv.rs",
    "file_name": "aes128gcmsiv.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/Dwp/InnerInit/inner_init",
    "statement_type": "function",
    "deps": [],
    "body": "    fn inner_init(cipher: Self::Inner) -> Self {\n        Self {\n            cipher,\n            _pd: PhantomData,\n        }\n    }",
    "display_name": "inner_init",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/lib.rs",
    "relative_path": "belt-dwp/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Cipher/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/Cipher/finish_tag",
      "init_ctr"
    ],
    "body": "    pub(crate) fn decrypt_inout_detached(\n        mut self,\n        associated_data: &[u8],\n        mut buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n    ) -> Result<(), Error> {\n        if buffer.len() as u64 > C_MAX || associated_data.len() as u64 > A_MAX {\n            return Err(Error);\n        }\n\n        self.polyval.update_padded(associated_data);\n\n        // TODO(tarcieri): interleave decryption and authentication\n        init_ctr(&self.enc_cipher, tag).apply_keystream_partial(buffer.reborrow());\n        self.polyval.update_padded(buffer.get_out());\n\n        let expected_tag = self.finish_tag(associated_data.len(), buffer.len());\n\n        use subtle::ConstantTimeEq;\n        if expected_tag.ct_eq(tag).into() {\n            Ok(())\n        } else {\n            // On MAC verify failure, re-encrypt the plaintext buffer to\n            // prevent accidental exposure.\n            init_ctr(&self.enc_cipher, tag).apply_keystream_partial(buffer);\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.11.0_rc.0 impl/ChaChaPoly1305/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &Key) -> Self {\n        Self {\n            key: *key,\n            stream_cipher: PhantomData,\n            nonce_size: PhantomData,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/lib.rs",
    "relative_path": "chacha20poly1305/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "rfc3610_ccm_aes128_8_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(rfc3610_ccm_aes128_8_13, \"rfc3610_ccm_aes128_8_13\", Ccm<Aes128, U8, U13>);\naead::new_test!(rfc3610_ccm_aes128_10_13, \"rfc3610_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\n\n// Test vectors from CAVP:\n// https://csrc.nist.gov/Projects/cryptographic-algorithm-validation-program/CAVP-TESTING-BLOCK-CIPHER-MODES\naead::new_test!(cavp_ccm_aes128_4_7, \"cavp_ccm_aes128_4_7\", Ccm<Aes128, U4, U7>);\naead::new_test!(cavp_ccm_aes128_4_13, \"cavp_ccm_aes128_4_13\", Ccm<Aes128, U4, U13>);\naead::new_test!(cavp_ccm_aes128_6_13, \"cavp_ccm_aes128_6_13\", Ccm<Aes128, U6, U13>);\naead::new_test!(cavp_ccm_aes128_8_13, \"cavp_ccm_aes128_8_13\", Ccm<Aes128, U8, U13>);\naead::new_test!(cavp_ccm_aes128_10_13, \"cavp_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\naead::new_test!(cavp_ccm_aes128_12_13, \"cavp_ccm_aes128_12_13\", Ccm<Aes128, U12, U13>);\naead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "rfc3610_ccm_aes128_8_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.11.0_rc.0 wycheproof_chacha20poly1305",
    "statement_type": "function",
    "deps": [],
    "body": "    wycheproof_chacha20poly1305,\n    \"wycheproof_chacha20poly1305\",\n    ChaCha20Poly1305\n);\naead::new_test!(\n    wycheproof_xchacha20poly1305,\n    \"wycheproof_xchacha20poly1305\",\n    XChaCha20Poly1305\n);\n\nmacro_rules! impl_tests {\n    ($cipher:ty, $key:expr, $nonce:expr, $aad:expr, $plaintext:expr, $ciphertext:expr, $tag:expr) => {\n        #[test]\n        fn encrypt() {\n            let key = Array(*$key);\n            let nonce = Array(*$nonce);\n            let payload = Payload {\n                msg: $plaintext,\n                aad: $aad,\n            };\n\n            let ciphertext = <$cipher>::new(&key).encrypt(&nonce, payload).unwrap();\n\n            let tag_begins = ciphertext.len() - 16;\n            assert_eq!($ciphertext, &ciphertext[..tag_begins]);\n            assert_eq!($tag, &ciphertext[tag_begins..]);\n        }\n\n        #[test]\n        fn decrypt() {\n            let key = Array(*$key);\n            let nonce = Array(*$nonce);\n\n            let mut ciphertext = Vec::from($ciphertext);\n            ciphertext.extend_from_slice($tag);\n            let payload = Payload {\n                msg: &ciphertext,\n                aad: $aad,\n            };\n\n            let plaintext = <$cipher>::new(&key).decrypt(&nonce, payload).unwrap();\n\n            assert_eq!($plaintext, plaintext.as_slice());\n        }\n\n        #[test]\n        fn decrypt_modified() {\n            let key = Array(*$key);\n            let nonce = Array(*$nonce);\n\n            let mut ciphertext = Vec::from($ciphertext);\n            ciphertext.extend_from_slice($tag);\n\n            // Tweak the first byte\n            ciphertext[0] ^= 0xaa;\n\n            let payload = Payload {\n                msg: &ciphertext,\n                aad: $aad,\n            };\n\n            let cipher = <$cipher>::new(&key);\n            assert!(cipher.decrypt(&nonce, payload).is_err());\n        }\n    };\n}",
    "display_name": "wycheproof_chacha20poly1305",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/tests/lib.rs",
    "relative_path": "chacha20poly1305/tests/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "modes/impl/DeoxysII/DeoxysMode/decrypt_inout",
    "statement_type": "function",
    "deps": [
      "modes/DeoxysModeInternal/compute_ad_tag",
      "modes/impl/DeoxysII/authenticate_message",
      "DeoxysBcType/encrypt_inout",
      "modes/impl/DeoxysII/encrypt_decrypt_message"
    ],
    "body": "    fn decrypt_inout(\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        mut buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n    ) -> Result<(), aead::Error> {\n        let mut computed_tag = Tag::default();\n        let mut tweak = Tweak::default();\n\n        // Associated Data\n        <Self as DeoxysModeInternal<B>>::compute_ad_tag(\n            associated_data,\n            &mut tweak,\n            subkeys,\n            &mut computed_tag,\n        );\n\n        // Message decryption\n        Self::encrypt_decrypt_message(buffer.reborrow(), &mut tweak, subkeys, tag, nonce);\n\n        tweak.fill(0);\n\n        // Message authentication\n        Self::authenticate_message(buffer.get_out(), &mut tweak, subkeys, &mut computed_tag);\n\n        tweak[0] = TWEAK_TAG;\n        tweak[1..].copy_from_slice(nonce);\n        B::encrypt_inout((&mut computed_tag).into(), &tweak, subkeys);\n\n        if tag.ct_eq(&computed_tag).into() {\n            Ok(())\n        } else {\n            Err(aead::Error)\n        }\n    }",
    "display_name": "decrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/modes.rs",
    "relative_path": "deoxys/src/modes.rs",
    "file_name": "modes.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/StreamLE31/StreamPrimitive/encrypt_in_place",
    "statement_type": "function",
    "deps": [
      "impl/StreamLE31/aead_nonce"
    ],
    "body": "    fn encrypt_in_place(\n        &self,\n        position: u32,\n        last_block: bool,\n        associated_data: &[u8],\n        buffer: &mut dyn Buffer,\n    ) -> Result<()> {\n        let nonce = self.aead_nonce(position, last_block)?;\n        self.aead.encrypt_in_place(&nonce, associated_data, buffer)\n    }",
    "display_name": "encrypt_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/Eax/tag_clone",
    "statement_type": "function",
    "deps": [
      "online/impl/EaxImpl/tag_clone"
    ],
    "body": "    pub fn tag_clone(&self) -> Tag<M> {\n        self.imp.tag_clone()\n    }",
    "display_name": "tag_clone",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "modes/encrypt_decrypt_block",
    "statement_type": "function",
    "deps": [
      "DeoxysBcType/encrypt_inout"
    ],
    "body": "        fn encrypt_decrypt_block<B: DeoxysBcType, F: FnOnce(&Block)>(\n            index: usize,\n            tweak: &mut Tweak,\n            subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n            nonce: &Array<u8, U15>,\n            xor: F,\n        ) {\n            let index_array = (index as u64).to_be_bytes();\n\n            // XOR in block numbers\n            for (t, i) in tweak[8..].iter_mut().zip(&index_array) {\n                *t ^= i\n            }\n\n            let mut block = Block::default();\n            block[1..].copy_from_slice(nonce);\n\n            B::encrypt_inout((&mut block).into(), tweak, subkeys);\n\n            xor(&block);\n\n            // XOR out block numbers\n            for (t, i) in tweak[8..].iter_mut().zip(&index_array) {\n                *t ^= i\n            }\n        }",
    "display_name": "encrypt_decrypt_block",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/modes.rs",
    "relative_path": "deoxys/src/modes.rs",
    "file_name": "modes.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre run_pass_test",
    "statement_type": "function",
    "deps": [],
    "body": "fn run_pass_test<C: Aead>(\n    cipher: &C,\n    nonce: &Nonce<C>,\n    aad: &[u8],\n    pt: &[u8],\n    ct: &[u8],\n) -> Result<(), &'static str> {\n    let res = cipher\n        .encrypt(nonce, Payload { aad, msg: pt })\n        .map_err(|_| \"encryption failure\")?;\n    if res != ct {\n        return Err(\"encrypted data is different from target ciphertext\");\n    }\n\n    let res = cipher\n        .decrypt(nonce, Payload { aad, msg: ct })\n        .map_err(|_| \"decryption failure\")?;\n    if res != pt {\n        return Err(\"decrypted data is different from target plaintext\");\n    }\n\n    Ok(())\n}",
    "display_name": "run_pass_test",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/tests/reference_kats.rs",
    "relative_path": "ascon-aead128/tests/reference_kats.rs",
    "file_name": "reference_kats.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.0.1_pre.0 impl/Xaes256Gcm/derive_key",
    "statement_type": "function",
    "deps": [],
    "body": "    fn derive_key(&self, n1: &Nonce<<NonceSize as Div<U2>>::Output>) -> Key<Aes256Gcm> {\n        // M1 = 0x00 || 0x01 || X || 0x00 || N[:12]\n        let mut m1 = Block::default();\n        m1[..4].copy_from_slice(&[0, 1, b'X', 0]);\n        m1[4..].copy_from_slice(n1);\n\n        // M2 = 0x00 || 0x02 || X || 0x00 || N[:12]\n        let mut m2 = Block::default();\n        m2[..4].copy_from_slice(&[0, 2, b'X', 0]);\n        m2[4..].copy_from_slice(n1);\n\n        // K‚Çò = AES-256‚Çñ(M1 ‚äï K1)\n        // K‚Çô = AES-256‚Çñ(M2 ‚äï K1)\n        // K‚Çì = K‚Çò || K‚Çô = AES-256‚Çñ(M1 ‚äï K1) || AES-256‚Çñ(M2 ‚äï K1)\n        let mut key: Key<Aes256Gcm> = Array::default();\n        let (km, kn) = key.split_ref_mut::<<KeySize as Div<U2>>::Output>();\n        for i in 0..km.len() {\n            km[i] = m1[i] ^ self.k1[i];\n        }\n        for i in 0..kn.len() {\n            kn[i] = m2[i] ^ self.k1[i];\n        }\n\n        self.aes.encrypt_block(km);\n        self.aes.encrypt_block(kn);\n        key\n    }",
    "display_name": "derive_key",
    "full_path": "file:///home/lacra/git_repos/AEADs/xaes-256-gcm/src/lib.rs",
    "relative_path": "xaes-256-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Cipher/finish_tag",
    "statement_type": "function",
    "deps": [],
    "body": "    fn finish_tag(&mut self, associated_data_len: usize, buffer_len: usize) -> Tag {\n        let associated_data_bits = (associated_data_len as u64) * 8;\n        let buffer_bits = (buffer_len as u64) * 8;\n\n        let mut block = polyval::Block::default();\n        block[..8].copy_from_slice(&associated_data_bits.to_le_bytes());\n        block[8..].copy_from_slice(&buffer_bits.to_le_bytes());\n        self.polyval.update(&[block]);\n\n        let mut tag = self.polyval.finalize_reset();\n\n        // XOR the nonce into the resulting tag\n        for (i, byte) in tag[..12].iter_mut().enumerate() {\n            *byte ^= self.nonce[i];\n        }\n\n        // Clear the highest bit\n        tag[15] &= 0x7f;\n\n        self.enc_cipher.encrypt_block(&mut tag);\n        tag\n    }",
    "display_name": "finish_tag",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Eax/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/Eax/cmac_with_iv"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce<Self::NonceSize>,\n        associated_data: &[u8],\n        mut buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag<M>, Error> {\n        if buffer.len() as u64 > P_MAX || associated_data.len() as u64 > A_MAX {\n            return Err(Error);\n        }\n\n        // https://crypto.stackexchange.com/questions/26948/eax-cipher-mode-with-nonce-equal-header\n        // has an explanation of eax.\n\n        // l = block cipher size = 128 (for AES-128) = 16 byte\n        // 1. n ‚Üê OMAC(0 || Nonce)\n        // (the 0 means the number zero in l bits)\n        let n = Self::cmac_with_iv(&self.key, 0, nonce);\n\n        // 2. h ‚Üê OMAC(1 || associated data)\n        let h = Self::cmac_with_iv(&self.key, 1, associated_data);\n\n        // 3. enc ‚Üê CTR(M) using n as iv\n        Ctr128BE::<Cipher>::inner_iv_init(Cipher::new(&self.key), &n)\n            .apply_keystream_partial(buffer.reborrow());\n\n        // 4. c ‚Üê OMAC(2 || enc)\n        let c = Self::cmac_with_iv(&self.key, 2, buffer.get_out());\n\n        // 5. tag ‚Üê n ^ h ^ c\n        // (^ means xor)\n        let full_tag: Array<_, OutputSize<Cmac<Cipher>>> = n\n            .into_iter()\n            .zip(h)\n            .map(|(a, b)| a ^ b)\n            .zip(c)\n            .map(|(a, b)| a ^ b)\n            .take(OutputSize::<Cmac<Cipher>>::to_usize())\n            .collect();\n\n        let tag = Tag::<M>::try_from(&full_tag[..M::to_usize()]).expect(\"tag size mismatch\");\n        Ok(tag)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/lib.rs",
    "relative_path": "eax/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_256_6",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_256_6() {\n    let plaintext = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: [u8; 32] =\n        hex!(\"109f8a168b36dfade02628a9e129d5257f03cc7912aefa79729b67b186a2b08f\");\n\n    let tag: [u8; 16] = hex!(\"6549f9bf10acba0a451dbb2484a60d90\");\n\n    let encrypted = DeoxysII256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_256_6",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_256.rs",
    "relative_path": "deoxys/tests/deoxys_ii_256.rs",
    "file_name": "deoxys_ii_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "NewStream/new",
    "statement_type": "function",
    "deps": [
      "NewStream/from_aead"
    ],
    "body": "    fn new(key: &Key<A>, nonce: &Nonce<A, Self>) -> Self\n    where\n        A: KeyInit,\n        Self: Sized,\n    {\n        Self::from_aead(A::new(key), nonce)\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_4_7",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_4_7, \"cavp_ccm_aes128_4_7\", Ccm<Aes128, U4, U7>);\naead::new_test!(cavp_ccm_aes128_4_13, \"cavp_ccm_aes128_4_13\", Ccm<Aes128, U4, U13>);\naead::new_test!(cavp_ccm_aes128_6_13, \"cavp_ccm_aes128_6_13\", Ccm<Aes128, U6, U13>);\naead::new_test!(cavp_ccm_aes128_8_13, \"cavp_ccm_aes128_8_13\", Ccm<Aes128, U8, U13>);\naead::new_test!(cavp_ccm_aes128_10_13, \"cavp_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\naead::new_test!(cavp_ccm_aes128_12_13, \"cavp_ccm_aes128_12_13\", Ccm<Aes128, U12, U13>);\naead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_4_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "tests/test_deoxys_ii_128_5",
    "statement_type": "function",
    "deps": [
      "tests/impl/MockBuffer/as_in_out_buf",
      "impl/Deoxys/KeyInit/new",
      "tests/impl/MockBuffer/AsRef/as_ref",
      "modes/impl/DeoxysII/DeoxysMode/encrypt_inout",
      "modes/impl/DeoxysII/DeoxysMode/decrypt_inout",
      "tests/impl/MockBuffer/From/from"
    ],
    "body": "    fn test_deoxys_ii_128_5() {\n        let plaintext = hex!(\"06ac1756eccece62bd743fa80c299f7baa3872b556130f52265919494bdc136db3\");\n        let mut buffer = MockBuffer::from(&plaintext[..]);\n\n        let aad = [];\n\n        let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n        let key = Array(key);\n\n        let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n        let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n        let ciphertext_expected =\n            hex!(\"82bf241958b324ed053555d23315d3cc20935527fc970ff34a9f521a95e302136d\");\n\n        let tag_expected: [u8; 16] = hex!(\"0eadc8612d5208c491e93005195e9769\");\n\n        type M = modes::DeoxysII<deoxys_bc::DeoxysBc256>;\n        let cipher = DeoxysII128::new(&key);\n        let tag: Tag = M::encrypt_inout(&nonce, &aad, buffer.as_in_out_buf(), &cipher.subkeys);\n\n        let ciphertext = buffer.as_ref();\n        assert_eq!(ciphertext, ciphertext_expected);\n        assert_eq!(tag, tag_expected);\n\n        let mut buffer = MockBuffer::from(buffer.as_ref());\n        M::decrypt_inout(&nonce, &aad, buffer.as_in_out_buf(), &tag, &cipher.subkeys)\n            .expect(\"decryption failed\");\n\n        assert_eq!(&plaintext[..], buffer.as_ref());\n    }",
    "display_name": "test_deoxys_ii_128_5",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_128_3",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_128_3() {\n    let plaintext = Vec::new();\n\n    let aad = hex!(\"a754f3387be992ffee5bee80e18b151900c6d69ec59786fb12d2eadb0750f82cf5\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"0a989ed78fa16776cd6c691ea734d874\");\n\n    let encrypted = DeoxysII128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_ii_128_3",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_128.rs",
    "relative_path": "deoxys/tests/deoxys_ii_128.rs",
    "file_name": "deoxys_ii_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes128_16_12",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_16_12",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_ii_256_3",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_256_3() {\n    let plaintext = Vec::new();\n\n    let aad = hex!(\"f495c9c03d29989695d98ff5d430650125805c1e0576d06f26cbda42b1f82238b8\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"3277689dc4208cc1ff59d15434a1baf1\");\n\n    let encrypted = DeoxysII256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_ii_256_3",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_256.rs",
    "relative_path": "deoxys/tests/deoxys_ii_256.rs",
    "file_name": "deoxys_ii_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/AesGcmSiv/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/Cipher/new",
      "impl/Cipher/decrypt_inout_detached"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n    ) -> Result<(), Error> {\n        Cipher::<Aes>::new(&self.key_generating_key, nonce).decrypt_inout_detached(\n            associated_data,\n            buffer,\n            tag,\n        )\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "StreamPrimitive/decrypt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decrypt<'msg, 'aad>(\n        &self,\n        position: Self::Counter,\n        last_block: bool,\n        ciphertext: impl Into<Payload<'msg, 'aad>>,\n    ) -> Result<Vec<u8>> {\n        let payload = ciphertext.into();\n        let mut buffer = Vec::from(payload.msg);\n        self.decrypt_in_place(position, last_block, payload.aad, &mut buffer)?;\n        Ok(buffer)\n    }",
    "display_name": "decrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Eax/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &Key<Cipher>) -> Self {\n        Self {\n            key: key.clone(),\n            _tag_size: PhantomData,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/lib.rs",
    "relative_path": "eax/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.0.1_pre.0 impl/Xaes256Gcm/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &Key) -> Self {\n        let aes = Aes256::new(key);\n\n        // L = AES-256‚Çñ(0¬π¬≤‚Å∏)\n        let mut k1 = Block::default();\n        aes.encrypt_block(&mut k1);\n\n        // If MSB‚ÇÅ(L) = 0 then K1 = L << 1 Else K1 = (L << 1) ‚äï 0¬π¬≤‚Å∞10000111\n        let mut msb = 0;\n        for i in (0..k1.len()).rev() {\n            let new_msb = k1[i] >> 7;\n            k1[i] = (k1[i] << 1) | msb;\n            msb = new_msb;\n        }\n\n        let b = k1.len() - 1;\n        k1[b] ^= msb * 0b10000111;\n\n        Self { aes, k1 }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/xaes-256-gcm/src/lib.rs",
    "relative_path": "xaes-256-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/u64_from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "fn u64_from_bytes(input: &[u8]) -> u64 {\n    // Soundness: function is always called with slices of the correct size\n    u64::from_le_bytes(input.try_into().unwrap())\n}",
    "display_name": "u64_from_bytes",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gf/GfElement/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new() -> Self;\n    fn into_bytes(self) -> Array<u8, Self::N>;\n    fn mul_sum(&mut self, a: &Array<u8, Self::N>, b: &Array<u8, Self::N>);\n}\n\n/// Tests from Appendix A, table 18 of [STB 34.101.31-2020](https://apmi.bsu.by/assets/files/std/belt-spec372.pdf)\n#[test]\nfn test_a18() {\n    use crate::gf::gf128_soft64::Element;\n    use aead::consts::U16;\n    use hex_literal::hex;\n\n    type Block = Array<u8, U16>;\n\n    let test_vectors = [\n        (\n            hex!(\"34904055 11BE3297 1343724C 5AB793E9\"),\n            hex!(\"22481783 8761A9D6 E3EC9689 110FB0F3\"),\n            hex!(\"0001D107 FC67DE40 04DC2C80 3DFD95C3\"),\n        ),\n        (\n            hex!(\"703FCCF0 95EE8DF1 C1ABF8EE 8DF1C1AB\"),\n            hex!(\"2055704E 2EDB48FE 87E74075 A5E77EB1\"),\n            hex!(\"4A5C9593 8B3FE8F6 74D59BC1 EB356079\"),\n        ),\n    ];\n    for (u, v, w) in test_vectors {\n        let a = Block::try_from(&u[..]).unwrap();\n        let b = Block::try_from(&v[..]).unwrap();\n        let c = Block::try_from(&w[..]).unwrap();\n\n        let mut elem = Element::new();\n        elem.mul_sum(&a, &b);\n\n        assert_eq!(c, elem.into_bytes());\n    }\n}",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf.rs",
    "relative_path": "belt-dwp/src/gf.rs",
    "file_name": "gf.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "siv/xor_in_place",
    "statement_type": "function",
    "deps": [],
    "body": "fn xor_in_place(dst: &mut [u8], src: &[u8]) {\n    for (a, b) in dst[..src.len()].iter_mut().zip(src) {\n        *a ^= *b;\n    }\n}",
    "display_name": "xor_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/EaxImpl/verify_ct",
    "statement_type": "function",
    "deps": [
      "online/impl/EaxImpl/tag"
    ],
    "body": "    fn verify_ct(self, expected: &Tag<M>) -> Result<(), Error> {\n        // Check MAC using secure comparison\n        use subtle::ConstantTimeEq;\n\n        let resulting_tag = &self.tag()[..expected.len()];\n        if resulting_tag.ct_eq(expected).into() {\n            Ok(())\n        } else {\n            Err(Error)\n        }\n    }",
    "display_name": "verify_ct",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Decryptor/decrypt_last_in_place",
    "statement_type": "function",
    "deps": [
      "StreamPrimitive/decrypt"
    ],
    "body": "    decrypt_last_in_place,\n    decrypt,\n    decrypt_in_place,\n    \"decrypt\",\n    \"ùíü STREAM decryptor\"\n);\n\n/// STREAM encryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type EncryptorBE32<A> = Encryptor<A, StreamBE32<A>>;\n\n/// STREAM decryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type DecryptorBE32<A> = Decryptor<A, StreamBE32<A>>;\n\n/// STREAM encryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type EncryptorLE31<A> = Encryptor<A, StreamLE31<A>>;\n\n/// STREAM decryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type DecryptorLE31<A> = Decryptor<A, StreamLE31<A>>;\n\n/// The original \"Rogaway-flavored\" STREAM as described in the paper\n/// [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance][1].\n///\n/// Uses a 32-bit big endian counter and 1-byte \"last block\" flag stored as\n/// the last 5-bytes of the AEAD nonce.\n///\n/// [1]: https://eprint.iacr.org/2015/189.pdf\n#[derive(Debug)]\npub struct StreamBE32<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<U5>,\n    <<A as AeadCore>::NonceSize as Sub<U5>>::Output: ArraySize,\n{\n    /// Underlying AEAD cipher\n    aead: A,\n\n    /// Nonce (sans STREAM overhead)\n    nonce: Nonce<A, Self>,\n}",
    "display_name": "decrypt_last_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "DeoxysMode/encrypt_inout",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encrypt_inout(\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n    ) -> Tag;\n\n    /// Decrypts the data in place with the specified parameters\n    /// Returns an error if the tag verification fails\n    fn decrypt_inout(\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n    ) -> Result<(), aead::Error>;\n}\n\n/// Deoxys-BC trait.\n/// This type contains the public API for Deoxys-BC implementations, which varies depending on the size of the key.\npub trait DeoxysBcType: deoxys_bc::DeoxysBcInternal {\n    /// The size of the required tweakey.\n    type KeySize: ArraySize;\n\n    /// Precompute the subkeys\n    fn precompute_subkeys(key: &Array<u8, Self::KeySize>) -> Array<DeoxysKey, Self::SubkeysSize>;\n\n    /// Encrypts a block of data in place.\n    fn encrypt_inout(\n        mut block: InOut<'_, '_, Block>,\n        tweak: &Tweak,\n        subkeys: &Array<DeoxysKey, Self::SubkeysSize>,\n    ) {\n        let keys = Self::key_schedule(tweak, subkeys);\n\n        block.xor_in2out(&keys[0]);\n\n        for k in &keys[1..] {\n            aes::hazmat::cipher_round(block.get_out(), k);\n        }\n    }\n\n    /// Decrypts a block of data in place.\n    fn decrypt_inout(\n        mut block: InOut<'_, '_, Block>,\n        tweak: &Tweak,\n        subkeys: &Array<DeoxysKey, Self::SubkeysSize>,\n    ) {\n        let mut keys = Self::key_schedule(tweak, subkeys);\n\n        let r = keys.len();\n\n        block.xor_in2out(&keys[r - 1]);\n\n        aes::hazmat::inv_mix_columns(block.get_out());\n\n        for k in keys[..r - 1].iter_mut().rev() {\n            aes::hazmat::inv_mix_columns(k);\n            aes::hazmat::equiv_inv_cipher_round(block.get_out(), k);\n        }\n\n        aes::hazmat::mix_columns(block.get_out());\n    }\n}",
    "display_name": "encrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre num2str96",
    "statement_type": "function",
    "deps": [],
    "body": "fn num2str96(num: usize) -> [u8; 12] {\n    let num: u32 = num.try_into().unwrap();\n    let mut out = [0u8; 12];\n    out[8..12].copy_from_slice(&num.to_be_bytes());\n    out\n}",
    "display_name": "num2str96",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/tests/kats.rs",
    "relative_path": "ocb3/tests/kats.rs",
    "file_name": "kats.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.11.0_rc.0 cipher/impl/Cipher/authenticate_lengths",
    "statement_type": "function",
    "deps": [],
    "body": "    fn authenticate_lengths(&mut self, associated_data: &[u8], buffer: &[u8]) -> Result<(), Error> {\n        let associated_data_len: u64 = associated_data.len().try_into().map_err(|_| Error)?;\n        let buffer_len: u64 = buffer.len().try_into().map_err(|_| Error)?;\n\n        let mut block = Array::default();\n        block[..8].copy_from_slice(&associated_data_len.to_le_bytes());\n        block[8..].copy_from_slice(&buffer_len.to_le_bytes());\n        self.mac.update(&[block]);\n\n        Ok(())\n    }",
    "display_name": "authenticate_lengths",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/cipher.rs",
    "relative_path": "chacha20poly1305/src/cipher.rs",
    "file_name": "cipher.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ghash/impl/GHash/UniversalHash/update_with_backend",
    "statement_type": "function",
    "deps": [],
    "body": "    fn update_with_backend(&mut self, f: impl UhfClosure<BlockSize = Self::BlockSize>) {\n        f.call(self)\n    }",
    "display_name": "update_with_backend",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/ghash.rs",
    "relative_path": "belt-dwp/src/ghash.rs",
    "file_name": "ghash.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Decryptor/decrypt_next_in_place",
    "statement_type": "function",
    "deps": [],
    "body": "    decrypt_next_in_place,\n    decrypt_last,\n    decrypt_last_in_place,\n    decrypt,\n    decrypt_in_place,\n    \"decrypt\",\n    \"ùíü STREAM decryptor\"\n);\n\n/// STREAM encryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type EncryptorBE32<A> = Encryptor<A, StreamBE32<A>>;\n\n/// STREAM decryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type DecryptorBE32<A> = Decryptor<A, StreamBE32<A>>;\n\n/// STREAM encryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type EncryptorLE31<A> = Encryptor<A, StreamLE31<A>>;\n\n/// STREAM decryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type DecryptorLE31<A> = Decryptor<A, StreamLE31<A>>;\n\n/// The original \"Rogaway-flavored\" STREAM as described in the paper\n/// [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance][1].\n///\n/// Uses a 32-bit big endian counter and 1-byte \"last block\" flag stored as\n/// the last 5-bytes of the AEAD nonce.\n///\n/// [1]: https://eprint.iacr.org/2015/189.pdf\n#[derive(Debug)]\npub struct StreamBE32<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<U5>,\n    <<A as AeadCore>::NonceSize as Sub<U5>>::Output: ArraySize,\n{\n    /// Underlying AEAD cipher\n    aead: A,\n\n    /// Nonce (sans STREAM overhead)\n    nonce: Nonce<A, Self>,\n}",
    "display_name": "decrypt_next_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_128_5",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_128_5() {\n    let plaintext = hex!(\"5a4c652cb880808707230679224b11799b5883431292973215e9bd03cf3bc32fe4\");\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext = hex!(\"cded5a43d3c76e942277c2a1517530ad66037897c985305ede345903ed7585a626\");\n\n    let tag: [u8; 16] = hex!(\"cbf5faa6b8398c47f4278d2019161776\");\n\n    let encrypted = DeoxysI128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_128_5",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_128.rs",
    "relative_path": "deoxys/tests/deoxys_i_128.rs",
    "file_name": "deoxys_i_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_ii_128_1",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_128_1() {\n    let plaintext = Vec::new();\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"97d951f2fd129001483e831f2a6821e9\");\n\n    let encrypted = DeoxysII128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_ii_128_1",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_128.rs",
    "relative_path": "deoxys/tests/deoxys_ii_128.rs",
    "file_name": "deoxys_ii_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes128_16_8",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_16_8",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "rfc3610_ccm_aes128_10_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(rfc3610_ccm_aes128_10_13, \"rfc3610_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\n\n// Test vectors from CAVP:\n// https://csrc.nist.gov/Projects/cryptographic-algorithm-validation-program/CAVP-TESTING-BLOCK-CIPHER-MODES\naead::new_test!(cavp_ccm_aes128_4_7, \"cavp_ccm_aes128_4_7\", Ccm<Aes128, U4, U7>);\naead::new_test!(cavp_ccm_aes128_4_13, \"cavp_ccm_aes128_4_13\", Ccm<Aes128, U4, U13>);\naead::new_test!(cavp_ccm_aes128_6_13, \"cavp_ccm_aes128_6_13\", Ccm<Aes128, U6, U13>);\naead::new_test!(cavp_ccm_aes128_8_13, \"cavp_ccm_aes128_8_13\", Ccm<Aes128, U8, U13>);\naead::new_test!(cavp_ccm_aes128_10_13, \"cavp_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\naead::new_test!(cavp_ccm_aes128_12_13, \"cavp_ccm_aes128_12_13\", Ccm<Aes128, U12, U13>);\naead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "rfc3610_ccm_aes128_10_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Array, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>>/From/from",
    "statement_type": "function",
    "deps": [
      "gf/gf128_soft64/impl/Element/GfElement/into_bytes"
    ],
    "body": "    fn from(element: Element) -> Self {\n        element.into_bytes()\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "online/impl/Eax/encrypt",
    "statement_type": "function",
    "deps": [
      "online/impl/EaxImpl/encrypt"
    ],
    "body": "    pub fn encrypt(&mut self, msg: &mut [u8]) {\n        self.imp.encrypt(msg)\n    }",
    "display_name": "encrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_14_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_14_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes192_6_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_6_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "siv/impl/Siv/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &Array<u8, KeySize<C>>) -> Self {\n        // Use the first half of the key as the MAC key and\n        // the second one as the encryption key\n        let (mac_key, enc_key) = key.split_at(M::key_size());\n\n        Self {\n            encryption_key: enc_key.try_into().expect(\"encryption key size mismatch\"),\n            mac: <M as KeyInit>::new(mac_key.try_into().expect(\"MAC key size mismatch\")),\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/AesGcm/compute_tag",
    "statement_type": "function",
    "deps": [],
    "body": "    fn compute_tag(&self, mask: Block, associated_data: &[u8], buffer: &[u8]) -> Tag {\n        let mut ghash = self.ghash.clone();\n        ghash.update_padded(associated_data);\n        ghash.update_padded(buffer);\n\n        let associated_data_bits = (associated_data.len() as u64) * 8;\n        let buffer_bits = (buffer.len() as u64) * 8;\n\n        let mut block = ghash::Block::default();\n        block[..8].copy_from_slice(&associated_data_bits.to_be_bytes());\n        block[8..].copy_from_slice(&buffer_bits.to_be_bytes());\n        ghash.update(&[block]);\n\n        let mut tag = ghash.finalize();\n        for (a, b) in tag.as_mut_slice().iter_mut().zip(mask.as_slice()) {\n            *a ^= *b;\n        }\n\n        tag\n    }",
    "display_name": "compute_tag",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/src/lib.rs",
    "relative_path": "aes-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes192_16_12",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_16_12",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "private/SealedTag/get_m_tick",
    "statement_type": "function",
    "deps": [],
    "body": "    fn get_m_tick() -> u8 {\n        (Self::to_u8() - 2) / 2\n    }",
    "display_name": "get_m_tick",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/private.rs",
    "relative_path": "ccm/src/private.rs",
    "file_name": "private.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre nonce_dependent_variables",
    "statement_type": "function",
    "deps": [],
    "body": "fn nonce_dependent_variables<\n    Cipher: BlockSizeUser<BlockSize = U16> + BlockCipherEncrypt,\n    NonceSize: sealed::NonceSizes,\n>(\n    cipher: &Cipher,\n    nn: &Nonce<NonceSize>,\n    tag_len: u32,\n) -> (usize, [u8; 24]) {\n    // Nonce = num2str(TAGLEN mod 128,7) || zeros(120-bitlen(N)) || 1 || N\n    let mut nonce = [0u8; 16];\n    nonce[0] = (((tag_len * 8) % 128) << 1) as u8;\n\n    let start = 16 - NonceSize::to_usize();\n    nonce[start..16].copy_from_slice(nn.as_slice());\n    nonce[16 - NonceSize::to_usize() - 1] |= 1;\n\n    // Separate the last 6 bits into `bottom`, and the rest into `top`.\n    let bottom = nonce[15] & 0b111111;\n\n    let nonce = u128::from_be_bytes(nonce);\n    let top = nonce & !0b111111;\n\n    let mut ktop = Block::from(top.to_be_bytes());\n    cipher.encrypt_block(&mut ktop);\n    let ktop = ktop.as_mut_slice();\n\n    // stretch = Ktop || (Ktop[1..64] xor Ktop[9..72])\n    let mut stretch = [0u8; 24];\n    stretch[..16].copy_from_slice(ktop);\n    for i in 0..8 {\n        ktop[i] ^= ktop[i + 1];\n    }\n    stretch[16..].copy_from_slice(&ktop[..8]);\n\n    (bottom as usize, stretch)\n}",
    "display_name": "nonce_dependent_variables",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_4_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_4_13, \"cavp_ccm_aes128_4_13\", Ccm<Aes128, U4, U13>);\naead::new_test!(cavp_ccm_aes128_6_13, \"cavp_ccm_aes128_6_13\", Ccm<Aes128, U6, U13>);\naead::new_test!(cavp_ccm_aes128_8_13, \"cavp_ccm_aes128_8_13\", Ccm<Aes128, U8, U13>);\naead::new_test!(cavp_ccm_aes128_10_13, \"cavp_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\naead::new_test!(cavp_ccm_aes128_12_13, \"cavp_ccm_aes128_12_13\", Ccm<Aes128, U12, U13>);\naead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_4_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "modes/impl/DeoxysI/DeoxysMode/decrypt_inout",
    "statement_type": "function",
    "deps": [
      "modes/DeoxysModeInternal/compute_ad_tag",
      "DeoxysBcType/decrypt_inout",
      "DeoxysBcType/encrypt_inout"
    ],
    "body": "    fn decrypt_inout(\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n    ) -> Result<(), aead::Error> {\n        let mut computed_tag = Tag::default();\n        let mut checksum = Checksum::default();\n        let mut tweak = Tweak::default();\n\n        // Associated Data\n        <Self as DeoxysModeInternal<B>>::compute_ad_tag(\n            associated_data,\n            &mut tweak,\n            subkeys,\n            &mut computed_tag,\n        );\n\n        // Add the nonce to the tweak\n        tweak[0] = nonce[0] >> 4;\n        for i in 1..nonce.len() {\n            tweak[i] = (nonce[i - 1] << 4) | (nonce[i] >> 4);\n        }\n\n        tweak[8] = nonce[7] << 4;\n\n        // Message authentication and encryption\n\n        tweak[0] = (tweak[0] & 0xf) | TWEAK_M;\n\n        let (data_blocks, mut tail) = buffer.into_chunks();\n        let mut data_blocks_len = data_blocks.len();\n\n        for (index, mut data) in data_blocks.into_iter().enumerate() {\n            // Copy block number\n            let tmp = tweak[8] & 0xf0;\n            tweak[8..].copy_from_slice(&(index as u64).to_be_bytes());\n            tweak[8] = (tweak[8] & 0xf) | tmp;\n\n            B::decrypt_inout(data.reborrow(), tweak.as_ref(), subkeys);\n\n            for (c, d) in checksum.iter_mut().zip(data.get_out().iter()) {\n                *c ^= d;\n            }\n        }\n\n        // Process incomplete last block\n        if !tail.is_empty() {\n            // Copy block number\n            let tmp = tweak[8] & 0xf0;\n            tweak[8..].copy_from_slice(&(data_blocks_len as u64).to_be_bytes());\n            tweak[8] = (tweak[8] & 0xf) | tmp;\n\n            // Last block checksum\n            tweak[0] = (tweak[0] & 0xf) | TWEAK_M_LAST;\n\n            let mut block = Block::default();\n            B::encrypt_inout((&mut block).into(), tweak.as_ref(), subkeys);\n\n            tail.xor_in2out((block[..tail.len()]).into());\n\n            block.fill(0);\n\n            block[..tail.len()].copy_from_slice(tail.get_out());\n            block[tail.len()] = 0x80;\n\n            for (c, d) in checksum.iter_mut().zip(block.iter()) {\n                *c ^= d;\n            }\n\n            data_blocks_len += 1;\n        }\n\n        // Tag computing.\n        let t = if tail.is_empty() {\n            TWEAK_TAG\n        } else {\n            TWEAK_CHKSUM\n        };\n        tweak[0] = (tweak[0] & 0xf) | t;\n        let tmp = tweak[8] & 0xf0;\n        tweak[8..].copy_from_slice(&(data_blocks_len as u64).to_be_bytes());\n        tweak[8] = (tweak[8] & 0xf) | tmp;\n\n        B::encrypt_inout((&mut checksum).into(), tweak.as_ref(), subkeys);\n\n        for (t, c) in computed_tag.iter_mut().zip(checksum.iter()) {\n            *t ^= c;\n        }\n\n        if tag.ct_eq(&computed_tag).into() {\n            Ok(())\n        } else {\n            Err(aead::Error)\n        }\n    }",
    "display_name": "decrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/modes.rs",
    "relative_path": "deoxys/src/modes.rs",
    "file_name": "modes.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.11.0_rc.0 impl/ChaChaPoly1305/Drop/drop",
    "statement_type": "function",
    "deps": [],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        {\n            use zeroize::Zeroize;\n            self.key.as_mut_slice().zeroize();\n        }\n    }",
    "display_name": "drop",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/lib.rs",
    "relative_path": "chacha20poly1305/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_16_11",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_16_11",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "siv/impl/Siv/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "siv/impl/Siv/xor_with_keystream",
      "siv/s2v"
    ],
    "body": "    pub fn encrypt_inout_detached<I, T>(\n        &mut self,\n        headers: I,\n        plaintext: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag, Error>\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,\n    {\n        // Compute the synthetic IV for this plaintext\n        let siv_tag = s2v(&mut self.mac, headers, plaintext.get_in())?;\n        self.xor_with_keystream(siv_tag, plaintext);\n        Ok(siv_tag)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.11.0_rc.0 impl/ChaChaPoly1305/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.11.0_rc.0 cipher/impl/Cipher/new",
      "0.11.0_rc.0 cipher/impl/Cipher/encrypt_inout_detached"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &aead::Nonce<Self>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag, Error> {\n        Cipher::new(C::new(&self.key, nonce)).encrypt_inout_detached(associated_data, buffer)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/lib.rs",
    "relative_path": "chacha20poly1305/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/Eax/with_key_and_nonce",
    "statement_type": "function",
    "deps": [
      "online/impl/EaxImpl/with_key_and_nonce"
    ],
    "body": "    pub fn with_key_and_nonce(key: &Key<Cipher>, nonce: &Nonce<Cipher::BlockSize>) -> Self {\n        let imp = EaxImpl::<Cipher, M>::with_key_and_nonce(key, nonce);\n\n        Self {\n            imp,\n            marker: PhantomData,\n        }\n    }",
    "display_name": "with_key_and_nonce",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "private/SealedNonce/get_l",
    "statement_type": "function",
    "deps": [],
    "body": "    fn get_l() -> u8 {\n        15 - Self::to_u8()\n    }",
    "display_name": "get_l",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/private.rs",
    "relative_path": "ccm/src/private.rs",
    "file_name": "private.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes192_14_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_14_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.11.0_rc.0 impl/ChaChaPoly1305/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "    fn clone(&self) -> Self {\n        Self {\n            key: self.key,\n            stream_cipher: PhantomData,\n            nonce_size: PhantomData,\n        }\n    }",
    "display_name": "clone",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/lib.rs",
    "relative_path": "chacha20poly1305/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes192_16_10",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_16_10",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "online/impl/EaxImpl/decrypt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decrypt(&mut self, msg: &mut [u8]) {\n        self.message.update(msg);\n        self.ctr.apply_keystream(msg);\n    }",
    "display_name": "decrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_16_7",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_16_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.2.0_pre inplace_xor",
    "statement_type": "function",
    "deps": [],
    "body": "pub(crate) fn inplace_xor<T, U>(a: &mut Array<T, U>, b: &Array<T, U>)\nwhere\n    U: ArraySize,\n    T: core::ops::BitXor<Output = T> + Copy,\n{\n    for (aa, bb) in a.as_mut_slice().iter_mut().zip(b.as_slice()) {\n        *aa = *aa ^ *bb;\n    }\n}",
    "display_name": "inplace_xor",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre ntz",
    "statement_type": "function",
    "deps": [],
    "body": "pub(crate) fn ntz(n: usize) -> usize {\n    n.trailing_zeros() as usize\n}",
    "display_name": "ntz",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "modes/DeoxysModeInternal/compute_ad_tag",
    "statement_type": "function",
    "deps": [
      "DeoxysBcType/encrypt_inout"
    ],
    "body": "    fn compute_ad_tag(\n        associated_data: &[u8],\n        tweak: &mut Tweak,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n        tag: &mut Tag,\n    ) {\n        if !associated_data.is_empty() {\n            tweak[0] = TWEAK_AD;\n\n            for (index, ad) in associated_data.chunks(16).enumerate() {\n                // Copy block number\n                tweak[8..].copy_from_slice(&(index as u64).to_be_bytes());\n\n                if ad.len() == 16 {\n                    let mut block = Block::default();\n                    block.copy_from_slice(ad);\n\n                    B::encrypt_inout((&mut block).into(), tweak, subkeys);\n\n                    for (t, b) in tag.iter_mut().zip(block.iter()) {\n                        *t ^= b;\n                    }\n                } else {\n                    // Last block\n                    tweak[0] = TWEAK_AD_LAST;\n\n                    let mut block = Block::default();\n                    block[0..ad.len()].copy_from_slice(ad);\n\n                    block[ad.len()] = 0x80;\n\n                    B::encrypt_inout((&mut block).into(), tweak, subkeys);\n\n                    for (t, b) in tag.iter_mut().zip(block.iter()) {\n                        *t ^= b;\n                    }\n                }\n            }\n        }\n    }",
    "display_name": "compute_ad_tag",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/modes.rs",
    "relative_path": "deoxys/src/modes.rs",
    "file_name": "modes.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "modes/impl/DeoxysII/encrypt_decrypt_message",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encrypt_decrypt_message(\n        buffer: InOutBuf<'_, '_, u8>,\n        tweak: &mut Tweak,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n        tag: &Tag,\n        nonce: &Array<u8, U15>,\n    ) {\n        #[inline]\n        fn encrypt_decrypt_block<B: DeoxysBcType, F: FnOnce(&Block)>(\n            index: usize,\n            tweak: &mut Tweak,\n            subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n            nonce: &Array<u8, U15>,\n            xor: F,\n        ) {\n            let index_array = (index as u64).to_be_bytes();\n\n            // XOR in block numbers\n            for (t, i) in tweak[8..].iter_mut().zip(&index_array) {\n                *t ^= i\n            }\n\n            let mut block = Block::default();\n            block[1..].copy_from_slice(nonce);\n\n            B::encrypt_inout((&mut block).into(), tweak, subkeys);\n\n            xor(&block);\n\n            // XOR out block numbers\n            for (t, i) in tweak[8..].iter_mut().zip(&index_array) {\n                *t ^= i\n            }\n        }\n\n        if buffer.is_empty() {\n            return;\n        }\n\n        tweak.copy_from_slice(tag);\n        tweak[0] |= 0x80;\n\n        let (blocks, tail) = buffer.into_chunks::<U16>();\n        let blocks_len = blocks.len();\n        for (index, mut data) in blocks.into_iter().enumerate() {\n            encrypt_decrypt_block::<B, _>(index, tweak, subkeys, nonce, |block| {\n                data.xor_in2out(block)\n            });\n        }\n        let mut data = tail;\n        let index = blocks_len;\n\n        encrypt_decrypt_block::<B, _>(index, tweak, subkeys, nonce, |block| {\n            data.xor_in2out((block[..data.len()]).into())\n        });\n    }",
    "display_name": "encrypt_decrypt_message",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/modes.rs",
    "relative_path": "deoxys/src/modes.rs",
    "file_name": "modes.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/KeyInit/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new(key: &aead::Key<Self>) -> Self {\n        Cipher::new(key).into()\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes192_16_9",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_16_9",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/StreamLE31/NewStream/from_aead",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_aead(aead: A, nonce: &Nonce<A, Self>) -> Self {\n        Self {\n            aead,\n            nonce: nonce.clone(),\n        }\n    }",
    "display_name": "from_aead",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_16_11",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_16_11",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "aes128cmacsiv/wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "    wycheproof_tests!(Aes128Siv, wycheproof, \"wycheproof-256\");\n}\n\nmod aes256cmacsiv {\n    use super::{Array, TestVector};\n    use aes_siv::{KeyInit, siv::Aes256Siv};\n    use hex_literal::hex;\n\n    /// AES-256-CMAC-SIV test vectors\n    const TEST_VECTORS: &[TestVector<[u8; 64]>] = &[\n        TestVector {\n            key: &hex!(\n                \"fffefdfcfbfaf9f8f7f6f5f4f3f2f1f06f6e6d6c6b6a69686766656463626160f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff000102030405060708090a0b0c0d0e0f\"\n            ),\n            aad: &[&hex!(\"101112131415161718191a1b1c1d1e1f2021222324252627\")],\n            plaintext: &hex!(\"112233445566778899aabbccddee\"),\n            ciphertext: &hex!(\"f125274c598065cfc26b0e71575029088b035217e380cac8919ee800c126\"),\n        },\n        TestVector {\n            key: &hex!(\n                \"7f7e7d7c7b7a797877767574737271706f6e6d6c6b6a69686766656463626160404142434445464748494a4b4c4d4e4f505152535455565758595a5b5b5d5e5f\"\n            ),\n            aad: &[\n                &hex!(\n                    \"00112233445566778899aabbccddeeffdeaddadadeaddadaffeeddccbbaa99887766554433221100\"\n                ),\n                &hex!(\"102030405060708090a0\"),\n                &hex!(\"09f911029d74e35bd84156c5635688c0\"),\n            ],\n            plaintext: &hex!(\n                \"7468697320697320736f6d6520706c61696e7465787420746f20656e6372797074207573696e67205349562d414553\"\n            ),\n            ciphertext: &hex!(\n                \"85b8167310038db7dc4692c0281ca35868181b2762f3c24f2efa5fb80cb143516ce6c434b898a6fd8eb98a418842f51f66fc67de43ac185a66dd72475bbb08\"\n            ),\n        },\n    ];\n\n    tests!(Aes256Siv, TEST_VECTORS);\n\n    wycheproof_tests!(Aes256Siv, wycheproof, \"wycheproof-512\");\n}",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/tests/siv.rs",
    "relative_path": "aes-siv/tests/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/AesGcm/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(cipher: Aes) -> Self {\n        let mut ghash_key = ghash::Key::default();\n        cipher.encrypt_block(&mut ghash_key);\n\n        let ghash = GHash::new(&ghash_key);\n\n        #[cfg(feature = \"zeroize\")]\n        ghash_key.zeroize();\n\n        Self {\n            cipher,\n            ghash,\n            nonce_size: PhantomData,\n            tag_size: PhantomData,\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/src/lib.rs",
    "relative_path": "aes-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "DeoxysMode/decrypt_inout",
    "statement_type": "function",
    "deps": [],
    "body": "    fn decrypt_inout(\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n        subkeys: &Array<DeoxysKey, B::SubkeysSize>,\n    ) -> Result<(), aead::Error>;\n}\n\n/// Deoxys-BC trait.\n/// This type contains the public API for Deoxys-BC implementations, which varies depending on the size of the key.\npub trait DeoxysBcType: deoxys_bc::DeoxysBcInternal {\n    /// The size of the required tweakey.\n    type KeySize: ArraySize;\n\n    /// Precompute the subkeys\n    fn precompute_subkeys(key: &Array<u8, Self::KeySize>) -> Array<DeoxysKey, Self::SubkeysSize>;\n\n    /// Encrypts a block of data in place.\n    fn encrypt_inout(\n        mut block: InOut<'_, '_, Block>,\n        tweak: &Tweak,\n        subkeys: &Array<DeoxysKey, Self::SubkeysSize>,\n    ) {\n        let keys = Self::key_schedule(tweak, subkeys);\n\n        block.xor_in2out(&keys[0]);\n\n        for k in &keys[1..] {\n            aes::hazmat::cipher_round(block.get_out(), k);\n        }\n    }\n\n    /// Decrypts a block of data in place.\n    fn decrypt_inout(\n        mut block: InOut<'_, '_, Block>,\n        tweak: &Tweak,\n        subkeys: &Array<DeoxysKey, Self::SubkeysSize>,\n    ) {\n        let mut keys = Self::key_schedule(tweak, subkeys);\n\n        let r = keys.len();\n\n        block.xor_in2out(&keys[r - 1]);\n\n        aes::hazmat::inv_mix_columns(block.get_out());\n\n        for k in keys[..r - 1].iter_mut().rev() {\n            aes::hazmat::inv_mix_columns(k);\n            aes::hazmat::equiv_inv_cipher_round(block.get_out(), k);\n        }\n\n        aes::hazmat::mix_columns(block.get_out());\n    }\n}",
    "display_name": "decrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre rfc7253_more_sample_results",
    "statement_type": "function",
    "deps": [],
    "body": "fn rfc7253_more_sample_results() {\n    rfc7253_wider_variety!(Aes128Ocb3, 16, 16, \"67E944D23256C5E0B6C61FA22FDF1EA2\");\n    rfc7253_wider_variety!(Aes192Ocb3, 24, 16, \"F673F2C3E7174AAE7BAE986CA9F29E17\");\n    rfc7253_wider_variety!(Aes256Ocb3, 32, 16, \"D90EB8E9C977C88B79DD793D7FFA161C\");\n    rfc7253_wider_variety!(Aes128Ocb3Tag96, 16, 12, \"77A3D8E73589158D25D01209\");\n    rfc7253_wider_variety!(Aes192Ocb3Tag96, 24, 12, \"05D56EAD2752C86BE6932C5E\");\n    rfc7253_wider_variety!(Aes256Ocb3Tag96, 32, 12, \"5458359AC23B0CBA9E6330DD\");\n    rfc7253_wider_variety!(Aes128Ocb3Tag64, 16, 8, \"192C9B7BD90BA06A\");\n    rfc7253_wider_variety!(Aes192Ocb3Tag64, 24, 8, \"0066BC6E0EF34E24\");\n    rfc7253_wider_variety!(Aes256Ocb3Tag64, 32, 8, \"7D4EA5D445501CBE\");\n}",
    "display_name": "rfc7253_more_sample_results",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/tests/kats.rs",
    "relative_path": "ocb3/tests/kats.rs",
    "file_name": "kats.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "StreamPrimitive/encrypt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn encrypt<'msg, 'aad>(\n        &self,\n        position: Self::Counter,\n        last_block: bool,\n        plaintext: impl Into<Payload<'msg, 'aad>>,\n    ) -> Result<Vec<u8>> {\n        let payload = plaintext.into();\n        let mut buffer = Vec::with_capacity(payload.msg.len() + A::TagSize::to_usize());\n        buffer.extend_from_slice(payload.msg);\n        self.encrypt_in_place(position, last_block, payload.aad, &mut buffer)?;\n        Ok(buffer)\n    }",
    "display_name": "encrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "decrypt_msg_only_16kb",
    "statement_type": "function",
    "deps": [
      "impl/Dwp/AeadInOut/decrypt_inout_detached",
      "impl/Dwp/AeadInOut/encrypt_inout_detached"
    ],
    "body": "fn decrypt_msg_only_16kb(b: &mut Bencher) {\n    let c = BeltDwp::new(&KEY);\n    let aad = [];\n    let mut ct_buf = vec![0u8; 16 * 1024];\n    let tag = c\n        .encrypt_inout_detached(&NONCE, &aad, (&mut ct_buf[..]).into())\n        .unwrap();\n\n    let mut buf = ct_buf.clone();\n    b.iter(|| {\n        let (aad, buf, nonce, tag) = test::black_box((&aad, &mut buf[..], &NONCE, &tag));\n        let res = c.decrypt_inout_detached(nonce, aad, buf.into(), tag);\n        let _ = test::black_box(res);\n        buf.copy_from_slice(&ct_buf);\n    });\n\n    b.bytes = 16 * 1024;\n}",
    "display_name": "decrypt_msg_only_16kb",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/benches/mod.rs",
    "relative_path": "belt-dwp/benches/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Element/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, rhs: Self) -> Self {\n        Self(self.0 ^ rhs.0, self.1 ^ rhs.1)\n    }",
    "display_name": "add",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "test_data_len_check",
    "statement_type": "function",
    "deps": [
      "impl/Ccm/KeyInit/new",
      "impl/Ccm/AeadInOut/encrypt_inout_detached"
    ],
    "body": "fn test_data_len_check() {\n    let key = hex!(\"D7828D13B2B0BDC325A76236DF93CC6B\");\n    let nonce = hex!(\"2F1DBD38CE3EDA7C23F04DD650\");\n\n    type Cipher = Ccm<aes::Aes128, U10, U13>;\n    let key = Array(key);\n    let nonce = Array(nonce);\n    let c = Cipher::new(&key);\n\n    let mut buf1 = [1; u16::MAX as usize];\n    let res = c.encrypt_inout_detached(&nonce, &[], buf1.as_mut_slice().into());\n    assert!(res.is_ok());\n\n    let mut buf2 = [1; u16::MAX as usize + 1];\n    let res = c.encrypt_inout_detached(&nonce, &[], buf2.as_mut_slice().into());\n    assert!(res.is_err());\n}",
    "display_name": "test_data_len_check",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes192_16_8",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_16_8",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_i_256_3",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_256_3() {\n    let plaintext = Vec::new();\n\n    let aad = hex!(\"52d15808134c3c2e8acbc154299df5c6f86f48ec5dafa5363989b33ba7e0299565\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"0001020304050607\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"f343b91c303180ae2ae4f379022087fa\");\n\n    let encrypted = DeoxysI256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_i_256_3",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_256.rs",
    "relative_path": "deoxys/tests/deoxys_i_256.rs",
    "file_name": "deoxys_i_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.2.0_pre tests/rfc7253_nonce_dependent_constants",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre initial_offset",
      "0.2.0_pre nonce_dependent_variables"
    ],
    "body": "    fn rfc7253_nonce_dependent_constants() {\n        // Test vector from page 17 of https://www.rfc-editor.org/rfc/rfc7253.html\n        let key = hex!(\"000102030405060708090A0B0C0D0E0F\");\n        let nonce = hex!(\"BBAA9988776655443322110F\");\n        let expected_bottom = usize::try_from(15).unwrap();\n        let expected_stretch = hex!(\"9862B0FDEE4E2DD56DBA6433F0125AA2FAD24D13A063F8B8\");\n        let expected_offset_0 = Block::from(hex!(\"587EF72716EAB6DD3219F8092D517D69\"));\n\n        const TAGLEN: u32 = 16;\n\n        let cipher = aes::Aes128::new(key.as_ref());\n        let (bottom, stretch) =\n            nonce_dependent_variables::<aes::Aes128, U12>(&cipher, &Nonce::from(nonce), TAGLEN);\n        let offset_0 = initial_offset::<aes::Aes128, U12>(&cipher, &Nonce::from(nonce), TAGLEN);\n\n        assert_eq!(bottom, expected_bottom, \"bottom\");\n        assert_eq!(stretch, expected_stretch, \"stretch\");\n        assert_eq!(offset_0, expected_offset_0, \"offset\");\n    }",
    "display_name": "rfc7253_nonce_dependent_constants",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "encrypt_msg_only_16kb",
    "statement_type": "function",
    "deps": [
      "impl/Dwp/AeadInOut/encrypt_inout_detached"
    ],
    "body": "fn encrypt_msg_only_16kb(b: &mut Bencher) {\n    let c = BeltDwp::new(&KEY);\n    let aad = [];\n    let mut buf = vec![0; 16 * 1024];\n\n    b.iter(|| {\n        let (aad, buf, nonce) = test::black_box((&aad, &mut buf[..], &NONCE));\n        let res = c.encrypt_inout_detached(nonce, aad, buf.into()).unwrap();\n        test::black_box(res);\n    });\n\n    b.bytes = 16 * 1024;\n}",
    "display_name": "encrypt_msg_only_16kb",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/benches/mod.rs",
    "relative_path": "belt-dwp/benches/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "test_belt_dwp",
    "statement_type": "function",
    "deps": [
      "impl/Dwp/AeadInOut/encrypt_inout_detached",
      "impl/Dwp/AeadInOut/decrypt_inout_detached"
    ],
    "body": "fn test_belt_dwp() {\n    struct TestVector {\n        i: [u8; 32],\n        k: [u8; 32],\n        s: [u8; 16],\n        x: [u8; 16],\n        y: [u8; 16],\n        t: [u8; 8],\n    }\n\n    let test_vectors = [\n        TestVector {\n            i: hex!(\"8504FA9D 1BB6C7AC 252E72C2 02FDCE0D 5BE3D612 17B96181 FE6786AD 716B890B\"),\n            k: hex!(\"E9DEE72C 8F0C0FA6 2DDB49F4 6F739647 06075316 ED247A37 39CBA383 03A98BF6\"),\n            s: hex!(\"BE329713 43FC9A48 A02A885F 194B09A1\"),\n            x: hex!(\"B194BAC8 0A08F53B 366D008E 584A5DE4\"),\n            y: hex!(\"52C9AF96 FF50F644 35FC43DE F56BD797\"),\n            t: hex!(\"3B2E0AEB 2B91854B\"),\n        },\n        TestVector {\n            i: hex!(\"C1AB7638 9FE678CA F7C6F860 D5BB9C4F F33C657B 637C306A DD4EA779 9EB23D31\"),\n            k: hex!(\"92BD9B1C E5D14101 5445FBC9 5E4D0EF2 682080AA 227D642F 2687F934 90405511\"),\n            s: hex!(\"7ECDA4D0 1544AF8C A58450BF 66D2E88A\"),\n            x: hex!(\"DF181ED0 08A20F43 DCBBB936 50DAD34B\"),\n            y: hex!(\"E12BDC1A E28257EC 703FCCF0 95EE8DF1\"),\n            t: hex!(\"6A2C2C94 C4150DC0\"),\n        },\n    ];\n\n    for vec in test_vectors {\n        let mut x = vec.x;\n        let belt_dwp = BeltDwp::new_from_slice(&vec.k).unwrap();\n        let tag = belt_dwp.encrypt_inout_detached(&vec.s.into(), &vec.i, (&mut x[..]).into());\n        assert_eq!(vec.t, *tag.unwrap());\n        assert_eq!(vec.y, x);\n        belt_dwp\n            .decrypt_inout_detached(&vec.s.into(), &vec.i, (&mut x[..]).into(), &tag.unwrap())\n            .unwrap();\n        assert_eq!(x, vec.x);\n    }\n}",
    "display_name": "test_belt_dwp",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/tests/belt.rs",
    "relative_path": "belt-dwp/tests/belt.rs",
    "file_name": "belt.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/compute_tag",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre impl/Ocb3/hash",
      "0.2.0_pre inplace_xor"
    ],
    "body": "    fn compute_tag(\n        &self,\n        associated_data: &[u8],\n        checksum_m: &mut Block,\n        offset_m: &Block,\n    ) -> Tag<TagSize> {\n        // Tag = ENCIPHER(K, checksum_m xor offset_m xor L_$) xor HASH(K,A)\n        let full_tag = checksum_m;\n        inplace_xor(full_tag, offset_m);\n        inplace_xor(full_tag, &self.ll_dollar);\n        self.cipher.encrypt_block(full_tag);\n        inplace_xor(full_tag, &self.hash(associated_data));\n\n        // truncate the tag to the required length\n        Tag::try_from(&full_tag[..TagSize::to_usize()]).expect(\"tag size mismatch\")\n    }",
    "display_name": "compute_tag",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "deoxys_bc/lfsr2",
    "statement_type": "function",
    "deps": [],
    "body": "fn lfsr2(tk: &mut [u8; 16]) {\n    let mut data = u128::from_ne_bytes(*tk);\n    data = ((data << 1) & 0xFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFE)\n        | (((data >> 7) ^ (data >> 5)) & 0x01010101010101010101010101010101);\n\n    tk.copy_from_slice(&data.to_ne_bytes())\n}",
    "display_name": "lfsr2",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/deoxys_bc.rs",
    "relative_path": "deoxys/src/deoxys_bc.rs",
    "file_name": "deoxys_bc.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_256_8",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_256_8() {\n    let plaintext = hex!(\n        \"d18db1b44ad16fe5623ccd73c250c27240daf512e97de1ca770983f262d36e1c9eafdf925c\"\n        \"9786aeb556c1d058e1d3d0d92b8a5fed45bff46204f7cc1db8b23e69f271593f4c8427ee56\"\n        \"60fad6edf209f903921c1eba5c884777be45ca7875c72e5b44b550dc30ee875798a19a0d61\"\n        \"965bf9ec6a17bdebb91b9e503dbf70e5ec314e67d199296cd6375c510b04dbe30ac3b6a083\"\n        \"f655627ab3859c168263babfbd5ca2f9c33df7deefd46f37693ba4350b69e3ddbde6b0d571\"\n        \"1c4a0a7c8dcadf8b2340ed7a0748c3e9ef6ae72022fd3799b0561f00b255cdde1199b1c2de\"\n        \"f3b6324508f28b1f1935aeb1083072598d8cea7e420ad8ce090922fca2be67b68e0b8fe5db\"\n        \"2f06faca945480f4831a6fd9bbeb40084403a8a2617184f8c9d3340c2720b19f838d64a82e\"\n        \"ff4b2020ee92a72291102487788d8f774a32d5b1a6752cd80118f400806fe613d312d8d65c\"\n        \"c21f4af83b50407fedec7ed4972a54b8d2260cb652f3d9f3868d3081b20a719a1ff8611fe1\"\n        \"9ec41dc92570b74688506746cf96c7f5db878446b0fdcc554a1c3e7fa62b611077a65e29bb\"\n        \"460699a6187fa4c52b91f58cc103a7dce86d3feefd9dcbc86fa5bf67b13fc0157c6da22d5d\"\n        \"da3f0443a05b2d7b286b5da2372013f18a361cab696219d84f8677588d8500b7ebb34b29b1\"\n        \"520258bcaa19f77229ddab6fcba75faaf4e09ecaa590e77e027477f5399b47\"\n    );\n\n    let aad = hex!(\n        \"bbc9aa3017a7ee71293eb2ea451f2efa6794e41c55b7505df1f2073f5babe332a479619f85\"\n        \"5a39e45ef469b0c6329a786dbfc2b05b27983683d5edf26949cf964d75d7110bd4dba14a76\"\n        \"f88353e3c652b46aca2f661d37dc7ffcf8da13c7aa48f25095ce16c8834c3d2c9c81319792\"\n        \"6d47c9f73895fdf70f2574d7f8539a9ef2aba78e80ec138ef1f702daf007ba337e1e0dfc49\"\n        \"e6bd3f3eb4ff5a5c4e0ca2bdcf3e5b6fea5401dfaa40e66db6fc63a6e306755492684bbc60\"\n        \"21e2a1bbf1245422377664475b22cdd83960e47852b474da196e67db018b87839966ffe52c\"\n        \"665cabe0c021df68d0c1454505b0458fe3dc3acc6b8400ec04a3129266ae9368c15bbf13aa\"\n        \"bd05f859e2e9ea7cc937e899cc5c5bd72d2b72bd16d9024db4706fcf5195bbe25eb807fea0\"\n        \"1840f4b572f0fadb8a4246d6895547a37cd8a9b756425b31872a1d51c0ef2d53ca00071138\"\n        \"8228b76490780e3a10389c72ccc0deded32a5d9e723aa31dddd3344b068bcde9d483c92493\"\n        \"75a88dce482a819361993fde555603cea01cede77fe64190906157ded418c3c21bc5274034\"\n        \"b8d9edf09daf2aa90fb3b5f7d3b7da5c018144e54af9737227d2c13210c861fd5b4246d1a2\"\n        \"90fd054fd15d59d2e08894239d000b1076055771f7a7da54b2fcd7cd1f5a9e1da5a25a0ddb\"\n        \"aa8d4397d74828a2b75a8da4730b87ac6c2fc5ef4985b9915320ea4942690df6\"\n    );\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"0001020304050607\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext = hex!(\n        \"e94c5c6df7c19474bbdd292baa2555fdbd5e90a35fb94627cdd7dd3b424ca47d6779f3e699\"\n        \"7809204263bdbd4825b7d6510995b1c371e582942bd7f6ab909f993cd5b7db5f95e8b8b56e\"\n        \"4cdf016f5cab37f662329b32801fda4403f731fa61f7aa16b9a23f2637b1f75fa0b36ced90\"\n        \"ce6a1f73aafbb5adca756e0d59b8ae6661f2d3fc409c88d8baf3836fac55df78b9ba522221\"\n        \"345f42bd794c26d5d1a83fed0114d1d1b04d3c3b77ff0083647710b316e17896b2081d9375\"\n        \"fde1f2fe063e66423a0d413919ffa6b5754d10de8de64d32ede0d02ebe8f8791d8e9f59462\"\n        \"b615f4122dd8c3b97671a8c156eb32ebebb3fb91832fd01f6afee9d4ab045fea83ec877438\"\n        \"23ea3bd18f7826229c312ad8a4bc9e2f6d1ad520e6d850bd189b4538d10005abf5a7c50f4f\"\n        \"8ded6a62b18cd2a7e6bd3159edc3e9b553cbddd419af540da10576e9ea7d49e2fd0dc1c5ee\"\n        \"7693504b63b928e4e23b1753147a3d0ad00cc2e6390fba10e925dc536db4eb30cf152ddb04\"\n        \"20f8e8eaa8460feb9a7f0be589ccb877732d8d606085536c405c2ba6c03cb68e12f7d14609\"\n        \"587a6c478e2a32794290ba35ce6dba21784d8f6faf401920bfc2aa172c3b4d9bea2eae8542\"\n        \"b18410d3a40414247a406379855cb78c28e82ab67b62433a4016b15c4abf4f01c372ba4f15\"\n        \"62596531cb0337117ad769eaa666b497b7822eba924e358693bc48cf555f70\"\n    );\n\n    let tag: [u8; 16] = hex!(\"e404257c9cf7eb9774fc288a9ef1592e\");\n\n    let encrypted = DeoxysI256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_256_8",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_256.rs",
    "relative_path": "deoxys/tests/deoxys_i_256.rs",
    "file_name": "deoxys_i_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes128_16_10",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_16_10",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes256_16_9",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_16_9",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "tests/test_deoxys_i_128_5",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new",
      "tests/impl/MockBuffer/From/from",
      "tests/impl/MockBuffer/as_in_out_buf",
      "tests/impl/MockBuffer/AsRef/as_ref",
      "modes/impl/DeoxysI/DeoxysMode/decrypt_inout",
      "modes/impl/DeoxysI/DeoxysMode/encrypt_inout"
    ],
    "body": "    fn test_deoxys_i_128_5() {\n        let plaintext = hex!(\"5a4c652cb880808707230679224b11799b5883431292973215e9bd03cf3bc32fe4\");\n        let mut buffer = MockBuffer::from(&plaintext[..]);\n\n        let aad = [];\n\n        let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n        let key = Array(key);\n\n        let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n        let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n        let ciphertext_expected =\n            hex!(\"cded5a43d3c76e942277c2a1517530ad66037897c985305ede345903ed7585a626\");\n\n        let tag_expected: [u8; 16] = hex!(\"cbf5faa6b8398c47f4278d2019161776\");\n\n        type M = modes::DeoxysI<deoxys_bc::DeoxysBc256>;\n        let cipher = DeoxysI128::new(&key);\n        let tag: Tag = M::encrypt_inout(&nonce, &aad, buffer.as_in_out_buf(), &cipher.subkeys);\n\n        let ciphertext = buffer.as_ref();\n        assert_eq!(ciphertext, ciphertext_expected);\n        assert_eq!(tag, tag_expected);\n\n        let mut buffer = MockBuffer::from(buffer.as_ref());\n        M::decrypt_inout(&nonce, &aad, buffer.as_in_out_buf(), &tag, &cipher.subkeys)\n            .expect(\"decryption failed\");\n\n        assert_eq!(&plaintext[..], buffer.as_ref());\n    }",
    "display_name": "test_deoxys_i_128_5",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre impl/Ascon/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/impl/AsconCore/new",
      "0.1.0_pre asconcore/impl/AsconCore/decrypt_inout"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce<Self>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag<Self>,\n    ) -> Result<(), Error> {\n        if (buffer.len() as u64)\n            .checked_add(associated_data.len() as u64)\n            .is_none()\n        {\n            return Err(Error);\n        }\n\n        let mut core = AsconCore::<P>::new(&self.key, nonce);\n        core.decrypt_inout(buffer, associated_data, tag)\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/lib.rs",
    "relative_path": "ascon-aead128/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_16_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_16_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes256_10_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_10_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "init_ctr",
    "statement_type": "function",
    "deps": [],
    "body": "fn init_ctr<Aes>(cipher: Aes, nonce: &cipher::Block<Aes>) -> Ctr32LE<Aes>\nwhere\n    Aes: BlockSizeUser<BlockSize = U16> + BlockCipherEncrypt,\n{\n    let mut counter_block = *nonce;\n    counter_block[15] |= 0x80;\n    Ctr32LE::inner_iv_init(cipher, &counter_block)\n}",
    "display_name": "init_ctr",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre impl/Ocb3/decrypt_inout_return_tag"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce<NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &aead::Tag<Self>,\n    ) -> aead::Result<()> {\n        let expected_tag = self.decrypt_inout_return_tag(nonce, associated_data, buffer);\n        if expected_tag.ct_eq(tag).into() {\n            Ok(())\n        } else {\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre split_into_two_blocks",
    "statement_type": "function",
    "deps": [],
    "body": "pub(crate) fn split_into_two_blocks<'i, 'o>(\n    two_blocks: InOut<'i, 'o, DoubleBlock>,\n) -> [InOut<'i, 'o, Block>; 2] {\n    Array::<InOut<'i, 'o, Block>, U2>::from(two_blocks).into()\n}",
    "display_name": "split_into_two_blocks",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.11.0_rc.0 chacha20/clone_impl",
    "statement_type": "function",
    "deps": [
      "0.11.0_rc.0 impl/ChaChaPoly1305/Clone/clone",
      "0.11.0_rc.0 impl/ChaChaPoly1305/KeyInit/new"
    ],
    "body": "    fn clone_impl() {\n        let _ = ChaCha20Poly1305::new(KEY.into()).clone();\n    }",
    "display_name": "clone_impl",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/tests/lib.rs",
    "relative_path": "chacha20poly1305/tests/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_ii_256_5",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_256_5() {\n    let plaintext = hex!(\"15cd77732f9d0c4c6e581ef400876ad9188c5b8850ebd38224da95d7cdc99f7acc\");\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext = hex!(\"e5ffd2abc5b459a73667756eda6443ede86c0883fc51dd75d22bb14992c684618c\");\n\n    let tag: [u8; 16] = hex!(\"5fa78d57308f19d0252072ee39df5ecc\");\n\n    let encrypted = DeoxysII256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_256_5",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_256.rs",
    "relative_path": "deoxys/tests/deoxys_ii_256.rs",
    "file_name": "deoxys_ii_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "gf/test_a18",
    "statement_type": "function",
    "deps": [
      "gf/gf128_soft64/impl/Element/GfElement/new",
      "gf/gf128_soft64/impl/Element/GfElement/mul_sum",
      "gf/gf128_soft64/impl/Element/GfElement/into_bytes"
    ],
    "body": "fn test_a18() {\n    use crate::gf::gf128_soft64::Element;\n    use aead::consts::U16;\n    use hex_literal::hex;\n\n    type Block = Array<u8, U16>;\n\n    let test_vectors = [\n        (\n            hex!(\"34904055 11BE3297 1343724C 5AB793E9\"),\n            hex!(\"22481783 8761A9D6 E3EC9689 110FB0F3\"),\n            hex!(\"0001D107 FC67DE40 04DC2C80 3DFD95C3\"),\n        ),\n        (\n            hex!(\"703FCCF0 95EE8DF1 C1ABF8EE 8DF1C1AB\"),\n            hex!(\"2055704E 2EDB48FE 87E74075 A5E77EB1\"),\n            hex!(\"4A5C9593 8B3FE8F6 74D59BC1 EB356079\"),\n        ),\n    ];\n    for (u, v, w) in test_vectors {\n        let a = Block::try_from(&u[..]).unwrap();\n        let b = Block::try_from(&v[..]).unwrap();\n        let c = Block::try_from(&w[..]).unwrap();\n\n        let mut elem = Element::new();\n        elem.mul_sum(&a, &b);\n\n        assert_eq!(c, elem.into_bytes());\n    }\n}",
    "display_name": "test_a18",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf.rs",
    "relative_path": "belt-dwp/src/gf.rs",
    "file_name": "gf.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Element/GfElement/mul_sum",
    "statement_type": "function",
    "deps": [
      "gf/gf128_soft64/from_block",
      "gf/utils/bmul64"
    ],
    "body": "    fn mul_sum(&mut self, a: &Block, b: &Block) {\n        let [a1, a0] = from_block(a);\n        let [b1, b0] = from_block(b);\n\n        let a2 = a1 ^ a0;\n        let b2 = b1 ^ b0;\n\n        // Multiply using Karatsuba multiplication\n        let c = bmul64(a1, b1);\n        let d = bmul64(a0, b0);\n        let e = bmul64(a2, b2);\n        let t = c ^ d ^ e;\n        let v0 = d as u64;\n        let v1 = ((d >> 64) ^ t) as u64;\n        let v2 = (c ^ (t >> 64)) as u64;\n        let v3 = (c >> 64) as u64;\n\n        // reduce over polynomial f(w) = w^128 + w^7 + w^2 + w + 1\n        let d = v2 ^ (v3 >> 63) ^ (v3 >> 62) ^ (v3 >> 57);\n        self.1 ^= v0 ^ d ^ (d << 1) ^ (d << 2) ^ (d << 7);\n        self.0 ^= v1 ^ v3 ^ (v3 << 1) ^ (v3 << 2) ^ (v3 << 7) ^ (d >> 63) ^ (d >> 62) ^ (d >> 57);\n    }",
    "display_name": "mul_sum",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "0.0.1_pre.0 impl/Xaes256Gcm/AeadInOut/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/AesGcm/KeyInit/new",
      "0.0.1_pre.0 impl/Xaes256Gcm/derive_key",
      "impl/AesGcm/AeadInOut/encrypt_inout_detached"
    ],
    "body": "    fn encrypt_inout_detached(\n        &self,\n        nonce: &Nonce,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag, Error> {\n        if buffer.len() as u64 > P_MAX || associated_data.len() as u64 > A_MAX {\n            return Err(Error);\n        }\n\n        let (n1, n) = nonce.split_ref::<<NonceSize as Div<U2>>::Output>();\n        let k = self.derive_key(n1);\n        Aes256Gcm::new(&k).encrypt_inout_detached(n, associated_data, buffer)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/xaes-256-gcm/src/lib.rs",
    "relative_path": "xaes-256-gcm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre tests/double_basic_test",
    "statement_type": "function",
    "deps": [],
    "body": "    fn double_basic_test() {\n        let zero = Block::from(hex!(\"00000000000000000000000000000000\"));\n        assert_eq!(zero, zero.dbl());\n        let one = Block::from(hex!(\"00000000000000000000000000000001\"));\n        let two = Block::from(hex!(\"00000000000000000000000000000002\"));\n        assert_eq!(two, one.dbl());\n    }",
    "display_name": "double_basic_test",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/wide_encrypt",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre split_into_two_blocks",
      "0.2.0_pre ntz",
      "0.2.0_pre initial_offset",
      "0.2.0_pre inplace_xor"
    ],
    "body": "    fn wide_encrypt<'i, 'o>(\n        &self,\n        nonce: &Nonce<NonceSize>,\n        buffer: InOutBuf<'i, 'o, u8>,\n    ) -> (InOutBuf<'i, 'o, u8>, usize, Block, Block) {\n        const WIDTH: usize = 2;\n\n        let mut i = 1;\n\n        let mut offset_i = [Block::default(); WIDTH];\n        offset_i[1] = initial_offset(&self.cipher, nonce, TagSize::to_u32());\n        let mut checksum_i = Block::default();\n\n        let (wide_blocks, tail): (InOutBuf<'_, '_, DoubleBlock>, _) = buffer.into_chunks();\n        for wide_block in wide_blocks.into_iter() {\n            let mut p_i = split_into_two_blocks(wide_block);\n            // checksum_i = checksum_{i-1} xor p_i\n            for p_ij in &p_i {\n                inplace_xor(&mut checksum_i, p_ij.get_in());\n            }\n\n            // offset_i = offset_{i-1} xor L_{ntz(i)}\n            offset_i[0] = offset_i[1];\n            inplace_xor(&mut offset_i[0], &self.ll[ntz(i)]);\n            offset_i[1] = offset_i[0];\n            inplace_xor(&mut offset_i[1], &self.ll[ntz(i + 1)]);\n\n            // c_i = offset_i xor ENCIPHER(K, p_i xor offset_i)\n            for j in 0..p_i.len() {\n                p_i[j].xor_in2out(&offset_i[j]);\n                self.cipher.encrypt_block(p_i[j].get_out());\n                inplace_xor(p_i[j].get_out(), &offset_i[j]);\n            }\n\n            i += WIDTH;\n        }\n\n        (tail, i, offset_i[offset_i.len() - 1], checksum_i)\n    }",
    "display_name": "wide_encrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_128_8",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_128_8() {\n    let plaintext = hex!(\n        \"95330042c3d48419798f9285fbd8d24968d7cee311f637463f8c0a1778f79d758a84e3\"\n        \"5b7d4a9fde2ed56fa796ad5a0f7004490ed32664ad69069678f53dfd7ee92e00a8ee34\"\n        \"776b4d758536dc725ec4d48e2c11d0c5a16e4a2ce6c0e91604adb33a11127f50a46ea3\"\n        \"cf5353d88a7a244c0f4337f449e68bf7c31feab02346d3c84c2335b8a06dc7df89dab0\"\n        \"5b6496fe428133c210c3bac68e18f026daa56662a41c36f9b55787fc1c5382d70b86e3\"\n        \"3be8555fd924606d2572c30a6ab6da71eccd4744ceb4e729519eef42ef4260db0e0158\"\n        \"32bfb0e742201fac36c711969a61243b08a77c372e44f76646fd1e9c9c06570447aa30\"\n        \"527339baceb1d002e24e6ee3114f5a5daf0062bd372f824a60eebd74afc4fecffe7454\"\n        \"1933411b575295e27891abc71fc0e9597f65fc51be21962eea0aec96214b40a1a8ef32\"\n        \"329df02a8b0ef038c48a1d5b2529ed01a820a6f262488de7791b07c5f941126be7893f\"\n        \"7dadfb9639892264bc01af40402aa87a44df1754ce4e17226c41a8e3f05e4883d6ef45\"\n        \"11e96378067f455f3a7275215622bfc71bb4db398b03b08e4bf6c54b2b6396c5b501fa\"\n        \"26782fc36ad22044f5eb6a8f83efc8850d70ae4525d4e798f2aa1894621803394415f3\"\n        \"4cd4d002a2b3d393efa7d57f687b753830ff04798c240f05f581ce706f7d151417f09f\"\n        \"17174cb87eff0e042c1860342b4ace069e1691e092e3\"\n    );\n\n    let aad = hex!(\n        \"5b187979e145d7b5beebbc0e689e759a027b5588059419b06b1afe4224f8f56ecccb2b\"\n        \"fe2cef9ecf103eb382172320a17c19dce14a3e38030d3443697845b992ff1e871c02e7\"\n        \"88d7b40264f52ef0733791dc82dacdfa987685b33423bed0c05e0a65bce48ce1006d16\"\n        \"628ea21b4390e75be72e043f299d6290289f90007474bf4e9ffb6c774d762afec8f3a0\"\n        \"1b2db545611772c32386fe6c7332125f0750c4987988d1e0e727c3c295bc743a34d319\"\n        \"6d5e2d14f11bf2c884265ba901e77144a4b5a77864ad082e945727786f376bfcae9904\"\n        \"8ee7a994a2ea87584cd2e7e83ffd0310cf9cdb2cff5cf8c9cc09c94becb3f37fb9b071\"\n        \"a76ee7ae115a49f0d95b1a9ec97e5b62bcae2c3cf47a3d2cb1b3d3dcd1729c33266ad7\"\n        \"b0899654949a6f09086b74297cb48227e566e1f401109495ea05d636a5025104cd04c2\"\n        \"a3c59f396b858f7f025825baf667b29b4f7f692f3a6c0c8956575a8dd183d1d03bd372\"\n        \"c214e005d6e1090d89f2d950b8ac856465943568bc320602f52bf67d30f0d8ec7a9550\"\n        \"dcdef99a43404a6d32d8f6b537b3eed568e32ab7ee63e16be63009702995d4d9300114\"\n        \"638ba4c874f02039f3f67e2df64946030edef1930f30d4e6b9ca95887539d1af2036c8\"\n        \"f5cf129c54d5734224e09b3daab5fb0e74c848af70a49c1499a5e56bc5eea90395df5b\"\n        \"fd3e84a1c0a5be02dd3f2e2353e5522aeadaafdbf44444\"\n    );\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext = hex!(\n        \"b8eddddb8d0042bb42fdf675bae285e504b90e4d73e02f99f790b2ffe7815dba40fe4c\"\n        \"7bc886ce44505f6ac53d3bba5d3c73efd98daf4b7a5af250a5d100ff5558c211cb03a2\"\n        \"8d9519502d7d0fc85a6d73e618feb6b503af12cb0330bb9c5743b19996174a84dbf5ba\"\n        \"c38d10d207067e4ab211a62ad0f85dd8245dfb077443017b7847996fe7ed547b9e0205\"\n        \"1f1cbe39128e21486b4f73399d0a50d9a1111bed11ebb0547454d0a922633c83f0bba7\"\n        \"84571f63f55dc33f92e09862471945312d99e40b4ed739556f102afd43055497739a4b\"\n        \"22d107e867cc652a5d96974ff785976c82bc1ff89731c780e84a257bb885cd23e00a7b\"\n        \"dc7a68e0a1668516fb972721a777429c76cfd4adb45afa554d44a8932d133af8c9254f\"\n        \"d3fef2bd0bb65801f2ffbf752f14eaa783e53c2342f021863598e88b20232a0c44e963\"\n        \"dd8943e9a54213ffbb174b90e38b55aa9b223e9596acb1517ff21b7458b76944880477\"\n        \"97c521883c00762e7227f1e8a5e3f11a43962bdccde8dc4009aef7628a96efa8793d60\"\n        \"80982f9b00a7b97d93fd5928702e78427f34eb434e2286de00216b405c36105dc2e8da\"\n        \"e68c3342a23274b32a6d2d8ac85239a8fa2947126f505a517fb18847104b21b0326b7f\"\n        \"d67efb54f5d0b12b311ef998ebaf14939b7cdb44b35435eedf1ba5b07eea99533f1857\"\n        \"b8cc1538290a8dbd44ca696c6bc2f1105451032a650c\"\n    );\n\n    let tag: [u8; 16] = hex!(\"e68a5de27beaeb6472611dfa9783602a\");\n\n    let encrypted = DeoxysII128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_128_8",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_128.rs",
    "relative_path": "deoxys/tests/deoxys_ii_128.rs",
    "file_name": "deoxys_ii_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.11.0_rc.0 cipher/impl/Cipher/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "0.11.0_rc.0 cipher/impl/Cipher/authenticate_lengths"
    ],
    "body": "    pub(crate) fn decrypt_inout_detached(\n        mut self,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n    ) -> Result<(), Error> {\n        if buffer.len() / BLOCK_SIZE >= MAX_BLOCKS {\n            return Err(Error);\n        }\n\n        self.mac.update_padded(associated_data);\n        self.mac.update_padded(buffer.get_in());\n        self.authenticate_lengths(associated_data, buffer.get_in())?;\n\n        // This performs a constant-time comparison using the `subtle` crate\n        if self.mac.verify(tag).is_ok() {\n            // TODO(tarcieri): interleave decryption with Poly1305\n            // See: <https://github.com/RustCrypto/AEADs/issues/74>\n            self.cipher.apply_keystream_inout(buffer);\n            Ok(())\n        } else {\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/cipher.rs",
    "relative_path": "chacha20poly1305/src/cipher.rs",
    "file_name": "cipher.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Element/GfElement/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new() -> Self {\n        Self(0, 0)\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "0.2.0_pre impl/Ocb3/decrypt_inout_return_tag",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre inplace_xor",
      "0.2.0_pre impl/Ocb3/wide_decrypt",
      "0.2.0_pre impl/Ocb3/compute_tag",
      "0.2.0_pre ntz"
    ],
    "body": "    pub(crate) fn decrypt_inout_return_tag(\n        &self,\n        nonce: &Nonce<NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> aead::Tag<Self> {\n        if (buffer.len() > C_MAX) || (associated_data.len() > A_MAX) {\n            unimplemented!()\n        }\n\n        // First, try to process many blocks at once.\n        let (tail, index, mut offset_i, mut checksum_i) = self.wide_decrypt(nonce, buffer);\n\n        let mut i = index;\n\n        // Then, process the remaining blocks.\n        let (blocks, mut tail): (InOutBuf<'_, '_, Block>, _) = tail.into_chunks();\n        for c_i in blocks {\n            // offset_i = offset_{i-1} xor L_{ntz(i)}\n            inplace_xor(&mut offset_i, &self.ll[ntz(i)]);\n            // p_i = offset_i xor DECIPHER(K, c_i xor offset_i)\n            let mut p_i = c_i;\n            p_i.xor_in2out(&offset_i);\n            self.cipher.decrypt_block(p_i.get_out());\n            inplace_xor(p_i.get_out(), &offset_i);\n            // checksum_i = checksum_{i-1} xor p_i\n            inplace_xor(&mut checksum_i, p_i.get_out());\n\n            i += 1;\n        }\n\n        // Process any partial blocks.\n        if !tail.is_empty() {\n            let remaining_bytes = tail.len();\n\n            // offset_* = offset_m xor L_*\n            inplace_xor(&mut offset_i, &self.ll_star);\n            // Pad = ENCIPHER(K, offset_*)\n            let mut pad = Block::default();\n            inplace_xor(&mut pad, &offset_i);\n            self.cipher.encrypt_block(&mut pad);\n            // P_* = C_* xor Pad[1..bitlen(C_*)]\n            let c_star = tail.get_in();\n            let pad = &mut pad[..c_star.len()];\n            tail.xor_in2out(pad);\n            // checksum_* = checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*)))\n            let checksum_rhs = &mut [0u8; 16];\n            checksum_rhs[..remaining_bytes].copy_from_slice(tail.get_out());\n            checksum_rhs[remaining_bytes] = 0b1000_0000;\n            inplace_xor(&mut checksum_i, checksum_rhs.as_ref());\n        }\n\n        self.compute_tag(associated_data, &mut checksum_i, &offset_i)\n    }",
    "display_name": "decrypt_inout_return_tag",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/decrypt_inout",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/impl/AsconCore/process_associated_data",
      "0.1.0_pre asconcore/impl/AsconCore/process_decrypt_inout",
      "0.1.0_pre asconcore/impl/AsconCore/process_final"
    ],
    "body": "    pub(crate) fn decrypt_inout(\n        &mut self,\n        mut ciphertext: InOutBuf<'_, '_, u8>,\n        associated_data: &[u8],\n        expected_tag: &Array<u8, U16>,\n    ) -> Result<(), Error> {\n        self.process_associated_data(associated_data);\n        self.process_decrypt_inout(ciphertext.reborrow());\n\n        let tag = self.process_final();\n        if bool::from(tag.ct_eq(expected_tag)) {\n            Ok(())\n        } else {\n            ciphertext.get_out().fill(0);\n            Err(Error)\n        }\n    }",
    "display_name": "decrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "siv/impl/Siv/encrypt_in_place",
    "statement_type": "function",
    "deps": [
      "siv/impl/Siv/encrypt_inout_detached"
    ],
    "body": "    pub fn encrypt_in_place<I, T>(\n        &mut self,\n        headers: I,\n        buffer: &mut dyn Buffer,\n    ) -> Result<(), Error>\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,\n    {\n        let pt_len = buffer.len();\n\n        // Make room in the buffer for the SIV tag. It needs to be prepended.\n        buffer.extend_from_slice(Tag::default().as_slice())?;\n\n        // TODO(tarcieri): add offset param to `encrypt_inout_detached`\n        buffer.as_mut().copy_within(..pt_len, IV_SIZE);\n\n        let tag = self.encrypt_inout_detached(headers, (&mut buffer.as_mut()[IV_SIZE..]).into())?;\n        buffer.as_mut()[..IV_SIZE].copy_from_slice(tag.as_slice());\n        Ok(())\n    }",
    "display_name": "encrypt_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Cipher/encrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "impl/Cipher/finish_tag",
      "init_ctr"
    ],
    "body": "    pub(crate) fn encrypt_inout_detached(\n        mut self,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n    ) -> Result<Tag, Error> {\n        if buffer.len() as u64 > P_MAX || associated_data.len() as u64 > A_MAX {\n            return Err(Error);\n        }\n\n        self.polyval.update_padded(associated_data);\n        self.polyval.update_padded(buffer.get_in());\n\n        let tag = self.finish_tag(associated_data.len(), buffer.len());\n        init_ctr(&self.enc_cipher, &tag).apply_keystream_partial(buffer);\n\n        Ok(tag)\n    }",
    "display_name": "encrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm-siv/src/lib.rs",
    "relative_path": "aes-gcm-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ivlen1024/encrypt",
    "statement_type": "function",
    "deps": [
      "impl/AesGcm/KeyInit/new"
    ],
    "body": "    fn encrypt() {\n        let key = hex!(\"71eebc49c8fb773b2224eaff3ad68714\");\n        let nonce = hex!(\n            \"07e961e67784011f72faafd95b0eb64089c8de15ad685ec57e63d56e679d3e20\n             2b18b75fcbbec3185ffc41653bc2ac4ae6ae8be8c85636f353a9d19a86100d0b\n             d035cc6bdefcab4318ac7b1a08b819427ad8f6abc782466c6ebd4d6a0dd76e78\n             389b0a2a66506bb85f038ffc1da220c24f3817c7b2d02c5e8fc5e7e3be5074bc\"\n        );\n        let plaintext = hex!(\"705da82292143d2c949dc4ba014f6396\");\n\n        let ciphertext = Aes128GcmWith1024BitNonce::new(&key.into())\n            .encrypt(&Array(nonce), &plaintext[..])\n            .unwrap();\n\n        let (ct, tag) = ciphertext.split_at(ciphertext.len() - 16);\n        assert_eq!(hex!(\"032363cf0828a03553478bec0f51f372\"), ct);\n        assert_eq!(hex!(\"c681b2c568feaa21900bc44b86aeb946\"), tag);\n    }",
    "display_name": "encrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/tests/other_ivlen.rs",
    "relative_path": "aes-gcm/tests/other_ivlen.rs",
    "file_name": "other_ivlen.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "deoxys_bc/h_substitution",
    "statement_type": "function",
    "deps": [],
    "body": "fn h_substitution(tk: &mut [u8; 16]) {\n    let mut result = [0u8; 16];\n\n    for i in 0..16 {\n        result[i] = tk[H_PERM[i] as usize];\n    }\n\n    tk.copy_from_slice(&result);\n}",
    "display_name": "h_substitution",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/deoxys_bc.rs",
    "relative_path": "deoxys/src/deoxys_bc.rs",
    "file_name": "deoxys_bc.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_6_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_6_13, \"cavp_ccm_aes128_6_13\", Ccm<Aes128, U6, U13>);\naead::new_test!(cavp_ccm_aes128_8_13, \"cavp_ccm_aes128_8_13\", Ccm<Aes128, U8, U13>);\naead::new_test!(cavp_ccm_aes128_10_13, \"cavp_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\naead::new_test!(cavp_ccm_aes128_12_13, \"cavp_ccm_aes128_12_13\", Ccm<Aes128, U12, U13>);\naead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_6_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "wycheproof",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(wycheproof, \"wycheproof-128\", Aes128Gcm);",
    "display_name": "wycheproof",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-gcm/tests/aes128gcm.rs",
    "relative_path": "aes-gcm/tests/aes128gcm.rs",
    "file_name": "aes128gcm.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/StreamBE32/NewStream/from_aead",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from_aead(aead: A, nonce: &Nonce<A, Self>) -> Self {\n        Self {\n            aead,\n            nonce: nonce.clone(),\n        }\n    }",
    "display_name": "from_aead",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "gf/gf128_soft64/impl/Element/GfElement/into_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    fn into_bytes(self) -> Block {\n        let mut block = Block::default();\n        block[8..].copy_from_slice(&self.0.to_le_bytes());\n        block[..8].copy_from_slice(&self.1.to_le_bytes());\n        block\n    }",
    "display_name": "into_bytes",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "impl/StreamBE32/aead_nonce",
    "statement_type": "function",
    "deps": [],
    "body": "    fn aead_nonce(&self, position: u32, last_block: bool) -> aead::Nonce<A> {\n        let mut result = Array::default();\n\n        // TODO(tarcieri): use `generic_array::sequence::Concat` (or const generics)\n        let (prefix, tail) = result.split_at_mut(NonceSize::<A, Self>::to_usize());\n        prefix.copy_from_slice(&self.nonce);\n\n        let (counter, flag) = tail.split_at_mut(4);\n        counter.copy_from_slice(&position.to_be_bytes());\n        flag[0] = last_block as u8;\n\n        result\n    }",
    "display_name": "aead_nonce",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_256_7",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_256_7() {\n    let plaintext = hex!(\"8a968861ccb4aa1b7744ffff4812e001d1a749df3f66497c1c717681c43987b4eb\");\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f10\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"0001020304050607\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: [u8; 33] =\n        hex!(\"705f9db5d50ec6ff0ae28557a5640d32b19504833d5fc6de3baf638cef4cda50bc\");\n\n    let tag: [u8; 16] = hex!(\"88f06bac360362824401c8f1385073a8\");\n\n    let encrypted = DeoxysI256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_256_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_256.rs",
    "relative_path": "deoxys/tests/deoxys_i_256.rs",
    "file_name": "deoxys_i_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_ii_256_4",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_256_4() {\n    let plaintext = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext = hex!(\"9da20db1c2781f6669257d87e2a4d9be1970f7581bef2c995e1149331e5e8cc1\");\n\n    let tag: [u8; 16] = hex!(\"92ce3aec3a4b72ff9eab71c2a93492fa\");\n\n    let encrypted = DeoxysII256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_256_4",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_256.rs",
    "relative_path": "deoxys/tests/deoxys_ii_256.rs",
    "file_name": "deoxys_ii_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "ghash/impl/GHash/new_with_init_block",
    "statement_type": "function",
    "deps": [
      "gf/gf128_soft64/impl/Element/From, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>>>/from",
      "gf/gf128_soft64/impl/Element/From/from"
    ],
    "body": "    pub(crate) fn new_with_init_block(h: &Key, s: u128) -> Self {\n        Self {\n            s: Element::from(s),\n            h: Element::from(h),\n        }\n    }",
    "display_name": "new_with_init_block",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/ghash.rs",
    "relative_path": "belt-dwp/src/ghash.rs",
    "file_name": "ghash.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes128_8_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes128_8_13, \"cavp_ccm_aes128_8_13\", Ccm<Aes128, U8, U13>);\naead::new_test!(cavp_ccm_aes128_10_13, \"cavp_ccm_aes128_10_13\", Ccm<Aes128, U10, U13>);\naead::new_test!(cavp_ccm_aes128_12_13, \"cavp_ccm_aes128_12_13\", Ccm<Aes128, U12, U13>);\naead::new_test!(cavp_ccm_aes128_14_13, \"cavp_ccm_aes128_14_13\", Ccm<Aes128, U14, U13>);\naead::new_test!(cavp_ccm_aes128_16_7, \"cavp_ccm_aes128_16_7\", Ccm<Aes128, U16, U7>);\naead::new_test!(cavp_ccm_aes128_16_8, \"cavp_ccm_aes128_16_8\", Ccm<Aes128, U16, U8>);\naead::new_test!(cavp_ccm_aes128_16_9, \"cavp_ccm_aes128_16_9\", Ccm<Aes128, U16, U9>);\naead::new_test!(cavp_ccm_aes128_16_10, \"cavp_ccm_aes128_16_10\", Ccm<Aes128, U16, U10>);\naead::new_test!(cavp_ccm_aes128_16_11, \"cavp_ccm_aes128_16_11\", Ccm<Aes128, U16, U11>);\naead::new_test!(cavp_ccm_aes128_16_12, \"cavp_ccm_aes128_16_12\", Ccm<Aes128, U16, U12>);\naead::new_test!(cavp_ccm_aes128_16_13, \"cavp_ccm_aes128_16_13\", Ccm<Aes128, U16, U13>);\n\naead::new_test!(cavp_ccm_aes192_4_7, \"cavp_ccm_aes192_4_7\", Ccm<Aes192, U4, U7>);\naead::new_test!(cavp_ccm_aes192_4_13, \"cavp_ccm_aes192_4_13\", Ccm<Aes192, U4, U13>);\naead::new_test!(cavp_ccm_aes192_6_13, \"cavp_ccm_aes192_6_13\", Ccm<Aes192, U6, U13>);\naead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes128_8_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/encrypt_inout",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/impl/AsconCore/process_associated_data",
      "0.1.0_pre asconcore/impl/AsconCore/process_encrypt_inout",
      "0.1.0_pre asconcore/impl/AsconCore/process_final"
    ],
    "body": "    pub(crate) fn encrypt_inout(\n        &mut self,\n        message: InOutBuf<'_, '_, u8>,\n        associated_data: &[u8],\n    ) -> Array<u8, U16> {\n        self.process_associated_data(associated_data);\n        self.process_encrypt_inout(message);\n        Array::from(self.process_final())\n    }",
    "display_name": "encrypt_inout",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes192_8_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes192_8_13, \"cavp_ccm_aes192_8_13\", Ccm<Aes192, U8, U13>);\naead::new_test!(cavp_ccm_aes192_10_13, \"cavp_ccm_aes192_10_13\", Ccm<Aes192, U10, U13>);\naead::new_test!(cavp_ccm_aes192_12_13, \"cavp_ccm_aes192_12_13\", Ccm<Aes192, U12, U13>);\naead::new_test!(cavp_ccm_aes192_14_13, \"cavp_ccm_aes192_14_13\", Ccm<Aes192, U14, U13>);\naead::new_test!(cavp_ccm_aes192_16_7, \"cavp_ccm_aes192_16_7\", Ccm<Aes192, U16, U7>);\naead::new_test!(cavp_ccm_aes192_16_8, \"cavp_ccm_aes192_16_8\", Ccm<Aes192, U16, U8>);\naead::new_test!(cavp_ccm_aes192_16_9, \"cavp_ccm_aes192_16_9\", Ccm<Aes192, U16, U9>);\naead::new_test!(cavp_ccm_aes192_16_10, \"cavp_ccm_aes192_16_10\", Ccm<Aes192, U16, U10>);\naead::new_test!(cavp_ccm_aes192_16_11, \"cavp_ccm_aes192_16_11\", Ccm<Aes192, U16, U11>);\naead::new_test!(cavp_ccm_aes192_16_12, \"cavp_ccm_aes192_16_12\", Ccm<Aes192, U16, U12>);\naead::new_test!(cavp_ccm_aes192_16_13, \"cavp_ccm_aes192_16_13\", Ccm<Aes192, U16, U13>);\n\naead::new_test!(cavp_ccm_aes256_4_7, \"cavp_ccm_aes256_4_7\", Ccm<Aes256, U4, U7>);\naead::new_test!(cavp_ccm_aes256_4_13, \"cavp_ccm_aes256_4_13\", Ccm<Aes256, U4, U13>);\naead::new_test!(cavp_ccm_aes256_6_13, \"cavp_ccm_aes256_6_13\", Ccm<Aes256, U6, U13>);\naead::new_test!(cavp_ccm_aes256_8_13, \"cavp_ccm_aes256_8_13\", Ccm<Aes256, U8, U13>);\naead::new_test!(cavp_ccm_aes256_10_13, \"cavp_ccm_aes256_10_13\", Ccm<Aes256, U10, U13>);\naead::new_test!(cavp_ccm_aes256_12_13, \"cavp_ccm_aes256_12_13\", Ccm<Aes256, U12, U13>);\naead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes192_8_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "0.2.0_pre initial_offset",
    "statement_type": "function",
    "deps": [
      "0.2.0_pre nonce_dependent_variables"
    ],
    "body": "fn initial_offset<\n    Cipher: BlockSizeUser<BlockSize = U16> + BlockCipherEncrypt,\n    NonceSize: sealed::NonceSizes,\n>(\n    cipher: &Cipher,\n    nn: &Nonce<NonceSize>,\n    tag_size: u32,\n) -> Block {\n    let (bottom, stretch) = nonce_dependent_variables(cipher, nn, tag_size);\n    let stretch_low = u128::from_be_bytes((&stretch[..16]).try_into().unwrap());\n    let stretch_hi = u64::from_be_bytes((&stretch[16..24]).try_into().unwrap());\n    let stretch_hi = u128::from(stretch_hi);\n\n    // offset_0 = stretch[1+bottom..128+bottom]\n    let offset = (stretch_low << bottom) | (stretch_hi >> (64 - bottom));\n    offset.to_be_bytes().into()\n}",
    "display_name": "initial_offset",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/src/lib.rs",
    "relative_path": "ocb3/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_14_13",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_14_13, \"cavp_ccm_aes256_14_13\", Ccm<Aes256, U14, U13>);\naead::new_test!(cavp_ccm_aes256_16_7, \"cavp_ccm_aes256_16_7\", Ccm<Aes256, U16, U7>);\naead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_14_13",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "gf/gf128_soft64/from_block",
    "statement_type": "function",
    "deps": [],
    "body": "fn from_block(block: &Block) -> [u64; 2] {\n    let (a, b) = block.split_at(8);\n    [\n        u64::from_le_bytes(b.try_into().unwrap()),\n        u64::from_le_bytes(a.try_into().unwrap()),\n    ]\n}",
    "display_name": "from_block",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/src/gf/gf128_soft64.rs",
    "relative_path": "belt-dwp/src/gf/gf128_soft64.rs",
    "file_name": "gf128_soft64.rs",
    "parent_folder": "gf"
  },
  {
    "identifier": "impl/SivAead/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "siv/impl/Siv/decrypt_inout_detached",
      "siv/impl/Siv/KeyInit/new"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Array<u8, Self::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Array<u8, Self::TagSize>,\n    ) -> Result<(), Error> {\n        Siv::<C, M>::new(&self.key).decrypt_inout_detached(\n            [associated_data, nonce.as_slice()],\n            buffer,\n            tag,\n        )\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/lib.rs",
    "relative_path": "aes-siv/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "tests/fill_aad_header_test",
    "statement_type": "function",
    "deps": [
      "fill_aad_header"
    ],
    "body": "    fn fill_aad_header_test() {\n        use super::fill_aad_header;\n        use hex_literal::hex;\n\n        let (n, b) = fill_aad_header(0x0123);\n        assert_eq!(n, 2);\n        assert_eq!(b[..], hex!(\"01230000000000000000000000000000\")[..]);\n\n        let (n, b) = fill_aad_header(0xFF00);\n        assert_eq!(n, 6);\n        assert_eq!(b[..], hex!(\"FFFE0000FF0000000000000000000000\")[..]);\n\n        let (n, b) = fill_aad_header(0x01234567);\n        assert_eq!(n, 6);\n        assert_eq!(b[..], hex!(\"FFFE0123456700000000000000000000\")[..]);\n\n        #[cfg(target_pointer_width = \"64\")]\n        {\n            let (n, b) = fill_aad_header(0x0123456789ABCDEF);\n            assert_eq!(n, 10);\n            assert_eq!(b[..], hex!(\"FFFF0123456789ABCDEF000000000000\")[..]);\n        }\n    }",
    "display_name": "fill_aad_header_test",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.2.0_pre rfc7253_ocb_aes",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(rfc7253_ocb_aes, \"rfc7253_ocb_aes\", Aes128Ocb3);\n\nfn num2str96(num: usize) -> [u8; 12] {\n    let num: u32 = num.try_into().unwrap();\n    let mut out = [0u8; 12];\n    out[8..12].copy_from_slice(&num.to_be_bytes());\n    out\n}",
    "display_name": "rfc7253_ocb_aes",
    "full_path": "file:///home/lacra/git_repos/AEADs/ocb3/tests/kats.rs",
    "relative_path": "ocb3/tests/kats.rs",
    "file_name": "kats.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "siv/impl/Siv/encrypt",
    "statement_type": "function",
    "deps": [
      "siv/impl/Siv/encrypt_in_place"
    ],
    "body": "    pub fn encrypt<I, T>(&mut self, headers: I, plaintext: &[u8]) -> Result<Vec<u8>, Error>\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,\n    {\n        let mut buffer = Vec::with_capacity(plaintext.len() + IV_SIZE);\n        buffer.extend_from_slice(plaintext);\n        self.encrypt_in_place(headers, &mut buffer)?;\n        Ok(buffer)\n    }",
    "display_name": "encrypt",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "cavp_ccm_aes256_16_8",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_16_8, \"cavp_ccm_aes256_16_8\", Ccm<Aes256, U16, U8>);\naead::new_test!(cavp_ccm_aes256_16_9, \"cavp_ccm_aes256_16_9\",Ccm<Aes256, U16, U9>);\naead::new_test!(cavp_ccm_aes256_16_10, \"cavp_ccm_aes256_16_10\", Ccm<Aes256, U16, U10>);\naead::new_test!(cavp_ccm_aes256_16_11, \"cavp_ccm_aes256_16_11\", Ccm<Aes256, U16, U11>);\naead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_16_8",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "impl/Ccm/calc_mac",
    "statement_type": "function",
    "deps": [
      "impl/CbcMac/finalize",
      "private/SealedNonce/get_max_len",
      "impl/CbcMac/block_update",
      "fill_aad_header",
      "impl/CbcMac/from_cipher",
      "impl/CbcMac/update",
      "private/SealedNonce/get_l",
      "private/SealedTag/get_m_tick"
    ],
    "body": "    fn calc_mac(\n        &self,\n        nonce: &Nonce<N>,\n        adata: &[u8],\n        buffer: &[u8],\n    ) -> Result<Tag<C::BlockSize>, Error> {\n        let is_ad = !adata.is_empty();\n        let l = N::get_l();\n        let flags = 64 * (is_ad as u8) + 8 * M::get_m_tick() + (l - 1);\n\n        if buffer.len() > N::get_max_len() {\n            return Err(Error);\n        }\n\n        let mut b0 = Block::<C>::default();\n        b0[0] = flags;\n        let n = 1 + N::to_usize();\n        b0[1..n].copy_from_slice(nonce);\n\n        let cb = b0.len() - n;\n        // the max len check makes certain that we discard only\n        // zero bytes from `b`\n        if cb > 4 {\n            let b = (buffer.len() as u64).to_be_bytes();\n            b0[n..].copy_from_slice(&b[b.len() - cb..]);\n        } else {\n            let b = (buffer.len() as u32).to_be_bytes();\n            b0[n..].copy_from_slice(&b[b.len() - cb..]);\n        }\n\n        let mut mac = CbcMac::from_cipher(&self.cipher);\n        mac.block_update(&b0);\n\n        if !adata.is_empty() {\n            let alen = adata.len();\n            let (n, mut b) = fill_aad_header(alen);\n            if b.len() - n >= alen {\n                b[n..][..alen].copy_from_slice(adata);\n                mac.block_update(&b);\n            } else {\n                let (l, r) = adata.split_at(b.len() - n);\n                b[n..].copy_from_slice(l);\n                mac.block_update(&b);\n                mac.update(r);\n            }\n        }\n\n        mac.update(buffer);\n\n        Ok(mac.finalize())\n    }",
    "display_name": "calc_mac",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/src/lib.rs",
    "relative_path": "ccm/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Deoxys/AeadInOut/decrypt_inout_detached",
    "statement_type": "function",
    "deps": [
      "DeoxysMode/decrypt_inout"
    ],
    "body": "    fn decrypt_inout_detached(\n        &self,\n        nonce: &Nonce<M::NonceSize>,\n        associated_data: &[u8],\n        buffer: InOutBuf<'_, '_, u8>,\n        tag: &Tag,\n    ) -> Result<(), Error> {\n        M::decrypt_inout(nonce, associated_data, buffer, tag, &self.subkeys)\n    }",
    "display_name": "decrypt_inout_detached",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/new",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/u64_from_bytes"
    ],
    "body": "    pub(crate) fn new(internal_key: &'a P::InternalKey, nonce: &Array<u8, U16>) -> Self {\n        let mut state = State::new(\n            P::IV,\n            internal_key.get_k1(),\n            internal_key.get_k2(),\n            u64_from_bytes(&nonce[..8]),\n            u64_from_bytes(&nonce[8..]),\n        );\n\n        state.permute_12();\n        state[3] ^= internal_key.get_k1();\n        state[4] ^= internal_key.get_k2();\n\n        Self {\n            state,\n            key: internal_key,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_i_128_1",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_128_1() {\n    let plaintext = Vec::new();\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"eec87dce98d29d4078598abd16d550ff\");\n\n    let encrypted = DeoxysI128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_i_128_1",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_128.rs",
    "relative_path": "deoxys/tests/deoxys_i_128.rs",
    "file_name": "deoxys_i_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_i_128_4",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_128_4() {\n    let plaintext = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext = hex!(\"4bf8c5ecec375b25acabd687aa605f1a8bb296face74f82527d4944dbb11b757\");\n\n    let tag: [u8; 16] = hex!(\"f32754de1727da4909413815a64e6a69\");\n\n    let encrypted = DeoxysI128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_128_4",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_128.rs",
    "relative_path": "deoxys/tests/deoxys_i_128.rs",
    "file_name": "deoxys_i_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "tests/impl/MockBuffer/as_in_out_buf",
    "statement_type": "function",
    "deps": [],
    "body": "        pub fn as_in_out_buf(&mut self) -> InOutBuf<'_, '_, u8> {\n            InOutBuf::new(self.in_buf.as_slice(), self.out_buf.as_mut_slice())\n                .expect(\"Invariant violation\")\n        }",
    "display_name": "as_in_out_buf",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/StreamLE31/aead_nonce",
    "statement_type": "function",
    "deps": [],
    "body": "    fn aead_nonce(&self, position: u32, last_block: bool) -> Result<aead::Nonce<A>> {\n        if position > Self::COUNTER_MAX {\n            return Err(Error);\n        }\n\n        let mut result = Array::default();\n\n        // TODO(tarcieri): use `generic_array::sequence::Concat` (or const generics)\n        let (prefix, tail) = result.split_at_mut(NonceSize::<A, Self>::to_usize());\n        prefix.copy_from_slice(&self.nonce);\n\n        let position_with_flag = position | ((last_block as u32) << 31);\n        tail.copy_from_slice(&position_with_flag.to_le_bytes());\n\n        Ok(result)\n    }",
    "display_name": "aead_nonce",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/InternalKey16/From, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>, aead::consts::B0>>>/from",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/u64_from_bytes"
    ],
    "body": "    fn from(key: &Array<u8, U16>) -> Self {\n        Self(u64_from_bytes(&key[..8]), u64_from_bytes(&key[8..]))\n    }",
    "display_name": "from",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_128_5",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_128_5() {\n    let plaintext = hex!(\"06ac1756eccece62bd743fa80c299f7baa3872b556130f52265919494bdc136db3\");\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext = hex!(\"82bf241958b324ed053555d23315d3cc20935527fc970ff34a9f521a95e302136d\");\n\n    let tag: [u8; 16] = hex!(\"0eadc8612d5208c491e93005195e9769\");\n\n    let encrypted = DeoxysII128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_128_5",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_128.rs",
    "relative_path": "deoxys/tests/deoxys_ii_128.rs",
    "file_name": "deoxys_ii_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "DeoxysBcType/precompute_subkeys",
    "statement_type": "function",
    "deps": [],
    "body": "    fn precompute_subkeys(key: &Array<u8, Self::KeySize>) -> Array<DeoxysKey, Self::SubkeysSize>;\n\n    /// Encrypts a block of data in place.\n    fn encrypt_inout(\n        mut block: InOut<'_, '_, Block>,\n        tweak: &Tweak,\n        subkeys: &Array<DeoxysKey, Self::SubkeysSize>,\n    ) {\n        let keys = Self::key_schedule(tweak, subkeys);\n\n        block.xor_in2out(&keys[0]);\n\n        for k in &keys[1..] {\n            aes::hazmat::cipher_round(block.get_out(), k);\n        }\n    }",
    "display_name": "precompute_subkeys",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "StreamPrimitive/encryptor",
    "statement_type": "function",
    "deps": [
      "impl/Encryptor/from_stream_primitive"
    ],
    "body": "    fn encryptor(self) -> Encryptor<A, Self>\n    where\n        Self: Sized,\n    {\n        Encryptor::from_stream_primitive(self)\n    }",
    "display_name": "encryptor",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.11.0_rc.0 cipher/impl/Cipher/new",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn new(mut cipher: C) -> Self {\n        // Derive Poly1305 key from the first 32-bytes of the ChaCha20 keystream\n        let mut mac_key = poly1305::Key::default();\n        cipher.apply_keystream(&mut mac_key);\n\n        let mac = Poly1305::new(&mac_key);\n        #[cfg(feature = \"zeroize\")]\n        {\n            use zeroize::Zeroize;\n            mac_key.zeroize();\n        }\n\n        // Set ChaCha20 counter to 1\n        cipher.seek(BLOCK_SIZE as u64);\n\n        Self { cipher, mac }\n    }",
    "display_name": "new",
    "full_path": "file:///home/lacra/git_repos/AEADs/chacha20poly1305/src/cipher.rs",
    "relative_path": "chacha20poly1305/src/cipher.rs",
    "file_name": "cipher.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "online/impl/Eax/finish",
    "statement_type": "function",
    "deps": [
      "online/impl/EaxImpl/tag"
    ],
    "body": "    pub fn finish(self) -> Tag<M> {\n        self.imp.tag()\n    }",
    "display_name": "finish",
    "full_path": "file:///home/lacra/git_repos/AEADs/eax/src/online.rs",
    "relative_path": "eax/src/online.rs",
    "file_name": "online.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_128_4",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_128_4() {\n    let plaintext = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext = hex!(\"fa22f8eb84ee6d2388bdb16150232e856cd5fa3508bc589dad16d284208048c9\");\n\n    let tag: [u8; 16] = hex!(\"a381b06ef16db99df089e738c3b4064a\");\n\n    let encrypted = DeoxysII128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_128_4",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_128.rs",
    "relative_path": "deoxys/tests/deoxys_ii_128.rs",
    "file_name": "deoxys_ii_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "sp800_38c_examples",
    "statement_type": "function",
    "deps": [],
    "body": "fn sp800_38c_examples() {\n    macro_rules! check {\n        (\n            $key:expr, $m:ty, $n:ty,\n            nonce: $nonce:expr, adata: $adata:expr, pt: $pt:expr, ct: $ct:expr,\n        ) => {\n            let key = Array($key);\n            let c = Ccm::<aes::Aes128, $m, $n>::new(&key);\n            let nonce = Array($nonce);\n            let res = c.encrypt(&nonce, Payload { aad: &$adata, msg: &$pt })\n                .unwrap();\n            assert_eq!(res, &$ct);\n            let res = c.decrypt(&nonce, Payload { aad: &$adata, msg: &$ct })\n                .unwrap();\n            assert_eq!(res, &$pt);\n        };\n    }\n\n    let key = hex!(\"40414243 44454647 48494a4b 4c4d4e4f\");\n\n    check!(\n        key, U4, U7,\n        nonce: hex!(\"10111213 141516\"),\n        adata: hex!(\"00010203 04050607\"),\n        pt: hex!(\"20212223\"),\n        ct: hex!(\"7162015b 4dac255d\"),\n    );\n\n    check!(\n        key, U6, U8,\n        nonce: hex!(\"10111213 14151617\"),\n        adata: hex!(\"00010203 04050607 08090a0b 0c0d0e0f\"),\n        pt: hex!(\"20212223 24252627 28292a2b 2c2d2e2f\"),\n        ct: hex!(\"d2a1f0e0 51ea5f62 081a7792 073d593d 1fc64fbf accd\"),\n    );\n\n    check!(\n        key, U8, U12,\n        nonce: hex!(\"10111213 14151617 18191a1b\"),\n        adata: hex!(\"00010203 04050607 08090a0b 0c0d0e0f 10111213\"),\n        pt: hex!(\"\n            20212223 24252627 28292a2b 2c2d2e2f\n            30313233 34353637\n        \"),\n        ct: hex!(\"\n            e3b201a9 f5b71a7a 9b1ceaec cd97e70b\n            6176aad9 a4428aa5 484392fb c1b09951\n        \"),\n    );\n\n    let adata = (0..524288 / 8).map(|i| i as u8).collect::<Vec<u8>>();\n    check!(\n        key, U14, U13,\n        nonce: hex!(\"10111213 14151617 18191a1b 1c\"),\n        adata: adata,\n        pt: hex!(\"\n            20212223 24252627 28292a2b 2c2d2e2f\n            30313233 34353637 38393a3b 3c3d3e3f\n        \"),\n        ct: hex!(\"\n            69915dad 1e84c637 6a68c296 7e4dab61\n            5ae0fd1f aec44cc4 84828529 463ccf72\n            b4ac6bec 93e8598e 7f0dadbc ea5b\n        \"),\n    );\n}",
    "display_name": "sp800_38c_examples",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_ii_128_7",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_128_7() {\n    let plaintext = hex!(\"039ca0907aa315a0d5ba020c84378840023d4ad3ba639787d3f6f46cb446bd63dc\");\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f10\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: [u8; 33] =\n        hex!(\"801f1b81878faca562c8c6c0859b166c2669fbc54b1784be637827b4905729bdf9\");\n\n    let tag: [u8; 16] = hex!(\"fe4e9bcd26b96647350eda1e550cc994\");\n\n    let encrypted = DeoxysII128::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII128::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_128_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_128.rs",
    "relative_path": "deoxys/tests/deoxys_ii_128.rs",
    "file_name": "deoxys_ii_128.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_i_256_2",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_256_2() {\n    let plaintext = Vec::new();\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"0001020304050607\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext: Vec<u8> = Vec::new();\n\n    let tag: [u8; 16] = hex!(\"0e641b45bcffb3c07fa7f7d31edc37d2\");\n\n    let encrypted = DeoxysI256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(plaintext, decrypted);\n}",
    "display_name": "test_deoxys_i_256_2",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_256.rs",
    "relative_path": "deoxys/tests/deoxys_i_256.rs",
    "file_name": "deoxys_i_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "test_deoxys_i_256_5",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_i_256_5() {\n    let plaintext = hex!(\"9d63bc34aceebe70b21768e4f1cfd87bacbcae1e2577b6018de1d72707a42b2569\");\n\n    let aad = Vec::new();\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"0001020304050607\");\n    let nonce = Array::try_from(&nonce[..8]).unwrap();\n\n    let ciphertext = hex!(\"fd1ea6745fb5b435751d92be58f5973b84c7589501fcfaff6ce07e2a0e9a72c23e\");\n\n    let tag: [u8; 16] = hex!(\"e957add57b7c5924d9a22db6fe03cce7\");\n\n    let encrypted = DeoxysI256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysI256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_i_256_5",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_i_256.rs",
    "relative_path": "deoxys/tests/deoxys_i_256.rs",
    "file_name": "deoxys_i_256.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "cavp_ccm_aes256_16_12",
    "statement_type": "function",
    "deps": [],
    "body": "aead::new_test!(cavp_ccm_aes256_16_12, \"cavp_ccm_aes256_16_12\", Ccm<Aes256, U16, U12>);\naead::new_test!(cavp_ccm_aes256_16_13, \"cavp_ccm_aes256_16_13\", Ccm<Aes256, U16, U13>);",
    "display_name": "cavp_ccm_aes256_16_12",
    "full_path": "file:///home/lacra/git_repos/AEADs/ccm/tests/mod.rs",
    "relative_path": "ccm/tests/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "encrypt_aad_only_16kb",
    "statement_type": "function",
    "deps": [
      "impl/Dwp/AeadInOut/encrypt_inout_detached"
    ],
    "body": "fn encrypt_aad_only_16kb(b: &mut Bencher) {\n    let c = BeltDwp::new(&KEY);\n    let aad = vec![0; 16 * 1024];\n    let mut buf = [];\n\n    b.iter(|| {\n        let (aad, buf, nonce) = test::black_box((&aad, &mut buf[..], &NONCE));\n        let res = c.encrypt_inout_detached(nonce, aad, buf.into()).unwrap();\n        test::black_box(res);\n    });\n\n    b.bytes = 16 * 1024;\n}",
    "display_name": "encrypt_aad_only_16kb",
    "full_path": "file:///home/lacra/git_repos/AEADs/belt-dwp/benches/mod.rs",
    "relative_path": "belt-dwp/benches/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "impl/Decryptor/decrypt_last",
    "statement_type": "function",
    "deps": [],
    "body": "    decrypt_last,\n    decrypt_last_in_place,\n    decrypt,\n    decrypt_in_place,\n    \"decrypt\",\n    \"ùíü STREAM decryptor\"\n);\n\n/// STREAM encryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type EncryptorBE32<A> = Encryptor<A, StreamBE32<A>>;\n\n/// STREAM decryptor instantiated with [`StreamBE32`] as the underlying\n/// STREAM primitive.\npub type DecryptorBE32<A> = Decryptor<A, StreamBE32<A>>;\n\n/// STREAM encryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type EncryptorLE31<A> = Encryptor<A, StreamLE31<A>>;\n\n/// STREAM decryptor instantiated with [`StreamLE31`] as the underlying\n/// STREAM primitive.\npub type DecryptorLE31<A> = Decryptor<A, StreamLE31<A>>;\n\n/// The original \"Rogaway-flavored\" STREAM as described in the paper\n/// [Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance][1].\n///\n/// Uses a 32-bit big endian counter and 1-byte \"last block\" flag stored as\n/// the last 5-bytes of the AEAD nonce.\n///\n/// [1]: https://eprint.iacr.org/2015/189.pdf\n#[derive(Debug)]\npub struct StreamBE32<A>\nwhere\n    A: AeadInOut,\n    A::NonceSize: Sub<U5>,\n    <<A as AeadCore>::NonceSize as Sub<U5>>::Output: ArraySize,\n{\n    /// Underlying AEAD cipher\n    aead: A,\n\n    /// Nonce (sans STREAM overhead)\n    nonce: Nonce<A, Self>,\n}",
    "display_name": "decrypt_last",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/Deoxys/Drop/drop",
    "statement_type": "function",
    "deps": [],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        {\n            use zeroize::Zeroize;\n            for s in self.subkeys.iter_mut() {\n                s.zeroize();\n            }\n        }\n    }",
    "display_name": "drop",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/src/lib.rs",
    "relative_path": "deoxys/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "siv/s2v",
    "statement_type": "function",
    "deps": [
      "siv/xor_in_place"
    ],
    "body": "fn s2v<M, I, T>(mac: &mut M, headers: I, message: &[u8]) -> Result<Tag, Error>\nwhere\n    M: Mac<OutputSize = U16> + FixedOutputReset,\n    I: IntoIterator<Item = T>,\n    T: AsRef<[u8]>,\n{\n    Mac::update(mac, &Tag::default());\n    let mut state = mac.finalize_reset().into_bytes();\n\n    for (i, header) in headers.into_iter().enumerate() {\n        if i >= MAX_HEADERS {\n            return Err(Error);\n        }\n\n        state = state.dbl();\n        Mac::update(mac, header.as_ref());\n        let code = mac.finalize_reset().into_bytes();\n        xor_in_place(&mut state, &code);\n    }\n\n    if message.len() >= IV_SIZE {\n        let n = message.len().checked_sub(IV_SIZE).unwrap();\n\n        Mac::update(mac, &message[..n]);\n        xor_in_place(&mut state, &message[n..]);\n    } else {\n        state = state.dbl();\n        xor_in_place(&mut state, message);\n        state[message.len()] ^= 0x80;\n    };\n\n    Mac::update(mac, state.as_ref());\n    Ok(mac.finalize_reset().into_bytes())\n}",
    "display_name": "s2v",
    "full_path": "file:///home/lacra/git_repos/AEADs/aes-siv/src/siv.rs",
    "relative_path": "aes-siv/src/siv.rs",
    "file_name": "siv.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.0_pre asconcore/impl/AsconCore/process_associated_data",
    "statement_type": "function",
    "deps": [
      "0.1.0_pre asconcore/impl/AsconCore/permute_state",
      "0.1.0_pre asconcore/pad",
      "0.1.0_pre asconcore/u64_from_bytes_partial",
      "0.1.0_pre asconcore/u64_from_bytes"
    ],
    "body": "    fn process_associated_data(&mut self, associated_data: &[u8]) {\n        if !associated_data.is_empty() {\n            // TODO: replace with as_chunks once stabilized\n            // https://github.com/rust-lang/rust/issues/74985\n\n            let mut blocks = associated_data.chunks_exact(16);\n            for block in blocks.by_ref() {\n                // process full block of associated data\n                self.state[0] ^= u64_from_bytes(&block[..8]);\n                self.state[1] ^= u64_from_bytes(&block[8..16]);\n                self.permute_state();\n            }\n\n            // process partial block if it exists\n            let mut last_block = blocks.remainder();\n            let sidx = if last_block.len() >= 8 {\n                self.state[0] ^= u64_from_bytes(&last_block[..8]);\n                last_block = &last_block[8..];\n                1\n            } else {\n                0\n            };\n            self.state[sidx] ^= pad(last_block.len());\n            if !last_block.is_empty() {\n                self.state[sidx] ^= u64_from_bytes_partial(last_block);\n            }\n            self.permute_state();\n        }\n\n        // domain separation\n        self.state[4] ^= 0x8000000000000000;\n    }",
    "display_name": "process_associated_data",
    "full_path": "file:///home/lacra/git_repos/AEADs/ascon-aead128/src/asconcore.rs",
    "relative_path": "ascon-aead128/src/asconcore.rs",
    "file_name": "asconcore.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "impl/StreamBE32/StreamPrimitive/encrypt_in_place",
    "statement_type": "function",
    "deps": [
      "impl/StreamBE32/aead_nonce"
    ],
    "body": "    fn encrypt_in_place(\n        &self,\n        position: u32,\n        last_block: bool,\n        associated_data: &[u8],\n        buffer: &mut dyn Buffer,\n    ) -> Result<()> {\n        let nonce = self.aead_nonce(position, last_block);\n        self.aead.encrypt_in_place(&nonce, associated_data, buffer)\n    }",
    "display_name": "encrypt_in_place",
    "full_path": "file:///home/lacra/git_repos/AEADs/aead-stream/src/lib.rs",
    "relative_path": "aead-stream/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "test_deoxys_ii_256_7",
    "statement_type": "function",
    "deps": [
      "impl/Deoxys/KeyInit/new"
    ],
    "body": "fn test_deoxys_ii_256_7() {\n    let plaintext = hex!(\"422857fb165af0a35c03199fb895604dca9cea6d788954962c419e0d5c225c0327\");\n\n    let aad = hex!(\"000102030405060708090a0b0c0d0e0f10\");\n\n    let payload = Payload {\n        msg: &plaintext,\n        aad: &aad,\n    };\n\n    let key = hex!(\"101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f\");\n    let key = Array(key);\n\n    let nonce = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let nonce = Array::try_from(&nonce[..15]).unwrap();\n\n    let ciphertext: [u8; 33] =\n        hex!(\"7d772203fa38be296d8d20d805163130c69aba8cb16ed845c2296c61a8f34b394e\");\n\n    let tag: [u8; 16] = hex!(\"0b3f10e3933c78190b24b33008bf80e9\");\n\n    let encrypted = DeoxysII256::new(&key).encrypt(&nonce, payload).unwrap();\n\n    let tag_begins = encrypted.len() - 16;\n    assert_eq!(ciphertext, encrypted[..tag_begins]);\n    assert_eq!(tag, encrypted[tag_begins..]);\n\n    let payload = Payload {\n        msg: &encrypted,\n        aad: &aad,\n    };\n\n    let decrypted = DeoxysII256::new(&key).decrypt(&nonce, payload).unwrap();\n\n    assert_eq!(&plaintext[..], &decrypted[..]);\n}",
    "display_name": "test_deoxys_ii_256_7",
    "full_path": "file:///home/lacra/git_repos/AEADs/deoxys/tests/deoxys_ii_256.rs",
    "relative_path": "deoxys/tests/deoxys_ii_256.rs",
    "file_name": "deoxys_ii_256.rs",
    "parent_folder": "tests"
  }
]