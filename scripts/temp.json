[
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core arith/ops/Sub",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Sub",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/len",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "len",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/PartialEq/eq",
    "statement_type": "function",
    "deps": [],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/non_adjacent_form",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core num/wrapping_sub",
      "read_le_u64_into"
    ],
    "body": "    pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {\n        // required by the NAF definition\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        debug_assert!(w <= 8);\n\n        let mut naf = [0i8; 256];\n\n        let mut x_u64 = [0u64; 5];\n        read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }\n\n        naf\n    }",
    "display_name": "non_adjacent_form",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core fmt/Debug",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Debug",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/Product/product",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/fold",
      "core https:/github.com/rust_lang/rust/library/core accum/traits/iter/Sum",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator",
      "core https:/github.com/rust_lang/rust/library/core borrow/Borrow"
    ],
    "body": "    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }",
    "display_name": "product",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "bot_half",
    "statement_type": "function",
    "deps": [],
    "body": "        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }",
    "display_name": "bot_half",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> Scalar {\n        -&self\n    }",
    "display_name": "neg",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core arith/ops/Sub"
    ],
    "body": "    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core double_ended/traits/iter/DoubleEndedIterator",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "DoubleEndedIterator",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core cmp/Eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Eq",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "pack",
    "statement_type": "function",
    "deps": [],
    "body": "    fn pack(&self) -> Scalar {\n        Scalar {\n            bytes: self.to_bytes(),\n        }\n    }",
    "display_name": "pack",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/from_canonical_bytes",
    "statement_type": "function",
    "deps": [
      "Scalar/is_canonical",
      "core https:/github.com/rust_lang/rust/library/core fmt/Debug"
    ],
    "body": "    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }",
    "display_name": "from_canonical_bytes",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/to_le_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_le_bytes",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/Index/index",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core arith/ops/MulAssign"
    ],
    "body": "    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }",
    "display_name": "index",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/from_bytes_mod_order",
    "statement_type": "function",
    "deps": [
      "Scalar/reduce"
    ],
    "body": "    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> Scalar {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }",
    "display_name": "from_bytes_mod_order",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core arith/ops/Add"
    ],
    "body": "    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Add/add",
    "statement_type": "function",
    "deps": [
      "Scalar/unpack",
      "core https:/github.com/rust_lang/rust/library/core arith/ops/SubAssign"
    ],
    "body": "    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }",
    "display_name": "add",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/invert",
    "statement_type": "function",
    "deps": [
      "Scalar/unpack"
    ],
    "body": "    pub fn invert(&self) -> Scalar {\n        self.unpack().invert().pack()\n    }",
    "display_name": "invert",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Neg/neg",
    "statement_type": "function",
    "deps": [
      "Scalar/unpack",
      "core https:/github.com/rust_lang/rust/library/core arith/ops/Neg"
    ],
    "body": "    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }",
    "display_name": "neg",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }",
    "display_name": "from_bytes_mod_order_wide",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "montgomery_invert",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn montgomery_invert(&self) -> UnpackedScalar {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let    _1 = *self;\n        let   _10 = _1.montgomery_square();\n        let  _100 = _10.montgomery_square();\n        let   _11 = UnpackedScalar::montgomery_mul(&_10,     &_1);\n        let  _101 = UnpackedScalar::montgomery_mul(&_10,    &_11);\n        let  _111 = UnpackedScalar::montgomery_mul(&_10,   &_101);\n        let _1001 = UnpackedScalar::montgomery_mul(&_10,   &_111);\n        let _1011 = UnpackedScalar::montgomery_mul(&_10,  &_1001);\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n\n        #[inline]\n        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,       4, &_1001);\n        square_multiply(&mut y,       2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 3, &_101);\n        square_multiply(&mut y,   3 + 3, &_101);\n        square_multiply(&mut y,       3, &_111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   2 + 3, &_111);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,   2 + 4, &_1011);\n        square_multiply(&mut y,   6 + 4, &_1001);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1001);\n        square_multiply(&mut y,   1 + 3, &_111);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   1 + 2, &_11);\n\n        y\n    }",
    "display_name": "montgomery_invert",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/Default/default",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/From"
    ],
    "body": "    fn default() -> Scalar {\n        Scalar::ZERO\n    }",
    "display_name": "default",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "square_multiply",
    "statement_type": "function",
    "deps": [],
    "body": "        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }",
    "display_name": "square_multiply",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/chunks",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "chunks",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "top_half",
    "statement_type": "function",
    "deps": [
      "bot_half",
      "read_le_u64_into"
    ],
    "body": "        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }",
    "display_name": "top_half",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core default/Default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Default",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "copy_from_slice",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "map",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/random",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core marker/Sized",
      "Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        let mut scalar_bytes = [0u8; 64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }",
    "display_name": "random",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core arith/ops/Neg",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Neg",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/conditional_select",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core accum/traits/iter/Product",
      "core https:/github.com/rust_lang/rust/library/core borrow/Borrow"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Iterator",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/reduce",
    "statement_type": "function",
    "deps": [
      "Scalar/unpack"
    ],
    "body": "    fn reduce(&self) -> Scalar {\n        let x = self.unpack();\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        x_mod_l.pack()\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core arith/ops/SubAssign",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "SubAssign",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/From/from",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "core https:/github.com/rust_lang/rust/library/core convert/From",
      "core https:/github.com/rust_lang/rust/library/core num/to_le_bytes",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice"
    ],
    "body": "    fn from(x: u128) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
    "display_name": "from",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "invert",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core marker/Sized"
    ],
    "body": "    pub fn invert(&self) -> UnpackedScalar {\n        self.as_montgomery().montgomery_invert().from_montgomery()\n    }",
    "display_name": "invert",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/bits_le",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core double_ended/traits/iter/DoubleEndedIterator"
    ],
    "body": "    pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n        (0..256).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }",
    "display_name": "bits_le",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/unpack",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn unpack(&self) -> UnpackedScalar {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }",
    "display_name": "unpack",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core accum/traits/iter/Sum",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Sum",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "expect",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core arith/ops/MulAssign",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "MulAssign",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core convert/From",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "From",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/is_canonical",
    "statement_type": "function",
    "deps": [
      "Scalar/reduce"
    ],
    "body": "    fn is_canonical(&self) -> Choice {\n        self.ct_eq(&self.reduce())\n    }",
    "display_name": "is_canonical",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/as_radix_16",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn as_radix_16(&self) -> [i8; 64] {\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8; 64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[allow(clippy::identity_op)]\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        for i in 0..32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        output\n    }",
    "display_name": "as_radix_16",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/wrapping_sub",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "wrapping_sub",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Sub/sub",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core arith/ops/Neg",
      "Scalar/unpack"
    ],
    "body": "    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }",
    "display_name": "sub",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.bytes\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "zip",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core cmp/PartialEq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "PartialEq",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.bytes\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core index/ops/Index",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Index",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "read_le_u64_into",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/chunks",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "core https:/github.com/rust_lang/rust/library/core slice/iter_mut",
      "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "core https:/github.com/rust_lang/rust/library/core num/from_le_bytes",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip"
    ],
    "body": "fn read_le_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(\n        src.len() == 8 * dst.len(),\n        \"src.len() = {}, dst.len() = {}\",\n        src.len(),\n        dst.len()\n    );\n    for (bytes, val) in src.chunks(8).zip(dst.iter_mut()) {\n        *val = u64::from_le_bytes(\n            bytes\n                .try_into()\n                .expect(\"Incorrect src length, should be 8 * dst.len()\"),\n        );\n    }\n}",
    "display_name": "read_le_u64_into",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core arith/ops/Mul",
      "Scalar/unpack"
    ],
    "body": "    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "try_into",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "clamp_integer",
    "statement_type": "function",
    "deps": [],
    "body": "pub const fn clamp_integer(mut bytes: [u8; 32]) -> [u8; 32] {\n    bytes[0] &= 0b1111_1000;\n    bytes[31] &= 0b0111_1111;\n    bytes[31] |= 0b0100_0000;\n    bytes\n}",
    "display_name": "clamp_integer",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core arith/ops/Mul",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Mul",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core arith/ops/AddAssign",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "AddAssign",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Mul/mul",
    "statement_type": "function",
    "deps": [
      "Scalar/unpack",
      "core https:/github.com/rust_lang/rust/library/core arith/ops/AddAssign"
    ],
    "body": "    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }",
    "display_name": "mul",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core arith/ops/Add",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Add",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/fold",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "fold",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core borrow/Borrow",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Borrow",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core marker/Sized",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Sized",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/fold",
      "core https:/github.com/rust_lang/rust/library/core default/Default"
    ],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/iter_mut",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "iter_mut",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core cmp/PartialEq",
      "core https:/github.com/rust_lang/rust/library/core cmp/Eq"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core accum/traits/iter/Product",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "Product",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "Scalar/ct_eq",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core index/ops/Index"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.bytes.ct_eq(&other.bytes)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/from_le_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_le_bytes",
    "full_path": "file:///work/temp/scalar.rs",
    "relative_path": "scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "temp"
  }
]