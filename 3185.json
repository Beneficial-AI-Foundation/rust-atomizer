[
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "sum",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "CtOption/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/optional_mixe",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/double",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/Identity/identity",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/as_extended",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 window/NafLookupTable5/From/from",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_projective"
    ],
    "body": "    {\n        cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n        let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n        if token_avx512.get() {\n            return BackendKind::Avx512;\n        }\n    }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_shuffle_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_shuffle_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "/// A Diffie-Hellman secret key which may be used more than once, but is\n/// purposefully not serialiseable in order to discourage key-reuse.  This is\n/// implemented to facilitate protocols such as Noise (e.g. Noise IK key usage,\n/// etc.) and X3DH which require an \"ephemeral\" key to conduct the\n/// Diffie-Hellman operation multiple times throughout the protocol, while the\n/// protocol run at a higher level is only conducted once per key.\n///\n/// Similarly to [`EphemeralSecret`], this type does _not_ have serialisation\n/// methods, in order to discourage long-term usage of secret key material. (For\n/// long-term secret keys, see `StaticSecret`.)\n///\n/// # Warning\n///\n/// If you're uncertain about whether you should use this, then you likely\n/// should not be using this.  Our strongly recommended advice is to use\n/// [`EphemeralSecret`] at all times, as that type enforces at compile-time that\n/// secret keys are never reused, which can have very serious security\n/// implications for many protocols.\n#[cfg(feature = \"reusable_secrets\")]\n#[derive(Clone)]\npub struct ReusableSecret(pub(crate) [u8; 32]);\n\n#[cfg(feature = \"reusable_secrets\")]\nimpl ReusableSecret {\n    /// Perform a Diffie-Hellman key agreement between `self` and\n    /// `their_public` key to produce a [`SharedSecret`].\n    pub fn diffie_hellman(&self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }\n\n    /// Generate a new [`ReusableSecret`] with the supplied RNG.\n    pub fn random_from_rng<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {\n        // The secret key is random bytes. Clamping is done later.\n        let mut bytes = [0u8; 32];\n        csprng.fill_bytes(&mut bytes);\n        ReusableSecret(bytes)\n    }\n\n    /// Generate a new [`ReusableSecret`].\n    #[cfg(feature = \"os_rng\")]\n    pub fn random() -> Self {\n        Self::random_from_rng(&mut rand_core::OsRng.unwrap_mut())\n    }\n}",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/first",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "first",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/blend",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/diff_sum"
    ],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "0.1.1 process_impl",
    "statement_type": "function",
    "deps": [
      "clone/gen/Generics/Clone/clone",
      "0.1.1 process_function",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/push",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/new",
      "alloc https:/github.com/rust_lang/rust/library/alloc boxed/Box/new",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/drain",
      "alloc https:/github.com/rust_lang/rust/library/alloc boxed/Box/Clone/clone",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "fn process_impl(attributes: &syn::LitStr, mut item_impl: syn::ItemImpl) -> TokenStream {\n    unsupported_if_some!(item_impl.defaultness);\n    unsupported_if_some!(item_impl.unsafety);\n\n    let mut items = Vec::new();\n    for item in item_impl.items.drain(..) {\n        match item {\n            syn::ImplItem::Fn(function) => {\n                unsupported_if_some!(function.defaultness);\n                let function = syn::ItemFn {\n                    attrs: function.attrs,\n                    vis: function.vis,\n                    sig: function.sig,\n                    block: Box::new(function.block),\n                };\n                let output_item = process_function(\n                    attributes,\n                    function,\n                    Some((item_impl.generics.clone(), item_impl.self_ty.clone())),\n                );\n                items.push(syn::ImplItem::Verbatim(output_item.into()));\n            }\n            item => items.push(item),\n        }\n    }\n\n    item_impl.items = items;\n    quote::quote! {\n        #item_impl\n    }\n    .into()\n}",
    "display_name": "process_impl",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_unpacklo_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_unpacklo_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectiveNielsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/is_small_order",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/is_small_order"
    ],
    "body": "    fn is_small_order() {\n        // The basepoint has large prime order\n        assert!(!constants::ED25519_BASEPOINT_POINT.is_small_order());\n        // constants::EIGHT_TORSION has all points of small order.\n        for torsion_point in &constants::EIGHT_TORSION {\n            assert!(torsion_point.is_small_order());\n        }\n    }",
    "display_name": "is_small_order",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "power2/arithmetic/lemma_pow2_unfold",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_pow2_unfold",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 Signature/from_components",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_components",
    "full_path": "file:///work/3185/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/elligator_encode",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square2",
      "5.0.0_pre.0 field/FieldElement51/sqrt_ratio_i",
      "ConditionallyNegatable/conditional_negate",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_select",
      "5.0.0_pre.0 field/FieldElement51/invert"
    ],
    "body": "\n    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
    "display_name": "elligator_encode",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/StaticSecret/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/montgomery_radix",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n",
    "display_name": "montgomery_radix",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 Signature/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_wide_to_nat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_wide_to_nat_rec"
    ],
    "body": "}\n\nverus! {\n\n/// u64 * u64 = u128 multiply helper\n#[inline(always)]\nfn m(x: u64, y: u64) -> (z: u128)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures\n    z < (1u128 << 104),\n    z == x * y\n{\n    proof {lemma_52_52(x, y);}\n    (x as u128) * (y as u128)\n}\n\nimpl Scalar52 {\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: Scalar52 = Scalar52 { limbs: [0, 0, 0, 0, 0] };\n\n    /// Unpack a 32 byte / 256 bit scalar into 5 52-bit limbs.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n    ensures bytes_to_nat(bytes) == to_nat(&s.limbs)\n    {\n        let mut words = [0u64; 4];\n        for i in 0..4\n            invariant 0 <= i <= 4 // proof\n        {\n            for j in 0..8\n                invariant 0 <= j <= 8 && i < 4\n            {\n                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64)*8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)\n        assume(bytes_to_nat(bytes) == words_to_nat(&words));\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n\n        s.limbs[0] =   words[0]                            & mask;\n        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] =  (words[3] >> 16)                     & top_mask;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }\n\n    /// Reduce a 64 byte / 512 bit scalar mod l\n    #[rustfmt::skip] // keep alignment of lo[*] and hi[*] calculations\n    #[verifier::external_body] // TODO Verify this function\n    pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n    ensures\n        limbs_bounded(&s),\n        to_nat(&s.limbs) == bytes_wide_to_nat(bytes) % group_order(),\n    {\n        assume(false); // TODO: complete the proof\n        let mut words = [0u64; 8];\n        for i in 0..8 {\n            for j in 0..8 {\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        let mut hi = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n\n        lo[0] =   words[0]                             & mask;\n        lo[1] = ((words[0] >> 52) | (words[ 1] << 12)) & mask;\n        lo[2] = ((words[1] >> 40) | (words[ 2] << 24)) & mask;\n        lo[3] = ((words[2] >> 28) | (words[ 3] << 36)) & mask;\n        lo[4] = ((words[3] >> 16) | (words[ 4] << 48)) & mask;\n        hi[0] =  (words[4] >>  4)                      & mask;\n        hi[1] = ((words[4] >> 56) | (words[ 5] <<  8)) & mask;\n        hi[2] = ((words[5] >> 44) | (words[ 6] << 20)) & mask;\n        hi[3] = ((words[6] >> 32) | (words[ 7] << 32)) & mask;\n        hi[4] =   words[7] >> 20                             ;\n\n        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar52::add(&hi, &lo)\n    }\n\n    /// Pack the limbs of this `Scalar52` into 32 bytes\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    #[allow(clippy::identity_op)]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_bytes(self) -> (s: [u8; 32])\n    ensures bytes_to_nat(&s) == to_nat(&self.limbs)\n    {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.limbs[ 0] >>  0)                      as u8;\n        s[ 1] =  (self.limbs[ 0] >>  8)                      as u8;\n        s[ 2] =  (self.limbs[ 0] >> 16)                      as u8;\n        s[ 3] =  (self.limbs[ 0] >> 24)                      as u8;\n        s[ 4] =  (self.limbs[ 0] >> 32)                      as u8;\n        s[ 5] =  (self.limbs[ 0] >> 40)                      as u8;\n        s[ 6] = ((self.limbs[ 0] >> 48) | (self.limbs[ 1] << 4)) as u8;\n        s[ 7] =  (self.limbs[ 1] >>  4)                      as u8;\n        s[ 8] =  (self.limbs[ 1] >> 12)                      as u8;\n        s[ 9] =  (self.limbs[ 1] >> 20)                      as u8;\n        s[10] =  (self.limbs[ 1] >> 28)                      as u8;\n        s[11] =  (self.limbs[ 1] >> 36)                      as u8;\n        s[12] =  (self.limbs[ 1] >> 44)                      as u8;\n        s[13] =  (self.limbs[ 2] >>  0)                      as u8;\n        s[14] =  (self.limbs[ 2] >>  8)                      as u8;\n        s[15] =  (self.limbs[ 2] >> 16)                      as u8;\n        s[16] =  (self.limbs[ 2] >> 24)                      as u8;\n        s[17] =  (self.limbs[ 2] >> 32)                      as u8;\n        s[18] =  (self.limbs[ 2] >> 40)                      as u8;\n        s[19] = ((self.limbs[ 2] >> 48) | (self.limbs[ 3] << 4)) as u8;\n        s[20] =  (self.limbs[ 3] >>  4)                      as u8;\n        s[21] =  (self.limbs[ 3] >> 12)                      as u8;\n        s[22] =  (self.limbs[ 3] >> 20)                      as u8;\n        s[23] =  (self.limbs[ 3] >> 28)                      as u8;\n        s[24] =  (self.limbs[ 3] >> 36)                      as u8;\n        s[25] =  (self.limbs[ 3] >> 44)                      as u8;\n        s[26] =  (self.limbs[ 4] >>  0)                      as u8;\n        s[27] =  (self.limbs[ 4] >>  8)                      as u8;\n        s[28] =  (self.limbs[ 4] >> 16)                      as u8;\n        s[29] =  (self.limbs[ 4] >> 24)                      as u8;\n        s[30] =  (self.limbs[ 4] >> 32)                      as u8;\n        s[31] =  (self.limbs[ 4] >> 40)                      as u8;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }\n\n    /// Compute `a + b` (mod l)\n    pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order(),\n    {\n        let mut sum = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector); }\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        for i in 0..5\n           invariant\n                    forall|j: int| 0 <= j < i ==> sum.limbs[j] < 1u64 << 52,\n                    limbs_bounded(a),\n                    limbs_bounded(b),\n                    mask == (1u64 << 52) - 1,\n                    i == 0 ==> carry == 0,\n                    i >= 1 ==> (carry >> 52) < 2,\n        {\n            proof {lemma_add_loop_bounds(i as int, carry, a.limbs[i as int], b.limbs[i as int]);}\n            carry = a.limbs[i] + b.limbs[i] + (carry >> 52);\n            sum.limbs[i] = carry & mask;\n            proof {lemma_add_carry_and_sum_bounds(carry, mask);}\n        }\n\n        // subtract l if the sum is >= l\n        proof { lemma_l_value_properties(&constants::L, &sum); }\n        let result = Scalar52::sub(&sum, &constants::L);\n        assume(to_nat(&result.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order());\n        result\n\n    }\n\n    /// Compute `a - b` (mod l)\n    pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) + group_order() - to_nat(&b.limbs)) % (group_order() as int)\n    {\n        let mut difference = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector);}\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        for i in 0..5\n            invariant\n                      limbs_bounded(b),\n                      forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n                      mask == (1u64 << 52) - 1,\n        {\n            proof { assert ((borrow >> 63) < 2) by (bit_vector); }\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            difference.limbs[i] = borrow & mask;\n            proof { lemma_borrow_and_mask_bounded(borrow, mask); }\n        }\n\n        // conditionally add l if the difference is negative\n        let mut carry: u64 = 0;\n        for i in 0..5\n            invariant\n                      forall|j: int| 0 <= j < 5 ==> difference.limbs[j] < (1u64 << 52),  // from first loop\n                      mask == (1u64 << 52) - 1,\n                      i == 0 ==> carry == 0,\n                      i >= 1 ==> (carry >> 52) < 2,\n        {\n            let underflow = Choice::from((borrow >> 63) as u8);\n            let addend = select(&0, &constants::L.limbs[i], underflow);\n            proof {lemma_scalar_subtract_no_overflow(carry, difference.limbs[i as int], addend, i as u32, &constants::L);}\n            carry = (carry >> 52) + difference.limbs[i] + addend;\n            difference.limbs[i] = carry & mask;\n            proof { lemma_carry_bounded_after_mask(carry, mask); }\n        }\n        assume(to_nat(&difference.limbs) == (to_nat(&a.limbs) + group_order() - to_nat(&b.limbs)) % (group_order() as int));\n        difference\n    }\n\n    /// Compute `a * b`\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of z[*] calculations\n    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&b.limbs),\n    {\n        proof {lemma_mul_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n\n        z[0] = m(a.limbs[0], b.limbs[0]);\n        z[1] = m(a.limbs[0], b.limbs[1]) + m(a.limbs[1], b.limbs[0]);\n        z[2] = m(a.limbs[0], b.limbs[2]) + m(a.limbs[1], b.limbs[1]) + m(a.limbs[2], b.limbs[0]);\n        z[3] = m(a.limbs[0], b.limbs[3]) + m(a.limbs[1], b.limbs[2]) + m(a.limbs[2], b.limbs[1]) + m(a.limbs[3], b.limbs[0]);\n        z[4] = m(a.limbs[0], b.limbs[4]) + m(a.limbs[1], b.limbs[3]) + m(a.limbs[2], b.limbs[2]) + m(a.limbs[3], b.limbs[1]) + m(a.limbs[4], b.limbs[0]);\n        z[5] =                 m(a.limbs[1], b.limbs[4]) + m(a.limbs[2], b.limbs[3]) + m(a.limbs[3], b.limbs[2]) + m(a.limbs[4], b.limbs[1]);\n        z[6] =                                 m(a.limbs[2], b.limbs[4]) + m(a.limbs[3], b.limbs[3]) + m(a.limbs[4], b.limbs[2]);\n        z[7] =                                                 m(a.limbs[3], b.limbs[4]) + m(a.limbs[4], b.limbs[3]);\n        z[8] =                                                                 m(a.limbs[4], b.limbs[4]);\n\n        proof {lemma_mul_internal_correct(&a.limbs, &b.limbs, &z);}\n\n        z\n    }\n\n\n    // TODO Make this function more like the original?\n    /// Compute `a^2`\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of calculations\n    pub (crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n    {\n        proof {lemma_square_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(a.limbs[2], a.limbs[2]);\n        z[5] =                 m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] =                                 m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] =                                                 m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] =                                                                 m(a.limbs[4], a.limbs[4]);\n\n        proof {lemma_square_internal_correct(&a.limbs, &z);}\n\n        z\n    }\n\n    /// Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^260\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of n* and r* calculations\n    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    ensures\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == slice128_to_nat(limbs) % group_order(),\n        limbs_bounded(&result),\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = Self::part1(limbs[0]);\n        let (carry, n1) = Self::part1(carry + limbs[1] + m(n0, l.limbs[1]));\n        let (carry, n2) = Self::part1(carry + limbs[2] + m(n0, l.limbs[2]) + m(n1, l.limbs[1]));\n        let (carry, n3) = Self::part1(carry + limbs[3] + m(n1, l.limbs[2]) + m(n2, l.limbs[1]));\n        let (carry, n4) = Self::part1(carry + limbs[4] + m(n0, l.limbs[4]) + m(n2, l.limbs[2]) + m(n3, l.limbs[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = Self::part2(carry + limbs[5] + m(n1, l.limbs[4]) + m(n3, l.limbs[2]) + m(n4, l.limbs[1]));\n        let (carry, r1) = Self::part2(carry + limbs[6] + m(n2, l.limbs[4]) + m(n4, l.limbs[2]));\n        let (carry, r2) = Self::part2(carry + limbs[7] + m(n3, l.limbs[4]));\n        let (carry, r3) = Self::part2(carry + limbs[8] + m(n4, l.limbs[4]));\n        let r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52 { limbs: [r0, r1, r2, r3, r4] }, l)\n    }\n\n\n    /// Helper function for Montgomery reduction\n    #[inline(always)]\n    fn part1(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n        let carry = (sum + m(p, constants::L.limbs[0])) >> 52;\n        (carry, p)\n    }\n\n    /// Helper function for Montgomery reduction\n    #[inline(always)]\n    fn part2(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let w = (sum as u64) & ((1u64 << 52) - 1);\n        let carry = sum >> 52;\n        (carry, w)\n    }\n\n    /// Compute `a * b` (mod l)\n    #[inline(never)]\n    pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR))\n    }\n\n    /// Compute `a^2` (mod l)\n    #[inline(never)]\n    #[allow(dead_code)] // XXX we don't expose square() via the Scalar API\n    pub fn square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR))\n    }\n\n    /// Compute `(a * b) / R` (mod l), where R is the Montgomery modulus 2^260\n    #[inline(never)]\n    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }\n\n    /// Compute `(a^2) / R` (mod l) in Montgomery form, where R is the Montgomery modulus 2^260\n    #[inline(never)]\n    pub fn montgomery_square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }\n\n    /// Puts a Scalar52 in to Montgomery form, i.e. computes `a*R (mod l)`\n    #[inline(never)]\n    pub fn as_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order(),\n    {\n        proof {\n            lemma_rr_limbs_bounded();\n        }\n        let result = Scalar52::montgomery_mul(self, &constants::RR);\n        assume(to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order());\n        result\n    }\n\n    /// Takes a Scalar52 out of Montgomery form, i.e. computes `a/R (mod l)`\n    #[allow(clippy::wrong_self_convention)]\n    #[inline(never)]\n    pub fn from_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == to_nat(&self.limbs) % group_order(),\n    {\n        let mut limbs = [0u128; 9];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5\n            invariant\n                forall|j: int| #![auto] 0 <= j < i ==> limbs[j] == self.limbs[j] as u128,\n                forall|j: int| #![auto] i <= j < 9 ==> limbs[j] == 0,\n        {\n            limbs[i] = self.limbs[i] as u128;\n        }\n        let result = Scalar52::montgomery_reduce(&limbs);\n        proof {\n            lemma_from_montgomery_limbs_conversion(&limbs, &self.limbs);\n        }\n        result\n    }\n}\n\n\n} // verus!",
    "display_name": "bytes_wide_to_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/from_bytes",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "core https:/github.com/rust_lang/rust/library/core result/Result/map_err"
    ],
    "body": "    }\n}\n\nimpl Verifier<Signature> for SigningKey {\n    /// Verify a signature on a message with this signing key's public key.\n    fn verify(&self, message: &[u8], signature: &Signature) -> Result<(), SignatureError> {\n        self.verifying_key.verify(message, signature)\n    }\n}",
    "display_name": "try_from",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 test/hazmat/sign_verify_nonspec",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/From/from",
      "3.0.0_pre.0 hazmat/raw_sign",
      "3.0.0_pre.0 hazmat/raw_verify",
      "TryRngCore/unwrap_err",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "3.0.0_pre.0 test/hazmat/ExpandedSecretKey/random"
    ],
    "body": "    fn sign_verify_nonspec() {\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        let msg = b\"Then one day, a piano fell on my head\";\n\n        // Sign and verify\n        let sig = raw_sign::<CtxDigest>(&esk, msg, &vk);\n        raw_verify::<CtxDigest>(&vk, msg, &sig).unwrap();\n    }",
    "display_name": "sign_verify_nonspec",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery_benches/montgomery_benches",
    "statement_type": "function",
    "deps": [
      "Criterion/benchmark_group",
      "5.0.0_pre.0 montgomery_benches/montgomery_ladder",
      "Criterion/Default/default",
      "5.0.0_pre.0 montgomery_benches/consttime_fixed_base_scalar_mul"
    ],
    "body": "    pub(crate) fn montgomery_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"montgomery benches\");\n\n        montgomery_ladder(&mut g);\n        consttime_fixed_base_scalar_mul(&mut g);\n    }",
    "display_name": "montgomery_benches",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "    fn default() -> Scalar {\n        Scalar::ZERO\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/montgomery_to_edwards_rejects_twist",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "core https:/github.com/rust_lang/rust/library/core option/Option/is_none",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_edwards"
    ],
    "body": "    fn montgomery_to_edwards_rejects_twist() {\n        let one = FieldElement::ONE;\n\n        // u = 2 corresponds to a point on the twist.\n        let two = MontgomeryPoint((&one + &one).to_bytes());\n\n        assert!(two.to_edwards(0).is_none());\n\n        // u = -1 corresponds to a point on the twist, but should be\n        // checked explicitly because it's an exceptional point for the\n        // birational map.  For instance, libsignal will accept it.\n        let minus_one = MontgomeryPoint((-&one).to_bytes());\n\n        assert!(minus_one.to_edwards(0).is_none());\n    }",
    "display_name": "montgomery_to_edwards_rejects_twist",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/PublicKey/as_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/as_bytes"
    ],
    "body": "    pub fn as_bytes(&self) -> &[u8; 32] {\n        self.0.as_bytes()\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/one_way_map",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/RistrettoPoint/from_uniform_bytes",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress"
    ],
    "body": "    fn one_way_map() {\n        // These inputs are from\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#appendix-A.3\n        let test_vectors: &[([u8; 64], CompressedRistretto)] = &[\n            (\n                [\n                    0x5d, 0x1b, 0xe0, 0x9e, 0x3d, 0x0c, 0x82, 0xfc, 0x53, 0x81, 0x12, 0x49, 0x0e,\n                    0x35, 0x70, 0x19, 0x79, 0xd9, 0x9e, 0x06, 0xca, 0x3e, 0x2b, 0x5b, 0x54, 0xbf,\n                    0xfe, 0x8b, 0x4d, 0xc7, 0x72, 0xc1, 0x4d, 0x98, 0xb6, 0x96, 0xa1, 0xbb, 0xfb,\n                    0x5c, 0xa3, 0x2c, 0x43, 0x6c, 0xc6, 0x1c, 0x16, 0x56, 0x37, 0x90, 0x30, 0x6c,\n                    0x79, 0xea, 0xca, 0x77, 0x05, 0x66, 0x8b, 0x47, 0xdf, 0xfe, 0x5b, 0xb6,\n                ],\n                CompressedRistretto([\n                    0x30, 0x66, 0xf8, 0x2a, 0x1a, 0x74, 0x7d, 0x45, 0x12, 0x0d, 0x17, 0x40, 0xf1,\n                    0x43, 0x58, 0x53, 0x1a, 0x8f, 0x04, 0xbb, 0xff, 0xe6, 0xa8, 0x19, 0xf8, 0x6d,\n                    0xfe, 0x50, 0xf4, 0x4a, 0x0a, 0x46,\n                ]),\n            ),\n            (\n                [\n                    0xf1, 0x16, 0xb3, 0x4b, 0x8f, 0x17, 0xce, 0xb5, 0x6e, 0x87, 0x32, 0xa6, 0x0d,\n                    0x91, 0x3d, 0xd1, 0x0c, 0xce, 0x47, 0xa6, 0xd5, 0x3b, 0xee, 0x92, 0x04, 0xbe,\n                    0x8b, 0x44, 0xf6, 0x67, 0x8b, 0x27, 0x01, 0x02, 0xa5, 0x69, 0x02, 0xe2, 0x48,\n                    0x8c, 0x46, 0x12, 0x0e, 0x92, 0x76, 0xcf, 0xe5, 0x46, 0x38, 0x28, 0x6b, 0x9e,\n                    0x4b, 0x3c, 0xdb, 0x47, 0x0b, 0x54, 0x2d, 0x46, 0xc2, 0x06, 0x8d, 0x38,\n                ],\n                CompressedRistretto([\n                    0xf2, 0x6e, 0x5b, 0x6f, 0x7d, 0x36, 0x2d, 0x2d, 0x2a, 0x94, 0xc5, 0xd0, 0xe7,\n                    0x60, 0x2c, 0xb4, 0x77, 0x3c, 0x95, 0xa2, 0xe5, 0xc3, 0x1a, 0x64, 0xf1, 0x33,\n                    0x18, 0x9f, 0xa7, 0x6e, 0xd6, 0x1b,\n                ]),\n            ),\n            (\n                [\n                    0x84, 0x22, 0xe1, 0xbb, 0xda, 0xab, 0x52, 0x93, 0x8b, 0x81, 0xfd, 0x60, 0x2e,\n                    0xff, 0xb6, 0xf8, 0x91, 0x10, 0xe1, 0xe5, 0x72, 0x08, 0xad, 0x12, 0xd9, 0xad,\n                    0x76, 0x7e, 0x2e, 0x25, 0x51, 0x0c, 0x27, 0x14, 0x07, 0x75, 0xf9, 0x33, 0x70,\n                    0x88, 0xb9, 0x82, 0xd8, 0x3d, 0x7f, 0xcf, 0x0b, 0x2f, 0xa1, 0xed, 0xff, 0xe5,\n                    0x19, 0x52, 0xcb, 0xe7, 0x36, 0x5e, 0x95, 0xc8, 0x6e, 0xaf, 0x32, 0x5c,\n                ],\n                CompressedRistretto([\n                    0x00, 0x6c, 0xcd, 0x2a, 0x9e, 0x68, 0x67, 0xe6, 0xa2, 0xc5, 0xce, 0xa8, 0x3d,\n                    0x33, 0x02, 0xcc, 0x9d, 0xe1, 0x28, 0xdd, 0x2a, 0x9a, 0x57, 0xdd, 0x8e, 0xe7,\n                    0xb9, 0xd7, 0xff, 0xe0, 0x28, 0x26,\n                ]),\n            ),\n            (\n                [\n                    0xac, 0x22, 0x41, 0x51, 0x29, 0xb6, 0x14, 0x27, 0xbf, 0x46, 0x4e, 0x17, 0xba,\n                    0xee, 0x8d, 0xb6, 0x59, 0x40, 0xc2, 0x33, 0xb9, 0x8a, 0xfc, 0xe8, 0xd1, 0x7c,\n                    0x57, 0xbe, 0xeb, 0x78, 0x76, 0xc2, 0x15, 0x0d, 0x15, 0xaf, 0x1c, 0xb1, 0xfb,\n                    0x82, 0x4b, 0xbd, 0x14, 0x95, 0x5f, 0x2b, 0x57, 0xd0, 0x8d, 0x38, 0x8a, 0xab,\n                    0x43, 0x1a, 0x39, 0x1c, 0xfc, 0x33, 0xd5, 0xba, 0xfb, 0x5d, 0xbb, 0xaf,\n                ],\n                CompressedRistretto([\n                    0xf8, 0xf0, 0xc8, 0x7c, 0xf2, 0x37, 0x95, 0x3c, 0x58, 0x90, 0xae, 0xc3, 0x99,\n                    0x81, 0x69, 0x00, 0x5d, 0xae, 0x3e, 0xca, 0x1f, 0xbb, 0x04, 0x54, 0x8c, 0x63,\n                    0x59, 0x53, 0xc8, 0x17, 0xf9, 0x2a,\n                ]),\n            ),\n            (\n                [\n                    0x16, 0x5d, 0x69, 0x7a, 0x1e, 0xf3, 0xd5, 0xcf, 0x3c, 0x38, 0x56, 0x5b, 0xee,\n                    0xfc, 0xf8, 0x8c, 0x0f, 0x28, 0x2b, 0x8e, 0x7d, 0xbd, 0x28, 0x54, 0x4c, 0x48,\n                    0x34, 0x32, 0xf1, 0xce, 0xc7, 0x67, 0x5d, 0xeb, 0xea, 0x8e, 0xbb, 0x4e, 0x5f,\n                    0xe7, 0xd6, 0xf6, 0xe5, 0xdb, 0x15, 0xf1, 0x55, 0x87, 0xac, 0x4d, 0x4d, 0x4a,\n                    0x1d, 0xe7, 0x19, 0x1e, 0x0c, 0x1c, 0xa6, 0x66, 0x4a, 0xbc, 0xc4, 0x13,\n                ],\n                CompressedRistretto([\n                    0xae, 0x81, 0xe7, 0xde, 0xdf, 0x20, 0xa4, 0x97, 0xe1, 0x0c, 0x30, 0x4a, 0x76,\n                    0x5c, 0x17, 0x67, 0xa4, 0x2d, 0x6e, 0x06, 0x02, 0x97, 0x58, 0xd2, 0xd7, 0xe8,\n                    0xef, 0x7c, 0xc4, 0xc4, 0x11, 0x79,\n                ]),\n            ),\n            (\n                [\n                    0xa8, 0x36, 0xe6, 0xc9, 0xa9, 0xca, 0x9f, 0x1e, 0x8d, 0x48, 0x62, 0x73, 0xad,\n                    0x56, 0xa7, 0x8c, 0x70, 0xcf, 0x18, 0xf0, 0xce, 0x10, 0xab, 0xb1, 0xc7, 0x17,\n                    0x2d, 0xdd, 0x60, 0x5d, 0x7f, 0xd2, 0x97, 0x98, 0x54, 0xf4, 0x7a, 0xe1, 0xcc,\n                    0xf2, 0x04, 0xa3, 0x31, 0x02, 0x09, 0x5b, 0x42, 0x00, 0xe5, 0xbe, 0xfc, 0x04,\n                    0x65, 0xac, 0xcc, 0x26, 0x31, 0x75, 0x48, 0x5f, 0x0e, 0x17, 0xea, 0x5c,\n                ],\n                CompressedRistretto([\n                    0xe2, 0x70, 0x56, 0x52, 0xff, 0x9f, 0x5e, 0x44, 0xd3, 0xe8, 0x41, 0xbf, 0x1c,\n                    0x25, 0x1c, 0xf7, 0xdd, 0xdb, 0x77, 0xd1, 0x40, 0x87, 0x0d, 0x1a, 0xb2, 0xed,\n                    0x64, 0xf1, 0xa9, 0xce, 0x86, 0x28,\n                ]),\n            ),\n            (\n                [\n                    0x2c, 0xdc, 0x11, 0xea, 0xeb, 0x95, 0xda, 0xf0, 0x11, 0x89, 0x41, 0x7c, 0xdd,\n                    0xdb, 0xf9, 0x59, 0x52, 0x99, 0x3a, 0xa9, 0xcb, 0x9c, 0x64, 0x0e, 0xb5, 0x05,\n                    0x8d, 0x09, 0x70, 0x2c, 0x74, 0x62, 0x2c, 0x99, 0x65, 0xa6, 0x97, 0xa3, 0xb3,\n                    0x45, 0xec, 0x24, 0xee, 0x56, 0x33, 0x5b, 0x55, 0x6e, 0x67, 0x7b, 0x30, 0xe6,\n                    0xf9, 0x0a, 0xc7, 0x7d, 0x78, 0x10, 0x64, 0xf8, 0x66, 0xa3, 0xc9, 0x82,\n                ],\n                CompressedRistretto([\n                    0x80, 0xbd, 0x07, 0x26, 0x25, 0x11, 0xcd, 0xde, 0x48, 0x63, 0xf8, 0xa7, 0x43,\n                    0x4c, 0xef, 0x69, 0x67, 0x50, 0x68, 0x1c, 0xb9, 0x51, 0x0e, 0xea, 0x55, 0x70,\n                    0x88, 0xf7, 0x6d, 0x9e, 0x50, 0x65,\n                ]),\n            ),\n            (\n                [\n                    0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n        ];\n        // Check that onewaymap(input) == output for all the above vectors\n        for (input, output) in test_vectors {\n            let Q = RistrettoPoint::from_uniform_bytes(input);\n            assert_eq!(&Q.compress(), output);\n        }\n    }",
    "display_name": "one_way_map",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "signer/Signer/sign",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "sign",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.1.1 inner_spec/spec_function",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn spec_function(a: u32, b: u32) -> u32 {\n        a - b - CONST\n    }",
    "display_name": "spec_function",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core option/Option/is_none",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_none",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto_benches/compress",
    "statement_type": "function",
    "deps": [
      "bencher/Bencher/iter",
      "benchmark_group/BenchmarkGroup/bench_function",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress"
    ],
    "body": "    fn compress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"RistrettoPoint compression\", |b| {\n            let B = &constants::RISTRETTO_BASEPOINT_POINT;\n            b.iter(|| B.compress())\n        });\n    }",
    "display_name": "compress",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "0.1.1 SpecializeArg/Parse/parse",
    "statement_type": "function",
    "deps": [
      "parse/ParseBuffer/parse",
      "0.1.1 kw/conditional",
      "lookahead/Lookahead1/peek",
      "parse/ParseBuffer/lookahead1"
    ],
    "body": "    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        let lookahead = input.lookahead1();\n        if lookahead.peek(kw::conditional) {\n            input.parse::<kw::conditional>()?;\n\n            let content;\n            syn::parenthesized!(content in input);\n\n            let conditional = content.parse()?;\n            Ok(SpecializeArg::Conditional(conditional))\n        } else {\n            Ok(SpecializeArg::LitStr(input.parse()?))\n        }\n    }",
    "display_name": "parse",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_multiply_divide_lt",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_multiply_divide_lt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/reduce",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/splat",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/new"
    ],
    "body": "    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> FieldElement2625x4 {\n        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }\n\n        // We don't know that the original `FieldElement51`s were\n        // fully reduced, so the odd limbs may exceed 2^25.\n        // Reduce them to be sure.\n        FieldElement2625x4(buf).reduce()\n    }",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/reduce",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order"
    ],
    "body": "    fn reduce() {\n        let biggest = Scalar::from_bytes_mod_order([0xff; 32]);\n        assert_eq!(biggest, CANONICAL_2_256_MINUS_1);\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/pow2_le_max64",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/lemma2_to64",
      "power2/arithmetic/lemma2_to64_rest",
      "power2/arithmetic/pow2"
    ],
    "body": "pub proof fn pow2_le_max64(k: nat)\n    requires\n        k < 64,\n    ensures\n        pow2(k) <= u64::MAX\n    {\n        lemma2_to64();\n        lemma2_to64_rest();\n    }",
    "display_name": "pow2_le_max64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
    "statement_type": "function",
    "deps": [],
    "body": "        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] =  (words[3] >> 16)                     & top_mask;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }\n\n    /// Reduce a 64 byte / 512 bit scalar mod l\n    #[rustfmt::skip] // keep alignment of lo[*] and hi[*] calculations\n    #[verifier::external_body] // TODO Verify this function\n    pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n    ensures\n        limbs_bounded(&s),\n        to_nat(&s.limbs) == bytes_wide_to_nat(bytes) % group_order(),\n    {\n        assume(false); // TODO: complete the proof\n        let mut words = [0u64; 8];\n        for i in 0..8 {\n            for j in 0..8 {\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        let mut hi = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n\n        lo[0] =   words[0]                             & mask;\n        lo[1] = ((words[0] >> 52) | (words[ 1] << 12)) & mask;\n        lo[2] = ((words[1] >> 40) | (words[ 2] << 24)) & mask;\n        lo[3] = ((words[2] >> 28) | (words[ 3] << 36)) & mask;\n        lo[4] = ((words[3] >> 16) | (words[ 4] << 48)) & mask;\n        hi[0] =  (words[4] >>  4)                      & mask;\n        hi[1] = ((words[4] >> 56) | (words[ 5] <<  8)) & mask;\n        hi[2] = ((words[5] >> 44) | (words[ 6] << 20)) & mask;\n        hi[3] = ((words[6] >> 32) | (words[ 7] << 32)) & mask;\n        hi[4] =   words[7] >> 20                             ;\n\n        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar52::add(&hi, &lo)\n    }",
    "display_name": "limbs_bounded",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_52_52",
    "statement_type": "function",
    "deps": [],
    "body": "pub proof fn lemma_52_52(x: u64, y: u64)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures (x as u128) * (y as u128) < (1u128 << 104)\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert( x * y < x * (1u128 << 52)  );\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}",
    "display_name": "lemma_52_52",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/scalar_mul_vs_ed25519py",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn scalar_mul_vs_ed25519py() {\n        let aB = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n        assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n    }",
    "display_name": "scalar_mul_vs_ed25519py",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    }\n\n    /// Attempt to compute `sqrt(1/self)` in constant time.\n    ///\n    /// Convenience wrapper around `sqrt_ratio_i`.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(1/self))  ` if `self` is a nonzero square;\n    /// - `(Choice(0), zero)           ` if `self` is zero;\n    /// - `(Choice(0), +sqrt(i/self))  ` if `self` is a nonzero nonsquare;\n    ///\n    pub(crate) fn invsqrt(&self) -> (Choice, FieldElement) {\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint16_vs_mul_by_pow_2_4",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2"
    ],
    "body": "    fn basepoint16_vs_mul_by_pow_2_4() {\n        let bp16 = constants::ED25519_BASEPOINT_POINT.mul_by_pow_2(4);\n        assert_eq!(bp16.compress(), BASE16_CMPRSSD);\n    }",
    "display_name": "basepoint16_vs_mul_by_pow_2_4",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u32x8/new",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_set_epi32"
    ],
    "body": "            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n\n    /// Convenience wrapper around `new(x,x,x,x)`.\n    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "bencher/Bencher/iter_with_setup",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "iter_with_setup",
    "full_path": "file:///work/3185/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/StaticSecret/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(bytes: [u8; 32]) -> StaticSecret {\n        StaticSecret(bytes)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "                .collect::<Option<Vec<_>>>()?;\n\n            let mut Q = ExtendedPoint::identity();\n\n            for i in (0..256).rev() {\n                Q = Q.double();\n\n                for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                    match naf[i].cmp(&0) {\n                        Ordering::Greater => {\n                            Q = &Q + &lookup_table.select(naf[i] as usize);\n                        }\n                        Ordering::Less => {\n                            Q = &Q - &lookup_table.select(-naf[i] as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n            }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/main",
    "statement_type": "function",
    "deps": [],
    "body": "fn main() {}\n",
    "display_name": "main",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 affine/edwards/AffinePoint/to_edwards",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_edwards(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T: &self.x * &self.y,\n        }\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_srlv_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_srlv_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/is_empty",
    "statement_type": "function",
    "deps": [
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/is_empty"
    ],
    "body": "\n#[inline]\nfn get_selected_backend() -> BackendKind {\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    {\n        cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n        let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n        if token_avx512.get() {\n            return BackendKind::Avx512;\n        }\n    }\n\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    {\n        cpufeatures::new!(cpuid_avx2, \"avx2\");\n        let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n        if token_avx2.get() {\n            return BackendKind::Avx2;\n        }\n    }\n\n    BackendKind::Serial\n}",
    "display_name": "is_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 window/NafLookupTable5/select",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 16);\n\n        self.0[x / 2]\n    }",
    "display_name": "select",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/PublicKey/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/a_p58_vs_ap58_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/FieldElement51/pow_p58"
    ],
    "body": "    fn a_p58_vs_ap58_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ap58 = FieldElement::from_bytes(&AP58_BYTES);\n        assert_eq!(ap58, a.pow_p58());\n    }",
    "display_name": "a_p58_vs_ap58_constant",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "mul/arithmetic/lemma_mul_is_distributive_sub",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_is_distributive_sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc string/String/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_ref",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/decompress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 decompress/ristretto/step_1",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 decompress/ristretto/step_2"
    ],
    "body": "    use curve25519_dalek::ristretto::RistrettoPoint;\n\n    fn compress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"RistrettoPoint compression\", |b| {\n            let B = &constants::RISTRETTO_BASEPOINT_POINT;\n            b.iter(|| B.compress())\n        });\n    }",
    "display_name": "decompress",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/as_extended",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square"
    ],
    "body": "",
    "display_name": "as_extended",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_tables_unreduced_scalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix32/BasepointTable/create",
      "5.0.0_pre.0 edwards/EdwardsBasepointTable/BasepointTable/create",
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix256/BasepointTable/create",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix128/BasepointTable/create",
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix64/BasepointTable/create"
    ],
    "body": "    fn basepoint_tables_unreduced_scalar() {\n        let P = &constants::ED25519_BASEPOINT_POINT;\n        let a = crate::scalar::test::LARGEST_UNREDUCED_SCALAR;\n\n        let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n        let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n        let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n        let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n        let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n        let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n        let aP16 = (&table_radix16 * &a).compress();\n        let aP32 = (&table_radix32 * &a).compress();\n        let aP64 = (&table_radix64 * &a).compress();\n        let aP128 = (&table_radix128 * &a).compress();\n        let aP256 = (&table_radix256 * &a).compress();\n\n        assert_eq!(aP, aP16);\n        assert_eq!(aP16, aP32);\n        assert_eq!(aP32, aP64);\n        assert_eq!(aP64, aP128);\n        assert_eq!(aP128, aP256);\n    }",
    "display_name": "basepoint_tables_unreduced_scalar",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &'a FieldElement51) {\n        for i in 0..5 {\n            self.0[i] += _rhs.0[i];\n        }\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix64/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_pow2_square",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/lemma_pow2_unfold",
      "power/arithmetic/pow",
      "power/arithmetic/lemma_pow_adds",
      "power2/arithmetic/pow2"
    ],
    "body": "pub proof fn lemma_pow2_square(v: int, i: nat)\n    ensures\n        pow(v, pow2(i)) * pow(v, pow2(i)) == pow(v, pow2(i + 1))\n{\n    // pow(v, pow2(i)) * pow(v, pow2(i)) = pow(v, pow2(i) + pow2(i));\n    lemma_pow_adds(v as int, pow2(i), pow2(i));\n    // 2 * pow2(i) = pow2(i + 1)\n    lemma_pow2_unfold(i + 1);\n}",
    "display_name": "lemma_pow2_square",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/montgomery_radix",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion"
    ],
    "body": "    fn from(x: u8) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        s_bytes[0] = x;\n        Scalar { bytes: s_bytes }\n    }",
    "display_name": "from_montgomery",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/sqrt_ratio_i",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
      "5.0.0_pre.0 field/FieldElement51/is_negative",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_assign",
      "ConditionallyNegatable/conditional_negate",
      "5.0.0_pre.0 field/FieldElement51/ConstantTimeEq/ct_eq",
      "5.0.0_pre.0 field/FieldElement51/pow_p58"
    ],
    "body": "    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (Choice, FieldElement) {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(), we can compute  = ^((p+3)/8).\n        // Then ^2 = , so multiplying  by sqrt(-1) if necessary\n        // gives sqrt().\n        //\n        // To compute 1/sqrt(), we observe that\n        //    1/ = ^(p-1 - (p+3)/8) = ^((7p-11)/8)\n        //                            = ^3 * (^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = u/v,\n        //                                     so vr^2 = u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n        let flipped_sign_sqrt = check.ct_eq(&(-u));\n        let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        r.conditional_negate(r_is_negative);\n\n        let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n\n        (was_nonzero_square, r)\n    }",
    "display_name": "sqrt_ratio_i",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/Signer/try_sign",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/SigningKey/MultipartSigner/try_multipart_sign"
    ],
    "body": "    fn try_sign(&self, message: &[u8]) -> Result<Signature, SignatureError> {\n        self.try_multipart_sign(&[message])\n    }",
    "display_name": "try_sign",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/straus_multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/size_hint",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/by_ref"
    ],
    "body": "",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/neg_twice_is_identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg_twice_is_identity() {\n        let negative_X = -&X;\n        let should_be_X = -&negative_X;\n\n        assert_eq!(should_be_X, X);\n    }",
    "display_name": "neg_twice_is_identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 window/NafLookupTable8/From/from"
    ],
    "body": "\nuse crate::EdwardsPoint;\nuse crate::Scalar;\n\npub mod serial;\n\n#[cfg(curve25519_dalek_backend = \"simd\")]\npub mod vector;\n\n#[derive(Copy, Clone)]\nenum BackendKind {\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    Avx2,\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    Avx512,\n    Serial,\n}",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/masked_lt",
    "statement_type": "function",
    "deps": [
      "bits/low_bits_mask",
      "power2/arithmetic/pow2",
      "power2/arithmetic/lemma_pow2_pos",
      "div_mod/arithmetic/lemma_mod_bound",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2"
    ],
    "body": "pub proof fn masked_lt(v: u64, k: nat)\n    requires\n        0 <= k < 64\n    ensures\n        v & (low_bits_mask(k) as u64) < (1u64 << k)\n{\n    // v & (low_bits_mask(k) as u64) = v % pow2(k)\n    lemma_u64_low_bits_mask_is_mod(v, k);\n    // pow2(k) > 0\n    lemma_pow2_pos(k);\n    // v % pow2(k) < pow2(k)\n    lemma_mod_bound(v as int, pow2(k) as int);\n    // 1 << k = pow2(k)\n    shift_is_pow2(k);\n}",
    "display_name": "masked_lt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/LookupTable/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/From/from",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/From/from"
    ],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/variable_base.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_clamped",
      "5.0.0_pre.0 traits/BasepointTable/mul_base_clamped",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base_clamped",
      "os/OsRng/TryRngCore/try_fill_bytes",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix256/BasepointTable/create"
    ],
    "body": "    fn mul_base_clamped() {\n        let mut csprng = rand_core::OsRng;\n\n        // Make a random curve point in the curve. Give it torsion to make things interesting.\n        #[cfg(feature = \"precomputed-tables\")]\n        let random_point = {\n            let mut b = [0u8; 32];\n            csprng.try_fill_bytes(&mut b).unwrap();\n            EdwardsPoint::mul_base_clamped(b) + constants::EIGHT_TORSION[1]\n        };\n        // Make a basepoint table from the random point. We'll use this with mul_base_clamped\n        #[cfg(feature = \"precomputed-tables\")]\n        let random_table = EdwardsBasepointTableRadix256::create(&random_point);\n\n        // Now test scalar mult. agreement on the default basepoint as well as random_point\n\n        // Test that mul_base_clamped and mul_clamped agree on a large integer. Even after\n        // clamping, this integer is not reduced mod l.\n        let a_bytes = [0xff; 32];\n        assert_eq!(\n            EdwardsPoint::mul_base_clamped(a_bytes),\n            constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n        );\n        #[cfg(feature = \"precomputed-tables\")]\n        assert_eq!(\n            random_table.mul_base_clamped(a_bytes),\n            random_point.mul_clamped(a_bytes)\n        );\n\n        // Test agreement on random integers\n        for _ in 0..100 {\n            // This will be reduced mod l with probability l / 2^256  6.25%\n            let mut a_bytes = [0u8; 32];\n            csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n            assert_eq!(\n                EdwardsPoint::mul_base_clamped(a_bytes),\n                constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n            );\n            #[cfg(feature = \"precomputed-tables\")]\n            assert_eq!(\n                random_table.mul_base_clamped(a_bytes),\n                random_point.mul_clamped(a_bytes)\n            );\n        }\n    }",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/div_ceil",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "div_ceil",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "power/arithmetic/lemma_pow1",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_pow1",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "ConstantTimeEq/ct_eq"
    ],
    "body": "        use curve25519_dalek::digest::Digest;\n\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        // Hash the message\n        let msg = b\"And then I got trampled by a herd of buffalo\";\n        let mut h = MsgDigest::new();\n        h.update(msg);\n\n        let ctx_str = &b\"consequences\"[..];\n\n        // Sign and verify prehashed\n        let sig = raw_sign_prehashed::<CtxDigest, MsgDigest>(&esk, h.clone(), &vk, Some(ctx_str))\n            .unwrap();\n        raw_verify_prehashed::<CtxDigest, MsgDigest>(&vk, h, Some(ctx_str), &sig).unwrap();\n    }\n\n    #[test]\n    fn sign_byupdate() {\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        let msg = b\"realistic\";\n        // signatures are deterministic so we can compare with a good one\n        let good_sig = raw_sign::<CtxDigest>(&esk, msg, &vk);\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(msg);\n                Ok(())\n            },\n            &vk,\n        );\n        assert!(sig.unwrap() == good_sig, \"sign byupdate matches\");\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(msg);\n                Err(SignatureError::new())\n            },\n            &vk,\n        );\n        assert!(sig.is_err(), \"sign byupdate failure propagates\");\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(&msg[..1]);\n                h.update(&msg[1..]);\n                Ok(())\n            },\n            &vk,\n        );\n        assert!(sig.unwrap() == good_sig, \"sign byupdate two part\");\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "error/Error/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/ed25519-dalek/src/errors.rs",
    "relative_path": "ed25519-dalek/src/errors.rs",
    "file_name": "errors.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc string/ToString/to_string",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_string",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/random",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/IsIdentity/is_identity",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress"
    ],
    "body": "",
    "display_name": "random",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "Choice/unwrap_u8",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/splat"
    ],
    "body": "    fn conditional_select(\n        a: &FieldElement2625x4,\n        b: &FieldElement2625x4,\n        choice: Choice,\n    ) -> FieldElement2625x4 {\n        let mask = (-(choice.unwrap_u8() as i32)) as u32;\n        let mask_vec = u32x8::splat(mask);\n        FieldElement2625x4([\n            a.0[0] ^ (mask_vec & (a.0[0] ^ b.0[0])),\n            a.0[1] ^ (mask_vec & (a.0[1] ^ b.0[1])),\n            a.0[2] ^ (mask_vec & (a.0[2] ^ b.0[2])),\n            a.0[3] ^ (mask_vec & (a.0[3] ^ b.0[3])),\n            a.0[4] ^ (mask_vec & (a.0[4] ^ b.0[4])),\n        ])\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/ProjectivePoint/as_affine",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/invert",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes"
    ],
    "body": "    pub fn as_affine(&self) -> MontgomeryPoint {\n        let u = &self.U * &self.W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
    "display_name": "as_affine",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_decompression_compression",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress",
      "5.0.0_pre.0 edwards/EdwardsPoint/ValidityCheck/is_valid",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_decompression_compression() {\n        let base_X = FieldElement::from_bytes(&BASE_X_COORD_BYTES);\n        let bp = constants::ED25519_BASEPOINT_COMPRESSED\n            .decompress()\n            .unwrap();\n        assert!(bp.is_valid());\n        // Check that decompression actually gives the correct X coordinate\n        assert_eq!(base_X, bp.X);\n        assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n    }",
    "display_name": "basepoint_decompression_compression",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_mod_twice",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mod_twice",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/repack_pair",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_blend_epi32",
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_shuffle_epi32",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "fn repack_pair(x: u32x8, y: u32x8) -> u32x8 {\n    unsafe {\n        use core::arch::x86_64::_mm256_blend_epi32;\n        use core::arch::x86_64::_mm256_shuffle_epi32;\n\n        // Input: x = (a0, 0, b0, 0, c0, 0, d0, 0)\n        // Input: y = (a1, 0, b1, 0, c1, 0, d1, 0)\n\n        let x_shuffled = _mm256_shuffle_epi32(x.into(), 0b11_01_10_00);\n        let y_shuffled = _mm256_shuffle_epi32(y.into(), 0b10_00_11_01);\n\n        // x' = (a0, b0,  0,  0, c0, d0,  0,  0)\n        // y' = ( 0,  0, a1, b1,  0,  0, c1, d1)\n\n        _mm256_blend_epi32(x_shuffled, y_shuffled, 0b11001100).into()\n    }\n}",
    "display_name": "repack_pair",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/sqrt_ratio_behavior",
    "statement_type": "function",
    "deps": [
      "From/from",
      "5.0.0_pre.0 field/FieldElement51/sqrt_ratio_i",
      "5.0.0_pre.0 field/FieldElement51/is_negative",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square"
    ],
    "body": "    fn sqrt_ratio_behavior() {\n        let zero = FieldElement::ZERO;\n        let one = FieldElement::ONE;\n        let i = constants::SQRT_M1;\n        let two = &one + &one; // 2 is nonsquare mod p.\n        let four = &two + &two; // 4 is square mod p.\n\n        // 0/0 should return (1, 0) since u is 0\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&zero, &zero);\n        assert!(bool::from(choice));\n        assert_eq!(sqrt, zero);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 1/0 should return (0, 0) since v is 0, u is nonzero\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&one, &zero);\n        assert!(bool::from(!choice));\n        assert_eq!(sqrt, zero);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 2/1 is nonsquare, so we expect (0, sqrt(i*2))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&two, &one);\n        assert!(bool::from(!choice));\n        assert_eq!(sqrt.square(), &two * &i);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 4/1 is square, so we expect (1, sqrt(4))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&four, &one);\n        assert!(bool::from(choice));\n        assert_eq!(sqrt.square(), four);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 1/4 is square, so we expect (1, 1/sqrt(4))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&one, &four);\n        assert!(bool::from(choice));\n        assert_eq!(&sqrt.square() * &four, one);\n        assert!(bool::from(!sqrt.is_negative()));\n    }",
    "display_name": "sqrt_ratio_behavior",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_square_internal_no_overflow",
    "statement_type": "function",
    "deps": [],
    "body": "pub proof fn lemma_square_internal_no_overflow()\n    ensures\n         (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n         (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n         (1u128 << 104) * 2 == (1u128 << 105),\n         (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}",
    "display_name": "lemma_square_internal_no_overflow",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_srli_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_srli_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/is_negative",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    pub(crate) fn is_negative(&self) -> Choice {\n        let bytes = self.to_bytes();\n        (bytes[0] & 1).into()\n    }",
    "display_name": "is_negative",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "power/arithmetic/lemma_pow_adds",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_pow_adds",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/to_affine_niels_clears_denominators",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_affine_niels"
    ],
    "body": "    fn to_affine_niels_clears_denominators() {\n        // construct a point as aB so it has denominators (ie. Z != 1)\n        let aB = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n        let aB_affine_niels = aB.as_affine_niels();\n        let also_aB = (&EdwardsPoint::identity() + &aB_affine_niels).as_extended();\n        assert_eq!(aB.compress(), also_aB.compress());\n    }",
    "display_name": "to_affine_niels_clears_denominators",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "digest/Digest/digest",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "digest",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(<[u8; 32]>::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/compress_batch",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "5.0.0_pre.0 affine/edwards/AffinePoint/compress",
      "5.0.0_pre.0 field/FieldElement51/batch_invert",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect"
    ],
    "body": "",
    "display_name": "compress_batch",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/shl_zero_is_id",
    "statement_type": "function",
    "deps": [],
    "body": "pub broadcast proof fn shl_zero_is_id(v: u64)\n    ensures\n        #![trigger v << 0]\n        v << 0 == v\n{\n    assert(v << 0 == v) by (bit_vector);\n}",
    "display_name": "shl_zero_is_id",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
    "statement_type": "function",
    "deps": [],
    "body": "}\n\n// ------------------------------------------------------------------------\n// Serde support\n// ------------------------------------------------------------------------\n// Serializes to and from `RistrettoPoint` directly, doing compression\n// and decompression internally.  This means that users can create\n// structs containing `RistrettoPoint`s and use Serde's derived\n// serializers to serialize those structures.\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n",
    "display_name": "as_extended",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_rr_limbs_bounded",
    "statement_type": "function",
    "deps": [],
    "body": "pub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}",
    "display_name": "lemma_rr_limbs_bounded",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 traits/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> Self;\n}\n\n/// Trait for testing if a curve point is equivalent to the identity point.\npub trait IsIdentity {\n    /// Return true if this element is the identity element of the curve.\n    fn is_identity(&self) -> bool;\n}",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core result/Result/is_err",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_err",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_base",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery"
    ],
    "body": "    fn consttime_multiscalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Constant-time variable-base multiscalar multiplication\",\n                    *multiscalar_size,\n                ),\n                &multiscalar_size,\n                |b, &&size| {\n                    let points = construct_points(size);\n                    // This is supposed to be constant-time, but we might as well\n                    // rerandomize the scalars for every call just in case.\n                    b.iter_batched(\n                        || construct_scalars(size),\n                        |scalars| EdwardsPoint::multiscalar_mul(&scalars, &points),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }",
    "display_name": "mul_base",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_unpackhi_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_unpackhi_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "digest/Digest/finalize",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "finalize",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "Criterion/benchmark_group",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "benchmark_group",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery_benches/consttime_fixed_base_scalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "benchmark_group/BenchmarkGroup/bench_function",
      "5.0.0_pre.0 scalar/Scalar/invert",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_base",
      "bencher/Bencher/iter"
    ],
    "body": "    fn consttime_fixed_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time fixed-base scalar mul\", move |b| {\n            b.iter(|| MontgomeryPoint::mul_base(&s))\n        });\n    }",
    "display_name": "consttime_fixed_base_scalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/reverse",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "reverse",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_permutevar8x32_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_permutevar8x32_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/rand_prime_order_point",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/random",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base"
    ],
    "body": "    fn rand_prime_order_point<R: CryptoRng + ?Sized>(rng: &mut R) -> EdwardsPoint {\n        let s: Scalar = Scalar::random(rng);\n        EdwardsPoint::mul_base(&s)\n    }",
    "display_name": "rand_prime_order_point",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 bench_diffie_hellman",
    "statement_type": "function",
    "deps": [
      "TryRngCore/unwrap_err",
      "3.0.0_pre.0 x25519/PublicKey/From/from",
      "3.0.0_pre.0 x25519/EphemeralSecret/random_from_rng",
      "Criterion/bench_function",
      "bencher/Bencher/iter_with_setup",
      "3.0.0_pre.0 x25519/EphemeralSecret/diffie_hellman"
    ],
    "body": "fn bench_diffie_hellman(c: &mut Criterion) {\n    let bob_secret = EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err());\n    let bob_public = PublicKey::from(&bob_secret);\n\n    c.bench_function(\"diffie_hellman\", move |b| {\n        b.iter_with_setup(\n            || EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err()),\n            |alice_secret| alice_secret.diffie_hellman(&bob_public),\n        )\n    });\n}",
    "display_name": "bench_diffie_hellman",
    "full_path": "file:///work/3185/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core convert/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "        println!(\"{:?}\", demo_toml_rebuild);\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core mem/replace",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "replace",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress",
      "core https:/github.com/rust_lang/rust/library/core option/Option/ok_or"
    ],
    "body": "                !success,\n                \"verify_strict() expected failure in testcase #{number}\",\n            );",
    "display_name": "from_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/a_square_vs_a_squared_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square"
    ],
    "body": "    fn a_square_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(asq, a.square());\n    }",
    "display_name": "a_square_vs_a_squared_constant",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/NafLookupTable5/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/From/from",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/double",
      "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/From/from",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/negate_lazy",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn negate_lazy(&self) -> FieldElement2625x4 {\n        // The limbs of self are bounded with b < 0.999, while the\n        // smallest limb of 2*p is 67108845 > 2^{26+0.9999}, so\n        // underflows are not possible.\n        FieldElement2625x4([\n            P_TIMES_2_LO - self.0[0],\n            P_TIMES_2_HI - self.0[1],\n            P_TIMES_2_HI - self.0[2],\n            P_TIMES_2_HI - self.0[3],\n            P_TIMES_2_HI - self.0[4],\n        ])\n    }",
    "display_name": "negate_lazy",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core empty/sources/iter/empty",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "generics/Generics/split_for_impl",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "split_for_impl",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 decompress/edwards/step_2",
    "statement_type": "function",
    "deps": [
      "Choice/From/from",
      "ConditionallyNegatable/conditional_negate",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes"
    ],
    "body": "    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> EdwardsPoint {\n         // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n         // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n        X.conditional_negate(compressed_sign_bit);\n\n        EdwardsPoint {\n            X,\n            Y,\n            Z,\n            T: &X * &Y,\n        }\n    }",
    "display_name": "step_2",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/multiscalar_consistency_n_100",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 test/edwards/multiscalar_consistency_iter"
    ],
    "body": "    fn multiscalar_consistency_n_100() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(100);\n        }\n    }",
    "display_name": "multiscalar_consistency_n_100",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/fold",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "fold",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/batch_invert_consistency",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "5.0.0_pre.0 scalar/Scalar/invert",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Clone/clone",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 scalar/Scalar/batch_invert",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/product",
      "5.0.0_pre.0 scalar/Scalar/From/from"
    ],
    "body": "    fn batch_invert_consistency() {\n        let mut x = Scalar::from(1u64);\n        let mut v1: Vec<_> = (0..16)\n            .map(|_| {\n                let tmp = x;\n                x = x + x;\n                tmp\n            })\n            .collect();\n        let v2 = v1.clone();\n\n        let expected: Scalar = v1.iter().product();\n        let expected = expected.invert();\n        let ret = Scalar::batch_invert(&mut v1);\n        assert_eq!(ret, expected);\n\n        for (a, b) in v1.iter().zip(v2.iter()) {\n            assert_eq!(a * b, Scalar::ONE);\n        }\n    }",
    "display_name": "batch_invert_consistency",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/sign",
    "statement_type": "function",
    "deps": [
      "Criterion/bench_function",
      "3.0.0_pre.0 signing/SigningKey/generate",
      "bencher/Bencher/iter",
      "signer/Signer/sign",
      "thread/rngs/rng"
    ],
    "body": "    fn sign(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n\n        c.bench_function(\"Ed25519 signing\", move |b| b.iter(|| keypair.sign(msg)));\n    }",
    "display_name": "sign",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/size_hint",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "size_hint",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "token/Paren/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Identity/identity"
    ],
    "body": "    fn default() -> ExtendedPoint {\n        ExtendedPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/is_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/VartimePrecomputedStraus/is_empty"
    ],
    "body": "    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }",
    "display_name": "is_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "punctuated/Punctuated/iter",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "iter",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectivePoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/is_zero",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "ConstantTimeEq/ct_eq"
    ],
    "body": "    pub(crate) fn is_zero(&self) -> Choice {\n        let zero = [0u8; 32];\n        let bytes = self.to_bytes();\n\n        bytes.ct_eq(&zero)\n    }",
    "display_name": "is_zero",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.0.conditional_assign(&other.0, choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/as_slice",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_slice",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat_32_u8",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "pub open spec fn as_nat_32_u8(limbs: [u8; 32]) -> nat {\n    // Verus error: `core::iter::range::impl&%15::fold` is not supported\n    // we write them out manually\n    (limbs[0] as nat) +\n    pow2( 1 * 8) * (limbs[ 1] as nat) +\n    pow2( 2 * 8) * (limbs[ 2] as nat) +\n    pow2( 3 * 8) * (limbs[ 3] as nat) +\n    pow2( 4 * 8) * (limbs[ 4] as nat) +\n    pow2( 5 * 8) * (limbs[ 5] as nat) +\n    pow2( 6 * 8) * (limbs[ 6] as nat) +\n    pow2( 7 * 8) * (limbs[ 7] as nat) +\n    pow2( 8 * 8) * (limbs[ 8] as nat) +\n    pow2( 9 * 8) * (limbs[ 9] as nat) +\n    pow2(10 * 8) * (limbs[10] as nat) +\n    pow2(11 * 8) * (limbs[11] as nat) +\n    pow2(12 * 8) * (limbs[12] as nat) +\n    pow2(13 * 8) * (limbs[13] as nat) +\n    pow2(14 * 8) * (limbs[14] as nat) +\n    pow2(15 * 8) * (limbs[15] as nat) +\n    pow2(16 * 8) * (limbs[16] as nat) +\n    pow2(17 * 8) * (limbs[17] as nat) +\n    pow2(18 * 8) * (limbs[18] as nat) +\n    pow2(19 * 8) * (limbs[19] as nat) +\n    pow2(20 * 8) * (limbs[20] as nat) +\n    pow2(21 * 8) * (limbs[21] as nat) +\n    pow2(22 * 8) * (limbs[22] as nat) +\n    pow2(23 * 8) * (limbs[23] as nat) +\n    pow2(24 * 8) * (limbs[24] as nat) +\n    pow2(25 * 8) * (limbs[25] as nat) +\n    pow2(26 * 8) * (limbs[26] as nat) +\n    pow2(27 * 8) * (limbs[27] as nat) +\n    pow2(28 * 8) * (limbs[28] as nat) +\n    pow2(29 * 8) * (limbs[29] as nat) +\n    pow2(30 * 8) * (limbs[30] as nat) +\n    pow2(31 * 8) * (limbs[31] as nat)\n}",
    "display_name": "as_nat_32_u8",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/constants/test_sqrt_a_minus_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square"
    ],
    "body": "    fn test_sqrt_a_minus_2() {\n        let one = FieldElement::ONE;\n        let a_minus_two = &(&constants::MONTGOMERY_A_NEG - &one) - &one;\n\n        assert_eq!(constants::ED25519_SQRTAM2.square(), a_minus_two)\n    }",
    "display_name": "test_sqrt_a_minus_2",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/from_le_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_le_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_shr_51_le",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/lemma2_to64_rest",
      "div_mod/arithmetic/lemma_div_is_ordered",
      "power2/arithmetic/lemma_pow2_pos"
    ],
    "body": "pub proof fn lemma_shr_51_le(a: u128, b: u128)\n    requires\n        a <= b\n    ensures\n        (a >> 51) <= (b >> 51)\n{\n    lemma_pow2_pos(51);\n    lemma2_to64_rest(); // pow2(51) value\n    lemma_u128_shr_is_div(a, 51);\n    lemma_u128_shr_is_div(b, 51);\n    lemma_div_is_ordered(a as int, b as int, 51);\n}",
    "display_name": "lemma_shr_51_le",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/vartime_precomputed_vs_nonprecomputed_multiscalar",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/chain",
      "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/len",
      "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/is_empty",
      "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "thread/rngs/rng",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "5.0.0_pre.0 ristretto/RistrettoPoint/mul_base",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 scalar/Scalar/random"
    ],
    "body": "    fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let static_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let check_scalar: Scalar = static_scalars\n            .iter()\n            .chain(dynamic_scalars.iter())\n            .map(|s| s * s)\n            .sum();\n\n        let static_points = static_scalars\n            .iter()\n            .map(RistrettoPoint::mul_base)\n            .collect::<Vec<_>>();\n        let dynamic_points = dynamic_scalars\n            .iter()\n            .map(RistrettoPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n\n        assert_eq!(precomputation.len(), 128);\n        assert!(!precomputation.is_empty());\n\n        let P = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        use crate::traits::VartimeMultiscalarMul;\n        let Q = RistrettoPoint::vartime_multiscalar_mul(\n            static_scalars.iter().chain(dynamic_scalars.iter()),\n            static_points.iter().chain(dynamic_points.iter()),\n        );\n\n        let R = RistrettoPoint::mul_base(&check_scalar);\n\n        assert_eq!(P.compress(), R.compress());\n        assert_eq!(Q.compress(), R.compress());\n    }",
    "display_name": "vartime_precomputed_vs_nonprecomputed_multiscalar",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 StructWithGenerics/member_function",
    "statement_type": "function",
    "deps": [],
    "body": "    fn member_function(&self, b: T) -> T::Output {\n        self.a - b\n    }",
    "display_name": "member_function",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "power2/arithmetic/lemma_pow2_strictly_increases",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_pow2_strictly_increases",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "power/arithmetic/lemma0_pow",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma0_pow",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/ExpandedSecretKey/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "ConstantTimeEq/ct_eq",
      "5.0.0_pre.0 scalar/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.scalar.ct_eq(&other.scalar) & self.hash_prefix.ct_eq(&other.hash_prefix)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 spec/straus/scalar_mul/vector/backend/Straus/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Identity/identity",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/double",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 edwards/avx2/vector/backend/NafLookupTable5/From/from",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev"
    ],
    "body": "        fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let nafs: Vec<_> = scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect();\n            let lookup_tables: Vec<_> = points\n                .into_iter()\n                .map(|P_opt| P_opt.map(|P| NafLookupTable5::<CachedPoint>::from(&P)))\n                .collect::<Option<Vec<_>>>()?;\n\n            let mut Q = ExtendedPoint::identity();\n\n            for i in (0..256).rev() {\n                Q = Q.double();\n\n                for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                    match naf[i].cmp(&0) {\n                        Ordering::Greater => {\n                            Q = &Q + &lookup_table.select(naf[i] as usize);\n                        }\n                        Ordering::Less => {\n                            Q = &Q - &lookup_table.select(-naf[i] as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n            }\n\n            Some(Q.into())\n        }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/is_identity",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 traits/IsIdentity/is_identity"
    ],
    "body": "    fn is_identity() {\n        assert!(EdwardsPoint::identity().is_identity());\n        assert!(!constants::ED25519_BASEPOINT_POINT.is_identity());\n    }",
    "display_name": "is_identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/SharedSecret/Drop/drop",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "zip",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Extend/extend",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "extend",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/ExpandedSecretKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order",
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    pub fn from_bytes(bytes: &[u8; 64]) -> Self {\n        // TODO: Use bytes.split_array_ref once its in MSRV.\n        let mut scalar_bytes: [u8; 32] = [0u8; 32];\n        let mut hash_prefix: [u8; 32] = [0u8; 32];\n        scalar_bytes.copy_from_slice(&bytes[00..32]);\n        hash_prefix.copy_from_slice(&bytes[32..64]);\n\n        // For signing, we'll need the integer, clamped, and converted to a Scalar. See\n        // PureEdDSA.keygen in RFC 8032 Appendix A.\n        let scalar = Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes));\n\n        ExpandedSecretKey {\n            scalar,\n            hash_prefix,\n        }\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/Hash/hash",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/as_bytes",
      "core https:/github.com/rust_lang/rust/library/core array/Hash/hash"
    ],
    "body": "    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.as_bytes().hash(state);\n    }",
    "display_name": "hash",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/LookupTable/select",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "select",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.y_minus_x;\n        let MP = &Y_minus_X * &other.y_plus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &Z2 - &Txy2d,\n            T: &Z2 + &Txy2d,\n        }\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_swap",
    "statement_type": "function",
    "deps": [
      "ConditionallySelectable/conditional_swap"
    ],
    "body": "    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }",
    "display_name": "conditional_swap",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/VartimePrecomputedStraus/optional_mixed_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/optional_mixe"
    ],
    "body": "//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "parse/ParseBuffer/lookahead1",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lookahead1",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/straus_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 straus/scalar_mul/serial/backend/Straus/MultiscalarMul/multiscalar_mul"
    ],
    "body": "pub fn straus_multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator,\n    J::Item: core::borrow::Borrow<EdwardsPoint>,\n{\n    use crate::traits::MultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => {\n            vector::scalar_mul::straus::spec_avx2::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
    "display_name": "straus_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/ValidityCheck/is_valid",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/ValidityCheck/is_valid",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective"
    ],
    "body": "",
    "display_name": "is_valid",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/unpack_pair",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/splat",
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_unpackhi_epi32",
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_unpacklo_epi32",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "fn unpack_pair(src: u32x8) -> (u32x8, u32x8) {\n    let a: u32x8;\n    let b: u32x8;\n    let zero = u32x8::splat(0);\n    unsafe {\n        use core::arch::x86_64::_mm256_unpackhi_epi32;\n        use core::arch::x86_64::_mm256_unpacklo_epi32;\n        a = _mm256_unpacklo_epi32(src.into(), zero.into()).into();\n        b = _mm256_unpackhi_epi32(src.into(), zero.into()).into();\n    }\n    (a, b)\n}",
    "display_name": "unpack_pair",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/reduce",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul_internal",
      "5.0.0_pre.0 scalar/Scalar52/pack",
      "5.0.0_pre.0 scalar/Scalar/unpack"
    ],
    "body": "    fn reduce(&self) -> Scalar {\n        let x = self.unpack();\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        x_mod_l.pack()\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 inner/inner_function",
    "statement_type": "function",
    "deps": [],
    "body": "    fn inner_function(a: u32, b: u32) -> u32 {\n        a - b\n    }",
    "display_name": "inner_function",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/generate",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core array/Default/default",
      "3.0.0_pre.0 signing/SigningKey/from_bytes"
    ],
    "body": "",
    "display_name": "generate",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "error/Error/into_compile_error",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "into_compile_error",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectiveNielsPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/ProjectiveNielsPoint/Identity/identity"
    ],
    "body": "    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectiveNielsPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectiveNielsPoint{{\\n\\tY_plus_X: {:?},\\n\\tY_minus_X: {:?},\\n\\tZ: {:?},\\n\\tT2d: {:?}\\n}}\",\n            &self.Y_plus_X, &self.Y_minus_X, &self.Z, &self.T2d\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_projective_extended_round_trip",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/as_extended",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective"
    ],
    "body": "    fn basepoint_projective_extended_round_trip() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT\n                .as_projective()\n                .as_extended()\n                .compress(),\n            constants::ED25519_BASEPOINT_COMPRESSED\n        );\n    }",
    "display_name": "basepoint_projective_extended_round_trip",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "\n#[cfg(feature = \"os_rng\")]\nmod os_rng {\n\n    use super::*;\n\n    #[test]\n    fn ephemeral_random() {\n        EphemeralSecret::random();\n    }\n\n    #[test]\n    #[cfg(feature = \"reusable_secrets\")]\n    fn reusable_random() {\n        ReusableSecret::random();\n    }\n\n    #[test]\n    #[cfg(feature = \"static_secrets\")]\n    fn static_random() {\n        StaticSecret::random();\n    }\n}",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/slice128_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux"
    ],
    "body": "pub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\nensures\n    nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs)\n{\n\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            ((limbs[4] as nat) +\n            ((limbs[5] as nat) +\n                ((limbs[6] as nat) +\n                ((limbs[7] as nat) +\n                (limbs[8] as nat) * pow2(52)\n                ) * pow2(52)\n                ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        lemma_pow2_adds(208, 52);\n        lemma_pow2_adds(260, 52);\n        lemma_pow2_adds(312, 52);\n        lemma_pow2_adds(364, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}",
    "display_name": "lemma_nine_limbs_equals_slice128_to_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "impls/de/String/Deserialize/deserialize",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "deserialize",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/slice128_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux",
      "power2/arithmetic/lemma_pow2_adds",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux",
      "mul/arithmetic/lemma_mul_is_associative",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat"
    ],
    "body": "pub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}",
    "display_name": "lemma_mul_internal_correct",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/pow255_gt_19",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2",
      "power2/arithmetic/lemma2_to64",
      "power2/arithmetic/lemma_pow2_strictly_increases"
    ],
    "body": "pub proof fn pow255_gt_19()\n    ensures\n        pow2(255) > 19\n{\n    lemma2_to64(); // 2^5\n    lemma_pow2_strictly_increases(5, 255);\n}",
    "display_name": "pow255_gt_19",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/ExpandedSecretKey/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/ExpandedSecretKey/from_bytes",
      "digest/Digest/finalize",
      "0.11.0_rc.0 Sha512/Default/default",
      "Array/AsRef/as_ref",
      "digest/Digest/chain_update"
    ],
    "body": "    fn from(secret_key: &SecretKey) -> ExpandedSecretKey {\n        let hash = Sha512::default().chain_update(secret_key).finalize();\n        ExpandedSecretKey::from_bytes(hash.as_ref())\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core fmt/Formatter/debug_struct",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "debug_struct",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/consttime_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "benchmark_group/BenchmarkGroup/bench_with_input",
      "bencher/Bencher/iter_batched",
      "5.0.0_pre.0 multiscalar_benches/construct_scalars",
      "5.0.0_pre.0 edwards/EdwardsPoint/MultiscalarMul/multiscalar_mul",
      "benchmark_group/BenchmarkId/new",
      "5.0.0_pre.0 multiscalar_benches/construct_points"
    ],
    "body": "    fn consttime_multiscalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Constant-time variable-base multiscalar multiplication\",\n                    *multiscalar_size,\n                ),\n                &multiscalar_size,\n                |b, &&size| {\n                    let points = construct_points(size);\n                    // This is supposed to be constant-time, but we might as well\n                    // rerandomize the scalars for every call just in case.\n                    b.iter_batched(\n                        || construct_scalars(size),\n                        |scalars| EdwardsPoint::multiscalar_mul(&scalars, &points),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }",
    "display_name": "consttime_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/as_affine_niels",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/invert"
    ],
    "body": "",
    "display_name": "as_affine_niels",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core exact_size/traits/iter/ExactSizeIterator/is_empty",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/Identity/identity"
    ],
    "body": "    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "os/OsRng/TryRngCore/try_fill_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "try_fill_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/sub"
    ],
    "body": "    fn sub() {\n        let res = Scalar52::sub(&A, &B);\n        for i in 0..5 {\n            assert!(res[i] == AB[i]);\n        }\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoBasepointTable/basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsBasepointTable/BasepointTable/basepoint"
    ],
    "body": "    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }",
    "display_name": "basepoint",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/to_scalar_bytes",
    "statement_type": "function",
    "deps": [
      "0.11.0_rc.0 Sha512/Default/default",
      "digest/Digest/finalize",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "digest/Digest/chain_update"
    ],
    "body": "",
    "display_name": "to_scalar_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/conditional_negate",
    "statement_type": "function",
    "deps": [
      "Choice/From/from",
      "ConditionallyNegatable/conditional_negate"
    ],
    "body": "    fn conditional_negate() {\n        let one = FieldElement::ONE;\n        let minus_one = FieldElement::MINUS_ONE;\n        let mut x = one;\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(0));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, one);\n    }",
    "display_name": "conditional_negate",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/hash_to_field",
    "statement_type": "function",
    "deps": [
      "digest/Digest/chain_update",
      "core https:/github.com/rust_lang/rust/library/core ptr_try_from_impls/num/convert/TryFrom/try_from",
      "digest/Digest/finalize",
      "Array/Default/default",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "core https:/github.com/rust_lang/rust/library/core slice/reverse",
      "Array/as_slice",
      "core https:/github.com/rust_lang/rust/library/core num/to_be_bytes",
      "digest/Digest/new",
      "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
      "5.0.0_pre.0 field/FieldElement51/from_bytes_wide"
    ],
    "body": "    pub fn hash_to_field<D>(bytes: &[&[u8]], domain_sep: &[&[u8]]) -> Self\n    where\n        D: BlockSizeUser + Default + FixedOutput<OutputSize = U64> + HashMarker,\n        D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    {\n        let l_i_b_str = 48u16.to_be_bytes();\n        let z_pad = Array::<u8, D::BlockSize>::default();\n\n        let mut hasher = D::new().chain_update(z_pad);\n\n        for slice in bytes {\n            hasher = hasher.chain_update(slice);\n        }\n\n        hasher = hasher.chain_update(l_i_b_str).chain_update([0u8]);\n\n        let mut domain_sep_len = 0usize;\n        for slice in domain_sep {\n            hasher = hasher.chain_update(slice);\n            domain_sep_len += slice.len();\n        }\n\n        let domain_sep_len = u8::try_from(domain_sep_len)\n            .expect(\"Unexpected overflow from domain separator's size.\");\n        assert_ne!(\n            domain_sep_len, 0,\n            \"Domain separator MUST have nonzero length.\"\n        );\n\n        let b_0 = hasher.chain_update([domain_sep_len]).finalize();\n\n        let mut hasher = D::new().chain_update(b_0.as_slice()).chain_update([1u8]);\n\n        for slice in domain_sep {\n            hasher = hasher.chain_update(slice)\n        }\n\n        let b_1 = hasher.chain_update([domain_sep_len]).finalize();\n\n        // 5.2, we only generate count * m * L = 1 * 1 * (256 + 128)/8 = 48 bytes\n        let mut bytes_wide = [0u8; 64];\n        bytes_wide[..48].copy_from_slice(&b_1.as_slice()[..48]);\n        bytes_wide[..48].reverse();\n\n        FieldElement::from_bytes_wide(&bytes_wide)\n    }",
    "display_name": "hash_to_field",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 BatchCompressState/efgh",
    "statement_type": "function",
    "deps": [],
    "body": "            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }",
    "display_name": "efgh",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/test_pippenger_radix_iter",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "5.0.0_pre.0 scalar/Scalar/reduce",
      "5.0.0_pre.0 scalar/Scalar/to_radix_2w_size_hint",
      "5.0.0_pre.0 scalar/Scalar/as_radix_2w"
    ],
    "body": "    fn test_pippenger_radix_iter(scalar: Scalar, w: usize) {\n        let digits_count = Scalar::to_radix_2w_size_hint(w);\n        let digits = scalar.as_radix_2w(w);\n\n        let radix = Scalar::from((1 << w) as u64);\n        let mut term = Scalar::ONE;\n        let mut recovered_scalar = Scalar::ZERO;\n        for digit in &digits[0..digits_count] {\n            let digit = *digit;\n            if digit != 0 {\n                let sdigit = if digit < 0 {\n                    -Scalar::from((-(digit as i64)) as u64)\n                } else {\n                    Scalar::from(digit as u64)\n                };\n                recovered_scalar += term * sdigit;\n            }\n            term *= radix;\n        }\n        // When the input is unreduced, we may only recover the scalar mod l.\n        assert_eq!(recovered_scalar, scalar.reduce());\n    }",
    "display_name": "test_pippenger_radix_iter",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/compress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 affine/edwards/AffinePoint/compress",
      "5.0.0_pre.0 edwards/EdwardsPoint/to_affine"
    ],
    "body": "        // derived from `serialize_deserialize_verifying_key_json` test\n        // trailing zero elements makes key too long (34 bytes)\n        let encoded_verifying_key_too_long = \"[130,39,155,15,62,76,188,63,124,122,26,251,233,253,225,220,14,41,166,120,108,35,254,77,160,83,172,58,219,42,86,120,0,0]\";\n        let de_err = serde_json::from_str::<VerifyingKey>(encoded_verifying_key_too_long)\n            .unwrap_err()\n            .to_string();\n        assert!(\n            de_err.contains(\"invalid length 34\"),\n            \"expected invalid length error, got: {de_err}\",\n        );",
    "display_name": "compress",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/multiscalar_consistency_iter",
    "statement_type": "function",
    "deps": [
      "thread/rngs/rng",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "5.0.0_pre.0 scalar/Scalar/random",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 edwards/EdwardsPoint/MultiscalarMul/multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum"
    ],
    "body": "    fn multiscalar_consistency_iter(n: usize) {\n        let mut rng = rand::rng();\n\n        // Construct random coefficients x0, ..., x_{n-1},\n        // followed by some extra hardcoded ones.\n        let xs = (0..n).map(|_| Scalar::random(&mut rng)).collect::<Vec<_>>();\n        let check = xs.iter().map(|xi| xi * xi).sum::<Scalar>();\n\n        // Construct points G_i = x_i * B\n        let Gs = xs.iter().map(EdwardsPoint::mul_base).collect::<Vec<_>>();\n\n        // Compute H1 = <xs, Gs> (consttime)\n        let H1 = EdwardsPoint::multiscalar_mul(&xs, &Gs);\n        // Compute H2 = <xs, Gs> (vartime)\n        let H2 = EdwardsPoint::vartime_multiscalar_mul(&xs, &Gs);\n        // Compute H3 = <xs, Gs> = sum(xi^2) * B\n        let H3 = EdwardsPoint::mul_base(&check);\n\n        assert_eq!(H1, H3);\n        assert_eq!(H2, H3);\n    }",
    "display_name": "multiscalar_consistency_iter",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) * _rhs;\n        self.0 = result.0;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/ExpandedSecretKey/Drop/drop",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/Zeroize/zeroize",
      "Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        self.scalar.zeroize();\n        self.hash_prefix.zeroize()\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/multiscalar_consistency_n_250",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 test/edwards/multiscalar_consistency_iter"
    ],
    "body": "    fn multiscalar_consistency_n_250() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(250);\n        }\n    }",
    "display_name": "multiscalar_consistency_n_250",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "std https:/github.com/rust_lang/rust/library/std env/var",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "var",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/consttime_fixed_base_scalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/invert",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "benchmark_group/BenchmarkGroup/bench_function",
      "bencher/Bencher/iter"
    ],
    "body": "    fn consttime_fixed_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time fixed-base scalar mul\", move |b| {\n            b.iter(|| EdwardsPoint::mul_base(&s))\n        });\n    }",
    "display_name": "consttime_fixed_base_scalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/ConstantTimeEq/ct_eq",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/ProjectivePoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/ProjectivePoint/Identity/identity"
    ],
    "body": "    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 subtle_assumes/u64/serial/backend/boolify",
    "statement_type": "function",
    "deps": [],
    "body": "pub uninterp spec fn boolify(c: Choice) -> bool;\n\npub assume_specification [Choice::from](u: u8) -> (c: Choice)\n    ensures u == 0 ==> boolify(c) == false,\n            u == 1 ==> boolify(c) == true;\n\n#[verifier::external_body]\npub fn select(x: &u64, y: &u64, c: Choice) -> (res: u64)\n    ensures boolify(c) ==> res == x,\n            ! boolify(c) ==> res == y\n{\n    u64::conditional_select(x, y, c)\n}",
    "display_name": "boolify",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
    "file_name": "subtle_assumes.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc slice/to_vec",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_vec",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/a_mul_a_vs_a_squared_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes"
    ],
    "body": "    fn a_mul_a_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(asq, &a * &a);\n    }",
    "display_name": "a_mul_a_vs_a_squared_constant",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/cmp",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "cmp",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity"
    ],
    "body": "    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/unpack",
      "5.0.0_pre.0 scalar/Scalar52/invert",
      "5.0.0_pre.0 scalar/Scalar52/pack"
    ],
    "body": "",
    "display_name": "invert",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar52/pack",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/to_bytes"
    ],
    "body": "    fn pack(&self) -> Scalar {\n        Scalar {\n            bytes: self.to_bytes(),\n        }\n    }",
    "display_name": "pack",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/to_le_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_le_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul_internal",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/square_internal"
    ],
    "body": "                    \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                    basepoint order \",\n                )\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Option::from(Scalar::from_canonical_bytes(bytes))\n                    .ok_or_else(|| serde::de::Error::custom(\"scalar was not canonically encoded\"))\n            }",
    "display_name": "square",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 square_multiply",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_square",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_mul"
    ],
    "body": "        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }",
    "display_name": "square_multiply",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/vartime_double_base_scalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "benchmark_group/BenchmarkGroup/bench_function",
      "bencher/Bencher/iter_batched",
      "thread/rngs/rng",
      "5.0.0_pre.0 scalar/Scalar/random",
      "5.0.0_pre.0 edwards/EdwardsPoint/vartime_double_scalar_mul_basepoint"
    ],
    "body": "    fn vartime_double_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"Variable-time aA+bB, A variable, B fixed\", |bench| {\n            let mut rng = rng();\n            let A = EdwardsPoint::mul_base(&Scalar::random(&mut rng));\n            bench.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| EdwardsPoint::vartime_double_scalar_mul_basepoint(&a, &A, &b),\n                BatchSize::SmallInput,\n            );\n        });\n    }",
    "display_name": "vartime_double_base_scalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "/// Edwards form of) Curve25519.\n///\n/// Internally, a `RistrettoPoint` is implemented as a wrapper type\n/// around `EdwardsPoint`, with custom equality, compression, and\n/// decompression routines to account for the quotient.  This means that\n/// operations on `RistrettoPoint`s are exactly as fast as operations on\n/// `EdwardsPoint`s.\n///\n#[derive(Copy, Clone)]\npub struct RistrettoPoint(pub(crate) EdwardsPoint);\n\nimpl RistrettoPoint {\n    /// Compress this point using the Ristretto encoding.\n    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let u1 = &(Z + &Y) * &(Z - &Y);\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let (_, invsqrt) = (&u1 * &u2.square()).invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let z_inv = &i1 * &(&i2 * T);\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let rotate = (T * &z_inv).is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        Y.conditional_negate((&X * &z_inv).is_negative());\n\n        let mut s = &den_inv * &(Z - &Y);\n        let s_is_negative = s.is_negative();\n        s.conditional_negate(s_is_negative);\n\n        CompressedRistretto(s.to_bytes())\n    }\n\n    /// Double-and-compress a batch of points.  The Ristretto encoding\n    /// is not batchable, since it requires an inverse square root.\n    ///\n    /// However, given input points \\\\( P\\_1, \\ldots, P\\_n, \\\\)\n    /// it is possible to compute the encodings of their doubles \\\\(\n    /// \\mathrm{enc}( \\[2\\]P\\_1), \\ldots, \\mathrm{enc}( \\[2\\]P\\_n ) \\\\)\n    /// in a batch.\n    ///\n    #[cfg_attr(feature = \"rand_core\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use rand_core::{OsRng, TryRngCore};\n    ///\n    /// # // Need fn main() here in comment so the doctest compiles\n    /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    /// # fn main() {\n    /// let mut rng = OsRng.unwrap_err();\n    ///\n    /// let points: Vec<RistrettoPoint> =\n    ///     (0..32).map(|_| RistrettoPoint::random(&mut rng)).collect();\n    ///\n    /// let compressed = RistrettoPoint::double_and_compress_batch(&points);\n    ///\n    /// for (P, P2_compressed) in points.iter().zip(compressed.iter()) {\n    ///     assert_eq!(*P2_compressed, (P + P).compress());\n    /// }\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.to_bytes())\n            })\n            .collect()\n    }\n\n    /// Return the coset self + E\\[4\\], for debugging.\n    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }\n\n    /// Computes the Ristretto Elligator map. This is the\n    /// [`MAP`](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4)\n    /// function defined in the Ristretto spec.\n    ///\n    /// # Note\n    ///\n    /// This method is not public because it's just used for hashing\n    /// to a point -- proper elligator support is deferred for now.\n    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }\n\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `RistrettoPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRng` interface.\n    ///\n    /// # Returns\n    ///\n    /// A random element of the Ristretto group.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self::try_from_rng(rng)\n            .map_err(|_: Infallible| {})\n            .expect(\"[bug] unfallible rng failed\")\n    }\n\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `RistrettoPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `TryCryptoRng` interface.\n    ///\n    /// # Returns\n    ///\n    /// A random element of the Ristretto group.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    pub fn try_from_rng<R: TryCryptoRng + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut uniform_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n\n        Ok(RistrettoPoint::from_uniform_bytes(&uniform_bytes))\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a `RistrettoPoint`.\n    ///\n    /// Takes a type parameter `D`, which is any `Digest` producing 64\n    /// bytes of output.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use sha2::Sha512;\n    ///\n    /// # // Need fn main() here in comment so the doctest compiles\n    /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let P = RistrettoPoint::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    ///\n    pub fn hash_from_bytes<D>(input: &[u8]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        RistrettoPoint::from_hash(hash)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a `RistrettoPoint` from an existing `Digest` instance.\n    ///\n    /// Use this instead of `hash_from_bytes` if it is more convenient\n    /// to stream data into the `Digest` than to pass a single byte\n    /// slice.\n    pub fn from_hash<D>(hash: D) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        // dealing with generic arrays is clumsy, until const generics land\n        let output = hash.finalize();\n        let mut output_bytes = [0u8; 64];\n        output_bytes.copy_from_slice(output.as_slice());\n\n        RistrettoPoint::from_uniform_bytes(&output_bytes)\n    }\n\n    /// Construct a `RistrettoPoint` from 64 bytes of data.\n    ///\n    /// If the input bytes are uniformly distributed, the resulting\n    /// point will be uniformly distributed over the group, and its\n    /// discrete log with respect to other points should be unknown.\n    ///\n    /// # Implementation\n    ///\n    /// This function splits the input array into two 32-byte halves,\n    /// takes the low 255 bits of each half mod p, applies the\n    /// Ristretto-flavored Elligator map to each, and adds the results.\n    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }\n}",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 shuffle_lanes",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_permutevar8x32_epi32",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/new",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "        fn shuffle_lanes(x: u32x8, control: Shuffle) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_permutevar8x32_epi32;\n\n                let c: u32x8 = match control {\n                    Shuffle::AAAA => u32x8::new(0, 0, 2, 2, 0, 0, 2, 2),\n                    Shuffle::BBBB => u32x8::new(1, 1, 3, 3, 1, 1, 3, 3),\n                    Shuffle::CACA => u32x8::new(4, 0, 6, 2, 4, 0, 6, 2),\n                    Shuffle::DBBD => u32x8::new(5, 1, 7, 3, 1, 5, 3, 7),\n                    Shuffle::ADDA => u32x8::new(0, 5, 2, 7, 5, 0, 7, 2),\n                    Shuffle::CBCB => u32x8::new(4, 1, 6, 3, 4, 1, 6, 3),\n                    Shuffle::ABAB => u32x8::new(0, 1, 2, 3, 0, 1, 2, 3),\n                    Shuffle::BADC => u32x8::new(1, 0, 3, 2, 5, 4, 7, 6),\n                    Shuffle::BACD => u32x8::new(1, 0, 3, 2, 4, 5, 6, 7),\n                    Shuffle::ABDC => u32x8::new(0, 1, 2, 3, 5, 4, 7, 6),\n                };\n                // Note that this gets turned into a generic LLVM\n                // shuffle-by-constants, which can be lowered to a simpler\n                // instruction than a generic permute.\n                _mm256_permutevar8x32_epi32(x.into(), c.into()).into()\n            }\n        }",
    "display_name": "shuffle_lanes",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/differential_add_and_double",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square"
    ],
    "body": "fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = &P.U + &P.W;\n    let t1 = &P.U - &P.W;\n    let t2 = &Q.U + &Q.W;\n    let t3 = &Q.U - &Q.W;\n\n    let t4 = t0.square();   // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square();   // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = &t4 - &t5;     // 4 U_P W_P\n\n    let t7 = &t0 * &t3;     // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = &t1 * &t2;     // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9  = &t7 + &t8;    // 2 (U_P U_Q - W_P W_Q)\n    let t10 = &t7 - &t8;    // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 =  t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n\n    let t13 = &APLUS2_OVER_FOUR * &t6; // (A + 2) U_P U_Q\n\n    let t14 = &t4 * &t5;    // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = &t13 + &t5;   // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = &t6 * &t15;   // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n\n    let t17 = affine_PmQ * &t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11;               // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14;  // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16;  // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18;  // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17;  // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}",
    "display_name": "differential_add_and_double",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 get_test_vectors",
    "statement_type": "function",
    "deps": [
      "std https:/github.com/rust_lang/rust/library/std fs/File/open",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/IntoIterator/into_iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "de/from_reader",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
      "3.0.0_pre.0 TestVector/From/from"
    ],
    "body": "fn get_test_vectors() -> impl Iterator<Item = TestVector> {\n    let f = File::open(\"VALIDATIONVECTORS\").expect(\n        \"This test is only available when the code has been cloned from the git repository, since\n        the VALIDATIONVECTORS file is large and is therefore not included within the distributed \\\n        crate.\",\n    );\n\n    serde_json::from_reader::<_, Vec<IntermediateTestVector>>(f)\n        .unwrap()\n        .into_iter()\n        .map(TestVector::from)\n}",
    "display_name": "get_test_vectors",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "bits/low_bits_mask",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "low_bits_mask",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/variable_base_mul"
    ],
    "body": "    fn mul(self, point: &'a EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "power2/arithmetic/lemma_pow2_subtracts",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_pow2_subtracts",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core option/Option/expect"
    ],
    "body": "            );\n        });\n        c.bench_function(\"Scalar multiplication\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a * b,\n                BatchSize::SmallInput,\n            );\n        });",
    "display_name": "vartime_mixed_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/compress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/FieldElement51/invsqrt",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_assign",
      "ConditionallyNegatable/conditional_negate",
      "5.0.0_pre.0 field/FieldElement51/is_negative"
    ],
    "body": "",
    "display_name": "compress",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/elligator_vs_ristretto_sage",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 ristretto/RistrettoPoint/elligator_ristretto_flavor",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress"
    ],
    "body": "    fn elligator_vs_ristretto_sage() {\n        // Test vectors extracted from ristretto.sage.\n        //\n        // Notice that all of the byte sequences have bit 255 set to 0; this is because\n        // ristretto.sage does not mask the high bit of a field element.  When the high bit is set,\n        // the ristretto.sage elligator implementation gives different results, since it takes a\n        // different field element as input.\n        let bytes: [[u8; 32]; 16] = [\n            [\n                184, 249, 135, 49, 253, 123, 89, 113, 67, 160, 6, 239, 7, 105, 211, 41, 192, 249,\n                185, 57, 9, 102, 70, 198, 15, 127, 7, 26, 160, 102, 134, 71,\n            ],\n            [\n                229, 14, 241, 227, 75, 9, 118, 60, 128, 153, 226, 21, 183, 217, 91, 136, 98, 0,\n                231, 156, 124, 77, 82, 139, 142, 134, 164, 169, 169, 62, 250, 52,\n            ],\n            [\n                115, 109, 36, 220, 180, 223, 99, 6, 204, 169, 19, 29, 169, 68, 84, 23, 21, 109,\n                189, 149, 127, 205, 91, 102, 172, 35, 112, 35, 134, 69, 186, 34,\n            ],\n            [\n                16, 49, 96, 107, 171, 199, 164, 9, 129, 16, 64, 62, 241, 63, 132, 173, 209, 160,\n                112, 215, 105, 50, 157, 81, 253, 105, 1, 154, 229, 25, 120, 83,\n            ],\n            [\n                156, 131, 161, 162, 236, 251, 5, 187, 167, 171, 17, 178, 148, 210, 90, 207, 86, 21,\n                79, 161, 167, 215, 234, 1, 136, 242, 182, 248, 38, 85, 79, 86,\n            ],\n            [\n                251, 177, 124, 54, 18, 101, 75, 235, 245, 186, 19, 46, 133, 157, 229, 64, 10, 136,\n                181, 185, 78, 144, 254, 167, 137, 49, 107, 10, 61, 10, 21, 25,\n            ],\n            [\n                232, 193, 20, 68, 240, 77, 186, 77, 183, 40, 44, 86, 150, 31, 198, 212, 76, 81, 3,\n                217, 197, 8, 126, 128, 126, 152, 164, 208, 153, 44, 189, 77,\n            ],\n            [\n                173, 229, 149, 177, 37, 230, 30, 69, 61, 56, 172, 190, 219, 115, 167, 194, 71, 134,\n                59, 75, 28, 244, 118, 26, 162, 97, 64, 16, 15, 189, 30, 64,\n            ],\n            [\n                106, 71, 61, 107, 250, 117, 42, 151, 91, 202, 212, 100, 52, 188, 190, 21, 125, 218,\n                31, 18, 253, 241, 160, 133, 57, 242, 3, 164, 189, 68, 111, 75,\n            ],\n            [\n                112, 204, 182, 90, 220, 198, 120, 73, 173, 107, 193, 17, 227, 40, 162, 36, 150,\n                141, 235, 55, 172, 183, 12, 39, 194, 136, 43, 153, 244, 118, 91, 89,\n            ],\n            [\n                111, 24, 203, 123, 254, 189, 11, 162, 51, 196, 163, 136, 204, 143, 10, 222, 33,\n                112, 81, 205, 34, 35, 8, 66, 90, 6, 164, 58, 170, 177, 34, 25,\n            ],\n            [\n                225, 183, 30, 52, 236, 82, 6, 183, 109, 25, 227, 181, 25, 82, 41, 193, 80, 77, 161,\n                80, 242, 203, 79, 204, 136, 245, 131, 110, 237, 106, 3, 58,\n            ],\n            [\n                207, 246, 38, 56, 30, 86, 176, 90, 27, 200, 61, 42, 221, 27, 56, 210, 79, 178, 189,\n                120, 68, 193, 120, 167, 77, 185, 53, 197, 124, 128, 191, 126,\n            ],\n            [\n                1, 136, 215, 80, 240, 46, 63, 147, 16, 244, 230, 207, 82, 189, 74, 50, 106, 169,\n                138, 86, 30, 131, 214, 202, 166, 125, 251, 228, 98, 24, 36, 21,\n            ],\n            [\n                210, 207, 228, 56, 155, 116, 207, 54, 84, 195, 251, 215, 249, 199, 116, 75, 109,\n                239, 196, 251, 194, 246, 252, 228, 70, 146, 156, 35, 25, 39, 241, 4,\n            ],\n            [\n                34, 116, 123, 9, 8, 40, 93, 189, 9, 103, 57, 103, 66, 227, 3, 2, 157, 107, 134,\n                219, 202, 74, 230, 154, 78, 107, 219, 195, 214, 14, 84, 80,\n            ],\n        ];\n        let encoded_images: [CompressedRistretto; 16] = [\n            CompressedRistretto([\n                176, 157, 237, 97, 66, 29, 140, 166, 168, 94, 26, 157, 212, 216, 229, 160, 195,\n                246, 232, 239, 169, 112, 63, 193, 64, 32, 152, 69, 11, 190, 246, 86,\n            ]),\n            CompressedRistretto([\n                234, 141, 77, 203, 181, 225, 250, 74, 171, 62, 15, 118, 78, 212, 150, 19, 131, 14,\n                188, 238, 194, 244, 141, 138, 166, 162, 83, 122, 228, 201, 19, 26,\n            ]),\n            CompressedRistretto([\n                232, 231, 51, 92, 5, 168, 80, 36, 173, 179, 104, 68, 186, 149, 68, 40, 140, 170,\n                27, 103, 99, 140, 21, 242, 43, 62, 250, 134, 208, 255, 61, 89,\n            ]),\n            CompressedRistretto([\n                208, 120, 140, 129, 177, 179, 237, 159, 252, 160, 28, 13, 206, 5, 211, 241, 192,\n                218, 1, 97, 130, 241, 20, 169, 119, 46, 246, 29, 79, 80, 77, 84,\n            ]),\n            CompressedRistretto([\n                202, 11, 236, 145, 58, 12, 181, 157, 209, 6, 213, 88, 75, 147, 11, 119, 191, 139,\n                47, 142, 33, 36, 153, 193, 223, 183, 178, 8, 205, 120, 248, 110,\n            ]),\n            CompressedRistretto([\n                26, 66, 231, 67, 203, 175, 116, 130, 32, 136, 62, 253, 215, 46, 5, 214, 166, 248,\n                108, 237, 216, 71, 244, 173, 72, 133, 82, 6, 143, 240, 104, 41,\n            ]),\n            CompressedRistretto([\n                40, 157, 102, 96, 201, 223, 200, 197, 150, 181, 106, 83, 103, 126, 143, 33, 145,\n                230, 78, 6, 171, 146, 210, 143, 112, 5, 245, 23, 183, 138, 18, 120,\n            ]),\n            CompressedRistretto([\n                220, 37, 27, 203, 239, 196, 176, 131, 37, 66, 188, 243, 185, 250, 113, 23, 167,\n                211, 154, 243, 168, 215, 54, 171, 159, 36, 195, 81, 13, 150, 43, 43,\n            ]),\n            CompressedRistretto([\n                232, 121, 176, 222, 183, 196, 159, 90, 238, 193, 105, 52, 101, 167, 244, 170, 121,\n                114, 196, 6, 67, 152, 80, 185, 221, 7, 83, 105, 176, 208, 224, 121,\n            ]),\n            CompressedRistretto([\n                226, 181, 183, 52, 241, 163, 61, 179, 221, 207, 220, 73, 245, 242, 25, 236, 67, 84,\n                179, 222, 167, 62, 167, 182, 32, 9, 92, 30, 165, 127, 204, 68,\n            ]),\n            CompressedRistretto([\n                226, 119, 16, 242, 200, 139, 240, 87, 11, 222, 92, 146, 156, 243, 46, 119, 65, 59,\n                1, 248, 92, 183, 50, 175, 87, 40, 206, 53, 208, 220, 148, 13,\n            ]),\n            CompressedRistretto([\n                70, 240, 79, 112, 54, 157, 228, 146, 74, 122, 216, 88, 232, 62, 158, 13, 14, 146,\n                115, 117, 176, 222, 90, 225, 244, 23, 94, 190, 150, 7, 136, 96,\n            ]),\n            CompressedRistretto([\n                22, 71, 241, 103, 45, 193, 195, 144, 183, 101, 154, 50, 39, 68, 49, 110, 51, 44,\n                62, 0, 229, 113, 72, 81, 168, 29, 73, 106, 102, 40, 132, 24,\n            ]),\n            CompressedRistretto([\n                196, 133, 107, 11, 130, 105, 74, 33, 204, 171, 133, 221, 174, 193, 241, 36, 38,\n                179, 196, 107, 219, 185, 181, 253, 228, 47, 155, 42, 231, 73, 41, 78,\n            ]),\n            CompressedRistretto([\n                58, 255, 225, 197, 115, 208, 160, 143, 39, 197, 82, 69, 143, 235, 92, 170, 74, 40,\n                57, 11, 171, 227, 26, 185, 217, 207, 90, 185, 197, 190, 35, 60,\n            ]),\n            CompressedRistretto([\n                88, 43, 92, 118, 223, 136, 105, 145, 238, 186, 115, 8, 214, 112, 153, 253, 38, 108,\n                205, 230, 157, 130, 11, 66, 101, 85, 253, 110, 110, 14, 148, 112,\n            ]),\n        ];\n        for i in 0..16 {\n            let r_0 = FieldElement::from_bytes(&bytes[i]);\n            let Q = RistrettoPoint::elligator_ristretto_flavor(&r_0);\n            assert_eq!(Q.compress(), encoded_images[i]);\n        }\n    }",
    "display_name": "elligator_vs_ristretto_sage",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "CtOption/is_some",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_some",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 bytes_from_hex",
    "statement_type": "function",
    "deps": [
      "impls/de/String/Deserialize/deserialize",
      "de/Error/custom",
      "alloc https:/github.com/rust_lang/rust/library/alloc string/String/len",
      "decode",
      "alloc https:/github.com/rust_lang/rust/library/alloc string/String/insert",
      "core https:/github.com/rust_lang/rust/library/core result/Result/map_err"
    ],
    "body": "fn bytes_from_hex<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    let mut hex_str = String::deserialize(deserializer)?;\n    // Prepend a 0 if it's not even length\n    if hex_str.len() % 2 == 1 {\n        hex_str.insert(0, '0');\n    }\n    hex::decode(hex_str).map_err(|e| SError::custom(format!(\"{:?}\", e)))\n}",
    "display_name": "bytes_from_hex",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signature/check_scalar",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 scalar/Scalar/from_canonical_bytes"
    ],
    "body": "fn check_scalar(bytes: [u8; 32]) -> Result<Scalar, SignatureError> {\n    match Scalar::from_canonical_bytes(bytes).into() {\n        None => Err(InternalError::ScalarFormat.into()),\n        Some(x) => Ok(x),\n    }\n}",
    "display_name": "check_scalar",
    "full_path": "file:///work/3185/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/wrapping_sub",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "wrapping_sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 function",
    "statement_type": "function",
    "deps": [],
    "body": "fn function(a: u32, b: u32) -> u32 {\n    a - b\n}",
    "display_name": "function",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/square_max",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/square"
    ],
    "body": "    fn square_max() {\n        let res = X.square();\n        for i in 0..5 {\n            assert!(res[i] == XX[i]);\n        }\n    }",
    "display_name": "square_max",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/ExpandedSecretKey/raw_sign",
    "statement_type": "function",
    "deps": [
      "digest/Digest/update",
      "core https:/github.com/rust_lang/rust/library/core iter/slice/Iter/Iterator/for_each",
      "3.0.0_pre.0 signing/ExpandedSecretKey/raw_sign_byupdate",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "core https:/github.com/rust_lang/rust/library/core slice/iter"
    ],
    "body": "",
    "display_name": "raw_sign",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/montgomery_elligator_correct",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_bytes",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 montgomery/elligator_encode",
      "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect"
    ],
    "body": "    fn montgomery_elligator_correct() {\n        let bytes: Vec<u8> = (0u8..32u8).collect();\n        let bits_in: [u8; 32] = (&bytes[..]).try_into().expect(\"Range invariant broken\");\n\n        let fe = FieldElement::from_bytes(&bits_in);\n        let (eg, _) = elligator_encode(&fe);\n        assert_eq!(eg.to_bytes(), ELLIGATOR_CORRECT_OUTPUT);\n    }",
    "display_name": "montgomery_elligator_correct",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/mul_le",
    "statement_type": "function",
    "deps": [
      "mul/arithmetic/lemma_mul_inequality"
    ],
    "body": "pub proof fn mul_le(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 <= b1,\n        a2 <= b2,\n    ensures\n        a1 * a2 <= b1 * b2,\n{\n    // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n    lemma_mul_inequality(a1 as int, b1  as int, a2 as int);\n    // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n    lemma_mul_inequality(a2 as int, b2 as int, b1 as int);\n}",
    "display_name": "mul_le",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "1.0.95 Ident/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.y_plus_x;\n        let MM = &Y_minus_X * &other.y_minus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &Z2 + &Txy2d,\n            T: &Z2 - &Txy2d,\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u32x8/splat",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_set1_epi32"
    ],
    "body": "    /// Create a `FieldElement2625x4` from four `FieldElement51`s.\n    ///\n    /// # Postconditions\n    ///\n    /// The resulting `FieldElement2625x4` is bounded with \\\\( b < 0.0002 \\\\).\n    #[rustfmt::skip] // keep alignment of computed lanes\n    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> FieldElement2625x4 {\n        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }\n\n        // We don't know that the original `FieldElement51`s were\n        // fully reduced, so the odd limbs may exceed 2^25.\n        // Reduce them to be sure.\n        FieldElement2625x4(buf).reduce()\n    }",
    "display_name": "splat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core str/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/EphemeralSecret/diffie_hellman",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_clamped"
    ],
    "body": "",
    "display_name": "diffie_hellman",
    "full_path": "file:///work/3185/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/reduce"
    ],
    "body": "",
    "display_name": "from_bytes_mod_order",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/pick_r",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 edwards/EdwardsPoint/Neg/neg",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress"
    ],
    "body": "    fn pick_r(s: Scalar) -> EdwardsPoint {\n        let r0 = s * ED25519_BASEPOINT_POINT;\n        // Pick a torsion point of order 2\n        r0 + WEAK_PUBKEY.decompress().unwrap().neg()\n    }",
    "display_name": "pick_r",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n        self.0[0] = 1;\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 is_capable_simd",
    "statement_type": "function",
    "deps": [],
    "body": "fn is_capable_simd(arch: &str, bits: DalekBits) -> bool {\n    arch == \"x86_64\" && bits == DalekBits::Dalek64\n}",
    "display_name": "is_capable_simd",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "0.1.1 Struct/member_function_with_const_arg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn member_function_with_const_arg<const N: u32>(self) -> u32 {\n        self.a - N\n    }",
    "display_name": "member_function_with_const_arg",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_mod_sum_factor",
    "statement_type": "function",
    "deps": [
      "div_mod/arithmetic/lemma_add_mod_noop",
      "div_mod/arithmetic/lemma_mod_twice",
      "div_mod/arithmetic/lemma_mod_multiples_basic"
    ],
    "body": "        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}\n\n// Auxiliary lemma for reordering terms in the pow2k proof\npub proof fn lemma_reorder_mul(a: int, b: int)\n    ensures\n        2 * (a * (19 * b)) == 19 * (2 * (a * b))\n{\n    // 2*( a * (19 * b)) = (2 * a) * (19 * b)\n    lemma_mul_is_associative(2, a, 19 * b);\n    // (2 * a) * (19 * b) = (19 * b) * (2 * a) = 19 * (b * (2 * a))\n    lemma_mul_is_associative(19, b, 2 * a);\n    // (b * (2 * a)) = (b * (a * 2)) = 2 * (a * b)\n    lemma_mul_is_associative(b, a, 2);\n}",
    "display_name": "lemma_mod_sum_factor",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/IntoIterator/into_iter",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "into_iter",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/remove",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "remove",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/words_to_nat_gen_u64",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "pub open spec fn words_to_nat_gen_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u64(words, num_words - 1, bits_per_word)\n    }\n}",
    "display_name": "words_to_nat_gen_u64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "file_name": "scalar_specs.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/take",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "take",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/Neg/neg",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/negate_lazy",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/blend",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/shuffle"
    ],
    "body": "    fn neg(self) -> CachedPoint {\n        let swapped = self.0.shuffle(Shuffle::BACD);\n        CachedPoint(swapped.blend(swapped.negate_lazy(), Lanes::D))\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        FieldElement51([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/contains",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "contains",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/four_torsion_random",
    "statement_type": "function",
    "deps": [
      "TryRngCore/unwrap_err",
      "5.0.0_pre.0 ristretto/RistrettoPoint/mul_base",
      "5.0.0_pre.0 ristretto/RistrettoPoint/coset4",
      "5.0.0_pre.0 scalar/Scalar/random"
    ],
    "body": "    fn four_torsion_random() {\n        let mut rng = OsRng.unwrap_err();\n        let P = RistrettoPoint::mul_base(&Scalar::random(&mut rng));\n        let P_coset = P.coset4();\n        for point in P_coset {\n            assert_eq!(P, RistrettoPoint(point));\n        }\n    }",
    "display_name": "four_torsion_random",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signature/Signature/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 Signature/from_components",
      "5.0.0_pre.0 scalar/Scalar/as_bytes",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn from(sig: InternalSignature) -> ed25519::Signature {\n        ed25519::Signature::from_components(*sig.R.as_bytes(), *sig.s.as_bytes())\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "ConstantTimeEq/ct_eq",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes"
    ],
    "body": "    fn ct_eq(&self, other: &FieldElement) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 StructWithGenericsNoWhere/member_function",
    "statement_type": "function",
    "deps": [],
    "body": "    fn member_function(&self, b: T) -> T::Output {\n        self.a - b\n    }",
    "display_name": "member_function",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/vartime_precomputed_pure_static",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_multiscalar_mul",
      "benchmark_group/BenchmarkGroup/bench_with_input",
      "benchmark_group/BenchmarkId/new",
      "5.0.0_pre.0 multiscalar_benches/construct_points",
      "bencher/Bencher/iter_batched",
      "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 multiscalar_benches/construct_scalars"
    ],
    "body": "    fn vartime_precomputed_pure_static<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Variable-time fixed-base multiscalar multiplication\",\n                    multiscalar_size,\n                ),\n                &multiscalar_size,\n                move |b, &&total_size| {\n                    let static_size = total_size;\n\n                    let static_points = construct_points(static_size);\n                    let precomp = VartimeEdwardsPrecomputation::new(static_points);\n                    // Rerandomize the scalars for every call to prevent\n                    // false timings from better caching (e.g., the CPU\n                    // cache lifts exactly the right table entries for the\n                    // benchmark into the highest cache levels).\n                    b.iter_batched(\n                        || construct_scalars(static_size),\n                        |scalars| precomp.vartime_multiscalar_mul(scalars),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }",
    "display_name": "vartime_precomputed_pure_static",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/elligator_ristretto_flavor",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/sqrt_ratio_i",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_assign",
      "5.0.0_pre.0 field/FieldElement51/is_negative",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "ConditionallyNegatable/conditional_negate"
    ],
    "body": "    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }",
    "display_name": "elligator_ristretto_flavor",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 cpuid_avx2/init",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "init",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_projective",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_projective",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/part2",
    "statement_type": "function",
    "deps": [],
    "body": "    fn part2(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let w = (sum as u64) & ((1u64 << 52) - 1);\n        let carry = sum >> 52;\n        (carry, w)\n    }",
    "display_name": "part2",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 spec/precomputed_straus/scalar_mul/vector/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 edwards/avx2/vector/backend/NafLookupTable8/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect"
    ],
    "body": "        fn new<I>(static_points: I) -> Self\n        where\n            I: IntoIterator,\n            I::Item: Borrow<EdwardsPoint>,\n        {\n            Self {\n                static_lookup_tables: static_points\n                    .into_iter()\n                    .map(|P| NafLookupTable8::<CachedPoint>::from(P.borrow()))\n                    .collect(),\n            }\n        }",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/batch_invert",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_assign",
      "5.0.0_pre.0 field/FieldElement51/is_zero",
      "From/from",
      "core https:/github.com/rust_lang/rust/library/core slice/iter_mut",
      "5.0.0_pre.0 field/FieldElement51/invert",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/IntoIterator/into_iter"
    ],
    "body": "    pub(crate) fn batch_invert(inputs: &mut [FieldElement]) {\n        // Montgomerys Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        let n = inputs.len();\n        let mut scratch = vec![FieldElement::ONE; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = FieldElement::ONE;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        assert!(bool::from(!acc.is_zero()));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n    }",
    "display_name": "batch_invert",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        CachedPoint(FieldElement2625x4::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/PublicKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/PublicKey/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "token/Pound/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 affine/edwards/AffinePoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 affine/edwards/AffinePoint/Identity/identity"
    ],
    "body": "    fn default() -> AffinePoint {\n        AffinePoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/invert",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes"
    ],
    "body": "",
    "display_name": "to_montgomery",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "mul/arithmetic/lemma_mul_is_distributive_sub_other_way",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_is_distributive_sub_other_way",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 process_item",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "0.1.1 process_impl",
      "0.1.1 process_function",
      "0.1.1 process_mod"
    ],
    "body": "fn process_item(attributes: &syn::LitStr, item: syn::Item, strict: bool) -> TokenStream {\n    match item {\n        syn::Item::Fn(function) => process_function(attributes, function, None),\n        syn::Item::Impl(item_impl) => process_impl(attributes, item_impl),\n        syn::Item::Mod(item_mod) => process_mod(attributes, item_mod, None).into(),\n        item => {\n            if strict {\n                unsupported!(item)\n            } else {\n                quote::quote! { #item }.into()\n            }\n        }\n    }\n}",
    "display_name": "process_item",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/compress",
    "statement_type": "function",
    "deps": [
      "bencher/Bencher/iter",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "benchmark_group/BenchmarkGroup/bench_function"
    ],
    "body": "    fn compress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B = &constants::ED25519_BASEPOINT_POINT;\n        c.bench_function(\"EdwardsPoint compression\", move |b| b.iter(|| B.compress()));\n    }",
    "display_name": "compress",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core exact_size/traits/iter/ExactSizeIterator/len",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "len",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n",
    "display_name": "group_order",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap_or_default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "unwrap_or_default",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signature/InternalSignature/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Signature( R: {:?}, s: {:?} )\", &self.R, &self.s)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core default/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ConditionallySelectable/conditional_swap",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "conditional_swap",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 kw/conditional",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "conditional",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/square2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/pow2k"
    ],
    "body": "    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            // TODO\n            // as_nat(square2(x)) = 2 * as_nat(x) * as_nat(x)\n            true\n    {\n        let mut square = self.pow2k(1);\n        for i in 0..5 {\n            proof {\n                assume(false);\n            }\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }",
    "display_name": "square2",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.0.conditional_assign(&other.0, choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
    "statement_type": "function",
    "deps": [],
    "body": "    ) -> Signature\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n    {\n        // OK unwrap, update can't fail.\n        self.raw_sign_byupdate(\n            |h: &mut CtxDigest| {\n                message.iter().for_each(|slice| h.update(slice));\n                Ok(())\n            },\n            verifying_key,\n        )\n        .unwrap()\n    }",
    "display_name": "mul_base",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/as_projective",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n        }\n    }",
    "display_name": "as_projective",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/as_projective_niels",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_projective_niels",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/hash_to_curve",
    "statement_type": "function",
    "deps": [
      "bencher/Bencher/iter",
      "benchmark_group/BenchmarkGroup/bench_function",
      "5.0.0_pre.0 edwards/EdwardsPoint/hash_to_curve",
      "thread/rngs/rng",
      "thread/rngs/ThreadRng/RngCore/fill_bytes"
    ],
    "body": "    fn hash_to_curve<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let mut rng = rng();\n\n        let mut msg = [0u8; 32];\n        let mut domain_sep = [0u8; 32];\n        rng.fill_bytes(&mut msg);\n        rng.fill_bytes(&mut domain_sep);\n\n        c.bench_function(\n            \"Elligator2 hash to curve (SHA-512, input size 32 bytes)\",\n            |b| b.iter(|| EdwardsPoint::hash_to_curve::<Sha512>(&[&msg], &[&domain_sep])),\n        );\n    }",
    "display_name": "hash_to_curve",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/compressed_identity",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress_batch",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/Identity/identity"
    ],
    "body": "    fn compressed_identity() {\n        assert_eq!(\n            EdwardsPoint::identity().compress(),\n            CompressedEdwardsY::identity()\n        );\n\n        #[cfg(feature = \"alloc\")]\n        {\n            let compressed = EdwardsPoint::compress_batch(&[EdwardsPoint::identity()]);\n            assert_eq!(&compressed, &[CompressedEdwardsY::identity()]);\n        }\n    }",
    "display_name": "compressed_identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_double_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/double",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_double_vs_basepoint2() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT.double().compress(),\n            BASE2_CMPRSSD\n        );\n    }",
    "display_name": "basepoint_double_vs_basepoint2",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "digest/Digest/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_div_and_mod_51",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_div_and_mod",
      "5.0.0_pre.0 field_verus/u64/serial/backend/l51_bit_mask_lt",
      "power2/arithmetic/pow2"
    ],
    "body": "pub proof fn lemma_div_and_mod_51(ai:u64, bi: u64, v: u64)\n    requires\n        ai == v >> 51,\n        bi == v & LOW_51_BIT_MASK\n    ensures\n        ai == v / (pow2(51) as u64),\n        bi == v % (pow2(51) as u64),\n        v == ai * pow2(51) + bi\n{\n    l51_bit_mask_lt(); // LOW_51_BIT_MASK == low_bits_mask(51)\n    lemma_div_and_mod(ai, bi, v, 51);\n}",
    "display_name": "lemma_div_and_mod_51",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 backend/VartimePrecomputedStraus/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/new"
    ],
    "body": "//! The Ristretto group comes equipped with an Elligator map.  This is\n//! used to implement\n//!\n//! * `RistrettoPoint::random()`, which generates random points from an\n//!   RNG - enabled by `rand_core` feature;\n//!\n//! * `RistrettoPoint::from_hash()` and\n//!   `RistrettoPoint::hash_from_bytes()`, which perform hashing to the\n//!   group.\n//!\n//! The Elligator map itself is not currently exposed.\n//!\n//! ## Implementation\n//!\n//! The Decaf suggestion is to use a quotient group, such as \\\\(\\mathcal\n//! E / \\mathcal E\\[4\\]\\\\) or \\\\(2 \\mathcal E / \\mathcal E\\[2\\] \\\\), to\n//! implement a prime-order group using a non-prime-order curve.\n//!\n//! This requires only changing\n//!\n//! 1. the function for equality checking (so that two representatives\n//!    of the same coset are considered equal);\n//! 2. the function for encoding (so that two representatives of the\n//!    same coset are encoded as identical bitstrings);\n//! 3. the function for decoding (so that only the canonical encoding of\n//!    a coset is accepted).\n//!\n//! Internally, each coset is represented by a curve point; two points\n//! \\\\( P, Q \\\\) may represent the same coset in the same way that two\n//! points with different \\\\(X,Y,Z\\\\) coordinates may represent the\n//! same point.  The group operations are carried out with no overhead\n//! using Edwards formulas.\n//!\n//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/equality",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes"
    ],
    "body": "    fn equality() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        assert!(a == a);\n        assert!(a != ainv);\n    }",
    "display_name": "equality",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/shuffle",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn shuffle(&self, control: Shuffle) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn shuffle_lanes(x: u32x8, control: Shuffle) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_permutevar8x32_epi32;\n\n                let c: u32x8 = match control {\n                    Shuffle::AAAA => u32x8::new(0, 0, 2, 2, 0, 0, 2, 2),\n                    Shuffle::BBBB => u32x8::new(1, 1, 3, 3, 1, 1, 3, 3),\n                    Shuffle::CACA => u32x8::new(4, 0, 6, 2, 4, 0, 6, 2),\n                    Shuffle::DBBD => u32x8::new(5, 1, 7, 3, 1, 5, 3, 7),\n                    Shuffle::ADDA => u32x8::new(0, 5, 2, 7, 5, 0, 7, 2),\n                    Shuffle::CBCB => u32x8::new(4, 1, 6, 3, 4, 1, 6, 3),\n                    Shuffle::ABAB => u32x8::new(0, 1, 2, 3, 0, 1, 2, 3),\n                    Shuffle::BADC => u32x8::new(1, 0, 3, 2, 5, 4, 7, 6),\n                    Shuffle::BACD => u32x8::new(1, 0, 3, 2, 4, 5, 6, 7),\n                    Shuffle::ABDC => u32x8::new(0, 1, 2, 3, 5, 4, 7, 6),\n                };\n                // Note that this gets turned into a generic LLVM\n                // shuffle-by-constants, which can be lowered to a simpler\n                // instruction than a generic permute.\n                _mm256_permutevar8x32_epi32(x.into(), c.into()).into()\n            }\n        }\n\n        FieldElement2625x4([\n            shuffle_lanes(self.0[0], control),\n            shuffle_lanes(self.0[1], control),\n            shuffle_lanes(self.0[2], control),\n            shuffle_lanes(self.0[3], control),\n            shuffle_lanes(self.0[4], control),\n        ])\n    }",
    "display_name": "shuffle",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/MultipartVerifier/multipart_verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/MultipartVerifier/multipart_verify"
    ],
    "body": "    fn multipart_verify(\n        &self,\n        message: &[&[u8]],\n        signature: &Signature,\n    ) -> Result<(), SignatureError> {\n        self.verifying_key.multipart_verify(message, signature)\n    }",
    "display_name": "multipart_verify",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/try_from_rng",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/RistrettoPoint/from_uniform_bytes"
    ],
    "body": "",
    "display_name": "try_from_rng",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"VerifyingKey({:?}), {:?})\", self.compressed, self.point)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 vstd_u128/u64/serial/backend/lemma_u128_and_split_low_bit",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 vstd_u128/u64/serial/backend/lemma_u128_pow2_no_overflow"
    ],
    "body": "    lemma_u128_and_split_low_bit,\n    lemma_u128_pow2_no_overflow,\n    u128\n);\n}",
    "display_name": "lemma_u128_and_split_low_bit",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/vstd_u128.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/vstd_u128.rs",
    "file_name": "vstd_u128.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/multiscalar_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 multiscalar_benches/vartime_precomputed_pure_static",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 multiscalar_benches/vartime_precomputed_helper",
      "Criterion/Default/default",
      "5.0.0_pre.0 multiscalar_benches/vartime_multiscalar_mul",
      "Criterion/benchmark_group",
      "5.0.0_pre.0 multiscalar_benches/consttime_multiscalar_mul"
    ],
    "body": "    pub(crate) fn multiscalar_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"multiscalar benches\");\n\n        consttime_multiscalar_mul(&mut g);\n        vartime_multiscalar_mul(&mut g);\n        vartime_precomputed_pure_static(&mut g);\n\n        let dynamic_fracs = [0.0, 0.2, 0.5];\n\n        for frac in dynamic_fracs.iter() {\n            vartime_precomputed_helper(&mut g, *frac);\n        }\n    }",
    "display_name": "multiscalar_benches",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/MultiscalarMul/multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map"
    ],
    "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> RistrettoPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<RistrettoPoint>,\n    {\n        let extended_points = points.into_iter().map(|P| P.borrow().0);\n        RistrettoPoint(EdwardsPoint::multiscalar_mul(scalars, extended_points))\n    }",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul"
    ],
    "body": "    fn mul() {\n        let res = Scalar52::mul(&X, &Y);\n        for i in 0..5 {\n            assert!(res[i] == XY[i]);\n        }\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc string/String/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core map/adapters/iter/Map/Iterator/fold",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "fold",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_mod_diff_factor",
    "statement_type": "function",
    "deps": [
      "div_mod/arithmetic/lemma_mod_twice",
      "div_mod/arithmetic/lemma_sub_mod_noop",
      "div_mod/arithmetic/lemma_mod_multiples_basic"
    ],
    "body": "pub proof fn lemma_mod_diff_factor(a: int, b: int, m: int)\n    requires\n        m > 0,\n    ensures\n        (b - a * m) % m == b % m\n{\n    // (b - a * m) % m == (b % m - (a * m) % m) % m\n    lemma_sub_mod_noop(b, a * m, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}",
    "display_name": "lemma_mod_diff_factor",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 variable_base/scalar_mul/serial/backend/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "5.0.0_pre.0 scalar/Scalar/as_radix_16",
      "5.0.0_pre.0 window/LookupTable/From/from",
      "5.0.0_pre.0 window/LookupTable/select",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/double",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_projective",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity"
    ],
    "body": "\n//! **INTERNALS:** Pluggable implementations for different architectures.\n//!\n//! The backend code is split into two parts: a serial backend,\n//! and a vector backend.\n//!\n//! The [`serial`] backend contains 32- and 64-bit implementations of\n//! field arithmetic and scalar arithmetic, as well as implementations\n//! of point operations using the mixed-model strategy (passing\n//! between different curve models depending on the operation).\n//!\n//! The [`vector`] backend contains implementations of vectorized\n//! field arithmetic, used to implement point operations using a novel\n//! implementation strategy derived from parallel formulas of Hisil,\n//! Wong, Carter, and Dawson.\n//!\n//! Because the two strategies give rise to different curve models,\n//! it's not possible to reuse exactly the same scalar multiplication\n//! code (or to write it generically), so both serial and vector\n//! backends contain matching implementations of scalar multiplication\n//! algorithms.  These are intended to be selected by a `#[cfg]`-based\n//! type alias.\n//!\n//! The [`vector`] backend is selected by the `simd_backend` cargo\n//! feature; it uses the [`serial`] backend for non-vectorized operations.\n\nuse crate::EdwardsPoint;\nuse crate::Scalar;\n\npub mod serial;\n\n#[cfg(curve25519_dalek_backend = \"simd\")]\npub mod vector;\n\n#[derive(Copy, Clone)]\nenum BackendKind {\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    Avx2,\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    Avx512,\n    Serial,\n}",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/SharedSecret/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/SharedSecret/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 affine/edwards/Scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 affine/edwards/AffinePoint/to_edwards"
    ],
    "body": "    fn mul(self, rhs: &AffinePoint) -> EdwardsPoint {\n        rhs.to_edwards() * self\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core impls/cmp/Ord/cmp",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "cmp",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
    "file_name": "vartime_double_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/from_uniform_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "5.0.0_pre.0 ristretto/RistrettoPoint/elligator_ristretto_flavor"
    ],
    "body": "    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }",
    "display_name": "from_uniform_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/add_reduces",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_reduces() {\n        // Check that addition wraps around the modulus\n        assert_eq!(BASEPOINT_ORDER_MINUS_ONE + Scalar::ONE, Scalar::ZERO);\n    }",
    "display_name": "add_reduces",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 unsafe_target_feature",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "unsafe_target_feature",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_plus_basepoint_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_plus_basepoint_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_added = bp + bp;\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }",
    "display_name": "basepoint_plus_basepoint_vs_basepoint2",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/is_weak",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/is_small_order"
    ],
    "body": "        }\n        s_candidate\n    }\n\n    fn pick_r(s: Scalar) -> EdwardsPoint {\n        let r0 = s * ED25519_BASEPOINT_POINT;\n        // Pick a torsion point of order 2\n        r0 + WEAK_PUBKEY.decompress().unwrap().neg()\n    }",
    "display_name": "is_weak",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.bytes\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/extended_point_equality_handles_scaling",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/ConstantTimeEq/ct_eq",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "From/from"
    ],
    "body": "    fn extended_point_equality_handles_scaling() {\n        let mut two_bytes = [0u8; 32];\n        two_bytes[0] = 2;\n        let id1 = EdwardsPoint::identity();\n        let id2 = EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::from_bytes(&two_bytes),\n            Z: FieldElement::from_bytes(&two_bytes),\n            T: FieldElement::ZERO,\n        };\n        assert!(bool::from(id1.ct_eq(&id2)));\n    }",
    "display_name": "extended_point_equality_handles_scaling",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/StaticSecret/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_wide_to_nat_rec",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "pub open spec fn bytes_wide_to_nat_rec(bytes: &[u8; 64], index: int) -> nat\ndecreases 64 - index\n{\n    if index >= 64 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_wide_to_nat_rec(bytes, index + 1)\n    }\n}",
    "display_name": "bytes_wide_to_nat_rec",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "file_name": "scalar_specs.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/EdwardsPoint/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/split"
    ],
    "body": "    fn from(P: ExtendedPoint) -> edwards::EdwardsPoint {\n        let tmp = P.0.split();\n        edwards::EdwardsPoint {\n            X: tmp[0],\n            Y: tmp[1],\n            Z: tmp[2],\n            T: tmp[3],\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/lemma_pow2_pos",
      "div_mod/arithmetic/lemma_fundamental_div_mod",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "mul/arithmetic/lemma_mul_strict_inequality_converse"
    ],
    "body": "pub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
    "display_name": "lemma_carry_bounded_after_mask",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "punctuated/Punctuated/parse_terminated",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "parse_terminated",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/is_empty",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/from_keypair_bytes",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/SigningKey/TryFrom/try_from",
      "core https:/github.com/rust_lang/rust/library/core slice/split_at",
      "3.0.0_pre.0 verifying/VerifyingKey/TryFrom/try_from",
      "3.0.0_pre.0 signing/SigningKey/verifying_key",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    pub fn from_keypair_bytes(bytes: &[u8; 64]) -> Result<SigningKey, SignatureError> {\n        let (secret_key, verifying_key) = bytes.split_at(SECRET_KEY_LENGTH);\n        let signing_key = SigningKey::try_from(secret_key)?;\n        let verifying_key = VerifyingKey::try_from(verifying_key)?;\n\n        if signing_key.verifying_key() != verifying_key {\n            return Err(InternalError::MismatchedKeypair.into());\n        }\n\n        Ok(signing_key)\n    }",
    "display_name": "from_keypair_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 SpecializeArg/lit",
    "statement_type": "function",
    "deps": [],
    "body": "    fn lit(&self) -> &syn::LitStr {\n        match self {\n            SpecializeArg::LitStr(lit) => lit,\n            SpecializeArg::Conditional(conditional) => &conditional.lit,\n        }\n    }",
    "display_name": "lit",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/double",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/double"
    ],
    "body": "",
    "display_name": "double",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/shl_nondecreasing",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_shl_le_u64",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shl_decomposition",
      "power2/arithmetic/lemma_pow2_adds",
      "power2/arithmetic/pow2",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shl_zero_is_id",
      "5.0.0_pre.0 common_verus/u64/serial/backend/mul_le",
      "power2/arithmetic/lemma_pow2_strictly_increases",
      "mul/arithmetic/lemma_mul_is_associative",
      "power2/arithmetic/lemma2_to64"
    ],
    "body": "pub proof fn shl_nondecreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b < 64,\n        v * pow2(b) <= u64::MAX\n    ensures\n        (v << a) <= (v << b)\n{\n    lemma2_to64(); // pow2(0)\n\n    if (a == b) {\n        // trivial\n    }\n    else if (a == 0) {\n        // a != b <=> b > 0\n        lemma_pow2_strictly_increases(0, b);\n        lemma_u64_shl_is_mul(v, 0);\n        lemma_u64_shl_is_mul(v, b as u64);\n        mul_le(v as nat, v as nat, pow2(0), pow2(b));\n    }\n    else {\n        // if a != 0 and a != b then 0 < d < b\n        let d = b - a;\n\n        // v << b = (v << (b - a)) << a\n        shl_decomposition(v, d as nat, a);\n\n        assert(v << d == v * pow2(d as nat)) by {\n            // we need the precond v * pow2(d) < M\n            lemma_pow2_strictly_increases(d as nat, b);\n            mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));\n            lemma_u64_shl_is_mul(v, d as u64);\n        }\n\n        assert(v <= v << d) by {\n            shl_zero_is_id(v);\n            lemma_u64_shl_is_mul(v, 0);\n            lemma_pow2_strictly_increases(0, d as nat);\n            mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));\n        }\n\n        lemma_pow2_adds(a, d as nat);\n\n        assert( (v << (d as u64)) * pow2(a) <= u64::MAX ) by {\n            broadcast use lemma_mul_is_associative;\n        }\n\n        // [v <= v << d] => [(v << a) <= (v << d) << a]\n        lemma_shl_le_u64(v, v << (d as u64), a);\n    }\n}",
    "display_name": "shl_nondecreasing",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/as_radix_16",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn as_radix_16(&self) -> [i8; 64] {\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8; 64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[allow(clippy::identity_op)]\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        for i in 0..32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        output\n    }",
    "display_name": "as_radix_16",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Sub/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/sub",
      "5.0.0_pre.0 scalar/Scalar/unpack",
      "5.0.0_pre.0 scalar/Scalar52/pack"
    ],
    "body": "    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar52/invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_montgomery",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/as_montgomery",
      "5.0.0_pre.0 scalar/Scalar52/montgomery_invert"
    ],
    "body": "    pub fn invert(&self) -> UnpackedScalar {\n        self.as_montgomery().montgomery_invert().from_montgomery()\n    }",
    "display_name": "invert",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 spec/vartime_double_base/scalar_mul/vector/backend/mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "5.0.0_pre.0 edwards/avx2/vector/backend/NafLookupTable5/From/from",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 window/NafLookupTable5/select",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/double",
      "core https:/github.com/rust_lang/rust/library/core impls/cmp/Ord/cmp",
      "5.0.0_pre.0 window/NafLookupTable8/select",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Identity/identity",
      "5.0.0_pre.0 scalar/Scalar/non_adjacent_form"
    ],
    "body": "    pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n        let a_naf = a.non_adjacent_form(5);\n\n        #[cfg(feature = \"precomputed-tables\")]\n        let b_naf = b.non_adjacent_form(8);\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        let b_naf = b.non_adjacent_form(5);\n\n        // Find starting index\n        let mut i: usize = 255;\n        for j in (0..256).rev() {\n            i = j;\n            if a_naf[i] != 0 || b_naf[i] != 0 {\n                break;\n            }\n        }\n\n        let table_A = NafLookupTable5::<CachedPoint>::from(A);\n\n        #[cfg(feature = \"precomputed-tables\")]\n        let table_B = &BASEPOINT_ODD_LOOKUP_TABLE;\n\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        let table_B =\n            &NafLookupTable5::<CachedPoint>::from(&crate::constants::ED25519_BASEPOINT_POINT);\n\n        let mut Q = ExtendedPoint::identity();\n\n        loop {\n            Q = Q.double();\n\n            match a_naf[i].cmp(&0) {\n                Ordering::Greater => {\n                    Q = &Q + &table_A.select(a_naf[i] as usize);\n                }\n                Ordering::Less => {\n                    Q = &Q - &table_A.select(-a_naf[i] as usize);\n                }\n                Ordering::Equal => {}\n            }\n\n            match b_naf[i].cmp(&0) {\n                Ordering::Greater => {\n                    Q = &Q + &table_B.select(b_naf[i] as usize);\n                }\n                Ordering::Less => {\n                    Q = &Q - &table_B.select(-b_naf[i] as usize);\n                }\n                Ordering::Equal => {}\n            }\n\n            if i == 0 {\n                break;\n            }\n            i -= 1;\n        }\n\n        Q.into()\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/vartime_double_base.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/vartime_double_base.rs",
    "file_name": "vartime_double_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/p",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "pub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n}",
    "display_name": "p",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "attr/MetaList/parse_args",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "parse_args",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core ptr_try_from_impls/num/convert/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "try_from",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/SigningKey/verifying_key",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base"
    ],
    "body": "    fn from(point: EdwardsPoint) -> VerifyingKey {\n        VerifyingKey {\n            point,\n            compressed: point.compress(),\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/len",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/VartimePrecomputedStraus/len"
    ],
    "body": "    fn len(&self) -> usize {\n        self.0.len()\n    }",
    "display_name": "len",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/SharedSecret/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Neg/neg",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/unpack",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/sub",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul_internal",
      "5.0.0_pre.0 scalar/Scalar52/pack"
    ],
    "body": "    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/against_reference_implementation",
    "statement_type": "function",
    "deps": [
      "std https:/github.com/rust_lang/rust/library/std bufreader/buffered/io/BufReader/new",
      "core https:/github.com/rust_lang/rust/library/core result/Result/is_err",
      "std https:/github.com/rust_lang/rust/library/std fs/File/open",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "std https:/github.com/rust_lang/rust/library/std io/BufRead/lines",
      "3.0.0_pre.0 signing/SigningKey/from_bytes",
      "3.0.0_pre.0 signing/SigningKey/verify",
      "core https:/github.com/rust_lang/rust/library/core result/Result/is_ok",
      "Vec/FromHex/from_hex",
      "3.0.0_pre.0 Signature/TryFrom/try_from",
      "3.0.0_pre.0 verifying/VerifyingKey/from_bytes",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "3.0.0_pre.0 signing/SigningKey/verifying_key",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len",
      "signer/Signer/sign",
      "3.0.0_pre.0 verifying/VerifyingKey/verify_strict",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core str/split"
    ],
    "body": "    fn against_reference_implementation() {\n        // TestGolden\n        let mut line: String;\n        let mut lineno: usize = 0;\n\n        let f = File::open(\"TESTVECTORS\");\n        if f.is_err() {\n            println!(\n                \"This test is only available when the code has been cloned \\\n                 from the git repository, since the TESTVECTORS file is large \\\n                 and is therefore not included within the distributed crate.\"\n            );\n            panic!();\n        }\n        let file = BufReader::new(f.unwrap());\n\n        for l in file.lines() {\n            lineno += 1;\n            line = l.unwrap();\n\n            let parts: Vec<&str> = line.split(':').collect();\n            assert_eq!(parts.len(), 5, \"wrong number of fields in line {}\", lineno);\n\n            let sec_bytes: Vec<u8> = FromHex::from_hex(parts[0]).unwrap();\n            let pub_bytes: Vec<u8> = FromHex::from_hex(parts[1]).unwrap();\n            let msg_bytes: Vec<u8> = FromHex::from_hex(parts[2]).unwrap();\n            let sig_bytes: Vec<u8> = FromHex::from_hex(parts[3]).unwrap();\n\n            let sec_bytes = &sec_bytes[..SECRET_KEY_LENGTH].try_into().unwrap();\n            let pub_bytes = &pub_bytes[..PUBLIC_KEY_LENGTH].try_into().unwrap();\n\n            let signing_key = SigningKey::from_bytes(sec_bytes);\n            let expected_verifying_key = VerifyingKey::from_bytes(pub_bytes).unwrap();\n            assert_eq!(expected_verifying_key, signing_key.verifying_key());\n\n            // The signatures in the test vectors also include the message\n            // at the end, but we just want R and S.\n            let sig1: Signature = Signature::try_from(&sig_bytes[..64]).unwrap();\n            let sig2: Signature = signing_key.sign(&msg_bytes);\n\n            assert!(sig1 == sig2, \"Signature bytes not equal on line {}\", lineno);\n            assert!(\n                signing_key.verify(&msg_bytes, &sig2).is_ok(),\n                \"Signature verification failed on line {}\",\n                lineno\n            );\n            assert!(\n                expected_verifying_key\n                    .verify_strict(&msg_bytes, &sig2)\n                    .is_ok(),\n                \"Signature strict verification failed on line {}\",\n                lineno\n            );\n        }\n    }",
    "display_name": "against_reference_implementation",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/reduce",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/p",
      "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_boundaries",
      "5.0.0_pre.0 field_verus/u64/serial/backend/spec_reduce",
      "div_mod/arithmetic/lemma_mod_multiples_vanish",
      "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_reduce",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/pow255_gt_19"
    ],
    "body": "    fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n        ensures\n            r.limbs == spec_reduce(limbs),\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n            (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n            as_nat(r.limbs) == as_nat(limbs) - p() * (limbs[4] >> 51),\n            as_nat(r.limbs) % p() == as_nat(limbs) % p()\n    {\n        proof {\n            lemma_boundaries(limbs);\n            lemma_reduce(limbs);\n            pow255_gt_19();\n            lemma_mod_multiples_vanish((limbs[4] >> 51) as int, as_nat(spec_reduce(limbs)) as int, p() as int);\n        }\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/pow_p58",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/pow22501",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/pow2k"
    ],
    "body": "    fn pow_p58(&self) -> FieldElement {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();    // 249..0\n        let t20 = t19.pow2k(2);            // 251..2\n        let t21 = self * &t20;             // 251..2,0\n\n        t21\n    }",
    "display_name": "pow_p58",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/non_adjacent_form_iter",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/non_adjacent_form",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev"
    ],
    "body": "    fn non_adjacent_form_iter(w: usize, x: &Scalar) {\n        let naf = x.non_adjacent_form(w);\n\n        // Reconstruct the scalar from the computed NAF\n        let mut y = Scalar::ZERO;\n        for i in (0..256).rev() {\n            y += y;\n            let digit = if naf[i] < 0 {\n                -Scalar::from((-naf[i]) as u64)\n            } else {\n                Scalar::from(naf[i] as u64)\n            };\n            y += digit;\n        }\n\n        assert_eq!(*x, y);\n    }",
    "display_name": "non_adjacent_form_iter",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/fuzzer_testcase_reduction",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order_wide",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order"
    ],
    "body": "    fn fuzzer_testcase_reduction() {\n        // LE bytes of 24519928653854221733733552434404946937899825954937634815\n        let a_bytes = [\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n            255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        // LE bytes of 4975441334397345751130612518500927154628011511324180036903450236863266160640\n        let b_bytes = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 210, 210,\n            210, 255, 255, 255, 255, 10,\n        ];\n        // LE bytes of 6432735165214683820902750800207468552549813371247423777071615116673864412038\n        let c_bytes = [\n            134, 171, 119, 216, 180, 128, 178, 62, 171, 132, 32, 62, 34, 119, 104, 193, 47, 215,\n            181, 250, 14, 207, 172, 93, 75, 207, 211, 103, 144, 204, 56, 14,\n        ];\n\n        let a = Scalar::from_bytes_mod_order(a_bytes);\n        let b = Scalar::from_bytes_mod_order(b_bytes);\n        let c = Scalar::from_bytes_mod_order(c_bytes);\n\n        let mut tmp = [0u8; 64];\n\n        // also_a = (a mod l)\n        tmp[0..32].copy_from_slice(&a_bytes[..]);\n        let also_a = Scalar::from_bytes_mod_order_wide(&tmp);\n\n        // also_b = (b mod l)\n        tmp[0..32].copy_from_slice(&b_bytes[..]);\n        let also_b = Scalar::from_bytes_mod_order_wide(&tmp);\n\n        let expected_c = a * b;\n        let also_expected_c = also_a * also_b;\n\n        assert_eq!(c, expected_c);\n        assert_eq!(c, also_expected_c);\n    }",
    "display_name": "fuzzer_testcase_reduction",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/Product/product",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/fold"
    ],
    "body": "    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }",
    "display_name": "product",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 find_validation_criteria",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/Verifier/verify",
      "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/contains",
      "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/insert",
      "3.0.0_pre.0 get_test_vectors",
      "3.0.0_pre.0 verifying/VerifyingKey/verify_strict",
      "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/new",
      "core https:/github.com/rust_lang/rust/library/core result/Result/is_ok"
    ],
    "body": "fn find_validation_criteria() {\n    let mut verify_allowed_edgecases = Set::new();\n    let mut verify_strict_allowed_edgecases = Set::new();\n\n    // Counts the number of times a signature with a re-encoded k and a low-order A verified. This\n    // happens with 1/8 probability, assuming the usual verification equation(s).\n    let mut num_lucky_reencoded_k = 0;\n    let mut num_reencoded_k = 0;\n\n    for TestVector {\n        number: _,\n        pubkey,\n        msg,\n        sig,\n        flags,\n    } in get_test_vectors()\n    {\n        // If verify() was a success, add all the associated flags to verify-permitted set\n        let success = pubkey.verify(&msg, &sig).is_ok();\n\n        // If this is ReencodedK && LowOrderA, log some statistics\n        if flags.contains(&Flag::ReencodedK) && flags.contains(&Flag::LowOrderA) {\n            num_reencoded_k += 1;\n            num_lucky_reencoded_k += success as u8;\n        }\n\n        if success {\n            for flag in &flags {\n                // Don't count re-encoded k when A is low-order. This is because the\n                // re-encoded k might be a multiple of 8 by accident\n                if *flag == Flag::ReencodedK && flags.contains(&Flag::LowOrderA) {\n                    continue;\n                } else {\n                    verify_allowed_edgecases.insert(*flag);\n                }\n            }\n        }\n\n        // If verify_strict() was a success, add all the associated flags to\n        // verify_strict-permitted set\n        let success = pubkey.verify_strict(&msg, &sig).is_ok();\n        if success {\n            for flag in &flags {\n                verify_strict_allowed_edgecases.insert(*flag);\n            }\n        }\n    }\n\n    println!(\"VERIFY_ALLOWED_EDGECASES: {:?}\", verify_allowed_edgecases);\n    println!(\n        \"VERIFY_STRICT_ALLOWED_EDGECASES: {:?}\",\n        verify_strict_allowed_edgecases\n    );\n    println!(\n        \"re-encoded k && low-order A yielded a valid signature {}/{} of the time\",\n        num_lucky_reencoded_k, num_reencoded_k\n    );\n}",
    "display_name": "find_validation_criteria",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 decompress/ristretto/step_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
      "5.0.0_pre.0 field/FieldElement51/is_negative",
      "ConditionallyNegatable/conditional_negate",
      "5.0.0_pre.0 field/FieldElement51/is_zero",
      "5.0.0_pre.0 field/FieldElement51/invsqrt"
    ],
    "body": "    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as\n        let u2 = &one + &ss; //  1 - as    where a=-1\n        let u2_sqr = u2.square(); // (1 - as)\n\n        // v == ad(1+as) - (1-as)            where d=-121665/121666\n        let v = &(&(-&constants::EDWARDS_D) * &u1.square()) - &u2_sqr;\n\n        let (ok, I) = (&v * &u2_sqr).invsqrt(); // 1/sqrt(v*u_2)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dy = &I * &(&Dx * &v); // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s/(ad(1+as) - (1-as)))\n        let mut x = &(&s + &s) * &Dx;\n        let x_neg = x.is_negative();\n        x.conditional_negate(x_neg);\n\n        // y == (1-as)/(1+as)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as) sqrt(4s/(ad(1+as) - (1-as))))/(1-as)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }",
    "display_name": "step_2",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core builders/fmt/DebugStruct/field",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "field",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ser/to_string",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_string",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/mul_lt",
    "statement_type": "function",
    "deps": [
      "mul/arithmetic/lemma_mul_nonzero",
      "mul/arithmetic/lemma_mul_strict_inequality"
    ],
    "body": "pub proof fn mul_lt(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 < b1,\n        a2 < b2,\n    ensures\n        a1 * a2 < b1 * b2,\n{\n    if (a2 == 0) {\n        assert(b1 * b2 > 0) by {\n            // a * b != 0 <==> a != 0 /\\ b != 0\n            lemma_mul_nonzero(b1 as int, b2 as int);\n        }\n    }\n    else {\n        // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n        lemma_mul_strict_inequality(a1 as int, b1  as int, a2 as int);\n        // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n        lemma_mul_strict_inequality(a2 as int, b2 as int, b1 as int);\n    }\n}",
    "display_name": "mul_lt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 test_unset_target_feature",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_unset_target_feature() {\n    compile_error!(\"When an unknown target_feature is set on a test, unsafe_target_feature is expected remove the function\");\n}",
    "display_name": "test_unset_target_feature",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/pippenger_optional_multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/by_ref",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/size_hint",
      "5.0.0_pre.0 backend/straus_optional_multiscalar_mul"
    ],
    "body": "        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 BatchCompressState/From/from",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_assign",
      "5.0.0_pre.0 field/FieldElement51/batch_invert",
      "ConditionallyNegatable/conditional_negate",
      "5.0.0_pre.0 BatchCompressState/efgh",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 field/FieldElement51/is_negative",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
      "core https:/github.com/rust_lang/rust/library/core slice/iter"
    ],
    "body": "            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/Add/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective_niels",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended"
    ],
    "body": "    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 test/hazmat/sign_byupdate",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/From/from",
      "core https:/github.com/rust_lang/rust/library/core result/Result/is_err",
      "3.0.0_pre.0 hazmat/raw_sign",
      "3.0.0_pre.0 hazmat/raw_sign_byupdate",
      "TryRngCore/unwrap_err",
      "digest/Digest/update",
      "3.0.0_pre.0 test/hazmat/ExpandedSecretKey/random",
      "error/Error/new",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap"
    ],
    "body": "    fn sign_byupdate() {\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        let msg = b\"realistic\";\n        // signatures are deterministic so we can compare with a good one\n        let good_sig = raw_sign::<CtxDigest>(&esk, msg, &vk);\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(msg);\n                Ok(())\n            },\n            &vk,\n        );\n        assert!(sig.unwrap() == good_sig, \"sign byupdate matches\");\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(msg);\n                Err(SignatureError::new())\n            },\n            &vk,\n        );\n        assert!(sig.is_err(), \"sign byupdate failure propagates\");\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(&msg[..1]);\n                h.update(&msg[1..]);\n                Ok(())\n            },\n            &vk,\n        );\n        assert!(sig.unwrap() == good_sig, \"sign byupdate two part\");\n    }",
    "display_name": "sign_byupdate",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/impl_sum",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 scalar/Scalar/From/from"
    ],
    "body": "    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let BASE = constants::ED25519_BASEPOINT_POINT;\n\n        let s1 = Scalar::from(999u64);\n        let P1 = BASE * s1;\n\n        let s2 = Scalar::from(333u64);\n        let P2 = BASE * s2;\n\n        let vec = vec![P1, P2];\n        let sum: EdwardsPoint = vec.iter().sum();\n\n        assert_eq!(sum, P1 + P2);\n\n        // Test that sum works for the empty iterator\n        let empty_vector: Vec<EdwardsPoint> = vec![];\n        let sum: EdwardsPoint = empty_vector.iter().sum();\n\n        assert_eq!(sum, EdwardsPoint::identity());\n\n        // Test that sum works on owning iterators\n        let s = Scalar::from(2u64);\n        let mapped = vec.iter().map(|x| x * s);\n        let sum: EdwardsPoint = mapped.sum();\n\n        assert_eq!(sum, P1 * s + P2 * s);\n    }",
    "display_name": "impl_sum",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/ConstantTimeEq/ct_eq",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core result/Result/is_ok",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_ok",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core array/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "try_from",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 process_function",
    "statement_type": "function",
    "deps": [
      "1.0.95 Ident/span",
      "core https:/github.com/rust_lang/rust/library/core slice/first",
      "1.0.95 Ident/Clone/clone",
      "generics/TypeGenerics/as_turbofish",
      "alloc https:/github.com/rust_lang/rust/library/alloc boxed/Box/new",
      "alloc https:/github.com/rust_lang/rust/library/alloc boxed/Box/Clone/clone",
      "clone/gen/FnArg/Clone/clone",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/push",
      "error/Error/new",
      "core https:/github.com/rust_lang/rust/library/core option/Option/is_some",
      "0.1.1 is_path_eq",
      "error/Error/into_compile_error",
      "generics/Generics/split_for_impl",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/enumerate",
      "1.0.95 Ident/new",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "core https:/github.com/rust_lang/rust/library/core option/Option/is_none",
      "spanned/Spanned/span",
      "clone/gen/Receiver/Clone/clone",
      "punctuated/Punctuated/iter",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/new",
      "alloc https:/github.com/rust_lang/rust/library/alloc string/ToString/to_string"
    ],
    "body": "fn process_function(\n    attributes: &syn::LitStr,\n    function: syn::ItemFn,\n    outer: Option<(syn::Generics, Box<syn::Type>)>,\n) -> TokenStream {\n    if function.sig.unsafety.is_some() {\n        return quote::quote! {\n            #[target_feature(enable = #attributes)]\n            #function\n        }\n        .into();\n    }\n\n    unsupported_if_some!(function.sig.constness);\n    unsupported_if_some!(function.sig.asyncness);\n    unsupported_if_some!(function.sig.abi);\n    unsupported_if_some!(function.sig.variadic);\n\n    let function_visibility = function.vis;\n    let function_name = function.sig.ident;\n    let function_return = function.sig.output;\n    let function_inner_name =\n        syn::Ident::new(&format!(\"_impl_{}\", function_name), function_name.span());\n    let function_args = function.sig.inputs;\n    let function_body = function.block;\n    let mut function_call_args = Vec::new();\n    let mut function_args_outer = Vec::new();\n    let mut function_args_inner = Vec::new();\n    for (index, arg) in function_args.iter().enumerate() {\n        match arg {\n            syn::FnArg::Receiver(receiver) => {\n                unsupported_if_some!(receiver.attrs.first());\n                unsupported_if_some!(receiver.colon_token);\n\n                if outer.is_none() {\n                    return syn::Error::new(receiver.span(), \"unsupported by #[unsafe_target_feature(...)]; put the attribute on the outer `impl`\").into_compile_error().into();\n                }\n\n                function_args_inner.push(syn::FnArg::Receiver(receiver.clone()));\n                function_args_outer.push(syn::FnArg::Receiver(receiver.clone()));\n                function_call_args.push(syn::Ident::new(\"self\", receiver.self_token.span()));\n            }\n            syn::FnArg::Typed(ty) => {\n                unsupported_if_some!(ty.attrs.first());\n\n                match &*ty.pat {\n                    syn::Pat::Ident(pat_ident) => {\n                        unsupported_if_some!(pat_ident.attrs.first());\n\n                        function_args_inner.push(arg.clone());\n                        function_args_outer.push(syn::FnArg::Typed(syn::PatType {\n                            attrs: Vec::new(),\n                            pat: Box::new(syn::Pat::Ident(syn::PatIdent {\n                                attrs: Vec::new(),\n                                by_ref: None,\n                                mutability: None,\n                                ident: pat_ident.ident.clone(),\n                                subpat: None,\n                            })),\n                            colon_token: ty.colon_token,\n                            ty: ty.ty.clone(),\n                        }));\n                        function_call_args.push(pat_ident.ident.clone());\n                    }\n                    syn::Pat::Wild(pat_wild) => {\n                        unsupported_if_some!(pat_wild.attrs.first());\n\n                        let ident = syn::Ident::new(\n                            &format!(\"__arg_{}__\", index),\n                            pat_wild.underscore_token.span(),\n                        );\n                        function_args_inner.push(arg.clone());\n                        function_args_outer.push(syn::FnArg::Typed(syn::PatType {\n                            attrs: Vec::new(),\n                            pat: Box::new(syn::Pat::Ident(syn::PatIdent {\n                                attrs: Vec::new(),\n                                by_ref: None,\n                                mutability: None,\n                                ident: ident.clone(),\n                                subpat: None,\n                            })),\n                            colon_token: ty.colon_token,\n                            ty: ty.ty.clone(),\n                        }));\n                        function_call_args.push(ident);\n                    }\n                    _ => unsupported!(arg),\n                }\n            }\n        }\n    }\n\n    let mut maybe_inline = quote::quote! {};\n    let mut maybe_outer_attributes = Vec::new();\n    let mut maybe_cfg = quote::quote! {};\n    for attribute in function.attrs {\n        match &attribute.meta {\n            syn::Meta::Path(path) if is_path_eq(path, \"inline\") => {\n                maybe_inline = quote::quote! { #[inline] };\n            }\n            syn::Meta::Path(path) if is_path_eq(path, \"test\") => {\n                maybe_outer_attributes.push(attribute);\n                maybe_cfg = quote::quote! { #[cfg(target_feature = #attributes)] };\n            }\n            syn::Meta::List(syn::MetaList { path, tokens, .. })\n                if is_path_eq(path, \"inline\") && tokens.to_string() == \"always\" =>\n            {\n                maybe_inline = quote::quote! { #[inline] };\n            }\n            syn::Meta::NameValue(syn::MetaNameValue { path, .. }) if is_path_eq(path, \"doc\") => {\n                maybe_outer_attributes.push(attribute);\n            }\n            syn::Meta::List(syn::MetaList { path, .. })\n                if is_path_eq(path, \"cfg\")\n                    || is_path_eq(path, \"allow\")\n                    || is_path_eq(path, \"deny\") =>\n            {\n                maybe_outer_attributes.push(attribute);\n            }\n            syn::Meta::Path(path) if is_path_eq(path, \"rustfmt::skip\") => {\n                maybe_outer_attributes.push(attribute);\n            }\n            _ => unsupported!(attribute),\n        }\n    }\n\n    let (fn_impl_generics, fn_ty_generics, fn_where_clause) =\n        function.sig.generics.split_for_impl();\n    let fn_call_generics = fn_ty_generics.as_turbofish();\n\n    if let Some((generics, self_ty)) = outer {\n        let (outer_impl_generics, outer_ty_generics, outer_where_clause) =\n            generics.split_for_impl();\n        let trait_ident =\n            syn::Ident::new(&format!(\"__Impl_{}__\", function_name), function_name.span());\n        let item_trait = quote::quote! {\n            #[allow(non_camel_case_types)]\n            trait #trait_ident #outer_impl_generics #outer_where_clause {\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause;\n            }\n        };\n\n        let item_trait_impl = quote::quote! {\n            impl #outer_impl_generics #trait_ident #outer_ty_generics for #self_ty #outer_where_clause {\n                #[target_feature(enable = #attributes)]\n                #maybe_inline\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_inner),*) #function_return #fn_where_clause #function_body\n            }\n        };\n\n        quote::quote! {\n            #[inline(always)]\n            #(#maybe_outer_attributes)*\n            #function_visibility fn #function_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause {\n                #item_trait\n                #item_trait_impl\n                unsafe {\n                    <Self as #trait_ident #outer_ty_generics> ::#function_inner_name #fn_call_generics (#(#function_call_args),*)\n                }\n            }\n        }.into()\n    } else {\n        quote::quote! {\n            #[inline(always)]\n            #maybe_cfg\n            #(#maybe_outer_attributes)*\n            #function_visibility fn #function_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause {\n                #[target_feature(enable = #attributes)]\n                #maybe_inline\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_inner),*) #function_return #fn_where_clause #function_body\n                unsafe {\n                    #function_inner_name #fn_call_generics (#(#function_call_args),*)\n                }\n            }\n        }.into()\n    }\n}",
    "display_name": "process_function",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "into",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "len",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/verify_batch_signatures",
    "statement_type": "function",
    "deps": [],
    "body": "    fn verify_batch_signatures(_: &mut Criterion) {}\n",
    "display_name": "verify_batch_signatures",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "ser/to_string",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_string",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_cast_then_mod_51",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/lemma2_to64_rest",
      "power2/arithmetic/pow2"
    ],
    "body": "pub proof fn lemma_cast_then_mod_51(x: u128)\n    ensures\n        (x as u64) % (pow2(51) as u64) == x % (pow2(51) as u128)\n{\n    lemma2_to64_rest(); // pow2(51 | 64)\n    assert( (x as u64) % 0x8000000000000 == x % 0x8000000000000) by (bit_vector);\n}",
    "display_name": "lemma_cast_then_mod_51",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "/// implications for many protocols.\n#[cfg(feature = \"static_secrets\")]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n#[derive(Clone)]\npub struct StaticSecret([u8; 32]);\n\n#[cfg(feature = \"static_secrets\")]\nimpl StaticSecret {\n    /// Perform a Diffie-Hellman key agreement between `self` and\n    /// `their_public` key to produce a `SharedSecret`.\n    pub fn diffie_hellman(&self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }\n\n    /// Generate a new [`StaticSecret`] with the supplied RNG.\n    pub fn random_from_rng<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {\n        // The secret key is random bytes. Clamping is done later.\n        let mut bytes = [0u8; 32];\n        csprng.fill_bytes(&mut bytes);\n        StaticSecret(bytes)\n    }\n\n    /// Generate a new [`StaticSecret`].\n    #[cfg(feature = \"os_rng\")]\n    pub fn random() -> Self {\n        Self::random_from_rng(&mut rand_core::OsRng.unwrap_mut())\n    }\n\n    /// Extract this key's bytes for serialization.\n    #[inline]\n    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// View this key as a byte array.\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n}",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u64x4/new",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_set_epi64x"
    ],
    "body": "    pub fn new(x0: u64, x1: u64, x2: u64, x3: u64) -> u64x4 {\n        unsafe {\n            // _mm256_set_epi64 sets the underlying vector in reverse order of the args\n            u64x4(core::arch::x86_64::_mm256_set_epi64x(\n                x3 as i64, x2 as i64, x1 as i64, x0 as i64,\n            ))\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_mult_two_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 scalar/Scalar/From/from"
    ],
    "body": "    fn basepoint_mult_two_vs_basepoint2() {\n        let two = Scalar::from(2u64);\n        let bp2 = EdwardsPoint::mul_base(&two);\n        assert_eq!(bp2.compress(), BASE2_CMPRSSD);\n    }",
    "display_name": "basepoint_mult_two_vs_basepoint2",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_slli_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_slli_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/reduce64",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 packed_simd/vector/backend/u64x4/shr",
      "5.0.0_pre.0 packed_simd/vector/backend/u64x4/splat",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/mul32",
      "5.0.0_pre.0 field/avx2/vector/backend/repack_pair",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/From/from",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    fn reduce64(mut z: [u64x4; 10]) -> FieldElement2625x4 {\n        // These aren't const because splat isn't a const fn\n        let LOW_25_BITS: u64x4 = u64x4::splat((1 << 25) - 1);\n        let LOW_26_BITS: u64x4 = u64x4::splat((1 << 26) - 1);\n\n        // Carry the value from limb i = 0..8 to limb i+1\n        let carry = |z: &mut [u64x4; 10], i: usize| {\n            debug_assert!(i < 9);\n            if i % 2 == 0 {\n                // Even limbs have 26 bits\n                z[i + 1] += z[i].shr::<26>();\n                z[i] &= LOW_26_BITS;\n            } else {\n                // Odd limbs have 25 bits\n                z[i + 1] += z[i].shr::<25>();\n                z[i] &= LOW_25_BITS;\n            }\n        };\n\n        // Perform two halves of the carry chain in parallel.\n        carry(&mut z, 0); carry(&mut z, 4);\n        carry(&mut z, 1); carry(&mut z, 5);\n        carry(&mut z, 2); carry(&mut z, 6);\n        carry(&mut z, 3); carry(&mut z, 7);\n        // Since z[3] < 2^64, c < 2^(64-25) = 2^39,\n        // so    z[4] < 2^26 + 2^39 < 2^39.0002\n        carry(&mut z, 4); carry(&mut z, 8);\n        // Now z[4] < 2^26\n        // and z[5] < 2^25 + 2^13.0002 < 2^25.0004 (good enough)\n\n        // Last carry has a multiplication by 19.  In the serial case we\n        // do a 64-bit multiplication by 19, but here we want to do a\n        // 32-bit multiplication.  However, if we only know z[9] < 2^64,\n        // the carry is bounded as c < 2^(64-25) = 2^39, which is too\n        // big.  To ensure c < 2^32, we would need z[9] < 2^57.\n        // Instead, we split the carry in two, with c = c_0 + c_1*2^26.\n\n        let c = z[9].shr::<25>();\n        z[9] &= LOW_25_BITS;\n        let mut c0: u64x4 = c & LOW_26_BITS; // c0 < 2^26;\n        let mut c1: u64x4 = c.shr::<26>();         // c1 < 2^(39-26) = 2^13;\n\n        let x19 = u64x4::splat(19);\n        c0 = u32x8::from(c0).mul32(u32x8::from(x19));\n        c1 = u32x8::from(c1).mul32(u32x8::from(x19));\n\n        z[0] += c0; // z0 < 2^26 + 2^30.25 < 2^30.33\n        z[1] += c1; // z1 < 2^25 + 2^17.25 < 2^25.0067\n        carry(&mut z, 0); // z0 < 2^26, z1 < 2^25.0067 + 2^4.33 = 2^25.007\n\n        // The output coefficients are bounded with\n        //\n        // b = 0.007  for z[1]\n        // b = 0.0004 for z[5]\n        // b = 0      for other z[i].\n        //\n        // So the packed result is bounded with b = 0.007.\n        FieldElement2625x4([\n            repack_pair(z[0].into(), z[1].into()),\n            repack_pair(z[2].into(), z[3].into()),\n            repack_pair(z[4].into(), z[5].into()),\n            repack_pair(z[6].into(), z[7].into()),\n            repack_pair(z[8].into(), z[9].into()),\n        ])\n    }",
    "display_name": "reduce64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/a_square2_vs_a_squared_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square2"
    ],
    "body": "    fn a_square2_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(a.square2(), &asq + &asq);\n    }",
    "display_name": "a_square2_vs_a_squared_constant",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 Conditional/Parse/parse",
    "statement_type": "function",
    "deps": [
      "parse/ParseBuffer/parse"
    ],
    "body": "    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        let lit = input.parse()?;\n        input.parse::<syn::Token![,]>()?;\n        let attr = input.parse()?;\n\n        Ok(Conditional { lit, attr })\n    }",
    "display_name": "parse",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoBasepointTable/create",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsBasepointTable/BasepointTable/create"
    ],
    "body": "    pub fn create(basepoint: &RistrettoPoint) -> RistrettoBasepointTable {\n        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }",
    "display_name": "create",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 test_function",
    "statement_type": "function",
    "deps": [
      "0.1.1 function_with_where_clause",
      "0.1.1 function_with_const_arg",
      "0.1.1 function",
      "0.1.1 StructWithGenerics/member_function",
      "0.1.1 StructWithGenericsNoWhere/member_function",
      "0.1.1 Struct/member_function"
    ],
    "body": "fn test_function() {\n    assert_eq!(function(10, 3), 7);\n    assert_eq!(function_with_where_clause(10, 3), 7);\n    assert_eq!(function_with_const_arg::<10>(3), 7);\n    assert_eq!(Struct { a: 10 }.member_function(3), 7);\n    assert_eq!(StructWithGenerics { a: 10 }.member_function(3), 7);\n    assert_eq!(StructWithGenericsNoWhere { a: 10 }.member_function(3), 7);\n    assert_eq!(inner_spec_sse2::spec_function(10, 3), 6);\n    assert_eq!(inner_spec_avx2::spec_function(10, 3), 5);\n}",
    "display_name": "test_function",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/NafLookupTable8/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/From/from",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/From/from",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/double",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/repudiation",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 vectors/pick_r",
      "3.0.0_pre.0 vectors/serialize_signature",
      "3.0.0_pre.0 verifying/VerifyingKey/Verifier/verify",
      "3.0.0_pre.0 verifying/VerifyingKey/verify_strict",
      "de/from_str",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 traits/IsIdentity/is_identity",
      "core https:/github.com/rust_lang/rust/library/core result/Result/is_ok",
      "ser/to_string",
      "de/from_str",
      "3.0.0_pre.0 vectors/compute_challenge",
      "serialized_size",
      "ser/to_string",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "3.0.0_pre.0 Signature/TryFrom/try_from",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "3.0.0_pre.0 verifying/VerifyingKey/from_bytes",
      "3.0.0_pre.0 verifying/VerifyingKey/is_weak",
      "deserialize",
      "serialize",
      "5.0.0_pre.0 edwards/EdwardsPoint/Neg/neg",
      "core https:/github.com/rust_lang/rust/library/core result/Result/is_err",
      "3.0.0_pre.0 vectors/non_null_scalar"
    ],
    "body": "    fn repudiation() {\n        let message1 = b\"Send 100 USD to Alice\";\n        let message2 = b\"Send 100000 USD to Alice\";\n\n        let mut s: Scalar = non_null_scalar();\n        let pubkey = WEAK_PUBKEY.decompress().unwrap();\n        let mut r = pick_r(s);\n\n        // Find an R such that\n        //     H(R || A || M)  A == A == H(R || A || M)  A\n        // This happens with high probability when A is low order.\n        while !(pubkey.neg() + compute_challenge(message1, &pubkey, &r, None) * pubkey)\n            .is_identity()\n            || !(pubkey.neg() + compute_challenge(message2, &pubkey, &r, None) * pubkey)\n                .is_identity()\n        {\n            // We pick an s and let R = sB - A where B is the basepoint\n            s = non_null_scalar();\n            r = pick_r(s);\n        }\n\n        // At this point, both verification equations hold:\n        //     sB = R + H(R || A || M)  A\n        //        = R + H(R || A || M)  A\n        // Check that this is true\n        let signature = serialize_signature(&r, &s);\n        let vk = VerifyingKey::from_bytes(pubkey.compress().as_bytes()).unwrap();\n        let sig = Signature::try_from(&signature[..]).unwrap();\n        assert!(vk.verify(message1, &sig).is_ok());\n        assert!(vk.verify(message2, &sig).is_ok());\n\n        // Check that this public key appears as weak\n        assert!(vk.is_weak());\n\n        // Now check that the sigs fail under verify_strict. This is because verify_strict rejects\n        // small order pubkeys.\n        assert!(vk.verify_strict(message1, &sig).is_err());\n        assert!(vk.verify_strict(message2, &sig).is_err());\n    }",
    "display_name": "repudiation",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/with_capacity",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "with_capacity",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "serialized_size",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "serialized_size",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signature/InternalSignature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signature/InternalSignature/from_bytes",
      "3.0.0_pre.0 Signature/to_bytes"
    ],
    "body": "        let compressed = CompressedEdwardsY(*bytes);\n        let point = compressed\n            .decompress()\n            .ok_or(InternalError::PointDecompression)?;\n\n        // Invariant: VerifyingKey.1 is always the decompression of VerifyingKey.0\n        Ok(VerifyingKey { compressed, point })\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/is_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/VartimePrecomputedStraus/is_empty"
    ],
    "body": "    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }",
    "display_name": "is_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsBasepointTable/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> Scalar {\n        -&self\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/montgomery_reduce_matches_from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order_wide",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_bytes_wide",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul_internal",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar/Scalar/unpack"
    ],
    "body": "    fn montgomery_reduce_matches_from_bytes_mod_order_wide() {\n        let mut bignum = [0u8; 64];\n\n        // set bignum = x + 2^256x\n        for i in 0..32 {\n            bignum[i] = X[i];\n            bignum[32 + i] = X[i];\n        }\n        // x + 2^256x (mod l)\n        //         = 3958878930004874126169954872055634648693766179881526445624823978500314864344\n        let expected = Scalar {\n            bytes: [\n                216, 154, 179, 139, 210, 121, 2, 71, 69, 99, 158, 216, 23, 173, 63, 100, 204, 0,\n                91, 50, 219, 153, 57, 249, 28, 82, 31, 197, 100, 165, 192, 8,\n            ],\n        };\n        let reduced = Scalar::from_bytes_mod_order_wide(&bignum);\n\n        // The reduced scalar should match the expected\n        assert_eq!(reduced.bytes, expected.bytes);\n\n        //  (x + 2^256x) * R\n        let interim =\n            UnpackedScalar::mul_internal(&UnpackedScalar::from_bytes_wide(&bignum), &constants::R);\n        // ((x + 2^256x) * R) / R  (mod l)\n        let montgomery_reduced = UnpackedScalar::montgomery_reduce(&interim);\n\n        // The Montgomery reduced scalar should match the reduced one, as well as the expected\n        assert_eq!(montgomery_reduced.limbs, reduced.unpack().limbs);\n        assert_eq!(montgomery_reduced.limbs, expected.unpack().limbs)\n    }",
    "display_name": "montgomery_reduce_matches_from_bytes_mod_order_wide",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bits/lemma_low_bits_mask_div2",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_low_bits_mask_div2",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u64x4/splat_const",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 packed_simd/vector/backend/u64x4/new_const"
    ],
    "body": "    pub const fn splat_const<const N: u64>() -> Self {\n        Self::new_const(N, N, N, N)\n    }",
    "display_name": "splat_const",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u32x8/mul32",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_mul_epu32"
    ],
    "body": "        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }",
    "display_name": "mul32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_cast_then_mask_51",
    "statement_type": "function",
    "deps": [],
    "body": "pub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & LOW_51_BIT_MASK]\n        (x as u64) & LOW_51_BIT_MASK == x & (LOW_51_BIT_MASK as u128)\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}",
    "display_name": "lemma_cast_then_mask_51",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/compress_batch",
    "statement_type": "function",
    "deps": [
      "thread/rngs/rng",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/take",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "core https:/github.com/rust_lang/rust/library/core repeat_with/sources/iter/repeat_with",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Extend/extend",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 edwards/EdwardsPoint/random",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress_batch",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn compress_batch() {\n        let mut rng = rand::rng();\n\n        // TODO(tarcieri): proptests?\n        // Make some points deterministically then randomly\n        let mut points = (1u64..16)\n            .map(|n| constants::ED25519_BASEPOINT_POINT * Scalar::from(n))\n            .collect::<Vec<_>>();\n        points.extend(core::iter::repeat_with(|| EdwardsPoint::random(&mut rng)).take(100));\n        let compressed = EdwardsPoint::compress_batch(&points);\n\n        // Check that the batch-compressed points match the individually compressed ones\n        for (point, compressed) in points.iter().zip(&compressed) {\n            assert_eq!(&point.compress(), compressed);\n        }\n    }",
    "display_name": "compress_batch",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/part1",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core num/wrapping_mul",
      "5.0.0_pre.0 scalar/u64/serial/backend/m"
    ],
    "body": "    fn part1(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n        let carry = (sum + m(p, constants::L.limbs[0])) >> 52;\n        (carry, p)\n    }",
    "display_name": "part1",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/seq_to_nat",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "pub open spec fn seq_to_nat(limbs: Seq<nat>) -> nat\ndecreases limbs.len()\n{\n    if limbs.len() == 0 {\n        0\n    } else {\n        limbs[0] + seq_to_nat(limbs.subrange(1, limbs.len() as int)) * pow2(52)\n    }\n}",
    "display_name": "seq_to_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "file_name": "scalar_specs.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "benchmark_group/BenchmarkId/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/Zeroize/zeroize"
    ],
    "body": "            fn visit_seq<A>(self, mut seq: A) -> Result<CompressedRistretto, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Ok(CompressedRistretto(bytes))\n            }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat"
    ],
    "body": "        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg_attr(docsrs, doc(cfg(curve25519_dalek_bits = \"64\")))]\n        type UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n    } else {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_scalar_subtract_no_overflow",
    "statement_type": "function",
    "deps": [],
    "body": "pub proof fn lemma_scalar_subtract_no_overflow(carry: u64, difference_limb: u64, addend: u64, i: u32, l_value: &Scalar52)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
    "display_name": "lemma_scalar_subtract_no_overflow",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "de/Error/custom",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "custom",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/bits_le",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/skip",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_bits_be"
    ],
    "body": "    fn mul(self, point: &MontgomeryPoint) -> MontgomeryPoint {\n        point * self\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/verify_strict",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress",
      "5.0.0_pre.0 edwards/EdwardsPoint/is_small_order",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "3.0.0_pre.0 errors/Error/From/from",
      "3.0.0_pre.0 signature/InternalSignature/TryFrom/try_from",
      "3.0.0_pre.0 verifying/RCompute/compute",
      "core https:/github.com/rust_lang/rust/library/core option/Option/ok_or_else"
    ],
    "body": "",
    "display_name": "verify_strict",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/insert",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "insert",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core builders/fmt/DebugStruct/finish_non_exhaustive",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "finish_non_exhaustive",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/batch_invert_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/batch_invert"
    ],
    "body": "    fn batch_invert_empty() {\n        FieldElement::batch_invert(&mut []);\n    }",
    "display_name": "batch_invert_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "/// If you're uncertain about whether you should use this, then you likely\n/// should not be using this.  Our strongly recommended advice is to use\n/// [`EphemeralSecret`] at all times, as that type enforces at compile-time that\n/// secret keys are never reused, which can have very serious security\n/// implications for many protocols.\n#[cfg(feature = \"reusable_secrets\")]\n#[derive(Clone)]\npub struct ReusableSecret(pub(crate) [u8; 32]);\n\n#[cfg(feature = \"reusable_secrets\")]\nimpl ReusableSecret {\n    /// Perform a Diffie-Hellman key agreement between `self` and\n    /// `their_public` key to produce a [`SharedSecret`].\n    pub fn diffie_hellman(&self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }\n\n    /// Generate a new [`ReusableSecret`] with the supplied RNG.\n    pub fn random_from_rng<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {\n        // The secret key is random bytes. Clamping is done later.\n        let mut bytes = [0u8; 32];\n        csprng.fill_bytes(&mut bytes);\n        ReusableSecret(bytes)\n    }\n\n    /// Generate a new [`ReusableSecret`].\n    #[cfg(feature = \"os_rng\")]\n    pub fn random() -> Self {\n        Self::random_from_rng(&mut rand_core::OsRng.unwrap_mut())\n    }\n}",
    "display_name": "mul_clamped",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc slice/join",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "join",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/RCompute/new",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "digest/Digest/update",
      "digest/Digest/new",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes"
    ],
    "body": "    pub(crate) fn new(\n        key: &VerifyingKey,\n        signature: InternalSignature,\n        prehash_ctx: Option<&[u8]>,\n    ) -> Self {\n        let R = &signature.R;\n        let A = &key.compressed;\n\n        let mut h = CtxDigest::new();\n        if let Some(c) = prehash_ctx {\n            h.update(b\"SigEd25519 no Ed25519 collisions\");\n            h.update([1]); // Ed25519ph\n            h.update([c.len() as u8]);\n            h.update(c);\n        }\n\n        h.update(R.as_bytes());\n        h.update(A.as_bytes());\n        Self {\n            key: *key,\n            signature,\n            h,\n        }\n    }",
    "display_name": "new",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "spanned/Spanned/span",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "span",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 DalekBits/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let w_bits = match self {\n            DalekBits::Dalek32 => \"32\",\n            DalekBits::Dalek64 => \"64\",\n        };\n        write!(f, \"{}\", w_bits)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/MultipartVerifier/multipart_verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/raw_verify"
    ],
    "body": "    /// Sign a message with this signing key's secret key.\n    fn try_sign(&self, message: &[u8]) -> Result<Signature, SignatureError> {\n        self.try_multipart_sign(&[message])\n    }",
    "display_name": "multipart_verify",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/impl_add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/From/from"
    ],
    "body": "    fn impl_add() {\n        let two = Scalar::from(2u64);\n        let one = Scalar::ONE;\n        let should_be_two = one + one;\n        assert_eq!(should_be_two, two);\n    }",
    "display_name": "impl_add",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_mult_one_vs_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_mult_one_vs_basepoint() {\n        let bp = ED25519_BASEPOINT_TABLE * &Scalar::ONE;\n        let compressed = bp.compress();\n        assert_eq!(compressed, constants::ED25519_BASEPOINT_COMPRESSED);\n    }",
    "display_name": "basepoint_mult_one_vs_basepoint",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/BasepointTable/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "//!   [`VartimeMultiscalarMul`](../traits/trait.VartimeMultiscalarMul.html)\n//!   trait for variable-time variable-base multiscalar multiplication;\n//!\n//! ## Implementation\n//!\n//! The Edwards arithmetic is implemented using the extended twisted\n//! coordinates of Hisil, Wong, Carter, and Dawson, and the\n//! corresponding complete formulas.  For more details,\n//! see the [`curve_models` submodule][curve_models]\n//! of the internal documentation.\n//!\n//! ## Validity Checking\n//!\n//! There is no function for checking whether a point is valid.\n//! Instead, the `EdwardsPoint` struct is guaranteed to hold a valid\n//! point on the curve.\n//!\n//! We use the Rust type system to make invalid points\n//! unrepresentable: `EdwardsPoint` objects can only be created via\n//! successful decompression of a compressed point, or else by\n//! operations on other (valid) `EdwardsPoint`s.\n//!\n//! [curve_models]: https://docs.rs/curve25519-dalek/latest/curve25519-dalek/backend/serial/curve_models/index.html\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nmod affine;\n\nuse cfg_if::cfg_if;\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_scalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat"
    ],
    "body": "spec fn to_scalar(limbs: &[u64; 5]) -> nat {\n    to_nat(limbs) % group_order()\n}",
    "display_name": "to_scalar",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "file_name": "scalar_specs.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "mul/arithmetic/lemma_mul_nonzero",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_nonzero",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/as_bytes"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedRistretto: {:?}\", self.as_bytes())\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 rand_core/static_from_rng",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/StaticSecret/random_from_rng",
      "TryRngCore/unwrap_err"
    ],
    "body": "    fn static_from_rng() {\n        StaticSecret::random_from_rng(&mut OsRng.unwrap_err());\n    }",
    "display_name": "static_from_rng",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/raw_sign_byupdate",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/ExpandedSecretKey/raw_sign_byupdate"
    ],
    "body": "pub fn raw_sign_byupdate<CtxDigest, F>(\n    esk: &ExpandedSecretKey,\n    msg_update: F,\n    verifying_key: &VerifyingKey,\n) -> Result<Signature, SignatureError>\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n    F: Fn(&mut CtxDigest) -> Result<(), SignatureError>,\n{\n    esk.raw_sign_byupdate::<CtxDigest, F>(msg_update, verifying_key)\n}",
    "display_name": "raw_sign_byupdate",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/double",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square2"
    ],
    "body": "",
    "display_name": "double",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }",
    "display_name": "index",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_set1_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_set1_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/all",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "all",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_div_denominator",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_div_denominator",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/to_keypair_bytes",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "3.0.0_pre.0 verifying/VerifyingKey/as_bytes"
    ],
    "body": "    pub fn to_keypair_bytes(&self) -> [u8; KEYPAIR_LENGTH] {\n        let mut bytes: [u8; KEYPAIR_LENGTH] = [0u8; KEYPAIR_LENGTH];\n\n        bytes[..SECRET_KEY_LENGTH].copy_from_slice(&self.secret_key);\n        bytes[SECRET_KEY_LENGTH..].copy_from_slice(self.verifying_key.as_bytes());\n        bytes\n    }",
    "display_name": "to_keypair_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_sub_epi64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_sub_epi64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/vartime_precomputed_helper",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 multiscalar_benches/construct_scalars",
      "5.0.0_pre.0 multiscalar_benches/construct_points",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "benchmark_group/BenchmarkGroup/bench_with_input",
      "benchmark_group/BenchmarkId/new",
      "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "bencher/Bencher/iter_batched"
    ],
    "body": "    fn vartime_precomputed_helper<M: Measurement>(\n        c: &mut BenchmarkGroup<M>,\n        dynamic_fraction: f64,\n    ) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            let bench_id = BenchmarkId::new(\n                \"Variable-time mixed-base\",\n                format!(\n                    \"(size: {:?}), ({:.0}pct dyn)\",\n                    multiscalar_size,\n                    100.0 * dynamic_fraction\n                ),\n            );\n\n            c.bench_with_input(bench_id, &multiscalar_size, move |b, &&total_size| {\n                let dynamic_size = ((total_size as f64) * dynamic_fraction) as usize;\n                let static_size = total_size - dynamic_size;\n\n                let static_points = construct_points(static_size);\n                let dynamic_points = construct_points(dynamic_size);\n                let precomp = VartimeEdwardsPrecomputation::new(static_points);\n                // Rerandomize the scalars for every call to prevent\n                // false timings from better caching (e.g., the CPU\n                // cache lifts exactly the right table entries for the\n                // benchmark into the highest cache levels).  Timings\n                // should be independent of points so we don't\n                // randomize them.\n                b.iter_batched(\n                    || {\n                        (\n                            construct_scalars(static_size),\n                            construct_scalars(dynamic_size),\n                        )\n                    },\n                    |(static_scalars, dynamic_scalars)| {\n                        precomp.vartime_mixed_multiscalar_mul(\n                            &static_scalars,\n                            &dynamic_scalars,\n                            &dynamic_points,\n                        )\n                    },\n                    BatchSize::SmallInput,\n                );\n            });\n        }\n    }",
    "display_name": "vartime_precomputed_helper",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_two_factoring",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/lemma_pow2_adds",
      "mul/arithmetic/lemma_mul_is_associative",
      "power2/arithmetic/pow2"
    ],
    "body": "    pow2( 8 * 8) * (limbs[ 8] as nat) +\n    pow2( 9 * 8) * (limbs[ 9] as nat) +\n    pow2(10 * 8) * (limbs[10] as nat) +\n    pow2(11 * 8) * (limbs[11] as nat) +\n    pow2(12 * 8) * (limbs[12] as nat) +\n    pow2(13 * 8) * (limbs[13] as nat) +\n    pow2(14 * 8) * (limbs[14] as nat) +\n    pow2(15 * 8) * (limbs[15] as nat) +\n    pow2(16 * 8) * (limbs[16] as nat) +\n    pow2(17 * 8) * (limbs[17] as nat) +\n    pow2(18 * 8) * (limbs[18] as nat) +\n    pow2(19 * 8) * (limbs[19] as nat) +\n    pow2(20 * 8) * (limbs[20] as nat) +\n    pow2(21 * 8) * (limbs[21] as nat) +\n    pow2(22 * 8) * (limbs[22] as nat) +\n    pow2(23 * 8) * (limbs[23] as nat) +\n    pow2(24 * 8) * (limbs[24] as nat) +\n    pow2(25 * 8) * (limbs[25] as nat) +\n    pow2(26 * 8) * (limbs[26] as nat) +\n    pow2(27 * 8) * (limbs[27] as nat) +\n    pow2(28 * 8) * (limbs[28] as nat) +\n    pow2(29 * 8) * (limbs[29] as nat) +\n    pow2(30 * 8) * (limbs[30] as nat) +\n    pow2(31 * 8) * (limbs[31] as nat)\n}\n\n// Lemma: If a > b pointwise, then as_nat(a - b) = as_nat(a) - as_nat(b)\npub proof fn lemma_as_nat_sub(a: [u64;5], b: [u64;5])\n    requires\n        forall |i:int| 0 <= i < 5 ==> b[i] < a[i]\n    ensures\n        as_nat([\n            (a[0] - b[0]) as u64,\n            (a[1] - b[1]) as u64,\n            (a[2] - b[2]) as u64,\n            (a[3] - b[3]) as u64,\n            (a[4] - b[4]) as u64\n        ]) == as_nat(a) - as_nat(b)\n{\n    let c: [u64;5] = [\n        (a[0] - b[0]) as u64,\n        (a[1] - b[1]) as u64,\n        (a[2] - b[2]) as u64,\n        (a[3] - b[3]) as u64,\n        (a[4] - b[4]) as u64\n    ];\n    // distribute pow2\n    assert( as_nat(c) ==\n        (a[0] - b[0]) +\n        pow2(51) * a[1] - pow2(51) * b[1] +\n        pow2(102) * a[2] - pow2(102) * b[2] +\n        pow2(153) * a[3] - pow2(153) * b[3] +\n        pow2(204) * a[4] - pow2(204) * b[4]\n    ) by {\n        broadcast use lemma_mul_is_distributive_sub;\n    }\n}",
    "display_name": "lemma_two_factoring",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/raw_sign",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/ExpandedSecretKey/raw_sign"
    ],
    "body": "pub fn raw_sign<CtxDigest>(\n    esk: &ExpandedSecretKey,\n    message: &[u8],\n    verifying_key: &VerifyingKey,\n) -> Signature\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    esk.raw_sign::<CtxDigest>(&[message], verifying_key)\n}",
    "display_name": "raw_sign",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "thread/rngs/ThreadRng/RngCore/fill_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "fill_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/is_small_order",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/IsIdentity/is_identity",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_cofactor"
    ],
    "body": "",
    "display_name": "is_small_order",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "    fn create(basepoint: &Self::Point) -> Self;\n\n    /// Retrieve the original basepoint from this table.\n    fn basepoint(&self) -> Self::Point;\n\n    /// Multiply a `scalar` by this precomputed basepoint table, in constant time.\n    fn mul_base(&self, scalar: &Scalar) -> Self::Point;\n\n    /// Multiply `clamp_integer(bytes)` by this precomputed basepoint table, in constant time. For\n    /// a description of clamping, see [`clamp_integer`].\n    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
    "display_name": "create",
    "full_path": "file:///work/3185/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar52/pack",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul",
      "5.0.0_pre.0 scalar/Scalar/unpack"
    ],
    "body": "    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc boxed/Box/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "core https:/github.com/rust_lang/rust/library/core array/TryFrom/try_from",
      "core https:/github.com/rust_lang/rust/library/core result/Result/map",
      "3.0.0_pre.0 signing/SigningKey/from_bytes",
      "core https:/github.com/rust_lang/rust/library/core result/Result/map_err"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<SigningKey, SignatureError> {\n        SecretKey::try_from(bytes)\n            .map(|bytes| Self::from_bytes(&bytes))\n            .map_err(|_| {\n                InternalError::BytesLength {\n                    name: \"SecretKey\",\n                    length: SECRET_KEY_LENGTH,\n                }\n                .into()\n            })\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 pippenger/scalar_mul/serial/backend/Pippenger/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/by_ref",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core map/adapters/iter/Map/Iterator/next",
      "core https:/github.com/rust_lang/rust/library/core map/adapters/iter/Map/Iterator/fold",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/cmp",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/size_hint",
      "5.0.0_pre.0 scalar/Scalar/to_radix_2w_size_hint",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "core https:/github.com/rust_lang/rust/library/core option/Option/expect"
    ],
    "body": "        cpufeatures::new!(cpuid_avx2, \"avx2\");\n        let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n        if token_avx2.get() {\n            return BackendKind::Avx2;\n        }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_mod_multiples_vanish",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mod_multiples_vanish",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/Sum/sum",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/fold",
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity"
    ],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, rhs: &FieldElement2625x4) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let (y0, y1) = unpack_pair(rhs.0[0]);\n        let (y2, y3) = unpack_pair(rhs.0[1]);\n        let (y4, y5) = unpack_pair(rhs.0[2]);\n        let (y6, y7) = unpack_pair(rhs.0[3]);\n        let (y8, y9) = unpack_pair(rhs.0[4]);\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let y1_19 = m_lo(v19, y1); // This fits in a u32\n        let y2_19 = m_lo(v19, y2); // iff 26 + b + lg(19) < 32\n        let y3_19 = m_lo(v19, y3); // if  b < 32 - 26 - 4.248 = 1.752\n        let y4_19 = m_lo(v19, y4);\n        let y5_19 = m_lo(v19, y5);\n        let y6_19 = m_lo(v19, y6);\n        let y7_19 = m_lo(v19, y7);\n        let y8_19 = m_lo(v19, y8);\n        let y9_19 = m_lo(v19, y9);\n\n        let x1_2 = x1 + x1; // This fits in a u32 iff 25 + b + 1 < 32\n        let x3_2 = x3 + x3; //                    iff b < 6\n        let x5_2 = x5 + x5;\n        let x7_2 = x7 + x7;\n        let x9_2 = x9 + x9;\n\n        let z0 = m(x0, y0) + m(x1_2, y9_19) + m(x2, y8_19) + m(x3_2, y7_19) + m(x4, y6_19) + m(x5_2, y5_19) + m(x6, y4_19) + m(x7_2, y3_19) + m(x8, y2_19) + m(x9_2, y1_19);\n        let z1 = m(x0, y1) + m(x1,      y0) + m(x2, y9_19) + m(x3,   y8_19) + m(x4, y7_19) + m(x5,   y6_19) + m(x6, y5_19) + m(x7,   y4_19) + m(x8, y3_19) + m(x9,   y2_19);\n        let z2 = m(x0, y2) + m(x1_2,    y1) + m(x2,    y0) + m(x3_2, y9_19) + m(x4, y8_19) + m(x5_2, y7_19) + m(x6, y6_19) + m(x7_2, y5_19) + m(x8, y4_19) + m(x9_2, y3_19);\n        let z3 = m(x0, y3) + m(x1,      y2) + m(x2,    y1) + m(x3,      y0) + m(x4, y9_19) + m(x5,   y8_19) + m(x6, y7_19) + m(x7,   y6_19) + m(x8, y5_19) + m(x9,   y4_19);\n        let z4 = m(x0, y4) + m(x1_2,    y3) + m(x2,    y2) + m(x3_2,    y1) + m(x4,    y0) + m(x5_2, y9_19) + m(x6, y8_19) + m(x7_2, y7_19) + m(x8, y6_19) + m(x9_2, y5_19);\n        let z5 = m(x0, y5) + m(x1,      y4) + m(x2,    y3) + m(x3,      y2) + m(x4,    y1) + m(x5,      y0) + m(x6, y9_19) + m(x7,   y8_19) + m(x8, y7_19) + m(x9,   y6_19);\n        let z6 = m(x0, y6) + m(x1_2,    y5) + m(x2,    y4) + m(x3_2,    y3) + m(x4,    y2) + m(x5_2,    y1) + m(x6,    y0) + m(x7_2, y9_19) + m(x8, y8_19) + m(x9_2, y7_19);\n        let z7 = m(x0, y7) + m(x1,      y6) + m(x2,    y5) + m(x3,      y4) + m(x4,    y3) + m(x5,      y2) + m(x6,    y1) + m(x7,      y0) + m(x8, y9_19) + m(x9,   y8_19);\n        let z8 = m(x0, y8) + m(x1_2,    y7) + m(x2,    y6) + m(x3_2,    y5) + m(x4,    y4) + m(x5_2,    y3) + m(x6,    y2) + m(x7_2,    y1) + m(x8,    y0) + m(x9_2, y9_19);\n        let z9 = m(x0, y9) + m(x1,      y8) + m(x2,    y7) + m(x3,      y6) + m(x4,    y5) + m(x5,      y4) + m(x6,    y3) + m(x7,      y2) + m(x8,    y1) + m(x9,      y0);\n\n        // The bounds on z[i] are the same as in the serial 32-bit code\n        // and the comment below is copied from there:\n\n        // How big is the contribution to z[i+j] from x[i], y[j]?\n        //\n        // Using the bounds above, we get:\n        //\n        // i even, j even:   x[i]*y[j] <   2^(26+b)*2^(26+b) = 2*2^(51+2*b)\n        // i  odd, j even:   x[i]*y[j] <   2^(25+b)*2^(26+b) = 1*2^(51+2*b)\n        // i even, j  odd:   x[i]*y[j] <   2^(26+b)*2^(25+b) = 1*2^(51+2*b)\n        // i  odd, j  odd: 2*x[i]*y[j] < 2*2^(25+b)*2^(25+b) = 1*2^(51+2*b)\n        //\n        // We perform inline reduction mod p by replacing 2^255 by 19\n        // (since 2^255 - 19 = 0 mod p).  This adds a factor of 19, so\n        // we get the bounds (z0 is the biggest one, but calculated for\n        // posterity here in case finer estimation is needed later):\n        //\n        //  z0 < ( 2 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 249*2^(51 + 2*b)\n        //  z1 < ( 1 +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 154*2^(51 + 2*b)\n        //  z2 < ( 2 +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 195*2^(51 + 2*b)\n        //  z3 < ( 1 +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 118*2^(51 + 2*b)\n        //  z4 < ( 2 +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 141*2^(51 + 2*b)\n        //  z5 < ( 1 +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) =  82*2^(51 + 2*b)\n        //  z6 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) =  87*2^(51 + 2*b)\n        //  z7 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 )*2^(51 + 2b) =  46*2^(51 + 2*b)\n        //  z8 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 )*2^(51 + 2b) =  33*2^(51 + 2*b)\n        //  z9 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   )*2^(51 + 2b) =  10*2^(51 + 2*b)\n        //\n        // So z[0] fits into a u64 if 51 + 2*b + lg(249) < 64\n        //                         if b < 2.5.\n\n        // In fact this bound is slightly sloppy, since it treats both\n        // inputs x and y as being bounded by the same parameter b,\n        // while they are in fact bounded by b_x and b_y, and we\n        // already require that b_y < 1.75 in order to fit the\n        // multiplications by 19 into a u32.  The tighter bound on b_y\n        // means we could get a tighter bound on the outputs, or a\n        // looser bound on b_x.\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_add_loop_bounds",
    "statement_type": "function",
    "deps": [],
    "body": "pub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
    "display_name": "lemma_add_loop_bounds",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/non_adjacent_form_random",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 test/scalar/non_adjacent_form_iter",
      "5.0.0_pre.0 scalar/Scalar/random",
      "thread/rngs/rng"
    ],
    "body": "    fn non_adjacent_form_random() {\n        let mut rng = rand::rng();\n        for _ in 0..1_000 {\n            let x = Scalar::random(&mut rng);\n            for w in &[5, 6, 7, 8] {\n                non_adjacent_form_iter(*w, &x);\n            }\n        }\n    }",
    "display_name": "non_adjacent_form_random",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "Vec/FromHex/from_hex",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_hex",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "clone/gen/ItemMod/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/spec_reduce",
    "statement_type": "function",
    "deps": [],
    "body": "pub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5]) {\n    let r = [\n        ((limbs[0] & LOW_51_BIT_MASK) + (limbs[4] >> 51) * 19) as u64,\n        ((limbs[1] & LOW_51_BIT_MASK) + (limbs[0] >> 51)) as u64,\n        ((limbs[2] & LOW_51_BIT_MASK) + (limbs[1] >> 51)) as u64,\n        ((limbs[3] & LOW_51_BIT_MASK) + (limbs[2] >> 51)) as u64,\n        ((limbs[4] & LOW_51_BIT_MASK) + (limbs[3] >> 51)) as u64,\n    ];\n    r\n}",
    "display_name": "spec_reduce",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/From/from",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "core https:/github.com/rust_lang/rust/library/core num/to_le_bytes"
    ],
    "body": "    fn from(x: u128) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/optional_mixed_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/VartimePrecomputedStraus/optional_mixed_multiscalar_mul"
    ],
    "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 vartime/test/edwards/double_scalar_mul_basepoint_vs_ed25519py",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsPoint/vartime_double_scalar_mul_basepoint",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap"
    ],
    "body": "        fn double_scalar_mul_basepoint_vs_ed25519py() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result =\n                EdwardsPoint::vartime_double_scalar_mul_basepoint(&A_SCALAR, &A, &B_SCALAR);\n            assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n        }",
    "display_name": "double_scalar_mul_basepoint_vs_ed25519py",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/impl_sum",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum"
    ],
    "body": "    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let two = Scalar::from(2u64);\n        let one_vector = [Scalar::ONE, Scalar::ONE];\n        let should_be_two: Scalar = one_vector.iter().sum();\n        assert_eq!(should_be_two, two);\n\n        // Test that sum works for the empty iterator\n        let zero = Scalar::ZERO;\n        let empty_vector = [];\n        let should_be_zero: Scalar = empty_vector.iter().sum();\n        assert_eq!(should_be_zero, zero);\n\n        // Test that sum works for owned types\n        let xs = [Scalar::from(1u64); 10];\n        let ys = [Scalar::from(2u64); 10];\n        // now zs is an iterator with Item = Scalar\n        let zs = xs.iter().zip(ys.iter()).map(|(x, y)| x + y);\n\n        let x_sum: Scalar = xs.iter().sum();\n        let y_sum: Scalar = ys.iter().sum();\n        let z_sum: Scalar = zs.sum();\n\n        assert_eq!(x_sum, Scalar::from(10u64));\n        assert_eq!(y_sum, Scalar::from(20u64));\n        assert_eq!(z_sum, Scalar::from(30u64));\n        assert_eq!(x_sum + y_sum, z_sum);\n    }",
    "display_name": "impl_sum",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_sub_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_sub_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/verify_strict",
    "statement_type": "function",
    "deps": [
      "thread/rngs/rng",
      "Criterion/bench_function",
      "bencher/Bencher/iter",
      "3.0.0_pre.0 signing/SigningKey/verify_strict",
      "3.0.0_pre.0 signing/SigningKey/generate",
      "signer/Signer/sign"
    ],
    "body": "    fn verify_strict(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n        let sig: Signature = keypair.sign(msg);\n\n        c.bench_function(\"Ed25519 strict signature verification\", move |b| {\n            b.iter(|| keypair.verify_strict(msg, &sig))\n        });\n    }",
    "display_name": "verify_strict",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "TryRngCore/unwrap_err",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "unwrap_err",
    "full_path": "file:///work/3185/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"AffineNielsPoint{{\\n\\ty_plus_x: {:?},\\n\\ty_minus_x: {:?},\\n\\txy2d: {:?}\\n}}\",\n            &self.y_plus_x, &self.y_minus_x, &self.xy2d\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "3.0.0_pre.0 byte_basepoint_matches_edwards_scalar_mul",
    "statement_type": "function",
    "deps": [
      "serialize",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base_clamped",
      "deserialize",
      "3.0.0_pre.0 x25519/x25519",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_bytes",
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery"
    ],
    "body": "fn byte_basepoint_matches_edwards_scalar_mul() {\n    let mut scalar_bytes = [0x37; 32];\n\n    for i in 0..32 {\n        scalar_bytes[i] += 2;\n\n        let result = x25519(scalar_bytes, X25519_BASEPOINT_BYTES);\n        let expected = EdwardsPoint::mul_base_clamped(scalar_bytes)\n            .to_montgomery()\n            .to_bytes();\n\n        assert_eq!(result, expected);\n    }\n}",
    "display_name": "byte_basepoint_matches_edwards_scalar_mul",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "lit/LitStr/span",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "span",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/montgomery_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_mul"
    ],
    "body": "    fn montgomery_mul() {\n        let res = Scalar52::montgomery_mul(&X, &Y);\n        for i in 0..5 {\n            assert!(res[i] == XY_MONT[i]);\n        }\n    }",
    "display_name": "montgomery_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 decompress/ristretto/step_1",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/as_bytes",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/FieldElement51/is_negative",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "ConstantTimeEq/ct_eq"
    ],
    "body": "    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.to_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }",
    "display_name": "step_1",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/four_torsion_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/RistrettoPoint/coset4"
    ],
    "body": "    fn four_torsion_basepoint() {\n        let bp = constants::RISTRETTO_BASEPOINT_POINT;\n        let bp_coset = bp.coset4();\n        for point in bp_coset {\n            assert_eq!(bp, RistrettoPoint(point));\n        }\n    }",
    "display_name": "four_torsion_basepoint",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/Index/index",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index(&self, _index: usize) -> &u64 {\n        &(self.limbs[_index])\n    }",
    "display_name": "index",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/from_limbs",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }",
    "display_name": "from_limbs",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 spec/precomputed_straus/scalar_mul/vector/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/optional",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/double",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Identity/identity",
      "5.0.0_pre.0 edwards/avx2/vector/backend/NafLookupTable5/From/from",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect"
    ],
    "body": "        fn optional_mixed_multiscalar_mul<I, J, K>(\n            &self,\n            static_scalars: I,\n            dynamic_scalars: J,\n            dynamic_points: K,\n        ) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator,\n            J::Item: Borrow<Scalar>,\n            K: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let static_nafs = static_scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect::<Vec<_>>();\n            let dynamic_nafs: Vec<_> = dynamic_scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect::<Vec<_>>();\n\n            let dynamic_lookup_tables = dynamic_points\n                .into_iter()\n                .map(|P_opt| P_opt.map(|P| NafLookupTable5::<CachedPoint>::from(&P)))\n                .collect::<Option<Vec<_>>>()?;\n\n            let sp = self.static_lookup_tables.len();\n            let dp = dynamic_lookup_tables.len();\n            assert!(sp >= static_nafs.len());\n            assert_eq!(dp, dynamic_nafs.len());\n\n            // We could save some doublings by looking for the highest\n            // nonzero NAF coefficient, but since we might have a lot of\n            // them to search, it's not clear it's worthwhile to check.\n            let mut R = ExtendedPoint::identity();\n            for j in (0..256).rev() {\n                R = R.double();\n\n                for i in 0..dp {\n                    let t_ij = dynamic_nafs[i][j];\n                    match t_ij.cmp(&0) {\n                        Ordering::Greater => {\n                            R = &R + &dynamic_lookup_tables[i].select(t_ij as usize);\n                        }\n                        Ordering::Less => {\n                            R = &R - &dynamic_lookup_tables[i].select(-t_ij as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..static_nafs.len() {\n                    let t_ij = static_nafs[i][j];\n                    match t_ij.cmp(&0) {\n                        Ordering::Greater => {\n                            R = &R + &self.static_lookup_tables[i].select(t_ij as usize);\n                        }\n                        Ordering::Less => {\n                            R = &R - &self.static_lookup_tables[i].select(-t_ij as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n            }\n\n            Some(R.into())\n        }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/non_adjacent_form_test_vector",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/non_adjacent_form"
    ],
    "body": "    fn non_adjacent_form_test_vector() {\n        let naf = A_SCALAR.non_adjacent_form(5);\n        for i in 0..256 {\n            assert_eq!(naf[i], A_NAF[i]);\n        }\n    }",
    "display_name": "non_adjacent_form_test_vector",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "power2/arithmetic/lemma_pow2_adds",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_pow2_adds",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/to_be_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_be_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_slli_epi64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_slli_epi64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/enumerate",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "enumerate",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/montgomery_square_max",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_square"
    ],
    "body": "    fn montgomery_square_max() {\n        let res = X.montgomery_square();\n        for i in 0..5 {\n            assert!(res[i] == XX_MONT[i]);\n        }\n    }",
    "display_name": "montgomery_square_max",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/shr_nonincreasing",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/shr_decomposition",
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_shr_le_u64"
    ],
    "body": "pub proof fn shr_nonincreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b <= 64\n    ensures\n        v >> b <= v >> a\n{\n    if (b == 64) {\n        assert(v >> 64 == 0) by (bit_vector);\n    }\n    else {\n        let d = (b - a) as u64;\n        // v >> b = (v >> (b - a)) >> a\n        shr_decomposition(v, d as nat, a);\n        assert(v >> d <= v) by (bit_vector);\n        // a <= b => a >> x <= b >> x\n        lemma_shr_le_u64(v >> d, v, a);\n    }\n}",
    "display_name": "shr_nonincreasing",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/to_edwards",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress",
      "5.0.0_pre.0 field/FieldElement51/invert"
    ],
    "body": "    use super::*;\n\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/test_scalar_clamp",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    fn test_scalar_clamp() {\n        let input = A_SCALAR.bytes;\n        let expected = [\n            0x18, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n            0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n            0x23, 0x76, 0xef, 0x49,\n        ];\n        let actual = clamp_integer(input);\n        assert_eq!(actual, expected);\n\n        let expected = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0x40,\n        ];\n        let actual = clamp_integer([0; 32]);\n        assert_eq!(expected, actual);\n        let expected = [\n            0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0x7f,\n        ];\n        let actual = clamp_integer([0xff; 32]);\n        assert_eq!(actual, expected);\n\n        assert_eq!(\n            LARGEST_CLAMPED_INTEGER,\n            clamp_integer(LARGEST_CLAMPED_INTEGER)\n        );\n    }",
    "display_name": "test_scalar_clamp",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "1.0.95 Ident/span",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "span",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 tests/affine/edwards/identity_conversion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 affine/edwards/AffinePoint/to_edwards",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "5.0.0_pre.0 affine/edwards/AffinePoint/Identity/identity"
    ],
    "body": "    fn identity_conversion() {\n        assert_eq!(\n            AffinePoint::identity().to_edwards(),\n            EdwardsPoint::identity()\n        );\n    }",
    "display_name": "identity_conversion",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/pow22501",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/pow2k"
    ],
    "body": "    fn pow22501(&self) -> (FieldElement, FieldElement) {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        let t0  = self.square();           // 1         e_0 = 2^1\n        let t1  = t0.square().square();    // 3         e_1 = 2^3\n        let t2  = self * &t1;              // 3,0       e_2 = 2^3 + 2^0\n        let t3  = &t0 * &t2;               // 3,1,0\n        let t4  = t3.square();             // 4,2,1\n        let t5  = &t2 * &t4;               // 4,3,2,1,0\n        let t6  = t5.pow2k(5);             // 9,8,7,6,5\n        let t7  = &t6 * &t5;               // 9,8,7,6,5,4,3,2,1,0\n        let t8  = t7.pow2k(10);            // 19..10\n        let t9  = &t8 * &t7;               // 19..0\n        let t10 = t9.pow2k(20);            // 39..20\n        let t11 = &t10 * &t9;              // 39..0\n        let t12 = t11.pow2k(10);           // 49..10\n        let t13 = &t12 * &t7;              // 49..0\n        let t14 = t13.pow2k(50);           // 99..50\n        let t15 = &t14 * &t13;             // 99..0\n        let t16 = t15.pow2k(100);          // 199..100\n        let t17 = &t16 * &t15;             // 199..0\n        let t18 = t17.pow2k(50);           // 249..50\n        let t19 = &t18 * &t13;             // 249..0\n\n        (t19, t3)\n    }",
    "display_name": "pow22501",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.11.0_rc.0 Sha512/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "power2/arithmetic/lemma2_to64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma2_to64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "Zeroizing/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/coset4",
    "statement_type": "function",
    "deps": [],
    "body": "    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
    "display_name": "coset4",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/ExpandedSecretKey/raw_sign_byupdate",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "3.0.0_pre.0 verifying/VerifyingKey/as_bytes",
      "digest/Digest/update",
      "digest/Digest/new",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 scalar/Scalar/from_hash",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "",
    "display_name": "raw_sign_byupdate",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/to_edwards",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_edwards(&self) -> EdwardsPoint {\n        self.point\n    }",
    "display_name": "to_edwards",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 rfc7748_ladder_test1_vectorset1",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 do_rfc7748_ladder_test1"
    ],
    "body": "fn rfc7748_ladder_test1_vectorset1() {\n    let input_scalar: [u8; 32] = [\n        0xa5, 0x46, 0xe3, 0x6b, 0xf0, 0x52, 0x7c, 0x9d, 0x3b, 0x16, 0x15, 0x4b, 0x82, 0x46, 0x5e,\n        0xdd, 0x62, 0x14, 0x4c, 0x0a, 0xc1, 0xfc, 0x5a, 0x18, 0x50, 0x6a, 0x22, 0x44, 0xba, 0x44,\n        0x9a, 0xc4,\n    ];\n    let input_point: [u8; 32] = [\n        0xe6, 0xdb, 0x68, 0x67, 0x58, 0x30, 0x30, 0xdb, 0x35, 0x94, 0xc1, 0xa4, 0x24, 0xb1, 0x5f,\n        0x7c, 0x72, 0x66, 0x24, 0xec, 0x26, 0xb3, 0x35, 0x3b, 0x10, 0xa9, 0x03, 0xa6, 0xd0, 0xab,\n        0x1c, 0x4c,\n    ];\n    let expected: [u8; 32] = [\n        0xc3, 0xda, 0x55, 0x37, 0x9d, 0xe9, 0xc6, 0x90, 0x8e, 0x94, 0xea, 0x4d, 0xf2, 0x8d, 0x08,\n        0x4f, 0x32, 0xec, 0xcf, 0x03, 0x49, 0x1c, 0x71, 0xf7, 0x54, 0xb4, 0x07, 0x55, 0x77, 0xa2,\n        0x85, 0x52,\n    ];\n\n    do_rfc7748_ladder_test1(input_scalar, input_point, expected);\n}",
    "display_name": "rfc7748_ladder_test1_vectorset1",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/Drop/drop",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        self.secret_key.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/invsqrt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/sqrt_ratio_i"
    ],
    "body": "    pub(crate) fn invsqrt(&self) -> (Choice, FieldElement) {\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }",
    "display_name": "invsqrt",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/from_bytes_highbit_is_ignored",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes"
    ],
    "body": "    fn from_bytes_highbit_is_ignored() {\n        let mut cleared_bytes = B_BYTES;\n        cleared_bytes[31] &= 127u8;\n        let with_highbit_set = FieldElement::from_bytes(&B_BYTES);\n        let without_highbit_set = FieldElement::from_bytes(&cleared_bytes);\n        assert_eq!(without_highbit_set, with_highbit_set);\n    }",
    "display_name": "from_bytes_highbit_is_ignored",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 affine/edwards/AffinePoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::ZERO,\n            y: FieldElement::ONE,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "deserialize",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "deserialize",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/CompressedEdwardsY/from_slice"
    ],
    "body": "    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_benches/batch_scalar_inversion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/batch_invert",
      "benchmark_group/BenchmarkId/new",
      "benchmark_group/BenchmarkGroup/bench_with_input",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 scalar/Scalar/random",
      "TryRngCore/unwrap_err",
      "bencher/Bencher/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Clone/clone"
    ],
    "body": "    fn batch_scalar_inversion<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in &BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch scalar inversion\", *batch_size),\n                &batch_size,\n                |b, &&size| {\n                    let mut rng = OsRng.unwrap_err();\n                    let scalars: Vec<Scalar> =\n                        (0..size).map(|_| Scalar::random(&mut rng)).collect();\n                    b.iter(|| {\n                        let mut s = scalars.clone();\n                        Scalar::batch_invert(&mut s);\n                    });\n                },\n            );\n        }\n    }",
    "display_name": "batch_scalar_inversion",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/skip",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "skip",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/to_affine",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/invert"
    ],
    "body": "    pub(crate) fn to_affine(self) -> AffinePoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        AffinePoint { x, y }\n    }",
    "display_name": "to_affine",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/ed25519_benches",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 ed25519_benches/verify",
      "3.0.0_pre.0 ed25519_benches/key_generation",
      "Criterion/Default/default",
      "3.0.0_pre.0 ed25519_benches/verify_strict",
      "3.0.0_pre.0 ed25519_benches/verify_batch_signatures",
      "3.0.0_pre.0 ed25519_benches/sign"
    ],
    "body": "        name = ed25519_benches;\n        config = Criterion::default();\n        targets =\n            sign,\n            verify,\n            verify_strict,\n            verify_batch_signatures,\n            key_generation,\n    }\n}\n\ncriterion::criterion_main!(ed25519_benches::ed25519_benches);",
    "display_name": "ed25519_benches",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 traits/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>;\n}\n\n/// A trait for variable-time multiscalar multiplication without precomputation.\npub trait VartimeMultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// `Option`s of points, compute either `Some(Q)`, where\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// if all points were `Some(P_i)`, or else return `None`.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    /// let abc = [a,b,c];\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    /// let PQR = [P, Q, R];\n    ///\n    /// let compressed = [P.compress(), Q.compress(), R.compress()];\n    ///\n    /// // Now we can compute A1 = a*P + b*Q + c*R using P, Q, R:\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &PQR);\n    ///\n    /// // Or using the compressed points:\n    /// let A2 = RistrettoPoint::optional_multiscalar_mul(\n    ///     &abc,\n    ///     compressed.iter().map(|pt| pt.decompress()),\n    /// );\n    ///\n    /// assert_eq!(A2, Some(A1));\n    ///\n    /// // It's also possible to mix compressed and uncompressed points:\n    /// let A3 = RistrettoPoint::optional_multiscalar_mul(\n    ///     abc.iter()\n    ///         .chain(abc.iter()),\n    ///     compressed.iter().map(|pt| pt.decompress())\n    ///         .chain(PQR.iter().map(|&pt| Some(pt))),\n    /// );\n    ///\n    /// assert_eq!(A3, Some(A1+A1));\n    /// # }\n    /// ```\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n}",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "thread/rngs/rng",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "rng",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectiveNielsPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.Y_plus_X.zeroize();\n        self.Y_minus_X.zeroize();\n        self.Z.zeroize();\n        self.T2d.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/eq_defined_mod_p",
    "statement_type": "function",
    "deps": [],
    "body": "    fn eq_defined_mod_p() {\n        let mut u18_bytes = [0u8; 32];\n        u18_bytes[0] = 18;\n        let u18 = MontgomeryPoint(u18_bytes);\n        let u18_unred = MontgomeryPoint([255; 32]);\n\n        assert_eq!(u18, u18_unred);\n    }",
    "display_name": "eq_defined_mod_p",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core rev/adapters/iter/Rev/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/partial_precomputed_mixed_multiscalar_empty",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/new",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 ristretto/RistrettoPoint/random",
      "5.0.0_pre.0 scalar/Scalar/random",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "thread/rngs/rng"
    ],
    "body": "    fn partial_precomputed_mixed_multiscalar_empty() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n        let n_dynamic = 8;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use zero scalars\n        let static_scalars = Vec::new();\n\n        let dynamic_points = (0..n_dynamic)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..n_dynamic)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n        for i in 0..n_dynamic {\n            result_manual += dynamic_points[i] * dynamic_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }",
    "display_name": "partial_precomputed_mixed_multiscalar_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core fmt/Formatter/debug_struct",
      "core https:/github.com/rust_lang/rust/library/core builders/fmt/DebugStruct/finish_non_exhaustive",
      "core https:/github.com/rust_lang/rust/library/core builders/fmt/DebugStruct/field"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"SigningKey\")\n            .field(\"verifying_key\", &self.verifying_key)\n            .finish_non_exhaustive() // avoids printing `secret_key`\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/ValidityCheck/is_valid",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square"
    ],
    "body": "    fn is_valid(&self) -> bool {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        let ZZZZ = ZZ.square();\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n\n        lhs == rhs\n    }",
    "display_name": "is_valid",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/split",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/extract"
    ],
    "body": "    pub fn split(&self) -> [FieldElement51; 4] {\n        let mut out = [FieldElement51::ZERO; 4];\n        for i in 0..5 {\n            let a_2i   = self.0[i].extract::<0>() as u64; //\n            let b_2i   = self.0[i].extract::<1>() as u64; //\n            let a_2i_1 = self.0[i].extract::<2>() as u64; // `.\n            let b_2i_1 = self.0[i].extract::<3>() as u64; //  | pre-swapped to avoid\n            let c_2i   = self.0[i].extract::<4>() as u64; //  | a cross lane shuffle\n            let d_2i   = self.0[i].extract::<5>() as u64; // .'\n            let c_2i_1 = self.0[i].extract::<6>() as u64; //\n            let d_2i_1 = self.0[i].extract::<7>() as u64; //\n\n            out[0].0[i] = a_2i + (a_2i_1 << 26);\n            out[1].0[i] = b_2i + (b_2i_1 << 26);\n            out[2].0[i] = c_2i + (c_2i_1 << 26);\n            out[3].0[i] = d_2i + (d_2i_1 << 26);\n        }\n\n        out\n    }",
    "display_name": "split",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/decompress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress",
      "bencher/Bencher/iter",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "benchmark_group/BenchmarkGroup/bench_function"
    ],
    "body": "    fn decompress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B_comp = &constants::ED25519_BASEPOINT_COMPRESSED;\n        c.bench_function(\"EdwardsPoint decompression\", move |b| {\n            b.iter(|| B_comp.decompress().unwrap())\n        });\n    }",
    "display_name": "decompress",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 cpuid_avx2/InitToken/get",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "get",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "1.0.95 TokenStream/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/batch_to_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery_batch",
      "thread/rngs/rng",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 scalar/Scalar/random",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery"
    ],
    "body": "    fn batch_to_montgomery() {\n        let mut rng = rand::rng();\n\n        let scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let points = scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let single_monts = points\n            .iter()\n            .map(EdwardsPoint::to_montgomery)\n            .collect::<Vec<_>>();\n\n        for i in [0, 1, 2, 3, 10, 50, 128] {\n            let invs = EdwardsPoint::to_montgomery_batch(&points[..i]);\n            assert_eq!(&invs, &single_monts[..i]);\n        }\n    }",
    "display_name": "batch_to_montgomery",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 errors/Error/From/from",
    "statement_type": "function",
    "deps": [
      "error/Error/new"
    ],
    "body": "    fn from(_err: InternalError) -> SignatureError {\n        SignatureError::new()\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/ed25519-dalek/src/errors.rs",
    "relative_path": "ed25519-dalek/src/errors.rs",
    "file_name": "errors.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/low_bits_masks_fit_u64",
    "statement_type": "function",
    "deps": [
      "bits/low_bits_mask",
      "5.0.0_pre.0 common_verus/u64/serial/backend/low_bits_mask_increases",
      "bits/lemma_low_bits_mask_values"
    ],
    "body": "pub proof fn low_bits_masks_fit_u64(k: nat)\n    requires\n        k <= 64\n    ensures\n        low_bits_mask(k) <= u64::MAX\n{\n    lemma_low_bits_mask_values(); // lbm(0) = 0, lbm(64) = 2^64\n    assert(low_bits_mask(64) <= u64::MAX) by (compute);\n    if (k < 64){\n        low_bits_mask_increases(k, 64);\n    }\n}",
    "display_name": "low_bits_masks_fit_u64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ExtendedPoint(FieldElement2625x4::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes",
      "ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &CompressedEdwardsY) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "1.0.95 TokenStream/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core intrinsics/transmute",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "transmute",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/compress_batch",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "TryRngCore/unwrap_err",
      "benchmark_group/BenchmarkGroup/bench_with_input",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "bencher/Bencher/iter",
      "benchmark_group/BenchmarkId/new",
      "5.0.0_pre.0 edwards/EdwardsPoint/random",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress_batch"
    ],
    "body": "    fn compress_batch<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch EdwardsPoint compression\", batch_size),\n                &batch_size,\n                |b, &size| {\n                    let mut rng = OsRng.unwrap_err();\n                    let points: Vec<EdwardsPoint> =\n                        (0..size).map(|_| EdwardsPoint::random(&mut rng)).collect();\n                    b.iter(|| EdwardsPoint::compress_batch(&points));\n                },\n            );\n        }\n    }",
    "display_name": "compress_batch",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/double",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/shuffle",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/square_and_negate_D",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/blend",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/negate_lazy"
    ],
    "body": "                    match naf[i].cmp(&0) {\n                        Ordering::Greater => {\n                            Q = &Q + &lookup_table.select(naf[i] as usize);\n                        }\n                        Ordering::Less => {\n                            Q = &Q - &lookup_table.select(-naf[i] as usize);\n                        }\n                        Ordering::Equal => {}\n                    }",
    "display_name": "double",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_mult_vs_ed25519py",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base"
    ],
    "body": "    fn basepoint_mult_vs_ed25519py() {\n        let aB = EdwardsPoint::mul_base(&A_SCALAR);\n        assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n    }",
    "display_name": "basepoint_mult_vs_ed25519py",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc string/String/len",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "len",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_to_x25519_dh",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/SharedSecret/to_bytes",
      "3.0.0_pre.0 signing/SigningKey/verifying_key",
      "3.0.0_pre.0 x25519/StaticSecret/diffie_hellman",
      "3.0.0_pre.0 x25519/PublicKey/From/from",
      "3.0.0_pre.0 signing/SigningKey/to_scalar",
      "3.0.0_pre.0 x25519/PublicKey/to_bytes",
      "3.0.0_pre.0 x25519/PublicKey/as_bytes",
      "3.0.0_pre.0 x25519/StaticSecret/From/from",
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/as_bytes",
      "digest/Digest/digest",
      "3.0.0_pre.0 signing/SigningKey/from_bytes",
      "3.0.0_pre.0 signing/SigningKey/to_scalar_bytes",
      "3.0.0_pre.0 verifying/VerifyingKey/to_montgomery",
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "fn ed25519_to_x25519_dh() {\n    // Keys from RFC8032 test vectors (from section 7.1)\n    let ed_secret_key_a = hex!(\"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60\");\n    let ed_secret_key_b = hex!(\"4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb\");\n\n    let ed_signing_key_a = SigningKey::from_bytes(&ed_secret_key_a);\n    let ed_signing_key_b = SigningKey::from_bytes(&ed_secret_key_b);\n\n    // Create an x25519 static secret from the ed25519 signing key\n    let scalar_bytes_a = ed_signing_key_a.to_scalar_bytes();\n    let scalar_bytes_b = ed_signing_key_b.to_scalar_bytes();\n    let x_static_secret_a = XStaticSecret::from(scalar_bytes_a);\n    let x_static_secret_b = XStaticSecret::from(scalar_bytes_b);\n\n    // Compute the secret scalars too\n    let scalar_a = ed_signing_key_a.to_scalar();\n    let scalar_b = ed_signing_key_b.to_scalar();\n\n    // Compare the scalar bytes to the first 32 bytes of SHA-512(secret_key). We have to clamp and\n    // reduce the SHA-512 output because that's what the spec does before using the scalars for\n    // anything.\n    assert_eq!(scalar_bytes_a, &Sha512::digest(ed_secret_key_a)[..32]);\n    assert_eq!(scalar_bytes_b, &Sha512::digest(ed_secret_key_b)[..32]);\n\n    // Compare the scalar with the clamped and reduced scalar bytes\n    assert_eq!(\n        scalar_a,\n        Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes_a))\n    );\n    assert_eq!(\n        scalar_b,\n        Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes_b))\n    );\n\n    let x_public_key_a = XPublicKey::from(&x_static_secret_a);\n    let x_public_key_b = XPublicKey::from(&x_static_secret_b);\n    assert_eq!(\n        x_public_key_a.to_bytes(),\n        hex!(\"d85e07ec22b0ad881537c2f44d662d1a143cf830c57aca4305d85c7a90f6b62e\")\n    );\n    assert_eq!(\n        x_public_key_b.to_bytes(),\n        hex!(\"25c704c594b88afc00a76b69d1ed2b984d7e22550f3ed0802d04fbcd07d38d47\")\n    );\n\n    // Test the claim made in the comments of SigningKey::to_scalar_bytes, i.e., that the resulting\n    // scalar is a valid private key for the x25519 pubkey represented by\n    // `sk.verifying_key().to_montgomery()`\n    assert_eq!(\n        ed_signing_key_a.verifying_key().to_montgomery().as_bytes(),\n        x_public_key_a.as_bytes()\n    );\n    assert_eq!(\n        ed_signing_key_b.verifying_key().to_montgomery().as_bytes(),\n        x_public_key_b.as_bytes()\n    );\n\n    // Check that Diffie-Hellman works\n    let expected_shared_secret =\n        hex!(\"5166f24a6918368e2af831a4affadd97af0ac326bdf143596c045967cc00230e\");\n    assert_eq!(\n        x_static_secret_a.diffie_hellman(&x_public_key_b).to_bytes(),\n        expected_shared_secret,\n    );\n    assert_eq!(\n        x_static_secret_b.diffie_hellman(&x_public_key_a).to_bytes(),\n        expected_shared_secret,\n    );\n}",
    "display_name": "ed25519_to_x25519_dh",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 affine/edwards/AffinePoint/compress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/FieldElement51/is_negative",
      "Choice/unwrap_u8"
    ],
    "body": "//! The Edwards arithmetic is implemented using the extended twisted\n//! coordinates of Hisil, Wong, Carter, and Dawson, and the\n//! corresponding complete formulas.  For more details,\n//! see the [`curve_models` submodule][curve_models]\n//! of the internal documentation.\n//!\n//! ## Validity Checking\n//!\n//! There is no function for checking whether a point is valid.\n//! Instead, the `EdwardsPoint` struct is guaranteed to hold a valid\n//! point on the curve.\n//!\n//! We use the Rust type system to make invalid points\n//! unrepresentable: `EdwardsPoint` objects can only be created via\n//! successful decompression of a compressed point, or else by\n//! operations on other (valid) `EdwardsPoint`s.\n//!\n//! [curve_models]: https://docs.rs/curve25519-dalek/latest/curve25519-dalek/backend/serial/curve_models/index.html\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nmod affine;\n\nuse cfg_if::cfg_if;\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
    "display_name": "compress",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/batch_invert_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/batch_invert"
    ],
    "body": "    fn batch_invert_empty() {\n        assert_eq!(Scalar::ONE, Scalar::batch_invert(&mut []));\n    }",
    "display_name": "batch_invert_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc boxed/Box/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [],
    "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Return the number of static points in the precomputation.\n    fn len(&self) -> usize;\n\n    /// Determine if the precomputation is empty.\n    fn is_empty(&self) -> bool;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\).\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/identity_in_different_models",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/Identity/identity",
      "serialize",
      "deserialize",
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity"
    ],
    "body": "    fn identity_in_different_models() {\n        assert!(EdwardsPoint::identity().to_montgomery() == MontgomeryPoint::identity());\n    }",
    "display_name": "identity_in_different_models",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/len",
    "statement_type": "function",
    "deps": [
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len"
    ],
    "body": "    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    Avx512,\n    Serial,\n}\n\n#[inline]\nfn get_selected_backend() -> BackendKind {\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    {\n        cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n        let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n        if token_avx512.get() {\n            return BackendKind::Avx512;\n        }\n    }\n\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    {\n        cpufeatures::new!(cpuid_avx2, \"avx2\");\n        let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n        if token_avx2.get() {\n            return BackendKind::Avx2;\n        }\n    }\n\n    BackendKind::Serial\n}",
    "display_name": "len",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/a_invert_vs_inverse_of_a_constant",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 field/FieldElement51/invert"
    ],
    "body": "    fn a_invert_vs_inverse_of_a_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        let should_be_inverse = a.invert();\n        assert_eq!(ainv, should_be_inverse);\n        assert_eq!(FieldElement::ONE, &a * &should_be_inverse);\n    }",
    "display_name": "a_invert_vs_inverse_of_a_constant",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/m",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/mul_le"
    ],
    "body": "fn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX\n\n{\n    proof {\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}",
    "display_name": "m",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_mul_mod_noop",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_mod_noop",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/filter",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "filter",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 function_with_const_arg",
    "statement_type": "function",
    "deps": [],
    "body": "fn function_with_const_arg<const N: u32>(b: u32) -> u32 {\n    N - b\n}",
    "display_name": "function_with_const_arg",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert( x * y < x * (1u128 << 52)  );\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }",
    "display_name": "five_limbs_to_nat_aux",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 tests/affine/edwards/generator_round_trip",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/to_affine",
      "5.0.0_pre.0 affine/edwards/AffinePoint/to_edwards"
    ],
    "body": "    fn generator_round_trip() {\n        let basepoint = constants::ED25519_BASEPOINT_POINT;\n        assert_eq!(basepoint.to_affine().to_edwards(), basepoint);\n    }",
    "display_name": "generator_round_trip",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_as_nat_sub",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2",
      "mul/arithmetic/lemma_mul_is_distributive_sub",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat"
    ],
    "body": "pub proof fn lemma_as_nat_sub(a: [u64;5], b: [u64;5])\n    requires\n        forall |i:int| 0 <= i < 5 ==> b[i] < a[i]\n    ensures\n        as_nat([\n            (a[0] - b[0]) as u64,\n            (a[1] - b[1]) as u64,\n            (a[2] - b[2]) as u64,\n            (a[3] - b[3]) as u64,\n            (a[4] - b[4]) as u64\n        ]) == as_nat(a) - as_nat(b)\n{\n    let c: [u64;5] = [\n        (a[0] - b[0]) as u64,\n        (a[1] - b[1]) as u64,\n        (a[2] - b[2]) as u64,\n        (a[3] - b[3]) as u64,\n        (a[4] - b[4]) as u64\n    ];\n    // distribute pow2\n    assert( as_nat(c) ==\n        (a[0] - b[0]) +\n        pow2(51) * a[1] - pow2(51) * b[1] +\n        pow2(102) * a[2] - pow2(102) * b[2] +\n        pow2(153) * a[3] - pow2(153) * b[3] +\n        pow2(204) * a[4] - pow2(204) * b[4]\n    ) by {\n        broadcast use lemma_mul_is_distributive_sub;\n    }\n}",
    "display_name": "lemma_as_nat_sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/identity_in_different_coordinates",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 montgomery/ProjectivePoint/as_affine",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/Identity/identity"
    ],
    "body": "    fn identity_in_different_coordinates() {\n        let id_projective = ProjectivePoint::identity();\n        let id_montgomery = id_projective.as_affine();\n\n        assert!(id_montgomery == MontgomeryPoint::identity());\n    }",
    "display_name": "identity_in_different_coordinates",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/as_bytes",
      "ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "unwrap",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/to_scalar",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/ExpandedSecretKey/From/from"
    ],
    "body": "",
    "display_name": "to_scalar",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 Signature/TryFrom/try_from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "try_from",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/hash_to_field",
    "statement_type": "function",
    "deps": [
      "decode",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "core https:/github.com/rust_lang/rust/library/core slice/reverse",
      "5.0.0_pre.0 field/FieldElement51/hash_to_field",
      "core https:/github.com/rust_lang/rust/library/core str/as_bytes",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes"
    ],
    "body": "    fn hash_to_field() {\n        use sha2::Sha512;\n        let dst = \"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n\n        for (msg, expected_hash_hex) in RFC_HASH_TO_FIELD_KAT {\n            let fe = FieldElement::hash_to_field::<Sha512>(&[msg], &[dst.as_bytes()]);\n            let expected_fe = {\n                let mut expected_hash = hex::decode(expected_hash_hex).unwrap();\n                expected_hash.reverse();\n                FieldElement::from_bytes(&expected_hash.try_into().unwrap())\n            };\n\n            assert_eq!(fe, expected_fe);\n        }\n    }",
    "display_name": "hash_to_field",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/verify",
    "statement_type": "function",
    "deps": [
      "bencher/Bencher/iter",
      "3.0.0_pre.0 signing/SigningKey/generate",
      "signer/Signer/sign",
      "Criterion/bench_function",
      "3.0.0_pre.0 signing/SigningKey/verify",
      "thread/rngs/rng"
    ],
    "body": "    fn verify(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n        let sig: Signature = keypair.sign(msg);\n\n        c.bench_function(\"Ed25519 signature verification\", move |b| {\n            b.iter(|| keypair.verify(msg, &sig))\n        });\n    }",
    "display_name": "verify",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 test/spec/pippenger/scalar_mul/vector/backend/test_vartime_pippenger",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "alloc https:/github.com/rust_lang/rust/library/alloc slice/to_vec",
      "5.0.0_pre.0 scalar/Scalar/invert",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Clone/clone",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip"
    ],
    "body": "        fn test_vartime_pippenger() {\n            use super::*;\n            use crate::constants;\n            use crate::scalar::Scalar;\n\n            // Reuse points across different tests\n            let mut n = 512;\n            let x = Scalar::from(2128506u64).invert();\n            let y = Scalar::from(4443282u64).invert();\n            let points: Vec<_> = (0..n)\n                .map(|i| constants::ED25519_BASEPOINT_POINT * Scalar::from(1 + i as u64))\n                .collect();\n            let scalars: Vec<_> = (0..n)\n                .map(|i| x + (Scalar::from(i as u64) * y)) // fast way to make ~random but deterministic scalars\n                .collect();\n\n            let premultiplied: Vec<EdwardsPoint> = scalars\n                .iter()\n                .zip(points.iter())\n                .map(|(sc, pt)| sc * pt)\n                .collect();\n\n            while n > 0 {\n                let scalars = &scalars[0..n].to_vec();\n                let points = &points[0..n].to_vec();\n                let control: EdwardsPoint = premultiplied[0..n].iter().sum();\n\n                let subject = Pippenger::vartime_multiscalar_mul(scalars.clone(), points.clone());\n\n                assert_eq!(subject.compress(), control.compress());\n\n                n = n / 2;\n            }\n        }",
    "display_name": "test_vartime_pippenger",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/is_subset",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_subset",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/words_to_nat_gen_u32",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "pub open spec fn words_to_nat_gen_u32(words: &[u32], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u32(words, num_words - 1, bits_per_word)\n    }\n}",
    "display_name": "words_to_nat_gen_u32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "file_name": "scalar_specs.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "digest/Digest/update",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "update",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "de/from_str",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_str",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "Criterion/bench_function",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "bench_function",
    "full_path": "file:///work/3185/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsBasepointTable/BasepointTable/basepoint",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "basepoint",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/reduce",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_mul_epu32",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/splat",
      "5.0.0_pre.0 packed_simd/vector/backend/u64x4/splat",
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_shuffle_epi32",
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_srlv_epi32",
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_blend_epi32",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/new",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    pub fn reduce(&self) -> FieldElement2625x4 {\n        let shifts = u32x8::new(26, 26, 25, 25, 26, 26, 25, 25);\n        let masks = u32x8::new(\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n        );\n\n        // Let c(x) denote the carryout of the coefficient x.\n        //\n        // Given    (   x0,    y0,    x1,    y1,    z0,    w0,    z1,    w1),\n        // compute  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0)).\n        //\n        // The carryouts are bounded by 2^(32 - 25) = 2^7.\n        let rotated_carryout = |v: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_shuffle_epi32;\n                use core::arch::x86_64::_mm256_srlv_epi32;\n\n                let c = _mm256_srlv_epi32(v.into(), shifts.into());\n                _mm256_shuffle_epi32(c, 0b01_00_11_10).into()\n            }\n        };\n\n        // Combine (lo, lo, lo, lo, lo, lo, lo, lo)\n        //    with (hi, hi, hi, hi, hi, hi, hi, hi)\n        //      to (lo, lo, hi, hi, lo, lo, hi, hi)\n        //\n        // This allows combining carryouts, e.g.,\n        //\n        // lo  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0))\n        // hi  (c(x3), c(y3), c(x2), c(y2), c(z3), c(w3), c(z2), c(w2))\n        // ->  (c(x1), c(y1), c(x2), c(y2), c(z1), c(w1), c(z2), c(w2))\n        //\n        // which is exactly the vector of carryins for\n        //\n        //     (   x2,    y2,    x3,    y3,    z2,    w2,    z3,    w3).\n        //\n        let combine = |v_lo: u32x8, v_hi: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(v_lo.into(), v_hi.into(), 0b11_00_11_00).into()\n            }\n        };\n\n        let mut v = self.0;\n\n        let c10 = rotated_carryout(v[0]);\n        v[0] = (v[0] & masks) + combine(u32x8::splat(0), c10);\n\n        let c32 = rotated_carryout(v[1]);\n        v[1] = (v[1] & masks) + combine(c10, c32);\n\n        let c54 = rotated_carryout(v[2]);\n        v[2] = (v[2] & masks) + combine(c32, c54);\n\n        let c76 = rotated_carryout(v[3]);\n        v[3] = (v[3] & masks) + combine(c54, c76);\n\n        let c98 = rotated_carryout(v[4]);\n        v[4] = (v[4] & masks) + combine(c76, c98);\n\n        let c9_19: u32x8 = unsafe {\n            use core::arch::x86_64::_mm256_mul_epu32;\n            use core::arch::x86_64::_mm256_shuffle_epi32;\n\n            // Need to rearrange c98, since vpmuludq uses the low\n            // 32-bits of each 64-bit lane to compute the product:\n            //\n            // c98       = (c(x9), c(y9), c(x8), c(y8), c(z9), c(w9), c(z8), c(w8));\n            // c9_spread = (c(x9), c(x8), c(y9), c(y8), c(z9), c(z8), c(w9), c(w8)).\n            let c9_spread = _mm256_shuffle_epi32(c98.into(), 0b11_01_10_00);\n\n            // Since the carryouts are bounded by 2^7, their products with 19\n            // are bounded by 2^11.25.  This means that\n            //\n            // c9_19_spread = (19*c(x9), 0, 19*c(y9), 0, 19*c(z9), 0, 19*c(w9), 0).\n            let c9_19_spread = _mm256_mul_epu32(c9_spread, u64x4::splat(19).into());\n\n            // Unshuffle:\n            // c9_19 = (19*c(x9), 19*c(y9), 0, 0, 19*c(z9), 19*c(w9), 0, 0).\n            _mm256_shuffle_epi32(c9_19_spread, 0b11_01_10_00).into()\n        };\n\n        // Add the final carryin.\n        v[0] += c9_19;\n\n        // Each output coefficient has exactly one carryin, which is\n        // bounded by 2^11.25, so they are bounded as\n        //\n        // c_even < 2^26 + 2^11.25 < 26.00006 < 2^{26+b}\n        // c_odd  < 2^25 + 2^11.25 < 25.0001  < 2^{25+b}\n        //\n        // where b = 0.0002.\n        FieldElement2625x4(v)\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_plus_basepoint_projective_niels_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective_niels",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended"
    ],
    "body": "    fn basepoint_plus_basepoint_projective_niels_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_added = (&bp + &bp.as_projective_niels()).as_extended();\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }",
    "display_name": "basepoint_plus_basepoint_projective_niels_vs_basepoint2",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/constants/test_four_torsion",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/filter",
      "5.0.0_pre.0 edwards/EdwardsPoint/ValidityCheck/is_valid",
      "5.0.0_pre.0 traits/IsIdentity/is_identity",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2"
    ],
    "body": "    fn test_four_torsion() {\n        for i in (0..8).filter(|i| i % 2 == 0) {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(2);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }",
    "display_name": "test_four_torsion",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery_batch",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/batch_invert",
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/push",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/with_capacity"
    ],
    "body": "    pub fn to_montgomery_batch(eds: &[Self]) -> Vec<MontgomeryPoint> {\n        // Do the same thing as the above function. u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        // We will do this in a batch, ie compute (Z-Y) for all the input\n        // points, then invert them all at once\n\n        // Compute the denominators in a batch\n        let mut denominators = eds.iter().map(|p| &p.Z - &p.Y).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut denominators);\n\n        // Now compute the Montgomery u coordinate for every point\n        let mut ret = Vec::with_capacity(eds.len());\n        for (ed, d) in eds.iter().zip(denominators.iter()) {\n            let u = &(&ed.Z + &ed.Y) * d;\n            ret.push(MontgomeryPoint(u.to_bytes()));\n        }\n\n        ret\n    }",
    "display_name": "to_montgomery_batch",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/scalar_mul_by_one",
    "statement_type": "function",
    "deps": [],
    "body": "    fn scalar_mul_by_one() {\n        let test_scalar = X * Scalar::ONE;\n        for i in 0..32 {\n            assert!(test_scalar[i] == X[i]);\n        }\n    }",
    "display_name": "scalar_mul_by_one",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/negate",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "div_mod/arithmetic/lemma_mod_multiples_vanish",
      "power2/arithmetic/lemma_pow2_adds",
      "mul/arithmetic/lemma_mul_is_distributive_sub",
      "power2/arithmetic/pow2",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_as_nat_sub",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/p",
      "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/reduce",
      "power2/arithmetic/lemma2_to64_rest"
    ],
    "body": "    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, as_nat((c0, c, c, c, c)) = p, so\n            // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n            // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            as_nat(self.limbs) == 16 * p() - as_nat(old(self).limbs) - p() * ((36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n            (as_nat(self.limbs) + as_nat(old(self).limbs)) % p() == 0\n    {\n        proof {\n            let c0 = (pow2(51) - 19);\n            let c  = (pow2(51) - 1);\n            lemma2_to64_rest(); // get pow2(51)\n            // solver knows 36028797018963664u64 == 16 * c0\n            // solver knows 36028797018963952u64 == 16 * c;\n\n            assert forall |i: int| 0 <= i < 5 implies old(self).limbs[i] < 16 * c0 by {\n                shift_is_pow2(51);\n            }\n\n            // Introduce 16p as a vector\n            let v = [(16 * c0) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64];\n\n            assert(as_nat(v) == 16 * p()) by {\n                // by definition of as_nat\n                assert( as_nat(v) ==\n                    16 * c0 +\n                    pow2(51) * (16 * c) +\n                    pow2(102) * (16 * c) +\n                    pow2(153) * (16 * c) +\n                    pow2(204) * (16 * c)\n                );\n\n                // solver can reorder factors and pull out 16 on its own\n                // ...\n\n                // Write out `c`s and sum up powers\n                assert( p() ==\n                    c0 +\n                    pow2(51) * c +\n                    pow2(102) * c +\n                    pow2(153) * c +\n                    pow2(204) * c\n                ) by {\n                    lemma_pow2_adds(51, 51);\n                    lemma_pow2_adds(51, 102);\n                    lemma_pow2_adds(51, 153);\n                    lemma_pow2_adds(51, 204);\n                }\n            }\n\n            let l0 = old(self).limbs[0];\n            let l1 = old(self).limbs[1];\n            let l2 = old(self).limbs[2];\n            let l3 = old(self).limbs[3];\n            let l4 = old(self).limbs[4];\n\n            assert(as_nat([\n                (16 * c0 - l0) as u64,\n                (16 * c - l1) as u64,\n                (16 * c - l2) as u64,\n                (16 * c - l3) as u64,\n                (16 * c - l4) as u64,\n                ]) == as_nat(v) - as_nat(old(self).limbs)\n            ) by {\n                lemma_as_nat_sub(v, old(self).limbs);\n            }\n        }\n        // See commentary in the Sub impl: (copied below)\n            // To avoid underflow, first add a multiple of p.\n            // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n            //\n            // If we could statically track the bitlengths of the limbs\n            // of every FieldElement51, we could choose a multiple of p\n            // just bigger than _rhs and avoid having to do a reduction.\n            //\n            // Since we don't yet have type-level integers to do this, we\n            // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.limbs[0],\n            36028797018963952u64 - self.limbs[1],\n            36028797018963952u64 - self.limbs[2],\n            36028797018963952u64 - self.limbs[3],\n            36028797018963952u64 - self.limbs[4],\n        ]);\n        proof {\n            let k = ((36028797018963952u64 - old(self).limbs[4]) as u64 >> 51) as nat;\n            broadcast use lemma_mul_is_distributive_sub;\n            lemma_mod_multiples_vanish((16 - k) as int, 0 as int, p() as int);\n        }\n        self.limbs = neg.limbs;\n    }",
    "display_name": "negate",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/basepoint_roundtrip",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/decompress",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/Identity/identity",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap"
    ],
    "body": "    fn basepoint_roundtrip() {\n        let bp_compressed_ristretto = constants::RISTRETTO_BASEPOINT_POINT.compress();\n        let bp_recaf = bp_compressed_ristretto.decompress().unwrap().0;\n        // Check that bp_recaf differs from bp by a point of order 4\n        let diff = constants::RISTRETTO_BASEPOINT_POINT.0 - bp_recaf;\n        let diff4 = diff.mul_by_pow_2(2);\n        assert_eq!(diff4.compress(), CompressedEdwardsY::identity());\n    }",
    "display_name": "basepoint_roundtrip",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/get_selected_backend",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 cpuid_avx2/init",
      "5.0.0_pre.0 cpuid_avx2/InitToken/get"
    ],
    "body": "fn get_selected_backend() -> BackendKind {\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    {\n        cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n        let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n        if token_avx512.get() {\n            return BackendKind::Avx512;\n        }\n    }\n\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    {\n        cpufeatures::new!(cpuid_avx2, \"avx2\");\n        let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n        if token_avx2.get() {\n            return BackendKind::Avx2;\n        }\n    }\n\n    BackendKind::Serial\n}",
    "display_name": "get_selected_backend",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/FromIterator/from_iter",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_iter",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/shr_zero_is_id",
    "statement_type": "function",
    "deps": [],
    "body": "pub broadcast proof fn shr_zero_is_id(v: u64)\n    ensures\n        #![trigger v >> 0]\n        v >> 0 == v\n{\n    assert(v >> 0 == v) by (bit_vector);\n}",
    "display_name": "shr_zero_is_id",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/decompress_negative_s_fails",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "5.0.0_pre.0 ristretto/CompressedRistretto/decompress",
      "core https:/github.com/rust_lang/rust/library/core option/Option/is_none"
    ],
    "body": "    fn decompress_negative_s_fails() {\n        // constants::d is neg, so decompression should fail as |d| != d.\n        let bad_compressed = CompressedRistretto(constants::EDWARDS_D.to_bytes());\n        assert!(bad_compressed.decompress().is_none());\n    }",
    "display_name": "decompress_negative_s_fails",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "Array/as_slice",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_slice",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_l_value_properties",
    "statement_type": "function",
    "deps": [],
    "body": "pub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}",
    "display_name": "lemma_l_value_properties",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_limbs",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51(limbs)\n    }",
    "display_name": "from_limbs",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/elligator_hash_to_curve_test_vectors",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "decode",
      "core https:/github.com/rust_lang/rust/library/core slice/reverse",
      "5.0.0_pre.0 edwards/EdwardsPoint/hash_to_curve",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/enumerate",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap"
    ],
    "body": "    fn elligator_hash_to_curve_test_vectors() {\n        let dst = b\"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n        for (index, vector) in RFC_HASH_TO_CURVE_KAT.iter().enumerate() {\n            let input = vector.0;\n\n            let expected_output = {\n                let mut x_bytes = hex::decode(vector.1).unwrap();\n                x_bytes.reverse();\n                let x = FieldElement::from_bytes(&x_bytes.try_into().unwrap());\n\n                let mut y_bytes = hex::decode(vector.2).unwrap();\n                y_bytes.reverse();\n                let y = FieldElement::from_bytes(&y_bytes.try_into().unwrap());\n\n                EdwardsPoint {\n                    X: x,\n                    Y: y,\n                    Z: FieldElement::ONE,\n                    T: &x * &y,\n                }\n            };\n\n            let computed = EdwardsPoint::hash_to_curve::<sha2::Sha512>(&[&input], &[dst]);\n            assert_eq!(computed, expected_output, \"Failed in test {}\", index);\n        }\n    }",
    "display_name": "elligator_hash_to_curve_test_vectors",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/contains",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "contains",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/batch_invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_montgomery",
      "Vec/Zeroize/zeroize",
      "5.0.0_pre.0 scalar/Scalar52/pack",
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "core https:/github.com/rust_lang/rust/library/core slice/iter_mut",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 scalar/Scalar/unpack",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/as_montgomery",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_mul",
      "5.0.0_pre.0 scalar/Scalar52/montgomery_invert",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev"
    ],
    "body": "",
    "display_name": "batch_invert",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/non_null_scalar",
    "statement_type": "function",
    "deps": [
      "TryRngCore/unwrap_err",
      "5.0.0_pre.0 scalar/Scalar/random"
    ],
    "body": "    fn non_null_scalar() -> Scalar {\n        let mut rng = rand::rngs::OsRng.unwrap_err();\n        let mut s_candidate = Scalar::random(&mut rng);\n        while s_candidate == Scalar::ZERO {\n            s_candidate = Scalar::random(&mut rng);\n        }\n        s_candidate\n    }",
    "display_name": "non_null_scalar",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_set_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_set_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 m",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/mul32"
    ],
    "body": "        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }",
    "display_name": "m",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 decompress/edwards/step_1",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/sqrt_ratio_i",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square"
    ],
    "body": "    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }",
    "display_name": "step_1",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/constants/test_d_vs_ratio",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/invert"
    ],
    "body": "    fn test_d_vs_ratio() {\n        use crate::backend::serial::u64::field::FieldElement51;\n        let a = -&FieldElement51([121665, 0, 0, 0, 0]);\n        let b = FieldElement51([121666, 0, 0, 0, 0]);\n        let d = &a * &b.invert();\n        let d2 = &d + &d;\n        assert_eq!(d, constants::EDWARDS_D);\n        assert_eq!(d2, constants::EDWARDS_D2);\n    }",
    "display_name": "test_d_vs_ratio",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/constants/test_two_torsion",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/filter",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 traits/IsIdentity/is_identity",
      "5.0.0_pre.0 edwards/EdwardsPoint/ValidityCheck/is_valid"
    ],
    "body": "    fn test_two_torsion() {\n        for i in (0..8).filter(|i| i % 4 == 0) {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(1);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }",
    "display_name": "test_two_torsion",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/pow22501",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/pow2k"
    ],
    "body": "    pub(crate) fn invert(&self) -> FieldElement {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);            // 254..5\n        let t21 = &t20 * &t3;              // 254..5,3,1,0\n\n        t21\n    }",
    "display_name": "invert",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core option/Option/ok_or_else",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ok_or_else",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_mod_multiples_basic",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mod_multiples_basic",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/shr_decomposition",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/lemma2_to64_rest",
      "div_mod/arithmetic/lemma_div_denominator",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shr_zero_is_id",
      "power2/arithmetic/pow2",
      "power2/arithmetic/lemma_pow2_pos",
      "power2/arithmetic/lemma_pow2_adds",
      "power2/arithmetic/lemma_pow2_strictly_increases"
    ],
    "body": "pub proof fn shr_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64\n    ensures\n        (v >> (a + b)) == ((v >> a) >> b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shr_zero_is_id;\n    }\n    else {\n        lemma2_to64_rest(); // pow2(64)\n        lemma_pow2_strictly_increases(a, a + b);\n        lemma_pow2_strictly_increases(b, a + b);\n        lemma_pow2_strictly_increases(a + b, 64); // pow2(a + b) fits in u64\n\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // v >> a + b = v / 2^(a+b)\n        lemma_u64_shr_is_div(v, (a + b) as u64);\n        // v >> a = v / 2^a\n        lemma_u64_shr_is_div(v, a as u64);\n        // (v / 2^a) << b = (v / 2^a) / 2^b\n        lemma_u64_shr_is_div((v / (pow2(a) as u64)) as u64, b as u64);\n\n        // 2^k > 0\n        lemma_pow2_pos(a);\n        lemma_pow2_pos(b);\n\n        // v / 2^a / 2^b = v / 2^(a + b)\n        lemma_div_denominator(v as int, pow2(a) as int, pow2(b) as int);\n    }\n}",
    "display_name": "shr_decomposition",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "decode",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "decode",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_add_epi64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_add_epi64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul_internal",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded"
    ],
    "body": "\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct ScalarVisitor;\n\n        impl<'de> Visitor<'de> for ScalarVisitor {\n            type Value = Scalar;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\n                    \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                    basepoint order \",\n                )\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Option::from(Scalar::from_canonical_bytes(bytes))\n                    .ok_or_else(|| serde::de::Error::custom(\"scalar was not canonically encoded\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_mul_epu32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_mul_epu32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "parse/ParseBuffer/parse",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "parse",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "clone/gen/Receiver/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_benches/scalar_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto_benches/ristretto_benches",
      "5.0.0_pre.0 scalar_benches/scalar_arith",
      "5.0.0_pre.0 edwards_benches/edwards_benches",
      "Criterion/Default/default",
      "5.0.0_pre.0 scalar_benches/batch_scalar_inversion",
      "5.0.0_pre.0 montgomery_benches/montgomery_benches",
      "5.0.0_pre.0 multiscalar_benches/multiscalar_benches",
      "Criterion/benchmark_group"
    ],
    "body": "    pub(crate) fn scalar_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"scalar benches\");\n\n        scalar_arith(&mut g);\n        batch_scalar_inversion(&mut g);\n    }",
    "display_name": "scalar_benches",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 scalar/Scalar/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    /// # Inputs\n    ///\n    /// * `bytes`: an `&[u8]` of length [`KEYPAIR_LENGTH`], representing the\n    ///   scalar for the secret key, and a compressed Edwards-Y coordinate of a\n    ///   point on curve25519, both as bytes. (As obtained from\n    ///   [`SigningKey::to_bytes`].)\n    ///\n    /// # Returns\n    ///\n    /// A `Result` whose okay value is an EdDSA [`SigningKey`] or whose error value\n    /// is a `SignatureError` describing the error that occurred.\n    #[inline]\n    pub fn from_keypair_bytes(bytes: &[u8; 64]) -> Result<SigningKey, SignatureError> {\n        let (secret_key, verifying_key) = bytes.split_at(SECRET_KEY_LENGTH);\n        let signing_key = SigningKey::try_from(secret_key)?;\n        let verifying_key = VerifyingKey::try_from(verifying_key)?;\n\n        if signing_key.verifying_key() != verifying_key {\n            return Err(InternalError::MismatchedKeypair.into());\n        }\n\n        Ok(signing_key)\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_reorder_mul",
    "statement_type": "function",
    "deps": [
      "mul/arithmetic/lemma_mul_is_associative"
    ],
    "body": "pub proof fn lemma_reorder_mul(a: int, b: int)\n    ensures\n        2 * (a * (19 * b)) == 19 * (2 * (a * b))\n{\n    // 2*( a * (19 * b)) = (2 * a) * (19 * b)\n    lemma_mul_is_associative(2, a, 19 * b);\n    // (2 * a) * (19 * b) = (19 * b) * (2 * a) = 19 * (b * (2 * a))\n    lemma_mul_is_associative(19, b, 2 * a);\n    // (b * (2 * a)) = (b * (a * 2)) = 2 * (a * b)\n    lemma_mul_is_associative(b, a, 2);\n}",
    "display_name": "lemma_reorder_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/montgomery_mul_max",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_mul"
    ],
    "body": "    fn montgomery_mul_max() {\n        let res = Scalar52::montgomery_mul(&X, &X);\n        for i in 0..5 {\n            assert!(res[i] == XX_MONT[i]);\n        }\n    }",
    "display_name": "montgomery_mul_max",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core num/wrapping_mul",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "wrapping_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "bits/lemma_low_bits_mask_unfold",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_low_bits_mask_unfold",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 is_path_eq",
    "statement_type": "function",
    "deps": [
      "path/PathArguments/is_none",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len",
      "core https:/github.com/rust_lang/rust/library/core str/split",
      "punctuated/Punctuated/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/all",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "punctuated/Punctuated/len",
      "core https:/github.com/rust_lang/rust/library/core slice/iter"
    ],
    "body": "fn is_path_eq(path: &syn::Path, ident: &str) -> bool {\n    let segments: Vec<_> = ident.split(\"::\").collect();\n    path.segments.len() == segments.len()\n        && path\n            .segments\n            .iter()\n            .zip(segments.iter())\n            .all(|(segment, expected)| segment.ident == expected && segment.arguments.is_none())\n}",
    "display_name": "is_path_eq",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery_benches/montgomery_ladder",
    "statement_type": "function",
    "deps": [
      "benchmark_group/BenchmarkGroup/bench_function",
      "bencher/Bencher/iter",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "5.0.0_pre.0 scalar/Scalar/invert"
    ],
    "body": "    fn montgomery_ladder<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"Montgomery pseudomultiplication\", |b| {\n            let B = constants::X25519_BASEPOINT;\n            let s = Scalar::from(897987897u64).invert();\n            b.iter(|| B * s);\n        });\n    }",
    "display_name": "montgomery_ladder",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/test_read_le_u64_into_should_panic_on_bad_input",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/read_le_u64_into"
    ],
    "body": "    fn test_read_le_u64_into_should_panic_on_bad_input() {\n        let mut dst = [0_u64; 1];\n        // One byte short\n        read_le_u64_into(&[0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F], &mut dst);\n    }",
    "display_name": "test_read_le_u64_into_should_panic_on_bad_input",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/Identity/identity"
    ],
    "body": "    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 SpecializeArgs/Parse/parse",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "punctuated/Punctuated/parse_terminated",
      "alloc https:/github.com/rust_lang/rust/library/alloc slice/join",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Clone/clone",
      "alloc https:/github.com/rust_lang/rust/library/alloc str/replace",
      "1.0.95 TokenStream/Clone/clone",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "token/Paren/Default/default",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/push",
      "core https:/github.com/rust_lang/rust/library/core str/split",
      "0.1.1 process_item",
      "1.0.95 Ident/new",
      "0.1.1 SpecializeArg/lit",
      "1.0.95 Ident/span",
      "lit/LitStr/value",
      "token/Pound/Default/default",
      "0.1.1 process_mod",
      "lit/LitStr/span",
      "0.1.1 SpecializeArg/condition",
      "clone/gen/ItemMod/Clone/clone",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/new",
      "token/Bracket/Default/default"
    ],
    "body": "    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        Ok(Self(syn::punctuated::Punctuated::parse_terminated(input)?))\n    }",
    "display_name": "parse",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/ExpandedSecretKey/from_slice",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "core https:/github.com/rust_lang/rust/library/core result/Result/map",
      "core https:/github.com/rust_lang/rust/library/core result/Result/map_err",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "3.0.0_pre.0 hazmat/ExpandedSecretKey/from_bytes"
    ],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<Self, SignatureError> {\n        // Try to coerce bytes to a [u8; 64]\n        bytes.try_into().map(Self::from_bytes).map_err(|_| {\n            InternalError::BytesLength {\n                name: \"ExpandedSecretKey\",\n                length: 64,\n            }\n            .into()\n        })\n    }",
    "display_name": "from_slice",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core array/Hash/hash",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "hash",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/Verifier/verify"
    ],
    "body": "    fn verify(&self, message: &[u8], signature: &Signature) -> Result<(), SignatureError> {\n        self.verifying_key.verify(message, signature)\n    }",
    "display_name": "verify",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/scalarmult_ristrettopoint_works_both_ways",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress",
      "5.0.0_pre.0 ristretto/CompressedRistretto/as_bytes"
    ],
    "body": "    fn scalarmult_ristrettopoint_works_both_ways() {\n        let P = constants::RISTRETTO_BASEPOINT_POINT;\n        let s = Scalar::from(999u64);\n\n        let P1 = P * s;\n        let P2 = s * P;\n\n        assert!(P1.compress().as_bytes() == P2.compress().as_bytes());\n    }",
    "display_name": "scalarmult_ristrettopoint_works_both_ways",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", self.limbs)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 affine/edwards/AffinePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/optional_mixed_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core option/Option/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 backend/VartimePrecomputedStraus/optional_mixed_multiscalar_mul"
    ],
    "body": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points.into_iter().map(|P_opt| P_opt.map(|P| P.0)),\n            )\n            .map(RistrettoPoint)\n    }",
    "display_name": "optional_mixed_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/Add/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/blend",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/diff_sum",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/shuffle"
    ],
    "body": "    fn add(self, other: &CachedPoint) -> ExtendedPoint {\n        // The coefficients of an `ExtendedPoint` are reduced after\n        // every operation.  If the `CachedPoint` was negated, its\n        // coefficients grow by one bit.  So on input, `self` is\n        // bounded with `b < 0.007` and `other` is bounded with\n        // `b < 1.0`.\n\n        let mut tmp = self.0;\n\n        tmp = tmp.blend(tmp.diff_sum(), Lanes::AB);\n        // tmp = (Y1-X1 Y1+X1 Z1 T1) = (S0 S1 Z1 T1) with b < 1.6\n\n        // (tmp, other) bounded with b < (1.6, 1.0) < (2.5, 1.75).\n        tmp = &tmp * &other.0;\n        // tmp = (S0*S2' S1*S3' Z1*Z2' T1*T2') = (S8 S9 S10 S11)\n\n        tmp = tmp.shuffle(Shuffle::ABDC);\n        // tmp = (S8 S9 S11 S10)\n\n        tmp = tmp.diff_sum();\n        // tmp = (S9-S8 S9+S8 S10-S11 S10+S11) = (S12 S13 S14 S15)\n\n        let t0 = tmp.shuffle(Shuffle::ADDA);\n        // t0 = (S12 S15 S15 S12)\n        let t1 = tmp.shuffle(Shuffle::CBCB);\n        // t1 = (S14 S13 S14 S13)\n\n        // All coefficients of t0, t1 are bounded with b < 1.6.\n        // Return (S12*S14 S15*S13 S15*S14 S12*S13) = (X3 Y3 Z3 T3)\n        ExtendedPoint(&t0 * &t1)\n    }",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "Choice/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/ExpandedSecretKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/ExpandedSecretKey/ConstantTimeEq/ct_eq",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u32x8/extract",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "extract",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc str/replace",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "replace",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 vartime/test/edwards/multiscalar_mul_vartime_vs_consttime",
    "statement_type": "function",
    "deps": [
      "deserialize",
      "serialize",
      "5.0.0_pre.0 edwards/EdwardsPoint/MultiscalarMul/multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress"
    ],
    "body": "        fn multiscalar_mul_vartime_vs_consttime() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result_vartime = EdwardsPoint::vartime_multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n            let result_consttime = EdwardsPoint::multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n\n            assert_eq!(result_vartime.compress(), result_consttime.compress());\n        }",
    "display_name": "multiscalar_mul_vartime_vs_consttime",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 affine/edwards/AffinePoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 affine/edwards/AffinePoint/ConstantTimeEq/ct_eq",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/montgomery_mul_bits_be",
    "statement_type": "function",
    "deps": [
      "TryRngCore/unwrap_err",
      "5.0.0_pre.0 test/montgomery/rand_prime_order_point",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_bits_be",
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order_wide",
      "5.0.0_pre.0 test/montgomery/bytestring_bits_le",
      "UnwrapErr/RngCore/fill_bytes"
    ],
    "body": "    fn montgomery_mul_bits_be() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            // Make a random prime-order point P\n            let p_edwards = rand_prime_order_point(&mut csprng);\n            let p_montgomery: MontgomeryPoint = p_edwards.to_montgomery();\n\n            // Make a random integer b\n            let mut bigint = [0u8; 64];\n            csprng.fill_bytes(&mut bigint[..]);\n            let bigint_bits_be = bytestring_bits_le(&bigint).rev();\n\n            // Check that bP is the same whether calculated as scalar-times-edwards or\n            // integer-times-montgomery.\n            let expected = Scalar::from_bytes_mod_order_wide(&bigint) * p_edwards;\n            let result = p_montgomery.mul_bits_be(bigint_bits_be);\n            assert_eq!(result, expected.to_montgomery())\n        }\n    }",
    "display_name": "montgomery_mul_bits_be",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "    fn from_bytes_mod_order_wide() {\n        let mut bignum = [0u8; 64];\n        // set bignum = x + 2^256x\n        for i in 0..32 {\n            bignum[i] = X[i];\n            bignum[32 + i] = X[i];\n        }\n        // 3958878930004874126169954872055634648693766179881526445624823978500314864344\n        // = x + 2^256x (mod l)\n        let reduced = Scalar {\n            bytes: [\n                216, 154, 179, 139, 210, 121, 2, 71, 69, 99, 158, 216, 23, 173, 63, 100, 204, 0,\n                91, 50, 219, 153, 57, 249, 28, 82, 31, 197, 100, 165, 192, 8,\n            ],\n        };\n        let test_red = Scalar::from_bytes_mod_order_wide(&bignum);\n        for i in 0..32 {\n            assert!(test_red[i] == reduced[i]);\n        }\n    }",
    "display_name": "from_bytes_mod_order_wide",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_small_mod",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_small_mod",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 ed25519_benches/key_generation",
    "statement_type": "function",
    "deps": [
      "thread/rngs/rng",
      "bencher/Bencher/iter",
      "3.0.0_pre.0 signing/SigningKey/generate",
      "Criterion/bench_function"
    ],
    "body": "    fn key_generation(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n\n        c.bench_function(\"Ed25519 keypair generation\", move |b| {\n            b.iter(|| SigningKey::generate(&mut csprng))\n        });\n    }",
    "display_name": "key_generation",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 x25519_benches",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 bench_diffie_hellman",
      "Criterion/Default/default"
    ],
    "body": "    name = x25519_benches;\n    config = Criterion::default();\n    targets =\n        bench_diffie_hellman,\n}\ncriterion_main! {\n    x25519_benches,\n}",
    "display_name": "x25519_benches",
    "full_path": "file:///work/3185/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "Array/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_ref",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core str/split",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "split",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "error/Error/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/construct_scalars",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 scalar/Scalar/random",
      "thread/rngs/rng",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map"
    ],
    "body": "    fn construct_scalars(n: usize) -> Vec<Scalar> {\n        let mut rng = rng();\n        (0..n).map(|_| Scalar::random(&mut rng)).collect()\n    }",
    "display_name": "construct_scalars",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "clone/gen/Generics/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 vartime_double_base/scalar_mul/serial/backend/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 window/NafLookupTable8/select",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 scalar/Scalar/non_adjacent_form",
      "5.0.0_pre.0 window/NafLookupTable5/select",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/double",
      "core https:/github.com/rust_lang/rust/library/core impls/cmp/Ord/cmp",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_projective",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "5.0.0_pre.0 window/NafLookupTable5/From/from",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/as_extended"
    ],
    "body": "//! field arithmetic, used to implement point operations using a novel\n//! implementation strategy derived from parallel formulas of Hisil,\n//! Wong, Carter, and Dawson.\n//!\n//! Because the two strategies give rise to different curve models,\n//! it's not possible to reuse exactly the same scalar multiplication\n//! code (or to write it generically), so both serial and vector\n//! backends contain matching implementations of scalar multiplication\n//! algorithms.  These are intended to be selected by a `#[cfg]`-based\n//! type alias.\n//!\n//! The [`vector`] backend is selected by the `simd_backend` cargo\n//! feature; it uses the [`serial`] backend for non-vectorized operations.\n\nuse crate::EdwardsPoint;\nuse crate::Scalar;\n\npub mod serial;\n\n#[cfg(curve25519_dalek_backend = \"simd\")]\npub mod vector;\n\n#[derive(Copy, Clone)]\nenum BackendKind {\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    Avx2,\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    Avx512,\n    Serial,\n}",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/Sum/sum",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/fold"
    ],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/unpack",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_bytes"
    ],
    "body": "    pub(crate) fn unpack(&self) -> UnpackedScalar {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }",
    "display_name": "unpack",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/main",
    "statement_type": "function",
    "deps": [],
    "body": "fn main() {}\n",
    "display_name": "main",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/by_ref",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "by_ref",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/seq_to_nat"
    ],
    "body": "//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}",
    "display_name": "to_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/traits.rs",
    "relative_path": "curve25519-dalek/src/traits.rs",
    "file_name": "traits.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc slice/concat",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "concat",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/test_pippenger_radix",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/chain",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 scalar/Scalar/invert",
      "core https:/github.com/rust_lang/rust/library/core once/sources/iter/once",
      "5.0.0_pre.0 test/scalar/test_pippenger_radix_iter"
    ],
    "body": "    fn test_pippenger_radix() {\n        use core::iter;\n        // For each valid radix it tests that 1000 random-ish scalars can be restored\n        // from the produced representation precisely.\n        let cases = (2..100)\n            .map(|s| Scalar::from(s as u64).invert())\n            // The largest unreduced scalar, s = 2^255-1. This is not reduced mod l. Scalar mult\n            // still works though.\n            .chain(iter::once(LARGEST_UNREDUCED_SCALAR));\n\n        for scalar in cases {\n            test_pippenger_radix_iter(scalar, 6);\n            test_pippenger_radix_iter(scalar, 7);\n            test_pippenger_radix_iter(scalar, 8);\n        }\n    }",
    "display_name": "test_pippenger_radix",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_tables",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix64/BasepointTable/create",
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix128/BasepointTable/create",
      "5.0.0_pre.0 edwards/EdwardsBasepointTable/BasepointTable/create",
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix256/BasepointTable/create",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix32/BasepointTable/create"
    ],
    "body": "    fn basepoint_tables() {\n        let P = &constants::ED25519_BASEPOINT_POINT;\n        let a = A_SCALAR;\n\n        let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n        let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n        let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n        let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n        let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n        let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n        let aP16 = (&table_radix16 * &a).compress();\n        let aP32 = (&table_radix32 * &a).compress();\n        let aP64 = (&table_radix64 * &a).compress();\n        let aP128 = (&table_radix128 * &a).compress();\n        let aP256 = (&table_radix256 * &a).compress();\n\n        assert_eq!(aP, aP16);\n        assert_eq!(aP16, aP32);\n        assert_eq!(aP32, aP64);\n        assert_eq!(aP64, aP128);\n        assert_eq!(aP128, aP256);\n    }",
    "display_name": "basepoint_tables",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/pippenger_optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 pippenger/scalar_mul/serial/backend/Pippenger/VartimeMultiscalarMul/optional_multiscalar_mul"
    ],
    "body": "pub fn pippenger_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 =>\n            vector::scalar_mul::pippenger::spec_avx2::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 =>\n            vector::scalar_mul::pippenger::spec_avx512ifma_avx512vl::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        BackendKind::Serial =>\n            serial::scalar_mul::pippenger::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n    }\n}",
    "display_name": "pippenger_optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "try_into",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/words_to_nat"
    ],
    "body": "//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;",
    "display_name": "from_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 rand_core/ephemeral_from_rng",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/EphemeralSecret/random_from_rng",
      "TryRngCore/unwrap_err"
    ],
    "body": "    fn ephemeral_from_rng() {\n        EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err());\n    }",
    "display_name": "ephemeral_from_rng",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/basepoint_montgomery_to_edwards",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_edwards"
    ],
    "body": "    fn basepoint_montgomery_to_edwards() {\n        // sign bit = 0 => basepoint\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT,\n            constants::X25519_BASEPOINT.to_edwards(0).unwrap()\n        );\n        // sign bit = 1 => minus basepoint\n        assert_eq!(\n            -constants::ED25519_BASEPOINT_POINT,\n            constants::X25519_BASEPOINT.to_edwards(1).unwrap()\n        );\n    }",
    "display_name": "basepoint_montgomery_to_edwards",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_set_epi64x",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_set_epi64x",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/RCompute/compute",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/RCompute/update",
      "core https:/github.com/rust_lang/rust/library/core iter/slice/Iter/Iterator/for_each",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "3.0.0_pre.0 verifying/RCompute/finish",
      "3.0.0_pre.0 verifying/RCompute/new"
    ],
    "body": "    pub(crate) fn compute(\n        key: &VerifyingKey,\n        signature: InternalSignature,\n        prehash_ctx: Option<&[u8]>,\n        message: &[&[u8]],\n    ) -> CompressedEdwardsY {\n        let mut c = Self::new(key, signature, prehash_ctx);\n        message.iter().for_each(|slice| c.update(slice));\n        c.finish()\n    }",
    "display_name": "compute",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/Verifier/verify"
    ],
    "body": "",
    "display_name": "verify",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 spec/precomputed_straus/scalar_mul/vector/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/is_empty",
    "statement_type": "function",
    "deps": [
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/is_empty"
    ],
    "body": "        fn is_empty(&self) -> bool {\n            self.static_lookup_tables.is_empty()\n        }",
    "display_name": "is_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "version",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "version",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/main",
    "statement_type": "function",
    "deps": [],
    "body": "fn main()\n{}\n",
    "display_name": "main",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/square_internal",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/montgomery_radix",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order"
    ],
    "body": "where\n    T: Borrow<Scalar>,\n{\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n}",
    "display_name": "montgomery_square",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc string/String/insert",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "insert",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/from_u64",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/From/from"
    ],
    "body": "    fn from_u64() {\n        let val: u64 = 0xdeadbeefdeadbeef;\n        let s = Scalar::from(val);\n        assert_eq!(s[7], 0xde);\n        assert_eq!(s[6], 0xad);\n        assert_eq!(s[5], 0xbe);\n        assert_eq!(s[4], 0xef);\n        assert_eq!(s[3], 0xde);\n        assert_eq!(s[2], 0xad);\n        assert_eq!(s[1], 0xbe);\n        assert_eq!(s[0], 0xef);\n    }",
    "display_name": "from_u64",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "neg",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/splat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/new"
    ],
    "body": "    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }",
    "display_name": "splat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/compute_challenge",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "digest/Digest/update",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes",
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "0.11.0_rc.0 Sha512/Default/default",
      "5.0.0_pre.0 scalar/Scalar/from_hash"
    ],
    "body": "    fn compute_challenge(\n        message: &[u8],\n        pub_key: &EdwardsPoint,\n        signature_r: &EdwardsPoint,\n        context: Option<&[u8]>,\n    ) -> Scalar {\n        let mut h = Sha512::default();\n        if let Some(c) = context {\n            h.update(b\"SigEd25519 no Ed25519 collisions\");\n            h.update([1]);\n            h.update([c.len() as u8]);\n            h.update(c);\n        }\n        h.update(signature_r.compress().as_bytes());\n        h.update(&pub_key.compress().as_bytes()[..]);\n        h.update(message);\n        Scalar::from_hash(h)\n    }",
    "display_name": "compute_challenge",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> CachedPoint {\n        constants::CACHEDPOINT_IDENTITY\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_extract_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_extract_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u32x8/shl",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "shl",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/m",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_52_52"
    ],
    "body": "fn m(x: u64, y: u64) -> (z: u128)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures\n    z < (1u128 << 104),\n    z == x * y\n{\n    proof {lemma_52_52(x, y);}\n    (x as u128) * (y as u128)\n}",
    "display_name": "m",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/Neg/neg",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/reduce"
    ],
    "body": "    fn neg(self) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            P_TIMES_16_LO - self.0[0],\n            P_TIMES_16_HI - self.0[1],\n            P_TIMES_16_HI - self.0[2],\n            P_TIMES_16_HI - self.0[3],\n            P_TIMES_16_HI - self.0[4],\n        ])\n        .reduce()\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u64x4/splat",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_set1_epi64x"
    ],
    "body": "                // match control {\n                //     Lanes::C => {\n                //         let imm = C_LANES as i32;\n                //         _mm256_blend_epi32(..., imm)\n                // ```\n                // let alone\n                // ```\n                // let imm = match control {\n                //     Lanes::C => C_LANES as i32,\n                // }\n                // _mm256_blend_epi32(..., imm)\n                // ```\n                // even though both of these would be constant-folded by LLVM\n                // at a lower level (as happens in the shuffle implementation,\n                // which does not require a shuffle immediate but *is* lowered\n                // to immediate shuffles anyways).\n                match control {\n                    Lanes::C => _mm256_blend_epi32(x.into(), y.into(), C_LANES as i32).into(),\n                    Lanes::D => _mm256_blend_epi32(x.into(), y.into(), D_LANES as i32).into(),\n                    Lanes::AD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::AB => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | B_LANES) as i32).into()\n                    }\n                    Lanes::AC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::CD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (C_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::BC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (B_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::ABCD => _mm256_blend_epi32(\n                        x.into(),\n                        y.into(),\n                        (A_LANES | B_LANES | C_LANES | D_LANES) as i32,\n                    )\n                    .into(),\n                }\n            }\n        }",
    "display_name": "splat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core option/Option/map",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "map",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core option/Option/map",
      "5.0.0_pre.0 edwards/EdwardsPoint/VartimeMultiscalarMul/optional_multiscalar_mul"
    ],
    "body": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<RistrettoPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<RistrettoPoint>>,\n    {\n        let extended_points = points.into_iter().map(|opt_P| opt_P.map(|P| P.0));\n\n        EdwardsPoint::optional_multiscalar_mul(scalars, extended_points).map(RistrettoPoint)\n    }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "Criterion/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/Identity/identity"
    ],
    "body": "    fn default() -> CachedPoint {\n        CachedPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/mul_max",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul"
    ],
    "body": "    fn mul_max() {\n        let res = Scalar52::mul(&X, &X);\n        for i in 0..5 {\n            assert!(res[i] == XX[i]);\n        }\n    }",
    "display_name": "mul_max",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/blend",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn blend(&self, other: FieldElement2625x4, control: Lanes) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn blend_lanes(x: u32x8, y: u32x8, control: Lanes) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n\n                // This would be much cleaner if we could factor out the match\n                // statement on the control. Unfortunately, rustc forgets\n                // constant-info very quickly, so we can't even write\n                // ```\n                // match control {\n                //     Lanes::C => {\n                //         let imm = C_LANES as i32;\n                //         _mm256_blend_epi32(..., imm)\n                // ```\n                // let alone\n                // ```\n                // let imm = match control {\n                //     Lanes::C => C_LANES as i32,\n                // }\n                // _mm256_blend_epi32(..., imm)\n                // ```\n                // even though both of these would be constant-folded by LLVM\n                // at a lower level (as happens in the shuffle implementation,\n                // which does not require a shuffle immediate but *is* lowered\n                // to immediate shuffles anyways).\n                match control {\n                    Lanes::C => _mm256_blend_epi32(x.into(), y.into(), C_LANES as i32).into(),\n                    Lanes::D => _mm256_blend_epi32(x.into(), y.into(), D_LANES as i32).into(),\n                    Lanes::AD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::AB => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | B_LANES) as i32).into()\n                    }\n                    Lanes::AC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::CD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (C_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::BC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (B_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::ABCD => _mm256_blend_epi32(\n                        x.into(),\n                        y.into(),\n                        (A_LANES | B_LANES | C_LANES | D_LANES) as i32,\n                    )\n                    .into(),\n                }\n            }\n        }\n\n        FieldElement2625x4([\n            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n\n    /// Convenience wrapper around `new(x,x,x,x)`.\n    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }\n\n    /// Create a `FieldElement2625x4` from four `FieldElement51`s.\n    ///\n    /// # Postconditions\n    ///\n    /// The resulting `FieldElement2625x4` is bounded with \\\\( b < 0.0002 \\\\).\n    #[rustfmt::skip] // keep alignment of computed lanes\n    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> FieldElement2625x4 {\n        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }\n\n        // We don't know that the original `FieldElement51`s were\n        // fully reduced, so the odd limbs may exceed 2^25.\n        // Reduce them to be sure.\n        FieldElement2625x4(buf).reduce()\n    }\n\n    /// Given \\\\((A,B,C,D)\\\\), compute \\\\((-A,-B,-C,-D)\\\\), without\n    /// performing a reduction.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.999 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1 \\\\).\n    #[inline]\n    pub fn negate_lazy(&self) -> FieldElement2625x4 {\n        // The limbs of self are bounded with b < 0.999, while the\n        // smallest limb of 2*p is 67108845 > 2^{26+0.9999}, so\n        // underflows are not possible.\n        FieldElement2625x4([\n            P_TIMES_2_LO - self.0[0],\n            P_TIMES_2_HI - self.0[1],\n            P_TIMES_2_HI - self.0[2],\n            P_TIMES_2_HI - self.0[3],\n            P_TIMES_2_HI - self.0[4],\n        ])\n    }\n\n    /// Given `self = (A,B,C,D)`, compute `(B - A, B + A, D - C, D + C)`.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.01 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1.6 \\\\).\n    #[inline]\n    pub fn diff_sum(&self) -> FieldElement2625x4 {\n        // tmp1 = (B, A, D, C)\n        let tmp1 = self.shuffle(Shuffle::BADC);\n        // tmp2 = (-A, B, -C, D)\n        let tmp2 = self.blend(self.negate_lazy(), Lanes::AC);\n        // (B - A, B + A, D - C, D + C) bounded with b < 1.6\n        tmp1 + tmp2\n    }\n\n    /// Reduce this vector of field elements \\\\(\\mathrm{mod} p\\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.0002 \\\\).\n    #[inline]\n    pub fn reduce(&self) -> FieldElement2625x4 {\n        let shifts = u32x8::new(26, 26, 25, 25, 26, 26, 25, 25);\n        let masks = u32x8::new(\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n        );\n\n        // Let c(x) denote the carryout of the coefficient x.\n        //\n        // Given    (   x0,    y0,    x1,    y1,    z0,    w0,    z1,    w1),\n        // compute  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0)).\n        //\n        // The carryouts are bounded by 2^(32 - 25) = 2^7.\n        let rotated_carryout = |v: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_shuffle_epi32;\n                use core::arch::x86_64::_mm256_srlv_epi32;\n\n                let c = _mm256_srlv_epi32(v.into(), shifts.into());\n                _mm256_shuffle_epi32(c, 0b01_00_11_10).into()\n            }\n        };\n\n        // Combine (lo, lo, lo, lo, lo, lo, lo, lo)\n        //    with (hi, hi, hi, hi, hi, hi, hi, hi)\n        //      to (lo, lo, hi, hi, lo, lo, hi, hi)\n        //\n        // This allows combining carryouts, e.g.,\n        //\n        // lo  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0))\n        // hi  (c(x3), c(y3), c(x2), c(y2), c(z3), c(w3), c(z2), c(w2))\n        // ->  (c(x1), c(y1), c(x2), c(y2), c(z1), c(w1), c(z2), c(w2))\n        //\n        // which is exactly the vector of carryins for\n        //\n        //     (   x2,    y2,    x3,    y3,    z2,    w2,    z3,    w3).\n        //\n        let combine = |v_lo: u32x8, v_hi: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(v_lo.into(), v_hi.into(), 0b11_00_11_00).into()\n            }\n        };\n\n        let mut v = self.0;\n\n        let c10 = rotated_carryout(v[0]);\n        v[0] = (v[0] & masks) + combine(u32x8::splat(0), c10);\n\n        let c32 = rotated_carryout(v[1]);\n        v[1] = (v[1] & masks) + combine(c10, c32);\n\n        let c54 = rotated_carryout(v[2]);\n        v[2] = (v[2] & masks) + combine(c32, c54);\n\n        let c76 = rotated_carryout(v[3]);\n        v[3] = (v[3] & masks) + combine(c54, c76);\n\n        let c98 = rotated_carryout(v[4]);\n        v[4] = (v[4] & masks) + combine(c76, c98);\n\n        let c9_19: u32x8 = unsafe {\n            use core::arch::x86_64::_mm256_mul_epu32;\n            use core::arch::x86_64::_mm256_shuffle_epi32;\n\n            // Need to rearrange c98, since vpmuludq uses the low\n            // 32-bits of each 64-bit lane to compute the product:\n            //\n            // c98       = (c(x9), c(y9), c(x8), c(y8), c(z9), c(w9), c(z8), c(w8));\n            // c9_spread = (c(x9), c(x8), c(y9), c(y8), c(z9), c(z8), c(w9), c(w8)).\n            let c9_spread = _mm256_shuffle_epi32(c98.into(), 0b11_01_10_00);\n\n            // Since the carryouts are bounded by 2^7, their products with 19\n            // are bounded by 2^11.25.  This means that\n            //\n            // c9_19_spread = (19*c(x9), 0, 19*c(y9), 0, 19*c(z9), 0, 19*c(w9), 0).\n            let c9_19_spread = _mm256_mul_epu32(c9_spread, u64x4::splat(19).into());\n\n            // Unshuffle:\n            // c9_19 = (19*c(x9), 19*c(y9), 0, 0, 19*c(z9), 19*c(w9), 0, 0).\n            _mm256_shuffle_epi32(c9_19_spread, 0b11_01_10_00).into()\n        };\n\n        // Add the final carryin.\n        v[0] += c9_19;\n\n        // Each output coefficient has exactly one carryin, which is\n        // bounded by 2^11.25, so they are bounded as\n        //\n        // c_even < 2^26 + 2^11.25 < 26.00006 < 2^{26+b}\n        // c_odd  < 2^25 + 2^11.25 < 25.0001  < 2^{25+b}\n        //\n        // where b = 0.0002.\n        FieldElement2625x4(v)\n    }\n\n    /// Given an array of wide coefficients, reduce them to a `FieldElement2625x4`.\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[inline]\n    #[rustfmt::skip] // keep alignment of carry chain\n    fn reduce64(mut z: [u64x4; 10]) -> FieldElement2625x4 {\n        // These aren't const because splat isn't a const fn\n        let LOW_25_BITS: u64x4 = u64x4::splat((1 << 25) - 1);\n        let LOW_26_BITS: u64x4 = u64x4::splat((1 << 26) - 1);\n\n        // Carry the value from limb i = 0..8 to limb i+1\n        let carry = |z: &mut [u64x4; 10], i: usize| {\n            debug_assert!(i < 9);\n            if i % 2 == 0 {\n                // Even limbs have 26 bits\n                z[i + 1] += z[i].shr::<26>();\n                z[i] &= LOW_26_BITS;\n            } else {\n                // Odd limbs have 25 bits\n                z[i + 1] += z[i].shr::<25>();\n                z[i] &= LOW_25_BITS;\n            }\n        };\n\n        // Perform two halves of the carry chain in parallel.\n        carry(&mut z, 0); carry(&mut z, 4);\n        carry(&mut z, 1); carry(&mut z, 5);\n        carry(&mut z, 2); carry(&mut z, 6);\n        carry(&mut z, 3); carry(&mut z, 7);\n        // Since z[3] < 2^64, c < 2^(64-25) = 2^39,\n        // so    z[4] < 2^26 + 2^39 < 2^39.0002\n        carry(&mut z, 4); carry(&mut z, 8);\n        // Now z[4] < 2^26\n        // and z[5] < 2^25 + 2^13.0002 < 2^25.0004 (good enough)\n\n        // Last carry has a multiplication by 19.  In the serial case we\n        // do a 64-bit multiplication by 19, but here we want to do a\n        // 32-bit multiplication.  However, if we only know z[9] < 2^64,\n        // the carry is bounded as c < 2^(64-25) = 2^39, which is too\n        // big.  To ensure c < 2^32, we would need z[9] < 2^57.\n        // Instead, we split the carry in two, with c = c_0 + c_1*2^26.\n\n        let c = z[9].shr::<25>();\n        z[9] &= LOW_25_BITS;\n        let mut c0: u64x4 = c & LOW_26_BITS; // c0 < 2^26;\n        let mut c1: u64x4 = c.shr::<26>();         // c1 < 2^(39-26) = 2^13;\n\n        let x19 = u64x4::splat(19);\n        c0 = u32x8::from(c0).mul32(u32x8::from(x19));\n        c1 = u32x8::from(c1).mul32(u32x8::from(x19));\n\n        z[0] += c0; // z0 < 2^26 + 2^30.25 < 2^30.33\n        z[1] += c1; // z1 < 2^25 + 2^17.25 < 2^25.0067\n        carry(&mut z, 0); // z0 < 2^26, z1 < 2^25.0067 + 2^4.33 = 2^25.007\n\n        // The output coefficients are bounded with\n        //\n        // b = 0.007  for z[1]\n        // b = 0.0004 for z[5]\n        // b = 0      for other z[i].\n        //\n        // So the packed result is bounded with b = 0.007.\n        FieldElement2625x4([\n            repack_pair(z[0].into(), z[1].into()),\n            repack_pair(z[2].into(), z[3].into()),\n            repack_pair(z[4].into(), z[5].into()),\n            repack_pair(z[6].into(), z[7].into()),\n            repack_pair(z[8].into(), z[9].into()),\n        ])\n    }\n\n    /// Square this field element, and negate the result's \\\\(D\\\\) value.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 1.5 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[rustfmt::skip] // keep alignment of z* calculations\n    pub fn square_and_negate_D(&self) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let x0_2 = x0.shl::<1>();\n        let x1_2 = x1.shl::<1>();\n        let x2_2 = x2.shl::<1>();\n        let x3_2 = x3.shl::<1>();\n        let x4_2 = x4.shl::<1>();\n        let x5_2 = x5.shl::<1>();\n        let x6_2 = x6.shl::<1>();\n        let x7_2 = x7.shl::<1>();\n\n        let x5_19 = m_lo(v19, x5);\n        let x6_19 = m_lo(v19, x6);\n        let x7_19 = m_lo(v19, x7);\n        let x8_19 = m_lo(v19, x8);\n        let x9_19 = m_lo(v19, x9);\n\n        let mut z0 = m(x0,   x0) + m(x2_2, x8_19) + m(x4_2, x6_19) + ((m(x1_2, x9_19) +   m(x3_2, x7_19) +    m(x5,   x5_19)).shl::<1>());\n        let mut z1 = m(x0_2, x1) + m(x3_2, x8_19) + m(x5_2, x6_19) +                    ((m(x2,   x9_19) +    m(x4,   x7_19)).shl::<1>());\n        let mut z2 = m(x0_2, x2) + m(x1_2,    x1) + m(x4_2, x8_19) +   m(x6,   x6_19) + ((m(x3_2, x9_19) +    m(x5_2, x7_19)).shl::<1>());\n        let mut z3 = m(x0_2, x3) + m(x1_2,    x2) + m(x5_2, x8_19) +                    ((m(x4,   x9_19) +    m(x6,   x7_19)).shl::<1>());\n        let mut z4 = m(x0_2, x4) + m(x1_2,  x3_2) + m(x2,      x2) +   m(x6_2, x8_19) + ((m(x5_2, x9_19) +    m(x7,   x7_19)).shl::<1>());\n        let mut z5 = m(x0_2, x5) + m(x1_2,    x4) + m(x2_2,    x3) +   m(x7_2, x8_19)                    +  ((m(x6,   x9_19)).shl::<1>());\n        let mut z6 = m(x0_2, x6) + m(x1_2,  x5_2) + m(x2_2,    x4) +   m(x3_2,    x3) +   m(x8,   x8_19) +  ((m(x7_2, x9_19)).shl::<1>());\n        let mut z7 = m(x0_2, x7) + m(x1_2,    x6) + m(x2_2,    x5) +   m(x3_2,    x4)                    +  ((m(x8,   x9_19)).shl::<1>());\n        let mut z8 = m(x0_2, x8) + m(x1_2,  x7_2) + m(x2_2,    x6) +   m(x3_2,  x5_2) +   m(x4,      x4) +  ((m(x9,   x9_19)).shl::<1>());\n        let mut z9 = m(x0_2, x9) + m(x1_2,    x8) + m(x2_2,    x7) +   m(x3_2,    x6) +   m(x4_2,    x5)                                 ;\n\n        // The biggest z_i is bounded as z_i < 249*2^(51 + 2*b);\n        // if b < 1.5 we get z_i < 4485585228861014016.\n        //\n        // The limbs of the multiples of p are bounded above by\n        //\n        // 0x3fffffff << 37 = 9223371899415822336 < 2^63\n        //\n        // and below by\n        //\n        // 0x1fffffff << 37 = 4611685880988434432\n        //                  > 4485585228861014016\n        //\n        // So these multiples of p are big enough to avoid underflow\n        // in subtraction, and small enough to fit within u64\n        // with room for a carry.\n\n        let low__p37 = u64x4::splat(0x3ffffed << 37);\n        let even_p37 = u64x4::splat(0x3ffffff << 37);\n        let odd__p37 = u64x4::splat(0x1ffffff << 37);\n\n        let negate_D = |x: u64x4, p: u64x4| -> u64x4 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(x.into(), (p - x).into(), D_LANES64 as i32).into()\n            }\n        };\n\n        z0 = negate_D(z0, low__p37);\n        z1 = negate_D(z1, odd__p37);\n        z2 = negate_D(z2, even_p37);\n        z3 = negate_D(z3, odd__p37);\n        z4 = negate_D(z4, even_p37);\n        z5 = negate_D(z5, odd__p37);\n        z6 = negate_D(z6, even_p37);\n        z7 = negate_D(z7, odd__p37);\n        z8 = negate_D(z8, even_p37);\n        z9 = negate_D(z9, odd__p37);\n\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Neg for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n\n    /// Negate this field element, performing a reduction.\n    ///\n    /// If the coefficients are known to be small, use `negate_lazy`\n    /// to avoid performing a reduction.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 4.0 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.0002 \\\\).\n    #[inline]\n    fn neg(self) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            P_TIMES_16_LO - self.0[0],\n            P_TIMES_16_HI - self.0[1],\n            P_TIMES_16_HI - self.0[2],\n            P_TIMES_16_HI - self.0[3],\n            P_TIMES_16_HI - self.0[4],\n        ])\n        .reduce()\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Add<FieldElement2625x4> for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Add two `FieldElement2625x4`s, without performing a reduction.\n    #[inline]\n    fn add(self, rhs: FieldElement2625x4) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            self.0[0] + rhs.0[0],\n            self.0[1] + rhs.0[1],\n            self.0[2] + rhs.0[2],\n            self.0[3] + rhs.0[3],\n            self.0[4] + rhs.0[4],\n        ])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Mul<(u32, u32, u32, u32)> for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Perform a multiplication by a vector of small constants.\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[inline]\n    fn mul(self, scalars: (u32, u32, u32, u32)) -> FieldElement2625x4 {\n        let consts = u32x8::new(scalars.0, 0, scalars.1, 0, scalars.2, 0, scalars.3, 0);\n\n        let (b0, b1) = unpack_pair(self.0[0]);\n        let (b2, b3) = unpack_pair(self.0[1]);\n        let (b4, b5) = unpack_pair(self.0[2]);\n        let (b6, b7) = unpack_pair(self.0[3]);\n        let (b8, b9) = unpack_pair(self.0[4]);\n\n        FieldElement2625x4::reduce64([\n            b0.mul32(consts),\n            b1.mul32(consts),\n            b2.mul32(consts),\n            b3.mul32(consts),\n            b4.mul32(consts),\n            b5.mul32(consts),\n            b6.mul32(consts),\n            b7.mul32(consts),\n            b8.mul32(consts),\n            b9.mul32(consts),\n        ])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Mul<&FieldElement2625x4> for &FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Multiply `self` by `rhs`.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 2.5 \\\\).\n    ///\n    /// The coefficients of `rhs` must be bounded with \\\\( b < 1.75 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    ///\n    #[rustfmt::skip] // keep alignment of z* calculations\n    #[inline]\n    fn mul(self, rhs: &FieldElement2625x4) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let (y0, y1) = unpack_pair(rhs.0[0]);\n        let (y2, y3) = unpack_pair(rhs.0[1]);\n        let (y4, y5) = unpack_pair(rhs.0[2]);\n        let (y6, y7) = unpack_pair(rhs.0[3]);\n        let (y8, y9) = unpack_pair(rhs.0[4]);\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let y1_19 = m_lo(v19, y1); // This fits in a u32\n        let y2_19 = m_lo(v19, y2); // iff 26 + b + lg(19) < 32\n        let y3_19 = m_lo(v19, y3); // if  b < 32 - 26 - 4.248 = 1.752\n        let y4_19 = m_lo(v19, y4);\n        let y5_19 = m_lo(v19, y5);\n        let y6_19 = m_lo(v19, y6);\n        let y7_19 = m_lo(v19, y7);\n        let y8_19 = m_lo(v19, y8);\n        let y9_19 = m_lo(v19, y9);\n\n        let x1_2 = x1 + x1; // This fits in a u32 iff 25 + b + 1 < 32\n        let x3_2 = x3 + x3; //                    iff b < 6\n        let x5_2 = x5 + x5;\n        let x7_2 = x7 + x7;\n        let x9_2 = x9 + x9;\n\n        let z0 = m(x0, y0) + m(x1_2, y9_19) + m(x2, y8_19) + m(x3_2, y7_19) + m(x4, y6_19) + m(x5_2, y5_19) + m(x6, y4_19) + m(x7_2, y3_19) + m(x8, y2_19) + m(x9_2, y1_19);\n        let z1 = m(x0, y1) + m(x1,      y0) + m(x2, y9_19) + m(x3,   y8_19) + m(x4, y7_19) + m(x5,   y6_19) + m(x6, y5_19) + m(x7,   y4_19) + m(x8, y3_19) + m(x9,   y2_19);\n        let z2 = m(x0, y2) + m(x1_2,    y1) + m(x2,    y0) + m(x3_2, y9_19) + m(x4, y8_19) + m(x5_2, y7_19) + m(x6, y6_19) + m(x7_2, y5_19) + m(x8, y4_19) + m(x9_2, y3_19);\n        let z3 = m(x0, y3) + m(x1,      y2) + m(x2,    y1) + m(x3,      y0) + m(x4, y9_19) + m(x5,   y8_19) + m(x6, y7_19) + m(x7,   y6_19) + m(x8, y5_19) + m(x9,   y4_19);\n        let z4 = m(x0, y4) + m(x1_2,    y3) + m(x2,    y2) + m(x3_2,    y1) + m(x4,    y0) + m(x5_2, y9_19) + m(x6, y8_19) + m(x7_2, y7_19) + m(x8, y6_19) + m(x9_2, y5_19);\n        let z5 = m(x0, y5) + m(x1,      y4) + m(x2,    y3) + m(x3,      y2) + m(x4,    y1) + m(x5,      y0) + m(x6, y9_19) + m(x7,   y8_19) + m(x8, y7_19) + m(x9,   y6_19);\n        let z6 = m(x0, y6) + m(x1_2,    y5) + m(x2,    y4) + m(x3_2,    y3) + m(x4,    y2) + m(x5_2,    y1) + m(x6,    y0) + m(x7_2, y9_19) + m(x8, y8_19) + m(x9_2, y7_19);\n        let z7 = m(x0, y7) + m(x1,      y6) + m(x2,    y5) + m(x3,      y4) + m(x4,    y3) + m(x5,      y2) + m(x6,    y1) + m(x7,      y0) + m(x8, y9_19) + m(x9,   y8_19);\n        let z8 = m(x0, y8) + m(x1_2,    y7) + m(x2,    y6) + m(x3_2,    y5) + m(x4,    y4) + m(x5_2,    y3) + m(x6,    y2) + m(x7_2,    y1) + m(x8,    y0) + m(x9_2, y9_19);\n        let z9 = m(x0, y9) + m(x1,      y8) + m(x2,    y7) + m(x3,      y6) + m(x4,    y5) + m(x5,      y4) + m(x6,    y3) + m(x7,      y2) + m(x8,    y1) + m(x9,      y0);\n\n        // The bounds on z[i] are the same as in the serial 32-bit code\n        // and the comment below is copied from there:\n\n        // How big is the contribution to z[i+j] from x[i], y[j]?\n        //\n        // Using the bounds above, we get:\n        //\n        // i even, j even:   x[i]*y[j] <   2^(26+b)*2^(26+b) = 2*2^(51+2*b)\n        // i  odd, j even:   x[i]*y[j] <   2^(25+b)*2^(26+b) = 1*2^(51+2*b)\n        // i even, j  odd:   x[i]*y[j] <   2^(26+b)*2^(25+b) = 1*2^(51+2*b)\n        // i  odd, j  odd: 2*x[i]*y[j] < 2*2^(25+b)*2^(25+b) = 1*2^(51+2*b)\n        //\n        // We perform inline reduction mod p by replacing 2^255 by 19\n        // (since 2^255 - 19 = 0 mod p).  This adds a factor of 19, so\n        // we get the bounds (z0 is the biggest one, but calculated for\n        // posterity here in case finer estimation is needed later):\n        //\n        //  z0 < ( 2 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 249*2^(51 + 2*b)\n        //  z1 < ( 1 +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 154*2^(51 + 2*b)\n        //  z2 < ( 2 +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 195*2^(51 + 2*b)\n        //  z3 < ( 1 +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 118*2^(51 + 2*b)\n        //  z4 < ( 2 +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 141*2^(51 + 2*b)\n        //  z5 < ( 1 +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) =  82*2^(51 + 2*b)\n        //  z6 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) =  87*2^(51 + 2*b)\n        //  z7 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 )*2^(51 + 2b) =  46*2^(51 + 2*b)\n        //  z8 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 )*2^(51 + 2b) =  33*2^(51 + 2*b)\n        //  z9 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   )*2^(51 + 2b) =  10*2^(51 + 2*b)\n        //\n        // So z[0] fits into a u64 if 51 + 2*b + lg(249) < 64\n        //                         if b < 2.5.\n\n        // In fact this bound is slightly sloppy, since it treats both\n        // inputs x and y as being bounded by the same parameter b,\n        // while they are in fact bounded by b_x and b_y, and we\n        // already require that b_y < 1.75 in order to fit the\n        // multiplications by 19 into a u32.  The tighter bound on b_y\n        // means we could get a tighter bound on the outputs, or a\n        // looser bound on b_x.\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}\n\n#[cfg(target_feature = \"avx2\")]\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn scale_by_curve_constants() {\n        let mut x = FieldElement2625x4::splat(&FieldElement51::ONE);\n\n        x = x * (121666, 121666, 2 * 121666, 2 * 121665);\n\n        let xs = x.split();\n        assert_eq!(xs[0], FieldElement51([121666, 0, 0, 0, 0]));\n        assert_eq!(xs[1], FieldElement51([121666, 0, 0, 0, 0]));\n        assert_eq!(xs[2], FieldElement51([2 * 121666, 0, 0, 0, 0]));\n        assert_eq!(xs[3], FieldElement51([2 * 121665, 0, 0, 0, 0]));\n    }\n\n    #[test]\n    fn diff_sum_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3).diff_sum();\n\n        let result = vec.split();\n\n        assert_eq!(result[0], &x1 - &x0);\n        assert_eq!(result[1], &x1 + &x0);\n        assert_eq!(result[2], &x3 - &x2);\n        assert_eq!(result[3], &x3 + &x2);\n    }\n\n    #[test]\n    fn square_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let result = vec.square_and_negate_D().split();\n\n        assert_eq!(result[0], &x0 * &x0);\n        assert_eq!(result[1], &x1 * &x1);\n        assert_eq!(result[2], &x2 * &x2);\n        assert_eq!(result[3], -&(&x3 * &x3));\n    }\n\n    #[test]\n    fn multiply_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n        let vecprime = vec.clone();\n\n        let result = (&vec * &vecprime).split();\n\n        assert_eq!(result[0], &x0 * &x0);\n        assert_eq!(result[1], &x1 * &x1);\n        assert_eq!(result[2], &x2 * &x2);\n        assert_eq!(result[3], &x3 * &x3);\n    }\n\n    #[test]\n    fn test_unpack_repack_pair() {\n        let x0 = FieldElement51([10000 + (10001 << 26), 0, 0, 0, 0]);\n        let x1 = FieldElement51([10100 + (10101 << 26), 0, 0, 0, 0]);\n        let x2 = FieldElement51([10200 + (10201 << 26), 0, 0, 0, 0]);\n        let x3 = FieldElement51([10300 + (10301 << 26), 0, 0, 0, 0]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let src = vec.0[0];\n\n        let (a, b) = unpack_pair(src);\n\n        let expected_a = u32x8::new(10000, 0, 10100, 0, 10200, 0, 10300, 0);\n        let expected_b = u32x8::new(10001, 0, 10101, 0, 10201, 0, 10301, 0);\n\n        assert_eq!(a, expected_a);\n        assert_eq!(b, expected_b);\n\n        let expected_src = repack_pair(a, b);\n\n        assert_eq!(src, expected_src);\n    }\n\n    #[test]\n    fn new_split_roundtrips() {\n        let x0 = FieldElement51::from_bytes(&[0x10; 32]);\n        let x1 = FieldElement51::from_bytes(&[0x11; 32]);\n        let x2 = FieldElement51::from_bytes(&[0x12; 32]);\n        let x3 = FieldElement51::from_bytes(&[0x13; 32]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let splits = vec.split();\n\n        assert_eq!(x0, splits[0]);\n        assert_eq!(x1, splits[1]);\n        assert_eq!(x2, splits[2]);\n        assert_eq!(x3, splits[3]);\n    }\n}",
    "display_name": "blend",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/chunks",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "chunks",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/AsRef/as_ref",
    "statement_type": "function",
    "deps": [],
    "body": "    fn as_ref(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.secret_key.ct_eq(&other.secret_key)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/VartimePrecomputedStraus/is_empty",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core exact_size/traits/iter/ExactSizeIterator/is_empty",
      "5.0.0_pre.0 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/is_empty"
    ],
    "body": "//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
    "display_name": "is_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 inner_spec/test_specialized",
    "statement_type": "function",
    "deps": [],
    "body": "    fn test_specialized() {\n        assert!(!IS_AVX2);\n    }",
    "display_name": "test_specialized",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_mult_by_basepoint_order",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "5.0.0_pre.0 traits/IsIdentity/is_identity"
    ],
    "body": "    fn basepoint_mult_by_basepoint_order() {\n        let should_be_id = EdwardsPoint::mul_base(&constants::BASEPOINT_ORDER);\n        assert!(should_be_id.is_identity());\n    }",
    "display_name": "basepoint_mult_by_basepoint_order",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "UnwrapErr/RngCore/fill_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "fill_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 bot_half",
    "statement_type": "function",
    "deps": [],
    "body": "        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }",
    "display_name": "bot_half",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 vectors/serialize_signature",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 scalar/Scalar/as_bytes",
      "alloc https:/github.com/rust_lang/rust/library/alloc slice/concat"
    ],
    "body": "    fn serialize_signature(r: &EdwardsPoint, s: &Scalar) -> Vec<u8> {\n        [&r.compress().as_bytes()[..], &s.as_bytes()[..]].concat()\n    }",
    "display_name": "serialize_signature",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_fundamental_div_mod",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_fundamental_div_mod",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_borrow_and_mask_bounded",
    "statement_type": "function",
    "deps": [],
    "body": "pub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}",
    "display_name": "lemma_borrow_and_mask_bounded",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "ConditionallySelectable/conditional_assign"
    ],
    "body": "    ///\n    /// The inverse is computed as self^(p-2), since\n    /// x^(p-2)x = x^(p-1) = 1 (mod p).\n    ///\n    /// This function returns zero on input zero.\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    pub(crate) fn invert(&self) -> FieldElement {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);            // 254..5\n        let t21 = &t20 * &t3;              // 254..5,3,1,0\n\n        t21\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 vartime/test/edwards/multiscalar_mul_vs_ed25519py",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress"
    ],
    "body": "        fn multiscalar_mul_vs_ed25519py() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result = EdwardsPoint::vartime_multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n            assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n        }",
    "display_name": "multiscalar_mul_vs_ed25519py",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "Array/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u32x8/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/scalarmult_extended_point_works_both_ways",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/to_bytes"
    ],
    "body": "    fn scalarmult_extended_point_works_both_ways() {\n        let G: EdwardsPoint = constants::ED25519_BASEPOINT_POINT;\n        let s: Scalar = A_SCALAR;\n\n        let P1 = G * s;\n        let P2 = s * G;\n\n        assert!(P1.compress().to_bytes() == P2.compress().to_bytes());\n    }",
    "display_name": "scalarmult_extended_point_works_both_ways",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/double_and_compress_batch",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "double_and_compress_batch",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/from_slice"
    ],
    "body": "    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/raw_verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/RCompute/compute",
      "3.0.0_pre.0 signature/InternalSignature/TryFrom/try_from",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "///\n/// `CtxDigest` is the digest used to calculate the pseudorandomness needed for signing. According\n/// to the Ed25519 spec, `CtxDigest = Sha512`.\n///\n/// #   Cryptographically Unsafe\n///\n/// Do NOT use this function unless you absolutely must. Using the wrong values in\n/// `ExpandedSecretKey` can leak your signing key. See\n/// [here](https://github.com/MystenLabs/ed25519-unsafe-libs) for more details on this attack.\npub fn raw_sign_byupdate<CtxDigest, F>(\n    esk: &ExpandedSecretKey,\n    msg_update: F,\n    verifying_key: &VerifyingKey,\n) -> Result<Signature, SignatureError>\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n    F: Fn(&mut CtxDigest) -> Result<(), SignatureError>,\n{\n    esk.raw_sign_byupdate::<CtxDigest, F>(msg_update, verifying_key)\n}",
    "display_name": "raw_verify",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/batch_invert_a_matches_nonbatched",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/invert",
      "5.0.0_pre.0 field/FieldElement51/batch_invert",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Clone/clone",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes"
    ],
    "body": "    fn batch_invert_a_matches_nonbatched() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ap58 = FieldElement::from_bytes(&AP58_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        let a0 = &a - &a;\n        let a2 = &a + &a;\n        let a_list = vec![a, ap58, asq, ainv, a0, a2];\n        let mut ainv_list = a_list.clone();\n        FieldElement::batch_invert(&mut ainv_list[..]);\n        for i in 0..6 {\n            assert_eq!(a_list[i].invert(), ainv_list[i]);\n        }\n    }",
    "display_name": "batch_invert_a_matches_nonbatched",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 process_mod",
    "statement_type": "function",
    "deps": [
      "0.1.1 is_path_eq",
      "core https:/github.com/rust_lang/rust/library/core slice/contains",
      "1.0.95 TokenStream/Default/default",
      "attr/MetaList/parse_args",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/remove",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "core https:/github.com/rust_lang/rust/library/core mem/replace",
      "0.1.1 process_item",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len",
      "lit/LitStr/value",
      "error/Error/into_compile_error"
    ],
    "body": "fn process_mod(\n    attributes: &syn::LitStr,\n    mut item_mod: syn::ItemMod,\n    spec_features: Option<Vec<String>>,\n) -> TokenStream2 {\n    if let Some((_, ref mut content)) = item_mod.content {\n        'next_item: for item in content {\n            if let Some(ref spec_features) = spec_features {\n                match item {\n                    syn::Item::Const(syn::ItemConst { ref mut attrs, .. })\n                    | syn::Item::Enum(syn::ItemEnum { ref mut attrs, .. })\n                    | syn::Item::ExternCrate(syn::ItemExternCrate { ref mut attrs, .. })\n                    | syn::Item::Fn(syn::ItemFn { ref mut attrs, .. })\n                    | syn::Item::ForeignMod(syn::ItemForeignMod { ref mut attrs, .. })\n                    | syn::Item::Impl(syn::ItemImpl { ref mut attrs, .. })\n                    | syn::Item::Macro(syn::ItemMacro { ref mut attrs, .. })\n                    | syn::Item::Mod(syn::ItemMod { ref mut attrs, .. })\n                    | syn::Item::Static(syn::ItemStatic { ref mut attrs, .. })\n                    | syn::Item::Struct(syn::ItemStruct { ref mut attrs, .. })\n                    | syn::Item::Trait(syn::ItemTrait { ref mut attrs, .. })\n                    | syn::Item::TraitAlias(syn::ItemTraitAlias { ref mut attrs, .. })\n                    | syn::Item::Type(syn::ItemType { ref mut attrs, .. })\n                    | syn::Item::Union(syn::ItemUnion { ref mut attrs, .. })\n                    | syn::Item::Use(syn::ItemUse { ref mut attrs, .. }) => {\n                        let mut index = 0;\n                        while index < attrs.len() {\n                            let attr = &attrs[index];\n                            if matches!(attr.style, syn::AttrStyle::Outer) {\n                                match attr.meta {\n                                    syn::Meta::List(ref list)\n                                        if is_path_eq(&list.path, \"for_target_feature\") =>\n                                    {\n                                        let feature: syn::LitStr = match list.parse_args() {\n                                            Ok(feature) => feature,\n                                            Err(error) => {\n                                                return error.into_compile_error();\n                                            }\n                                        };\n\n                                        let feature = feature.value();\n                                        if !spec_features.contains(&feature) {\n                                            *item = syn::Item::Verbatim(Default::default());\n                                            continue 'next_item;\n                                        }\n\n                                        attrs.remove(index);\n                                        continue;\n                                    }\n                                    _ => {}\n                                }\n                            }\n\n                            index += 1;\n                            continue;\n                        }\n                    }\n                    _ => {\n                        unsupported!(item_mod);\n                    }\n                }\n            }\n\n            *item = syn::Item::Verbatim(\n                process_item(\n                    attributes,\n                    std::mem::replace(item, syn::Item::Verbatim(Default::default())),\n                    false,\n                )\n                .into(),\n            );\n        }\n    }\n\n    quote::quote! {\n        #item_mod\n    }\n}",
    "display_name": "process_mod",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 vstd_u128/u64/serial/backend/lemma_u128_pow2_no_overflow",
    "statement_type": "function",
    "deps": [],
    "body": "lemma_pow2_no_overflow!(lemma_u128_pow2_no_overflow, u128);\n\nmacro_rules! lemma_low_bits_mask_is_mod {\n    ($name:ident, $and_split_low_bit:ident, $no_overflow:ident, $uN:ty) => {\n        verus! {\n        pub broadcast proof fn $name(x: $uN, n: nat)\n            requires\n                n < <$uN>::BITS,\n            ensures\n                #[trigger] (x & (low_bits_mask(n) as $uN)) == x % (pow2(n) as $uN),\n            decreases n,\n        {\n            // Bounds.\n            $no_overflow(n);\n            lemma_pow2_pos(n);\n            assert(pow2(0) == 1) by {\n                lemma2_to64();\n            }\n\n            // Inductive proof.\n            if n == 0 {\n                assert(low_bits_mask(0) == 0);\n                assert(x & 0 == 0) by (bit_vector);\n                assert(pow2(0) == 1);\n                assert(x % 1 == 0);\n            } else {\n                lemma_pow2_unfold(n);\n                assert((x % 2) == ((x % 2) & 1)) by (bit_vector);\n                calc!{ (==)\n                    x % (pow2(n) as $uN);\n                        {}\n                    x % ((2 * pow2((n-1) as nat)) as $uN);\n                        {\n                            lemma_pow2_pos((n-1) as nat);\n                            lemma_mod_breakdown(x as int, 2, pow2((n-1) as nat) as int);\n                        }\n                    add(mul(2, (x / 2) % (pow2((n-1) as nat) as $uN)), x % 2);\n                        {\n                            $name(x/2, (n-1) as nat);\n                        }\n                    add(mul(2, (x / 2) & (low_bits_mask((n-1) as nat) as $uN)), x % 2);\n                        {\n                            lemma_low_bits_mask_div2(n);\n                        }\n                    add(mul(2, (x / 2) & (low_bits_mask(n) as $uN / 2)), x % 2);\n                        {\n                            lemma_low_bits_mask_is_odd(n);\n                        }\n                    add(mul(2, (x / 2) & (low_bits_mask(n) as $uN / 2)), (x % 2) & ((low_bits_mask(n) as $uN) % 2));\n                        {\n                            $and_split_low_bit(x as $uN, low_bits_mask(n) as $uN);\n                        }\n                    x & (low_bits_mask(n) as $uN);\n                }\n            }\n        }\n\n        // Helper lemma breaking a bitwise-and operation into the low bit and the rest.\n        proof fn $and_split_low_bit(x: $uN, m: $uN)\n            by (bit_vector)\n            ensures\n                x & m == add(mul(((x / 2) & (m / 2)), 2), (x % 2) & (m % 2)),\n        {\n        }\n        }\n    };\n}",
    "display_name": "lemma_u128_pow2_no_overflow",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/vstd_u128.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/vstd_u128.rs",
    "file_name": "vstd_u128.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_bits_be",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "Choice/From/from",
      "5.0.0_pre.0 montgomery/ProjectivePoint/as_affine",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "Zeroize/zeroize",
      "5.0.0_pre.0 montgomery/differential_add_and_double",
      "ConditionallySelectable/conditional_swap"
    ],
    "body": "    pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2\n        let mut prev_bit = false;\n        for cur_bit in bits {\n            let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        #[cfg(feature = \"zeroize\")]\n        prev_bit.zeroize();\n\n        x0.as_affine()\n    }",
    "display_name": "mul_bits_be",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core option/Option/is_some",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_some",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/chain",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "chain",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 blend_lanes",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_blend_epi32",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "        fn blend_lanes(x: u32x8, y: u32x8, control: Lanes) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n\n                // This would be much cleaner if we could factor out the match\n                // statement on the control. Unfortunately, rustc forgets\n                // constant-info very quickly, so we can't even write\n                // ```\n                // match control {\n                //     Lanes::C => {\n                //         let imm = C_LANES as i32;\n                //         _mm256_blend_epi32(..., imm)\n                // ```\n                // let alone\n                // ```\n                // let imm = match control {\n                //     Lanes::C => C_LANES as i32,\n                // }\n                // _mm256_blend_epi32(..., imm)\n                // ```\n                // even though both of these would be constant-folded by LLVM\n                // at a lower level (as happens in the shuffle implementation,\n                // which does not require a shuffle immediate but *is* lowered\n                // to immediate shuffles anyways).\n                match control {\n                    Lanes::C => _mm256_blend_epi32(x.into(), y.into(), C_LANES as i32).into(),\n                    Lanes::D => _mm256_blend_epi32(x.into(), y.into(), D_LANES as i32).into(),\n                    Lanes::AD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::AB => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | B_LANES) as i32).into()\n                    }\n                    Lanes::AC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::CD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (C_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::BC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (B_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::ABCD => _mm256_blend_epi32(\n                        x.into(),\n                        y.into(),\n                        (A_LANES | B_LANES | C_LANES | D_LANES) as i32,\n                    )\n                    .into(),\n                }\n            }\n        }\n\n        FieldElement2625x4([\n            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n\n    /// Convenience wrapper around `new(x,x,x,x)`.\n    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }\n\n    /// Create a `FieldElement2625x4` from four `FieldElement51`s.\n    ///\n    /// # Postconditions\n    ///\n    /// The resulting `FieldElement2625x4` is bounded with \\\\( b < 0.0002 \\\\).\n    #[rustfmt::skip] // keep alignment of computed lanes\n    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> FieldElement2625x4 {\n        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }\n\n        // We don't know that the original `FieldElement51`s were\n        // fully reduced, so the odd limbs may exceed 2^25.\n        // Reduce them to be sure.\n        FieldElement2625x4(buf).reduce()\n    }\n\n    /// Given \\\\((A,B,C,D)\\\\), compute \\\\((-A,-B,-C,-D)\\\\), without\n    /// performing a reduction.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.999 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1 \\\\).\n    #[inline]\n    pub fn negate_lazy(&self) -> FieldElement2625x4 {\n        // The limbs of self are bounded with b < 0.999, while the\n        // smallest limb of 2*p is 67108845 > 2^{26+0.9999}, so\n        // underflows are not possible.\n        FieldElement2625x4([\n            P_TIMES_2_LO - self.0[0],\n            P_TIMES_2_HI - self.0[1],\n            P_TIMES_2_HI - self.0[2],\n            P_TIMES_2_HI - self.0[3],\n            P_TIMES_2_HI - self.0[4],\n        ])\n    }\n\n    /// Given `self = (A,B,C,D)`, compute `(B - A, B + A, D - C, D + C)`.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.01 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1.6 \\\\).\n    #[inline]\n    pub fn diff_sum(&self) -> FieldElement2625x4 {\n        // tmp1 = (B, A, D, C)\n        let tmp1 = self.shuffle(Shuffle::BADC);\n        // tmp2 = (-A, B, -C, D)\n        let tmp2 = self.blend(self.negate_lazy(), Lanes::AC);\n        // (B - A, B + A, D - C, D + C) bounded with b < 1.6\n        tmp1 + tmp2\n    }\n\n    /// Reduce this vector of field elements \\\\(\\mathrm{mod} p\\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.0002 \\\\).\n    #[inline]\n    pub fn reduce(&self) -> FieldElement2625x4 {\n        let shifts = u32x8::new(26, 26, 25, 25, 26, 26, 25, 25);\n        let masks = u32x8::new(\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n        );\n\n        // Let c(x) denote the carryout of the coefficient x.\n        //\n        // Given    (   x0,    y0,    x1,    y1,    z0,    w0,    z1,    w1),\n        // compute  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0)).\n        //\n        // The carryouts are bounded by 2^(32 - 25) = 2^7.\n        let rotated_carryout = |v: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_shuffle_epi32;\n                use core::arch::x86_64::_mm256_srlv_epi32;\n\n                let c = _mm256_srlv_epi32(v.into(), shifts.into());\n                _mm256_shuffle_epi32(c, 0b01_00_11_10).into()\n            }\n        };\n\n        // Combine (lo, lo, lo, lo, lo, lo, lo, lo)\n        //    with (hi, hi, hi, hi, hi, hi, hi, hi)\n        //      to (lo, lo, hi, hi, lo, lo, hi, hi)\n        //\n        // This allows combining carryouts, e.g.,\n        //\n        // lo  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0))\n        // hi  (c(x3), c(y3), c(x2), c(y2), c(z3), c(w3), c(z2), c(w2))\n        // ->  (c(x1), c(y1), c(x2), c(y2), c(z1), c(w1), c(z2), c(w2))\n        //\n        // which is exactly the vector of carryins for\n        //\n        //     (   x2,    y2,    x3,    y3,    z2,    w2,    z3,    w3).\n        //\n        let combine = |v_lo: u32x8, v_hi: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(v_lo.into(), v_hi.into(), 0b11_00_11_00).into()\n            }\n        };\n\n        let mut v = self.0;\n\n        let c10 = rotated_carryout(v[0]);\n        v[0] = (v[0] & masks) + combine(u32x8::splat(0), c10);\n\n        let c32 = rotated_carryout(v[1]);\n        v[1] = (v[1] & masks) + combine(c10, c32);\n\n        let c54 = rotated_carryout(v[2]);\n        v[2] = (v[2] & masks) + combine(c32, c54);\n\n        let c76 = rotated_carryout(v[3]);\n        v[3] = (v[3] & masks) + combine(c54, c76);\n\n        let c98 = rotated_carryout(v[4]);\n        v[4] = (v[4] & masks) + combine(c76, c98);\n\n        let c9_19: u32x8 = unsafe {\n            use core::arch::x86_64::_mm256_mul_epu32;\n            use core::arch::x86_64::_mm256_shuffle_epi32;\n\n            // Need to rearrange c98, since vpmuludq uses the low\n            // 32-bits of each 64-bit lane to compute the product:\n            //\n            // c98       = (c(x9), c(y9), c(x8), c(y8), c(z9), c(w9), c(z8), c(w8));\n            // c9_spread = (c(x9), c(x8), c(y9), c(y8), c(z9), c(z8), c(w9), c(w8)).\n            let c9_spread = _mm256_shuffle_epi32(c98.into(), 0b11_01_10_00);\n\n            // Since the carryouts are bounded by 2^7, their products with 19\n            // are bounded by 2^11.25.  This means that\n            //\n            // c9_19_spread = (19*c(x9), 0, 19*c(y9), 0, 19*c(z9), 0, 19*c(w9), 0).\n            let c9_19_spread = _mm256_mul_epu32(c9_spread, u64x4::splat(19).into());\n\n            // Unshuffle:\n            // c9_19 = (19*c(x9), 19*c(y9), 0, 0, 19*c(z9), 19*c(w9), 0, 0).\n            _mm256_shuffle_epi32(c9_19_spread, 0b11_01_10_00).into()\n        };\n\n        // Add the final carryin.\n        v[0] += c9_19;\n\n        // Each output coefficient has exactly one carryin, which is\n        // bounded by 2^11.25, so they are bounded as\n        //\n        // c_even < 2^26 + 2^11.25 < 26.00006 < 2^{26+b}\n        // c_odd  < 2^25 + 2^11.25 < 25.0001  < 2^{25+b}\n        //\n        // where b = 0.0002.\n        FieldElement2625x4(v)\n    }\n\n    /// Given an array of wide coefficients, reduce them to a `FieldElement2625x4`.\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[inline]\n    #[rustfmt::skip] // keep alignment of carry chain\n    fn reduce64(mut z: [u64x4; 10]) -> FieldElement2625x4 {\n        // These aren't const because splat isn't a const fn\n        let LOW_25_BITS: u64x4 = u64x4::splat((1 << 25) - 1);\n        let LOW_26_BITS: u64x4 = u64x4::splat((1 << 26) - 1);\n\n        // Carry the value from limb i = 0..8 to limb i+1\n        let carry = |z: &mut [u64x4; 10], i: usize| {\n            debug_assert!(i < 9);\n            if i % 2 == 0 {\n                // Even limbs have 26 bits\n                z[i + 1] += z[i].shr::<26>();\n                z[i] &= LOW_26_BITS;\n            } else {\n                // Odd limbs have 25 bits\n                z[i + 1] += z[i].shr::<25>();\n                z[i] &= LOW_25_BITS;\n            }\n        };\n\n        // Perform two halves of the carry chain in parallel.\n        carry(&mut z, 0); carry(&mut z, 4);\n        carry(&mut z, 1); carry(&mut z, 5);\n        carry(&mut z, 2); carry(&mut z, 6);\n        carry(&mut z, 3); carry(&mut z, 7);\n        // Since z[3] < 2^64, c < 2^(64-25) = 2^39,\n        // so    z[4] < 2^26 + 2^39 < 2^39.0002\n        carry(&mut z, 4); carry(&mut z, 8);\n        // Now z[4] < 2^26\n        // and z[5] < 2^25 + 2^13.0002 < 2^25.0004 (good enough)\n\n        // Last carry has a multiplication by 19.  In the serial case we\n        // do a 64-bit multiplication by 19, but here we want to do a\n        // 32-bit multiplication.  However, if we only know z[9] < 2^64,\n        // the carry is bounded as c < 2^(64-25) = 2^39, which is too\n        // big.  To ensure c < 2^32, we would need z[9] < 2^57.\n        // Instead, we split the carry in two, with c = c_0 + c_1*2^26.\n\n        let c = z[9].shr::<25>();\n        z[9] &= LOW_25_BITS;\n        let mut c0: u64x4 = c & LOW_26_BITS; // c0 < 2^26;\n        let mut c1: u64x4 = c.shr::<26>();         // c1 < 2^(39-26) = 2^13;\n\n        let x19 = u64x4::splat(19);\n        c0 = u32x8::from(c0).mul32(u32x8::from(x19));\n        c1 = u32x8::from(c1).mul32(u32x8::from(x19));\n\n        z[0] += c0; // z0 < 2^26 + 2^30.25 < 2^30.33\n        z[1] += c1; // z1 < 2^25 + 2^17.25 < 2^25.0067\n        carry(&mut z, 0); // z0 < 2^26, z1 < 2^25.0067 + 2^4.33 = 2^25.007\n\n        // The output coefficients are bounded with\n        //\n        // b = 0.007  for z[1]\n        // b = 0.0004 for z[5]\n        // b = 0      for other z[i].\n        //\n        // So the packed result is bounded with b = 0.007.\n        FieldElement2625x4([\n            repack_pair(z[0].into(), z[1].into()),\n            repack_pair(z[2].into(), z[3].into()),\n            repack_pair(z[4].into(), z[5].into()),\n            repack_pair(z[6].into(), z[7].into()),\n            repack_pair(z[8].into(), z[9].into()),\n        ])\n    }\n\n    /// Square this field element, and negate the result's \\\\(D\\\\) value.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 1.5 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[rustfmt::skip] // keep alignment of z* calculations\n    pub fn square_and_negate_D(&self) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let x0_2 = x0.shl::<1>();\n        let x1_2 = x1.shl::<1>();\n        let x2_2 = x2.shl::<1>();\n        let x3_2 = x3.shl::<1>();\n        let x4_2 = x4.shl::<1>();\n        let x5_2 = x5.shl::<1>();\n        let x6_2 = x6.shl::<1>();\n        let x7_2 = x7.shl::<1>();\n\n        let x5_19 = m_lo(v19, x5);\n        let x6_19 = m_lo(v19, x6);\n        let x7_19 = m_lo(v19, x7);\n        let x8_19 = m_lo(v19, x8);\n        let x9_19 = m_lo(v19, x9);\n\n        let mut z0 = m(x0,   x0) + m(x2_2, x8_19) + m(x4_2, x6_19) + ((m(x1_2, x9_19) +   m(x3_2, x7_19) +    m(x5,   x5_19)).shl::<1>());\n        let mut z1 = m(x0_2, x1) + m(x3_2, x8_19) + m(x5_2, x6_19) +                    ((m(x2,   x9_19) +    m(x4,   x7_19)).shl::<1>());\n        let mut z2 = m(x0_2, x2) + m(x1_2,    x1) + m(x4_2, x8_19) +   m(x6,   x6_19) + ((m(x3_2, x9_19) +    m(x5_2, x7_19)).shl::<1>());\n        let mut z3 = m(x0_2, x3) + m(x1_2,    x2) + m(x5_2, x8_19) +                    ((m(x4,   x9_19) +    m(x6,   x7_19)).shl::<1>());\n        let mut z4 = m(x0_2, x4) + m(x1_2,  x3_2) + m(x2,      x2) +   m(x6_2, x8_19) + ((m(x5_2, x9_19) +    m(x7,   x7_19)).shl::<1>());\n        let mut z5 = m(x0_2, x5) + m(x1_2,    x4) + m(x2_2,    x3) +   m(x7_2, x8_19)                    +  ((m(x6,   x9_19)).shl::<1>());\n        let mut z6 = m(x0_2, x6) + m(x1_2,  x5_2) + m(x2_2,    x4) +   m(x3_2,    x3) +   m(x8,   x8_19) +  ((m(x7_2, x9_19)).shl::<1>());\n        let mut z7 = m(x0_2, x7) + m(x1_2,    x6) + m(x2_2,    x5) +   m(x3_2,    x4)                    +  ((m(x8,   x9_19)).shl::<1>());\n        let mut z8 = m(x0_2, x8) + m(x1_2,  x7_2) + m(x2_2,    x6) +   m(x3_2,  x5_2) +   m(x4,      x4) +  ((m(x9,   x9_19)).shl::<1>());\n        let mut z9 = m(x0_2, x9) + m(x1_2,    x8) + m(x2_2,    x7) +   m(x3_2,    x6) +   m(x4_2,    x5)                                 ;\n\n        // The biggest z_i is bounded as z_i < 249*2^(51 + 2*b);\n        // if b < 1.5 we get z_i < 4485585228861014016.\n        //\n        // The limbs of the multiples of p are bounded above by\n        //\n        // 0x3fffffff << 37 = 9223371899415822336 < 2^63\n        //\n        // and below by\n        //\n        // 0x1fffffff << 37 = 4611685880988434432\n        //                  > 4485585228861014016\n        //\n        // So these multiples of p are big enough to avoid underflow\n        // in subtraction, and small enough to fit within u64\n        // with room for a carry.\n\n        let low__p37 = u64x4::splat(0x3ffffed << 37);\n        let even_p37 = u64x4::splat(0x3ffffff << 37);\n        let odd__p37 = u64x4::splat(0x1ffffff << 37);\n\n        let negate_D = |x: u64x4, p: u64x4| -> u64x4 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(x.into(), (p - x).into(), D_LANES64 as i32).into()\n            }\n        };\n\n        z0 = negate_D(z0, low__p37);\n        z1 = negate_D(z1, odd__p37);\n        z2 = negate_D(z2, even_p37);\n        z3 = negate_D(z3, odd__p37);\n        z4 = negate_D(z4, even_p37);\n        z5 = negate_D(z5, odd__p37);\n        z6 = negate_D(z6, even_p37);\n        z7 = negate_D(z7, odd__p37);\n        z8 = negate_D(z8, even_p37);\n        z9 = negate_D(z9, odd__p37);\n\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}",
    "display_name": "blend_lanes",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/constants/test_sqrt_constants_sign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/invsqrt",
      "From/from"
    ],
    "body": "    fn test_sqrt_constants_sign() {\n        let minus_one = FieldElement::MINUS_ONE;\n        let (was_nonzero_square, invsqrt_m1) = minus_one.invsqrt();\n        assert!(bool::from(was_nonzero_square));\n        let sign_test_sqrt = &invsqrt_m1 * &constants::SQRT_M1;\n        assert_eq!(sign_test_sqrt, minus_one);\n    }",
    "display_name": "test_sqrt_constants_sign",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_reduce",
    "statement_type": "function",
    "deps": [
      "mul/arithmetic/lemma_mul_is_distributive_sub_other_way",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat",
      "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_boundaries",
      "mul/arithmetic/lemma_mul_is_associative",
      "mul/arithmetic/lemma_mul_is_distributive_add",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/p",
      "5.0.0_pre.0 field_verus/u64/serial/backend/spec_reduce",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/pow255_gt_19",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_two_factoring_51",
      "5.0.0_pre.0 field_verus/u64/serial/backend/l51_bit_mask_lt",
      "power2/arithmetic/pow2",
      "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_div_and_mod_51",
      "div_mod/arithmetic/lemma_basic_div",
      "div_mod/arithmetic/lemma_small_mod",
      "power2/arithmetic/lemma_pow2_adds"
    ],
    "body": "pub proof fn lemma_reduce(limbs: [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52),\n        // Suppose l = (l0, l1, l2, l3, l4) are the input limbs.\n        // They represent a number\n        // e(l) =  l0 + l1 * 2^51 + l2 * 2^102 + l3 * 2^153 + l4 * 2^204\n        // in Z_p, for p = 2^255 - 19\n        // reduce(l) returns v = (v0, v1, v2, v3, v4), such that\n        // v0 = 19 * a4 + b0\n        // v1 =      a0 + b1\n        // v2 =      a1 + b2\n        // v3 =      a2 + b3\n        // v4 =      a3 + b4\n        // where ai = li >> 51 and bi = li & LOW_51_BIT_MASK\n        // we can reformulate this as ai = li / 2^51 (flooring division) and bi = li % 2^51\n        // Using the following identity connecting integer division and remainder:\n        // x = y * (x / y) + x % y\n        // we can see that li = ai * 2^51 + bi\n        // Plugging the above identities into the equations for v, we can observe that\n        // e(v) = e(l) - p * (l4 >> 51)\n        // IOW, e(reduce(l)) = e(l) (mod p)\n        // additionally, if all limbs are below 2^51, reduce(l) = l\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (spec_reduce(limbs) =~= limbs),\n        as_nat(spec_reduce(limbs)) == as_nat(limbs) - p() * (limbs[4] >> 51)\n{\n\n    // -----\n    // reduce identity for small limbs\n\n    // Can't seem to reference r within this proof block, we reconstruct it here\n    let rr: [u64; 5] = spec_reduce(limbs);\n\n    assert((forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) ==> (rr =~= limbs)) by {\n        if (forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) {\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] & LOW_51_BIT_MASK == limbs[i] by {\n                l51_bit_mask_lt(); // LOW_51_BIT_MASK = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_low_bits_mask_is_mod(limbs[i], 51);\n                lemma_small_mod(limbs[i] as nat, pow2(51));\n            }\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] >> 51 == 0 by {\n                l51_bit_mask_lt(); // LOW_51_BIT_MASK = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_shr_is_div(limbs[i], 51);\n                lemma_basic_div(limbs[i] as int, pow2(51) as int);\n            }\n        }\n    }\n\n    // -- as_nat identity\n\n    // ai = limbs[i] / 2^52\n    let a0 = (limbs[0] >> 51);\n    let a1 = (limbs[1] >> 51);\n    let a2 = (limbs[2] >> 51);\n    let a3 = (limbs[3] >> 51);\n    let a4 = (limbs[4] >> 51);\n\n    // bi = limbs[i] % 2^52\n    let b0 = (limbs[0] & LOW_51_BIT_MASK);\n    let b1 = (limbs[1] & LOW_51_BIT_MASK);\n    let b2 = (limbs[2] & LOW_51_BIT_MASK);\n    let b3 = (limbs[3] & LOW_51_BIT_MASK);\n    let b4 = (limbs[4] & LOW_51_BIT_MASK);\n\n    lemma_boundaries(limbs);\n\n    // distribute\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(102) * a1 + pow2(102) * b2 +\n        pow2(153) * a2 + pow2(153) * b3 +\n        pow2(204) * a3 + pow2(204) * b4\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n    }\n\n    // factor out\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(51) * (pow2(51) * a1) + pow2(102) * b2 +\n        pow2(102) * (pow2(51) * a2) + pow2(153) * b3 +\n        pow2(153) * (pow2(51) * a3) + pow2(204) * b4\n    ) by {\n        lemma_two_factoring_51(51, a1);\n        lemma_two_factoring_51(102, a2);\n        lemma_two_factoring_51(153, a3);\n    }\n\n    // change groupings\n    assert(as_nat(rr) ==\n        (b0 + pow2(51) * a0) +\n        pow2(51) * (b1 + pow2(51) * a1) +\n        pow2(102) * (b2 + pow2(51) * a2) +\n        pow2(153) * (b3 + pow2(51) * a3) +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n    }\n\n    // invoke div/mod identity\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a0, b0, limbs[0]);\n        lemma_div_and_mod_51(a1, b1, limbs[1]);\n        lemma_div_and_mod_51(a2, b2, limbs[2]);\n        lemma_div_and_mod_51(a3, b3, limbs[3]);\n    }\n\n    // Add missing limbs[4] parts\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * limbs[4] - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a4, b4, limbs[4]);\n        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204)* (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }\n    }\n\n    // The solver can collect components of as_nat(limbs) automatically:\n    // as_nat(rr) == as_nat(limbs) - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    // ... as well as pull in minus\n    // as_nat(rr) == as_nat(limbs) - (pow2(204) * (pow2(51) * a4 ) - 19 * a4)\n\n    // collect components of p() * a4\n    assert(pow2(204) * (pow2(51) * a4) - 19 * a4 == p() * a4) by {\n        lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, a4 as int);\n        lemma_pow2_adds(204, 51);\n        lemma_mul_is_distributive_sub_other_way(a4 as int, pow2(255) as int, 19 );\n        pow255_gt_19(); // we need to prove 2^255 - 19 doesn't underflow\n    }\n}",
    "display_name": "lemma_reduce",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/len",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "len",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 spec/straus/scalar_mul/vector/backend/Straus/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Identity/identity",
      "Zeroizing/new",
      "core https:/github.com/rust_lang/rust/library/core convert/From/from",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/mul_by_pow_2",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev"
    ],
    "body": "        fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator,\n            J::Item: Borrow<EdwardsPoint>,\n        {\n            // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n            // for each input point P\n            let lookup_tables: Vec<_> = points\n                .into_iter()\n                .map(|point| LookupTable::<CachedPoint>::from(point.borrow()))\n                .collect();\n\n            let scalar_digits_vec: Vec<_> = scalars\n                .into_iter()\n                .map(|s| s.borrow().as_radix_16())\n                .collect();\n            // Pass ownership to a `Zeroizing` wrapper\n            #[cfg(feature = \"zeroize\")]\n            let scalar_digits_vec = Zeroizing::new(scalar_digits_vec);\n\n            let mut Q = ExtendedPoint::identity();\n            for j in (0..64).rev() {\n                Q = Q.mul_by_pow_2(4);\n                let it = scalar_digits_vec.iter().zip(lookup_tables.iter());\n                for (s_i, lookup_table_i) in it {\n                    // Q = Q + s_{i,j} * P_i\n                    Q = &Q + &lookup_table_i.select(s_i[j]);\n                }\n            }\n            Q.into()\n        }",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/Sub/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective_niels",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended"
    ],
    "body": "    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_to_nat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_to_nat_rec"
    ],
    "body": "\nverus! {\nimpl Index<usize> for Scalar52 {\n    type Output = u64;\n    // TODO Verify this\n    #[verifier::external_body]\n    fn index(&self, _index: usize) -> &u64 {\n        &(self.limbs[_index])\n    }\n}\n} // verus!",
    "display_name": "bytes_to_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/new"
    ],
    "body": "    fn from(P: edwards::EdwardsPoint) -> ExtendedPoint {\n        ExtendedPoint(FieldElement2625x4::new(&P.X, &P.Y, &P.Z, &P.T))\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/EphemeralSecret/Drop/drop",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/monte_carlo_overflow_underflow_debug_assert_test",
    "statement_type": "function",
    "deps": [],
    "body": "    fn monte_carlo_overflow_underflow_debug_assert_test() {\n        let mut P = constants::ED25519_BASEPOINT_POINT;\n        // N.B. each scalar_mul does 1407 field mults, 1024 field squarings,\n        // so this does ~ 1M of each operation.\n        for _ in 0..1_000 {\n            P *= &A_SCALAR;\n        }\n    }",
    "display_name": "monte_carlo_overflow_underflow_debug_assert_test",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/bits_le",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map"
    ],
    "body": "    pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n        (0..256).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }",
    "display_name": "bits_le",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_table_basepoint_function_correct",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsBasepointTable/BasepointTable/basepoint",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_table_basepoint_function_correct() {\n        let bp = ED25519_BASEPOINT_TABLE.basepoint();\n        assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n    }",
    "display_name": "basepoint_table_basepoint_function_correct",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_benches/scalar_arith",
    "statement_type": "function",
    "deps": [
      "bencher/Bencher/iter_batched",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "thread/rngs/rng",
      "5.0.0_pre.0 scalar/Scalar/invert",
      "bencher/Bencher/iter",
      "benchmark_group/BenchmarkGroup/bench_function",
      "5.0.0_pre.0 scalar/Scalar/random"
    ],
    "body": "    fn scalar_arith<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let mut rng = rng();\n\n        c.bench_function(\"Scalar inversion\", |b| {\n            let s = Scalar::from(897987897u64).invert();\n            b.iter(|| s.invert());\n        });\n        c.bench_function(\"Scalar addition\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a + b,\n                BatchSize::SmallInput,\n            );\n        });\n        c.bench_function(\"Scalar subtraction\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a - b,\n                BatchSize::SmallInput,\n            );\n        });\n        c.bench_function(\"Scalar multiplication\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a * b,\n                BatchSize::SmallInput,\n            );\n        });\n    }",
    "display_name": "scalar_arith",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_base_clamped",
      "os/OsRng/TryRngCore/try_fill_bytes",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_clamped",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap"
    ],
    "body": "    fn mul_base_clamped() {\n        let mut csprng = rand_core::OsRng;\n\n        // Test agreement on a large integer. Even after clamping, this is not reduced mod l.\n        let a_bytes = [0xff; 32];\n        assert_eq!(\n            MontgomeryPoint::mul_base_clamped(a_bytes),\n            constants::X25519_BASEPOINT.mul_clamped(a_bytes)\n        );\n\n        // Test agreement on random integers\n        for _ in 0..100 {\n            // This will be reduced mod l with probability l / 2^256  6.25%\n            let mut a_bytes = [0u8; 32];\n            csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n            assert_eq!(\n                MontgomeryPoint::mul_base_clamped(a_bytes),\n                constants::X25519_BASEPOINT.mul_clamped(a_bytes)\n            );\n        }\n    }",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/from_hash",
    "statement_type": "function",
    "deps": [
      "digest/Digest/finalize",
      "Array/as_slice",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "        // derived from `serialize_deserialize_signing_key_json` test\n        // trailing zero elements makes key too long (34 bytes)\n        let encoded_signing_key_too_long = \"[62,70,27,163,92,182,11,3,77,234,98,4,11,127,79,228,243,187,150,73,201,137,76,22,85,251,152,2,241,42,72,54,0,0]\";\n        let de_err = serde_json::from_str::<SigningKey>(encoded_signing_key_too_long)\n            .unwrap_err()\n            .to_string();\n        assert!(\n            de_err.contains(\"invalid length 34\"),\n            \"expected invalid length error, got: {de_err}\",\n        );",
    "display_name": "from_hash",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/random_roundtrip",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/decompress",
      "5.0.0_pre.0 scalar/Scalar/random",
      "TryRngCore/unwrap_err",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 ristretto/RistrettoPoint/mul_base"
    ],
    "body": "    fn random_roundtrip() {\n        let mut rng = OsRng.unwrap_err();\n        for _ in 0..100 {\n            let P = RistrettoPoint::mul_base(&Scalar::random(&mut rng));\n            let compressed_P = P.compress();\n            let Q = compressed_P.decompress().unwrap();\n            assert_eq!(P, Q);\n        }\n    }",
    "display_name": "random_roundtrip",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/test_scalar_from_int",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/From/from"
    ],
    "body": "    fn test_scalar_from_int() {\n        let s1 = Scalar::ONE;\n\n        // For `x` in `u8`, `u16`, `u32`, `u64`, and `u128`, check that\n        // `Scalar::from(x + 1) == Scalar::from(x) + Scalar::from(1)`\n\n        let x = 0x23u8;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323u16;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323u32;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323_2323_2323u64;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323_2323_2323_2323_2323_2323_2323u128;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n    }",
    "display_name": "test_scalar_from_int",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/montgomery_radix",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul_internal",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat"
    ],
    "body": "                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Option::from(Scalar::from_canonical_bytes(bytes))\n                    .ok_or_else(|| serde::de::Error::custom(\"scalar was not canonically encoded\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\nimpl<T> Product<T> for Scalar\nwhere\n    T: Borrow<Scalar>,\n{\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n}",
    "display_name": "montgomery_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 backend/VartimePrecomputedStraus/new"
    ],
    "body": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(\n            static_points.into_iter().map(|P| P.borrow().0),\n        ))\n    }",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/LookupTable/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "de/from_str",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_str",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto_benches/decompress",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/decompress",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "bencher/Bencher/iter",
      "benchmark_group/BenchmarkGroup/bench_function"
    ],
    "body": "    fn decompress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"RistrettoPoint decompression\", |b| {\n            let B_comp = &constants::RISTRETTO_BASEPOINT_COMPRESSED;\n            b.iter(|| B_comp.decompress().unwrap())\n        });\n    }",
    "display_name": "decompress",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/encodings_of_small_multiples_of_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress"
    ],
    "body": "    fn encodings_of_small_multiples_of_basepoint() {\n        // Table of encodings of i*basepoint\n        // Generated using ristretto.sage\n        let compressed = [\n            CompressedRistretto([\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0,\n            ]),\n            CompressedRistretto([\n                226, 242, 174, 10, 106, 188, 78, 113, 168, 132, 169, 97, 197, 0, 81, 95, 88, 227,\n                11, 106, 165, 130, 221, 141, 182, 166, 89, 69, 224, 141, 45, 118,\n            ]),\n            CompressedRistretto([\n                106, 73, 50, 16, 247, 73, 156, 209, 127, 236, 181, 16, 174, 12, 234, 35, 161, 16,\n                232, 213, 185, 1, 248, 172, 173, 211, 9, 92, 115, 163, 185, 25,\n            ]),\n            CompressedRistretto([\n                148, 116, 31, 93, 93, 82, 117, 94, 206, 79, 35, 240, 68, 238, 39, 213, 209, 234,\n                30, 43, 209, 150, 180, 98, 22, 107, 22, 21, 42, 157, 2, 89,\n            ]),\n            CompressedRistretto([\n                218, 128, 134, 39, 115, 53, 139, 70, 111, 250, 223, 224, 179, 41, 58, 179, 217,\n                253, 83, 197, 234, 108, 149, 83, 88, 245, 104, 50, 45, 175, 106, 87,\n            ]),\n            CompressedRistretto([\n                232, 130, 177, 49, 1, 107, 82, 193, 211, 51, 112, 128, 24, 124, 247, 104, 66, 62,\n                252, 203, 181, 23, 187, 73, 90, 184, 18, 196, 22, 15, 244, 78,\n            ]),\n            CompressedRistretto([\n                246, 71, 70, 211, 201, 43, 19, 5, 14, 216, 216, 2, 54, 167, 240, 0, 124, 59, 63,\n                150, 47, 91, 167, 147, 209, 154, 96, 30, 187, 29, 244, 3,\n            ]),\n            CompressedRistretto([\n                68, 245, 53, 32, 146, 110, 200, 31, 189, 90, 56, 120, 69, 190, 183, 223, 133, 169,\n                106, 36, 236, 225, 135, 56, 189, 207, 166, 167, 130, 42, 23, 109,\n            ]),\n            CompressedRistretto([\n                144, 50, 147, 216, 242, 40, 126, 190, 16, 226, 55, 77, 193, 165, 62, 11, 200, 135,\n                229, 146, 105, 159, 2, 208, 119, 213, 38, 60, 221, 85, 96, 28,\n            ]),\n            CompressedRistretto([\n                2, 98, 42, 206, 143, 115, 3, 163, 28, 175, 198, 63, 143, 196, 143, 220, 22, 225,\n                200, 200, 210, 52, 178, 240, 214, 104, 82, 130, 169, 7, 96, 49,\n            ]),\n            CompressedRistretto([\n                32, 112, 111, 215, 136, 178, 114, 10, 30, 210, 165, 218, 212, 149, 43, 1, 244, 19,\n                188, 240, 231, 86, 77, 232, 205, 200, 22, 104, 158, 45, 185, 95,\n            ]),\n            CompressedRistretto([\n                188, 232, 63, 139, 165, 221, 47, 165, 114, 134, 76, 36, 186, 24, 16, 249, 82, 43,\n                198, 0, 74, 254, 149, 135, 122, 199, 50, 65, 202, 253, 171, 66,\n            ]),\n            CompressedRistretto([\n                228, 84, 158, 225, 107, 154, 160, 48, 153, 202, 32, 140, 103, 173, 175, 202, 250,\n                76, 63, 62, 78, 83, 3, 222, 96, 38, 227, 202, 143, 248, 68, 96,\n            ]),\n            CompressedRistretto([\n                170, 82, 224, 0, 223, 46, 22, 245, 95, 177, 3, 47, 195, 59, 196, 39, 66, 218, 214,\n                189, 90, 143, 192, 190, 1, 103, 67, 108, 89, 72, 80, 31,\n            ]),\n            CompressedRistretto([\n                70, 55, 107, 128, 244, 9, 178, 157, 194, 181, 246, 240, 197, 37, 145, 153, 8, 150,\n                229, 113, 111, 65, 71, 124, 211, 0, 133, 171, 127, 16, 48, 30,\n            ]),\n            CompressedRistretto([\n                224, 196, 24, 247, 200, 217, 196, 205, 215, 57, 91, 147, 234, 18, 79, 58, 217, 144,\n                33, 187, 104, 29, 252, 51, 2, 169, 217, 154, 46, 83, 230, 78,\n            ]),\n        ];\n        let mut bp = RistrettoPoint::identity();\n        for point in compressed {\n            assert_eq!(bp.compress(), point);\n            bp += constants::RISTRETTO_BASEPOINT_POINT;\n        }\n    }",
    "display_name": "encodings_of_small_multiples_of_basepoint",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/edwards_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards_benches/compress_batch",
      "5.0.0_pre.0 edwards_benches/vartime_double_base_scalar_mul",
      "5.0.0_pre.0 edwards_benches/decompress",
      "Criterion/benchmark_group",
      "5.0.0_pre.0 edwards_benches/hash_to_curve",
      "Criterion/Default/default",
      "5.0.0_pre.0 edwards_benches/consttime_variable_base_scalar_mul",
      "5.0.0_pre.0 edwards_benches/compress",
      "5.0.0_pre.0 edwards_benches/consttime_fixed_base_scalar_mul"
    ],
    "body": "    pub(crate) fn edwards_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"edwards benches\");\n\n        compress(&mut g);\n        decompress(&mut g);\n        #[cfg(feature = \"alloc\")]\n        compress_batch(&mut g);\n        consttime_fixed_base_scalar_mul(&mut g);\n        consttime_variable_base_scalar_mul(&mut g);\n        vartime_double_base_scalar_mul(&mut g);\n        hash_to_curve(&mut g);\n    }",
    "display_name": "edwards_benches",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/hash_from_bytes",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core default/Default/default",
      "5.0.0_pre.0 ristretto/RistrettoPoint/from_hash",
      "digest/Digest/update"
    ],
    "body": "    pub fn hash_from_bytes<D>(input: &[u8]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        RistrettoPoint::from_hash(hash)\n    }",
    "display_name": "hash_from_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/non_adjacent_form",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/read_le_u64_into",
      "core https:/github.com/rust_lang/rust/library/core num/wrapping_sub"
    ],
    "body": "    pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {\n        // required by the NAF definition\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        debug_assert!(w <= 8);\n\n        let mut naf = [0i8; 256];\n\n        let mut x_u64 = [0u64; 5];\n        read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }\n\n        naf\n    }",
    "display_name": "non_adjacent_form",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2",
      "5.0.0_pre.0 common_verus/u64/serial/backend/pow2_le_max64"
    ],
    "body": "\npub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]) ,\n        z[1] == (a[0] * a[1])  * 2,\n        z[2] == (a[0] * a[2])  * 2 + (a[1] * a[1]) ,\n        z[3] == (a[0] * a[3])  * 2 + (a[1] * a[2])  * 2,\n        z[4] == (a[0] * a[4])  * 2 + (a[1] * a[3])  * 2 + (a[2] * a[2]) ,\n        z[5] == (a[1] * a[4])  * 2 + (a[2] * a[3])  * 2,\n        z[6] == (a[2] * a[4])  * 2 + (a[3] * a[3]) ,\n        z[7] == (a[3] * a[4])  * 2,\n        z[8] == (a[4] * a[4]) ,\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n\n{\n        assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n            broadcast use group_mul_is_commutative_and_distributive;\n            broadcast use lemma_mul_is_associative;\n\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(52, 104);\n            lemma_pow2_adds(52, 156);\n            lemma_pow2_adds(52, 208);\n            lemma_pow2_adds(104, 104);\n            lemma_pow2_adds(104, 156);\n            lemma_pow2_adds(104, 208);\n            lemma_pow2_adds(156, 156);\n            lemma_pow2_adds(156, 208);\n            lemma_pow2_adds(208, 208);\n        };\n        lemma_nine_limbs_equals_slice128_to_nat(&z);\n        lemma_five_limbs_equals_to_nat(&a);\n}",
    "display_name": "shift_is_pow2",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/partial_precomputed_multiscalar",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "thread/rngs/rng",
      "5.0.0_pre.0 ristretto/RistrettoPoint/random",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 scalar/Scalar/random",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len"
    ],
    "body": "    fn partial_precomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use one fewer scalars\n        let static_scalars = (0..n_static - 1)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_multiscalar_mul(&static_scalars);\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }",
    "display_name": "partial_precomputed_multiscalar",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/NafLookupTable5/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"NafLookupTable5({:?})\", self.0)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/is_canonical",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/ConstantTimeEq/ct_eq",
      "5.0.0_pre.0 scalar/Scalar/reduce"
    ],
    "body": "    fn is_canonical(&self) -> Choice {\n        self.ct_eq(&self.reduce())\n    }",
    "display_name": "is_canonical",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 function_with_rustfmt_skip",
    "statement_type": "function",
    "deps": [],
    "body": "fn function_with_rustfmt_skip() {}\n",
    "display_name": "function_with_rustfmt_skip",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/SharedSecret/as_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/as_bytes"
    ],
    "body": "    pub fn as_bytes(&self) -> &[u8; 32] {\n        self.0.as_bytes()\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar52/pack",
      "5.0.0_pre.0 scalar/Scalar/unpack",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/square"
    ],
    "body": "    fn square() {\n        let expected = X * X;\n        let actual = X.unpack().square().pack();\n        for i in 0..32 {\n            assert!(expected[i] == actual[i]);\n        }\n    }",
    "display_name": "square",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/decompression_sign_handling",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress"
    ],
    "body": "    fn decompression_sign_handling() {\n        // Manually set the high bit of the last byte to flip the sign\n        let mut minus_basepoint_bytes = *constants::ED25519_BASEPOINT_COMPRESSED.as_bytes();\n        minus_basepoint_bytes[31] |= 1 << 7;\n        let minus_basepoint = CompressedEdwardsY(minus_basepoint_bytes)\n            .decompress()\n            .unwrap();\n        // Test projective coordinates exactly since we know they should\n        // only differ by a flipped sign.\n        assert_eq!(minus_basepoint.X, -(&constants::ED25519_BASEPOINT_POINT.X));\n        assert_eq!(minus_basepoint.Y, constants::ED25519_BASEPOINT_POINT.Y);\n        assert_eq!(minus_basepoint.Z, constants::ED25519_BASEPOINT_POINT.Z);\n        assert_eq!(minus_basepoint.T, -(&constants::ED25519_BASEPOINT_POINT.T));\n    }",
    "display_name": "decompression_sign_handling",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "std https:/github.com/rust_lang/rust/library/std fs/File/open",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "open",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 rfc7748_ladder_test2",
    "statement_type": "function",
    "deps": [],
    "body": "fn rfc7748_ladder_test2() {\n    use curve25519_dalek::constants::X25519_BASEPOINT;\n\n    let mut k: [u8; 32] = X25519_BASEPOINT.0;\n    let mut u: [u8; 32] = X25519_BASEPOINT.0;\n    let mut result: [u8; 32];\n\n    macro_rules! do_iterations {\n        ($n:expr) => {\n            for _ in 0..$n {\n                result = x25519(k, u);\n                // OBVIOUS THING THAT I'M GOING TO NOTE ANYWAY BECAUSE I'VE\n                // SEEN PEOPLE DO THIS WITH GOLANG'S STDLIB AND YOU SURE AS\n                // HELL SHOULDN'T DO HORRIBLY STUPID THINGS LIKE THIS WITH\n                // MY LIBRARY:\n                //\n                // NEVER EVER TREAT SCALARS AS POINTS AND/OR VICE VERSA.\n                //\n                //                 DON'T DO THIS \n                u = k.clone();\n                k = result;\n            }\n        };\n    }\n\n    // After one iteration:\n    //     422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079\n    // After 1,000 iterations:\n    //     684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51\n    // After 1,000,000 iterations:\n    //     7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424\n\n    do_iterations!(1);\n    assert_eq!(\n        k,\n        [\n            0x42, 0x2c, 0x8e, 0x7a, 0x62, 0x27, 0xd7, 0xbc, 0xa1, 0x35, 0x0b, 0x3e, 0x2b, 0xb7,\n            0x27, 0x9f, 0x78, 0x97, 0xb8, 0x7b, 0xb6, 0x85, 0x4b, 0x78, 0x3c, 0x60, 0xe8, 0x03,\n            0x11, 0xae, 0x30, 0x79,\n        ]\n    );\n    do_iterations!(999);\n    assert_eq!(\n        k,\n        [\n            0x68, 0x4c, 0xf5, 0x9b, 0xa8, 0x33, 0x09, 0x55, 0x28, 0x00, 0xef, 0x56, 0x6f, 0x2f,\n            0x4d, 0x3c, 0x1c, 0x38, 0x87, 0xc4, 0x93, 0x60, 0xe3, 0x87, 0x5f, 0x2e, 0xb9, 0x4d,\n            0x99, 0x53, 0x2c, 0x51,\n        ]\n    );\n    do_iterations!(999_000);\n    assert_eq!(\n        k,\n        [\n            0x7c, 0x39, 0x11, 0xe0, 0xab, 0x25, 0x86, 0xfd, 0x86, 0x44, 0x97, 0x29, 0x7e, 0x57,\n            0x5e, 0x6f, 0x3b, 0xc6, 0x01, 0xc0, 0x88, 0x3c, 0x30, 0xdf, 0x5f, 0x4d, 0xd2, 0xd2,\n            0x4f, 0x66, 0x54, 0x24,\n        ]\n    );\n}",
    "display_name": "rfc7748_ladder_test2",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "1.0.95 Ident/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core option/Option/expect",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/optional_multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map"
    ],
    "body": "        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"multiscalar benches\");\n\n        consttime_multiscalar_mul(&mut g);\n        vartime_multiscalar_mul(&mut g);\n        vartime_precomputed_pure_static(&mut g);\n\n        let dynamic_fracs = [0.0, 0.2, 0.5];\n\n        for frac in dynamic_fracs.iter() {\n            vartime_precomputed_helper(&mut g, *frac);\n        }",
    "display_name": "vartime_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/compress_id",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/Identity/identity",
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity",
      "5.0.0_pre.0 ristretto/RistrettoPoint/compress"
    ],
    "body": "    fn compress_id() {\n        let id = RistrettoPoint::identity();\n        assert_eq!(id.compress(), CompressedRistretto::identity());\n    }",
    "display_name": "compress_id",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul_internal",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/slice128_to_nat",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_mul_internal_no_overflow",
      "5.0.0_pre.0 scalar/u64/serial/backend/m",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_mul_internal_correct"
    ],
    "body": "    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }",
    "display_name": "mul_internal",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_from_montgomery_limbs_conversion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat",
      "power2/arithmetic/pow2",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/slice128_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat"
    ],
    "body": "pub proof fn lemma_from_montgomery_limbs_conversion(\n    limbs: &[u128; 9],\n    self_limbs: &[u64; 5]\n)\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) +\n           (self_limbs[1] as nat) * pow2(52) +\n           (self_limbs[2] as nat) * pow2(104) +\n           (self_limbs[3] as nat) * pow2(156) +\n           (self_limbs[4] as nat) * pow2(208) +\n           0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(416));\n}",
    "display_name": "lemma_from_montgomery_limbs_conversion",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix128/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_div_and_mod",
    "statement_type": "function",
    "deps": [
      "bits/low_bits_mask",
      "power2/arithmetic/lemma_pow2_pos",
      "div_mod/arithmetic/lemma_fundamental_div_mod",
      "power2/arithmetic/lemma2_to64",
      "power2/arithmetic/lemma_pow2_strictly_increases",
      "power2/arithmetic/pow2",
      "power2/arithmetic/lemma2_to64_rest"
    ],
    "body": "pub proof fn lemma_div_and_mod(ai:u64, bi: u64, v: u64, k: nat)\n    requires\n        k < 64,\n        ai == v >> k,\n        bi == v & (low_bits_mask(k) as u64)\n    ensures\n        ai == v / (pow2(k) as u64),\n        bi == v % (pow2(k) as u64),\n        v == ai * pow2(k) + bi\n{\n    lemma2_to64();\n    lemma2_to64_rest(); // pow2(63) = 0x8000000000000000\n\n    // v >> k = v / pow2(k);\n    lemma_u64_shr_is_div(v, k as u64);\n\n    // v & low_bits_mask(k) = v % pow2(k);\n    lemma_u64_low_bits_mask_is_mod(v, k);\n\n    // 0 < pow2(k) <= u64::MAX\n    lemma_pow2_pos(k);\n    assert(pow2(k) <= u64::MAX) by {\n        assert(0x8000000000000000 <= u64::MAX) by (compute);\n        if (k < 63) {\n            lemma_pow2_strictly_increases(k, 63);\n        }\n    }\n\n    // v = (pow2(k) * (v / pow2(k)) + (v % pow2(k)))\n    lemma_fundamental_div_mod(v as int, pow2(k) as int);\n}",
    "display_name": "lemma_div_and_mod",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/from_slice",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "core https:/github.com/rust_lang/rust/library/core result/Result/map"
    ],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/RCompute/finish",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/from_hash",
      "5.0.0_pre.0 edwards/EdwardsPoint/vartime_double_scalar_mul_basepoint",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    pub(crate) fn finish(self) -> CompressedEdwardsY {\n        let k = Scalar::from_hash(self.h);\n\n        let minus_A: EdwardsPoint = -self.key.point;\n        // Recall the (non-batched) verification equation: -[k]A + [s]B = R\n        EdwardsPoint::vartime_double_scalar_mul_basepoint(&k, &(minus_A), &self.signature.s)\n            .compress()\n    }",
    "display_name": "finish",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "path/PathArguments/is_none",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_none",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/Zeroize/zeroize",
      "deserialize",
      "serialize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core once/sources/iter/once",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "once",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.0;\n        let b: &[u64; 5] = &_rhs.0;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        // Multiply to get 128-bit coefficients of output\n        let     c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(a[1], b4_19);\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0],  b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(a[2], b4_19);\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1],  b[1]) + m(a[0],  b[2]) + m(a[4], b3_19) + m(a[3], b4_19);\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2],  b[1]) + m(a[1],  b[2]) + m(a[0],  b[3]) + m(a[4], b4_19);\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3],  b[1]) + m(a[2],  b[2]) + m(a[1],  b[3]) + m(a[0] , b[4]);\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));\n        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));\n        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));\n        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));\n        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n        let mut out = [0u64; 5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51(out)\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/ProjectivePoint/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/Add/add",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add(self, rhs: FieldElement2625x4) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            self.0[0] + rhs.0[0],\n            self.0[1] + rhs.0[1],\n            self.0[2] + rhs.0[2],\n            self.0[3] + rhs.0[3],\n            self.0[4] + rhs.0[4],\n        ])\n    }",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "generics/TypeGenerics/as_turbofish",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_turbofish",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "benchmark_group/BenchmarkGroup/bench_function",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "bench_function",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_add_mod_noop",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_add_mod_noop",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core empty/sources/iter/empty"
    ],
    "body": "        });\n    }\n\n    pub(crate) fn montgomery_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"montgomery benches\");\n\n        montgomery_ladder(&mut g);\n        consttime_fixed_base_scalar_mul(&mut g);\n    }",
    "display_name": "vartime_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux",
      "power2/arithmetic/lemma_pow2_adds",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/slice128_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_nine_limbs_equals_slice128_to_nat",
      "mul/arithmetic/lemma_mul_is_associative"
    ],
    "body": "pub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]) ,\n        z[1] == (a[0] * a[1])  * 2,\n        z[2] == (a[0] * a[2])  * 2 + (a[1] * a[1]) ,\n        z[3] == (a[0] * a[3])  * 2 + (a[1] * a[2])  * 2,\n        z[4] == (a[0] * a[4])  * 2 + (a[1] * a[3])  * 2 + (a[2] * a[2]) ,\n        z[5] == (a[1] * a[4])  * 2 + (a[2] * a[3])  * 2,\n        z[6] == (a[2] * a[4])  * 2 + (a[3] * a[3]) ,\n        z[7] == (a[3] * a[4])  * 2,\n        z[8] == (a[4] * a[4]) ,\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n\n{\n        assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n            broadcast use group_mul_is_commutative_and_distributive;\n            broadcast use lemma_mul_is_associative;\n\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(52, 104);\n            lemma_pow2_adds(52, 156);\n            lemma_pow2_adds(52, 208);\n            lemma_pow2_adds(104, 104);\n            lemma_pow2_adds(104, 156);\n            lemma_pow2_adds(104, 208);\n            lemma_pow2_adds(156, 156);\n            lemma_pow2_adds(156, 208);\n            lemma_pow2_adds(208, 208);\n        };\n        lemma_nine_limbs_equals_slice128_to_nat(&z);\n        lemma_five_limbs_equals_to_nat(&a);\n}",
    "display_name": "lemma_square_internal_correct",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn as_bytes(&self) -> &SecretKey {\n        &self.secret_key\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 deterministic/determine_curve25519_dalek_bits",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 deterministic/determine_curve25519_dalek_bits_warning",
      "std https:/github.com/rust_lang/rust/library/std env/var",
      "alloc https:/github.com/rust_lang/rust/library/alloc string/String/AsRef/as_ref"
    ],
    "body": "    pub(super) fn determine_curve25519_dalek_bits(target_arch: &String) -> DalekBits {\n        let target_pointer_width = match std::env::var(\"CARGO_CFG_TARGET_POINTER_WIDTH\") {\n            Ok(pw) => pw,\n            Err(_) => {\n                determine_curve25519_dalek_bits_warning(ERR_MSG_NO_POINTER_WIDTH);\n                return DalekBits::Dalek32;\n            }\n        };\n\n        #[allow(clippy::match_single_binding)]\n        match &target_arch {\n            //Issues: 449 and 456\n            //TODO: When adding arch defaults use proper types not String match\n            //TODO(Arm): Needs tests + benchmarks to back this up\n            //TODO(Wasm32): Needs tests + benchmarks to back this up\n            _ => match target_pointer_width.as_ref() {\n                \"64\" => DalekBits::Dalek64,\n                \"32\" => DalekBits::Dalek32,\n                // Intended default solely for non-32/64 target pointer widths\n                // Otherwise known target platforms only.\n                _ => {\n                    determine_curve25519_dalek_bits_warning(ERR_MSG_UNKNOWN_POINTER_WIDTH);\n                    DalekBits::Dalek32\n                }\n            },\n        }\n    }",
    "display_name": "determine_curve25519_dalek_bits",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "3.0.0_pre.0 signature/InternalSignature/from_bytes",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signature/check_scalar",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice"
    ],
    "body": "    pub fn from_bytes(bytes: &[u8; SIGNATURE_LENGTH]) -> Result<InternalSignature, SignatureError> {\n        // TODO: Use bytes.split_array_ref once its in MSRV.\n        let mut R_bytes: [u8; 32] = [0u8; 32];\n        let mut s_bytes: [u8; 32] = [0u8; 32];\n        R_bytes.copy_from_slice(&bytes[00..32]);\n        s_bytes.copy_from_slice(&bytes[32..64]);\n\n        Ok(InternalSignature {\n            R: CompressedEdwardsY(R_bytes),\n            s: check_scalar(s_bytes)?,\n        })\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/test_precomputed_basepoint_mult",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn test_precomputed_basepoint_mult() {\n        let aB_1 = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n        let aB_2 = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n        assert_eq!(aB_1.compress(), aB_2.compress());\n    }",
    "display_name": "test_precomputed_basepoint_mult",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/vartime_double_base_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 vartime_double_base/scalar_mul/serial/backend/mul"
    ],
    "body": "pub fn vartime_double_base_mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => vector::scalar_mul::vartime_double_base::spec_avx2::mul(a, A, b),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::vartime_double_base::spec_avx512ifma_avx512vl::mul(a, A, b)\n        }\n        BackendKind::Serial => serial::scalar_mul::vartime_double_base::mul(a, A, b),\n    }\n}",
    "display_name": "vartime_double_base_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/hash_from_bytes",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core default/Default/default",
      "5.0.0_pre.0 scalar/Scalar/from_hash",
      "digest/Digest/update"
    ],
    "body": "    pub fn hash_from_bytes<D>(input: &[u8]) -> Scalar\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }",
    "display_name": "hash_from_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_two_factoring_51",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_two_factoring",
      "power2/arithmetic/pow2"
    ],
    "body": "pub proof fn lemma_two_factoring_51(k : nat, ai: u64)\n    ensures\n        pow2(k + 51) * ai == pow2(k) * (pow2(51) * ai)\n{\n    lemma_two_factoring(k, 51, ai);\n}",
    "display_name": "lemma_two_factoring_51",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/verify_strict",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/verify_strict"
    ],
    "body": "",
    "display_name": "verify_strict",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/as_bytes"
    ],
    "body": "    fn eq(&self, other: &VerifyingKey) -> bool {\n        self.as_bytes() == other.as_bytes()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "expect",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "3.0.0_pre.0 signing/SigningKey/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "map",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/from_hash",
    "statement_type": "function",
    "deps": [
      "Array/as_slice",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "5.0.0_pre.0 ristretto/RistrettoPoint/from_uniform_bytes",
      "digest/Digest/finalize"
    ],
    "body": "    pub fn from_hash<D>(hash: D) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        // dealing with generic arrays is clumsy, until const generics land\n        let output = hash.finalize();\n        let mut output_bytes = [0u8; 64];\n        output_bytes.copy_from_slice(output.as_slice());\n\n        RistrettoPoint::from_uniform_bytes(&output_bytes)\n    }",
    "display_name": "from_hash",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "std https:/github.com/rust_lang/rust/library/std io/BufRead/lines",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lines",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/is_torsion_free",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/IsIdentity/is_identity"
    ],
    "body": "    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER).is_identity()\n    }",
    "display_name": "is_torsion_free",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_to_nat_rec",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "pub open spec fn bytes_to_nat_rec(bytes: &[u8; 32], index: int) -> nat\ndecreases 32 - index\n{\n    if index >= 32 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_to_nat_rec(bytes, index + 1)\n    }\n}",
    "display_name": "bytes_to_nat_rec",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "file_name": "scalar_specs.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "serialize",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "serialize",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_reduce",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/part2",
      "5.0.0_pre.0 scalar/u64/serial/backend/m",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/sub",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/slice128_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/part1",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/montgomery_radix"
    ],
    "body": "}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }\n}",
    "display_name": "montgomery_reduce",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/impl_product",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/product",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip"
    ],
    "body": "    fn impl_product() {\n        // Test that product works for non-empty iterators\n        let X_Y_vector = [X, Y];\n        let should_be_X_times_Y: Scalar = X_Y_vector.iter().product();\n        assert_eq!(should_be_X_times_Y, X_TIMES_Y);\n\n        // Test that product works for the empty iterator\n        let one = Scalar::ONE;\n        let empty_vector = [];\n        let should_be_one: Scalar = empty_vector.iter().product();\n        assert_eq!(should_be_one, one);\n\n        // Test that product works for iterators where Item = Scalar\n        let xs = [Scalar::from(2u64); 10];\n        let ys = [Scalar::from(3u64); 10];\n        // now zs is an iterator with Item = Scalar\n        let zs = xs.iter().zip(ys.iter()).map(|(x, y)| x * y);\n\n        let x_prod: Scalar = xs.iter().product();\n        let y_prod: Scalar = ys.iter().product();\n        let z_prod: Scalar = zs.product();\n\n        assert_eq!(x_prod, Scalar::from(1024u64));\n        assert_eq!(y_prod, Scalar::from(59049u64));\n        assert_eq!(z_prod, Scalar::from(60466176u64));\n        assert_eq!(x_prod * y_prod, z_prod);\n    }",
    "display_name": "impl_product",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/l51_bit_mask_lt",
    "statement_type": "function",
    "deps": [
      "bits/low_bits_mask",
      "power2/arithmetic/lemma2_to64_rest"
    ],
    "body": "pub proof fn l51_bit_mask_lt()\n    ensures\n        LOW_51_BIT_MASK == low_bits_mask(51),\n        LOW_51_BIT_MASK < (1u64 << 51) as nat,\n{\n    lemma2_to64_rest();\n    assert(LOW_51_BIT_MASK < (1u64 << 51) as nat) by (compute);\n}",
    "display_name": "l51_bit_mask_lt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "Vec/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/straus_optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 straus/scalar_mul/serial/backend/Straus/VartimeMultiscalarMul/optional_multiscalar_mul",
      "5.0.0_pre.0 backend/get_selected_backend"
    ],
    "body": "pub fn straus_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => {\n            vector::scalar_mul::straus::spec_avx2::Straus::optional_multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::optional_multiscalar_mul::<\n                I,\n                J,\n            >(scalars, points)\n        }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::optional_multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
    "display_name": "straus_optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/multiscalar_consistency_n_1000",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 test/edwards/multiscalar_consistency_iter"
    ],
    "body": "    fn multiscalar_consistency_n_1000() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(1000);\n        }\n    }",
    "display_name": "multiscalar_consistency_n_1000",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "power/arithmetic/lemma_pow_positive",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_pow_positive",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/Hash/hash",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "core https:/github.com/rust_lang/rust/library/core array/Hash/hash",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes"
    ],
    "body": "    fn hash<H: Hasher>(&self, state: &mut H) {\n        // Do a round trip through a `FieldElement`. `as_bytes` is guaranteed to give a canonical\n        // 32-byte encoding\n        let canonical_bytes = FieldElement::from_bytes(&self.0).to_bytes();\n        canonical_bytes.hash(state);\n    }",
    "display_name": "hash",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_m",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/mul_lt"
    ],
    "body": "pub proof fn lemma_m(x: u64, y: u64, bx: u64, by: u64)\n    requires\n        x < bx,\n        y < by\n    ensures\n        (x as u128) * (y as u128) < (bx as u128) * (by as u128)\n{\n    mul_lt(x as nat, bx as nat, y as nat, by as nat);\n}",
    "display_name": "lemma_m",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/test_read_le_u64_into",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/read_le_u64_into",
      "core https:/github.com/rust_lang/rust/library/core slice/len"
    ],
    "body": "    fn test_read_le_u64_into() {\n        let cases: &[(&[u8], &[u64])] = &[\n            (\n                &[0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F, 0xF0],\n                &[0xF00F_F11F_0110_EFFE],\n            ),\n            (\n                &[\n                    0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A,\n                    0xBC, 0xDE, 0xF0,\n                ],\n                &[0xF00F_F11F_0110_EFFE, 0xF0DE_BC9A_7856_3412],\n            ),\n        ];\n\n        for (src, expected) in cases {\n            let mut dst = vec![0; expected.len()];\n            read_le_u64_into(src, &mut dst);\n\n            assert_eq!(&dst, expected, \"Expected {:x?} got {:x?}\", expected, dst);\n        }\n    }",
    "display_name": "test_read_le_u64_into",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/CompressedEdwardsY/Identity/identity"
    ],
    "body": "    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/impl_mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn impl_mul() {\n        let should_be_X_times_Y = X * Y;\n        assert_eq!(should_be_X_times_Y, X_TIMES_Y);\n    }",
    "display_name": "impl_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.y_plus_x.zeroize();\n        self.y_minus_x.zeroize();\n        self.xy2d.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/Verifier/verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/MultipartVerifier/multipart_verify"
    ],
    "body": "",
    "display_name": "verify",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_five_limbs_equals_to_nat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/five_limbs_to_nat_aux"
    ],
    "body": "pub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\nensures\n    five_limbs_to_nat_aux(*limbs) == to_nat(limbs)\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            (limbs[4] as nat) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        (limbs[0] as nat) +\n        pow2(52) * (limbs[1] as nat) +\n        pow2(104) * (limbs[2] as nat) +\n        pow2(156) * (limbs[3] as nat) +\n        pow2(208) * (limbs[4] as nat); {\n        }\n        five_limbs_to_nat_aux(*limbs);\n    }\n}",
    "display_name": "lemma_five_limbs_equals_to_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/EdwardsPoint/From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(vk: VerifyingKey) -> EdwardsPoint {\n        vk.point\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "mul/arithmetic/lemma_mul_inequality",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_inequality",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_pow_nat_is_nat",
    "statement_type": "function",
    "deps": [
      "power/arithmetic/pow",
      "power2/arithmetic/pow2",
      "power/arithmetic/lemma0_pow",
      "power2/arithmetic/lemma_pow2_pos",
      "power/arithmetic/lemma_pow_positive"
    ],
    "body": "pub proof fn lemma_pow_nat_is_nat(v: nat, i: nat)\n    ensures\n        pow(v as int, pow2(i)) >= 0\n{\n    lemma_pow2_pos(i); // pow2(i) > 0\n    if (v == 0) {\n        lemma0_pow(pow2(i));\n    }\n    else {\n        lemma_pow_positive(v as int, pow2(i));\n    }\n}",
    "display_name": "lemma_pow_nat_is_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 spec/precomputed_straus/scalar_mul/vector/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/len",
    "statement_type": "function",
    "deps": [
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len"
    ],
    "body": "        fn len(&self) -> usize {\n            self.static_lookup_tables.len()\n        }",
    "display_name": "len",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "file_name": "precomputed_straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "mul/arithmetic/lemma_mul_strict_inequality_converse",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_strict_inequality_converse",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/Sub/sub",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub(self, other: &CachedPoint) -> ExtendedPoint {\n        self + &(-other)\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/test_mul_reduction_invariance",
    "statement_type": "function",
    "deps": [
      "thread/rngs/rng",
      "thread/rngs/ThreadRng/RngCore/fill_bytes",
      "5.0.0_pre.0 scalar/clamp_integer",
      "5.0.0_pre.0 scalar/Scalar/reduce"
    ],
    "body": "    fn test_mul_reduction_invariance() {\n        let mut rng = rand::rng();\n\n        for _ in 0..10 {\n            // Also define c that's clamped. We'll make sure that clamping doesn't affect\n            // computation\n            let (a, b, c) = {\n                let mut a_bytes = [0u8; 32];\n                let mut b_bytes = [0u8; 32];\n                let mut c_bytes = [0u8; 32];\n                rng.fill_bytes(&mut a_bytes);\n                rng.fill_bytes(&mut b_bytes);\n                rng.fill_bytes(&mut c_bytes);\n                (\n                    Scalar { bytes: a_bytes },\n                    Scalar { bytes: b_bytes },\n                    Scalar {\n                        bytes: clamp_integer(c_bytes),\n                    },\n                )\n            };\n\n            // Make sure this is the same product no matter how you cut it\n            let reduced_mul_ab = a.reduce() * b.reduce();\n            let reduced_mul_ac = a.reduce() * c.reduce();\n            assert_eq!(a * b, reduced_mul_ab);\n            assert_eq!(a.reduce() * b, reduced_mul_ab);\n            assert_eq!(a * b.reduce(), reduced_mul_ab);\n            assert_eq!(a * c, reduced_mul_ac);\n            assert_eq!(a.reduce() * c, reduced_mul_ac);\n            assert_eq!(a * c.reduce(), reduced_mul_ac);\n        }\n    }",
    "display_name": "test_mul_reduction_invariance",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "digest/Digest/chain_update",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "chain_update",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signature/InternalSignature/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "    fn clone(&self) -> Self {\n        *self\n    }",
    "display_name": "clone",
    "full_path": "file:///work/3185/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 backend/VartimePrecomputedStraus/len",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core exact_size/traits/iter/ExactSizeIterator/len",
      "5.0.0_pre.0 precomputed_straus/scalar_mul/serial/backend/VartimePrecomputedStraus/VartimePrecomputedMultiscalarMul/len"
    ],
    "body": "//! 1. the function for equality checking (so that two representatives\n//!    of the same coset are considered equal);\n//! 2. the function for encoding (so that two representatives of the\n//!    same coset are encoded as identical bitstrings);\n//! 3. the function for decoding (so that only the canonical encoding of\n//!    a coset is accepted).\n//!\n//! Internally, each coset is represented by a curve point; two points\n//! \\\\( P, Q \\\\) may represent the same coset in the same way that two\n//! points with different \\\\(X,Y,Z\\\\) coordinates may represent the\n//! same point.  The group operations are carried out with no overhead\n//! using Edwards formulas.\n//!\n//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};",
    "display_name": "len",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/shl_decomposition",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/mul_le",
      "power2/arithmetic/lemma_pow2_strictly_increases",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shl_zero_is_id",
      "power2/arithmetic/pow2",
      "power2/arithmetic/lemma_pow2_adds",
      "mul/arithmetic/lemma_mul_is_associative"
    ],
    "body": "pub proof fn shl_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n        v * pow2(a + b) <= u64::MAX\n    ensures\n        (v << (a + b)) == ((v << a) << b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shl_zero_is_id;\n    }\n    else {\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // 2^a < 2^(a + b) ...\n        lemma_pow2_strictly_increases(a, a + b);\n        // ..., which implies v * 2^a < v * 2^(a + b) <= u64::MAX\n        mul_le(v as nat, v as nat, pow2(a), pow2(a + b));\n        // v << a + b = v * 2^(a+b)\n        lemma_u64_shl_is_mul(v, (a + b) as u64);\n        // v << a = v * 2^a\n        lemma_u64_shl_is_mul(v, a as u64);\n        broadcast use lemma_mul_is_associative; // (v * 2^a) * 2^b = v * (2^a * 2^b)\n        // (v * 2^a) << b = (v * 2^a) * 2^b\n        lemma_u64_shl_is_mul((v * pow2(a)) as u64, b as u64);\n    }\n}",
    "display_name": "shl_decomposition",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/masked_lt_51",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/masked_lt",
      "5.0.0_pre.0 field_verus/u64/serial/backend/l51_bit_mask_lt"
    ],
    "body": "pub proof fn masked_lt_51(v: u64)\n    ensures\n        v & LOW_51_BIT_MASK < (1u64 << 51),\n{\n    l51_bit_mask_lt(); // LOW_51_BIT_MASK == low_bits_mask(51)\n    masked_lt(v, 51);\n}",
    "display_name": "masked_lt_51",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/square_internal",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_square_internal_no_overflow",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_square_internal_correct",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/slice128_to_nat",
      "5.0.0_pre.0 scalar/u64/serial/backend/m",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded"
    ],
    "body": "    pub (crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n    {\n        proof {lemma_square_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(a.limbs[2], a.limbs[2]);\n        z[5] =                 m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] =                                 m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] =                                                 m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] =                                                                 m(a.limbs[4], a.limbs[4]);\n\n        proof {lemma_square_internal_correct(&a.limbs, &z);}\n\n        z\n    }",
    "display_name": "square_internal",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u32x8/splat_const",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/new_const"
    ],
    "body": "                        (A_LANES | B_LANES | C_LANES | D_LANES) as i32,\n                    )\n                    .into(),\n                }\n            }\n        }\n\n        FieldElement2625x4([\n            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n\n    /// Convenience wrapper around `new(x,x,x,x)`.\n    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }",
    "display_name": "splat_const",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 TestVector/From/from",
    "statement_type": "function",
    "deps": [
      "alloc https:/github.com/rust_lang/rust/library/alloc string/String/as_bytes",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "alloc https:/github.com/rust_lang/rust/library/alloc slice/to_vec",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap_or_default",
      "3.0.0_pre.0 Signature/from_bytes",
      "3.0.0_pre.0 verifying/VerifyingKey/from_bytes",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice"
    ],
    "body": "    fn from(tv: IntermediateTestVector) -> Self {\n        let number = tv.number;\n        let pubkey = {\n            let mut buf = [0u8; 32];\n            buf.copy_from_slice(&tv.pubkey);\n            VerifyingKey::from_bytes(&buf).unwrap()\n        };\n        let sig = {\n            let mut buf = [0u8; 64];\n            buf.copy_from_slice(&tv.sig);\n            Signature::from_bytes(&buf)\n        };\n        let msg = tv.msg.as_bytes().to_vec();\n\n        // Unwrap the Option<Set<Flag>>\n        let flags = tv.flags.unwrap_or_default();\n\n        Self {\n            number,\n            pubkey,\n            sig,\n            msg,\n            flags,\n        }\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/AddAssign/add_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }",
    "display_name": "add_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/pippenger/scalar_mul/serial/backend/test_vartime_pippenger",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "alloc https:/github.com/rust_lang/rust/library/alloc slice/to_vec",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/Clone/clone",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 scalar/Scalar/invert",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip"
    ],
    "body": "    fn test_vartime_pippenger() {\n        // Reuse points across different tests\n        let mut n = 512;\n        let x = Scalar::from(2128506u64).invert();\n        let y = Scalar::from(4443282u64).invert();\n        let points: Vec<_> = (0..n)\n            .map(|i| constants::ED25519_BASEPOINT_POINT * Scalar::from(1 + i as u64))\n            .collect();\n        let scalars: Vec<_> = (0..n)\n            .map(|i| x + (Scalar::from(i as u64) * y)) // fast way to make ~random but deterministic scalars\n            .collect();\n\n        let premultiplied: Vec<EdwardsPoint> = scalars\n            .iter()\n            .zip(points.iter())\n            .map(|(sc, pt)| sc * pt)\n            .collect();\n\n        while n > 0 {\n            let scalars = &scalars[0..n].to_vec();\n            let points = &points[0..n].to_vec();\n            let control: EdwardsPoint = premultiplied[0..n].iter().sum();\n\n            let subject = Pippenger::vartime_multiscalar_mul(scalars.clone(), points.clone());\n\n            assert_eq!(subject.compress(), control.compress());\n\n            n /= 2;\n        }\n    }",
    "display_name": "test_vartime_pippenger",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 test/constants/test_sqrt_minus_one",
    "statement_type": "function",
    "deps": [
      "From/from",
      "5.0.0_pre.0 field/FieldElement51/is_negative"
    ],
    "body": "    fn test_sqrt_minus_one() {\n        let minus_one = FieldElement::MINUS_ONE;\n        let sqrt_m1_sq = &constants::SQRT_M1 * &constants::SQRT_M1;\n        assert_eq!(minus_one, sqrt_m1_sq);\n        assert!(bool::from(!constants::SQRT_M1.is_negative()));\n    }",
    "display_name": "test_sqrt_minus_one",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/as_radix_2w",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/read_le_u64_into",
      "core https:/github.com/rust_lang/rust/library/core num/div_ceil",
      "5.0.0_pre.0 scalar/Scalar/as_radix_16"
    ],
    "body": "    pub(crate) fn as_radix_2w(&self, w: usize) -> [i8; 64] {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        if w == 4 {\n            return self.as_radix_16();\n        }\n\n        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.\n        let mut scalar64x4 = [0u64; 4];\n        read_le_u64_into(&self.bytes, &mut scalar64x4[0..4]);\n\n        let radix: u64 = 1 << w;\n        let window_mask: u64 = radix - 1;\n\n        let mut carry = 0u64;\n        let mut digits = [0i8; 64];\n        let digits_count = 256_usize.div_ceil(w);\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }\n\n        // When 4 < w < 8, we can fold the final carry onto the last digit d,\n        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.\n        //\n        // When w = 8, we can't fit carry*2^w into an i8.  This should\n        // not happen anyways, because the final carry will be 0 for\n        // reduced scalars, but Scalar invariant #1 allows 255-bit scalars.\n        // To handle this, we expand the size_hint by 1 when w=8,\n        // and accumulate the final carry onto another digit.\n        match w {\n            8 => digits[digits_count] += carry as i8,\n            _ => digits[digits_count - 1] += (carry << w) as i8,\n        }\n\n        digits\n    }",
    "display_name": "as_radix_2w",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/FieldElement51/from_bytes_wide",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "core https:/github.com/rust_lang/rust/library/core num/to_le_bytes"
    ],
    "body": "    pub(crate) fn from_bytes_wide(bytes: &[u8; 64]) -> Self {\n        let mut fl = [0u8; 32];\n        let mut gl = [0u8; 32];\n        fl.copy_from_slice(&bytes[..32]);\n        gl.copy_from_slice(&bytes[32..]);\n        // Mask off the top bits of both halves, since from_bytes masks them off anyway. We'll add\n        // them back in later.\n        let fl_top_bit = (fl[31] >> 7) as u16;\n        let gl_top_bit = (gl[31] >> 7) as u16;\n        fl[31] &= 0x7f;\n        gl[31] &= 0x7f;\n\n        // Interpret both sides as field elements\n        let mut fe_f = Self::from_bytes(&fl);\n        let fe_g = Self::from_bytes(&gl);\n\n        // The full field elem is now fe_f + 2 fl_top_bit + 2 fe_g + 2 gl_top_bit\n\n        // Add the masked off bits back to fe_f. fl_top_bit, if set, is 2^255  19 (mod q).\n        // gl_top_bit, if set, is 2^511  722 (mod q)\n        let top_bits_sum = {\n            // This only need to be a u16 because the max value is 741\n            let addend: u16 = fl_top_bit * 19 + gl_top_bit * 722;\n            let mut addend_bytes = [0u8; 32];\n            addend_bytes[..2].copy_from_slice(&addend.to_le_bytes());\n            Self::from_bytes(&addend_bytes)\n        };\n        fe_f += &top_bits_sum;\n\n        // Now add the high half into fe_f. The RHS is multiplied by 2^256  38 (mod q)\n        const THIRTY_EIGHT: FieldElement = FieldElement::from_bytes(&[\n            38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        fe_f += &(&THIRTY_EIGHT * &fe_g);\n\n        fe_f\n    }",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/iter_mut",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "iter_mut",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core result/Result/map",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "map",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/read_le_u64_into",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/iter_mut",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "core https:/github.com/rust_lang/rust/library/core slice/len",
      "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
      "core https:/github.com/rust_lang/rust/library/core slice/chunks",
      "core https:/github.com/rust_lang/rust/library/core num/from_le_bytes"
    ],
    "body": "fn read_le_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(\n        src.len() == 8 * dst.len(),\n        \"src.len() = {}, dst.len() = {}\",\n        src.len(),\n        dst.len()\n    );\n    for (bytes, val) in src.chunks(8).zip(dst.iter_mut()) {\n        *val = u64::from_le_bytes(\n            bytes\n                .try_into()\n                .expect(\"Incorrect src length, should be 8 * dst.len()\"),\n        );\n    }\n}",
    "display_name": "read_le_u64_into",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/NafLookupTable8/select",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 128);\n\n        self.0[x / 2]\n    }",
    "display_name": "select",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/montgomery_mul_bits_be_twist",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "5.0.0_pre.0 test/montgomery/bytestring_bits_le",
      "TryRngCore/unwrap_err",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_bits_be",
      "core https:/github.com/rust_lang/rust/library/core rev/adapters/iter/Rev/Clone/clone",
      "UnwrapErr/RngCore/fill_bytes"
    ],
    "body": "    fn montgomery_mul_bits_be_twist() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            // Make a random point P on the curve or its twist\n            let p_montgomery = {\n                let mut buf = [0u8; 32];\n                csprng.fill_bytes(&mut buf);\n                MontgomeryPoint(buf)\n            };\n\n            // Compute two big integers b and b\n            let mut bigint1 = [0u8; 64];\n            let mut bigint2 = [0u8; 64];\n            csprng.fill_bytes(&mut bigint1[..]);\n            csprng.fill_bytes(&mut bigint2[..]);\n\n            // Compute bP and bP\n            let bigint1_bits_be = bytestring_bits_le(&bigint1).rev();\n            let bigint2_bits_be = bytestring_bits_le(&bigint2).rev();\n            let prod1 = p_montgomery.mul_bits_be(bigint1_bits_be.clone());\n            let prod2 = p_montgomery.mul_bits_be(bigint2_bits_be.clone());\n\n            // Check that b(bP) == b(bP)\n            assert_eq!(\n                prod1.mul_bits_be(bigint2_bits_be),\n                prod2.mul_bits_be(bigint1_bits_be)\n            );\n        }\n    }",
    "display_name": "montgomery_mul_bits_be_twist",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_shr_le_u64",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2",
      "power2/arithmetic/lemma_pow2_pos",
      "div_mod/arithmetic/lemma_div_is_ordered"
    ],
    "body": "pub proof fn lemma_shr_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64\n    ensures\n        (a >> k) <= (b >> k)\n{\n    lemma_pow2_pos(k);\n    lemma_u64_shr_is_div(a, k as u64);\n    lemma_u64_shr_is_div(b, k as u64);\n    lemma_div_is_ordered(a as int, b as int, pow2(k) as int);\n}",
    "display_name": "lemma_shr_le_u64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u64x4/shl",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "shl",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/iter",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "iter",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_add_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_add_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/partial_precomputed_multiscalar_empty",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_multiscalar_mul",
      "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len",
      "thread/rngs/rng",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity",
      "5.0.0_pre.0 ristretto/RistrettoPoint/random",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/new"
    ],
    "body": "    fn partial_precomputed_multiscalar_empty() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use zero scalars\n        let static_scalars = Vec::new();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_multiscalar_mul(&static_scalars);\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }",
    "display_name": "partial_precomputed_multiscalar_empty",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/encoding_is_canonical",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes"
    ],
    "body": "    fn encoding_is_canonical() {\n        // Encode 1 wrongly as 1 + (2^255 - 19) = 2^255 - 18\n        let one_encoded_wrongly_bytes: [u8; 32] = [\n            0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0x7f,\n        ];\n        // Decode to a field element\n        let one = FieldElement::from_bytes(&one_encoded_wrongly_bytes);\n        // .. then check that the encoding is correct\n        let one_bytes = one.to_bytes();\n        assert_eq!(one_bytes[0], 1);\n        for byte in &one_bytes[1..] {\n            assert_eq!(*byte, 0);\n        }\n    }",
    "display_name": "encoding_is_canonical",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "rev",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/canonical_decoding",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/from_canonical_bytes",
      "CtOption/is_some",
      "From/from",
      "CtOption/is_none",
      "serialize",
      "deserialize"
    ],
    "body": "    fn canonical_decoding() {\n        // canonical encoding of 1667457891\n        let canonical_bytes = [\n            99, 99, 99, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0,\n        ];\n\n        // encoding of\n        //   7265385991361016183439748078976496179028704920197054998554201349516117938192\n        // = 28380414028753969466561515933501938171588560817147392552250411230663687203 (mod l)\n        // non_canonical because unreduced mod l\n        let non_canonical_bytes_because_unreduced = [16; 32];\n\n        // encoding with high bit set, to check that the parser isn't pre-masking the high bit\n        let non_canonical_bytes_because_highbit = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 128,\n        ];\n\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(canonical_bytes).is_some()\n        ));\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(non_canonical_bytes_because_unreduced).is_none()\n        ));\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(non_canonical_bytes_because_highbit).is_none()\n        ));\n    }",
    "display_name": "canonical_decoding",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/clamp_integer",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clamp_integer",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "        message: &[&[u8]],\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError>\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n    {\n        let signature = InternalSignature::try_from(signature)?;\n\n        let expected_R = RCompute::<CtxDigest>::compute(self, signature, None, message);\n        if expected_R == signature.R {\n            Ok(())\n        } else {\n            Err(InternalError::Verify.into())\n        }\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "de/from_reader",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from_reader",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "power2/arithmetic/lemma2_to64_rest",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma2_to64_rest",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 decompress/edwards/step_2",
      "5.0.0_pre.0 decompress/edwards/step_1"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx/x86/core_arch/_mm256_set1_epi64x",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_set1_epi64x",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "version_meta",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "version_meta",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/conditional_assign_for_affine_niels_point",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/Identity/identity",
      "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/ConditionallySelectable/conditional_assign",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_affine_niels",
      "Choice/From/from"
    ],
    "body": "    fn conditional_assign_for_affine_niels_point() {\n        let id = AffineNielsPoint::identity();\n        let mut p1 = AffineNielsPoint::identity();\n        let bp = constants::ED25519_BASEPOINT_POINT.as_affine_niels();\n\n        p1.conditional_assign(&bp, Choice::from(0));\n        assert_eq!(p1, id);\n        p1.conditional_assign(&bp, Choice::from(1));\n        assert_eq!(p1, bp);\n    }",
    "display_name": "conditional_assign_for_affine_niels_point",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 do_rfc7748_ladder_test1",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/x25519"
    ],
    "body": "fn do_rfc7748_ladder_test1(input_scalar: [u8; 32], input_point: [u8; 32], expected: [u8; 32]) {\n    let result = x25519(input_scalar, input_point);\n\n    assert_eq!(result, expected);\n}",
    "display_name": "do_rfc7748_ladder_test1",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/impl_sum",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum",
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity",
      "5.0.0_pre.0 scalar/Scalar/From/from",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map"
    ],
    "body": "    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let BASE = constants::RISTRETTO_BASEPOINT_POINT;\n\n        let s1 = Scalar::from(999u64);\n        let P1 = BASE * s1;\n\n        let s2 = Scalar::from(333u64);\n        let P2 = BASE * s2;\n\n        let vec = vec![P1, P2];\n        let sum: RistrettoPoint = vec.iter().sum();\n\n        assert_eq!(sum, P1 + P2);\n\n        // Test that sum works for the empty iterator\n        let empty_vector: Vec<RistrettoPoint> = vec![];\n        let sum: RistrettoPoint = empty_vector.iter().sum();\n\n        assert_eq!(sum, RistrettoPoint::identity());\n\n        // Test that sum works on owning iterators\n        let s = Scalar::from(2u64);\n        let mapped = vec.iter().map(|x| x * s);\n        let sum: RistrettoPoint = mapped.sum();\n\n        assert_eq!(sum, P1 * s + P2 * s);\n    }",
    "display_name": "impl_sum",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix32/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/as_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    }\n\n    // Tests that verify_strict() rejects small-order pubkeys. We test this by explicitly\n    // constructing a pubkey-signature pair that verifies with respect to two distinct messages.\n    // This should be accepted by verify(), but rejected by verify_strict().\n    #[test]\n    fn repudiation() {\n        let message1 = b\"Send 100 USD to Alice\";\n        let message2 = b\"Send 100000 USD to Alice\";\n\n        let mut s: Scalar = non_null_scalar();\n        let pubkey = WEAK_PUBKEY.decompress().unwrap();\n        let mut r = pick_r(s);\n\n        // Find an R such that\n        //     H(R || A || M)  A == A == H(R || A || M)  A\n        // This happens with high probability when A is low order.\n        while !(pubkey.neg() + compute_challenge(message1, &pubkey, &r, None) * pubkey)\n            .is_identity()\n            || !(pubkey.neg() + compute_challenge(message2, &pubkey, &r, None) * pubkey)\n                .is_identity()\n        {\n            // We pick an s and let R = sB - A where B is the basepoint\n            s = non_null_scalar();\n            r = pick_r(s);\n        }\n\n        // At this point, both verification equations hold:\n        //     sB = R + H(R || A || M)  A\n        //        = R + H(R || A || M)  A\n        // Check that this is true\n        let signature = serialize_signature(&r, &s);\n        let vk = VerifyingKey::from_bytes(pubkey.compress().as_bytes()).unwrap();\n        let sig = Signature::try_from(&signature[..]).unwrap();\n        assert!(vk.verify(message1, &sig).is_ok());\n        assert!(vk.verify(message2, &sig).is_ok());\n\n        // Check that this public key appears as weak\n        assert!(vk.is_weak());\n\n        // Now check that the sigs fail under verify_strict. This is because verify_strict rejects\n        // small order pubkeys.\n        assert!(vk.verify_strict(message1, &sig).is_err());\n        assert!(vk.verify_strict(message2, &sig).is_err());\n    }",
    "display_name": "as_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iter/slice/Iter/Iterator/for_each",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "for_each",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/EphemeralSecret/random_from_rng",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "random_from_rng",
    "full_path": "file:///work/3185/x25519-dalek/benches/x25519.rs",
    "relative_path": "x25519-dalek/benches/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx/x86_64/core_arch/_mm256_extract_epi64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_extract_epi64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_bytes_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_mul",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/bytes_wide_to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/add",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order"
    ],
    "body": "use digest::array::typenum::U64;\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\nuse subtle::CtOption;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse crate::backend;\nuse crate::constants;\n\ncfg_if! {\n    if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        #[cfg_attr(\n            docsrs,\n            doc(cfg(all(feature = \"fiat_backend\", curve25519_dalek_bits = \"32\")))\n        )]\n        type UnpackedScalar = backend::serial::fiat_u32::scalar::Scalar29;\n\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        #[cfg_attr(\n            docsrs,\n            doc(cfg(all(feature = \"fiat_backend\", curve25519_dalek_bits = \"64\")))\n        )]\n        type UnpackedScalar = backend::serial::fiat_u64::scalar::Scalar52;\n    } else if #[cfg(curve25519_dalek_bits = \"64\")] {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg_attr(docsrs, doc(cfg(curve25519_dalek_bits = \"64\")))]\n        type UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n    } else {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg_attr(docsrs, doc(cfg(curve25519_dalek_bits = \"64\")))]\n        type UnpackedScalar = backend::serial::u32::scalar::Scalar29;\n    }\n}",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/StaticSecret/Drop/drop",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }",
    "display_name": "drop",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/from_canonical_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/is_canonical",
      "ConstantTimeEq/ct_eq",
      "CtOption/new"
    ],
    "body": "",
    "display_name": "from_canonical_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bencher/Bencher/iter",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "iter",
    "full_path": "file:///work/3185/ed25519-dalek/benches/ed25519_benchmarks.rs",
    "relative_path": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "file_name": "ed25519_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "From/from",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/pow2k"
    ],
    "body": "    }\n\n    #[test]\n    fn conditional_negate() {\n        let one = FieldElement::ONE;\n        let minus_one = FieldElement::MINUS_ONE;\n        let mut x = one;\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(0));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, one);\n    }",
    "display_name": "square",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/drain",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "drain",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/slice128_to_nat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/seq_to_nat"
    ],
    "body": "\nverus! {\n\n/// Verification: scalar * scalar.invert()  1 mod L\nproof fn verify_invert_correct(x: Scalar52)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}\n\npub proof fn lemma_52_52(x: u64, y: u64)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures (x as u128) * (y as u128) < (1u128 << 104)\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert( x * y < x * (1u128 << 52)  );\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}\n\npub proof fn lemma_square_internal_no_overflow()\n    ensures\n         (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n         (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n         (1u128 << 104) * 2 == (1u128 << 105),\n         (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}\n\n\npub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]) ,\n        z[1] == (a[0] * a[1])  * 2,\n        z[2] == (a[0] * a[2])  * 2 + (a[1] * a[1]) ,\n        z[3] == (a[0] * a[3])  * 2 + (a[1] * a[2])  * 2,\n        z[4] == (a[0] * a[4])  * 2 + (a[1] * a[3])  * 2 + (a[2] * a[2]) ,\n        z[5] == (a[1] * a[4])  * 2 + (a[2] * a[3])  * 2,\n        z[6] == (a[2] * a[4])  * 2 + (a[3] * a[3]) ,\n        z[7] == (a[3] * a[4])  * 2,\n        z[8] == (a[4] * a[4]) ,\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n\n{\n        assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n            broadcast use group_mul_is_commutative_and_distributive;\n            broadcast use lemma_mul_is_associative;\n\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(52, 104);\n            lemma_pow2_adds(52, 156);\n            lemma_pow2_adds(52, 208);\n            lemma_pow2_adds(104, 104);\n            lemma_pow2_adds(104, 156);\n            lemma_pow2_adds(104, 208);\n            lemma_pow2_adds(156, 156);\n            lemma_pow2_adds(156, 208);\n            lemma_pow2_adds(208, 208);\n        };\n        lemma_nine_limbs_equals_slice128_to_nat(&z);\n        lemma_five_limbs_equals_to_nat(&a);\n}\n\npub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}\n\n\npub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\nensures\n    nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs)\n{\n\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            ((limbs[4] as nat) +\n            ((limbs[5] as nat) +\n                ((limbs[6] as nat) +\n                ((limbs[7] as nat) +\n                (limbs[8] as nat) * pow2(52)\n                ) * pow2(52)\n                ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        lemma_pow2_adds(208, 52);\n        lemma_pow2_adds(260, 52);\n        lemma_pow2_adds(312, 52);\n        lemma_pow2_adds(364, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}\n\npub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\nensures\n    five_limbs_to_nat_aux(*limbs) == to_nat(limbs)\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            (limbs[4] as nat) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        (limbs[0] as nat) +\n        pow2(52) * (limbs[1] as nat) +\n        pow2(104) * (limbs[2] as nat) +\n        pow2(156) * (limbs[3] as nat) +\n        pow2(208) * (limbs[4] as nat); {\n        }\n        five_limbs_to_nat_aux(*limbs);\n    }\n}\n\n\npub proof fn lemma_scalar_subtract_no_overflow(carry: u64, difference_limb: u64, addend: u64, i: u32, l_value: &Scalar52)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}\n\npub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}\n\n\npub proof fn lemma_from_montgomery_limbs_conversion(\n    limbs: &[u128; 9],\n    self_limbs: &[u64; 5]\n)\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) +\n           (self_limbs[1] as nat) * pow2(52) +\n           (self_limbs[2] as nat) * pow2(104) +\n           (self_limbs[3] as nat) * pow2(156) +\n           (self_limbs[4] as nat) * pow2(208) +\n           0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(416));\n}\n\n\n\npub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}\n} // verus!",
    "display_name": "slice128_to_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/MultipartSigner/try_multipart_sign",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "3.0.0_pre.0 signing/ExpandedSecretKey/raw_sign"
    ],
    "body": "    fn try_multipart_sign(&self, message: &[&[u8]]) -> Result<Signature, SignatureError> {\n        let expanded: ExpandedSecretKey = (&self.secret_key).into();\n        Ok(expanded.raw_sign::<Sha512>(message, &self.verifying_key))\n    }",
    "display_name": "try_multipart_sign",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 function_with_where_clause",
    "statement_type": "function",
    "deps": [],
    "body": "fn function_with_where_clause<T>(a: T, b: T) -> T::Output\nwhere\n    T: Copy + core::ops::Sub,\n{\n    a - b\n}",
    "display_name": "function_with_where_clause",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_mod_bound",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mod_bound",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/SharedSecret/was_contributory",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/IsIdentity/is_identity"
    ],
    "body": "    pub fn was_contributory(&self) -> bool {\n        !self.0.is_identity()\n    }",
    "display_name": "was_contributory",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/PublicKey/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base_clamped",
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery"
    ],
    "body": "    fn from(secret: &'a StaticSecret) -> PublicKey {\n        PublicKey(EdwardsPoint::mul_base_clamped(secret.0).to_montgomery())\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "unwrap",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 ristretto/RistrettoPoint/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_mul_internal_no_overflow",
    "statement_type": "function",
    "deps": [],
    "body": "pub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}",
    "display_name": "lemma_mul_internal_no_overflow",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsBasepointTableRadix256/BasepointTable/create",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "create",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core option/Option/expect",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "expect",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/StaticSecret/random_from_rng",
    "statement_type": "function",
    "deps": [],
    "body": "\n    #[test]\n    #[cfg(feature = \"reusable_secrets\")]\n    fn reusable_random() {\n        ReusableSecret::random();\n    }",
    "display_name": "random_from_rng",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/ExpandedSecretKey/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core builders/fmt/DebugStruct/finish_non_exhaustive",
      "core https:/github.com/rust_lang/rust/library/core fmt/Formatter/debug_struct"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"ExpandedSecretKey\").finish_non_exhaustive() // avoids printing secrets\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "Choice/unwrap_u8",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "unwrap_u8",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 affine/edwards/AffinePoint/ConstantTimeEq/ct_eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/ConstantTimeEq/ct_eq"
    ],
    "body": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }",
    "display_name": "ct_eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards/affine.rs",
    "relative_path": "curve25519-dalek/src/edwards/affine.rs",
    "file_name": "affine.rs",
    "parent_folder": "edwards"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/AffineNielsPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/reduce"
    ],
    "body": "        D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    {\n        let l_i_b_str = 48u16.to_be_bytes();\n        let z_pad = Array::<u8, D::BlockSize>::default();\n\n        let mut hasher = D::new().chain_update(z_pad);\n\n        for slice in bytes {\n            hasher = hasher.chain_update(slice);\n        }\n\n        hasher = hasher.chain_update(l_i_b_str).chain_update([0u8]);\n\n        let mut domain_sep_len = 0usize;\n        for slice in domain_sep {\n            hasher = hasher.chain_update(slice);\n            domain_sep_len += slice.len();\n        }\n\n        let domain_sep_len = u8::try_from(domain_sep_len)\n            .expect(\"Unexpected overflow from domain separator's size.\");\n        assert_ne!(\n            domain_sep_len, 0,\n            \"Domain separator MUST have nonzero length.\"\n        );\n\n        let b_0 = hasher.chain_update([domain_sep_len]).finalize();\n\n        let mut hasher = D::new().chain_update(b_0.as_slice()).chain_update([1u8]);\n\n        for slice in domain_sep {\n            hasher = hasher.chain_update(slice)\n        }\n\n        let b_1 = hasher.chain_update([domain_sep_len]).finalize();\n\n        // 5.2, we only generate count * m * L = 1 * 1 * (256 + 128)/8 = 48 bytes\n        let mut bytes_wide = [0u8; 64];\n        bytes_wide[..48].copy_from_slice(&b_1.as_slice()[..48]);\n        bytes_wide[..48].reverse();\n\n        FieldElement::from_bytes_wide(&bytes_wide)\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u64x4/shr",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "shr",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core array/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 tests/inner_spec/test_specialized_inner",
    "statement_type": "function",
    "deps": [],
    "body": "        fn test_specialized_inner() {\n            assert!(!super::IS_AVX2);\n        }",
    "display_name": "test_specialized_inner",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "std https:/github.com/rust_lang/rust/library/std bufreader/buffered/io/BufReader/new",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "pub open spec fn as_nat(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n}",
    "display_name": "as_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/decompress_id",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/Identity/identity",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/CompressedEdwardsY/Identity/identity",
      "core https:/github.com/rust_lang/rust/library/core option/Option/unwrap",
      "5.0.0_pre.0 ristretto/CompressedRistretto/decompress",
      "5.0.0_pre.0 ristretto/RistrettoPoint/coset4"
    ],
    "body": "    fn decompress_id() {\n        let compressed_id = CompressedRistretto::identity();\n        let id = compressed_id.decompress().unwrap();\n        let mut identity_in_coset = false;\n        for P in &id.coset4() {\n            if P.compress() == CompressedEdwardsY::identity() {\n                identity_in_coset = true;\n            }\n        }\n        assert!(identity_in_coset);\n    }",
    "display_name": "decompress_id",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/vartime_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 multiscalar_benches/construct_points",
      "benchmark_group/BenchmarkId/new",
      "bencher/Bencher/iter_batched",
      "5.0.0_pre.0 multiscalar_benches/construct_scalars",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "benchmark_group/BenchmarkGroup/bench_with_input"
    ],
    "body": "    fn vartime_multiscalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Variable-time variable-base multiscalar multiplication\",\n                    *multiscalar_size,\n                ),\n                &multiscalar_size,\n                |b, &&size| {\n                    let points = construct_points(size);\n                    // Rerandomize the scalars for every call to prevent\n                    // false timings from better caching (e.g., the CPU\n                    // cache lifts exactly the right table entries for the\n                    // benchmark into the highest cache levels).\n                    b.iter_batched(\n                        || construct_scalars(size),\n                        |scalars| EdwardsPoint::vartime_multiscalar_mul(&scalars, &points),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }",
    "display_name": "vartime_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 window/NafLookupTable8/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/as_affine_niels",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective_niels",
      "5.0.0_pre.0 edwards/EdwardsPoint/double"
    ],
    "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/ExpandedSecretKey/TryFrom/try_from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/ExpandedSecretKey/from_slice"
    ],
    "body": "    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {\n        Self::from_slice(bytes)\n    }",
    "display_name": "try_from",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds",
    "statement_type": "function",
    "deps": [
      "div_mod/arithmetic/lemma_fundamental_div_mod",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "power2/arithmetic/lemma_pow2_pos",
      "mul/arithmetic/lemma_mul_strict_inequality_converse"
    ],
    "body": "pub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
    "display_name": "lemma_add_carry_and_sum_bounds",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_srli_epi64",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_srli_epi64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core map/adapters/iter/Map/Iterator/next",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "next",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/CompressedRistretto/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/CompressedRistretto/ConstantTimeEq/ct_eq",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity"
    ],
    "body": "    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat_squared",
    "statement_type": "function",
    "deps": [
      "mul/arithmetic/lemma_mul_is_associative",
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_mod_sum_factor",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/p",
      "power2/arithmetic/pow2",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/pow255_gt_19",
      "mul/arithmetic/lemma_mul_is_distributive_add",
      "power2/arithmetic/lemma_pow2_adds"
    ],
    "body": "pub proof fn as_nat_squared(v: [u64; 5])\n    ensures\n        as_nat(v) * as_nat(v) ==\n        pow2(8 * 51) * (v[4] * v[4]) +\n        pow2(7 * 51) * (2 * (v[3] * v[4])) +\n        pow2(6 * 51) * (v[3] * v[3] + 2 * (v[2] * v[4])) +\n        pow2(5 * 51) * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])) +\n        pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n        pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3])) +\n        pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2])) +\n        pow2(1 * 51) * (2 * (v[0] * v[1])) +\n                       (v[0] * v[0]),\n        // and the mod equality\n        (as_nat(v) * as_nat(v)) % p() ==\n        (\n            pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n            pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])) +\n            pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))) +\n            pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))) +\n                           (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])))\n        ) as nat % p()\n{\n    let v0 = v[0];\n    let v1 = v[1];\n    let v2 = v[2];\n    let v3 = v[3];\n    let v4 = v[4];\n\n    let s1 = pow2(1 * 51);\n    let s2 = pow2(2 * 51);\n    let s3 = pow2(3 * 51);\n    let s4 = pow2(4 * 51);\n    let s5 = pow2(5 * 51);\n    let s6 = pow2(6 * 51);\n    let s7 = pow2(7 * 51);\n    let s8 = pow2(8 * 51);\n\n    assert(s1 * s1 == s2) by {\n        lemma_pow2_adds(51, 51)\n    }\n    assert(s1 * s2 == s2 * s1 == s3) by {\n        lemma_pow2_adds(51, 102)\n    }\n    assert(s1 * s3 == s3 * s1 == s4) by {\n        lemma_pow2_adds(51, 153)\n    }\n    assert(s1 * s4 == s4 * s1 == s5) by {\n        lemma_pow2_adds(51, 204)\n    }\n    assert(s2 * s2 ==s4) by {\n        lemma_pow2_adds(102, 102)\n    }\n    assert(s2 * s3 == s3 * s2 == s5) by {\n        lemma_pow2_adds(102, 153)\n    }\n    assert(s2 * s4 == s4 * s2 == s6) by {\n        lemma_pow2_adds(102, 204)\n    }\n    assert(s3 * s3 == s6) by {\n        lemma_pow2_adds(153, 153)\n    }\n    assert(s3 * s4 == s4 * s3 == s7) by {\n        lemma_pow2_adds(153, 204)\n    }\n    assert(s4 * s4 == s8) by {\n        lemma_pow2_adds(204, 204)\n    }\n\n    assert(as_nat(v) * as_nat(v) ==\n        v0 * as_nat(v) +\n        (s1 * v1) * as_nat(v) +\n        (s2 * v2) * as_nat(v) +\n        (s3 * v3) * as_nat(v) +\n        (s4 * v4) * as_nat(v)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    // because of the sheer number of possible associativity/distributivity groupings we have\n    // to help the solver along by intermittently asserting chunks\n    assert(v0 * as_nat(v) ==\n        v0 * v0 +\n        v0 * (s1 * v1) +\n        v0 * (s2 * v2) +\n        v0 * (s3 * v3) +\n        v0 * (s4 * v4)\n        ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n        v0 * v0\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    assert((s1 * v1) * as_nat(v) ==\n        s5 * (v1 * v4) +\n        s4 * (v1 * v3) +\n        s3 * (v1 * v2) +\n        s2 * (v1 * v1) +\n        s1 * (v0 * v1)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    assert((s2 * v2) * as_nat(v) ==\n        s6 * (v2 * v4) +\n        s5 * (v2 * v3) +\n        s4 * (v2 * v2) +\n        s3 * (v1 * v2) +\n        s2 * (v0 * v2)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    assert((s3 * v3) * as_nat(v) ==\n        s7 * (v3 * v4) +\n        s6 * (v3 * v3) +\n        s5 * (v2 * v3) +\n        s4 * (v1 * v3) +\n        s3 * (v0 * v3)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    assert((s4 * v4) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (v3 * v4) +\n        s6 * (v2 * v4) +\n        s5 * (v1 * v4) +\n        s4 * (v0 * v4)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    // we now mash them all together\n    assert(as_nat(v) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (2 * (v3 * v4)) +\n        s6 * (v3 * v3 + 2 * (v2 * v4)) +\n        s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) +\n        s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4)) +\n        s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) +\n        s2 * (v1 * v1 + 2 * (v0 * v2)) +\n        s1 * (2 * (v0 * v1)) +\n             (v0 * v0)\n    ) by {\n        broadcast use lemma_mul_is_associative;\n        broadcast use lemma_mul_is_distributive_add;\n        assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n        assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n        assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n        assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n        assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n        assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n        assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n        assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n        assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n        assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n    }\n\n    // This is the explicit version, now we can take everything mod p\n\n    // p well defined\n    pow255_gt_19();\n\n    // By definition, p = s^5 - 19\n    // equivalently,\n    // s^5 = (p + 19)\n    // s^6 = s * (p + 19)\n    // s^7 = s^2 * (p + 19)\n    // s^8 = s^3 * (p + 19)\n    assert(s5 == (p() + 19));\n\n    // we pack together terms to slim down expressions;\n\n    let c0_base = v0 *  v0;\n    let c0_x19 = 2 * (v2 * v3) + 2 * (v1 * v4);\n    let c0 = c0_base + 19 * c0_x19;\n\n    let c1_base = 2 * (v0 *  v1);\n    let c1_x19 = v3 * v3 + 2 * (v2 * v4);\n    let c1 = c1_base + 19 * c1_x19;\n\n    let c2_base = v1 * v1 + 2 * (v0 *  v2);\n    let c2_x19 = 2 * (v3 * v4);\n    let c2 = c2_base + 19 * c2_x19;\n\n    let c3_base = 2 * (v1 *  v2) + 2 * (v0 *  v3);\n    let c3_x19 = v4 * v4;\n    let c3 = c3_base + 19 * c3_x19;\n\n    let c4 = v2 *  v2 + 2 * (v1 *  v3) + 2 * (v0 *  v4);\n\n    // group in preparation for the substitution\n    assert(as_nat(v) * as_nat(v) ==\n        s4 * c4 +\n        s3 * (s5 * c3_x19 + c3_base) +\n        s2 * (s5 * c2_x19 + c2_base) +\n        s1 * (s5 * c1_x19 + c1_base) +\n             (s5 * c0_x19 + c0_base)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    // Next we use the identity s5 = p + 19\n    assert(s5 * c3_x19 + c3_base == p() * c3_x19 + c3) by {\n        lemma_mul_is_distributive_add(c3_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c2_x19 + c2_base == p() * c2_x19 + c2) by {\n        lemma_mul_is_distributive_add(c2_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c1_x19 + c1_base == p() * c1_x19 + c1) by {\n        lemma_mul_is_distributive_add(c1_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c0_x19 + c0_base == p() * c0_x19 + c0) by {\n        lemma_mul_is_distributive_add(c0_x19 as int, p() as int, 19);\n    }\n\n    // in summary, we can reorder and regroup terms to get X * p() + Y\n    assert(as_nat(v) * as_nat(v) ==\n        p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 ) +\n        (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        )\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        // we don't broadcast assoc, too many trigger matches\n        lemma_mul_is_associative(s3 as int, p() as int, c3_x19 as int);\n        lemma_mul_is_associative(s2 as int, p() as int, c2_x19 as int);\n        lemma_mul_is_associative(s1 as int, p() as int, c1_x19 as int);\n        lemma_mul_is_associative(p() as int, s3 as int, c3_x19 as int);\n        lemma_mul_is_associative(p() as int, s2 as int, c2_x19 as int);\n        lemma_mul_is_associative(p() as int, s1 as int, c1_x19 as int);\n    }\n\n\n    let k = ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 );\n    let sum = (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        );\n\n    assert(as_nat(v) * as_nat(v) == k * p() + sum);\n    assert(k * p() + sum == (k as nat) * p() + (sum as nat));\n\n    // Now, we simply move to mod p\n\n    assert((as_nat(v) * as_nat(v)) % p() == ((k as nat) * p() + (sum as nat)) % p() );\n    assert(\n        ((k as nat) * p() + (sum as nat)) % p() ==\n        (sum as nat) % p()\n    ) by {\n        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}",
    "display_name": "as_nat_squared",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/square",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/pow2k"
    ],
    "body": "    pub fn square(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            // TODO\n            // as_nat(square(x)) = as_nat(x) * as_nat(x)\n            true\n\n    {\n        self.pow2k(1)\n    }",
    "display_name": "square",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/ProjectivePoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/PublicKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "lookahead/Lookahead1/peek",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "peek",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/Mul/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/reduce64",
      "5.0.0_pre.0 field/avx2/vector/backend/unpack_pair",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/mul32",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/new"
    ],
    "body": "    fn mul(self, scalars: (u32, u32, u32, u32)) -> FieldElement2625x4 {\n        let consts = u32x8::new(scalars.0, 0, scalars.1, 0, scalars.2, 0, scalars.3, 0);\n\n        let (b0, b1) = unpack_pair(self.0[0]);\n        let (b2, b3) = unpack_pair(self.0[1]);\n        let (b4, b5) = unpack_pair(self.0[2]);\n        let (b6, b7) = unpack_pair(self.0[3]);\n        let (b8, b9) = unpack_pair(self.0[4]);\n\n        FieldElement2625x4::reduce64([\n            b0.mul32(consts),\n            b1.mul32(consts),\n            b2.mul32(consts),\n            b3.mul32(consts),\n            b4.mul32(consts),\n            b5.mul32(consts),\n            b6.mul32(consts),\n            b7.mul32(consts),\n            b8.mul32(consts),\n            b9.mul32(consts),\n        ])\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: self.y_minus_x,\n            y_minus_x: self.y_plus_x,\n            xy2d: -(&self.xy2d),\n        }\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 vstd_u128/u64/serial/backend/lemma_u128_low_bits_mask_is_mod",
    "statement_type": "function",
    "deps": [],
    "body": "    lemma_u128_low_bits_mask_is_mod,\n    lemma_u128_and_split_low_bit,\n    lemma_u128_pow2_no_overflow,\n    u128\n);\n}",
    "display_name": "lemma_u128_low_bits_mask_is_mod",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/vstd_u128.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/vstd_u128.rs",
    "file_name": "vstd_u128.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "    fn zeroize(&mut self) {\n        self.limbs.zeroize();\n    }",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/Neg/neg",
    "statement_type": "function",
    "deps": [],
    "body": "    fn neg(self) -> RistrettoPoint {\n        -&self\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/push",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "push",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/Sub/sub",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/reduce"
    ],
    "body": "    fn sub(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        FieldElement51::reduce([\n            (self.0[0] + 36028797018963664u64) - _rhs.0[0],\n            (self.0[1] + 36028797018963952u64) - _rhs.0[1],\n            (self.0[2] + 36028797018963952u64) - _rhs.0[2],\n            (self.0[3] + 36028797018963952u64) - _rhs.0[3],\n            (self.0[4] + 36028797018963952u64) - _rhs.0[4],\n        ])\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectiveNielsPoint/Identity/identity",
    "statement_type": "function",
    "deps": [],
    "body": "    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }",
    "display_name": "identity",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_cofactor",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2"
    ],
    "body": "    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }",
    "display_name": "mul_by_cofactor",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/Mul/mul",
    "statement_type": "function",
    "deps": [],
    "body": "    fn mul(self, basepoint_table: &'a RistrettoBasepointTable) -> RistrettoPoint {\n        RistrettoPoint(self * &basepoint_table.0)\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_l_value_properties",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/sub",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_add_carry_and_sum_bounds",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_add_loop_bounds"
    ],
    "body": "    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    pub(crate) bytes: [u8; 32],\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> Scalar {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    #[cfg(feature = \"legacy_compatibility\")]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/basepoint_edwards_to_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery"
    ],
    "body": "    fn basepoint_edwards_to_montgomery() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT.to_montgomery(),\n            constants::X25519_BASEPOINT\n        );\n    }",
    "display_name": "basepoint_edwards_to_montgomery",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/from_bytes_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_bytes_wide"
    ],
    "body": "    fn from_bytes_wide() {\n        let bignum = [255u8; 64]; // 2^512 - 1\n        let reduced = Scalar52::from_bytes_wide(&bignum);\n        for i in 0..5 {\n            assert!(reduced[i] == C[i]);\n        }\n    }",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/field/from_bytes_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/to_bytes",
      "decode",
      "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into",
      "5.0.0_pre.0 field/FieldElement51/from_bytes_wide",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/as_slice"
    ],
    "body": "    fn from_bytes_wide() {\n        // Do the 64-byte input ones first\n        for (input_bytes, expected_reduced) in FROM_BYTES_WIDE_KAT_BIG {\n            let reduce_fe = FieldElement::from_bytes_wide(\n                &hex::decode(input_bytes)\n                    .unwrap()\n                    .as_slice()\n                    .try_into()\n                    .unwrap(),\n            );\n            assert_eq!(\n                &reduce_fe.to_bytes(),\n                hex::decode(expected_reduced).unwrap().as_slice()\n            );\n        }\n\n        // Now do the 48-byte inputs\n        for (input_bytes, expected_reduced) in FROM_BYTES_WIDE_KAT_MEDIUM {\n            let mut padded_input_bytes = [0u8; 64];\n            padded_input_bytes[..48].copy_from_slice(&hex::decode(input_bytes).unwrap());\n            let reduce_fe = FieldElement::from_bytes_wide(&padded_input_bytes);\n            assert_eq!(\n                &reduce_fe.to_bytes(),\n                hex::decode(expected_reduced).unwrap().as_slice()\n            );\n        }\n    }",
    "display_name": "from_bytes_wide",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto_benches/ristretto_benches",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto_benches/double_and_compress_batch",
      "Criterion/Default/default",
      "5.0.0_pre.0 ristretto_benches/decompress",
      "5.0.0_pre.0 ristretto_benches/compress",
      "Criterion/benchmark_group"
    ],
    "body": "    pub(crate) fn ristretto_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"ristretto benches\");\n\n        compress(&mut g);\n        decompress(&mut g);\n        double_and_compress_batch(&mut g);\n    }",
    "display_name": "ristretto_benches",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "token/Bracket/Default/default",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/constants/test_eight_torsion",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/ValidityCheck/is_valid",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 traits/IsIdentity/is_identity"
    ],
    "body": "    fn test_eight_torsion() {\n        for i in 0..8 {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(3);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }",
    "display_name": "test_eight_torsion",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/PartialEq/eq",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/ConstantTimeEq/ct_eq",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
    "display_name": "eq",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/square_and_negate_D",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn square_and_negate_D(&self) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let x0_2 = x0.shl::<1>();\n        let x1_2 = x1.shl::<1>();\n        let x2_2 = x2.shl::<1>();\n        let x3_2 = x3.shl::<1>();\n        let x4_2 = x4.shl::<1>();\n        let x5_2 = x5.shl::<1>();\n        let x6_2 = x6.shl::<1>();\n        let x7_2 = x7.shl::<1>();\n\n        let x5_19 = m_lo(v19, x5);\n        let x6_19 = m_lo(v19, x6);\n        let x7_19 = m_lo(v19, x7);\n        let x8_19 = m_lo(v19, x8);\n        let x9_19 = m_lo(v19, x9);\n\n        let mut z0 = m(x0,   x0) + m(x2_2, x8_19) + m(x4_2, x6_19) + ((m(x1_2, x9_19) +   m(x3_2, x7_19) +    m(x5,   x5_19)).shl::<1>());\n        let mut z1 = m(x0_2, x1) + m(x3_2, x8_19) + m(x5_2, x6_19) +                    ((m(x2,   x9_19) +    m(x4,   x7_19)).shl::<1>());\n        let mut z2 = m(x0_2, x2) + m(x1_2,    x1) + m(x4_2, x8_19) +   m(x6,   x6_19) + ((m(x3_2, x9_19) +    m(x5_2, x7_19)).shl::<1>());\n        let mut z3 = m(x0_2, x3) + m(x1_2,    x2) + m(x5_2, x8_19) +                    ((m(x4,   x9_19) +    m(x6,   x7_19)).shl::<1>());\n        let mut z4 = m(x0_2, x4) + m(x1_2,  x3_2) + m(x2,      x2) +   m(x6_2, x8_19) + ((m(x5_2, x9_19) +    m(x7,   x7_19)).shl::<1>());\n        let mut z5 = m(x0_2, x5) + m(x1_2,    x4) + m(x2_2,    x3) +   m(x7_2, x8_19)                    +  ((m(x6,   x9_19)).shl::<1>());\n        let mut z6 = m(x0_2, x6) + m(x1_2,  x5_2) + m(x2_2,    x4) +   m(x3_2,    x3) +   m(x8,   x8_19) +  ((m(x7_2, x9_19)).shl::<1>());\n        let mut z7 = m(x0_2, x7) + m(x1_2,    x6) + m(x2_2,    x5) +   m(x3_2,    x4)                    +  ((m(x8,   x9_19)).shl::<1>());\n        let mut z8 = m(x0_2, x8) + m(x1_2,  x7_2) + m(x2_2,    x6) +   m(x3_2,  x5_2) +   m(x4,      x4) +  ((m(x9,   x9_19)).shl::<1>());\n        let mut z9 = m(x0_2, x9) + m(x1_2,    x8) + m(x2_2,    x7) +   m(x3_2,    x6) +   m(x4_2,    x5)                                 ;\n\n        // The biggest z_i is bounded as z_i < 249*2^(51 + 2*b);\n        // if b < 1.5 we get z_i < 4485585228861014016.\n        //\n        // The limbs of the multiples of p are bounded above by\n        //\n        // 0x3fffffff << 37 = 9223371899415822336 < 2^63\n        //\n        // and below by\n        //\n        // 0x1fffffff << 37 = 4611685880988434432\n        //                  > 4485585228861014016\n        //\n        // So these multiples of p are big enough to avoid underflow\n        // in subtraction, and small enough to fit within u64\n        // with room for a carry.\n\n        let low__p37 = u64x4::splat(0x3ffffed << 37);\n        let even_p37 = u64x4::splat(0x3ffffff << 37);\n        let odd__p37 = u64x4::splat(0x1ffffff << 37);\n\n        let negate_D = |x: u64x4, p: u64x4| -> u64x4 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(x.into(), (p - x).into(), D_LANES64 as i32).into()\n            }\n        };\n\n        z0 = negate_D(z0, low__p37);\n        z1 = negate_D(z1, odd__p37);\n        z2 = negate_D(z2, even_p37);\n        z3 = negate_D(z3, odd__p37);\n        z4 = negate_D(z4, even_p37);\n        z5 = negate_D(z5, odd__p37);\n        z6 = negate_D(z6, even_p37);\n        z7 = negate_D(z7, odd__p37);\n        z8 = negate_D(z8, even_p37);\n        z9 = negate_D(z9, odd__p37);\n\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }",
    "display_name": "square_and_negate_D",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 Signature/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/signature.rs",
    "relative_path": "ed25519-dalek/src/signature.rs",
    "file_name": "signature.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/from_bytes",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/From/from",
      "3.0.0_pre.0 signing/ExpandedSecretKey/From/from"
    ],
    "body": "",
    "display_name": "from_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "bits/lemma_low_bits_mask_values",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_low_bits_mask_values",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "power2/arithmetic/lemma_pow2_pos",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_pow2_pos",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/verifying_key",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "verifying_key",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "mul/arithmetic/lemma_mul_is_distributive_add",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_is_distributive_add",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto_benches/double_and_compress_batch",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/RistrettoPoint/double_and_compress_batch",
      "benchmark_group/BenchmarkId/new",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "bencher/Bencher/iter",
      "benchmark_group/BenchmarkGroup/bench_with_input",
      "5.0.0_pre.0 ristretto/RistrettoPoint/try_from_rng",
      "core https:/github.com/rust_lang/rust/library/core result/Result/unwrap",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map"
    ],
    "body": "    fn double_and_compress_batch<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in &BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch Ristretto double-and-encode\", *batch_size),\n                &batch_size,\n                |b, &&size| {\n                    let mut rng = OsRng;\n                    let points: Vec<RistrettoPoint> = (0..size)\n                        .map(|_| RistrettoPoint::try_from_rng(&mut rng).unwrap())\n                        .collect();\n                    b.iter(|| RistrettoPoint::double_and_compress_batch(&points));\n                },\n            );\n        }\n    }",
    "display_name": "double_and_compress_batch",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base"
    ],
    "body": "",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "ConditionallyNegatable/conditional_negate",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "conditional_negate",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/x25519",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_clamped",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_bytes"
    ],
    "body": "",
    "display_name": "x25519",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 rfc7748_ladder_test1_vectorset2",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 do_rfc7748_ladder_test1"
    ],
    "body": "fn rfc7748_ladder_test1_vectorset2() {\n    let input_scalar: [u8; 32] = [\n        0x4b, 0x66, 0xe9, 0xd4, 0xd1, 0xb4, 0x67, 0x3c, 0x5a, 0xd2, 0x26, 0x91, 0x95, 0x7d, 0x6a,\n        0xf5, 0xc1, 0x1b, 0x64, 0x21, 0xe0, 0xea, 0x01, 0xd4, 0x2c, 0xa4, 0x16, 0x9e, 0x79, 0x18,\n        0xba, 0x0d,\n    ];\n    let input_point: [u8; 32] = [\n        0xe5, 0x21, 0x0f, 0x12, 0x78, 0x68, 0x11, 0xd3, 0xf4, 0xb7, 0x95, 0x9d, 0x05, 0x38, 0xae,\n        0x2c, 0x31, 0xdb, 0xe7, 0x10, 0x6f, 0xc0, 0x3c, 0x3e, 0xfc, 0x4c, 0xd5, 0x49, 0xc7, 0x15,\n        0xa4, 0x93,\n    ];\n    let expected: [u8; 32] = [\n        0x95, 0xcb, 0xde, 0x94, 0x76, 0xe8, 0x90, 0x7d, 0x7a, 0xad, 0xe4, 0x5c, 0xb4, 0xb8, 0x73,\n        0xf8, 0x8b, 0x59, 0x5a, 0x68, 0x79, 0x9f, 0xa1, 0x52, 0xe6, 0xf8, 0xf7, 0x64, 0x7a, 0xac,\n        0x79, 0x57,\n    ];\n\n    do_rfc7748_ladder_test1(input_scalar, input_point, expected);\n}",
    "display_name": "rfc7748_ladder_test1_vectorset2",
    "full_path": "file:///work/3185/x25519-dalek/tests/x25519_tests.rs",
    "relative_path": "x25519-dalek/tests/x25519_tests.rs",
    "file_name": "x25519_tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "clone/gen/FnArg/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/hash_to_curve",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/FieldElement51/invert",
      "5.0.0_pre.0 montgomery/elligator_encode",
      "core https:/github.com/rust_lang/rust/library/core option/Option/expect",
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_bytes",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_edwards",
      "5.0.0_pre.0 field/FieldElement51/is_negative",
      "5.0.0_pre.0 field/FieldElement51/hash_to_field",
      "ConditionallyNegatable/conditional_negate",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_cofactor"
    ],
    "body": "",
    "display_name": "hash_to_curve",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Add/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/add",
      "5.0.0_pre.0 scalar/Scalar/unpack",
      "5.0.0_pre.0 scalar/Scalar52/pack"
    ],
    "body": "    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/nine_limbs_to_nat_aux",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2"
    ],
    "body": "}\n\npub proof fn lemma_52_52(x: u64, y: u64)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures (x as u128) * (y as u128) < (1u128 << 104)\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert( x * y < x * (1u128 << 52)  );\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}",
    "display_name": "nine_limbs_to_nat_aux",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "bencher/Bencher/iter_batched",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "iter_batched",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 window/NafLookupTable5/From/from",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/EdwardsPoint/double",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_affine_niels",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective_niels"
    ],
    "body": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/as_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_mul",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_rr_limbs_bounded",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/montgomery_radix"
    ],
    "body": "where\n    T: Borrow<Scalar>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }\n}",
    "display_name": "as_montgomery",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 straus/scalar_mul/serial/backend/Straus/MultiscalarMul/multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2",
      "5.0.0_pre.0 edwards/EdwardsPoint/Identity/identity",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "core https:/github.com/rust_lang/rust/library/core convert/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "Zeroize/zeroize"
    ],
    "body": "    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    Avx512ifma(\n        vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus,\n    ),\n    Scalar(serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus),\n}\n\n#[cfg(feature = \"alloc\")]\nimpl VartimePrecomputedStraus {\n    pub fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<EdwardsPoint>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match get_selected_backend() {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            BackendKind::Avx2 =>\n                VartimePrecomputedStraus::Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus::new(static_points)),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            BackendKind::Avx512 =>\n                VartimePrecomputedStraus::Avx512ifma(vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus::new(static_points)),\n            BackendKind::Serial =>\n                VartimePrecomputedStraus::Scalar(serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus::new(static_points))\n        }\n    }\n\n    /// Return the number of static points in the precomputation.\n    pub fn len(&self) -> usize {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.len(),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.len(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.len(),\n        }\n    }\n\n    /// Determine if the precomputation is empty.\n    pub fn is_empty(&self) -> bool {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.is_empty(),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.is_empty(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.is_empty(),\n        }\n    }\n\n    pub fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: core::borrow::Borrow<Scalar>,\n        K: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }\n}",
    "display_name": "multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/negate",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/reduce"
    ],
    "body": "    pub fn negate(&mut self) {\n        // See commentary in the Sub impl\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.0[0],\n            36028797018963952u64 - self.0[1],\n            36028797018963952u64 - self.0[2],\n            36028797018963952u64 - self.0[3],\n            36028797018963952u64 - self.0[4],\n        ]);\n        self.0 = neg.0;\n    }",
    "display_name": "negate",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_shl_le_u64",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2",
      "5.0.0_pre.0 common_verus/u64/serial/backend/mul_le"
    ],
    "body": "pub proof fn lemma_shl_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64,\n        (b * pow2(k)) <= u64::MAX,\n    ensures\n        (a << k) <= (b << k)\n{\n    mul_le(a as nat, b as nat, pow2(k), pow2(k));\n    lemma_u64_shl_is_mul(a, k as u64);\n    lemma_u64_shl_is_mul(b, k as u64);\n}",
    "display_name": "lemma_shl_le_u64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core repeat_with/sources/iter/repeat_with",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "repeat_with",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/decompress",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 decompress/edwards/step_2",
      "5.0.0_pre.0 decompress/edwards/step_1"
    ],
    "body": "\n        // Find an R such that\n        //     H(R || A || M)  A == A == H(R || A || M)  A\n        // This happens with high probability when A is low order.\n        while !(pubkey.neg() + compute_challenge(message1, &pubkey, &r, None) * pubkey)\n            .is_identity()\n            || !(pubkey.neg() + compute_challenge(message2, &pubkey, &r, None) * pubkey)\n                .is_identity()\n        {\n            // We pick an s and let R = sB - A where B is the basepoint\n            s = non_null_scalar();\n            r = pick_r(s);\n        }",
    "display_name": "decompress",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_u64_max_shifting",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/pow2",
      "div_mod/arithmetic/lemma_div_multiples_vanish",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "power2/arithmetic/lemma_pow2_adds",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shl_decomposition",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shr_decomposition",
      "power2/arithmetic/lemma_pow2_strictly_increases",
      "5.0.0_pre.0 common_verus/u64/serial/backend/mul_le",
      "power2/arithmetic/lemma2_to64_rest",
      "power2/arithmetic/lemma2_to64"
    ],
    "body": "pub proof fn lemma_u64_max_shifting(k:nat)\n    requires\n        1 <= k < 64\n    ensures\n        u64::MAX >> k < 1u64 << (64 - k)\n    decreases 64-k\n{\n    let M = u64::MAX;\n\n    // recursion base case\n    if (k == 63){\n        assert(u64::MAX >> 63 < 1u64 << 1) by (compute);\n    }\n    else {\n        // M >> (k + 1) < 1 << (63 - k)\n        lemma_u64_max_shifting(k + 1);\n\n        // M >> (k + 1) = (M >> k) >> 1\n        shr_decomposition(M, k, 1);\n\n        // precondition\n        lemma2_to64_rest(); // pow2(63)\n        lemma_pow2_strictly_increases((63 - k) as nat, (64 - k) as nat);\n\n        assert(1u64 * pow2((64 - k) as nat) <= 1u64 * pow2(63)) by {\n            if (k == 1) {\n                // 64 - k = 63\n                // tautology\n            }\n            else {\n                // 64 - k < 63\n                lemma_pow2_strictly_increases((64 - k) as nat, 63);\n            }\n            mul_le(1u64 as nat, 1u64 as nat, pow2((64 - k) as nat), pow2(63));\n        }\n        assert( 1u64 * pow2(63) <= u64::MAX) by (compute);\n\n        // 1 << 64 - k = (1 << 63 - k) << 1\n        shl_decomposition(1u64, (63 - k) as nat, 1);\n\n        // (M >> k) >> 1 = (M >> k) / pow2(1);\n        lemma_u64_shr_is_div( M >> k, 1);\n\n        // lemma_u64_shl_is_mul(x, n) precondition: x * pow2(n) <= u64::MAX\n        assert((1u64 << ((63 - k))) * pow2(1) <= u64::MAX) by {\n            shift_is_pow2((63 - k) as nat);\n            lemma_pow2_adds((63-k) as nat, 1);\n        }\n\n        // (1 << 63 - k) << 1 = (1 << 63 - k) * pow2(1);\n        lemma_u64_shl_is_mul( 1u64 << ((63 - k)), 1);\n\n        lemma2_to64(); // pow2(1) = 2\n\n        assert((1u64 << ((64 - k) as u64)) / 2 == (1u64 << ((63 - k) as u64))) by {\n            lemma_div_multiples_vanish((1u64 << (63 - k) as u64) as int, 2);\n        }\n    }\n}",
    "display_name": "lemma_u64_max_shifting",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_sub_mod_noop",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_sub_mod_noop",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "collect",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 main",
    "statement_type": "function",
    "deps": [
      "std https:/github.com/rust_lang/rust/library/std env/var",
      "core https:/github.com/rust_lang/rust/library/core result/Result/as_deref",
      "version_meta",
      "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
      "alloc https:/github.com/rust_lang/rust/library/alloc string/ToString/to_string",
      "5.0.0_pre.0 is_capable_simd",
      "5.0.0_pre.0 deterministic/determine_curve25519_dalek_bits",
      "version"
    ],
    "body": "fn main() {\n    let target_arch = match std::env::var(\"CARGO_CFG_TARGET_ARCH\") {\n        Ok(arch) => arch,\n        _ => \"\".to_string(),\n    };\n\n    let curve25519_dalek_bits = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BITS\").as_deref() {\n        Ok(\"32\") => DalekBits::Dalek32,\n        Ok(\"64\") => DalekBits::Dalek64,\n        _ => deterministic::determine_curve25519_dalek_bits(&target_arch),\n    };\n\n    println!(\"cargo:rustc-cfg=curve25519_dalek_bits=\\\"{curve25519_dalek_bits}\\\"\");\n\n    let nightly = if rustc_version::version_meta()\n        .expect(\"failed to detect rustc version\")\n        .channel\n        == rustc_version::Channel::Nightly\n    {\n        println!(\"cargo:rustc-cfg=nightly\");\n        true\n    } else {\n        false\n    };\n\n    let rustc_version = rustc_version::version().expect(\"failed to detect rustc version\");\n    if rustc_version.major == 1 && rustc_version.minor <= 64 {\n        // Old versions of Rust complain when you have an `unsafe fn` and you use `unsafe {}` inside,\n        // so for those we want to apply the `#[allow(unused_unsafe)]` attribute to get rid of that warning.\n        println!(\"cargo:rustc-cfg=allow_unused_unsafe\");\n    }\n\n    // Backend overrides / defaults\n    let curve25519_dalek_backend = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BACKEND\")\n        .as_deref()\n    {\n        Ok(\"fiat\") => \"fiat\",\n        Ok(\"serial\") => \"serial\",\n        Ok(\"simd\") => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => \"simd\",\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to simd\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if nightly => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => {\n                    // In addition enable Avx2 fallback through simd stable backend\n                    // NOTE: Compiler permits duplicate / multi value on the same key\n                    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"simd\\\"\");\n\n                    \"unstable_avx512\"\n                }\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to unstable_avx512\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if !nightly => {\n            panic!(\n                \"Could not override curve25519_dalek_backend to unstable_avx512, as this is nightly only\"\n            );\n        }\n        // default between serial / simd (if potentially capable)\n        _ => match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n            true => \"simd\",\n            false => \"serial\",\n        },\n    };\n    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"{curve25519_dalek_backend}\\\"\");\n}",
    "display_name": "main",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/vartime_precomputed_vs_nonprecomputed_multiscalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/random",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/len",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/chain",
      "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/is_empty",
      "5.0.0_pre.0 traits/VartimeMultiscalarMul/vartime_multiscalar_mul",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/sum",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "thread/rngs/rng",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress",
      "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base"
    ],
    "body": "    fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let static_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let check_scalar: Scalar = static_scalars\n            .iter()\n            .chain(dynamic_scalars.iter())\n            .map(|s| s * s)\n            .sum();\n\n        let static_points = static_scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n        let dynamic_points = dynamic_scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let precomputation = VartimeEdwardsPrecomputation::new(static_points.iter());\n\n        assert_eq!(precomputation.len(), 128);\n        assert!(!precomputation.is_empty());\n\n        let P = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        use crate::traits::VartimeMultiscalarMul;\n        let Q = EdwardsPoint::vartime_multiscalar_mul(\n            static_scalars.iter().chain(dynamic_scalars.iter()),\n            static_points.iter().chain(dynamic_points.iter()),\n        );\n\n        let R = EdwardsPoint::mul_base(&check_scalar);\n\n        assert_eq!(P.compress(), R.compress());\n        assert_eq!(Q.compress(), R.compress());\n    }",
    "display_name": "vartime_precomputed_vs_nonprecomputed_multiscalar",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 test/hazmat/ExpandedSecretKey/random",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 hazmat/ExpandedSecretKey/from_bytes"
    ],
    "body": "        fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n            let mut bytes = [0u8; 64];\n            rng.fill_bytes(&mut bytes);\n            ExpandedSecretKey::from_bytes(&bytes)\n        }",
    "display_name": "random",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 traits/IsIdentity/is_identity",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 traits/Identity/identity",
      "ConstantTimeEq/ct_eq",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    #[inline]\n    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0.to_bytes()\n    }",
    "display_name": "is_identity",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/random",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order_wide"
    ],
    "body": "        let encoded_verifying_key: Vec<u8> = bincode::serialize(&verifying_key).unwrap();\n        let decoded_verifying_key: VerifyingKey =\n            bincode::deserialize(&encoded_verifying_key).unwrap();\n\n        assert_eq!(\n            &PUBLIC_KEY_BYTES[..],\n            &encoded_verifying_key[encoded_verifying_key.len() - PUBLIC_KEY_LENGTH..]\n        );\n        assert_eq!(verifying_key, decoded_verifying_key);\n    }\n\n    #[test]\n    fn serialize_deserialize_verifying_key_json() {\n        let verifying_key: VerifyingKey = VerifyingKey::from_bytes(&PUBLIC_KEY_BYTES).unwrap();\n        let encoded_verifying_key = serde_json::to_string(&verifying_key).unwrap();\n        let decoded_verifying_key: VerifyingKey =\n            serde_json::from_str(&encoded_verifying_key).unwrap();\n\n        assert_eq!(verifying_key, decoded_verifying_key);\n    }",
    "display_name": "random",
    "full_path": "file:///work/3185/ed25519-dalek/tests/ed25519.rs",
    "relative_path": "ed25519-dalek/tests/ed25519.rs",
    "file_name": "ed25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/StaticSecret/AsRef/as_ref",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 x25519/StaticSecret/as_bytes"
    ],
    "body": "    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }",
    "display_name": "as_ref",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_basic_div",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_basic_div",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core result/Result/map_err",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "map_err",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/pow2k",
    "statement_type": "function",
    "deps": [
      "mul/arithmetic/lemma_mul_is_distributive_sub_other_way",
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_pow2_square",
      "power2/arithmetic/lemma2_to64_rest",
      "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_cast_then_mask_51",
      "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_div_and_mod_51",
      "power/arithmetic/pow",
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_mod_diff_factor",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_cast_then_mod_51",
      "div_mod/arithmetic/lemma_mul_mod_noop",
      "power2/arithmetic/lemma2_to64",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_reorder_mul",
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_pow_nat_is_nat",
      "power/arithmetic/lemma_pow1",
      "5.0.0_pre.0 field_verus/u64/serial/backend/masked_lt_51",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat",
      "mul/arithmetic/lemma_mul_is_associative",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/as_nat_squared",
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_m",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_shr_51_fits_u64",
      "5.0.0_pre.0 field_verus/u64/serial/backend/m",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/p",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_shr_51_le",
      "power2/arithmetic/lemma_pow2_adds",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "5.0.0_pre.0 vstd_u128/u64/serial/backend/lemma_u128_low_bits_mask_is_mod",
      "div_mod/arithmetic/lemma_fundamental_div_mod",
      "power2/arithmetic/pow2",
      "mul/arithmetic/lemma_mul_is_distributive_sub",
      "5.0.0_pre.0 field_verus/u64/serial/backend/l51_bit_mask_lt",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/pow255_gt_19"
    ],
    "body": "    pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n        requires\n            k > 0, // debug_assert!( k > 0 );\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54 // 51 + b for b = 3\n        ensures\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(k as nat)) as nat % p(),\n    {\n        let mut a: [u64; 5] = self.limbs;\n\n        // pre-loop invariant, i = 0\n        proof {\n            assert(as_nat(a) == pow(as_nat(self.limbs) as int, pow2(0))) by {\n                lemma2_to64(); // pow2(0) = 1\n                lemma_pow1(as_nat(self.limbs) as int);\n            }\n        }\n\n        for i in 0..k\n            invariant\n                forall |i: int| 0 <= i < 5 ==> a[i] < 1u64 << 54,\n                as_nat(a) % p() == pow(as_nat(self.limbs) as int, pow2(i as nat)) as nat % p(),\n        {\n            proof {\n                pow255_gt_19(); // p > 0\n                lemma2_to64_rest(); // pow2(51 | 54)\n                shift_is_pow2(54);\n\n                let bound = 1u64 << 54;\n                let bound19 = (19 * bound) as u64;\n                let bound_sq = 1u128 << 108;\n                // u64 to u128 conversion forces extra assert\n                assert( (1u64 << 54) * ((19 * (1u64 << 54)) as u64) == 19 * (1u128 << 108)) by (bit_vector);\n\n                // bv arithmetic\n                assert(19 < (1u64 << 5)) by (bit_vector);\n                assert((1u64 << 51) < (1u64 << 52)) by (bit_vector);\n                assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 54) < (1u64 << 59)) by (bit_vector);\n                assert((1u64 << 54) * (1u64 << 5) == (1u64 << 59)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 54) as u128) == (1u128 << 108)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 59) as u128) == (1u128 << 113)) by (bit_vector);\n\n                let a3_19 = (19 * a[3]) as u64;\n                let a4_19 = (19 * a[4]) as u64;\n\n                // c0\n                let c0_0: u128 = (a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19)) as u128;\n                lemma_m(a[0], a[0], bound, bound);\n                lemma_m(a[1], a4_19, bound, bound19);\n                lemma_m(a[2], a3_19, bound, bound19);\n                // conclusion, (1 + 2 * (19 + 19)) = 77\n                assert(c0_0 < 77 * bound_sq);\n\n                // c1\n                let c1_0: u128 = (a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)) as u128;\n                lemma_m(a[3], a3_19, bound, bound19);\n                lemma_m(a[0],  a[1], bound, bound);\n                lemma_m(a[2], a4_19, bound, bound19);\n                // conclusion, (19 + 2 * (1 + 19)) = 59\n                assert(c1_0 < 59 * bound_sq);\n\n                // c2\n                let c2_0: u128 = (a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19)) as u128;\n                lemma_m(a[1],  a[1], bound, bound);\n                lemma_m(a[0],  a[2], bound, bound);\n                lemma_m(a[4], a3_19, bound, bound19);\n                // conclusion, (1 + 2 * (1 + 19)) = 41\n                assert(c2_0 < 41 * bound_sq);\n\n                // c3\n                let c3_0: u128 = (a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2])) as u128;\n                lemma_m(a[4], a4_19, bound, bound19);\n                lemma_m(a[0],  a[3], bound, bound);\n                lemma_m(a[1],  a[2], bound, bound);\n                // conclusion, (19 + 2 * (1 + 1)) = 23\n                assert(c3_0 < 23 * bound_sq);\n\n                // c4\n                let c4_0: u128 = (a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3])) as u128;\n                lemma_m(a[2],  a[2], bound, bound);\n                lemma_m(a[0],  a[4], bound, bound);\n                lemma_m(a[1],  a[3], bound, bound);\n                // conclusion, (1 + 2 * (1 + 1)) = 5\n                assert(c4_0 < 5 * bound_sq);\n\n                assert( 77 * bound_sq <= ((u64::MAX as u128) << 51)) by (compute); // all ci_0 are then < MAX << 51\n\n                lemma_shr_51_fits_u64(c0_0);\n\n                let c1 = (c1_0 + ((c0_0 >> 51) as u64) as u128) as u128;\n                let a0_0 = (c0_0 as u64) & LOW_51_BIT_MASK;\n\n                lemma_shr_51_fits_u64(c1);\n                // a0_0 < (1u64 << 51)\n                masked_lt_51(c0_0 as u64);\n\n                let c2 = (c2_0 + ((c1 >> 51) as u64) as u128) as u128;\n                let a1_0 = (c1 as u64) & LOW_51_BIT_MASK;\n\n                lemma_shr_51_fits_u64(c2);\n                // a1_0 < (1u64 << 51)\n                masked_lt_51(c1 as u64);\n\n                let c3 = (c3_0 + ((c2 >> 51) as u64) as u128) as u128;\n                let a2 = (c2 as u64) & LOW_51_BIT_MASK;\n\n                lemma_shr_51_fits_u64(c3);\n                // a2 < (1u64 << 51)\n                masked_lt_51(c2 as u64);\n\n                let c4 = (c4_0 + ((c3 >> 51) as u64) as u128) as u128;\n                let a3 = (c3 as u64) & LOW_51_BIT_MASK;\n\n                lemma_shr_51_fits_u64(c4);\n                // a3 < (1u64 << 51)\n                masked_lt_51(c3 as u64);\n\n                let carry: u64 = (c4 >> 51) as u64;\n                let a4 = (c4 as u64) & LOW_51_BIT_MASK;\n\n                // a4 < (1u64 << 51)\n                masked_lt_51(c4 as u64);\n\n                assert(c4 <= c4_0 + (u64::MAX as u128));\n                lemma_shr_51_le(c4, (5 * bound_sq + (u64::MAX as u128)) as u128 );\n\n                // From the comments below:\n                // c4 < 2^110.33  so that carry < 2^59.33\n                // and\n                // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n\n                // ceil(2^59.33)\n                let pow2_5933 = 724618875532318195u64;\n\n                assert((5 * (1u128 << 108) + (u64::MAX as u128)) as u128 >> 51 < (pow2_5933 as u128)) by (compute);\n                assert(carry < pow2_5933);\n\n                // a[0] += carry * 19 fits in u64\n                assert((1u64 << 51) + 19 * pow2_5933 <= u64::MAX) by (compute);\n                let a0_1 = (a0_0 + carry * 19) as u64;\n\n                lemma_shr_51_le(a0_1 as u128, u64::MAX as u128);\n                assert( ((u64::MAX as u128) >> 51) < (1u64 << 13) ) by (compute);\n\n                // a1_0 < (1u64 << 51)\n                assert((1u64 << 51) + (1u64 << 13) < (1u64 << 52)) by (compute);\n\n                // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n                assert(a1_0 + (a0_1 >> 51) < (1u64 << 52));\n                let a1_1 = (a1_0 + (a0_1 >> 51)) as u64;\n\n                let a0_2 = a0_1 & LOW_51_BIT_MASK;\n                // a0_2 < (1u64 << 51)\n                masked_lt_51(a0_1 as u64);\n\n                //---- end of no-overflow proof ----\n                // Loop invariant: after i loops we have as_nat(a) % p = as_nat(self.limbs) ^ (2 ^ i) % p\n                let a_hat = [a0_2, a1_1, a2, a3, a4];\n                assert(as_nat(a_hat) % p() == (as_nat(a) * as_nat(a)) % p() ) by {\n                    // it suffices to prove as_nat(a_hat) == (as_nat(a))^2 (mod p)\n                    // let s = pow2(51) for brevity\n\n                    // By definition, as_nat(a_hat) = a0_2 + s * a1_1 + s^2 * a2 + s^3 * a3 + s^4 * a4\n                    // a0_2 + s * a1_1 cancel out terms via the div/mod identity:\n                    assert(as_nat(a_hat) ==\n                        a0_1 +\n                        pow2(51) * a1_0 +\n                        pow2(102) * a2 +\n                        pow2(153) * a3 +\n                        pow2(204) * a4\n                    ) by {\n                        // a0_2 + s * a1_1 =\n                        // a0_1 % s  + s * (a1_0 + s * (a0_1 / s)) =\n                        // s * a1_0 + [s * (a0_1 / s) + a0_1 % s] = (by the div-mod identity)\n                        // s * a1_0 + a0_1\n                        assert(a0_2 + pow2(51) * a1_1 == a0_1 + pow2(51) * a1_0) by {\n                            lemma_div_and_mod_51((a0_1 >> 51), a0_2, a0_1);\n                        }\n                    }\n\n                    // Next, we replace all _ & LOW_BITS_MASK with (mod s)\n                    assert(as_nat(a_hat) ==\n                        ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry +\n                        pow2( 51) * ((c1 as u64) % (pow2(51) as u64)) +\n                        pow2(102) * ((c2 as u64) % (pow2(51) as u64)) +\n                        pow2(153) * ((c3 as u64) % (pow2(51) as u64)) +\n                        pow2(204) * ((c4 as u64) % (pow2(51) as u64))\n                    ) by {\n                        // TODO: we need lemma_u128_low_bits_mask_is_mod in vstd!\n                        broadcast use lemma_cast_then_mask_51;\n                        broadcast use lemma_u128_low_bits_mask_is_mod;\n                        l51_bit_mask_lt();\n                    }\n\n                    // We can see all mod operations in u128\n                    assert(as_nat(a_hat) ==\n                        (c0_0 % (pow2(51) as u128)) + 19 * carry +\n                        pow2( 51) * (c1 % (pow2(51) as u128)) +\n                        pow2(102) * (c2 % (pow2(51) as u128)) +\n                        pow2(153) * (c3 % (pow2(51) as u128)) +\n                        pow2(204) * (c4 % (pow2(51) as u128))\n                    ) by {\n                        // pow2(51) is the same in u64 and 128\n                        lemma_cast_then_mod_51(c0_0);\n                        lemma_cast_then_mod_51(c1);\n                        lemma_cast_then_mod_51(c2);\n                        lemma_cast_then_mod_51(c3);\n                        lemma_cast_then_mod_51(c4);\n                    }\n\n                    // Next, we categorically replace a % s with a - s * ( a / s )\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c0_0 / (pow2(51) as u128))) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c1/ (pow2(51) as u128))) +\n                        pow2(102) * (c2 - pow2(51) * (c2/ (pow2(51) as u128))) +\n                        pow2(153) * (c3 - pow2(51) * (c3/ (pow2(51) as u128))) +\n                        pow2(204) * (c4 - pow2(51) * (c4/ (pow2(51) as u128)))\n                    ) by {\n                        broadcast use lemma_fundamental_div_mod;\n                    }\n\n                    // Then, we know that\n                    // carry = c4/s\n                    // c4 = c4_0 + c3/s <=> c3/s = c4 - c4_0\n                    // c3 = c3_0 + c2/s <=> c2/s = c3 - c3_0\n                    // c2 = c2_0 + c1/s <=> c1/s = c2 - c2_0\n                    // c1 = c1_0 + c0_0/s <=> c0_0/s = c1 - c1_0\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c1 - c1_0)) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) +\n                        pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) +\n                        pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) +\n                        pow2(204) * (c4 - pow2(51) * carry)\n                    ) by {\n                        broadcast use lemma_u128_shr_is_div;\n                    }\n\n                    // Now we use distributivity and pow exponent sums, which cancels out any ci terms and leaves only ci_0 terms\n                    // Conveniently, we're left with a difference of c * p\n                    assert(as_nat(a_hat) ==\n                        c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0 -\n                        p() * carry\n                    ) by {\n                        broadcast use lemma_mul_is_associative;\n                        broadcast use lemma_mul_is_distributive_sub;\n\n                        lemma_pow2_adds(51, 51);\n                        lemma_pow2_adds(51, 102);\n                        lemma_pow2_adds(51, 153);\n                        lemma_pow2_adds(51, 204);\n\n                        // carry on the right, get p\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n                        pow255_gt_19();\n                    }\n\n                    let c_arr_as_nat = (c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0\n                        );\n\n\n                    assert(as_nat(a_hat) % p() == c_arr_as_nat as nat % p()) by {\n                        lemma_mod_diff_factor(carry as int, c_arr_as_nat as int, p() as int);\n                    }\n\n                    // We use the as_nat_squared lemma to see what (as_nat(a)^2) evaluates to (mod p)\n\n                    // The nat_squared lemma gives us the following:\n                    // as_nat(a) * as_nat(a) ==\n                    // pow2(8 * 51) * (a[4] * a[4]) +\n                    // pow2(7 * 51) * (2 * (a[3] * a[4])) +\n                    // pow2(6 * 51) * (a[3] * a[3] + 2 * (a[2] * a[4])) +\n                    // pow2(5 * 51) * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])) +\n                    // pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    // pow2(3 * 51) * (2 * (a[1] * a[2]) + 2 * (a[0] * a[3])) +\n                    // pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] * a[2])) +\n                    // pow2(1 * 51) * (2 * (a[0] * a[1])) +\n                    //                (a[0] * a[0])\n                    //\n                    // AND\n                    //\n                    // (as_nat(a) * as_nat(a)) % p() ==\n                    // (\n                    //     pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    //     pow2(3 * 51) * (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])) +\n                    //     pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))) +\n                    //     pow2(1 * 51) * (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))) +\n                    //                    (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))\n                    // ) as nat % p()\n                    as_nat_squared(a);\n\n                    // We're basically done, what remains is to prove that the coefficients next to pow2(i * 51)\n                    // are exactly ci_0s (via distributivity and associativity)\n\n                    // let c0_0: u128 = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                    assert(c0_0 == (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))) by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                        //     = a[0] *  a[0] + 2*( a[1] * a4_19 ) + 2 * (a[2] * a3_19);\n                        // RHS = a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))\n                        //     = a[0] *  a[0] + 19 * (2 * (a[2] * a[3])) + 19 * (2 * (a[1] * a[4]))\n\n                        // goals\n                        // 1) 2 * (a[1] * a4_19) = 19 * (2 * (a[1] * a[4]))\n                        // 2) 2 * (a[2] * a3_19) = 19 * (2 * (a[2] * a[3]))\n\n                        assert(2*(a[1] * a4_19) == 19 * (2 * (a[1] * a[4]))) by {\n                            lemma_reorder_mul(a[1] as int, a[4] as int);\n                        }\n\n                        assert(2*(a[2] * a3_19) == 19 * (2 * (a[2] * a[3]))) by {\n                            lemma_reorder_mul(a[2] as int, a[3] as int);\n                        }\n                    }\n\n                    // let c1_0: u128 = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19);\n                    assert(c1_0 == (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)\n                        //     = a[3] * a3_19 + 2*( a[0] *  a[1]) + 2 * (a[2] * a4_19)\n                        // RHS = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))\n                        //     = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3]) + 19 * (2 * (a[2] * a[4]))\n\n                        // goals: 1) a[3] * a3_19 = 19 * (a[3] * a[3])\n                        //        2) 2 * (a[2] * a4_19) = 19 * (2 * (a[2] * a[4]))\n\n                        assert(a[3] * a3_19 == 19 * (a[3] * a[3])) by {\n                            lemma_mul_is_associative(a[3] as int, a[3] as int, 19);\n                        }\n\n                        assert(2*(a[2] * a4_19) == 19 * (2 * (a[2] * a[4]))) by {\n                            lemma_reorder_mul(a[2] as int, a[4] as int);\n                        }\n                    }\n\n                    // let c2_0: u128 = a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19);\n                    assert(c2_0 == (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[1] * a[1] + 2 * (a[0] *  a[2] + a[4] * a3_19)\n                        //     = a[1] * a[1] + 2 * (a[0] *  a[2]) +  2 * (a[4] * a3_19)\n                        // RHS = a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))\n\n                        // goals: 2 * (a[4] * a3_19) = 19 * (2 * (a[3] * a[4]))\n\n                        assert(2 * (a[4] * a3_19) == 19 * (2 * (a[3] * a[4]))) by {\n                            lemma_mul_is_associative(a[4] as int, a[3] as int, 19);\n                        }\n                    }\n\n                    // let c3_0: u128 = a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]);\n                    assert(c3_0 == (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[4] * a4_19 + 2 * (a[0] *  a[3] + a[1] *  a[2])\n                        //     = a[4] * a4_19 + 2 * (a[0] *  a[3]) + 2 * (a[1] *  a[2])\n                        // RHS = 2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])\n\n                        // goals: a[4] * a4_19 = 19 * (a[4] * a[4])\n\n                        assert(a[4] * a4_19 == 19 * (a[4] * a[4])) by {\n                            lemma_mul_is_associative(a[4] as int, a[4] as int, 19);\n                        }\n                    }\n\n                    // let c4_0: u128 = a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]);\n                    assert(c4_0 == (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])\n                        //     = a[2] * a[2] + 2 * (a[0] * a[4]) + 2 * (a[1] * a[3])\n                        // RHS = a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])\n\n                        // goals: none\n                    }\n                }\n\n                let a_pow_2i_int = pow(as_nat(self.limbs) as int, pow2(i as nat));\n                assert(a_pow_2i_int >= 0) by {\n                    lemma_pow_nat_is_nat(as_nat(self.limbs), i as nat);\n                }\n                let a_pow_2i: nat = a_pow_2i_int as nat;\n\n                assert(as_nat(a_hat) % p() ==\n                    ((as_nat(a) % p()) * (as_nat(a) % p())) % p()\n                ) by {\n                    lemma_mul_mod_noop(as_nat(a) as int, as_nat(a) as int, p() as int);\n                }\n\n                // (a_pow_2i % p)^2 % p = (a_pow_2i^2) % p\n                lemma_mul_mod_noop(a_pow_2i as int, a_pow_2i as int, p() as int);\n\n                // We know, by the loop inv, that\n                // as_nat(a) % p == a_pow_2i % p\n                // and, by the above\n                // as_nat(a_hat) % p  = (as_nat(a) * as_nat(a)) % p = (a_pow_2i ^ 2)) % p\n                // It suffices to prove that\n                // (v^(2^i))^2 = v^(2^(i + 1))\n                lemma_pow2_square(as_nat(self.limbs) as int, i as nat);\n            }\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n            // debug_assert!(a[0] < (1 << 54));\n            // debug_assert!(a[1] < (1 << 54));\n            // debug_assert!(a[2] < (1 << 54));\n            // debug_assert!(a[3] < (1 << 54));\n            // debug_assert!(a[4] < (1 << 54));\n\n            // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n        }\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs: a}\n    }",
    "display_name": "pow2k",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/low_bits_mask_increases",
    "statement_type": "function",
    "deps": [
      "bits/lemma_low_bits_mask_unfold",
      "bits/low_bits_mask",
      "bits/lemma_low_bits_mask_div2",
      "bits/lemma_low_bits_mask_values"
    ],
    "body": "pub proof fn low_bits_mask_increases(a: nat, b: nat)\n    requires\n        a < b\n    ensures\n        low_bits_mask(a) < low_bits_mask(b)\n    decreases a + b\n{\n    if (a == 0){\n         // lbm(0) = 0\n        lemma_low_bits_mask_values();\n        // lbm(b) = 2 * lbm(b - 1) + 1, in particular, > 0\n        lemma_low_bits_mask_unfold(b);\n    }\n    else {\n        // lbm(b) / 2 = lbm(b - 1)\n        lemma_low_bits_mask_div2(b);\n        // lbm(a) / 2 = lbm(a - 1)\n        lemma_low_bits_mask_div2(a);\n        // lbm(a - 1) < lbm(b - 1)\n        low_bits_mask_increases((a - 1) as nat, (b - 1) as nat);\n    }\n\n}",
    "display_name": "low_bits_mask_increases",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_specs/u64/serial/backend/words_to_nat",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/words_to_nat_gen_u64"
    ],
    "body": "        }\n        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)\n        assume(bytes_to_nat(bytes) == words_to_nat(&words));\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }",
    "display_name": "words_to_nat",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/IndexMut/index_mut",
    "statement_type": "function",
    "deps": [],
    "body": "    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.limbs[_index])\n    }",
    "display_name": "index_mut",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/VartimeEdwardsPrecomputation/VartimePrecomputedMultiscalarMul/new",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/VartimePrecomputedStraus/new"
    ],
    "body": "",
    "display_name": "new",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/to_bytes",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_bytes(&self) -> SecretKey {\n        self.secret_key\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 spec/variable_base/scalar_mul/vector/backend/mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/LookupTable/From/from",
      "5.0.0_pre.0 scalar/Scalar/as_radix_16",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Identity/identity",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/mul_by_pow_2",
      "5.0.0_pre.0 window/LookupTable/select",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into"
    ],
    "body": "    pub fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n        // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n        let lookup_table = LookupTable::<CachedPoint>::from(point);\n        // Setting s = scalar, compute\n        //\n        //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n        //\n        // with `-8  s_i < 8` for `0  i < 63` and `-8  s_63  8`.\n        let scalar_digits = scalar.as_radix_16();\n        // Compute s*P as\n        //\n        //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n        //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n        //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n        //\n        // We sum right-to-left.\n        let mut Q = ExtendedPoint::identity();\n        for i in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            Q = &Q + &lookup_table.select(scalar_digits[i]);\n        }\n        Q.into()\n    }",
    "display_name": "mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/variable_base.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/variable_base.rs",
    "file_name": "variable_base.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "power2/arithmetic/pow2",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow2",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar52/montgomery_invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_square",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/montgomery_mul"
    ],
    "body": "    pub fn montgomery_invert(&self) -> UnpackedScalar {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let    _1 = *self;\n        let   _10 = _1.montgomery_square();\n        let  _100 = _10.montgomery_square();\n        let   _11 = UnpackedScalar::montgomery_mul(&_10,     &_1);\n        let  _101 = UnpackedScalar::montgomery_mul(&_10,    &_11);\n        let  _111 = UnpackedScalar::montgomery_mul(&_10,   &_101);\n        let _1001 = UnpackedScalar::montgomery_mul(&_10,   &_111);\n        let _1011 = UnpackedScalar::montgomery_mul(&_10,  &_1001);\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n\n        #[inline]\n        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,       4, &_1001);\n        square_multiply(&mut y,       2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 3, &_101);\n        square_multiply(&mut y,   3 + 3, &_101);\n        square_multiply(&mut y,       3, &_111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   2 + 3, &_111);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,   2 + 4, &_1011);\n        square_multiply(&mut y,   6 + 4, &_1001);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1001);\n        square_multiply(&mut y,   1 + 3, &_111);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   1 + 2, &_11);\n\n        y\n    }",
    "display_name": "montgomery_invert",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "power/arithmetic/pow",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "pow",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/diff_sum",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/blend",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/shuffle",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/negate_lazy"
    ],
    "body": "    pub fn diff_sum(&self) -> FieldElement2625x4 {\n        // tmp1 = (B, A, D, C)\n        let tmp1 = self.shuffle(Shuffle::BADC);\n        // tmp2 = (-A, B, -C, D)\n        let tmp2 = self.blend(self.negate_lazy(), Lanes::AC);\n        // (B - A, B + A, D - C, D + C) bounded with b < 1.6\n        tmp1 + tmp2\n    }",
    "display_name": "diff_sum",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/bytestring_bits_le",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core slice/len"
    ],
    "body": "    fn bytestring_bits_le(x: &[u8]) -> impl DoubleEndedIterator<Item = bool> + Clone + '_ {\n        let bitlen = x.len() * 8;\n        (0..bitlen).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((x[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }",
    "display_name": "bytestring_bits_le",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "lit/LitStr/value",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "value",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/copy_from_slice",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "copy_from_slice",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 m_lo",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/new",
      "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_blend_epi32",
      "5.0.0_pre.0 m",
      "core https:/github.com/rust_lang/rust/library/core convert/Into/into",
      "5.0.0_pre.0 field/avx2/vector/backend/unpack_pair",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/shl",
      "5.0.0_pre.0 packed_simd/vector/backend/u64x4/shl",
      "5.0.0_pre.0 packed_simd/vector/backend/u64x4/splat",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/mul32",
      "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/reduce64",
      "5.0.0_pre.0 field/avx2/vector/backend/repack_pair"
    ],
    "body": "        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }",
    "display_name": "m_lo",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.0[..])\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/sub_reduces",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_reduces() {\n        // Check that subtraction wraps around the modulus\n        assert_eq!(Scalar::ZERO - Scalar::ONE, BASEPOINT_ORDER_MINUS_ONE);\n    }",
    "display_name": "sub_reduces",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 load8_at",
    "statement_type": "function",
    "deps": [],
    "body": "        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }",
    "display_name": "load8_at",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/constants/test_sqrt_ad_minus_one",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square"
    ],
    "body": "    fn test_sqrt_ad_minus_one() {\n        let a = FieldElement::MINUS_ONE;\n        let ad_minus_one = &(&a * &constants::EDWARDS_D) + &a;\n        let should_be_ad_minus_one = constants::SQRT_AD_MINUS_ONE.square();\n        assert_eq!(should_be_ad_minus_one, ad_minus_one);\n    }",
    "display_name": "test_sqrt_ad_minus_one",
    "full_path": "file:///work/3185/curve25519-dalek/src/constants.rs",
    "relative_path": "curve25519-dalek/src/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/multiscalar_consistency_n_500",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 test/edwards/multiscalar_consistency_iter"
    ],
    "body": "    fn multiscalar_consistency_n_500() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(500);\n        }\n    }",
    "display_name": "multiscalar_consistency_n_500",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/mul_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer"
    ],
    "body": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
    "display_name": "mul_clamped",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "CtOption/is_none",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "is_none",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "benchmark_group/BenchmarkGroup/bench_with_input",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "bench_with_input",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 deterministic/determine_curve25519_dalek_bits_warning",
    "statement_type": "function",
    "deps": [],
    "body": "    fn determine_curve25519_dalek_bits_warning(cause: &str) {\n        println!(\"cargo:warning=\\\"Defaulting to curve25519_dalek_bits=32: {cause}\\\"\");\n    }",
    "display_name": "determine_curve25519_dalek_bits_warning",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/product",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "product",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/edwards/basepoint_plus_basepoint_affine_niels_vs_basepoint2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_affine_niels",
      "5.0.0_pre.0 edwards/EdwardsPoint/compress"
    ],
    "body": "    fn basepoint_plus_basepoint_affine_niels_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_affine_niels = bp.as_affine_niels();\n        let bp_added = (&bp + &bp_affine_niels).as_extended();\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }",
    "display_name": "basepoint_plus_basepoint_affine_niels_vs_basepoint2",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/to_montgomery",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery"
    ],
    "body": "",
    "display_name": "to_montgomery",
    "full_path": "file:///work/3185/ed25519-dalek/tests/x25519.rs",
    "relative_path": "ed25519-dalek/tests/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/VerifyingKey/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/CompressedEdwardsY/to_bytes"
    ],
    "body": "    pub fn to_bytes(&self) -> [u8; PUBLIC_KEY_LENGTH] {\n        self.compressed.to_bytes()\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/montgomery_elligator_zero_zero",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/from_bytes",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/to_bytes",
      "5.0.0_pre.0 montgomery/elligator_encode"
    ],
    "body": "    fn montgomery_elligator_zero_zero() {\n        let zero = [0u8; 32];\n        let fe = FieldElement::from_bytes(&zero);\n        let (eg, _) = elligator_encode(&fe);\n        assert_eq!(eg.to_bytes(), zero);\n    }",
    "display_name": "montgomery_elligator_zero_zero",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 From/from",
    "statement_type": "function",
    "deps": [],
    "body": "    fn from(_: &'a Struct) -> Self {}\n}",
    "display_name": "from",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/vartime_double_scalar_mul_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/vartime_double_base_mul"
    ],
    "body": "",
    "display_name": "vartime_double_scalar_mul_basepoint",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/random",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core result/Result/map_err",
      "core https:/github.com/rust_lang/rust/library/core result/Result/expect",
      "5.0.0_pre.0 ristretto/RistrettoPoint/try_from_rng"
    ],
    "body": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self::try_from_rng(rng)\n            .map_err(|_: Infallible| {})\n            .expect(\"[bug] unfallible rng failed\")\n    }",
    "display_name": "random",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 subtle_assumes/u64/serial/backend/select",
    "statement_type": "function",
    "deps": [
      "ConditionallySelectable/conditional_select",
      "5.0.0_pre.0 subtle_assumes/u64/serial/backend/boolify"
    ],
    "body": "use crate::constants;\n\n#[allow(unused_imports)]\nuse super::scalar_lemmas::*;\n#[allow(unused_imports)]\nuse super::scalar_specs::*;\nuse super::subtle_assumes::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\nuse vstd::prelude::*;\n\nverus! {\n/// The `Scalar52` struct represents an element in\n/// \\\\(\\mathbb Z / \\ell \\mathbb Z\\\\) as 5 \\\\(52\\\\)-bit limbs.\n#[derive(Copy, Clone)]\npub struct Scalar52 {\n    pub limbs: [u64; 5],\n}\n\n} // verus!",
    "display_name": "select",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 straus/scalar_mul/serial/backend/Straus/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "5.0.0_pre.0 window/NafLookupTable5/From/from",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/Identity/identity",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/double",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_projective",
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/as_extended",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip"
    ],
    "body": "        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: core::borrow::Borrow<Scalar>,\n        K: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/reduce",
    "statement_type": "function",
    "deps": [],
    "body": "    fn reduce(mut limbs: [u64; 5]) -> FieldElement51 {\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        FieldElement51(limbs)\n    }",
    "display_name": "reduce",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards_benches/consttime_variable_base_scalar_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/invert",
      "benchmark_group/BenchmarkGroup/bench_function",
      "bencher/Bencher/iter",
      "5.0.0_pre.0 scalar/Scalar/From/from"
    ],
    "body": "    fn consttime_variable_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B = &constants::ED25519_BASEPOINT_POINT;\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time variable-base scalar mul\", move |b| {\n            b.iter(|| B * s)\n        });\n    }",
    "display_name": "consttime_variable_base_scalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/mul_base",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }",
    "display_name": "mul_base",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 errors/InternalError/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            InternalError::PointDecompression => write!(f, \"Cannot decompress Edwards point\"),\n            InternalError::ScalarFormat => write!(f, \"Cannot use scalar with high-bit set\"),\n            InternalError::BytesLength { name: n, length: l } => {\n                write!(f, \"{} must be {} bytes in length\", n, l)\n            }\n            InternalError::Verify => write!(f, \"Verification equation was not satisfied\"),\n            #[cfg(feature = \"batch\")]\n            InternalError::ArrayLength {\n                name_a: na,\n                length_a: la,\n                name_b: nb,\n                length_b: lb,\n                name_c: nc,\n                length_c: lc,\n            } => write!(\n                f,\n                \"Arrays must be the same length: {} has length {},\n                              {} has length {}, {} has length {}.\",\n                na, la, nb, lb, nc, lc\n            ),\n            #[cfg(feature = \"digest\")]\n            InternalError::PrehashedContextLength => write!(\n                f,\n                \"An ed25519ph signature can only take up to 255 octets of context\"\n            ),\n            InternalError::MismatchedKeypair => write!(f, \"Mismatched Keypair detected\"),\n        }\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/ed25519-dalek/src/errors.rs",
    "relative_path": "ed25519-dalek/src/errors.rs",
    "file_name": "errors.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "punctuated/Punctuated/len",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "len",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/ProjectiveNielsPoint/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/ConditionallySelectable/conditional_assign"
    ],
    "body": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u64x4/new_const",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core intrinsics/transmute"
    ],
    "body": "    pub const fn new_const(x0: u64, x1: u64, x2: u64, x3: u64) -> Self {\n        // SAFETY: Transmuting between an array and a SIMD type is safe\n        // https://rust-lang.github.io/unsafe-code-guidelines/layout/packed-simd-vectors.html\n        unsafe {\n            Self(core::mem::transmute::<[u64; 4], core::arch::x86_64::__m256i>([x0, x1, x2, x3]))\n        }\n    }",
    "display_name": "new_const",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/packed_simd.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "file_name": "packed_simd.rs",
    "parent_folder": "vector"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_add_then_shift",
    "statement_type": "function",
    "deps": [
      "div_mod/arithmetic/lemma_multiply_divide_lt",
      "power2/arithmetic/lemma2_to64_rest",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "power2/arithmetic/pow2",
      "power2/arithmetic/lemma_pow2_subtracts"
    ],
    "body": "pub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52)\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}",
    "display_name": "lemma_add_then_shift",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/mul_by_pow_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/double"
    ],
    "body": "",
    "display_name": "mul_by_pow_2",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "file_name": "straus.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/SubAssign/sub_assign",
    "statement_type": "function",
    "deps": [],
    "body": "    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }",
    "display_name": "sub_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/u64/serial/backend/add",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/add"
    ],
    "body": "    fn add() {\n        let res = Scalar52::add(&A, &B);\n        let zero = Scalar52::ZERO;\n        for i in 0..5 {\n            assert!(res[i] == zero[i]);\n        }\n    }",
    "display_name": "add",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/Zeroize/zeroize",
    "statement_type": "function",
    "deps": [
      "Zeroize/zeroize"
    ],
    "body": "",
    "display_name": "zeroize",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/verify_invert_correct",
    "statement_type": "function",
    "deps": [],
    "body": "proof fn verify_invert_correct(x: Scalar52)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}",
    "display_name": "verify_invert_correct",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core option/Option/ok_or",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "ok_or",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 x25519/StaticSecret/diffie_hellman",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_clamped"
    ],
    "body": "    pub fn diffie_hellman(&self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }",
    "display_name": "diffie_hellman",
    "full_path": "file:///work/3185/x25519-dalek/src/x25519.rs",
    "relative_path": "x25519-dalek/src/x25519.rs",
    "file_name": "x25519.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 check_validation_criteria",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/verify_strict",
      "3.0.0_pre.0 verifying/VerifyingKey/Verifier/verify",
      "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/is_subset",
      "alloc https:/github.com/rust_lang/rust/library/alloc set/btree/collections/BTreeSet/FromIterator/from_iter",
      "3.0.0_pre.0 get_test_vectors",
      "alloc https:/github.com/rust_lang/rust/library/alloc slice/to_vec",
      "core https:/github.com/rust_lang/rust/library/core result/Result/is_ok"
    ],
    "body": "fn check_validation_criteria() {\n    let verify_allowed_edgecases = Set::from_iter(VERIFY_ALLOWED_EDGECASES.to_vec());\n    let verify_strict_allowed_edgecases = Set::from_iter(VERIFY_STRICT_ALLOWED_EDGECASES.to_vec());\n\n    for TestVector {\n        number,\n        pubkey,\n        msg,\n        sig,\n        flags,\n    } in get_test_vectors()\n    {\n        // If all the verify-permitted flags here are ones we permit, then verify() should succeed.\n        // Otherwise, it should not.\n        let success = pubkey.verify(&msg, &sig).is_ok();\n        if flags.is_subset(&verify_allowed_edgecases) {\n            assert!(success, \"verify() expected success in testcase #{number}\",);\n        } else {\n            assert!(!success, \"verify() expected failure in testcase #{number}\",);\n        }\n\n        // If all the verify_strict-permitted flags here are ones we permit, then verify_strict()\n        // should succeed. Otherwise, it should not.\n        let success = pubkey.verify_strict(&msg, &sig).is_ok();\n        if flags.is_subset(&verify_strict_allowed_edgecases) {\n            assert!(\n                success,\n                \"verify_strict() expected success in testcase #{number}\",\n            );\n        } else {\n            assert!(\n                !success,\n                \"verify_strict() expected failure in testcase #{number}\",\n            );\n        }\n    }\n}",
    "display_name": "check_validation_criteria",
    "full_path": "file:///work/3185/ed25519-dalek/tests/validation_criteria.rs",
    "relative_path": "ed25519-dalek/tests/validation_criteria.rs",
    "file_name": "validation_criteria.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 backend/variable_base_mul",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/get_selected_backend",
      "5.0.0_pre.0 variable_base/scalar_mul/serial/backend/mul"
    ],
    "body": "pub fn variable_base_mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => vector::scalar_mul::variable_base::spec_avx2::mul(point, scalar),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::variable_base::spec_avx512ifma_avx512vl::mul(point, scalar)\n        }\n        BackendKind::Serial => serial::scalar_mul::variable_base::mul(point, scalar),\n    }\n}",
    "display_name": "variable_base_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "backend"
  },
  {
    "identifier": "3.0.0_pre.0 signing/SigningKey/From/from",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 signing/SigningKey/from_bytes"
    ],
    "body": "    fn from(secret: &SecretKey) -> Self {\n        Self::from_bytes(secret)\n    }",
    "display_name": "from",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/sub",
    "statement_type": "function",
    "deps": [
      "Choice/From/from",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/group_order",
      "5.0.0_pre.0 subtle_assumes/u64/serial/backend/select",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_scalar_subtract_no_overflow",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/limbs_bounded",
      "core https:/github.com/rust_lang/rust/library/core num/wrapping_sub",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_borrow_and_mask_bounded",
      "5.0.0_pre.0 scalar_specs/u64/serial/backend/to_nat",
      "5.0.0_pre.0 scalar_lemmas/u64/serial/backend/lemma_carry_bounded_after_mask"
    ],
    "body": "    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }",
    "display_name": "sub",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core avx2/x86/core_arch/_mm256_blend_epi32",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "_mm256_blend_epi32",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 test/montgomery/montgomery_ladder_matches_edwards_scalarmult",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 test/montgomery/rand_prime_order_point",
      "TryRngCore/unwrap_err",
      "5.0.0_pre.0 edwards/EdwardsPoint/to_montgomery",
      "5.0.0_pre.0 scalar/Scalar/random"
    ],
    "body": "    fn montgomery_ladder_matches_edwards_scalarmult() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            let p_edwards = rand_prime_order_point(&mut csprng);\n            let p_montgomery: MontgomeryPoint = p_edwards.to_montgomery();\n\n            let s: Scalar = Scalar::random(&mut csprng);\n            let expected = s * p_edwards;\n            let result = s * p_montgomery;\n\n            assert_eq!(result, expected.to_montgomery())\n        }\n    }",
    "display_name": "montgomery_ladder_matches_edwards_scalarmult",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/invert",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/invert"
    ],
    "body": "    fn invert() {\n        let inv_X = X.invert();\n        assert_eq!(inv_X, XINV);\n        let should_be_one = inv_X * X;\n        assert_eq!(should_be_one, Scalar::ONE);\n    }",
    "display_name": "invert",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 window/NafLookupTable8/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        writeln!(f, \"NafLookupTable8([\")?;\n        for i in 0..64 {\n            writeln!(f, \"\\t{:?},\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/window.rs",
    "relative_path": "curve25519-dalek/src/window.rs",
    "file_name": "window.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/to_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field_verus/u64/serial/backend/spec_reduce",
      "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_reduce",
      "power2/arithmetic/lemma2_to64",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "5.0.0_pre.0 field_verus/u64/serial/backend/l51_bit_mask_lt",
      "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/reduce",
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_add_then_shift",
      "power2/arithmetic/lemma_pow2_adds",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shifted_lt"
    ],
    "body": "    pub fn to_bytes(self) -> (r: [u8; 32])\n        ensures\n            true // No overflow\n            // TODO:\n            // as_nat(self.limbs) =?= as_nat_32_u8(r),\n            // canonical encoding\n            // forall|i: int| 0 <= i < 5 ==> r[i] < (1u64 << 51)\n    {\n        proof {\n            let l = spec_reduce(self.limbs);\n            lemma_reduce(self.limbs);\n\n            let q0 = (l[0] + 19) as u64 >> 51;\n            let q1 = (l[1] + q0) as u64 >> 51;\n            let q2 = (l[2] + q1) as u64 >> 51;\n            let q3 = (l[3] + q2) as u64 >> 51;\n            let q4 = (l[4] + q3) as u64 >> 51;\n\n            assert(19 < (1u64 << 52)) by (bit_vector);\n            lemma_add_then_shift(l[0], 19);\n            lemma_add_then_shift(l[1], q0);\n            lemma_add_then_shift(l[2], q1);\n            lemma_add_then_shift(l[3], q2);\n            lemma_add_then_shift(l[4], q3);\n\n            let l0 = (l[0] + 19 * q4) as u64;\n            let l1 = (l[1] + (l0 >> 51)) as u64;\n            let l2 = (l[2] + (l1 >> 51)) as u64;\n            let l3 = (l[3] + (l2 >> 51)) as u64;\n            let l4 = (l[3] + (l3 >> 51)) as u64;\n\n            assert( 19 * q4 < 1u64 << 7) by {\n                // Explicit values for pow2(k) for k < 64\n                lemma2_to64();\n                shift_is_pow2(5); // now we know 19 < 1u64 << 5 for free\n                shift_is_pow2(2);\n                shift_is_pow2(7);\n                lemma_pow2_adds(5, 2);\n            }\n            assert(((1u64 << 7)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            assert(((1u64 << 13)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            shifted_lt(l0, 51);\n            shifted_lt(l1, 51);\n            shifted_lt(l2, 51);\n            shifted_lt(l3, 51);\n\n            l51_bit_mask_lt();\n\n            // TODO\n            // let rr = [\n            //     l0 & LOW_51_BIT_MASK,\n            //     l1 & LOW_51_BIT_MASK,\n            //     l2 & LOW_51_BIT_MASK,\n            //     l3 & LOW_51_BIT_MASK,\n            //     l4 & LOW_51_BIT_MASK\n            // ];\n\n            // let r = [\n            //     rr[0]                           as u8,\n            //     (rr[0] >>  8)                    as u8,\n            //     (rr[0] >> 16)                    as u8,\n            //     (rr[0] >> 24)                    as u8,\n            //     (rr[0] >> 32)                    as u8,\n            //     (rr[0] >> 40)                    as u8,\n            //     ((rr[0] >> 48) | (rr[1] << 3)) as u8,\n            //     (rr[1] >>  5)                    as u8,\n            //     (rr[1] >> 13)                    as u8,\n            //     (rr[1] >> 21)                    as u8,\n            //     (rr[1] >> 29)                    as u8,\n            //     (rr[1] >> 37)                    as u8,\n            //     ((rr[1] >> 45) | (rr[2] << 6)) as u8,\n            //     (rr[2] >>  2)                    as u8,\n            //     (rr[2] >> 10)                    as u8,\n            //     (rr[2] >> 18)                    as u8,\n            //     (rr[2] >> 26)                    as u8,\n            //     (rr[2] >> 34)                    as u8,\n            //     (rr[2] >> 42)                    as u8,\n            //     ((rr[2] >> 50) | (rr[3] << 1)) as u8,\n            //     (rr[3] >>  7)                    as u8,\n            //     (rr[3] >> 15)                    as u8,\n            //     (rr[3] >> 23)                    as u8,\n            //     (rr[3] >> 31)                    as u8,\n            //     (rr[3] >> 39)                    as u8,\n            //     ((rr[3] >> 47) | (rr[4] << 4)) as u8,\n            //     (rr[4] >>  4)                    as u8,\n            //     (rr[4] >> 12)                    as u8,\n            //     (rr[4] >> 20)                    as u8,\n            //     (rr[4] >> 28)                    as u8,\n            //     (rr[4] >> 36)                    as u8,\n            //     (rr[4] >> 44)                    as u8\n            // ];\n\n        }\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.limbs).limbs;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n        // debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
    "display_name": "to_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 test_sse2_only",
    "statement_type": "function",
    "deps": [],
    "body": "fn test_sse2_only() {}\n",
    "display_name": "test_sse2_only",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/square2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/pow2k"
    ],
    "body": "        let minus_one = FieldElement::MINUS_ONE;\n        let mut x = one;\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(0));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, one);\n    }\n\n    #[test]\n    fn encoding_is_canonical() {\n        // Encode 1 wrongly as 1 + (2^255 - 19) = 2^255 - 18\n        let one_encoded_wrongly_bytes: [u8; 32] = [\n            0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0x7f,\n        ];\n        // Decode to a field element\n        let one = FieldElement::from_bytes(&one_encoded_wrongly_bytes);\n        // .. then check that the encoding is correct\n        let one_bytes = one.to_bytes();\n        assert_eq!(one_bytes[0], 1);\n        for byte in &one_bytes[1..] {\n            assert_eq!(*byte, 0);\n        }\n    }",
    "display_name": "square2",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "3.0.0_pre.0 hazmat/raw_verify",
    "statement_type": "function",
    "deps": [
      "3.0.0_pre.0 verifying/VerifyingKey/raw_verify"
    ],
    "body": "pub fn raw_verify<CtxDigest>(\n    vk: &VerifyingKey,\n    message: &[u8],\n    signature: &ed25519::Signature,\n) -> Result<(), SignatureError>\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    vk.raw_verify::<CtxDigest>(&[message], signature)\n}",
    "display_name": "raw_verify",
    "full_path": "file:///work/3185/ed25519-dalek/src/hazmat.rs",
    "relative_path": "ed25519-dalek/src/hazmat.rs",
    "file_name": "hazmat.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/batch_invert_with_a_zero_input_panics",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar/batch_invert"
    ],
    "body": "    fn batch_invert_with_a_zero_input_panics() {\n        let mut xs = vec![Scalar::ONE; 16];\n        xs[3] = Scalar::ZERO;\n        // This should panic in debug mode.\n        Scalar::batch_invert(&mut xs);\n    }",
    "display_name": "batch_invert_with_a_zero_input_panics",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "mul/arithmetic/lemma_mul_is_associative",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_is_associative",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "file_name": "scalar_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_shr_51_fits_u64",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field_lemmas/u64/serial/backend/lemma_shr_51_le"
    ],
    "body": "pub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51\n    ensures\n        (a >> 51) <= (u64::MAX as u128)\n\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}",
    "display_name": "lemma_shr_51_fits_u64",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "0.1.1 Struct/member_function",
    "statement_type": "function",
    "deps": [],
    "body": "    fn member_function(&self, mut b: u32) -> u32 {\n        self.a - b\n    }",
    "display_name": "member_function",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/EdwardsPoint/mul_by_pow_2",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 curve_models/serial/backend/ProjectivePoint/double",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_projective",
      "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/as_extended",
      "5.0.0_pre.0 edwards/EdwardsPoint/as_projective"
    ],
    "body": "#[cfg(feature = \"zeroize\")]\nimpl Zeroize for CompressedRistretto {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}",
    "display_name": "mul_by_pow_2",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 spec/pippenger/scalar_mul/vector/backend/Pippenger/VartimeMultiscalarMul/optional_multiscalar_mul",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/size_hint",
      "5.0.0_pre.0 scalar/Scalar/to_radix_2w_size_hint",
      "core https:/github.com/rust_lang/rust/library/core convert/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/by_ref",
      "5.0.0_pre.0 edwards/avx2/vector/backend/ExtendedPoint/Identity/identity",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/cmp",
      "core https:/github.com/rust_lang/rust/library/core map/adapters/iter/Map/Iterator/fold",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/zip",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/rev",
      "5.0.0_pre.0 edwards/avx2/vector/backend/CachedPoint/From/from",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "core https:/github.com/rust_lang/rust/library/core map/adapters/iter/Map/Iterator/next",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "core https:/github.com/rust_lang/rust/library/core option/Option/expect"
    ],
    "body": "        fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let mut scalars = scalars.into_iter();\n            let size = scalars.by_ref().size_hint().0;\n            let w = if size < 500 {\n                6\n            } else if size < 800 {\n                7\n            } else {\n                8\n            };\n\n            let max_digit: usize = 1 << w;\n            let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n            let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n            // Collect optimized scalars and points in a buffer for repeated access\n            // (scanning the whole collection per each digit position).\n            let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n            let points = points\n                .into_iter()\n                .map(|p| p.map(|P| CachedPoint::from(ExtendedPoint::from(P))));\n\n            let scalars_points = scalars\n                .zip(points)\n                .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n                .collect::<Option<Vec<_>>>()?;\n\n            // Prepare 2^w/2 buckets.\n            // buckets[i] corresponds to a multiplication factor (i+1).\n            let mut buckets: Vec<ExtendedPoint> = (0..buckets_count)\n                .map(|_| ExtendedPoint::identity())\n                .collect();\n\n            let mut columns = (0..digits_count).rev().map(|digit_index| {\n                // Clear the buckets when processing another digit.\n                for bucket in &mut buckets {\n                    *bucket = ExtendedPoint::identity();\n                }\n\n                // Iterate over pairs of (point, scalar)\n                // and add/sub the point to the corresponding bucket.\n                // Note: if we add support for precomputed lookup tables,\n                // we'll be adding/subtractiong point premultiplied by `digits[i]` to buckets[0].\n                for (digits, pt) in scalars_points.iter() {\n                    // Widen digit so that we don't run into edge cases when w=8.\n                    let digit = digits[digit_index] as i16;\n                    match digit.cmp(&0) {\n                        Ordering::Greater => {\n                            let b = (digit - 1) as usize;\n                            buckets[b] = &buckets[b] + pt;\n                        }\n                        Ordering::Less => {\n                            let b = (-digit - 1) as usize;\n                            buckets[b] = &buckets[b] - pt;\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n\n                // Add the buckets applying the multiplication factor to each bucket.\n                // The most efficient way to do that is to have a single sum with two running sums:\n                // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n                //\n                // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n                //   C\n                //   C B\n                //   C B A   Sum = C + (C+B) + (C+B+A)\n                let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n                let mut buckets_sum = buckets[buckets_count - 1];\n                for i in (0..(buckets_count - 1)).rev() {\n                    buckets_intermediate_sum =\n                        &buckets_intermediate_sum + &CachedPoint::from(buckets[i]);\n                    buckets_sum = &buckets_sum + &CachedPoint::from(buckets_intermediate_sum);\n                }\n\n                buckets_sum\n            });\n\n            // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n            let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n            Some(\n                columns\n                    .fold(hi_column, |total, p| {\n                        &total.mul_by_pow_2(w as u32) + &CachedPoint::from(p)\n                    })\n                    .into(),\n            )\n        }",
    "display_name": "optional_multiscalar_mul",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "file_name": "pippenger.rs",
    "parent_folder": "scalar_mul"
  },
  {
    "identifier": "5.0.0_pre.0 field/avx2/vector/backend/FieldElement2625x4/ConditionallySelectable/conditional_assign",
    "statement_type": "function",
    "deps": [
      "Choice/unwrap_u8",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/splat_const",
      "5.0.0_pre.0 packed_simd/vector/backend/u32x8/splat"
    ],
    "body": "    fn conditional_assign(&mut self, other: &FieldElement2625x4, choice: Choice) {\n        let mask = (-(choice.unwrap_u8() as i32)) as u32;\n        let mask_vec = u32x8::splat(mask);\n        self.0[0] ^= mask_vec & (self.0[0] ^ other.0[0]);\n        self.0[1] ^= mask_vec & (self.0[1] ^ other.0[1]);\n        self.0[2] ^= mask_vec & (self.0[2] ^ other.0[2]);\n        self.0[3] ^= mask_vec & (self.0[3] ^ other.0[3]);\n        self.0[4] ^= mask_vec & (self.0[4] ^ other.0[4]);\n    }",
    "display_name": "conditional_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/field.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "file_name": "field.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "3.0.0_pre.0 verifying/RCompute/update",
    "statement_type": "function",
    "deps": [
      "digest/Digest/update"
    ],
    "body": "    pub(crate) fn update(&mut self, m: &[u8]) {\n        self.h.update(m)\n    }",
    "display_name": "update",
    "full_path": "file:///work/3185/ed25519-dalek/src/verifying.rs",
    "relative_path": "ed25519-dalek/src/verifying.rs",
    "file_name": "verifying.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_base_clamped",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/clamp_integer",
      "5.0.0_pre.0 montgomery/MontgomeryPoint/mul_base"
    ],
    "body": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
    "display_name": "mul_base_clamped",
    "full_path": "file:///work/3185/curve25519-dalek/src/montgomery.rs",
    "relative_path": "curve25519-dalek/src/montgomery.rs",
    "file_name": "montgomery.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/from_bytes_mod_order_wide",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/Scalar52/pack",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_bytes_wide"
    ],
    "body": "    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }",
    "display_name": "from_bytes_mod_order_wide",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "0.1.1 unsafe_target_feature_specialize",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "unsafe_target_feature_specialize",
    "full_path": "file:///work/3185/curve25519-dalek-derive/tests/tests.rs",
    "relative_path": "curve25519-dalek-derive/tests/tests.rs",
    "file_name": "tests.rs",
    "parent_folder": "tests"
  },
  {
    "identifier": "5.0.0_pre.0 multiscalar_benches/construct_points",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/mul_base",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "thread/rngs/rng",
      "5.0.0_pre.0 scalar/Scalar/random",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map"
    ],
    "body": "    fn construct_points(n: usize) -> Vec<EdwardsPoint> {\n        let mut rng = rng();\n        (0..n)\n            .map(|_| EdwardsPoint::mul_base(&Scalar::random(&mut rng)))\n            .collect()\n    }",
    "display_name": "construct_points",
    "full_path": "file:///work/3185/curve25519-dalek/benches/dalek_benchmarks.rs",
    "relative_path": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "file_name": "dalek_benchmarks.rs",
    "parent_folder": "benches"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/vartime_double_scalar_mul_basepoint",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 edwards/EdwardsPoint/vartime_double_scalar_mul_basepoint"
    ],
    "body": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &RistrettoPoint,\n        b: &Scalar,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::vartime_double_scalar_mul_basepoint(\n            a, &A.0, b,\n        ))\n    }",
    "display_name": "vartime_double_scalar_mul_basepoint",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 test/scalar/to_bytes_from_bytes_roundtrips",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/to_bytes",
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/from_bytes",
      "5.0.0_pre.0 scalar/Scalar/unpack"
    ],
    "body": "    fn to_bytes_from_bytes_roundtrips() {\n        let unpacked = X.unpack();\n        let bytes = unpacked.to_bytes();\n        let should_be_unpacked = UnpackedScalar::from_bytes(&bytes);\n\n        assert_eq!(should_be_unpacked.limbs, unpacked.limbs);\n    }",
    "display_name": "to_bytes_from_bytes_roundtrips",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 top_half",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 bot_half"
    ],
    "body": "        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }",
    "display_name": "top_half",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_div_is_ordered",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_div_is_ordered",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "file_name": "field_lemmas.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 common_verus/u64/serial/backend/shifted_lt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 common_verus/u64/serial/backend/shl_zero_is_id",
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_shr_le_u64",
      "5.0.0_pre.0 common_verus/u64/serial/backend/lemma_u64_max_shifting"
    ],
    "body": "pub proof fn shifted_lt(v: u64, k: nat)\n    requires\n        1 <= k <= 64\n    ensures\n        v >> k < 1u64 << (64 - k)\n{\n    if (k == 64) {\n        assert( v >> 64 == 0) by (bit_vector);\n        shl_zero_is_id(1u64);\n    }\n    else {\n        // (v >> k) <= (u64::MAX >> k)\n        lemma_shr_le_u64(v, u64::MAX, k);\n        // u64::MAX >> k < 1u64 << (64 - k)\n        lemma_u64_max_shifting(k);\n    }\n}",
    "display_name": "shifted_lt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core slice/split_at",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "split_at",
    "full_path": "file:///work/3185/ed25519-dalek/src/signing.rs",
    "relative_path": "ed25519-dalek/src/signing.rs",
    "file_name": "signing.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/FieldElement51/from_bytes",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field_verus/u64/serial/backend/load8_at",
      "5.0.0_pre.0 field_verus/u64/serial/backend/l51_bit_mask_lt"
    ],
    "body": "    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)\n        ensures\n            true\n            // TODO:\n            // as_nat(r.limbs) =?= as_nat_32_u8(bytes)\n    {\n        proof {\n            l51_bit_mask_lt() // No over/underflow in the below let-def\n        }\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{ limbs:\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ]}\n    }",
    "display_name": "from_bytes",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 test/ristretto/partial_precomputed_mixed_multiscalar",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/RistrettoPoint/random",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/collect",
      "5.0.0_pre.0 traits/VartimePrecomputedMultiscalarMul/vartime_mixed_multiscalar_mul",
      "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/new",
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/map",
      "core https:/github.com/rust_lang/rust/library/core slice/iter",
      "5.0.0_pre.0 scalar/Scalar/random",
      "thread/rngs/rng",
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity",
      "alloc https:/github.com/rust_lang/rust/library/alloc vec/Vec/len"
    ],
    "body": "    fn partial_precomputed_mixed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n        let n_dynamic = 8;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use one fewer scalars\n        let static_scalars = (0..n_static - 1)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_points = (0..n_dynamic)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..n_dynamic)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n        for i in 0..n_dynamic {\n            result_manual += dynamic_points[i] * dynamic_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }",
    "display_name": "partial_precomputed_mixed_multiscalar",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/lemma_boundaries",
    "statement_type": "function",
    "deps": [
      "power2/arithmetic/lemma_pow2_adds",
      "5.0.0_pre.0 field_verus/u64/serial/backend/masked_lt_51",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shift_is_pow2",
      "5.0.0_pre.0 common_verus/u64/serial/backend/shifted_lt",
      "5.0.0_pre.0 common_verus/u64/serial/backend/mul_lt"
    ],
    "body": "pub proof fn lemma_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & LOW_51_BIT_MASK) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & LOW_51_BIT_MASK) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & LOW_51_BIT_MASK) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & LOW_51_BIT_MASK) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & LOW_51_BIT_MASK) + (limbs[3] >> 51)) < (1u64 << 52)\n\n{\n    // \\A i. limbs[i] < 2^13\n    shifted_lt(limbs[0], 51);\n    shifted_lt(limbs[1], 51);\n    shifted_lt(limbs[2], 51);\n    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & LOW_51_BIT_MASK < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}",
    "display_name": "lemma_boundaries",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/to_radix_2w_size_hint",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core num/div_ceil"
    ],
    "body": "    pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        let digits_count = match w {\n            4..=7 => 256_usize.div_ceil(w),\n            // See comment in to_radix_2w on handling the terminal carry.\n            8 => 256_usize.div_ceil(w) + 1_usize,\n            _ => panic!(\"invalid radix parameter\"),\n        };\n\n        debug_assert!(digits_count <= 64);\n        digits_count\n    }",
    "display_name": "to_radix_2w_size_hint",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "mul/arithmetic/lemma_mul_strict_inequality",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_mul_strict_inequality",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/MulAssign/mul_assign",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 scalar/u64/serial/backend/Scalar52/mul",
      "5.0.0_pre.0 scalar/Scalar/unpack",
      "5.0.0_pre.0 scalar/Scalar52/pack"
    ],
    "body": "    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }",
    "display_name": "mul_assign",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "div_mod/arithmetic/lemma_div_multiples_vanish",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "lemma_div_multiples_vanish",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "file_name": "common_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 field_verus/u64/serial/backend/load8_at",
    "statement_type": "function",
    "deps": [],
    "body": "const fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        0 <= r <= (u64::MAX as nat),\n{\n        (input[i] as u64)\n    | ((input[i + 1] as u64) << 8)\n    | ((input[i + 2] as u64) << 16)\n    | ((input[i + 3] as u64) << 24)\n    | ((input[i + 4] as u64) << 32)\n    | ((input[i + 5] as u64) << 40)\n    | ((input[i + 6] as u64) << 48)\n    | ((input[i + 7] as u64) << 56)\n}",
    "display_name": "load8_at",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "file_name": "field_verus.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 packed_simd/vector/backend/u32x8/new_const",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core intrinsics/transmute"
    ],
    "body": "        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            55082775, 45300503, 16032654, 5964396, 17743504, 24634761, 19493066, 5184611,\n        ),\n        u32x8::new_const(\n            50172633, 35093294, 10040575, 23616256, 4543900, 61852191, 4049821, 7423669,\n        ),\n        u32x8::new_const(\n            20295398, 40009376, 10487190, 15670429, 51972856, 58649552, 20436392, 3432497,\n        ),\n        u32x8::new_const(\n            35189420, 54117751, 12825868, 6283038, 27540739, 30648758, 22658912, 9466689,\n        ),\n        u32x8::new_const(\n            51737549, 40725785, 17409814, 25201086, 21156239, 34176168, 26814520, 5956424,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            8211442, 8014184, 6260823, 22108096, 32182620, 51844847, 2466270, 28582231,\n        ),\n        u32x8::new_const(\n            27199739, 3848333, 31738017, 10892045, 4963982, 65391770, 32551997, 28906469,\n        ),\n        u32x8::new_const(\n            16606846, 32207068, 26404535, 7614129, 45416902, 65584718, 13821785, 2646060,\n        ),\n        u32x8::new_const(\n            36090634, 57981287, 32247670, 22837502, 31003861, 55448117, 6062915, 20369975,\n        ),\n        u32x8::new_const(\n            27381403, 50578107, 522631, 29521058, 31137497, 40220737, 27628049, 1824195,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            59402443, 17056879, 29262689, 6131785, 52551472, 43367471, 29423199, 18899208,\n        ),\n        u32x8::new_const(\n            5749414, 43514612, 11365899, 21514624, 65591890, 60945892, 19841732, 5628567,\n        ),\n        u32x8::new_const(\n            19334369, 52500268, 12307673, 5267367, 3212103, 9035822, 29142161, 30520954,\n        ),\n        u32x8::new_const(\n            57261330, 6819646, 22089161, 9800373, 55155453, 62250856, 13766735, 25244545,\n        ),\n        u32x8::new_const(\n            54370226, 61888301, 24496089, 2540581, 65637506, 60274355, 18154273, 11687259,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            12521903, 26014045, 13995625, 33360175, 23605474, 7376434, 27229267, 17195036,\n        ),\n        u32x8::new_const(\n            59482891, 10074423, 574357, 3857753, 61377787, 50306685, 5241065, 20234396,\n        ),\n        u32x8::new_const(\n            23674717, 6997172, 20771841, 16858511, 40565304, 29973136, 7049812, 14585010,\n        ),\n        u32x8::new_const(\n            1427477, 13295732, 31762066, 31499740, 60419925, 54666164, 22009424, 8089609,\n        ),\n        u32x8::new_const(\n            58154031, 41593020, 15342328, 957047, 38937260, 37037498, 24871992, 32973409,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            30654745, 51286025, 21206982, 2433562, 12780105, 31732574, 33087964, 33081189,\n        ),\n        u32x8::new_const(\n            66640017, 42720009, 16567620, 15300745, 1530367, 33001123, 20930247, 21042661,\n        ),\n        u32x8::new_const(\n            15003356, 5294119, 22985605, 18928772, 32628461, 18230172, 14773298, 27193722,\n        ),\n        u32x8::new_const(\n            27555, 65346287, 17017174, 7837720, 21499787, 42855613, 22474984, 13675085,\n        ),\n        u32x8::new_const(\n            24164369, 50130116, 5973149, 24152073, 1577334, 25400030, 18648484, 32228854,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            49518649, 59119280, 31670678, 20396561, 61728330, 651402, 176032, 9529498,\n        ),\n        u32x8::new_const(\n            61765532, 9082232, 32794568, 15526956, 48543100, 32614212, 19001206, 25680229,\n        ),\n        u32x8::new_const(\n            32086091, 10373081, 8996131, 31822823, 35788988, 49973190, 30542040, 17858455,\n        ),\n        u32x8::new_const(\n            48130197, 58121889, 27753291, 29923268, 54448075, 43300790, 9336565, 15770022,\n        ),\n        u32x8::new_const(\n            57725546, 20557498, 9366233, 16023566, 16189031, 2837363, 24315301, 27003505,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            28286608, 10767548, 18220739, 5413236, 48253387, 58255702, 11864864, 28527159,\n        ),\n        u32x8::new_const(\n            45038176, 58655197, 25648758, 10951484, 42564382, 34542843, 23146954, 22234334,\n        ),\n        u32x8::new_const(\n            14858710, 24978793, 15040559, 4379220, 47621477, 40271440, 15650420, 1998736,\n        ),\n        u32x8::new_const(\n            24106391, 9626149, 344505, 25253814, 34579800, 59687089, 25718289, 25904133,\n        ),\n        u32x8::new_const(\n            1981195, 37751302, 26132048, 1764722, 13288231, 28808622, 12531301, 18292949,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            13869851, 31448904, 14963539, 7581293, 20536485, 35021083, 21257574, 33356609,\n        ),\n        u32x8::new_const(\n            36903364, 18429241, 11097857, 5943856, 60583077, 40015815, 30509523, 31915271,\n        ),\n        u32x8::new_const(\n            49161801, 40681915, 67892, 25454357, 22779677, 25798439, 15964829, 5863227,\n        ),\n        u32x8::new_const(\n            60810637, 4496471, 5217137, 14095116, 50942411, 50712663, 2507380, 26844507,\n        ),\n        u32x8::new_const(\n            34579752, 53519385, 10859797, 18816024, 42552864, 39478521, 6783896, 17277037,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            43287109, 27900723, 33182187, 2766754, 17041989, 1018260, 33392790, 4830032,\n        ),\n        u32x8::new_const(\n            60194178, 30788903, 24728888, 14513195, 20897010, 28843233, 20111980, 17475240,\n        ),\n        u32x8::new_const(\n            46042274, 19257042, 4628173, 31649727, 27388316, 66631493, 11541886, 6408028,\n        ),\n        u32x8::new_const(\n            57024680, 49536568, 32050358, 31321917, 17437691, 49672356, 2884755, 20493991,\n        ),\n        u32x8::new_const(\n            59553007, 46782643, 29001173, 1814088, 21930692, 51319706, 14965872, 30748046,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            16441817, 36111849, 6900424, 602234, 46522199, 16441484, 8135070, 21726541,\n        ),\n        u32x8::new_const(\n            37711225, 32701959, 11679112, 13125533, 32154135, 9407918, 26554289, 620848,\n        ),\n        u32x8::new_const(\n            19233407, 30086864, 14679568, 2797374, 4892806, 7993077, 247658, 5632804,\n        ),\n        u32x8::new_const(\n            37427262, 26675495, 27125659, 13496131, 50718473, 40115609, 28505351, 27837393,\n        ),\n        u32x8::new_const(\n            196819, 18410429, 7070012, 21691388, 29763371, 24754123, 9727048, 10930179,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            28319289, 40734650, 16225680, 24739184, 64272368, 35356897, 7866648, 13635853,\n        ),\n        u32x8::new_const(\n            34165295, 48328447, 27041670, 23643655, 48949950, 52963288, 30411133, 6045174,\n        ),\n        u32x8::new_const(\n            18583559, 41649834, 9813585, 26098520, 25682734, 26733526, 19276490, 10654728,\n        ),\n        u32x8::new_const(\n            34867476, 52715968, 5694571, 13380978, 15134994, 1831255, 8608001, 17266401,\n        ),\n        u32x8::new_const(\n            59925903, 44282172, 27802465, 1855069, 14234749, 36635487, 11302294, 10938429,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            8373273, 49064494, 4932071, 32997499, 38472880, 29335908, 14504412, 22460029,\n        ),\n        u32x8::new_const(\n            31795930, 50785923, 25835990, 25790073, 65669841, 11360450, 9969157, 9008164,\n        ),\n        u32x8::new_const(\n            50262498, 45869261, 16124434, 15336007, 882762, 42522623, 11277198, 26296377,\n        ),\n        u32x8::new_const(\n            42332732, 59129236, 14452816, 567985, 208061, 34722729, 32008143, 14828749,\n        ),\n        u32x8::new_const(\n            17937794, 36846032, 32102665, 4442466, 19745435, 31633451, 7146411, 15812027,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            30741269, 38648744, 12562645, 30092623, 25073992, 28730659, 27911745, 30000958,\n        ),\n        u32x8::new_const(\n            2859794, 25991700, 17776078, 27091930, 2328322, 60061146, 18581824, 18039008,\n        ),\n        u32x8::new_const(\n            58206333, 17917354, 1972306, 11853766, 2655376, 60543390, 18416710, 13287440,\n        ),\n        u32x8::new_const(\n            62746330, 61423885, 21246577, 2266675, 60099139, 14804707, 14772234, 20679434,\n        ),\n        u32x8::new_const(\n            26987698, 15488817, 715616, 2339565, 51980752, 17333865, 21965103, 10839820,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            18672548, 57660959, 16042910, 19519287, 62865851, 17580961, 26628347, 23774759,\n        ),\n        u32x8::new_const(\n            368070, 3464471, 25888304, 30370559, 52396053, 45426828, 28745251, 9246829,\n        ),\n        u32x8::new_const(\n            29090099, 57950037, 23104657, 4903923, 10987778, 56163684, 23621539, 10332760,\n        ),\n        u32x8::new_const(\n            53338235, 44851161, 21606845, 31069622, 4243630, 34464392, 11286454, 5802022,\n        ),\n        u32x8::new_const(\n            46710757, 63389067, 11642865, 1980986, 12967337, 28162061, 3854192, 30432268,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            12179834, 41005450, 12809619, 33525228, 4624405, 46957889, 16968743, 11827816,\n        ),\n        u32x8::new_const(\n            51521162, 12466775, 31791271, 15303651, 49798465, 62714504, 6509600, 12918560,\n        ),\n        u32x8::new_const(\n            20445559, 1756449, 28848701, 7920171, 9835040, 5900071, 28757409, 12376688,\n        ),\n        u32x8::new_const(\n            18259496, 14281012, 21767026, 10232236, 20000226, 12400540, 4104902, 23570543,\n        ),\n        u32x8::new_const(\n            3687440, 26546648, 13328821, 26841081, 49822734, 22334054, 244496, 24862543,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            59523541, 62195428, 3853227, 13954801, 12387708, 47627615, 27221350, 17899572,\n        ),\n        u32x8::new_const(\n            63193587, 36343307, 14595132, 6880795, 1364792, 37648434, 3259017, 20536046,\n        ),\n        u32x8::new_const(\n            30362834, 10440372, 9574624, 11729232, 63861613, 21748389, 5530846, 2721586,\n        ),\n        u32x8::new_const(\n            18339760, 1550632, 17170271, 25732971, 28459263, 63142237, 21642345, 31557672,\n        ),\n        u32x8::new_const(\n            10611282, 5204623, 18049257, 214175, 19432723, 49809070, 26010406, 27449522,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            19770733, 26478685, 9464541, 29158041, 28604307, 45196604, 7586524, 6641859,\n        ),\n        u32x8::new_const(\n            65654484, 52230498, 30886612, 19112823, 47271809, 38942611, 16020035, 10773481,\n        ),\n        u32x8::new_const(\n            27464323, 54451016, 20646645, 17732915, 23008717, 53626684, 3253189, 15614410,\n        ),\n        u32x8::new_const(\n            52381752, 40693008, 7063024, 28469981, 51159478, 44543211, 19941777, 5985451,\n        ),\n        u32x8::new_const(\n            13553668, 35524849, 14788737, 1883845, 12385775, 47958835, 29135466, 1776722,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            36719806, 20827965, 23175373, 32996806, 42041892, 65708790, 5467143, 20884008,\n        ),\n        u32x8::new_const(\n            43256281, 40770646, 17244063, 31959819, 64366384, 43544617, 25057754, 12628720,\n        ),\n        u32x8::new_const(\n            17337782, 58472057, 27906934, 15305274, 30292418, 39284317, 16946773, 24806712,\n        ),\n        u32x8::new_const(\n            6485126, 32447403, 16261486, 13561940, 49439635, 10738368, 16419889, 8897231,\n        ),\n        u32x8::new_const(\n            44812203, 40122262, 25496058, 2759794, 25295304, 52178368, 24154195, 29334408,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            42307254, 57217102, 1088936, 3832827, 33905401, 23130334, 6958056, 12622851,\n        ),\n        u32x8::new_const(\n            3881189, 14870059, 19712830, 6071598, 38147944, 60776394, 3427938, 13765703,\n        ),\n        u32x8::new_const(\n            7666911, 24227591, 17077136, 22967588, 6874639, 30915523, 11451695, 24292224,\n        ),\n        u32x8::new_const(\n            13659529, 31984463, 28764736, 20506164, 64729627, 49321636, 28284636, 25472371,\n        ),\n        u32x8::new_const(\n            39360308, 42281399, 9446504, 868960, 49227724, 21351115, 30561851, 11292096,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            7071115, 46444090, 5387916, 15432877, 27226682, 41506862, 2398278, 3978240,\n        ),\n        u32x8::new_const(\n            51009614, 54216973, 24368938, 31392616, 38456150, 62313644, 6729154, 99724,\n        ),\n        u32x8::new_const(\n            17474332, 62857913, 2619930, 30659308, 18268181, 32809239, 22826292, 24561895,\n        ),\n        u32x8::new_const(\n            38187020, 67003092, 14118280, 16500577, 18808560, 64983716, 25712929, 32518261,\n        ),\n        u32x8::new_const(\n            25735813, 62284262, 10824872, 20558596, 48149681, 31162667, 22608274, 26285185,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            963440, 63742255, 10230323, 25515008, 32506414, 6105697, 25980317, 24645129,\n        ),\n        u32x8::new_const(\n            7162189, 8101249, 14679265, 33443386, 2002396, 8541405, 19442276, 4795881,\n        ),\n        u32x8::new_const(\n            8116694, 51463069, 4415528, 25599140, 55805721, 39582709, 6719436, 30033839,\n        ),\n        u32x8::new_const(\n            14468202, 42181869, 25188826, 9639755, 47546189, 62711146, 32762447, 18338064,\n        ),\n        u32x8::new_const(\n            33880058, 32810909, 8969931, 13095238, 38360605, 40138517, 9246134, 4928058,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            63655588, 17883670, 9410246, 26162761, 5000571, 7349225, 23785252, 32751089,\n        ),\n        u32x8::new_const(\n            28568737, 10733123, 9342397, 21570673, 54096560, 32467591, 20494687, 21511513,\n        ),\n        u32x8::new_const(\n            47675157, 47932807, 29250946, 15672208, 59760469, 9945465, 14939287, 18437405,\n        ),\n        u32x8::new_const(\n            37985267, 8609815, 31573002, 3373596, 47828883, 20834216, 13248616, 24154292,\n        ),\n        u32x8::new_const(\n            5543543, 29553242, 3386453, 30501150, 25058089, 15236571, 8814395, 32462955,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            39158670, 15322548, 20495103, 3312736, 14557171, 12985179, 8044741, 3176899,\n        ),\n        u32x8::new_const(\n            24673290, 29693310, 21412266, 18324699, 2154518, 40329021, 17500543, 3954277,\n        ),\n        u32x8::new_const(\n            36758685, 38738957, 165513, 14691866, 3070475, 10424235, 17096536, 16896898,\n        ),\n        u32x8::new_const(\n            59790459, 43094586, 8720681, 10423589, 1122030, 31545615, 4463786, 31811293,\n        ),\n        u32x8::new_const(\n            49778992, 60881044, 20509974, 5832494, 64155961, 31483358, 4511231, 20307815,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            2863373, 40876242, 26865913, 24067353, 15726407, 40919070, 12953902, 9931535,\n        ),\n        u32x8::new_const(\n            60934877, 42512204, 21649141, 21945190, 52211954, 60984193, 7046207, 5363493,\n        ),\n        u32x8::new_const(\n            4205971, 64068464, 18197273, 7327176, 51527794, 21166920, 20669933, 11828242,\n        ),\n        u32x8::new_const(\n            59782815, 49617225, 15379924, 457923, 9320508, 21498914, 3242540, 31563182,\n        ),\n        u32x8::new_const(\n            27714753, 8664670, 3366162, 26338598, 56775518, 25796006, 13129151, 21388876,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            59276548, 49972346, 16795002, 33455915, 48430097, 53857205, 18627071, 32474471,\n        ),\n        u32x8::new_const(\n            42160315, 50705892, 13530540, 28012698, 19833221, 55886870, 20191784, 9644313,\n        ),\n        u32x8::new_const(\n            20372416, 28414713, 24084234, 31804096, 33815377, 36131001, 17251241, 18291088,\n        ),\n        u32x8::new_const(\n            56234667, 14920441, 2033267, 29572003, 1724043, 45519699, 17873735, 501988,\n        ),\n        u32x8::new_const(\n            50031659, 31517850, 15697583, 1016845, 43104661, 54769582, 8008601, 27257051,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            52951491, 66542164, 14853573, 30444631, 12045973, 24321813, 16545674, 18160646,\n        ),\n        u32x8::new_const(\n            60107911, 1126003, 5947677, 19486116, 41119984, 30860440, 7935395, 13354438,\n        ),\n        u32x8::new_const(\n            17841328, 11063269, 1664538, 26687568, 6268968, 22280371, 17275484, 4523163,\n        ),\n        u32x8::new_const(\n            15886041, 56799482, 15446552, 21712778, 1005290, 17827215, 4978741, 6854882,\n        ),\n        u32x8::new_const(\n            34319277, 47731002, 20321804, 28544575, 29591814, 63376351, 24754545, 26001714,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            66783087, 5234346, 46102, 8566476, 19947339, 20180418, 25398238, 3726678,\n        ),\n        u32x8::new_const(\n            63890180, 46380965, 20674069, 5366544, 59661487, 48406612, 31533614, 7071217,\n        ),\n        u32x8::new_const(\n            13104676, 1406631, 24326736, 19854367, 61039528, 11019904, 31967425, 19219275,\n        ),\n        u32x8::new_const(\n            39003597, 30143957, 15351834, 8639435, 57309582, 61436794, 15830475, 10090318,\n        ),\n        u32x8::new_const(\n            45923044, 6700175, 99413, 21263025, 23762647, 53905481, 6063914, 10065424,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            42822326, 57678669, 4052879, 25452667, 54049411, 2373092, 22337016, 7701046,\n        ),\n        u32x8::new_const(\n            44382355, 43307377, 16761537, 30373573, 49790216, 23230748, 25655306, 10519391,\n        ),\n        u32x8::new_const(\n            919475, 59371245, 1273450, 25558666, 9724711, 8556709, 25755845, 10887647,\n        ),\n        u32x8::new_const(\n            25465699, 44651158, 17658392, 11257418, 29735193, 22885150, 7094716, 26828565,\n        ),\n        u32x8::new_const(\n            48237389, 47661599, 27054393, 7328070, 27280193, 65616691, 23062005, 4170709,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            26535281, 60238317, 30343788, 25790743, 37993933, 24614372, 9523840, 10401918,\n        ),\n        u32x8::new_const(\n            2783987, 29468958, 4697011, 19804475, 37246678, 46797720, 10261254, 18942252,\n        ),\n        u32x8::new_const(\n            58135580, 60247753, 25301938, 6844561, 20949454, 39844754, 4552026, 919057,\n        ),\n        u32x8::new_const(\n            6694071, 44126261, 32285330, 31370180, 24603698, 53328179, 13971149, 5325636,\n        ),\n        u32x8::new_const(\n            64879487, 582094, 17982081, 19190425, 24951286, 26923842, 29077174, 33286062,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            54863941, 67016431, 1224043, 23371240, 62940074, 52101083, 13523637, 30366406,\n        ),\n        u32x8::new_const(\n            36324581, 25407485, 18258623, 4698602, 50300544, 2658516, 26300935, 2611030,\n        ),\n        u32x8::new_const(\n            27183975, 21791014, 18105064, 9875199, 58118912, 54198635, 6400311, 14767984,\n        ),\n        u32x8::new_const(\n            33918318, 42937962, 14809334, 22136592, 10636588, 29082337, 29829692, 28549776,\n        ),\n        u32x8::new_const(\n            61080905, 854212, 12202487, 20004503, 9256495, 6903981, 20567109, 347423,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            41391822, 34336880, 22362564, 14247996, 12115604, 41583344, 7639288, 28910945,\n        ),\n        u32x8::new_const(\n            62066617, 59758859, 26665947, 11614812, 65737664, 45704543, 30324810, 12868376,\n        ),\n        u32x8::new_const(\n            17491771, 43589814, 9454919, 26047850, 52629282, 39304244, 3868968, 19296062,\n        ),\n        u32x8::new_const(\n            17826638, 30413590, 32534225, 32741469, 15012391, 14365713, 33039233, 14791399,\n        ),\n        u32x8::new_const(\n            64115596, 59197067, 32739005, 23275744, 32954320, 22241406, 20788442, 4942942,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            31956192, 59570132, 2784352, 4237732, 47222312, 4860927, 18658867, 15279314,\n        ),\n        u32x8::new_const(\n            63240583, 28160478, 23524941, 13390861, 66437406, 57718120, 33345312, 28896298,\n        ),\n        u32x8::new_const(\n            39026193, 46239965, 21440243, 25070488, 64012383, 60999016, 16517060, 29565907,\n        ),\n        u32x8::new_const(\n            18118181, 60161496, 4212092, 23976240, 36277753, 62363144, 5816868, 16964362,\n        ),\n        u32x8::new_const(\n            18196138, 62490693, 281468, 7934713, 56027312, 62015725, 4837237, 32932252,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            29885826, 51028067, 30418143, 33438769, 62542283, 39442528, 31535876, 143299,\n        ),\n        u32x8::new_const(\n            17143063, 56709783, 14451852, 15782104, 32762665, 14047066, 26295037, 5432487,\n        ),\n        u32x8::new_const(\n            75151, 533606, 7539077, 30926189, 38410914, 23771680, 4872443, 29199566,\n        ),\n        u32x8::new_const(\n            61522396, 48934708, 16223126, 207380, 11171993, 47975147, 14164574, 352966,\n        ),\n        u32x8::new_const(\n            15449006, 56530757, 26796528, 12045834, 63738697, 40667227, 33001582, 9101885,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            43331297, 18431341, 25801195, 17267698, 19365485, 57295202, 22218985, 21284590,\n        ),\n        u32x8::new_const(\n            2429849, 19152559, 10762172, 22564684, 21880390, 66866426, 20357935, 22641906,\n        ),\n        u32x8::new_const(\n            19771185, 31652693, 3666117, 28136958, 23624283, 55101502, 6313920, 6783662,\n        ),\n        u32x8::new_const(\n            3487137, 7092443, 11001876, 26196524, 47319246, 44542068, 17594073, 15027760,\n        ),\n        u32x8::new_const(\n            49563607, 32191113, 4991283, 25400512, 46539152, 4155103, 32368171, 201203,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            20548943, 14334571, 4073874, 6368588, 53208883, 56484515, 15970071, 25561889,\n        ),\n        u32x8::new_const(\n            49915097, 44030795, 11202344, 29284344, 60258023, 66225712, 8075764, 12383512,\n        ),\n        u32x8::new_const(\n            45248912, 4933668, 9592153, 5819559, 31030983, 38174071, 32435814, 7442522,\n        ),\n        u32x8::new_const(\n            62688129, 48218381, 22089545, 12897361, 21050881, 34278889, 7569163, 3225449,\n        ),\n        u32x8::new_const(\n            19050183, 51089071, 32935757, 22640195, 66122318, 47144608, 18743677, 25177079,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            41186817, 46681702, 31819867, 32997133, 38559207, 27147015, 30293819, 16762988,\n        ),\n        u32x8::new_const(\n            24154689, 51762873, 23883879, 13510519, 55338250, 61224161, 11663149, 30803960,\n        ),\n        u32x8::new_const(\n            18104238, 14117824, 11724021, 21362053, 65704761, 35530242, 13498058, 33522849,\n        ),\n        u32x8::new_const(\n            63812888, 23995539, 28920539, 24005193, 26412223, 36582218, 4251418, 26160309,\n        ),\n        u32x8::new_const(\n            16822053, 66064082, 3482145, 31979593, 45937188, 54475379, 612917, 7976478,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            46509314, 55327128, 8944536, 274914, 26432930, 53829300, 21192572, 3569894,\n        ),\n        u32x8::new_const(\n            20919764, 64356651, 30642344, 17215170, 20335124, 11203745, 18663316, 19024174,\n        ),\n        u32x8::new_const(\n            59297055, 53842463, 3680204, 9806710, 54004169, 51484914, 29807998, 20134199,\n        ),\n        u32x8::new_const(\n            14781592, 22628010, 26877930, 25880359, 30434803, 190607, 30184292, 8991040,\n        ),\n        u32x8::new_const(\n            64400983, 64591751, 854562, 28216111, 20010398, 50414793, 9803872, 22687008,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            15091184, 32550863, 8818643, 4244752, 43123513, 64565526, 408838, 13206998,\n        ),\n        u32x8::new_const(\n            16405061, 60379639, 31489017, 20949281, 27568751, 38734986, 8364264, 12451020,\n        ),\n        u32x8::new_const(\n            16005217, 58008076, 1406778, 26546927, 39571784, 56365493, 31274296, 8918790,\n        ),\n        u32x8::new_const(\n            23271122, 19453469, 27718201, 32742670, 234332, 36785342, 22601675, 14331046,\n        ),\n        u32x8::new_const(\n            40636025, 22442705, 22115403, 23745859, 41164945, 61012, 12499614, 542137,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            62776018, 32835413, 17373246, 17187309, 54469193, 21770290, 15923753, 28996575,\n        ),\n        u32x8::new_const(\n            59385210, 63082298, 12568449, 8509004, 9483342, 16105238, 5756054, 26890758,\n        ),\n        u32x8::new_const(\n            53987996, 38201748, 5521661, 19060159, 18663191, 9093637, 27786835, 31189196,\n        ),\n        u32x8::new_const(\n            65872678, 43635130, 27903055, 25020300, 65772737, 38110437, 5213502, 21909342,\n        ),\n        u32x8::new_const(\n            4438979, 9680838, 10212446, 4764184, 13235684, 58245995, 20264570, 21024049,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            60835961, 48209103, 31049052, 4688268, 12426713, 59829045, 22302488, 29008521,\n        ),\n        u32x8::new_const(\n            50401667, 29716596, 23531224, 7581281, 49071895, 6952617, 14934683, 8218256,\n        ),\n        u32x8::new_const(\n            1601446, 36631413, 31774811, 29625330, 56786114, 8331539, 23129509, 19783344,\n        ),\n        u32x8::new_const(\n            59514327, 64513110, 1772300, 5701338, 5737511, 16147555, 9461515, 5703271,\n        ),\n        u32x8::new_const(\n            33072974, 54300426, 11940114, 1308663, 15627555, 4931627, 28443714, 20924342,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            18135013, 20358426, 4922557, 10015355, 65729669, 34786528, 26248549, 29194359,\n        ),\n        u32x8::new_const(\n            797666, 34997544, 24316856, 25107230, 24612576, 4761401, 15307321, 32404252,\n        ),\n        u32x8::new_const(\n            16501152, 60565831, 9487105, 9316022, 24986054, 31917592, 3962024, 2501883,\n        ),\n        u32x8::new_const(\n            63356796, 50432342, 18044926, 30566881, 42032028, 31415202, 13524600, 16119907,\n        ),\n        u32x8::new_const(\n            3927286, 57022374, 9265437, 21620772, 19481940, 3806938, 24836192, 14572399,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            10785787, 46564798, 368445, 33181384, 5319843, 52687136, 30347110, 29837357,\n        ),\n        u32x8::new_const(\n            56436732, 47859251, 24141084, 22250712, 59046084, 4963427, 33463413, 17168859,\n        ),\n        u32x8::new_const(\n            15512044, 6366740, 4737504, 27644548, 30307977, 25037929, 14593903, 12836490,\n        ),\n        u32x8::new_const(\n            63878897, 34013023, 5860752, 7244096, 3689461, 57012135, 18389096, 11589351,\n        ),\n        u32x8::new_const(\n            4682110, 36302830, 653422, 22316819, 14081831, 5657024, 11088376, 24110612,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            39907267, 45940262, 24887471, 18342609, 878445, 40456159, 12019082, 345107,\n        ),\n        u32x8::new_const(\n            12794982, 28893944, 9447505, 11387200, 16961963, 13916996, 10893728, 25898006,\n        ),\n        u32x8::new_const(\n            44934162, 53465865, 3583620, 1102334, 53917811, 63478576, 2426066, 10389549,\n        ),\n        u32x8::new_const(\n            45096036, 37595344, 19367718, 20257175, 10280866, 41653449, 27665642, 375926,\n        ),\n        u32x8::new_const(\n            45847901, 24064074, 32494820, 32204556, 10720704, 51079060, 1297436, 29853825,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            66303987, 36060363, 16494578, 24962147, 11971403, 49538586, 25060560, 1964341,\n        ),\n        u32x8::new_const(\n            25988481, 27641502, 24909517, 27237087, 66646363, 52777626, 16360849, 10459972,\n        ),\n        u32x8::new_const(\n            43930529, 34374176, 31225968, 8807030, 10394758, 35904854, 25325589, 19335583,\n        ),\n        u32x8::new_const(\n            25094697, 34380951, 20051185, 32287161, 11739332, 53887441, 30517319, 26601892,\n        ),\n        u32x8::new_const(\n            8868546, 35635502, 32513071, 28248087, 51946989, 14222744, 19198839, 23261841,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            51218008, 5070126, 11046681, 5320810, 61212079, 34104447, 23895089, 6460727,\n        ),\n        u32x8::new_const(\n            39843528, 46278671, 10426120, 25624792, 66658766, 37140083, 28933107, 12969597,\n        ),\n        u32x8::new_const(\n            59635793, 40220191, 5751421, 173680, 58321825, 740337, 1412847, 7682623,\n        ),\n        u32x8::new_const(\n            975962, 56440763, 20812276, 22631115, 49095824, 19883130, 2419746, 31043648,\n        ),\n        u32x8::new_const(\n            66208703, 39669328, 22525915, 3748897, 65994776, 34533552, 8126286, 18326047,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            64176557, 3912400, 19351673, 30068471, 31190055, 24221683, 33142424, 28698542,\n        ),\n        u32x8::new_const(\n            34784792, 4109933, 3867193, 19557314, 2112512, 32715890, 24550117, 16595976,\n        ),\n        u32x8::new_const(\n            35542761, 48024875, 10925431, 31526577, 66577735, 23189821, 13375709, 1735095,\n        ),\n        u32x8::new_const(\n            59699254, 43854093, 29783239, 24777271, 19600372, 39924461, 2896720, 1472185,\n        ),\n        u32x8::new_const(\n            56389656, 35980854, 33172342, 1370336, 23707480, 57654949, 7850973, 12655016,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            38372660, 57101970, 7044964, 12732710, 57535705, 6043201, 30858914, 10946592,\n        ),\n        u32x8::new_const(\n            21023468, 6946992, 26403324, 23901823, 35695559, 23440687, 4763891, 6514074,\n        ),\n        u32x8::new_const(\n            28662273, 30933699, 9352242, 26354829, 37402243, 3145176, 8770289, 525937,\n        ),\n        u32x8::new_const(\n            54933102, 36695832, 3281859, 4755022, 23043294, 32794379, 15618886, 23602412,\n        ),\n        u32x8::new_const(\n            9931565, 29897140, 2480737, 24193701, 7833615, 2284939, 893926, 13421882,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            22917795, 22088359, 28978099, 19794863, 60542318, 29878494, 31053731, 9080720,\n        ),\n        u32x8::new_const(\n            23679072, 52547035, 28424916, 20647332, 4008761, 28267029, 12961289, 1589095,\n        ),\n        u32x8::new_const(\n            55616194, 26678929, 14998265, 23274397, 54625466, 46244264, 28627706, 33030665,\n        ),\n        u32x8::new_const(\n            11527330, 6449415, 26531607, 3472938, 41541592, 62607682, 19862690, 20564723,\n        ),\n        u32x8::new_const(\n            32843805, 49066843, 28425824, 19521495, 48792073, 48242878, 27392443, 13175986,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            16185025, 61537525, 2961305, 1492442, 25123147, 3095034, 31896958, 33089615,\n        ),\n        u32x8::new_const(\n            64748157, 18336595, 16522231, 25426312, 65718949, 35485695, 30554083, 10205918,\n        ),\n        u32x8::new_const(\n            39626934, 39271045, 16420458, 9826240, 56483981, 27128085, 3783403, 13360006,\n        ),\n        u32x8::new_const(\n            30793778, 66771960, 17241420, 6564573, 61102581, 29974476, 32385512, 9011754,\n        ),\n        u32x8::new_const(\n            28068166, 11862220, 14323567, 12380617, 52090465, 16029056, 24495309, 21409233,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            59411973, 57437124, 11695483, 17586857, 16108987, 43449109, 31098002, 6248476,\n        ),\n        u32x8::new_const(\n            42258047, 61595931, 29308533, 11742653, 43042345, 27373650, 30165249, 21929989,\n        ),\n        u32x8::new_const(\n            49907221, 9620337, 21888081, 20981082, 56288861, 61562203, 33223566, 3582446,\n        ),\n        u32x8::new_const(\n            57535017, 41003416, 22080416, 14463796, 65518565, 18127889, 24370863, 33332664,\n        ),\n        u32x8::new_const(\n            66655380, 6430175, 471782, 11947673, 30596400, 18898659, 15930721, 4211851,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            6757410, 65455566, 13584784, 11362173, 10797127, 24451471, 19541370, 29309435,\n        ),\n        u32x8::new_const(\n            40360156, 17685025, 18326181, 3846903, 13693365, 63049479, 31900359, 23385063,\n        ),\n        u32x8::new_const(\n            52455038, 57513503, 22163311, 27095042, 48610726, 66454160, 12085341, 26357004,\n        ),\n        u32x8::new_const(\n            22097042, 14063840, 6705778, 14342902, 66139825, 20702105, 31279090, 7495745,\n        ),\n        u32x8::new_const(\n            27360710, 49314837, 18774847, 7146436, 37066216, 42004961, 22409916, 10524446,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            1497507, 33054449, 11839906, 2960428, 40538463, 18884538, 25018820, 4073970,\n        ),\n        u32x8::new_const(\n            54484385, 43640735, 2808257, 20710708, 39840730, 27222424, 21783544, 11848522,\n        ),\n        u32x8::new_const(\n            45765237, 48200555, 9299019, 9393151, 34818188, 56098995, 13575233, 21012731,\n        ),\n        u32x8::new_const(\n            4265428, 49627650, 24960282, 9425650, 47883651, 2797524, 11853190, 22877329,\n        ),\n        u32x8::new_const(\n            25008173, 64199503, 380047, 12107343, 12329448, 11914399, 764281, 29687002,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            35889734, 23047226, 4022841, 7017445, 7274086, 53316179, 25100176, 15310676,\n        ),\n        u32x8::new_const(\n            42409427, 30270106, 6823853, 31551384, 40645017, 66489807, 18021817, 32669351,\n        ),\n        u32x8::new_const(\n            39827134, 43680850, 28297996, 20258133, 26058742, 52643238, 22238331, 21690533,\n        ),\n        u32x8::new_const(\n            60808002, 17499995, 30042246, 29310584, 48219954, 29389518, 8680514, 17844709,\n        ),\n        u32x8::new_const(\n            6452896, 50116553, 9532047, 26821214, 44524351, 50428429, 21904953, 12608048,\n        ),\n    ])),\n]);",
    "display_name": "new_const",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/vector/avx2/constants.rs",
    "relative_path": "curve25519-dalek/src/backend/vector/avx2/constants.rs",
    "file_name": "constants.rs",
    "parent_folder": "avx2"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 decompress/ristretto/step_2",
      "5.0.0_pre.0 decompress/ristretto/step_1",
      "5.0.0_pre.0 ristretto/RistrettoPoint/coset4"
    ],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let coset = self.coset4();\n        write!(\n            f,\n            \"RistrettoPoint: coset \\n{:?}\\n{:?}\\n{:?}\\n{:?}\",\n            coset[0], coset[1], coset[2], coset[3]\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/Sum/sum",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core iterator/traits/iter/Iterator/fold"
    ],
    "body": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }",
    "display_name": "sum",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 scalar/Scalar/ConditionallySelectable/conditional_select",
    "statement_type": "function",
    "deps": [
      "ConditionallySelectable/conditional_select"
    ],
    "body": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }",
    "display_name": "conditional_select",
    "full_path": "file:///work/3185/curve25519-dalek/src/scalar.rs",
    "relative_path": "curve25519-dalek/src/scalar.rs",
    "file_name": "scalar.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/Neg/neg",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/negate"
    ],
    "body": "    fn neg(self) -> FieldElement51 {\n        let mut output = *self;\n        output.negate();\n        output\n    }",
    "display_name": "neg",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/u64/field.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "file_name": "field.rs",
    "parent_folder": "u64"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/VartimeRistrettoPrecomputation/VartimePrecomputedMultiscalarMul/len",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 backend/VartimePrecomputedStraus/len"
    ],
    "body": "    fn len(&self) -> usize {\n        self.0.len()\n    }",
    "display_name": "len",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "core https:/github.com/rust_lang/rust/library/core result/Result/as_deref",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "as_deref",
    "full_path": "file:///work/3185/curve25519-dalek/build.rs",
    "relative_path": "curve25519-dalek/build.rs",
    "file_name": "build.rs",
    "parent_folder": "curve25519-dalek"
  },
  {
    "identifier": "5.0.0_pre.0 ristretto/RistrettoPoint/Default/default",
    "statement_type": "function",
    "deps": [
      "5.0.0_pre.0 ristretto/RistrettoPoint/Identity/identity"
    ],
    "body": "    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }",
    "display_name": "default",
    "full_path": "file:///work/3185/curve25519-dalek/src/ristretto.rs",
    "relative_path": "curve25519-dalek/src/ristretto.rs",
    "file_name": "ristretto.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 edwards/CompressedEdwardsY/from_slice",
    "statement_type": "function",
    "deps": [
      "core https:/github.com/rust_lang/rust/library/core result/Result/map",
      "core https:/github.com/rust_lang/rust/library/core convert/TryInto/try_into"
    ],
    "body": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        bytes.try_into().map(CompressedEdwardsY)\n    }",
    "display_name": "from_slice",
    "full_path": "file:///work/3185/curve25519-dalek/src/edwards.rs",
    "relative_path": "curve25519-dalek/src/edwards.rs",
    "file_name": "edwards.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 field/u64/serial/backend/FieldElement51/pow2k",
    "statement_type": "function",
    "deps": [],
    "body": "    #[test]\n    fn a_square_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(asq, a.square());\n    }",
    "display_name": "pow2k",
    "full_path": "file:///work/3185/curve25519-dalek/src/field.rs",
    "relative_path": "curve25519-dalek/src/field.rs",
    "file_name": "field.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "5.0.0_pre.0 curve_models/serial/backend/CompletedPoint/Debug/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"CompletedPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3185/curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "relative_path": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "file_name": "mod.rs",
    "parent_folder": "curve_models"
  },
  {
    "identifier": "0.1.1 SpecializeArg/condition",
    "statement_type": "function",
    "deps": [],
    "body": "    fn condition(&self) -> Option<&TokenStream2> {\n        match self {\n            SpecializeArg::LitStr(..) => None,\n            SpecializeArg::Conditional(conditional) => Some(&conditional.attr),\n        }\n    }",
    "display_name": "condition",
    "full_path": "file:///work/3185/curve25519-dalek-derive/src/lib.rs",
    "relative_path": "curve25519-dalek-derive/src/lib.rs",
    "file_name": "lib.rs",
    "parent_folder": "src"
  }
]