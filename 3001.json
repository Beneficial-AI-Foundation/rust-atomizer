[
  {
    "identifier": "bn/division/impl/BigNum/modulo",
    "statement_type": "function",
    "deps": [
      "bn/division/impl/BigNum/divide"
    ],
    "body": "    pub fn modulo(&self, other: &BigNum) -> BigNum {\n        self.divide(other).1\n    }",
    "display_name": "modulo",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/multiplication/tests/test_multiply_by_zero",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/from_u64",
      "bn/multiplication/impl/BigNum/multiply"
    ],
    "body": "    fn test_multiply_by_zero() {\n        let a = BigNum::from_u64(42);\n        let b = BigNum::from_u64(0);\n        let result = a.multiply(&b);\n        assert_eq!(result.to_u64(), 0);\n    }",
    "display_name": "test_multiply_by_zero",
    "full_path": "file:///work/3001/src/bn/multiplication.rs",
    "relative_path": "src/bn/multiplication.rs",
    "file_name": "multiplication.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/multiplication/tests/test_multiply_larger",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/from_u64",
      "bn/multiplication/impl/BigNum/multiply"
    ],
    "body": "    fn test_multiply_larger() {\n        let a = BigNum::from_u64(12); // 1100\n        let b = BigNum::from_u64(15); // 1111\n        let result = a.multiply(&b);\n        assert_eq!(result.to_u64(), 180); // 12 * 15 = 180\n    }",
    "display_name": "test_multiply_larger",
    "full_path": "file:///work/3001/src/bn/multiplication.rs",
    "relative_path": "src/bn/multiplication.rs",
    "file_name": "multiplication.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/shl",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/is_zero",
      "bn/bn/impl/BigNum/Clone/clone",
      "bn/bn/impl/BigNum/normalize"
    ],
    "body": "    pub fn shl(&self, n: usize) -> BigNum {\n        if self.is_zero() || n == 0 {\n            return self.clone();\n        }\n        \n        let mut result = vec![false; n];\n        result.extend(&self.bits);\n        \n        let mut bn = BigNum { bits: result };\n        bn.normalize();\n        bn\n    }",
    "display_name": "shl",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/to_u64",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn to_u64(&self) -> u64 {\n        let mut result = 0u64;\n        for (i, &bit) in self.bits.iter().enumerate() {\n            if i >= 64 { break; }\n            if bit {\n                result |= 1u64 << i;\n            }\n        }\n        result\n    }",
    "display_name": "to_u64",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/multiplication/tests/test_multiply_powers_of_two",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/from_u64",
      "bn/multiplication/impl/BigNum/multiply"
    ],
    "body": "    fn test_multiply_powers_of_two() {\n        let a = BigNum::from_u64(8);  // 1000\n        let b = BigNum::from_u64(16); // 10000\n        let result = a.multiply(&b);\n        assert_eq!(result.to_u64(), 128); // 8 * 16 = 128\n    }",
    "display_name": "test_multiply_powers_of_two",
    "full_path": "file:///work/3001/src/bn/multiplication.rs",
    "relative_path": "src/bn/multiplication.rs",
    "file_name": "multiplication.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/cmp",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/Clone/clone",
      "bn/bn/impl/BigNum/normalize"
    ],
    "body": "    pub fn cmp(&self, other: &BigNum) -> std::cmp::Ordering {\n        use std::cmp::Ordering;\n        \n        // First compare by length (after normalization)\n        let mut self_normalized = self.clone();\n        let mut other_normalized = other.clone();\n        self_normalized.normalize();\n        other_normalized.normalize();\n        \n        match self_normalized.bits.len().cmp(&other_normalized.bits.len()) {\n            Ordering::Greater => Ordering::Greater,\n            Ordering::Less => Ordering::Less,\n            Ordering::Equal => {\n                // Same length, compare bit by bit from MSB to LSB\n                for i in (0..self_normalized.bits.len()).rev() {\n                    let self_bit = self_normalized.bits[i];\n                    let other_bit = other_normalized.bits[i];\n                    match self_bit.cmp(&other_bit) {\n                        Ordering::Equal => continue,\n                        other => return other,\n                    }\n                }\n                Ordering::Equal\n            }\n        }\n    }",
    "display_name": "cmp",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/tests/test_from_u64",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_from_u64() {\n        let bn = BigNum::from_u64(5);\n        assert_eq!(bn.bits, vec![true, false, true]); // 101 in binary (LSB first)\n    }",
    "display_name": "test_from_u64",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/tests/test_is_zero",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/is_zero",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_is_zero() {\n        let zero = BigNum::from_u64(0);\n        let non_zero = BigNum::from_u64(1);\n        assert!(zero.is_zero());\n        assert!(!non_zero.is_zero());\n    }",
    "display_name": "test_is_zero",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/tests/test_cmp",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/from_u64",
      "bn/bn/impl/BigNum/cmp"
    ],
    "body": "    fn test_cmp() {\n        let a = BigNum::from_u64(10);\n        let b = BigNum::from_u64(5);\n        let c = BigNum::from_u64(10);\n        \n        assert_eq!(a.cmp(&b), std::cmp::Ordering::Greater);\n        assert_eq!(b.cmp(&a), std::cmp::Ordering::Less);\n        assert_eq!(a.cmp(&c), std::cmp::Ordering::Equal);\n    }",
    "display_name": "test_cmp",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/impl/BigNum/div",
    "statement_type": "function",
    "deps": [
      "bn/division/impl/BigNum/divide"
    ],
    "body": "    pub fn div(&self, other: &BigNum) -> BigNum {\n        self.divide(other).0\n    }",
    "display_name": "div",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/addition/tests/test_add_with_carry",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/from_u64",
      "bn/bn/impl/BigNum/to_u64",
      "bn/addition/impl/BigNum/add"
    ],
    "body": "    fn test_add_with_carry() {\n        let a = BigNum::from_u64(15); // 1111\n        let b = BigNum::from_u64(1);  // 0001\n        let result = a.add(&b);\n        assert_eq!(result.to_u64(), 16); // 10000\n    }",
    "display_name": "test_add_with_carry",
    "full_path": "file:///work/3001/src/bn/addition.rs",
    "relative_path": "src/bn/addition.rs",
    "file_name": "addition.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/tests/test_divide_smaller_by_larger",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/to_u64",
      "bn/division/impl/BigNum/divide",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_divide_smaller_by_larger() {\n        let a = BigNum::from_u64(3);\n        let b = BigNum::from_u64(10);\n        let (quotient, remainder) = a.divide(&b);\n        assert_eq!(quotient.to_u64(), 0);\n        assert_eq!(remainder.to_u64(), 3);\n    }",
    "display_name": "test_divide_smaller_by_larger",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/subtraction/tests/test_subtract",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/to_u64",
      "bn/subtraction/impl/BigNum/subtract",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_subtract() {\n        let a = BigNum::from_u64(10);\n        let b = BigNum::from_u64(3);\n        let result = a.subtract(&b);\n        assert_eq!(result.to_u64(), 7);\n    }",
    "display_name": "test_subtract",
    "full_path": "file:///work/3001/src/bn/subtraction.rs",
    "relative_path": "src/bn/subtraction.rs",
    "file_name": "subtraction.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/from_bits",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_bits(bits: Vec<bool>) -> Self {\n        BigNum { bits }\n    }",
    "display_name": "from_bits",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/tests/test_divide_with_remainder",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/from_u64",
      "bn/bn/impl/BigNum/to_u64",
      "bn/division/impl/BigNum/divide"
    ],
    "body": "    fn test_divide_with_remainder() {\n        let a = BigNum::from_u64(17);\n        let b = BigNum::from_u64(5);\n        let (quotient, remainder) = a.divide(&b);\n        assert_eq!(quotient.to_u64(), 3);\n        assert_eq!(remainder.to_u64(), 2);\n    }",
    "display_name": "test_divide_with_remainder",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/tests/test_divide_by_zero",
    "statement_type": "function",
    "deps": [
      "bn/division/impl/BigNum/divide",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_divide_by_zero() {\n        let a = BigNum::from_u64(10);\n        let b = BigNum::from_u64(0);\n        a.divide(&b);\n    }",
    "display_name": "test_divide_by_zero",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/is_zero",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn is_zero(&self) -> bool {\n        self.bits.iter().all(|&bit| !bit)\n    }",
    "display_name": "is_zero",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/multiplication/tests/test_multiply_by_one",
    "statement_type": "function",
    "deps": [
      "bn/multiplication/impl/BigNum/multiply",
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_multiply_by_one() {\n        let a = BigNum::from_u64(42);\n        let b = BigNum::from_u64(1);\n        let result = a.multiply(&b);\n        assert_eq!(result.to_u64(), 42);\n    }",
    "display_name": "test_multiply_by_one",
    "full_path": "file:///work/3001/src/bn/multiplication.rs",
    "relative_path": "src/bn/multiplication.rs",
    "file_name": "multiplication.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/impl/BigNum/divide",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/is_zero",
      "bn/bn/impl/BigNum/Clone/clone",
      "bn/bn/impl/BigNum/shl",
      "bn/bn/impl/BigNum/cmp",
      "bn/addition/impl/BigNum/add",
      "bn/bn/impl/BigNum/normalize",
      "bn/bn/impl/BigNum/from_u64",
      "bn/subtraction/impl/BigNum/subtract"
    ],
    "body": "    pub fn divide(&self, other: &BigNum) -> (BigNum, BigNum) {\n        if other.is_zero() {\n            panic!(\"Division by zero\");\n        }\n        \n        if self.is_zero() {\n            return (BigNum::from_u64(0), BigNum::from_u64(0));\n        }\n        \n        use std::cmp::Ordering;\n        match self.cmp(other) {\n            Ordering::Less => {\n                // self < other, so quotient is 0 and remainder is self\n                return (BigNum::from_u64(0), self.clone());\n            }\n            Ordering::Equal => {\n                // self == other, so quotient is 1 and remainder is 0\n                return (BigNum::from_u64(1), BigNum::from_u64(0));\n            }\n            Ordering::Greater => {\n                // Proceed with long division\n            }\n        }\n        \n        // Long division algorithm\n        let mut quotient_bits = vec![false; self.bits.len()];\n        let mut remainder = BigNum::from_u64(0);\n\n        // Process bits from MSB to LSB\n        for i in (0..self.bits.len()).rev() {\n            // Shift remainder left by 1 and add current bit\n            remainder = remainder.shl(1);\n            if self.bits[i] {\n                remainder = remainder.add(&BigNum::from_u64(1));\n            }\n\n            // If remainder >= divisor, subtract and set quotient bit\n            if remainder.cmp(other) != Ordering::Less {\n                remainder = remainder.subtract(other);\n                quotient_bits[i] = true;\n            }\n        }\n        \n        let mut quotient = BigNum { bits: quotient_bits };\n        quotient.normalize();\n        remainder.normalize();\n        (quotient, remainder)\n    }",
    "display_name": "divide",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/len",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn len(&self) -> usize {\n        self.bits.len()\n    }",
    "display_name": "len",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/normalize",
    "statement_type": "function",
    "deps": [],
    "body": "    pub(crate) fn normalize(&mut self) {\n        while self.bits.len() > 1 && !self.bits.last().unwrap() {\n            self.bits.pop();\n        }\n    }",
    "display_name": "normalize",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/tests/test_divide_equal_numbers",
    "statement_type": "function",
    "deps": [
      "bn/division/impl/BigNum/divide",
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_divide_equal_numbers() {\n        let a = BigNum::from_u64(42);\n        let b = BigNum::from_u64(42);\n        let (quotient, remainder) = a.divide(&b);\n        assert_eq!(quotient.to_u64(), 1);\n        assert_eq!(remainder.to_u64(), 0);\n    }",
    "display_name": "test_divide_equal_numbers",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/multiplication/tests/test_multiply_simple",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/from_u64",
      "bn/bn/impl/BigNum/to_u64",
      "bn/multiplication/impl/BigNum/multiply"
    ],
    "body": "    fn test_multiply_simple() {\n        let a = BigNum::from_u64(5); // 101\n        let b = BigNum::from_u64(3); // 011\n        let result = a.multiply(&b);\n        assert_eq!(result.to_u64(), 15); // 5 * 3 = 15\n    }",
    "display_name": "test_multiply_simple",
    "full_path": "file:///work/3001/src/bn/multiplication.rs",
    "relative_path": "src/bn/multiplication.rs",
    "file_name": "multiplication.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/subtraction/impl/BigNum/subtract",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/normalize"
    ],
    "body": "    pub fn subtract(&self, other: &BigNum) -> BigNum {\n        let max_len = self.bits.len().max(other.bits.len());\n        let mut result = Vec::with_capacity(max_len);\n        let mut borrow = false;\n\n        for i in 0..max_len {\n            let a = self.bits.get(i).copied().unwrap_or(false);\n            let b = other.bits.get(i).copied().unwrap_or(false);\n\n            // Subtract with borrow: diff = a - b - borrow\n            let diff = a as i8 - b as i8 - borrow as i8;\n            if diff >= 0 {\n                result.push(diff != 0);\n                borrow = false;\n            } else {\n                result.push(true); // 1 - 1 - 1 = -1, which is 1 with borrow\n                borrow = true;\n            }\n        }\n\n        let mut bn = BigNum { bits: result };\n        bn.normalize();\n        bn\n    }",
    "display_name": "subtract",
    "full_path": "file:///work/3001/src/bn/subtraction.rs",
    "relative_path": "src/bn/subtraction.rs",
    "file_name": "subtraction.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/addition/tests/test_add_simple",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/from_u64",
      "bn/bn/impl/BigNum/to_u64",
      "bn/addition/impl/BigNum/add"
    ],
    "body": "    fn test_add_simple() {\n        let a = BigNum::from_u64(5); // 101\n        let b = BigNum::from_u64(3); // 011\n        let result = a.add(&b);\n        assert_eq!(result.to_u64(), 8); // 1000\n    }",
    "display_name": "test_add_simple",
    "full_path": "file:///work/3001/src/bn/addition.rs",
    "relative_path": "src/bn/addition.rs",
    "file_name": "addition.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/Clone/clone",
    "statement_type": "function",
    "deps": [],
    "body": "",
    "display_name": "clone",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/tests/test_shr",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/shr",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_shr() {\n        let a = BigNum::from_u64(20); // 10100\n        let result = a.shr(2);        // Should be 101 = 5\n        assert_eq!(result.to_u64(), 5);\n    }",
    "display_name": "test_shr",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/from_u64",
    "statement_type": "function",
    "deps": [],
    "body": "    pub fn from_u64(mut value: u64) -> Self {\n        let mut bits = Vec::new();\n        \n        if value == 0 {\n            bits.push(false);\n        } else {\n            while value > 0 {\n                bits.push(value & 1 == 1);\n                value >>= 1;\n            }\n        }\n        \n        BigNum { bits }\n    }",
    "display_name": "from_u64",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/Display/fmt",
    "statement_type": "function",
    "deps": [],
    "body": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        // Simple binary representation (MSB first for display)\n        let binary: String = self.bits.iter().rev().map(|&b| if b { '1' } else { '0' }).collect();\n        write!(f, \"0b{}\", binary)\n    }",
    "display_name": "fmt",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/addition/tests/test_add_different_lengths",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/to_u64",
      "bn/addition/impl/BigNum/add",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_add_different_lengths() {\n        let a = BigNum::from_u64(255); // 11111111\n        let b = BigNum::from_u64(1);   // 00000001\n        let result = a.add(&b);\n        assert_eq!(result.to_u64(), 256); // 100000000\n    }",
    "display_name": "test_add_different_lengths",
    "full_path": "file:///work/3001/src/bn/addition.rs",
    "relative_path": "src/bn/addition.rs",
    "file_name": "addition.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/tests/test_div_and_modulo",
    "statement_type": "function",
    "deps": [
      "bn/division/impl/BigNum/modulo",
      "bn/bn/impl/BigNum/from_u64",
      "bn/division/impl/BigNum/div",
      "bn/bn/impl/BigNum/to_u64"
    ],
    "body": "    fn test_div_and_modulo() {\n        let a = BigNum::from_u64(25);\n        let b = BigNum::from_u64(7);\n        \n        let quotient = a.div(&b);\n        let remainder = a.modulo(&b);\n        \n        assert_eq!(quotient.to_u64(), 3);\n        assert_eq!(remainder.to_u64(), 4);\n    }",
    "display_name": "test_div_and_modulo",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "main",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/is_zero",
      "bn/subtraction/impl/BigNum/subtract",
      "bn/bn/impl/BigNum/cmp",
      "bn/bn/impl/BigNum/from_u64",
      "bn/division/impl/BigNum/modulo",
      "bn/multiplication/impl/BigNum/multiply",
      "bn/division/impl/BigNum/div",
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/shr",
      "bn/addition/impl/BigNum/add",
      "bn/division/impl/BigNum/divide",
      "bn/bn/impl/BigNum/shl"
    ],
    "body": "fn main() {\n    println!(\"BigNum Operations Demo\");\n    println!(\"=====================\");\n    \n    // Create some BigNums for testing\n    let a = BigNum::from_u64(42);\n    let b = BigNum::from_u64(58);\n    \n    println!(\"a = {} (decimal: {})\", a, a.to_u64());\n    println!(\"b = {} (decimal: {})\", b, b.to_u64());\n    println!();\n    \n    // Addition Demo\n    println!(\"Addition:\");\n    println!(\"---------\");\n    let add_result = a.add(&b);\n    println!(\"a + b = {} (decimal: {})\", add_result, add_result.to_u64());\n    \n    // Test carry propagation\n    let carry1 = BigNum::from_u64(15); // 1111\n    let carry2 = BigNum::from_u64(1);  // 0001\n    let carry_result = carry1.add(&carry2);\n    println!(\"{} + {} = {} (decimal: {})\",\n             carry1, carry2, carry_result, carry_result.to_u64());\n    println!();\n    \n    // Subtraction Demo\n    println!(\"Subtraction:\");\n    println!(\"------------\");\n    let sub_result = b.subtract(&a);\n    println!(\"b - a = {} (decimal: {})\", sub_result, sub_result.to_u64());\n    \n    let large_sub1 = BigNum::from_u64(100);\n    let large_sub2 = BigNum::from_u64(37);\n    let large_sub_result = large_sub1.subtract(&large_sub2);\n    println!(\"{} - {} = {} (decimal: {})\",\n             large_sub1, large_sub2, large_sub_result, large_sub_result.to_u64());\n    println!();\n    \n    // Multiplication Demo\n    println!(\"Multiplication:\");\n    println!(\"---------------\");\n    let m1 = BigNum::from_u64(7);\n    let m2 = BigNum::from_u64(6);\n    let mul_result1 = m1.multiply(&m2);\n    println!(\"{} * {} = {} (decimal: {})\", m1, m2, mul_result1, mul_result1.to_u64());\n\n    let m3 = BigNum::from_u64(12);\n    let m4 = BigNum::from_u64(15);\n    let mul_result2 = m3.multiply(&m4);\n    println!(\"{} * {} = {} (decimal: {})\", m3, m4, mul_result2, mul_result2.to_u64());\n\n    // Test multiplication resulting in a larger number\n    let m5 = BigNum::from_u64(100);\n    let m6 = BigNum::from_u64(100);\n    let mul_result3 = m5.multiply(&m6);\n    println!(\"{} * {} = {} (decimal: {})\", m5, m6, mul_result3, mul_result3.to_u64());\n    println!();\n    \n    // Division Demo\n    println!(\"Division:\");\n    println!(\"---------\");\n    let div1 = BigNum::from_u64(100);\n    let div2 = BigNum::from_u64(7);\n    let (quotient1, remainder1) = div1.divide(&div2);\n    println!(\"{} รท {} = {} remainder {} (decimal: {} remainder {})\",\n             div1, div2, quotient1, remainder1, quotient1.to_u64(), remainder1.to_u64());\n    \n    let div3 = BigNum::from_u64(256);\n    let div4 = BigNum::from_u64(16);\n    let (quotient2, remainder2) = div3.divide(&div4);\n    println!(\"{} รท {} = {} remainder {} (decimal: {} remainder {})\",\n             div3, div4, quotient2, remainder2, quotient2.to_u64(), remainder2.to_u64());\n    \n    // Test convenience methods\n    let div_only = div1.div(&div2);\n    let mod_only = div1.modulo(&div2);\n    println!(\"Using convenience methods: {} รท {} = {}, {} mod {} = {}\",\n             div1, div2, div_only.to_u64(), div1, div2, mod_only.to_u64());\n    println!();\n    \n    // Bit shift operations\n    println!(\"Bit Shift Operations:\");\n    println!(\"--------------------\");\n    let shift_num = BigNum::from_u64(5); // 101 in binary\n    println!(\"Original: {} (decimal: {})\", shift_num, shift_num.to_u64());\n    \n    let left_shifted = shift_num.shl(2);\n    println!(\"Left shift by 2:  {} (decimal: {})\", left_shifted, left_shifted.to_u64());\n    \n    let right_shifted = left_shifted.shr(1);\n    println!(\"Right shift by 1: {} (decimal: {})\", right_shifted, right_shifted.to_u64());\n    println!();\n    \n    // Comparison operations\n    println!(\"Comparison Operations:\");\n    println!(\"---------------------\");\n    let comp1 = BigNum::from_u64(42);\n    let comp2 = BigNum::from_u64(37);\n    let comp3 = BigNum::from_u64(42);\n    \n    use std::cmp::Ordering;\n    match comp1.cmp(&comp2) {\n        Ordering::Greater => println!(\"{} > {}\", comp1, comp2),\n        Ordering::Less => println!(\"{} < {}\", comp1, comp2),\n        Ordering::Equal => println!(\"{} = {}\", comp1, comp2),\n    }\n    \n    match comp1.cmp(&comp3) {\n        Ordering::Greater => println!(\"{} > {}\", comp1, comp3),\n        Ordering::Less => println!(\"{} < {}\", comp1, comp3),\n        Ordering::Equal => println!(\"{} = {}\", comp1, comp3),\n    }\n    println!();\n    \n    // Edge cases\n    println!(\"Edge Cases:\");\n    println!(\"-----------\");\n    let zero = BigNum::from_u64(0);\n    let one = BigNum::from_u64(1);\n    \n    println!(\"Zero test: {} (is_zero: {})\", zero, zero.is_zero());\n    println!(\"One test: {} (is_zero: {})\", one, one.is_zero());\n    \n    let zero_add = zero.add(&BigNum::from_u64(42));\n    println!(\"0 + 42 = {} (decimal: {})\", zero_add, zero_add.to_u64());\n    \n    let zero_mul = zero.multiply(&BigNum::from_u64(42));\n    println!(\"0 * 42 = {} (decimal: {})\", zero_mul, zero_mul.to_u64());\n    \n    let div_by_one = BigNum::from_u64(123).div(&one);\n    println!(\"123 รท 1 = {} (decimal: {})\", div_by_one, div_by_one.to_u64());\n    \n    println!();\n    println!(\"Demo completed successfully!\");\n}",
    "display_name": "main",
    "full_path": "file:///work/3001/src/main.rs",
    "relative_path": "src/main.rs",
    "file_name": "main.rs",
    "parent_folder": "src"
  },
  {
    "identifier": "bn/multiplication/impl/BigNum/multiply",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/from_u64",
      "bn/bn/impl/BigNum/normalize",
      "bn/bn/impl/BigNum/is_zero"
    ],
    "body": "    pub fn multiply(&self, other: &BigNum) -> BigNum {\n        // Handle zero cases\n        if self.is_zero() || other.is_zero() {\n            return BigNum::from_u64(0);\n        }\n        \n        // Initialize result with zeros\n        let result_len = self.bits.len() + other.bits.len();\n        let mut result = vec![false; result_len];\n        \n        // Grade-school multiplication algorithm\n        for i in 0..self.bits.len() {\n            if self.bits[i] {\n                let mut carry = false;\n                \n                for j in 0..other.bits.len() {\n                    let pos = i + j;\n                    if pos >= result.len() { break; }\n                    \n                    let a = result[pos];\n                    let b = other.bits[j];\n                    \n                    // Add with carry\n                    let sum = a ^ b ^ carry;\n                    let new_carry = (a & b) | (carry & (a ^ b));\n                    \n                    result[pos] = sum;\n                    carry = new_carry;\n                }\n                \n                // Propagate final carry\n                let mut pos = i + other.bits.len();\n                while carry && pos < result.len() {\n                    let sum = result[pos] ^ carry;\n                    carry = result[pos] & carry;\n                    result[pos] = sum;\n                    pos += 1;\n                }\n            }\n        }\n        \n        let mut bn = BigNum { bits: result };\n        bn.normalize();\n        bn\n    }",
    "display_name": "multiply",
    "full_path": "file:///work/3001/src/bn/multiplication.rs",
    "relative_path": "src/bn/multiplication.rs",
    "file_name": "multiplication.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/addition/impl/BigNum/add",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/normalize"
    ],
    "body": "    pub fn add(&self, other: &BigNum) -> BigNum {\n        let max_len = self.bits.len().max(other.bits.len());\n        let mut result = Vec::with_capacity(max_len + 1);\n        let mut carry = false;\n        \n        for i in 0..max_len {\n            let a = self.bits.get(i).copied().unwrap_or(false);\n            let b = other.bits.get(i).copied().unwrap_or(false);\n            \n            // Full adder logic\n            let sum = a ^ b ^ carry;\n            let new_carry = (a & b) | (carry & (a ^ b));\n            \n            result.push(sum);\n            carry = new_carry;\n        }\n        \n        // Add final carry if needed\n        if carry {\n            result.push(true);\n        }\n        \n        let mut bn = BigNum { bits: result };\n        bn.normalize();\n        bn\n    }",
    "display_name": "add",
    "full_path": "file:///work/3001/src/bn/addition.rs",
    "relative_path": "src/bn/addition.rs",
    "file_name": "addition.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/tests/test_divide_simple",
    "statement_type": "function",
    "deps": [
      "bn/division/impl/BigNum/divide",
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    fn test_divide_simple() {\n        let a = BigNum::from_u64(15);\n        let b = BigNum::from_u64(3);\n        let (quotient, remainder) = a.divide(&b);\n        assert_eq!(quotient.to_u64(), 5);\n        assert_eq!(remainder.to_u64(), 0);\n    }",
    "display_name": "test_divide_simple",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/impl/BigNum/shr",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/Clone/clone",
      "bn/bn/impl/BigNum/normalize",
      "bn/bn/impl/BigNum/is_zero",
      "bn/bn/impl/BigNum/from_u64"
    ],
    "body": "    pub fn shr(&self, n: usize) -> BigNum {\n        if self.is_zero() || n == 0 {\n            return self.clone();\n        }\n        \n        if n >= self.bits.len() {\n            return BigNum::from_u64(0);\n        }\n        \n        let result = self.bits[n..].to_vec();\n        if result.is_empty() {\n            return BigNum::from_u64(0);\n        }\n        \n        let mut bn = BigNum { bits: result };\n        bn.normalize();\n        bn\n    }",
    "display_name": "shr",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/bn/tests/test_shl",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/to_u64",
      "bn/bn/impl/BigNum/from_u64",
      "bn/bn/impl/BigNum/shl"
    ],
    "body": "    fn test_shl() {\n        let a = BigNum::from_u64(5); // 101\n        let result = a.shl(2);       // Should be 10100 = 20\n        assert_eq!(result.to_u64(), 20);\n    }",
    "display_name": "test_shl",
    "full_path": "file:///work/3001/src/bn/bn.rs",
    "relative_path": "src/bn/bn.rs",
    "file_name": "bn.rs",
    "parent_folder": "bn"
  },
  {
    "identifier": "bn/division/tests/test_divide_by_one",
    "statement_type": "function",
    "deps": [
      "bn/bn/impl/BigNum/from_u64",
      "bn/division/impl/BigNum/divide",
      "bn/bn/impl/BigNum/to_u64"
    ],
    "body": "    fn test_divide_by_one() {\n        let a = BigNum::from_u64(123);\n        let b = BigNum::from_u64(1);\n        let (quotient, remainder) = a.divide(&b);\n        assert_eq!(quotient.to_u64(), 123);\n        assert_eq!(remainder.to_u64(), 0);\n    }",
    "display_name": "test_divide_by_one",
    "full_path": "file:///work/3001/src/bn/division.rs",
    "relative_path": "src/bn/division.rs",
    "file_name": "division.rs",
    "parent_folder": "bn"
  }
]