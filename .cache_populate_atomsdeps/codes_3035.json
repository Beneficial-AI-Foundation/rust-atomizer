{
  "38741": {
    "text": "use vstd::prelude::*;\nuse vstd::calc;\n\nverus! {\n\n    fn main() {\n    }\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    // All characters must be '0' or '1'\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str_to_int(s: Seq<char>) -> nat\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let sub_seq = s.subrange(0, s.len() as int - 1);\n        let last_char = s[s.len() as int - 1];\n        2 * str_to_int(sub_seq) + \n        (if last_char == '1' { 1nat } else { 0nat })\n    }\n}\n\nproof fn str_to_int_empty(s: Seq<char>)\n    requires\n        s.len() == 0,\n    ensures\n        str_to_int(s) == 0nat,\n{\n}\nproof fn str_to_int_nonempty(s: Seq<char>)\n    requires\n        s.len() > 0,\n    ensures\n        str_to_int(s) == 2 * str_to_int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat }),\n{\n}\n\nproof fn str_to_int_of_zero(s: Seq<char>)\n    requires\n        s == seq![('0')],\n    ensures\n        str_to_int(s) == 0nat,\n{\n    let sub_seq = s.subrange(0, s.len() as int - 1);\n    assert(str_to_int(s) == 2 * str_to_int(sub_seq) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat }));\n}\n\nproof fn str_to_int_of_one(s: Seq<char>)\n    requires\n        s == seq![('1')],\n    ensures\n        str_to_int(s) == 1nat,\n{\n    let sub_seq = s.subrange(0, s.len() as int - 1);\n    assert(str_to_int(s) == 2 * str_to_int(sub_seq) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat }));\n    assert(sub_seq.len() == 0);\n    str_to_int_empty(sub_seq);\n    assert(str_to_int(sub_seq) == 0nat);\n    assert(str_to_int(s) == 2 * 0nat + 1nat);\n}\n\nproof fn str_to_int_extensionality(s1: Seq<char>, s2: Seq<char>)\n    requires\n        s1 =~= s2,\n    ensures\n        str_to_int(s1) == str_to_int(s2),\n    decreases s1.len()\n{\n    if s1.len() == 0 {\n        assert(s2.len() == 0);\n        assert(str_to_int(s1) == 0nat);\n        assert(str_to_int(s2) == 0nat);\n    } else {\n        let sub_s1 = s1.subrange(0, s1.len() as int - 1);\n        let sub_s2 = s2.subrange(0, s2.len() as int - 1);\n        assert(sub_s1 =~= sub_s2);\n        str_to_int_extensionality(sub_s1, sub_s2);\n        assert(s1[s1.len() as int - 1] == s2[s2.len() as int - 1]);\n    }\n}\n\nproof fn str_to_int_push(s: Seq<char>, c: char)\n    requires\n        c == '0' || c == '1',\n    ensures\n        str_to_int(s.push(c)) == 2 * str_to_int(s) + (if c == '1' { 1nat } else { 0nat }),\n{\n    let result = s.push(c);\n    assert(result.subrange(0, result.len() as int - 1) =~= s);\n    str_to_int_extensionality(result.subrange(0, result.len() as int - 1), s);\n}\n\nproof fn ignore_initial_zeros(s: Seq<char>, num_zeros: int)\n    requires\n        //valid_bit_string(s),\n        0 <= num_zeros <= s.len(),\n        forall|i: int| 0 <= i < num_zeros ==> s[i] == '0',\n    ensures str_to_int(s) == str_to_int(s.subrange(num_zeros, s.len() as int)),\n    decreases s.len(),\n{\n    if num_zeros == 0 {\n        assert(s.subrange(0, s.len() as int) =~= s);\n        return;\n    }\n    if num_zeros == s.len() {\n        assert(str_to_int(s) == (2 * str_to_int(s.subrange(0, s.len() - 1))));\n        ignore_initial_zeros(s.subrange(0, s.len() - 1), num_zeros - 1);\n        return;\n    }\n\n    // Recursive case: strip one character from the end\n    ignore_initial_zeros(s.drop_last(), num_zeros);\n    let t = s.subrange(num_zeros, s.len() as int);\n\n    calc! {\n        (==)\n        str_to_int(s); {\n        }\n        2 * str_to_int(s.drop_last()) +\n        (if s.last() == '1' { 1nat } else { 0nat }); {\n            ignore_initial_zeros(s.drop_last(), num_zeros);\n        }\n        2 * str_to_int(s.drop_last().subrange(num_zeros, s.drop_last().len() as int)) +\n        (if s.last() == '1' { 1nat } else { 0nat }); {\n            // Extra extensionality assertion\n            assert(s.drop_last().subrange(num_zeros, s.drop_last().len() as int) == s.subrange(num_zeros, s.len() - 1));\n        }\n        2 * str_to_int(s.subrange(num_zeros, s.len() - 1)) +\n        (if s.last() == '1' { 1nat } else { 0nat }); {\n            assert(t.drop_last() =~= s.subrange(num_zeros, s.len() as int - 1));\n        }\n        2 * str_to_int(t.drop_last()) +\n        (if t[t.len() - 1] == '1' { 1nat } else { 0nat }); {\n        }\n        str_to_int(t);\n    }\n}\n\nproof fn all_zeros_value(s: Seq<char>)\n    requires\n        forall|j: int| 0 <= j < s.len() ==> s[j] == '0',\n    ensures str_to_int(s) == 0nat,\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        // Base case\n    } else {\n        // Recursive case\n        assert(s[s.len() as int - 1] == '0');\n        assert(str_to_int(s) == 2 * str_to_int(s.subrange(0, s.len() as int - 1)) + 0nat);\n        all_zeros_value(s.subrange(0, s.len() as int - 1));\n        assert(str_to_int(s.subrange(0, s.len() as int - 1)) == 0nat);\n        assert(str_to_int(s) == 0nat);\n    }\n}\n\nspec fn find_first_nonzero(s: Seq<char>, start: nat) -> nat\n    recommends 0 <= start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        s.len()\n    } else if s[start as int] != '0' {\n        start\n    } else {\n        find_first_nonzero(s, start + 1)\n    }\n}\n\nproof fn find_first_nonzero_in_bounds(s: Seq<char>, start: nat)\n    requires\n        valid_bit_string(s),\n        start <= s.len(),\n    ensures\n        find_first_nonzero(s, start) <= s.len(),\n        start <= find_first_nonzero(s, start),\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        assert(find_first_nonzero(s, start) == s.len());\n    } else if s[start as int] != '0' {\n        assert(find_first_nonzero(s, start) == start);\n    } else {\n        // If we haven't found a non-zero, we look at the next position\n        assert(s[start as int] == '0');\n        // Recursive case\n        find_first_nonzero_in_bounds(s, start + 1);\n        assert(find_first_nonzero(s, start) == find_first_nonzero(s, start + 1));\n    }\n}\n\nproof fn find_first_nonzero_all_zeros_before(s: Seq<char>, start: nat)\n    requires\n        valid_bit_string(s),\n        start <= s.len(),\n    ensures\n        forall|k: int| start <= k < find_first_nonzero(s, start) ==> s[k] == '0',\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        assert(find_first_nonzero(s, start) == s.len());\n    } else if s[start as int] != '0' {\n        assert(find_first_nonzero(s, start) == start);\n    } else {\n        assert(s[start as int] == '0');\n        find_first_nonzero_all_zeros_before(s, start + 1);\n        assert(find_first_nonzero(s, start) == find_first_nonzero(s, start + 1));\n        assert forall|k: int| start <= k < find_first_nonzero(s, start) implies s[k] == '0' by {\n            if k == start {\n                assert(s[k] == '0');\n            } else {\n                assert(start + 1 <= k < find_first_nonzero(s, start + 1));\n            }\n        }\n    }\n}\n\nspec fn normalize_bit_string(s: Seq<char>) -> (result: Seq<char>)   \n{\n    if s.len() == 0 || !valid_bit_string(s) {\n        seq![('0')]\n    } else {\n        let i = find_first_nonzero(s, 0);\n        if i == s.len() {\n            seq![('0')]\n        } else {\n            s.subrange(i as int, s.len() as int)\n        }\n    }\n}\n\nproof fn normalize_bit_string_valid(s: Seq<char>)\n    requires\n        valid_bit_string(s),\n    ensures\n        valid_bit_string(normalize_bit_string(s)),\n        normalize_bit_string(s).len() > 0,\n        //normalize_bit_string(s).len() > 1 ==> normalize_bit_string(s)[0] != '0',\n        str_to_int(s) == str_to_int(normalize_bit_string(s)),\n{\n    let result = normalize_bit_string(s);\n    \n    if s.len() == 0 {\n        // Case: empty input\n        assert(result == seq![('0')]);\n        assert forall|i: int| 0 <= i < result.len() implies (result[i] == '0' || result[i] == '1') by {\n            assert(result.len() == 1);\n            assert(result[0] == '0');\n        }\n        assert(str_to_int(s) == 0nat);\n        assert(result == seq![('0')]);\n        str_to_int_of_zero(seq![('0')]);\n        assert(str_to_int(seq![('0')]) == 0nat);\n        assert(str_to_int(result) == 0nat);\n        assert(str_to_int(s) == str_to_int(result));\n    } else {\n        let i = find_first_nonzero(s, 0);\n        // Prove i is in bounds\n        find_first_nonzero_in_bounds(s, 0);\n        assert(0 <= i <= s.len());\n\n        if i == s.len() {\n            // Case: all zeros\n            assert(result == seq![('0')]);\n            str_to_int_of_zero(seq![('0')]);\n            assert(str_to_int(result) == 0nat);\n            assert(valid_bit_string(s));\n            find_first_nonzero_all_zeros_before(s, 0);\n            assert forall|j: int| 0 <= j < s.len() implies s[j] == '0' by {\n                assert(i == s.len());\n                assert(forall|k: int| 0 <= k < i ==> s[k] == '0');\n            }\n            all_zeros_value(s);\n            assert(str_to_int(s) == 0nat);\n            assert(str_to_int(s) == str_to_int(result));\n        } else {\n            // Case: substring from first non-zero\n            let substring = s.subrange(i as int, s.len() as int);\n            assert(result == substring);\n            \n            // Prove that substring length is valid\n            assert(0 <= i);\n            assert(i <= s.len());\n            assert(substring.len() == s.len() as int - i as int) by {\n                // This should now be provable since we know i is in bounds\n            };\n            \n            // Prove substring is valid_bit_string\n            assert forall|j: int| 0 <= j < substring.len() implies (substring[j] == '0' || substring[j] == '1') by {\n                assert(valid_bit_string(s));\n                let k = j + i as int;\n                assert(0 <= k < s.len()) by {\n                    assert(0 <= j < substring.len());\n                    assert(k < s.len());\n                };\n                assert(s[k] == '0' || s[k] == '1');\n                assert(substring[j] == s[k]);\n            }\n            \n            // Prove value preservation\n            find_first_nonzero_all_zeros_before(s, 0);\n            assert(forall|k: int| 0 <= k < i ==> s[k] == '0');\n            ignore_initial_zeros(s, i as int);\n            assert(str_to_int(s) == str_to_int(substring));\n            assert(str_to_int(s) == str_to_int(result));\n        }\n    }\n}\n\nspec fn add_helper(s1: Seq<char>, s2: Seq<char>, carry: nat) -> (result: Seq<char>)\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        if carry == 0 {\n            seq![('0')]\n        } else {\n            seq![('1')]\n        }\n    } else {\n        let bit1: nat = if s1.len() > 0 && s1[s1.len() as int - 1] == '1' { 1nat } else { 0nat };\n        let rest1: Seq<char> = if s1.len() > 0 { s1.subrange(0, s1.len() as int - 1) } else { seq![] };\n        \n        let bit2: nat = if s2.len() > 0 && s2[s2.len() as int - 1] == '1' { 1nat } else { 0nat };\n        let rest2: Seq<char> = if s2.len() > 0 { s2.subrange(0, s2.len() as int - 1) } else { seq![] };\n        \n        let sum: nat = bit1 + bit2 + carry;\n        let new_bit: char = if sum % 2nat == 1nat { '1' } else { '0' };\n        let new_carry: nat = sum / 2nat;\n        \n        add_helper(rest1, rest2, new_carry).push(new_bit)\n    }    \n}\n\n\nproof fn add_helper_correctness(s1: Seq<char>, s2: Seq<char>, carry: nat)\n    requires\n        valid_bit_string(s1),\n        valid_bit_string(s2),\n        carry <= 1,\n    ensures\n        valid_bit_string(add_helper(s1, s2, carry)),\n        str_to_int(add_helper(s1, s2, carry)) == str_to_int(s1) + str_to_int(s2) + carry,\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        // Base case: both strings are empty\n        if carry == 0 {\n            str_to_int_of_zero(seq![('0')]);\n            assert(str_to_int(s1) == 0nat);\n            assert(str_to_int(s2) == 0nat);\n            assert(add_helper(s1, s2, carry) =~= seq![('0')]);\n            assert(str_to_int(add_helper(s1, s2, carry)) == str_to_int(s1) + str_to_int(s2) + carry);\n        } else {\n            assert(str_to_int(s1) == 0nat);\n            assert(str_to_int(s2) == 0nat);\n            assert(add_helper(s1, s2, carry) =~= seq![('1')]);\n            str_to_int_of_one(seq![('1')]);\n            assert(str_to_int(seq![('1')]) == 1nat);\n            assert(str_to_int(add_helper(s1, s2, carry)) == str_to_int(s1) + str_to_int(s2) + carry);\n        }\n    } else {\n        // Recursive case\n        let bit1: nat = if s1.len() > 0 && s1[s1.len() as int - 1] == '1' { 1nat } else { 0nat };\n        let rest1: Seq<char> = if s1.len() > 0 { s1.subrange(0, s1.len() as int - 1) } else { seq![] };\n        \n        let bit2: nat = if s2.len() > 0 && s2[s2.len() as int - 1] == '1' { 1nat } else { 0nat };\n        let rest2: Seq<char> = if s2.len() > 0 { s2.subrange(0, s2.len() as int - 1) } else { seq![] };\n        \n        let sum: nat = bit1 + bit2 + carry;\n        let new_bit: char = if sum % 2nat == 1nat { '1' } else { '0' };\n        let new_carry: nat = sum / 2nat;\n        \n        // Prove that rest1 and rest2 are valid bit strings\n        assert forall|i: int| 0 <= i < rest1.len() implies (rest1[i] == '0' || rest1[i] == '1') by {\n            assert(valid_bit_string(s1));\n            assert(rest1[i] == s1[i]);\n        }\n        assert forall|i: int| 0 <= i < rest2.len() implies (rest2[i] == '0' || rest2[i] == '1') by {\n            assert(valid_bit_string(s2));\n            assert(rest2[i] == s2[i]);\n        }\n        \n        // Recursive call\n        add_helper_correctness(rest1, rest2, new_carry);\n        \n        // Prove the result is a valid bit string\n        let result = add_helper(s1, s2, carry);\n        assert(result =~= add_helper(rest1, rest2, new_carry).push(new_bit));\n        assert(valid_bit_string(add_helper(rest1, rest2, new_carry)));\n        assert(new_bit == '0' || new_bit == '1');\n        assert(valid_bit_string(result));\n        \n        // Prove value preservation\n        calc! {\n            (==)\n            str_to_int(result); {\n                assert(result =~= add_helper(rest1, rest2, new_carry).push(new_bit));\n                str_to_int_extensionality(result, add_helper(rest1, rest2, new_carry).push(new_bit));\n            }\n            str_to_int(add_helper(rest1, rest2, new_carry).push(new_bit)); {\n                str_to_int_push(add_helper(rest1, rest2, new_carry), new_bit);\n            }\n            2 * str_to_int(add_helper(rest1, rest2, new_carry)) + (if new_bit == '1' { 1nat } else { 0nat }); {\n                add_helper_correctness(rest1, rest2, new_carry);\n            }\n            2 * (str_to_int(rest1) + str_to_int(rest2) + new_carry) + (if new_bit == '1' { 1nat } else { 0nat }); {\n                assert(2 * new_carry + (if new_bit == '1' { 1nat } else { 0nat }) == sum);\n            }\n            2 * (str_to_int(rest1) + str_to_int(rest2)) + sum; {\n                assert(sum == bit1 + bit2 + carry);\n            }\n            2 * (str_to_int(rest1) + str_to_int(rest2)) + bit1 + bit2 + carry; {\n                assert(str_to_int(s1) == 2 * str_to_int(rest1) + bit1);\n                assert(str_to_int(s2) == 2 * str_to_int(rest2) + bit2);\n            }\n            str_to_int(s1) + str_to_int(s2) + carry;\n        }\n    }\n}\n\n\nproof fn add(s1: Seq<char>, s2: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_bit_string(s1),\n        valid_bit_string(s2),\n    ensures\n        valid_bit_string(result),\n        str_to_int(result) == str_to_int(s1) + str_to_int(s2),\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        let result = seq![('0')];\n        assert forall|i: int| 0 <= i < result.len() implies (result[i] == '0' || result[i] == '1') by {\n            assert(result.len() == 1);\n            assert(result[0] == '0');\n        }\n        add_helper_correctness(s1, s2, 0nat);\n        assert(str_to_int(result) == str_to_int(s1) + str_to_int(s2));\n        result\n    } else if s1.len() == 0 {\n        // When s1 is empty, its value is 0, so we can just return s2\n        // (normalized to ensure no leading zeros)\n        normalize_bit_string_valid(s2);\n        let result = normalize_bit_string(s2);\n        //add_helper_correctness(s1, s2, 0nat);\n        assert(str_to_int(result) == str_to_int(s1) + str_to_int(s2)); \n        result\n    } else if s2.len() == 0 {\n        // When s2 is empty, its value is 0, so we can just return s1\n        // (normalized to ensure no leading zeros)\n        normalize_bit_string_valid(s1);\n        let result = normalize_bit_string(s1);\n        assert(str_to_int(result) == str_to_int(s1) + str_to_int(s2)); \n        result\n    } else {\n        // Perform addition using helper function and normalize the result\n        let intermediate = add_helper(s1, s2, 0nat);\n        add_helper_correctness(s1, s2, 0nat);\n        //assert(valid_bit_string(intermediate)); // From add_helper ensures        \n        normalize_bit_string_valid(intermediate);\n        let result = normalize_bit_string(intermediate);\n        //add_helper_correctness(s1, s2, 0nat);\n        assert(str_to_int(result) == str_to_int(s1) + str_to_int(s2)); \n        result\n    }\n}\n}",
    "filename": "bn_add_seq.rs",
    "filepath": null,
    "folder_id": null,
    "user_id": 460176
  },
  "38742": {
    "text": "pub mod bn_add_seq; ",
    "filename": "src/lib.rs",
    "filepath": null,
    "folder_id": 8941,
    "user_id": 460176
  },
  "38743": {
    "text": "use vstd::prelude::*;\nuse vstd::calc;\n\nverus! {\n\n    fn main() {\n    }\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    // All characters must be '0' or '1'\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str_to_int(s: Seq<char>) -> nat\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let sub_seq = s.subrange(0, s.len() as int - 1);\n        let last_char = s[s.len() as int - 1];\n        2 * str_to_int(sub_seq) + \n        (if last_char == '1' { 1nat } else { 0nat })\n    }\n}\n\nproof fn str_to_int_empty(s: Seq<char>)\n    requires\n        s.len() == 0,\n    ensures\n        str_to_int(s) == 0nat,\n{\n}\nproof fn str_to_int_nonempty(s: Seq<char>)\n    requires\n        s.len() > 0,\n    ensures\n        str_to_int(s) == 2 * str_to_int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat }),\n{\n}\n\nproof fn str_to_int_of_zero(s: Seq<char>)\n    requires\n        s == seq![('0')],\n    ensures\n        str_to_int(s) == 0nat,\n{\n    let sub_seq = s.subrange(0, s.len() as int - 1);\n    assert(str_to_int(s) == 2 * str_to_int(sub_seq) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat }));\n}\n\nproof fn str_to_int_of_one(s: Seq<char>)\n    requires\n        s == seq![('1')],\n    ensures\n        str_to_int(s) == 1nat,\n{\n    let sub_seq = s.subrange(0, s.len() as int - 1);\n    assert(str_to_int(s) == 2 * str_to_int(sub_seq) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat }));\n    assert(sub_seq.len() == 0);\n    str_to_int_empty(sub_seq);\n    assert(str_to_int(sub_seq) == 0nat);\n    assert(str_to_int(s) == 2 * 0nat + 1nat);\n}\n\nproof fn str_to_int_extensionality(s1: Seq<char>, s2: Seq<char>)\n    requires\n        s1 =~= s2,\n    ensures\n        str_to_int(s1) == str_to_int(s2),\n    decreases s1.len()\n{\n    if s1.len() == 0 {\n        assert(s2.len() == 0);\n        assert(str_to_int(s1) == 0nat);\n        assert(str_to_int(s2) == 0nat);\n    } else {\n        let sub_s1 = s1.subrange(0, s1.len() as int - 1);\n        let sub_s2 = s2.subrange(0, s2.len() as int - 1);\n        assert(sub_s1 =~= sub_s2);\n        str_to_int_extensionality(sub_s1, sub_s2);\n        assert(s1[s1.len() as int - 1] == s2[s2.len() as int - 1]);\n    }\n}\n\nproof fn str_to_int_push(s: Seq<char>, c: char)\n    requires\n        c == '0' || c == '1',\n    ensures\n        str_to_int(s.push(c)) == 2 * str_to_int(s) + (if c == '1' { 1nat } else { 0nat }),\n{\n    let result = s.push(c);\n    assert(result.subrange(0, result.len() as int - 1) =~= s);\n    str_to_int_extensionality(result.subrange(0, result.len() as int - 1), s);\n}\n\nproof fn ignore_initial_zeros(s: Seq<char>, num_zeros: int)\n    requires\n        //valid_bit_string(s),\n        0 <= num_zeros <= s.len(),\n        forall|i: int| 0 <= i < num_zeros ==> s[i] == '0',\n    ensures str_to_int(s) == str_to_int(s.subrange(num_zeros, s.len() as int)),\n    decreases s.len(),\n{\n    if num_zeros == 0 {\n        assert(s.subrange(0, s.len() as int) =~= s);\n        return;\n    }\n    if num_zeros == s.len() {\n        assert(str_to_int(s) == (2 * str_to_int(s.subrange(0, s.len() - 1))));\n        ignore_initial_zeros(s.subrange(0, s.len() - 1), num_zeros - 1);\n        return;\n    }\n\n    // Recursive case: strip one character from the end\n    ignore_initial_zeros(s.drop_last(), num_zeros);\n    let t = s.subrange(num_zeros, s.len() as int);\n\n    calc! {\n        (==)\n        str_to_int(s); {\n        }\n        2 * str_to_int(s.drop_last()) +\n        (if s.last() == '1' { 1nat } else { 0nat }); {\n            ignore_initial_zeros(s.drop_last(), num_zeros);\n        }\n        2 * str_to_int(s.drop_last().subrange(num_zeros, s.drop_last().len() as int)) +\n        (if s.last() == '1' { 1nat } else { 0nat }); {\n            // Extra extensionality assertion\n            assert(s.drop_last().subrange(num_zeros, s.drop_last().len() as int) == s.subrange(num_zeros, s.len() - 1));\n        }\n        2 * str_to_int(s.subrange(num_zeros, s.len() - 1)) +\n        (if s.last() == '1' { 1nat } else { 0nat }); {\n            assert(t.drop_last() =~= s.subrange(num_zeros, s.len() as int - 1));\n        }\n        2 * str_to_int(t.drop_last()) +\n        (if t[t.len() - 1] == '1' { 1nat } else { 0nat }); {\n        }\n        str_to_int(t);\n    }\n}\n\nproof fn all_zeros_value(s: Seq<char>)\n    requires\n        forall|j: int| 0 <= j < s.len() ==> s[j] == '0',\n    ensures str_to_int(s) == 0nat,\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        // Base case\n    } else {\n        // Recursive case\n        assert(s[s.len() as int - 1] == '0');\n        assert(str_to_int(s) == 2 * str_to_int(s.subrange(0, s.len() as int - 1)) + 0nat);\n        all_zeros_value(s.subrange(0, s.len() as int - 1));\n        assert(str_to_int(s.subrange(0, s.len() as int - 1)) == 0nat);\n        assert(str_to_int(s) == 0nat);\n    }\n}\n\nspec fn find_first_nonzero(s: Seq<char>, start: nat) -> nat\n    recommends 0 <= start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        s.len()\n    } else if s[start as int] != '0' {\n        start\n    } else {\n        find_first_nonzero(s, start + 1)\n    }\n}\n\nproof fn find_first_nonzero_in_bounds(s: Seq<char>, start: nat)\n    requires\n        valid_bit_string(s),\n        start <= s.len(),\n    ensures\n        find_first_nonzero(s, start) <= s.len(),\n        start <= find_first_nonzero(s, start),\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        assert(find_first_nonzero(s, start) == s.len());\n    } else if s[start as int] != '0' {\n        assert(find_first_nonzero(s, start) == start);\n    } else {\n        // If we haven't found a non-zero, we look at the next position\n        assert(s[start as int] == '0');\n        // Recursive case\n        find_first_nonzero_in_bounds(s, start + 1);\n        assert(find_first_nonzero(s, start) == find_first_nonzero(s, start + 1));\n    }\n}\n\nproof fn find_first_nonzero_all_zeros_before(s: Seq<char>, start: nat)\n    requires\n        valid_bit_string(s),\n        start <= s.len(),\n    ensures\n        forall|k: int| start <= k < find_first_nonzero(s, start) ==> s[k] == '0',\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        assert(find_first_nonzero(s, start) == s.len());\n    } else if s[start as int] != '0' {\n        assert(find_first_nonzero(s, start) == start);\n    } else {\n        assert(s[start as int] == '0');\n        find_first_nonzero_all_zeros_before(s, start + 1);\n        assert(find_first_nonzero(s, start) == find_first_nonzero(s, start + 1));\n        assert forall|k: int| start <= k < find_first_nonzero(s, start) implies s[k] == '0' by {\n            if k == start {\n                assert(s[k] == '0');\n            } else {\n                assert(start + 1 <= k < find_first_nonzero(s, start + 1));\n            }\n        }\n    }\n}\n\nspec fn normalize_bit_string(s: Seq<char>) -> (result: Seq<char>)   \n{\n    if s.len() == 0 || !valid_bit_string(s) {\n        seq![('0')]\n    } else {\n        let i = find_first_nonzero(s, 0);\n        if i == s.len() {\n            seq![('0')]\n        } else {\n            s.subrange(i as int, s.len() as int)\n        }\n    }\n}\n\nproof fn normalize_bit_string_valid(s: Seq<char>)\n    requires\n        valid_bit_string(s),\n    ensures\n        valid_bit_string(normalize_bit_string(s)),\n        normalize_bit_string(s).len() > 0,\n        //normalize_bit_string(s).len() > 1 ==> normalize_bit_string(s)[0] != '0',\n        str_to_int(s) == str_to_int(normalize_bit_string(s)),\n{\n    let result = normalize_bit_string(s);\n    \n    if s.len() == 0 {\n        // Case: empty input\n        assert(result == seq![('0')]);\n        assert forall|i: int| 0 <= i < result.len() implies (result[i] == '0' || result[i] == '1') by {\n            assert(result.len() == 1);\n            assert(result[0] == '0');\n        }\n        assert(str_to_int(s) == 0nat);\n        assert(result == seq![('0')]);\n        str_to_int_of_zero(seq![('0')]);\n        assert(str_to_int(seq![('0')]) == 0nat);\n        assert(str_to_int(result) == 0nat);\n        assert(str_to_int(s) == str_to_int(result));\n    } else {\n        let i = find_first_nonzero(s, 0);\n        // Prove i is in bounds\n        find_first_nonzero_in_bounds(s, 0);\n        assert(0 <= i <= s.len());\n\n        if i == s.len() {\n            // Case: all zeros\n            assert(result == seq![('0')]);\n            str_to_int_of_zero(seq![('0')]);\n            assert(str_to_int(result) == 0nat);\n            assert(valid_bit_string(s));\n            find_first_nonzero_all_zeros_before(s, 0);\n            assert forall|j: int| 0 <= j < s.len() implies s[j] == '0' by {\n                assert(i == s.len());\n                assert(forall|k: int| 0 <= k < i ==> s[k] == '0');\n            }\n            all_zeros_value(s);\n            assert(str_to_int(s) == 0nat);\n            assert(str_to_int(s) == str_to_int(result));\n        } else {\n            // Case: substring from first non-zero\n            let substring = s.subrange(i as int, s.len() as int);\n            assert(result == substring);\n            \n            // Prove that substring length is valid\n            assert(0 <= i);\n            assert(i <= s.len());\n            assert(substring.len() == s.len() as int - i as int) by {\n                // This should now be provable since we know i is in bounds\n            };\n            \n            // Prove substring is valid_bit_string\n            assert forall|j: int| 0 <= j < substring.len() implies (substring[j] == '0' || substring[j] == '1') by {\n                assert(valid_bit_string(s));\n                let k = j + i as int;\n                assert(0 <= k < s.len()) by {\n                    assert(0 <= j < substring.len());\n                    assert(k < s.len());\n                };\n                assert(s[k] == '0' || s[k] == '1');\n                assert(substring[j] == s[k]);\n            }\n            \n            // Prove value preservation\n            find_first_nonzero_all_zeros_before(s, 0);\n            assert(forall|k: int| 0 <= k < i ==> s[k] == '0');\n            ignore_initial_zeros(s, i as int);\n            assert(str_to_int(s) == str_to_int(substring));\n            assert(str_to_int(s) == str_to_int(result));\n        }\n    }\n}\n\nspec fn add_helper(s1: Seq<char>, s2: Seq<char>, carry: nat) -> (result: Seq<char>)\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        if carry == 0 {\n            seq![('0')]\n        } else {\n            seq![('1')]\n        }\n    } else {\n        let bit1: nat = if s1.len() > 0 && s1[s1.len() as int - 1] == '1' { 1nat } else { 0nat };\n        let rest1: Seq<char> = if s1.len() > 0 { s1.subrange(0, s1.len() as int - 1) } else { seq![] };\n        \n        let bit2: nat = if s2.len() > 0 && s2[s2.len() as int - 1] == '1' { 1nat } else { 0nat };\n        let rest2: Seq<char> = if s2.len() > 0 { s2.subrange(0, s2.len() as int - 1) } else { seq![] };\n        \n        let sum: nat = bit1 + bit2 + carry;\n        let new_bit: char = if sum % 2nat == 1nat { '1' } else { '0' };\n        let new_carry: nat = sum / 2nat;\n        \n        add_helper(rest1, rest2, new_carry).push(new_bit)\n    }    \n}\n\n\nproof fn add_helper_correctness(s1: Seq<char>, s2: Seq<char>, carry: nat)\n    requires\n        valid_bit_string(s1),\n        valid_bit_string(s2),\n        carry <= 1,\n    ensures\n        valid_bit_string(add_helper(s1, s2, carry)),\n        str_to_int(add_helper(s1, s2, carry)) == str_to_int(s1) + str_to_int(s2) + carry,\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        // Base case: both strings are empty\n        if carry == 0 {\n            str_to_int_of_zero(seq![('0')]);\n            assert(str_to_int(s1) == 0nat);\n            assert(str_to_int(s2) == 0nat);\n            assert(add_helper(s1, s2, carry) =~= seq![('0')]);\n            assert(str_to_int(add_helper(s1, s2, carry)) == str_to_int(s1) + str_to_int(s2) + carry);\n        } else {\n            assert(str_to_int(s1) == 0nat);\n            assert(str_to_int(s2) == 0nat);\n            assert(add_helper(s1, s2, carry) =~= seq![('1')]);\n            str_to_int_of_one(seq![('1')]);\n            assert(str_to_int(seq![('1')]) == 1nat);\n            assert(str_to_int(add_helper(s1, s2, carry)) == str_to_int(s1) + str_to_int(s2) + carry);\n        }\n    } else {\n        // Recursive case\n        let bit1: nat = if s1.len() > 0 && s1[s1.len() as int - 1] == '1' { 1nat } else { 0nat };\n        let rest1: Seq<char> = if s1.len() > 0 { s1.subrange(0, s1.len() as int - 1) } else { seq![] };\n        \n        let bit2: nat = if s2.len() > 0 && s2[s2.len() as int - 1] == '1' { 1nat } else { 0nat };\n        let rest2: Seq<char> = if s2.len() > 0 { s2.subrange(0, s2.len() as int - 1) } else { seq![] };\n        \n        let sum: nat = bit1 + bit2 + carry;\n        let new_bit: char = if sum % 2nat == 1nat { '1' } else { '0' };\n        let new_carry: nat = sum / 2nat;\n        \n        // Prove that rest1 and rest2 are valid bit strings\n        assert forall|i: int| 0 <= i < rest1.len() implies (rest1[i] == '0' || rest1[i] == '1') by {\n            assert(valid_bit_string(s1));\n            assert(rest1[i] == s1[i]);\n        }\n        assert forall|i: int| 0 <= i < rest2.len() implies (rest2[i] == '0' || rest2[i] == '1') by {\n            assert(valid_bit_string(s2));\n            assert(rest2[i] == s2[i]);\n        }\n        \n        // Recursive call\n        add_helper_correctness(rest1, rest2, new_carry);\n        \n        // Prove the result is a valid bit string\n        let result = add_helper(s1, s2, carry);\n        assert(result =~= add_helper(rest1, rest2, new_carry).push(new_bit));\n        assert(valid_bit_string(add_helper(rest1, rest2, new_carry)));\n        assert(new_bit == '0' || new_bit == '1');\n        assert(valid_bit_string(result));\n        \n        // Prove value preservation\n        calc! {\n            (==)\n            str_to_int(result); {\n                assert(result =~= add_helper(rest1, rest2, new_carry).push(new_bit));\n                str_to_int_extensionality(result, add_helper(rest1, rest2, new_carry).push(new_bit));\n            }\n            str_to_int(add_helper(rest1, rest2, new_carry).push(new_bit)); {\n                str_to_int_push(add_helper(rest1, rest2, new_carry), new_bit);\n            }\n            2 * str_to_int(add_helper(rest1, rest2, new_carry)) + (if new_bit == '1' { 1nat } else { 0nat }); {\n                add_helper_correctness(rest1, rest2, new_carry);\n            }\n            2 * (str_to_int(rest1) + str_to_int(rest2) + new_carry) + (if new_bit == '1' { 1nat } else { 0nat }); {\n                assert(2 * new_carry + (if new_bit == '1' { 1nat } else { 0nat }) == sum);\n            }\n            2 * (str_to_int(rest1) + str_to_int(rest2)) + sum; {\n                assert(sum == bit1 + bit2 + carry);\n            }\n            2 * (str_to_int(rest1) + str_to_int(rest2)) + bit1 + bit2 + carry; {\n                assert(str_to_int(s1) == 2 * str_to_int(rest1) + bit1);\n                assert(str_to_int(s2) == 2 * str_to_int(rest2) + bit2);\n            }\n            str_to_int(s1) + str_to_int(s2) + carry;\n        }\n    }\n}\n\n\nproof fn add(s1: Seq<char>, s2: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_bit_string(s1),\n        valid_bit_string(s2),\n    ensures\n        valid_bit_string(result),\n        str_to_int(result) == str_to_int(s1) + str_to_int(s2),\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        let result = seq![('0')];\n        assert forall|i: int| 0 <= i < result.len() implies (result[i] == '0' || result[i] == '1') by {\n            assert(result.len() == 1);\n            assert(result[0] == '0');\n        }\n        add_helper_correctness(s1, s2, 0nat);\n        assert(str_to_int(result) == str_to_int(s1) + str_to_int(s2));\n        result\n    } else if s1.len() == 0 {\n        // When s1 is empty, its value is 0, so we can just return s2\n        // (normalized to ensure no leading zeros)\n        normalize_bit_string_valid(s2);\n        let result = normalize_bit_string(s2);\n        //add_helper_correctness(s1, s2, 0nat);\n        assert(str_to_int(result) == str_to_int(s1) + str_to_int(s2)); \n        result\n    } else if s2.len() == 0 {\n        // When s2 is empty, its value is 0, so we can just return s1\n        // (normalized to ensure no leading zeros)\n        normalize_bit_string_valid(s1);\n        let result = normalize_bit_string(s1);\n        assert(str_to_int(result) == str_to_int(s1) + str_to_int(s2)); \n        result\n    } else {\n        // Perform addition using helper function and normalize the result\n        let intermediate = add_helper(s1, s2, 0nat);\n        add_helper_correctness(s1, s2, 0nat);\n        //assert(valid_bit_string(intermediate)); // From add_helper ensures        \n        normalize_bit_string_valid(intermediate);\n        let result = normalize_bit_string(intermediate);\n        //add_helper_correctness(s1, s2, 0nat);\n        assert(str_to_int(result) == str_to_int(s1) + str_to_int(s2)); \n        result\n    }\n}\n}",
    "filename": "src/bn_add_seq.rs",
    "filepath": null,
    "folder_id": 8941,
    "user_id": 460176
  }
}