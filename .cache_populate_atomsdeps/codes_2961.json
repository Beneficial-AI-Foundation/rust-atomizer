{
  "28668": {
    "text": "//  \r\n// Copyright 2020-2022 Signal Messenger, LLC.\r\n// SPDX-License-Identifier: AGPL-3.0-only\r\n//\r\n\r\n#![warn(missing_docs)]\r\n\r\n//! Types for identifying an individual Signal client instance.\r\n\r\nuse std::fmt;\r\n\r\nuse uuid::Uuid;\r\n\r\n/// Known types of [ServiceId].\r\n#[derive(Clone, Copy, Hash, PartialEq, Eq, derive_more::TryFrom)]\r\n#[try_from(repr)]\r\n#[repr(u8)] \r\npub enum ServiceIdKind {\r\n    /// An [Aci].\r\n    Aci,\r\n    /// A [Pni].\r\n    Pni,\r\n}\r\n\r\nimpl From<ServiceIdKind> for u8 {\r\n    fn from(value: ServiceIdKind) -> Self {\r\n        value as u8\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ServiceIdKind {\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            ServiceIdKind::Aci => f.write_str(\"ACI\"),\r\n            ServiceIdKind::Pni => f.write_str(\"PNI\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Debug for ServiceIdKind {\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n        write!(f, \"{self}\")\r\n    }\r\n}\r\n\r\n/// The error returned for a failed \"downcast\" conversion from a [`ServiceId`] to a specific kind of\r\n/// service ID (e.g. [`Pni`]).\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\npub struct WrongKindOfServiceIdError {\r\n    /// The kind of service ID being converted to.\r\n    pub expected: ServiceIdKind,\r\n    /// The actual kind of the service ID being converted.\r\n    pub actual: ServiceIdKind,\r\n}\r\n\r\n/// A service ID with a known type.\r\n///\r\n/// `RAW_KIND` is a raw [ServiceIdKind] (eventually Rust will allow enums as generic parameters).\r\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\r\npub struct SpecificServiceId<const RAW_KIND: u8>(Uuid);\r\n\r\nimpl<const KIND: u8> SpecificServiceId<KIND> {\r\n    /// Convenience function to go directly from bytes to a specific kind of service ID.\r\n    ///\r\n    /// Prefer `from(Uuid)` / `Uuid::into` if you already have a strongly-typed UUID.\r\n    #[inline]\r\n    pub const fn from_uuid_bytes(bytes: [u8; 16]) -> Self {\r\n        Self::from_uuid(uuid::Uuid::from_bytes(bytes))\r\n    }\r\n\r\n    #[inline]\r\n    const fn from_uuid(uuid: Uuid) -> Self {\r\n        Self(uuid)\r\n    }\r\n}\r\n\r\n// We can go back to derive(Hash) if the uuid crate makes a similar change:\r\n// https://github.com/uuid-rs/uuid/issues/775\r\nimpl<const KIND: u8> std::hash::Hash for SpecificServiceId<KIND> {\r\n    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\r\n        state.write(self.0.as_bytes());\r\n    }\r\n}\r\n\r\nimpl<const KIND: u8> SpecificServiceId<KIND>\r\nwhere\r\n    ServiceId: From<Self>,\r\n    Self: TryFrom<ServiceId>,\r\n{\r\n    /// The standard variable-width binary representation for a Signal service ID.\r\n    ///\r\n    /// This format is not self-delimiting; the length is needed to decode it.\r\n    #[inline]\r\n    pub fn service_id_binary(&self) -> Vec<u8> {\r\n        ServiceId::from(*self).service_id_binary()\r\n    }\r\n\r\n    /// The standard fixed-width binary representation for a Signal service ID.\r\n    #[inline]\r\n    pub fn service_id_fixed_width_binary(&self) -> ServiceIdFixedWidthBinaryBytes {\r\n        ServiceId::from(*self).service_id_fixed_width_binary()\r\n    }\r\n\r\n    /// The standard string representation for a Signal service ID.\r\n    pub fn service_id_string(&self) -> String {\r\n        ServiceId::from(*self).service_id_string()\r\n    }\r\n\r\n    /// Parses from the standard binary representation, returning `None` if invalid.\r\n    #[inline]\r\n    pub fn parse_from_service_id_binary(bytes: &[u8]) -> Option<Self> {\r\n        ServiceId::parse_from_service_id_binary(bytes)?\r\n            .try_into()\r\n            .ok()\r\n    }\r\n\r\n    /// Parses from the standard binary representation, returning `None` if invalid.\r\n    #[inline]\r\n    pub fn parse_from_service_id_fixed_width_binary(\r\n        bytes: &ServiceIdFixedWidthBinaryBytes,\r\n    ) -> Option<Self> {\r\n        ServiceId::parse_from_service_id_fixed_width_binary(bytes)?\r\n            .try_into()\r\n            .ok()\r\n    }\r\n\r\n    /// Parses from the standard String representation, returning `None` if invalid.\r\n    ///\r\n    /// The UUID parsing is case-insensitive.\r\n    pub fn parse_from_service_id_string(input: &str) -> Option<Self> {\r\n        ServiceId::parse_from_service_id_string(input)?\r\n            .try_into()\r\n            .ok()\r\n    }\r\n}\r\n\r\nimpl<const KIND: u8> From<Uuid> for SpecificServiceId<KIND> {\r\n    #[inline]\r\n    fn from(value: Uuid) -> Self {\r\n        Self::from_uuid(value)\r\n    }\r\n}\r\n\r\nimpl<const KIND: u8> From<SpecificServiceId<KIND>> for Uuid {\r\n    #[inline]\r\n    fn from(value: SpecificServiceId<KIND>) -> Self {\r\n        value.0\r\n    }\r\n}\r\n\r\nimpl<const KIND: u8> fmt::Debug for SpecificServiceId<KIND>\r\nwhere\r\n    ServiceId: From<Self>,\r\n{\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n        ServiceId::from(*self).fmt(f)\r\n    }\r\n}\r\n\r\n/// A service ID representing an ACI (\"ACcount Identifier\").\r\n///\r\n/// See also [ServiceId].\r\npub type Aci = SpecificServiceId<{ ServiceIdKind::Aci as u8 }>;\r\n\r\n/// A service ID representing a PNI (\"Phone Number Identifier\").\r\n///\r\n/// See also [ServiceId].\r\npub type Pni = SpecificServiceId<{ ServiceIdKind::Pni as u8 }>;\r\n\r\n/// The fixed-width binary representation of a ServiceId.\r\n///\r\n/// Rarely used. The variable-width format that privileges ACIs is preferred.\r\npub type ServiceIdFixedWidthBinaryBytes = [u8; 17];\r\n\r\n/// A Signal service ID, which can be one of various types.\r\n///\r\n/// Conceptually this is a UUID in a particular \"namespace\" representing a particular way to reach a\r\n/// user on the Signal service.\r\n#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, derive_more::From)]\r\npub enum ServiceId {\r\n    /// An ACI\r\n    Aci(Aci),\r\n    /// A PNI\r\n    Pni(Pni),\r\n}\r\n\r\nimpl ServiceId {\r\n    /// The kind of service ID `self` is.\r\n    #[inline]\r\n    pub fn kind(&self) -> ServiceIdKind {\r\n        match self {\r\n            ServiceId::Aci(_) => ServiceIdKind::Aci,\r\n            ServiceId::Pni(_) => ServiceIdKind::Pni,\r\n        }\r\n    }\r\n\r\n    /// The standard variable-width binary representation for a Signal service ID.\r\n    ///\r\n    /// This format is not self-delimiting; the length is needed to decode it.\r\n    #[inline]\r\n    pub fn service_id_binary(&self) -> Vec<u8> {\r\n        if let Self::Aci(aci) = self {\r\n            aci.0.as_bytes().to_vec()\r\n        } else {\r\n            self.service_id_fixed_width_binary().to_vec()\r\n        }\r\n    }\r\n\r\n    /// The standard fixed-width binary representation for a Signal service ID.\r\n    #[inline]\r\n    pub fn service_id_fixed_width_binary(&self) -> ServiceIdFixedWidthBinaryBytes {\r\n        let mut result = [0; 17];\r\n        result[0] = self.kind().into();\r\n        result[1..].copy_from_slice(self.raw_uuid().as_bytes());\r\n        result\r\n    }\r\n\r\n    /// The standard string representation for a Signal service ID.\r\n    pub fn service_id_string(&self) -> String {\r\n        if let Self::Aci(aci) = self {\r\n            aci.0.to_string()\r\n        } else {\r\n            format!(\"{}:{}\", self.kind(), self.raw_uuid())\r\n        }\r\n    }\r\n\r\n    /// Parses from the standard binary representation, returning `None` if invalid.\r\n    #[inline]\r\n    pub fn parse_from_service_id_binary(bytes: &[u8]) -> Option<Self> {\r\n        match bytes.len() {\r\n            16 => Some(Self::Aci(Uuid::from_slice(bytes).ok()?.into())),\r\n            17 => {\r\n                let result = Self::parse_from_service_id_fixed_width_binary(\r\n                    bytes.try_into().expect(\"already measured\"),\r\n                )?;\r\n                if result.kind() == ServiceIdKind::Aci {\r\n                    // The ACI is unmarked in the standard binary format, so this is an error.\r\n                    None\r\n                } else {\r\n                    Some(result)\r\n                }\r\n            }\r\n            _ => None,\r\n        }\r\n    }\r\n\r\n    /// Parses from the standard binary representation, returning `None` if invalid.\r\n    #[inline]\r\n    pub fn parse_from_service_id_fixed_width_binary(\r\n        bytes: &ServiceIdFixedWidthBinaryBytes,\r\n    ) -> Option<Self> {\r\n        let uuid = Uuid::from_slice(&bytes[1..]).ok()?;\r\n        match ServiceIdKind::try_from(bytes[0]).ok()? {\r\n            ServiceIdKind::Aci => Some(Self::Aci(uuid.into())),\r\n            ServiceIdKind::Pni => Some(Self::Pni(uuid.into())),\r\n        }\r\n    }\r\n\r\n    /// Parses from the standard String representation, returning `None` if invalid.\r\n    ///\r\n    /// The UUID parsing is case-insensitive.\r\n    pub fn parse_from_service_id_string(input: &str) -> Option<Self> {\r\n        fn try_parse_hyphenated(input: &str) -> Option<Uuid> {\r\n            // uuid::Uuid supports multiple UUID formats; we only want to support the \"hyphenated\"\r\n            // form.\r\n            if input.len() != uuid::fmt::Hyphenated::LENGTH {\r\n                return None;\r\n            }\r\n            Uuid::try_parse(input).ok()\r\n        }\r\n\r\n        if let Some(uuid_string) = input.strip_prefix(\"PNI:\") {\r\n            let uuid = try_parse_hyphenated(uuid_string)?;\r\n            Some(Self::Pni(uuid.into()))\r\n        } else {\r\n            let uuid = try_parse_hyphenated(input)?;\r\n            Some(Self::Aci(uuid.into()))\r\n        }\r\n    }\r\n\r\n    /// Returns the UUID inside this service ID, discarding the type.\r\n    #[inline]\r\n    pub fn raw_uuid(self) -> Uuid {\r\n        match self {\r\n            ServiceId::Aci(aci) => aci.into(),\r\n            ServiceId::Pni(pni) => pni.into(),\r\n        }\r\n    }\r\n\r\n    /// Constructs a [ProtocolAddress] from this service ID and a device ID.\r\n    pub fn to_protocol_address(&self, device_id: DeviceId) -> ProtocolAddress {\r\n        ProtocolAddress::new(self.service_id_string(), device_id)\r\n    }\r\n}\r\n\r\nimpl fmt::Debug for ServiceId {\r\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\r\n        write!(f, \"<{}:{}>\", self.kind(), self.raw_uuid())\r\n    }\r\n}\r\n\r\nimpl<const KIND: u8> TryFrom<ServiceId> for SpecificServiceId<KIND> {\r\n    type Error = WrongKindOfServiceIdError;\r\n\r\n    #[inline]\r\n    fn try_from(value: ServiceId) -> Result<Self, Self::Error> {\r\n        if u8::from(value.kind()) == KIND {\r\n            Ok(value.raw_uuid().into())\r\n        } else {\r\n            Err(WrongKindOfServiceIdError {\r\n                expected: KIND\r\n                    .try_into()\r\n                    .expect(\"invalid kind, not covered in ServiceIdKind\"),\r\n                actual: value.kind(),\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nimpl<const KIND: u8> PartialEq<ServiceId> for SpecificServiceId<KIND>\r\nwhere\r\n    ServiceId: From<SpecificServiceId<KIND>>,\r\n{\r\n    fn eq(&self, other: &ServiceId) -> bool {\r\n        ServiceId::from(*self) == *other\r\n    }\r\n}\r\n\r\nimpl<const KIND: u8> PartialEq<SpecificServiceId<KIND>> for ServiceId\r\nwhere\r\n    ServiceId: From<SpecificServiceId<KIND>>,\r\n{\r\n    fn eq(&self, other: &SpecificServiceId<KIND>) -> bool {\r\n        *self == ServiceId::from(*other)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod service_id_tests {\r\n    use std::borrow::Borrow;\r\n\r\n    use proptest::prelude::*;\r\n    use rand::rng;\r\n    use rand::seq::SliceRandom;\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn conversions() {\r\n        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");\r\n\r\n        let aci = Aci::from(uuid);\r\n        assert_eq!(uuid, Uuid::from(aci));\r\n        let aci_service_id = ServiceId::from(aci);\r\n        assert_eq!(aci, aci_service_id);\r\n        assert_eq!(aci_service_id, aci);\r\n        assert_eq!(Ok(aci), Aci::try_from(aci_service_id));\r\n        assert_eq!(\r\n            Err(WrongKindOfServiceIdError {\r\n                expected: ServiceIdKind::Pni,\r\n                actual: ServiceIdKind::Aci\r\n            }),\r\n            Pni::try_from(aci_service_id)\r\n        );\r\n        assert_eq!(ServiceIdKind::Aci, aci_service_id.kind());\r\n\r\n        let pni = Pni::from(uuid);\r\n        assert_eq!(uuid, Uuid::from(pni));\r\n        let pni_service_id = ServiceId::from(pni);\r\n        assert_eq!(pni, pni_service_id);\r\n        assert_eq!(pni_service_id, pni);\r\n        assert_eq!(Ok(pni), Pni::try_from(pni_service_id));\r\n        assert_eq!(\r\n            Err(WrongKindOfServiceIdError {\r\n                expected: ServiceIdKind::Aci,\r\n                actual: ServiceIdKind::Pni\r\n            }),\r\n            Aci::try_from(pni_service_id)\r\n        );\r\n        assert_eq!(ServiceIdKind::Pni, pni_service_id.kind());\r\n\r\n        assert_ne!(aci_service_id, pni_service_id);\r\n    }\r\n\r\n    #[allow(clippy::too_many_arguments)]\r\n    fn round_trip_test<SerializedOwned, SerializedBorrowed>(\r\n        uuid: Uuid,\r\n        serialize: fn(&ServiceId) -> SerializedOwned,\r\n        serialize_aci: fn(&Aci) -> SerializedOwned,\r\n        serialize_pni: fn(&Pni) -> SerializedOwned,\r\n        deserialize: fn(&SerializedBorrowed) -> Option<ServiceId>,\r\n        deserialize_aci: fn(&SerializedBorrowed) -> Option<Aci>,\r\n        deserialize_pni: fn(&SerializedBorrowed) -> Option<Pni>,\r\n        expected_aci: &SerializedBorrowed,\r\n        expected_pni: &SerializedBorrowed,\r\n    ) where\r\n        SerializedOwned: Borrow<SerializedBorrowed>,\r\n        SerializedBorrowed: Eq + fmt::Debug + ?Sized,\r\n    {\r\n        {\r\n            let aci = Aci::from(uuid);\r\n            let serialized = serialize_aci(&aci);\r\n            assert_eq!(expected_aci, serialized.borrow());\r\n            assert_eq!(\r\n                serialized.borrow(),\r\n                serialize(&ServiceId::from(aci)).borrow()\r\n            );\r\n            let deserialized = deserialize(serialized.borrow()).expect(\"just serialized\");\r\n            assert_eq!(ServiceIdKind::Aci, deserialized.kind());\r\n            assert_eq!(uuid, deserialized.raw_uuid());\r\n            assert_eq!(aci, Aci::try_from(deserialized).expect(\"type matches\"));\r\n            assert_eq!(Some(aci), deserialize_aci(serialized.borrow()));\r\n            assert_eq!(None, deserialize_pni(serialized.borrow()));\r\n        }\r\n        {\r\n            let pni = Pni::from(uuid);\r\n            let serialized = serialize_pni(&pni);\r\n            assert_eq!(expected_pni, serialized.borrow());\r\n            assert_eq!(\r\n                serialized.borrow(),\r\n                serialize(&ServiceId::from(pni)).borrow()\r\n            );\r\n            let deserialized = deserialize(serialized.borrow()).expect(\"just serialized\");\r\n            assert_eq!(ServiceIdKind::Pni, deserialized.kind());\r\n            assert_eq!(uuid, deserialized.raw_uuid());\r\n            assert_eq!(pni, Pni::try_from(deserialized).expect(\"type matches\"));\r\n            assert_eq!(Some(pni), deserialize_pni(serialized.borrow()));\r\n            assert_eq!(None, deserialize_aci(serialized.borrow()));\r\n        }\r\n    }\r\n\r\n    fn array_prepend(tag: u8, uuid_bytes: &[u8; 16]) -> [u8; 17] {\r\n        let mut result = [tag; 17];\r\n        result[1..].copy_from_slice(uuid_bytes);\r\n        result\r\n    }\r\n\r\n    #[test]\r\n    fn round_trip_service_id_binary() {\r\n        proptest!(|(uuid_bytes: [u8; 16])| {\r\n            let uuid = Uuid::from_bytes(uuid_bytes);\r\n            round_trip_test(\r\n                uuid,\r\n                ServiceId::service_id_binary,\r\n                Aci::service_id_binary,\r\n                Pni::service_id_binary,\r\n                ServiceId::parse_from_service_id_binary,\r\n                Aci::parse_from_service_id_binary,\r\n                Pni::parse_from_service_id_binary,\r\n                uuid.as_bytes(),\r\n                &array_prepend(0x01, uuid.as_bytes()),\r\n            );\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn round_trip_service_id_fixed_width_binary() {\r\n        proptest!(|(uuid_bytes: [u8; 16])| {\r\n            let uuid = Uuid::from_bytes(uuid_bytes);\r\n            round_trip_test(\r\n                uuid,\r\n                ServiceId::service_id_fixed_width_binary,\r\n                Aci::service_id_fixed_width_binary,\r\n                Pni::service_id_fixed_width_binary,\r\n                ServiceId::parse_from_service_id_fixed_width_binary,\r\n                Aci::parse_from_service_id_fixed_width_binary,\r\n                Pni::parse_from_service_id_fixed_width_binary,\r\n                &array_prepend(0x00, uuid.as_bytes()),\r\n                &array_prepend(0x01, uuid.as_bytes()),\r\n            );\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn round_trip_service_id_string() {\r\n        proptest!(|(uuid_bytes: [u8; 16])| {\r\n            let uuid = Uuid::from_bytes(uuid_bytes);\r\n            round_trip_test(\r\n                uuid,\r\n                ServiceId::service_id_string,\r\n                Aci::service_id_string,\r\n                Pni::service_id_string,\r\n                ServiceId::parse_from_service_id_string,\r\n                Aci::parse_from_service_id_string,\r\n                Pni::parse_from_service_id_string,\r\n                &uuid.hyphenated().to_string(),\r\n                &format!(\"PNI:{}\", uuid.hyphenated()),\r\n            );\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn logging() {\r\n        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");\r\n        let aci = Aci::from(uuid);\r\n        assert_eq!(\r\n            \"<ACI:8c78cd2a-16ff-427d-83dc-1a5e36ce713d>\",\r\n            format!(\"{:?}\", aci)\r\n        );\r\n        assert_eq!(\r\n            \"<ACI:8c78cd2a-16ff-427d-83dc-1a5e36ce713d>\",\r\n            format!(\"{:?}\", ServiceId::from(aci))\r\n        );\r\n        let pni = Pni::from(uuid);\r\n        assert_eq!(\r\n            \"<PNI:8c78cd2a-16ff-427d-83dc-1a5e36ce713d>\",\r\n            format!(\"{:?}\", pni)\r\n        );\r\n        assert_eq!(\r\n            \"<PNI:8c78cd2a-16ff-427d-83dc-1a5e36ce713d>\",\r\n            format!(\"{:?}\", ServiceId::from(pni))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn case_insensitive() {\r\n        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");\r\n        let mut buffer = [0u8; 40]; // exactly fits \"PNI:{uuid}\"\r\n\r\n        let service_id =\r\n            ServiceId::parse_from_service_id_string(uuid.hyphenated().encode_upper(&mut buffer))\r\n                .expect(\"can decode uppercase\");\r\n        assert_eq!(uuid, service_id.raw_uuid());\r\n\r\n        let service_id =\r\n            ServiceId::parse_from_service_id_string(uuid.hyphenated().encode_lower(&mut buffer))\r\n                .expect(\"can decode lowercase\");\r\n        assert_eq!(uuid, service_id.raw_uuid());\r\n\r\n        buffer[..4].copy_from_slice(b\"PNI:\");\r\n        uuid.hyphenated().encode_upper(&mut buffer[4..]);\r\n        let service_id = ServiceId::parse_from_service_id_string(\r\n            std::str::from_utf8(&buffer).expect(\"valid UTF-8\"),\r\n        )\r\n        .expect(\"can decode uppercase PNI\");\r\n        assert_eq!(uuid, service_id.raw_uuid());\r\n\r\n        uuid.hyphenated().encode_lower(&mut buffer[4..]);\r\n        let service_id = ServiceId::parse_from_service_id_string(\r\n            std::str::from_utf8(&buffer).expect(\"valid UTF-8\"),\r\n        )\r\n        .expect(\"can decode lowercase PNI\");\r\n        assert_eq!(uuid, service_id.raw_uuid());\r\n    }\r\n\r\n    #[test]\r\n    fn accepts_ios_system_story_aci() {\r\n        // This is not technically a valid UUID, but we need to handle it anyway, at least on iOS.\r\n        let service_id =\r\n            ServiceId::parse_from_service_id_string(\"00000000-0000-0000-0000-000000000001\")\r\n                .expect(\"can decode\");\r\n        assert_eq!(\r\n            &const_str::hex!(\"00000000 0000 0000 0000 000000000001\"),\r\n            service_id.raw_uuid().as_bytes(),\r\n        );\r\n        assert_eq!(ServiceIdKind::Aci, service_id.kind());\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_invalid_binary_lengths() {\r\n        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");\r\n        assert!(ServiceId::parse_from_service_id_binary(&[]).is_none());\r\n        assert!(ServiceId::parse_from_service_id_binary(&[1]).is_none());\r\n        assert!(ServiceId::parse_from_service_id_binary(&uuid.as_bytes()[1..]).is_none());\r\n        assert!(ServiceId::parse_from_service_id_binary(&[1; 18]).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_invalid_uuid_strings() {\r\n        assert!(ServiceId::parse_from_service_id_string(\"\").is_none());\r\n        assert!(ServiceId::parse_from_service_id_string(\"11\").is_none());\r\n        assert!(\r\n            ServiceId::parse_from_service_id_string(\"8c78cd2a16ff427d83dc1a5e36ce713d\").is_none()\r\n        );\r\n        assert!(\r\n            ServiceId::parse_from_service_id_string(\"{8c78cd2a-16ff-427d-83dc-1a5e36ce713d}\")\r\n                .is_none()\r\n        );\r\n\r\n        assert!(ServiceId::parse_from_service_id_string(\"PNI:\").is_none());\r\n        assert!(ServiceId::parse_from_service_id_string(\"PNI:11\").is_none());\r\n        assert!(\r\n            ServiceId::parse_from_service_id_string(\"PNI:8c78cd2a16ff427d83dc1a5e36ce713d\")\r\n                .is_none()\r\n        );\r\n        assert!(ServiceId::parse_from_service_id_string(\r\n            \"PNI:{8c78cd2a-16ff-427d-83dc-1a5e36ce713d}\"\r\n        )\r\n        .is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_invalid_types() {\r\n        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");\r\n        assert!(\r\n            ServiceId::parse_from_service_id_binary(&array_prepend(0xFF, uuid.as_bytes()))\r\n                .is_none()\r\n        );\r\n        assert!(\r\n            ServiceId::parse_from_service_id_fixed_width_binary(&array_prepend(\r\n                0xFF,\r\n                uuid.as_bytes()\r\n            ))\r\n            .is_none()\r\n        );\r\n        assert!(ServiceId::parse_from_service_id_string(\"BAD:{uuid}\").is_none());\r\n        assert!(ServiceId::parse_from_service_id_string(\"PNI{uuid}\").is_none());\r\n        assert!(ServiceId::parse_from_service_id_string(\"PNI {uuid}\").is_none());\r\n        assert!(ServiceId::parse_from_service_id_string(\"PNI{uuid} \").is_none());\r\n\r\n        // ACIs are only prefixed in the fixed-width format.\r\n        assert!(\r\n            ServiceId::parse_from_service_id_binary(&array_prepend(0x00, uuid.as_bytes()))\r\n                .is_none()\r\n        );\r\n        assert!(ServiceId::parse_from_service_id_string(\"ACI:{uuid}\").is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn ordering() {\r\n        let test_uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");\r\n\r\n        let mut ids: [ServiceId; 4] = [\r\n            Aci::from_uuid(Uuid::nil()).into(),\r\n            Aci::from_uuid(test_uuid).into(),\r\n            Pni::from_uuid(Uuid::nil()).into(),\r\n            Pni::from_uuid(test_uuid).into(),\r\n        ];\r\n        let original = ids;\r\n        ids.shuffle(&mut rng());\r\n        ids.sort();\r\n        assert_eq!(original, ids);\r\n    }\r\n\r\n    #[test]\r\n    fn ordering_consistency() {\r\n        proptest!(|(\r\n            left_uuid_bytes: [u8; 16],\r\n            left_raw_kind in 0..=1,\r\n            right_uuid_bytes: [u8; 16],\r\n            right_raw_kind in 0..=1\r\n        )| {\r\n            let service_id_constructor = |raw_type| match raw_type {\r\n                0 => |uuid: Uuid| ServiceId::Aci(uuid.into()),\r\n                1 => |uuid: Uuid| ServiceId::Pni(uuid.into()),\r\n                _ => unreachable!(\"unexpected raw type {raw_type}\"),\r\n            };\r\n\r\n            let left_uuid = Uuid::from_bytes(left_uuid_bytes);\r\n            let left_service_id = service_id_constructor(left_raw_kind)(left_uuid);\r\n            let right_uuid = Uuid::from_bytes(right_uuid_bytes);\r\n            let right_service_id = service_id_constructor(right_raw_kind)(right_uuid);\r\n\r\n            assert_eq!(\r\n                left_service_id.cmp(&right_service_id),\r\n                left_service_id.service_id_fixed_width_binary()\r\n                    .cmp(&right_service_id.service_id_fixed_width_binary()),\r\n                \"didn't match Service-Id-FixedWidthBinary ordering ({left_service_id:?} vs {right_service_id:?})\",\r\n            );\r\n\r\n            if left_raw_kind == right_raw_kind {\r\n                assert_eq!(\r\n                    left_service_id.cmp(&right_service_id),\r\n                    left_service_id.service_id_string().cmp(&right_service_id.service_id_string()),\r\n                    \"same-kind ServiceIds didn't match Service-Id-String ordering ({left_service_id:?} vs {right_service_id:?})\",\r\n                );\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n/// The type used in memory to represent a *device*, i.e. a particular Signal client instance which\r\n/// represents some user.\r\n///\r\n/// Used in [ProtocolAddress].\r\n#[derive(\r\n    Copy, Clone, Debug, Hash, Eq, PartialEq, PartialOrd, Ord, derive_more::From, derive_more::Into,\r\n)]\r\npub struct DeviceId(u32);\r\n\r\nimpl fmt::Display for DeviceId {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        write!(f, \"{}\", self.0)\r\n    }\r\n}\r\n\r\n/// Represents a unique Signal client instance as `(<user ID>, <device ID>)` pair.\r\n#[derive(Clone, Debug, Hash, Eq, PartialEq, PartialOrd, Ord)]\r\npub struct ProtocolAddress {\r\n    name: String,\r\n    device_id: DeviceId,\r\n}\r\n\r\nimpl ProtocolAddress {\r\n    /// Create a new address.\r\n    ///\r\n    /// - `name` defines a user's public identity, and therefore must be globally unique to that\r\n    ///   user.\r\n    /// - Each Signal client instance then has its own `device_id`, which must be unique among\r\n    ///   all clients for that user.\r\n    ///\r\n    ///```\r\n    /// use libsignal_core::{DeviceId, ProtocolAddress};\r\n    ///\r\n    /// // This is a unique id for some user, typically a UUID.\r\n    /// let user_id: String = \"04899A85-4C9E-44CC-8428-A02AB69335F1\".to_string();\r\n    /// // Each client instance representing that user has a unique device id.\r\n    /// let device_id: DeviceId = 2_u32.into();\r\n    /// let address = ProtocolAddress::new(user_id.clone(), device_id);\r\n    ///\r\n    /// assert!(address.name() == &user_id);\r\n    /// assert!(address.device_id() == device_id);\r\n    ///```\r\n    pub fn new(name: String, device_id: DeviceId) -> Self {\r\n        ProtocolAddress { name, device_id }\r\n    }\r\n\r\n    /// A unique identifier for the target user. This is usually a UUID.\r\n    #[inline]\r\n    pub fn name(&self) -> &str {\r\n        &self.name\r\n    }\r\n\r\n    /// An identifier representing a particular Signal client instance to send to.\r\n    ///\r\n    /// For example, if a user has set up Signal on both their phone and laptop, a particular\r\n    /// message sent to the user will still only go to a single device. So when a user sends a\r\n    /// message to another user at all, they're actually sending a message to *every* device.\r\n    #[inline]\r\n    pub fn device_id(&self) -> DeviceId {\r\n        self.device_id\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ProtocolAddress {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        write!(f, \"{}.{}\", self.name, self.device_id)\r\n    }\r\n}",
    "filename": "single_rust.rs",
    "filepath": null,
    "folder_id": null,
    "user_id": 460154
  }
}