{
  "30579": {
    "text": "lemma Bound(s : string)\r\n  requires ValidBitString(s)\r\n  ensures Pow2(|s|) > Str2Int(s)\r\n{\r\n  if |s| == 0 {\r\n    Pow2Zero();\r\n  }\r\n  else {\r\n    calc {\r\n      Str2Int(s);\r\n    ==\r\n      2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\r\n    <=\r\n      {Bound(s[0..|s|-1]);}\r\n      2 * (Pow2(|s[0..|s|-1]|)-1) + (if s[|s|-1] == '1' then 1 else 0);\r\n    ==\r\n      2 * Pow2(|s|-1) - 2  + (if s[|s|-1] == '1' then 1 else 0);\r\n    <=\r\n      2 * Pow2(|s|-1) - 1;\r\n    ==\r\n      {Pow2Inductive(|s|-1);}\r\n      Pow2(|s|) - 1;\r\n    <\r\n      Pow2(|s|);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nlemma TrailingZeros(s: string, numZeros: nat)\r\n  requires ValidBitString(s)\r\n  requires numZeros <= |s|\r\n  requires forall i :: |s| - numZeros <= i < |s| ==> s[i] == '0'\r\n  ensures Str2Int(s) == Str2Int(s[..|s|-numZeros]) * Pow2(numZeros)\r\n{\r\n  if numZeros == 0 {\r\n    calc {\r\n      OStr2Int(s[..|s|-numZeros]) * Pow2(numZeros);\r\n    ==\r\n      {Pow2Zero();}\r\n      OStr2Int(s[..|s|]) * 1;\r\n    ==\r\n      {assert s[..|s|] == s;}\r\n      OStr2Int(s);\r\n    }\r\n    reveal OStr2Int;\r\n    return;\r\n  }\r\n  calc {\r\n    OStr2Int(s);\r\n  ==\r\n    {reveal OStr2Int;}\r\n    2 * OStr2Int(s[..|s|-1]);\r\n  ==\r\n    {TrailingZeros(s[..|s|-1], numZeros-1);\r\n     assert s[..|s|-1][..|s|-numZeros] == s[..|s|-numZeros];\r\n     reveal OStr2Int;\r\n    }\r\n    2 * (OStr2Int(s[..|s|-numZeros]) * Pow2(numZeros-1));\r\n  ==\r\n    OStr2Int(s[..|s|-numZeros]) * Pow2(numZeros-1) * 2;\r\n  ==\r\n    OStr2Int(s[..|s|-numZeros]) * (Pow2(numZeros-1) * 2);\r\n  ==\r\n    {\r\n      Pow2Inductive(numZeros-1);\r\n    }\r\n    OStr2Int(s[..|s|-numZeros]) * Pow2(numZeros);\r\n  }\r\n  reveal OStr2Int;\r\n}\r\n\r\n\r\nlemma Expand(A:nat, B:nat, C:nat)\r\n  ensures A * (B + 1) * C == A * C + A * B * C\r\n{\r\n}\r\n\r\n\r\n// ----------------------------------------------------\r\n// Int2Str: nat -> bit-string (reference function)\r\n//    - \"0\" if n=0\r\n//    - no leading zeros otherwise\r\n// ----------------------------------------------------\r\nfunction Int2Str(n: nat): string\r\n  // I added the following post-condition because Str2Int requires it\r\n  ensures ValidBitString(Int2Str(n))\r\n  ensures Str2Int(Int2Str(n)) == n\r\n  decreases n\r\n{\r\n  if n == 0 then\r\n    \"0\"\r\n\r\n  else (if n == 1\r\n        then \"1\"\r\n        else (\r\n            // Recursively build from most significant bits.\r\n            // The last character added is (n % 2).\r\n            assert ValidBitString(Int2Str(n/2));\r\n            assert Str2Int(Int2Str(n/2)) == n/2;\r\n            Int2Str(n / 2) + (if n % 2 == 0 then \"0\" else \"1\")\r\n          )\r\n       )\r\n}\r\n\r\n// Eleven and Thirteen will be used in Main\r\n\r\nlemma Eleven()\r\n  ensures Str2Int(\"1011\") == 11\r\n{\r\n  var s := \"1011\";\r\n  calc {\r\n    Str2Int(s);\r\n  ==\r\n    2*Str2Int(s[..3]) + 1;\r\n  ==\r\n    {assert s[..3] == \"101\";}\r\n    2*Str2Int(\"101\") + 1;\r\n  ==\r\n    {\r\n      assert 2*Str2Int(\"10\")+1 == Str2Int(\"101\");}\r\n    2*(2*Str2Int(\"10\")+1) + 1;\r\n  ==\r\n    4*Str2Int(\"10\") + 3;\r\n  ==\r\n    11;}\r\n}\r\n\r\nlemma Thirteen()\r\n  ensures Str2Int(\"1101\") == 13\r\n{\r\n  var s := \"1101\";\r\n  calc {\r\n    Str2Int(s);\r\n  ==\r\n    2*Str2Int(s[..3]) + 1;\r\n  ==\r\n    {assert s[..3] == \"110\";}\r\n    2*Str2Int(\"110\") + 1;\r\n  ==\r\n    {\r\n      assert 2*Str2Int(\"11\")+0 == Str2Int(\"110\");}\r\n    2*(2*Str2Int(\"11\")+0) + 1;\r\n  ==\r\n    4*Str2Int(\"11\") + 1;\r\n  ==\r\n    {assert Str2Int(\"11\") == 3;}\r\n    4*3 + 1;\r\n  ==\r\n    13;\r\n  }\r\n}\r\n\r\n// Lemma 1: Apply BitStringDecomposition for both numbers\r\nlemma AddAux1(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI+1]) * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ+1]) * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then (Str2Int(x[0..oldI]) * 2 + bitX) * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0)\r\n{\r\n  BitStringDecomposition(x, oldI);\r\n  BitStringDecomposition(y, oldJ);\r\n}\r\n\r\n\r\n// Claude was able to mostly prove this one via calc.\r\n// I wonder if it could be slightly easier to read by\r\n// defining t := s[0..i+1] and expanding Str2Int(t)\r\nlemma BitStringDecomposition(s: string, i: int)\r\n  requires ValidBitString(s) && i < |s|\r\n  ensures i >= 0 ==> Str2Int(s[0..i+1]) == Str2Int(s[0..i]) * 2 + (if s[i] == '1' then 1 else 0)\r\n{\r\n  if i >= 0 {\r\n    calc {\r\n      Str2Int(s[0..i+1]);\r\n    == // By definition of Str2Int\r\n      if |s[0..i+1]| == 0 then 0\r\n      else (2 * Str2Int(s[0..i+1][0..|s[0..i+1]|-1]) + (if s[0..i+1][|s[0..i+1]|-1] == '1' then 1 else 0));\r\n    == // Since i >= 0, |s[0..i+1]| = i+1 > 0\r\n      2 * Str2Int(s[0..i+1][0..|s[0..i+1]|-1]) + (if s[0..i+1][|s[0..i+1]|-1] == '1' then 1 else 0);\r\n    == // Simplify: s[0..i+1][0..|s[0..i+1]|-1] = s[0..i+1][0..i] = s[0..i]\r\n      2 * Str2Int(s[0..i+1][0..i]) + (if s[0..i+1][|s[0..i+1]|-1] == '1' then 1 else 0);\r\n    ==\r\n      { assert  s[0..i+1][0..i] == s[0..i];}\r\n      2 * Str2Int(s[0..i]) + (if s[0..i+1][|s[0..i+1]|-1] == '1' then 1 else 0);\r\n    ==\r\n      2 * Str2Int(s[0..i]) + (if s[0..i+1][i] == '1' then 1 else 0);\r\n    == // Simplify: s[0..i+1][i] = s[i]\r\n      2 * Str2Int(s[0..i]) + (if s[i] == '1' then 1 else 0);\r\n    }\r\n  }\r\n}\r\n\r\n// Lemma 2: Distribute Pow2(|oldSb|) in the third term\r\nlemma AddAux2(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then (Str2Int(x[0..oldI]) * 2 + bitX) * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then (Str2Int(x[0..oldI]) * 2) * Pow2(|oldSb|) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0)\r\n{\r\n  if oldI >= 0 {\r\n    var A := Str2Int(x[0..oldI]);\r\n    var B := bitX;\r\n    var C := Pow2(|oldSb|);\r\n    Rearrange(A, B, C);\r\n  }\r\n}\r\n\r\n\r\n// Lemma 3: Use associative property in the third term\r\nlemma AddAux3(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then (Str2Int(x[0..oldI]) * 2) * Pow2(|oldSb|) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * (2 * Pow2(|oldSb|)) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0)\r\n{\r\n  if oldI >= 0 {\r\n    assert (Str2Int(x[0..oldI]) * 2) * Pow2(|oldSb|) == Str2Int(x[0..oldI]) * (2 * Pow2(|oldSb|)) by {\r\n      MulIsAssociative(Str2Int(x[0..oldI]), 2, Pow2(|oldSb|));\r\n    }\r\n  }\r\n}\r\n\r\n// Lemma 4: Apply identity: 2 * Pow2(n) = Pow2(n+1) in the third term\r\nlemma AddAux4(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * (2 * Pow2(|oldSb|)) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0)\r\n{\r\n  assert Pow2(|oldSb| + 1) == 2 * Pow2(|oldSb|) by {\r\n    Pow2Inductive(|oldSb|);\r\n  }\r\n}\r\n\r\n// Lemma 5: Start distributing Pow2(|oldSb|) in the fourth term\r\nlemma AddAux5(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2) * Pow2(|oldSb|) + bitY * Pow2(|oldSb|) else 0)\r\n{\r\n  if oldJ >= 0 {\r\n    var A := Str2Int(y[0..oldJ]);\r\n    var B := bitY;\r\n    var C := Pow2(|oldSb|);\r\n    Rearrange(A, B, C);\r\n  }\r\n}\r\n\r\nlemma Rearrange(A:int, B:int, C:int)\r\n  ensures (A * 2 + B) * C == A * 2 * C + B * C\r\n{\r\n}\r\n\r\n// Lemma 6: Use associative property in the fourth term\r\nlemma AddAux6(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then (Str2Int(y[0..oldJ]) * 2) * Pow2(|oldSb|) + bitY * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * (2 * Pow2(|oldSb|)) + bitY * Pow2(|oldSb|) else 0)\r\n{\r\n  if oldJ >= 0 {\r\n    assert (Str2Int(y[0..oldJ]) * 2) * Pow2(|oldSb|) == Str2Int(y[0..oldJ]) * (2 * Pow2(|oldSb|)) by {\r\n      MulIsAssociative(Str2Int(y[0..oldJ]), 2, Pow2(|oldSb|));\r\n    }\r\n  }\r\n}\r\n\r\n// Lemma 7: Apply identity: 2 * Pow2(n) = Pow2(n+1) in the fourth term\r\nlemma AddAux7(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * (2 * Pow2(|oldSb|)) + bitY * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) + bitY * Pow2(|oldSb|) else 0)\r\n{\r\n  Pow2Inductive(|oldSb|);\r\n}\r\n\r\n// Lemma 8: Rearrange terms\r\nlemma AddAux8(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) + bitX * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) + bitY * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(oldSb) +\r\n          ((oldCarry * Pow2(|oldSb|)) +\r\n           (if oldI >= 0 then bitX else 0) * Pow2(|oldSb|)) + (if oldJ >= 0 then bitY else 0) * Pow2(|oldSb|) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0)\r\n{\r\n  // Simple rearrangement of terms\r\n}\r\n\r\n// Lemma 9: Group bit terms\r\nlemma AddAux9(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          ((oldCarry * Pow2(|oldSb|)) +\r\n           (if oldI >= 0 then bitX else 0) * Pow2(|oldSb|)) + (if oldJ >= 0 then bitY else 0) * Pow2(|oldSb|) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0) ==\r\n          Str2Int(oldSb) +\r\n          ((oldCarry + (if oldI >= 0 then bitX else 0) + (if oldJ >= 0 then bitY else 0)) * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0)\r\n{\r\n  // Grouping terms with the same factor Pow2(|oldSb|)\r\n}\r\n\r\n// Lemma 10: By definition of sum in the code\r\nlemma AddAux10(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n               oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          ((oldCarry + (if oldI >= 0 then bitX else 0) + (if oldJ >= 0 then bitY else 0)) * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (sum * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0)\r\n{\r\n  assert oldCarry + (if oldI >= 0 then bitX else 0) + (if oldJ >= 0 then bitY else 0) == sum;\r\n}\r\n\r\n// Lemma 11: sum = 2*carry + digit\r\nlemma AddAux11(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n               oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (sum * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0) ==\r\n          Str2Int(oldSb) +\r\n          ((2 * carry + digit) * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0)\r\n{\r\n  assert sum == 2 * carry + digit by {\r\n    assert carry == sum / 2;\r\n    assert digit == sum % 2;\r\n    assert sum == (sum / 2) * 2 + (sum % 2);\r\n  }\r\n}\r\n\r\n// Lemma 12: Distribute Pow2(|oldSb|)\r\nlemma AddAux12(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n               oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          ((2 * carry + digit) * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0) ==\r\n          Str2Int(oldSb) +\r\n          (digit * Pow2(|oldSb|)) +\r\n          (carry * Pow2(|oldSb| + 1)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0)\r\n{\r\n  calc {\r\n    ((2 * carry + digit) * Pow2(|oldSb|));\r\n  ==\r\n    2 * carry * Pow2(|oldSb|) + digit * Pow2(|oldSb|);\r\n  ==\r\n    {\r\n      Pow2Inductive(|oldSb|);\r\n    }\r\n    (digit * Pow2(|oldSb|)) + (carry * Pow2(|oldSb| + 1));\r\n  }\r\n}\r\n\r\n// Lemma 13: Definition of Str2Int for new digit + oldSb\r\nlemma AddAux13(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n               oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (digit * Pow2(|oldSb|)) +\r\n          (carry * Pow2(|oldSb| + 1)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ]) * Pow2(|oldSb| + 1) else 0) ==\r\n          Str2Int(if digit == 1 then ['1'] + oldSb else ['0'] + oldSb) +\r\n          (carry * Pow2(|oldSb| + 1)) +\r\n          (if oldI - 1 >= 0 then Str2Int(x[0..(oldI-1)+1]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ - 1 >= 0 then Str2Int(y[0..(oldJ-1)+1]) * Pow2(|oldSb| + 1) else 0)\r\n{\r\n  PrependDigitToString(digit, oldSb);\r\n}\r\n\r\n\r\n\r\nlemma PrependDigitToString(digit: int, s: string)\r\n  requires ValidBitString(s) && (digit == 0 || digit == 1)\r\n  ensures Str2Int(if digit == 1 then ['1'] + s else ['0'] + s) ==\r\n          Str2Int(s) + digit * Pow2(|s|)\r\n{\r\n  reveal Pow2();\r\n  var i := 0;\r\n  while i < |s|\r\n    decreases |s| - i\r\n    invariant 0 <= i <= |s|\r\n    invariant Str2Int(if digit == 1 then ['1'] + s[..i] else ['0'] + s[..i]) == Str2Int(s[..i]) + digit * Pow2(|s[..i]|)\r\n  {\r\n    var t := if digit == 1 then ['1'] + s[..i+1] else ['0'] + s[..i+1];\r\n    calc {\r\n      Str2Int(t);\r\n    ==\r\n      if |t| == 0 then  0  else  (2 * Str2Int(t[0..|t|-1]) + (if t[|t|-1] == '1' then 1 else 0));\r\n    ==\r\n      {assert |t| != 0;}\r\n      2 * Str2Int(t[0..|t|-1]) + (if t[|t|-1] == '1' then 1 else 0);\r\n    ==\r\n      {\r\n        assert t[|t|-1] == s[i];\r\n        assert t[0..|t|-1] == (if digit == 1 then ['1'] + s[..i] else ['0'] + s[..i]);\r\n      }\r\n      2 * Str2Int(if digit == 1 then ['1'] + s[..i] else ['0'] + s[..i]) + (if s[i] == '1' then 1 else 0);\r\n    ==\r\n      2 * (Str2Int(s[..i]) + digit * Pow2(|s[..i]|)) + (if s[i] == '1' then 1 else 0);\r\n    ==\r\n      {\r\n        var u := s[..i+1];\r\n        calc {\r\n          2 * Str2Int(s[..i]) + (if s[i] == '1' then 1 else 0);\r\n        ==\r\n          { assert s[..i] == u[0..|u|-1];\r\n            assert s[i] == u[|u|-1];\r\n          }\r\n          2 * Str2Int(u[0..|u|-1]) + (if u[|u|-1] == '1' then 1 else 0);\r\n        ==\r\n          Str2Int(s[..i+1]);\r\n        }\r\n      }\r\n      Str2Int(s[..i+1]) + digit * Pow2(|s[..i+1]|);\r\n    }\r\n\r\n    i:= i+1;\r\n  }\r\n  assert s[..i] == s;\r\n}\r\n\r\n// Lemma 14: By definition of sb and updated i, j\r\nlemma AddAux14(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n               oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(if digit == 1 then ['1'] + oldSb else ['0'] + oldSb) +\r\n          (carry * Pow2(|oldSb| + 1)) +\r\n          (if oldI - 1 >= 0 then Str2Int(x[0..(oldI-1)+1]) * Pow2(|oldSb| + 1) else 0) +\r\n          (if oldJ - 1 >= 0 then Str2Int(y[0..(oldJ-1)+1]) * Pow2(|oldSb| + 1) else 0) ==\r\n          Str2Int(sb) +\r\n          (carry * Pow2(|sb|)) +\r\n          (if i >= 0 then Str2Int(x[0..i+1]) * Pow2(|sb|) else 0) +\r\n          (if j >= 0 then Str2Int(y[0..j+1]) * Pow2(|sb|) else 0)\r\n{\r\n  assert Pow2(|sb|) == Pow2(|oldSb| + 1);\r\n  assert (if digit == 1 then ['1'] + oldSb else ['0'] + oldSb) == sb;\r\n\r\n  if oldI >= 0 {\r\n    assert i == oldI - 1;\r\n    if i >= 0 {\r\n      assert x[0..i+1] == x[0..oldI];\r\n    }\r\n  }\r\n\r\n  if oldJ >= 0 {\r\n    assert j == oldJ - 1;\r\n    if j >= 0 {\r\n      assert y[0..j+1] == y[0..oldJ];\r\n    }\r\n  }\r\n}\r\n\r\n// The proof of Add's invariant requires a long calculation that often times\r\n// out. To make it more robust, I've pulled it into a lemma AddAuxTop, which\r\n// then calls 14 lemmas, one for each step of the calculation. For conciseness,\r\n// all the lemmas use AddAuxPred as their precondition (although not all of them\r\n// need all of AddAuxPred)\r\n\r\npredicate AddAuxPred(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n                     oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n{\r\n  ValidBitString(sb) &&\r\n  ValidBitString(x) &&\r\n  ValidBitString(y) &&\r\n  ValidBitString(oldSb) &&\r\n  0 <= carry <= 1 &&\r\n  i <= |x| - 1 && j <= |y| - 1 &&\r\n  oldI <= |x| - 1 && oldJ <= |y| - 1 &&\r\n  i >= -1 &&\r\n  j >= -1 &&\r\n  (oldI >= 0 ==> i == oldI - 1) &&\r\n  (oldJ >= 0 ==> j == oldJ - 1) &&\r\n  (oldI < 0 ==> i == oldI) &&\r\n  (oldJ < 0 ==> j == oldJ) &&\r\n  (oldI >= 0 ==> (bitX == if x[oldI] == '1' then 1 else 0)) &&\r\n  (oldJ >= 0 ==> (bitY == if y[oldJ] == '1' then 1 else 0)) &&\r\n  (oldI < 0 ==> bitX == 0) &&\r\n  (oldJ < 0 ==> bitY == 0) &&\r\n  |oldSb| == |sb| - 1 &&\r\n  sum == bitX + bitY + oldCarry &&\r\n  digit == sum % 2 &&\r\n  carry == sum / 2 &&\r\n  (if digit == 1 then ['1'] + oldSb else ['0'] + oldSb) == sb\r\n}\r\n\r\n// Top-level lemma that combines all the individual steps\r\nlemma AddAuxTop(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n                oldJ: int, i:int, j:int, carry:nat, bitX:nat, bitY:nat, digit:nat, sum:nat, oldCarry:nat)\r\n  requires AddAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry)\r\n  ensures Str2Int(oldSb) +\r\n          (oldCarry * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then Str2Int(x[0..oldI+1]) * Pow2(|oldSb|) else 0) +\r\n          (if oldJ >= 0 then Str2Int(y[0..oldJ+1]) * Pow2(|oldSb|) else 0) ==\r\n          Str2Int(sb) +\r\n          (carry * Pow2(|sb|)) +\r\n          (if i >= 0 then Str2Int(x[0..i+1]) * Pow2(|sb|) else 0) +\r\n          (if j >= 0 then Str2Int(y[0..j+1]) * Pow2(|sb|) else 0)\r\n{\r\n  // Call all the sub-lemmas in sequence to establish the proof\r\n  AddAux1(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux2(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux3(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux4(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux5(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux6(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux7(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux8(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux9(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux10(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux11(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux12(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux13(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  AddAux14(x, y, oldSb, sb, oldI, oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n}\r\n\r\n// Lemma 1: Apply BitStringDecomposition for both numbers\r\nlemma SubAux1(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) -\r\n          (oldBorrow * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI+1]) * Pow2(|oldSb|) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ+1]) * Pow2(|oldSb|) else 0) ==\r\n          OStr2Int(oldSb) -\r\n          (oldBorrow * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then (OStr2Int(x[0..oldI]) * 2 + bitX) * Pow2(|oldSb|) else 0) -\r\n          (if oldJ >= 0 then (OStr2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0)\r\n{\r\n  reveal OStr2Int;\r\n  BitStringDecomposition(x, oldI);\r\n  BitStringDecomposition(y, oldJ);\r\n}\r\n\r\n// Lemma 2: Distribute Pow2(|oldSb|)\r\nlemma SubAux2(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) -\r\n          (oldBorrow * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then (OStr2Int(x[0..oldI]) * 2 + bitX) * Pow2(|oldSb|) else 0) -\r\n          (if oldJ >= 0 then (OStr2Int(y[0..oldJ]) * 2 + bitY) * Pow2(|oldSb|) else 0) ==\r\n          OStr2Int(oldSb) -\r\n          (oldBorrow * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * 2 * Pow2(|oldSb|) + bitX * Pow2(|oldSb|) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * 2 * Pow2(|oldSb|) + bitY * Pow2(|oldSb|) else 0)\r\n{\r\n  if oldI >= 0 {\r\n    assert (OStr2Int(x[0..oldI]) * 2 + bitX) * Pow2(|oldSb|) == OStr2Int(x[0..oldI]) * 2 * Pow2(|oldSb|) + bitX * Pow2(|oldSb|);\r\n  }\r\n  if oldJ >= 0 {\r\n    var A := OStr2Int(y[0..oldJ]);\r\n    var B := bitY;\r\n    var C := Pow2(|oldSb|);\r\n    Rearrange(A, B, C);\r\n  }\r\n}\r\n\r\n// Lemma 3: Use Pow2 relationship: 2 * Pow2(n) = Pow2(n+1)\r\nlemma SubAux3(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) -\r\n          (oldBorrow * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * 2 * Pow2(|oldSb|) + bitX * Pow2(|oldSb|) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * 2 * Pow2(|oldSb|) + bitY * Pow2(|oldSb|) else 0) ==\r\n          OStr2Int(oldSb) -\r\n          (oldBorrow * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) + bitX * Pow2(|oldSb|) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) + bitY * Pow2(|oldSb|) else 0)\r\n{\r\n  if oldI >= 0 {\r\n    var A := OStr2Int(x[0..oldI]);\r\n    var B := Pow2(|oldSb|);\r\n    assert (A * 2) * B == A * (2 * B) by { MulIsAssociative(A, 2, B); }\r\n    Pow2Inductive(|oldSb|);\r\n    assert Pow2(|oldSb|+1) == 2 * Pow2(|oldSb|);\r\n  }\r\n\r\n  if oldJ >= 0 {\r\n    var A := OStr2Int(y[0..oldJ]);\r\n    var B := Pow2(|oldSb|);\r\n    assert (A * 2) * B == A * (2 * B) by { MulIsAssociative(A, 2, B); }\r\n    Pow2Inductive(|oldSb|);\r\n    assert Pow2(|oldSb|+1) == 2 * Pow2(|oldSb|);\r\n  }\r\n}\r\n\r\n// The next few lemmas are trivial, but they're useful when Dafny struggles with\r\n// algebra in complicated expressions\r\n\r\nlemma MulIsAssociative(a: nat, b: nat, c: nat)\r\n  ensures a * (b * c) == a * b * c\r\n{\r\n}\r\n\r\n// Lemma 4: Rearrange to isolate the digit contribution\r\nlemma SubAux4(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) -\r\n          (oldBorrow * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) + bitX * Pow2(|oldSb|) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) + bitY * Pow2(|oldSb|) else 0) ==\r\n          OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          ((if oldI >= 0 then bitX else 0) - (if oldJ >= 0 then bitY else 0) - oldBorrow) * Pow2(|oldSb|)\r\n{\r\n  // Rearrangement step - just algebraic manipulation\r\n}\r\n\r\n// Lemma 5: By the definition of diff in code\r\nlemma SubAux5(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          ((if oldI >= 0 then bitX else 0) - (if oldJ >= 0 then bitY else 0) - oldBorrow) * Pow2(|oldSb|) ==\r\n          OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          (rawDiff * Pow2(|oldSb|))\r\n{\r\n  assert ((if oldI >= 0 then bitX else 0) - (if oldJ >= 0 then bitY else 0) - oldBorrow) == rawDiff;\r\n}\r\n\r\n// Lemma 6: Apply relationship between rawDiff, diff and borrow\r\nlemma SubAux6(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          (rawDiff * Pow2(|oldSb|)) ==\r\n          OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          ((if rawDiff < 0 then diff - 2 else diff) * Pow2(|oldSb|))\r\n{\r\n  if rawDiff < 0 {\r\n    assert rawDiff + 2 == diff;\r\n    assert borrow == 1;\r\n    assert rawDiff == diff - 2;\r\n  } else {\r\n    assert rawDiff == diff;\r\n    assert borrow == 0;\r\n  }\r\n}\r\n\r\n// Lemma 7: Rewrite in terms of borrow\r\nlemma SubAux7(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          ((if rawDiff < 0 then diff - 2 else diff) * Pow2(|oldSb|)) ==\r\n          OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          (diff * Pow2(|oldSb|) - (if borrow == 1 then 2 * Pow2(|oldSb|) else 0))\r\n{\r\n  // Rewrite using borrow\r\n}\r\n\r\n// Lemma 8: Use Pow2 relationship again\r\nlemma SubAux8(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          (diff * Pow2(|oldSb|) - (if borrow == 1 then 2 * Pow2(|oldSb|) else 0)) ==\r\n          OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          (diff * Pow2(|oldSb|) - (borrow * Pow2(|oldSb|+1)))\r\n{\r\n  if borrow == 1 {\r\n    assert 2 * Pow2(|oldSb|) == Pow2(|oldSb|+1) by { Pow2Inductive(|oldSb|); }\r\n  }\r\n}\r\n\r\nlemma Pow2Inductive(i: nat)\r\n  ensures Pow2(i+1) == 2*Pow2(i)\r\n{\r\n  reveal Pow2();\r\n}\r\n\r\n// Lemma 9: Rearrange terms\r\nlemma SubAux9(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n              oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) +\r\n          (diff * Pow2(|oldSb|) - (borrow * Pow2(|oldSb|+1))) ==\r\n          OStr2Int(oldSb) +\r\n          diff * Pow2(|oldSb|) +\r\n          (if i >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if j >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) -\r\n          (borrow * Pow2(|oldSb|+1))\r\n{\r\n  reveal OStr2Int;\r\n}\r\n\r\n// Lemma 10: Apply PrependDigitToString\r\nlemma SubAux10(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n               oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) +\r\n          diff * Pow2(|oldSb|) +\r\n          (if i >= 0 then OStr2Int(x[0..oldI]) * Pow2(|oldSb|+1) else 0) -\r\n          (if j >= 0 then OStr2Int(y[0..oldJ]) * Pow2(|oldSb|+1) else 0) -\r\n          (borrow * Pow2(|oldSb|+1)) ==\r\n          OStr2Int(if diff == 1 then ['1'] + oldSb else ['0'] + oldSb) +\r\n          (if i >= 0 then OStr2Int(x[0..i+1]) * Pow2(|oldSb|+1) else 0) -\r\n          (if j >= 0 then OStr2Int(y[0..j+1]) * Pow2(|oldSb|+1) else 0) -\r\n          (borrow * Pow2(|oldSb|+1))\r\n{\r\n  // Apply PrependDigitToString to convert the expression\r\n  reveal OStr2Int;\r\n  PrependDigitToString(diff, oldSb);\r\n\r\n  // Establish that sb == (if diff == 1 then ['1'] + oldSb else ['0'] + oldSb)\r\n  assert sb == (if diff == 1 then ['1'] + oldSb else ['0'] + oldSb);\r\n\r\n  // Establish relationships between indices when working with slices\r\n  if i >= 0 {\r\n    assert oldI >= 0 && i == oldI - 1;\r\n    assert x[0..i+1] == x[0..oldI];  // Since i+1 == oldI\r\n  }\r\n\r\n  if j >= 0 {\r\n    assert oldJ >= 0 && j == oldJ - 1;\r\n    assert y[0..j+1] == y[0..oldJ];  // Since j+1 == oldJ\r\n  }\r\n}\r\n\r\n// Sub also has a long calcuation step, which again we split into a bunch of lemmas\r\n\r\npredicate SubAuxPred(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n                     oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n{\r\n  ValidBitString(sb) &&\r\n  ValidBitString(x) &&\r\n  ValidBitString(y) &&\r\n  ValidBitString(oldSb) &&\r\n  0 <= borrow <= 1 &&\r\n  i <= |x| - 1 && j <= |y| - 1 &&\r\n  oldI <= |x| - 1 && oldJ <= |y| - 1 &&\r\n  i >= -1 &&\r\n  j >= -1 &&\r\n  (oldI >= 0 ==> i == oldI - 1) &&\r\n  (oldJ >= 0 ==> j == oldJ - 1) &&\r\n  (oldI < 0 ==> i == oldI) &&\r\n  (oldJ < 0 ==> j == oldJ) &&\r\n  (oldI >= 0 ==> (bitX == if x[oldI] == '1' then 1 else 0)) &&\r\n  (oldJ >= 0 ==> (bitY == if y[oldJ] == '1' then 1 else 0)) &&\r\n  (oldI < 0 ==> bitX == 0) &&\r\n  (oldJ < 0 ==> bitY == 0) &&\r\n  |oldSb| == |sb| - 1 &&\r\n  (if diff == 1 then ['1'] + oldSb else ['0'] + oldSb) == sb &&\r\n  ((if oldI >= 0 then bitX else 0) - (if oldJ >= 0 then bitY else 0) - oldBorrow) == rawDiff &&\r\n  (rawDiff < 0 ==> (diff == rawDiff + 2) && borrow == 1) &&\r\n  (rawDiff >= 0 ==> (diff == rawDiff) && borrow == 0)\r\n}\r\n\r\n\r\n\r\n// Top-level lemma that combines all the individual steps\r\nlemma SubAuxTop(x: string, y: string, oldSb: string, sb: string, oldI: int,\r\n                oldJ: int, i:int, j:int, borrow:nat, bitX:nat, bitY:nat, rawDiff:int, diff:nat, oldBorrow:nat)\r\n  requires SubAuxPred(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow)\r\n  ensures OStr2Int(oldSb) -\r\n          (oldBorrow * Pow2(|oldSb|)) +\r\n          (if oldI >= 0 then OStr2Int(x[0..oldI+1]) * Pow2(|oldSb|) else 0) -\r\n          (if oldJ >= 0 then OStr2Int(y[0..oldJ+1]) * Pow2(|oldSb|) else 0) ==\r\n          OStr2Int(sb) -\r\n          (borrow * Pow2(|sb|)) +\r\n          (if i >= 0 then OStr2Int(x[0..i+1]) * Pow2(|sb|) else 0) -\r\n          (if j >= 0 then OStr2Int(y[0..j+1]) * Pow2(|sb|) else 0)\r\n{\r\n  // Call all the sub-lemmas in sequence to establish the proof\r\n  SubAux1(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux2(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux3(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux4(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux5(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux6(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux7(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux8(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux9(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n  SubAux10(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n\r\n}\r\n\r\n\r\n\r\n// Helper lemma for maintaining the loop invariant in Mul\r\nlemma MulAux(x: string, y: string, prevProduct: string, product: string,\r\n             prevShift: string, shift: string, idx: int)\r\n  requires ValidBitString(x) && ValidBitString(y)\r\n  requires ValidBitString(prevProduct) && ValidBitString(product)\r\n  requires ValidBitString(prevShift) && ValidBitString(shift)\r\n  requires -1 <= idx < |y| - 1\r\n  requires forall i :: 0 <= i < |prevShift| ==> prevShift[i] == '0'\r\n  requires forall i :: 0 <= i < |shift| ==> shift[i] == '0'\r\n  requires shift == prevShift + ['0']\r\n  requires idx + 1 < |y|\r\n  requires y[idx+1] == '0' ==> prevProduct == product\r\n  requires y[idx+1] == '1' ==> OStr2Int(product) == OStr2Int(prevProduct)+ OStr2Int(x + prevShift)\r\n  requires OStr2Int(x) * OStr2Int(y) == OStr2Int(prevProduct) + OStr2Int(x) * OStr2Int(y[..idx+2] + prevShift)\r\n  ensures OStr2Int(x) * OStr2Int(y) ==\r\n          OStr2Int(prevProduct) + OStr2Int(x) * OStr2Int(y[..idx+2] + prevShift) ==>\r\n            OStr2Int(x) * OStr2Int(y) ==\r\n            OStr2Int(product) + OStr2Int(x) * OStr2Int(y[..idx+1] + shift)\r\n{\r\n  if y[idx+1] == '0' {\r\n    calc {\r\n      OStr2Int(x) * OStr2Int(y);\r\n    ==\r\n      OStr2Int(prevProduct) + OStr2Int(x) * OStr2Int(y[..idx+2] + prevShift);\r\n    ==\r\n      {\r\n        assert prevProduct == product;\r\n        assert y[..idx+2] + prevShift == y[..idx+1] + shift;\r\n      }\r\n      OStr2Int(product) + OStr2Int(x) * OStr2Int(y[..idx+1] + shift);\r\n    }\r\n  }\r\n  else {\r\n    var a := |shift|;\r\n    calc {\r\n      OStr2Int(x) * OStr2Int(y);\r\n    ==\r\n      OStr2Int(prevProduct) + OStr2Int(x) * OStr2Int(y[..idx+2] + prevShift);\r\n    ==\r\n      { assert y[..idx+2] + prevShift == y[..idx+1] + \"1\" + prevShift;}\r\n      OStr2Int(prevProduct) + OStr2Int(x) * OStr2Int(y[..idx+1] + \"1\" + prevShift);\r\n    ==\r\n      { TrailingZeros(y[..idx+1] + \"1\" + prevShift, a-1);\r\n        assert OStr2Int(y[..idx+1] + \"1\" + prevShift) == OStr2Int(y[..idx+1] + \"1\") * Pow2(a-1) by {reveal OStr2Int;}\r\n        assert OStr2Int(x) * OStr2Int(y[..idx+1] + \"1\" + prevShift) == OStr2Int(x) * (OStr2Int(y[..idx+1] + \"1\") * Pow2(a-1));\r\n        assert OStr2Int(x) * (OStr2Int(y[..idx+1] + \"1\") * Pow2(a-1)) == OStr2Int(x) * OStr2Int(y[..idx+1] + \"1\") * Pow2(a-1)\r\n        by {MulIsAssociative(OStr2Int(x), OStr2Int(y[..idx+1] + \"1\"), Pow2(a-1));}\r\n\r\n        assert OStr2Int(x) * OStr2Int(y[..idx+1] + \"1\" + prevShift) == OStr2Int(x) * OStr2Int(y[..idx+1] + \"1\") * Pow2(a-1);\r\n      }\r\n      OStr2Int(prevProduct) + OStr2Int(x) * OStr2Int(y[..idx+1] + \"1\") * Pow2(a-1);\r\n    ==\r\n      {reveal OStr2Int;\r\n      }\r\n      OStr2Int(prevProduct) + OStr2Int(x) * (2*OStr2Int(y[..idx+1]) + 1) * Pow2(a-1);\r\n    ==\r\n      {\r\n        Expand(OStr2Int(x), 2*OStr2Int(y[..idx+1]), Pow2(a-1));\r\n      }\r\n      OStr2Int(prevProduct) + OStr2Int(x) * Pow2(a-1) + OStr2Int(x) * (2*OStr2Int(y[..idx+1])) * Pow2(a-1);\r\n    ==\r\n      {assert OStr2Int(x) * Pow2(a-1) == OStr2Int(x + prevShift) by {\r\n\r\n         reveal OStr2Int;\r\n         TrailingZeros(x+ prevShift, a-1);\r\n       }\r\n       calc {\r\n         OStr2Int(x) * (2*OStr2Int(y[..idx+1])) * Pow2(a-1);\r\n       ==\r\n         {\r\n           MulIsAssociative(OStr2Int(x), 2*OStr2Int(y[..idx+1]), Pow2(a-1));\r\n         }\r\n         OStr2Int(x) * ((2*OStr2Int(y[..idx+1])) * Pow2(a-1));\r\n       ==\r\n         {\r\n           assert (2*OStr2Int(y[..idx+1])) * Pow2(a-1) == OStr2Int(y[..idx+1]) * Pow2(a)\r\n           by{\r\n             Pow2Inductive(a-1);\r\n           }\r\n         }\r\n         OStr2Int(x) * (OStr2Int(y[..idx+1]) * Pow2(a));\r\n       ==\r\n         {MulIsAssociative(OStr2Int(x), OStr2Int(y[..idx+1]), Pow2(a));}\r\n         OStr2Int(x) * OStr2Int(y[..idx+1]) * Pow2(a);\r\n       }\r\n      }\r\n      OStr2Int(prevProduct) + OStr2Int(x + prevShift) + OStr2Int(x) * OStr2Int(y[..idx+1]) * Pow2(a);\r\n    ==\r\n      {\r\n        assert OStr2Int(y[..idx+1]) * Pow2(a) ==  OStr2Int(y[..idx+1] + shift) by {\r\n          reveal OStr2Int;\r\n          TrailingZeros(y[..idx+1] + shift, a);\r\n        }\r\n        MulIsAssociative(OStr2Int(x), OStr2Int(y[..idx+1]), Pow2(a));\r\n        assert OStr2Int(x) * OStr2Int(y[..idx+1]) * Pow2(a) ==  OStr2Int(x) * OStr2Int(y[..idx+1] + shift);\r\n      }\r\n      OStr2Int(prevProduct) + OStr2Int(x + prevShift) + OStr2Int(x) * OStr2Int(y[..idx+1] + shift);\r\n    ==\r\n      {reveal OStr2Int;}\r\n      OStr2Int(product) + OStr2Int(x) * OStr2Int(y[..idx+1] + shift);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nmethod Main() {\r\n  print \"Examples:\\n\";\r\n\r\n  var a := \"1011\";  // decimal 11\r\n\r\n  var b := \"1101\";  // decimal 13\r\n\r\n  print \"a = \", a, \" (decimal=\", Str2Int(a), \")\\n\";\r\n  print \"b = \", b, \" (decimal=\", Str2Int(b), \")\\n\";\r\n\r\n  var s := Add(a, b);\r\n  print \"a + b = \", s, \" (decimal=\", Str2Int(s), \")\\n\";\r\n\r\n  // sub needs to know that the result will be positive\r\n  Eleven();\r\n  Thirteen();\r\n  var d := Sub(b, a);\r\n  print \"b - a = \", d, \" (decimal=\", Str2Int(d), \")\\n\";\r\n\r\n  var m := Mul(a, b);\r\n  print \"a * b = \", m, \" (decimal=\", Str2Int(m), \")\\n\";\r\n\r\n  var z := \"0\";\r\n  var sumZ := Add(a, z);\r\n  print a, \" + 0 = \", sumZ, \" (decimal=\", Str2Int(sumZ), \")\\n\";\r\n\r\n  // Convert integer -> string, then back\r\n  var n := 9999;\r\n  var sN := Int2Str(n);\r\n  print \"9999 -> \", sN, \" -> \", Str2Int(sN), \"\\n\";\r\n}\r\n\r\n\r\n// ----------------------------------------------------\r\n// string-based subtraction (s1 >= s2)\r\n// ----------------------------------------------------\r\nmethod Sub(s1: string, s2: string) returns (res: string)\r\n  requires ValidBitString(s1) && ValidBitString(s2)\r\n  requires Str2Int(s1) >= Str2Int(s2)\r\n  ensures ValidBitString(res)\r\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\r\n{\r\n  var x := NormalizeBitString(s1);\r\n  var y := NormalizeBitString(s2);\r\n\r\n  // If y == \"0\", the difference is x\r\n  if y == \"0\" {\r\n    res := x;\r\n    return;\r\n  }\r\n  // If x == y, the difference is \"0\"\r\n  if x == y {\r\n    res := \"0\";\r\n    return;\r\n  }\r\n\r\n  var i := |x| - 1; // pointer on x\r\n  var j := |y| - 1; // pointer on y\r\n  var borrow := 0;\r\n  var sb := [];\r\n\r\n  Pow2Zero();\r\n  assert borrow * Pow2(|sb|) == 0;\r\n  calc {\r\n    if i >= 0 then Str2Int(x[0..i+1]) * Pow2(|sb|) else 0;\r\n  ==\r\n    Str2Int(x[0..i+1]) * Pow2(|sb|);\r\n  ==\r\n    Str2Int(x[0..i+1]) * 1;\r\n  ==\r\n    Str2Int(x[0..i+1]);\r\n  ==\r\n    {assert x[0..i+1] == x;}\r\n    Str2Int(x);\r\n  }\r\n  calc {\r\n    if j >= 0 then Str2Int(y[0..j+1]) * Pow2(|sb|) else 0;\r\n  ==\r\n    Str2Int(y[0..j+1]) * Pow2(|sb|);\r\n  ==\r\n    Str2Int(y[0..j+1]) * 1;\r\n  ==\r\n    Str2Int(y[0..j+1]);\r\n  ==\r\n    {assert y[0..j+1] == y;}\r\n    Str2Int(y);\r\n  }\r\n\r\n  while i >= 0 || j >= 0\r\n    decreases i + j + 2, borrow\r\n    invariant 0 <= borrow <= 1\r\n    invariant i <= |x| - 1 && j <= |y| - 1\r\n    invariant i >= -1\r\n    invariant j >= -1\r\n    invariant ValidBitString(sb)\r\n    invariant Str2Int(x) - Str2Int(y) ==\r\n              Str2Int(sb) -\r\n              (borrow * Pow2(|sb|)) +\r\n              (if i >= 0 then Str2Int(x[0..i+1]) * Pow2(|sb|) else 0) -\r\n              (if j >= 0 then Str2Int(y[0..j+1]) * Pow2(|sb|) else 0)\r\n  {\r\n    var oldSb := sb;\r\n    var oldBorrow := borrow;\r\n    var bitX := 0;\r\n    if i >= 0 {\r\n      bitX := if x[i] == '1' then 1 else 0;\r\n    }\r\n    var bitY := 0;\r\n    if j >= 0 {\r\n      bitY := if y[j] == '1' then 1 else 0;\r\n    }\r\n\r\n    // Subtract with borrow:\r\n    var rawDiff := bitX - bitY - borrow;\r\n    var diff := rawDiff;\r\n    if rawDiff < 0 {\r\n      diff := rawDiff + 2;\r\n      borrow := 1;\r\n    } else {\r\n      borrow := 0;\r\n    }\r\n\r\n    assert diff == 1 || diff == 0;\r\n    if diff == 1 {\r\n      sb := ['1'] + sb;\r\n    } else {\r\n      sb := ['0'] + sb;\r\n    }\r\n\r\n    var oldI := i;\r\n    var oldJ := j;\r\n\r\n    if i >= 0 { i := i - 1; }\r\n    if j >= 0 { j := j - 1; }\r\n\r\n    SubAuxTop(x, y, oldSb, sb, oldI, oldJ, i, j, borrow, bitX, bitY, rawDiff, diff, oldBorrow);\r\n    reveal OStr2Int;\r\n  }\r\n\r\n\r\n\r\n  // If borrow is 1, the RHS will be negative,\r\n  // but the LHS is nonnegative\r\n  assert Str2Int(x) - Str2Int(y) == Str2Int(sb) - (borrow * Pow2(|sb|));\r\n  assert Pow2(|sb|) > Str2Int(sb) by {Bound(sb);}\r\n  assert borrow == 0;\r\n\r\n\r\n  assert Str2Int(x) - Str2Int(y) == Str2Int(sb);\r\n\r\n  res := NormalizeBitString(sb);\r\n\r\n  assert Str2Int(sb) == Str2Int(res);\r\n}\r\n// Below is a self-contained Dafny program that:\r\n\r\n// - Represents natural numbers as binary strings consisting only of `'0'` and `'1'`.\r\n// - Has two **conversion** functions:\r\n//   1. `Str2Int(s)`: Convert a valid bit-string `s` into a natural number.\r\n//   2. `Int2Str(n)`: Convert a natural number `n` into its binary representation (with no leading zeros except if `n = 0`).\r\n//\r\n// - Has three **pure string-based** arithmetic methods, each **not** using `Str2Int` or `Int2Str` inside the method body:\r\n// 1. `Add(s1, s2)`: Returns the bit-string representing the sum of `s1` and `s2`.\r\n// 2. `Sub(s1, s2)`: Returns the bit-string representing `s1 - s2`, assuming `s1 >= s2`.\r\n//  3. `Mul(s1, s2)`: Returns the bit-string representing the product `s1 * s2`.\r\n//\r\n// All methods come with specifications ensuring they do what they claim, and we prove correctness using Dafny's function specifications (`ensures`) by comparing the result against the reference functions `Str2Int` and `Int2Str`.\r\n\r\n// Theo note: To check that Add/Sub/Mul only use Int2Str and Str2Int for verification:\r\n// 1. Change Int2Str, OStr2Int, and Str2Int to `ghost function`\r\n// 2. Delete Main (because it uses Int2Str/Str2Int in executable code, so now won't verify)\r\n// 3. The rest of the code will still verify\r\n\r\n// This function will be useful in proofs\r\n\r\n// Establish some properties of Pow2\r\n\r\nlemma Pow2Zero()\r\n  ensures Pow2(0) == 1\r\n{\r\n  reveal Pow2();\r\n}\r\n\r\n\r\n// ----------------------------------------------------\r\n// string-based addition (no Str2Int / Int2Str)\r\n// ----------------------------------------------------\r\nmethod Add(s1: string, s2: string) returns (res: string)\r\n  requires ValidBitString(s1) && ValidBitString(s2)\r\n  ensures ValidBitString(res)\r\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\r\n{\r\n  // We implement classic binary addition from right to left.\r\n  // Step 1: Normalize inputs (drop leading zeros if needed).\r\n  var x := NormalizeBitString(s1);\r\n  var y := NormalizeBitString(s2);\r\n\r\n  if y == \"0\" {\r\n    res := x;\r\n    return;\r\n  }\r\n\r\n  // We build the result from the least significant bit forward.\r\n  var i := |x| - 1;  // index on x\r\n  var j := |y| - 1;  // index on y\r\n  var carry := 0;\r\n  var sb := []; // dynamic seq of chars for result (in reverse order)\r\n\r\n  assert x[0..i+1] == x;\r\n  assert y[0..j+1] == y;\r\n  assert Str2Int(x) + Str2Int(y) ==\r\n         (if i >= 0 then Str2Int(x[0..i+1]) else 0) +\r\n         (if j >= 0 then Str2Int(y[0..j+1]) else 0);\r\n\r\n  Pow2Zero();\r\n  while i >= 0 || j >= 0 || carry != 0\r\n    decreases i + j + 2, carry\r\n    invariant 0 <= carry <= 1\r\n    invariant i <= |x| - 1 && j <= |y| - 1\r\n    invariant i >= -1\r\n    invariant j >= -1\r\n    invariant ValidBitString(sb)\r\n    invariant Str2Int(x) + Str2Int(y) ==\r\n              Str2Int(sb) +\r\n              (carry * Pow2(|sb|)) +\r\n              (if i >= 0 then Str2Int(x[0..i+1]) * Pow2(|sb|) else 0) +\r\n              (if j >= 0 then Str2Int(y[0..j+1]) * Pow2(|sb|) else 0)\r\n  {\r\n    var oldSb := sb;\r\n    var oldCarry := carry;\r\n    var bitX := 0;\r\n    if i >= 0 {\r\n      bitX := if x[i] == '1' then 1 else 0;\r\n    }\r\n    var bitY := 0;\r\n    if j >= 0 {\r\n      bitY := if y[j] == '1' then 1 else 0;\r\n    }\r\n\r\n    var sum := bitX + bitY + carry;\r\n    var digit := sum % 2;\r\n    carry := sum / 2;\r\n\r\n    if digit == 1 {\r\n      sb := ['1'] + sb;\r\n    }\r\n    else\r\n    {\r\n      sb := ['0'] + sb;\r\n    }\r\n\r\n    var oldI := i;\r\n    var oldJ := j;\r\n\r\n    if i >= 0 { i := i - 1; }\r\n    if j >= 0 { j := j - 1; }\r\n\r\n    AddAuxTop(x, y, oldSb, sb, oldI,\r\n              oldJ, i, j, carry, bitX, bitY, digit, sum, oldCarry);\r\n  }\r\n\r\n  assert Str2Int(x) + Str2Int(y) == Str2Int(sb);\r\n\r\n  res := NormalizeBitString(sb);\r\n\r\n  assert Str2Int(sb) == Str2Int(res);\r\n\r\n  return res;\r\n}\r\n\r\n\r\nmethod NormalizeBitString(s: string) returns(t: string)\r\n  // Remove leading zeros, except keep at least one digit\r\n  ensures ValidBitString(t)\r\n  // I added and proved some extra post-conditions:\r\n  ensures |t| > 0\r\n  ensures |t| > 1 ==> t[0] != '0'\r\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\r\n{\r\n  // First pass: keep only valid bits\r\n  var validBits := \"\";\r\n  var i := 0;\r\n  while i < |s|\r\n    invariant ValidBitString(validBits)\r\n    invariant 0 <= i <= |s|\r\n    invariant i >= |validBits|\r\n    invariant |s| >= |validBits|\r\n    invariant ValidBitString(s) ==> i == |validBits|\r\n    invariant ValidBitString(s) ==> s[..i] == validBits[..i]\r\n  {\r\n    if s[i] == '0' || s[i] == '1' {\r\n      validBits := validBits + [s[i]];\r\n    }\r\n    i := i + 1;\r\n  }\r\n  assert ValidBitString(s) ==> s == validBits;\r\n  assert ValidBitString(validBits);\r\n  // Second pass: remove leading zeros\r\n  var j := 0;\r\n  assert ValidBitString(s) ==> Str2Int(s[j..]) == Str2Int(s);\r\n  while j < |validBits| && validBits[j] == '0'\r\n    invariant j <= |validBits|\r\n    invariant forall idx :: 0 <= idx < j ==> validBits[idx] == '0'\r\n  {\r\n    j := j + 1;\r\n  }\r\n  if ValidBitString(s){\r\n    assert Str2Int(s[j..]) == Str2Int(s) by\r\n    {\r\n      IgnoreInitialZeros(s, j);\r\n    }\r\n  }\r\n\r\n  // Extract substring after leading zeros\r\n  if j == |validBits| {\r\n    // All zeros or empty\r\n    return \"0\";\r\n  }\r\n  assert j <= |validBits|;\r\n  return validBits[j..];\r\n}\r\n\r\n\r\n// The next few lemmas will be needed\r\n// at various steps in the main proofs\r\n\r\nlemma IgnoreInitialZeros(s : string, numZeros:int)\r\n  requires ValidBitString(s)\r\n  requires 0<=numZeros<=|s|\r\n  requires forall i :: 0<=i<numZeros ==> s[i] == '0'\r\n  ensures Str2Int(s) == Str2Int(s[numZeros..])\r\n{\r\n  if numZeros == 0 {\r\n    return;\r\n  }\r\n  if numZeros == |s| {\r\n    assert Str2Int(s) == (2 * Str2Int(s[0..|s|-1]));\r\n    IgnoreInitialZeros(s[..|s|-1], numZeros-1);\r\n    return;\r\n  }\r\n  IgnoreInitialZeros(s[..|s|-1], numZeros);\r\n  var t := s[numZeros..];\r\n  calc {\r\n    Str2Int(s);\r\n  ==\r\n    (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0));\r\n  ==\r\n    (2 * Str2Int(s[numZeros..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0));\r\n  ==\r\n    {\r\n      assert t[..|t|-1] == s[numZeros..|s|-1];\r\n      assert t[|t|-1] == s[|s|-1];\r\n    }\r\n    (2 * Str2Int(t[..|t|-1]) + (if t[|t|-1] == '1' then 1 else 0));\r\n  ==\r\n    Str2Int(t);\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------\r\n// Str2Int: bit-string -> nat (reference function)\r\n// ----------------------------------------------------\r\nfunction Str2Int(s: string): nat\r\n  requires ValidBitString(s)\r\n  decreases s\r\n{\r\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\r\n}\r\n\r\n\r\n// Make an opaque version to speed up verification\r\nopaque function OStr2Int(s: string): nat\r\n  requires ValidBitString(s)\r\n{\r\n  Str2Int(s)\r\n}\r\n\r\npredicate ValidBitString(s: string)\r\n{\r\n  // All characters must be '0' or '1'.\r\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\r\n}\r\n\r\n\r\n\r\n// ----------------------------------------------------\r\n// string-based multiplication\r\n//    No direct use of Str2Int/Int2Str\r\n// ----------------------------------------------------\r\nmethod Mul(s1: string, s2: string) returns (res: string)\r\n  requires ValidBitString(s1) && ValidBitString(s2)\r\n  ensures ValidBitString(res)\r\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\r\n{\r\n  var x := NormalizeBitString(s1);\r\n  var y := NormalizeBitString(s2);\r\n\r\n  // If either is \"0\", result is \"0\"\r\n  if x == \"0\" || y == \"0\" {\r\n    res := \"0\";\r\n    return;\r\n  }\r\n\r\n  // We'll implement the classic method:\r\n  //   product = 0\r\n  //   for each bit of y (from right to left):\r\n  //       if that bit == 1, add (x << position) to product\r\n  // Use Add(...) to accumulate partial sums.\r\n\r\n  var product := \"0\";\r\n  var shift := \"\";\r\n  var idx := |y| - 1;\r\n  calc {\r\n    OStr2Int(x) * OStr2Int(y);\r\n  ==\r\n    {\r\n      assert OStr2Int(product) == 0 by {reveal OStr2Int;}\r\n      assert y[..idx+1] + shift == y;\r\n      assert OStr2Int(y[..idx+1] + shift) == OStr2Int(y);\r\n    }\r\n    OStr2Int(product) + OStr2Int(x) * OStr2Int(y[..idx+1] + shift);\r\n  }\r\n  while idx >= 0\r\n    decreases idx\r\n    invariant -1 <= idx < |y|\r\n    invariant ValidBitString(y[..idx+1] + shift)\r\n    invariant ValidBitString(product)\r\n    invariant ValidBitString(shift)\r\n    invariant forall i :: 0<=i<|shift| ==> shift[i] == '0'\r\n    invariant OStr2Int(x) * OStr2Int(y) == OStr2Int(product) + OStr2Int(x) * OStr2Int(y[..idx+1] + shift)\r\n  {\r\n    var prevProduct := product;\r\n    var prevIdx := idx;\r\n    var prevShift := shift;\r\n    if y[idx] == '1' {\r\n      var partial := x + shift;\r\n      product := Add(product, partial);\r\n      assert OStr2Int(product) == OStr2Int(prevProduct)+ OStr2Int(x + prevShift) by {reveal OStr2Int;}\r\n    }\r\n    shift := shift + ['0'];\r\n    idx := idx - 1;\r\n    assert ValidBitString(y[..idx+1] + shift);\r\n\r\n    // Use the MulAux lemma to maintain the loop invariant\r\n    MulAux(x, y, prevProduct, product, prevShift, shift, idx);\r\n  }\r\n  assert idx == -1;\r\n  calc {\r\n    OStr2Int(x) * OStr2Int(y);\r\n  ==\r\n    OStr2Int(product) + OStr2Int(x) * OStr2Int(y[..idx+1] + shift);\r\n  ==\r\n    { assert y[..idx+1] == \"\";\r\n      assert y[..idx+1] + shift == shift;\r\n    }\r\n    OStr2Int(product) + OStr2Int(x) * OStr2Int(shift);\r\n  ==\r\n    {reveal OStr2Int;\r\n     IgnoreInitialZeros(shift, |shift|);}\r\n    OStr2Int(product);\r\n  }\r\n  assert Str2Int(x) * Str2Int(y) == Str2Int(product) by {reveal OStr2Int;}\r\n  res := product;\r\n}",
    "filename": "test.rs",
    "filepath": null,
    "folder_id": null,
    "user_id": 460154
  }
}