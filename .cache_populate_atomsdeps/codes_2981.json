{
  "31978": {
    "text": "// #[macro_use]\nuse criterion::{\n    criterion_group, criterion_main,\n    Criterion, Bencher, ParameterizedBenchmark\n};\nuse rand::prelude::*;\n\nfn get_random_vec(n: usize) -> Vec<usize> {\n    let mut rng: StdRng = StdRng::seed_from_u64(42);\n    let mut vec: Vec<usize> = (0..n).collect();\n    vec.shuffle(&mut rng);\n    vec\n}\n\nmacro_rules! create_bench_function {\n    ($x:ident) => {\n        |b: &mut Bencher, n: &usize| {\n            let s = get_random_vec(*n);\n            b.iter(|| sorting_rs::$x(&mut s.clone()));\n        }\n    };\n}\n\nmacro_rules! create_bench {\n    ($p: expr, $f: ident, $($s: ident), *) => {\n        ParameterizedBenchmark::new(stringify!($f),\n        create_bench_function!($f), $p)\n    $(.with_function(stringify!($s), create_bench_function!($s)))*\n    }\n}\n\nfn bench(c: &mut Criterion) {\n    let sizes: Vec<usize> = vec![\n        2, 5, 8, 10, 16, 100, 128, 500, 512, 1000, 1024, 2000, 2048, 8000, 8192,\n        10_000, 16_000, 16_384, 32_000, 32_768, 50_000, /*65_000, 65_536,*/\n        100_000, /* 131_000, 131_072, 262_000, 262_144,*/ 500_000, /*524_288,*/\n        1_000_000, /*1_048_576,*/ 2_000_000, /*2_097_152, 8_388_608,*/\n        10_000_000, /*15_000_000, 16_777_216, 20_000_000,*/ 50_000_000,\n        100_000_000, 250_000_000\n    ];\n\n    let benchmark = create_bench! {\n        sizes,\n        bingo_sort,\n        bitonic_sort,\n        bubble_sort,\n        cocktail_sort,\n        comb_sort,\n        cycle_sort,\n        gnome_sort,\n        gnome_up_sort,\n        heap_sort,\n        heap_bottom_up_sort,\n        weak_heap_sort,\n        insertion_sort,\n        ksort,\n        merge_sort,\n        merge_bottom_up_sort,\n        nheap_sort,\n        oddeven_sort,\n        pancake_sort,\n        quick_sort,\n        quick_dual_sort,\n        selection_sort,\n        selection_double_sort,\n        shell_sort,\n        smooth_sort\n        // Exclude extremely slow sorts\n        // slow_sort,\n        // stooge_sort\n    };\n\n    c.bench(\"sort_bench\", benchmark);\n}\n\ncriterion_group!(benches, bench);\ncriterion_main!(benches);",
    "filename": "benches/sort_benchmark.rs",
    "filepath": null,
    "folder_id": 7139,
    "user_id": 460154
  },
  "31979": {
    "text": "/// Sorts a slice in-place using\n/// [Smooth sort](https://en.wikipedia.org/wiki/Smoothsort)\n/// \n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// This sorting algorithm transforms the input array into implicit heap data\n/// structure and then produces the sorted array by repeatedly extracting the\n/// largest remaining element.\n/// This algorithm makes use of Leonardo numbers. It's a sequence of numbers\n/// defined by:\n/// ```text\n/// L(0) = 1\n/// L(1) = 1\n/// L(n) = L(n - 1) + L(n - 2) + 1\n/// *OR*\n/// L(n) = 2 * Fib(n + 1) - 1\n/// ```\n/// Where *+ 1* is \"add\" number and \"Fib\" are Fibonacci numbers.\n/// \n/// For 64-bit systems it's possible to use 90 Leonardo numbers placed as a\n/// constant array [usize; 90].\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::smooth_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::smooth_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn smooth_sort<T: PartialOrd>(input: &mut [T])\n{\n    if input.len() < 2 {return;}\n    \n    // Init addtitional index heap\n    let input = input;\n    let in_len = input.len();\n    let mut heap = Vec::<usize>::new();\n\n    for i in 0..in_len {\n        if heap.len() >= 2 && heap[heap.len() - 2] == heap[heap.len() - 1] + 1 {\n            heap.pop();\n            let len_leo = heap.len();\n            heap[len_leo - 1] += 1;\n        } else if heap.len() >= 1 && heap[heap.len() - 1] == 1 {\n            heap.push(0);\n        } else {\n            heap.push(1);\n        }\n        restore_heap(input, i, &heap);\n    }\n\n    for i in (0..in_len).rev() {\n        if heap[heap.len() - 1] < 2 {\n            heap.pop();\n        } else {\n            let k = heap.pop().unwrap();\n            let t = get_child_trees(i, k);\n            // tr kr tl kl\n            // 0  1  2  3\n            heap.push(t[3]);\n            restore_heap(input, t[2], &heap);\n            heap.push(t[1]);\n            restore_heap(input, t[0], &heap);\n        }\n    }\n}\n\nfn restore_heap<T: PartialOrd>(input: &mut [T], index: usize, heap: &Vec<usize>)\n{\n    // Insertion sorting\n    let mut current = heap.len() - 1;\n    let mut i = index;\n    let mut k = heap[current];\n\n    while current > 0 {\n        let j = i - crate::LEO_NUMS[k];\n        if input[j] > input[i] &&\n        (k < 2 || input[j] > input[i - 1] && input[j] > input[i - 2]) {\n            input.swap(i, j);\n            i = j;\n            current -= 1;\n            k = heap[current];\n        } else {\n            break;\n        }\n    }\n\n    while k >= 2 {\n        let t = get_child_trees(i, k);\n        // tr kr tl kl\n        // 0  1  2  3\n        if input[i] < input[t[0]] || input[i] < input[t[2]] {\n            if input[t[0]] > input[t[2]] {\n                input.swap(i, t[0]);\n                i = t[0];\n                k = t[1];\n            } else {\n                input.swap(i, t[2]);\n                i = t[2];\n                k = t[3];\n            }\n        } else {\n            break;\n        }\n    }\n}\n\nfn get_child_trees(i: usize, k: usize) -> [usize; 4] {\n    let tr = i - 1;\n    let kr = k - 2;\n    let tl = tr - crate::LEO_NUMS[kr];\n    let kl = k - 1;\n    [tr, kr, tl, kl]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_smooth() {\n        let mut vector_in = vec![20, 10, 11, 13];\n        smooth_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[10, 11, 13, 20]);\n    }\n    #[test]\n    fn test_smooth_01() {\n        let mut vector_in = vec![20, 10, 11, 13, 24, 9, 2, 1, 8];\n        smooth_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[1, 2, 8, 9, 10, 11, 13, 20, 24]);\n    }\n    #[test]\n    fn test_smooth_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        smooth_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_smooth_len1() {\n        let mut vector_in = vec![1];\n        smooth_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[1]);\n    }\n}",
    "filename": "src/smooth_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31980": {
    "text": "/// Sorts a slice in-place using\n/// [N-heap sort](https://en.wikipedia.org/wiki/Heapsort)\n/// \n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// 3 children are a bit more effective than 2, though 4 and more are generally\n/// less effective, but you can modify this parameter by editing souces.\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::nheap_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::nheap_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn nheap_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let children = 3;\n    for i in (0..=input.len()).rev() {\n        nheap_sift(input, children, i, input.len() - 1);\n    }\n\n    for i in (1..input.len()).rev() {\n        input.swap(i, 0);\n        nheap_sift(input, children, 0, i - 1);\n    }\n}\n\nfn nheap_sift<T: PartialOrd>(input: &mut [T], children: usize, start: usize,\nend: usize) {\n    let mut root = start;\n    \n    loop {\n        let child = root * children + 1;\n        if child > end {break;}\n        let mut max = child;\n\n        for k in 2..children + 1 {\n            let current = root * children + k;\n            if current > end {break;}\n\n            if input[current] > input[max] {\n                max = current;\n            }\n        }\n        if input[root] < input[max] {\n            input.swap(root, max);\n            root = max;\n        } else {break;}\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_heap() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        nheap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_heap_01() {\n        let mut vector_in = vec![10, 20, 11, 24, 13, 12];\n        nheap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 12, 13, 20, 24]);\n    }\n    #[test]\n    fn test_heap_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        nheap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_heap_len1() {\n        let mut vector_in = vec![1];\n        nheap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/nheap_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31981": {
    "text": "/// Sorts a slice in-place using\n/// [Shell sort](https://en.wikipedia.org/wiki/Shellsort).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// Shellsort is an optimization of insertion sort that allows the exchange of\n/// items that are far apart. The idea is to arrange the list of elements so\n/// that, starting anywhere, taking every hth element produces a sorted list.\n/// Such a list is said to be h-sorted. It can also be thought of as h\n/// interleaved lists, each individually sorted.\n/// \n/// # Examples\n/// ```rust\n/// let mut vec = vec![0, -1, -2, -3,];\n/// sorting_rs::shell_sort(&mut vec);\n/// assert_eq!(vec, &[-3, -2, -1, 0]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::shell_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\nstruct GapSequence {\n    gap: usize,\n}\n\nimpl GapSequence {\n    fn new(n: usize) -> Self {\n        Self { gap: n }\n    }\n}\n\nimpl Iterator for GapSequence {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        self.gap /= 2;\n\n        if self.gap > 0 {\n            Some(self.gap)\n        } else {\n            None\n        }\n    }\n}\n\npub fn shell_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let len = input.len();\n    let gaps = GapSequence::new(len);\n\n    for gap in gaps {\n        for i in gap..len {\n            let mut j = i;\n\n            while j >= gap && input[j - gap] > input[j] {\n                input.swap(j - gap, j);\n\n                j -= gap;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_correct_gap_sequence() {\n        let gaps: Vec<_> = GapSequence::new(10).collect();\n        debug_assert_eq!(gaps, &[5, 2, 1]);\n    }\n    #[test]\n    fn test_shell() {\n        let mut vector_in = vec![11, 20, 21, 40, 11, 60, 5];\n        shell_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![5, 11, 11, 20, 21, 40, 60]);\n    }\n    #[test]\n    fn test_shell_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        shell_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_shell_len1() {\n        let mut vector_in = vec![1];\n        shell_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}\n",
    "filename": "src/shell_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31982": {
    "text": "//! Additional private binary to print powers of two.\n//! These numbers are used in bitonic sort algorithm as constant.\n//! This one can be useful in case you need to modify algorithm to use with\n//! 32-, 64-, 128-bit and other systems.\n//! This addition uses usize in case there is mainstream 64-bit system.\n//! \n//! # Usage:\n//! ```text\n//! cargo run --bin powers_of_two\n//! ```\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read value\");\n    input = input.to_string().trim().to_string();\n    match input.parse::<usize>() {\n        Ok(input) => {calculate_powers_of_two(input)},\n        _ => {println!(\"Input is not a number!\"); main();}\n    }\n}\n\nfn calculate_powers_of_two(input: usize) {\n    let mut powers = Vec::<usize>::with_capacity(input);\n    for i in 1..input + 1 {\n        powers.push(2usize.pow(i as u32));\n    }\n    println!(\"{:?}\", powers);\n}",
    "filename": "bin/powers_of_two.rs",
    "filepath": null,
    "folder_id": 7141,
    "user_id": 460154
  },
  "31983": {
    "text": "//! Additional private binary to print Leonardo and Fibonnaci numbers.\n//! Leonardo numbers are used in smoothsort algorithm as constant.\n//! This one can be useful in case you need to modify algorithm to use with\n//! 32-, 64-, 128-bit and other systems.\n//! This addition uses usize in case there is mainstream 64-bit system.\n//! \n//! # Usage:\n//! ```text\n//! cargo run --bin leonardo_numbers\n//! ```\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read value\");\n    input = input.to_string().trim().to_string();\n    println!(\"Maximum number: {}\\n\", usize::MAX);\n    match input.parse::<usize>() {\n        Ok(input) => {calculate_leonardo(input); calculate_fibonacci(input);},\n        _ => {println!(\"Input is not a number!\"); main();}\n    }\n}\n\nfn leonardo_generate(mut n0: usize, mut n1: usize, add: usize) ->\nimpl std::iter::Iterator<Item = usize> {\n    std::iter::from_fn(move || {\n        let n = n0;\n        n0 = n1;\n        n1 += n + add;\n        Some(n)\n    })\n}\n\n\nfn calculate_leonardo(num: usize) {\n    println!(\"Leonardo numbers:\");\n    for i in leonardo_generate(1, 1, 1).take(num) {\n        print!(\"{}, \", i);\n    }\n    println!();\n}\n\nfn calculate_fibonacci(num: usize) {\n    println!(\"Fibonacci numbers:\");\n    for i in leonardo_generate(0, 1, 0).take(num) {\n        print!(\"{}, \", i);\n    }\n    println!();\n}",
    "filename": "bin/leonardo_numbers.rs",
    "filepath": null,
    "folder_id": 7141,
    "user_id": 460154
  },
  "31984": {
    "text": "/// Sorts a slice in-place using\n/// [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// \n/// This sorting algorithm is very efficient when used on small data sets.\n/// This is because insertion sort has constant space complexity and works\n/// very fast when used on partially sorted data.\n/// \n/// # Examples\n/// ```rust\n/// let mut vec = vec![-4, -5, 7, 45, 0];\n/// sorting_rs::insertion_sort(&mut vec);\n/// assert_eq!(vec, &[-5, -4, 0, 7, 45]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::insertion_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn insertion_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    for i in 1..input.len() {\n        let mut j = i;\n        while j > 0 && input[j - 1] > input[j] {\n            input.swap(j - 1, j);\n            j -= 1;\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_insertion() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        insertion_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_insertion_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        insertion_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_insertion_len1() {\n        let mut vector_in = vec![1];\n        insertion_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n    // #[test]\n    // fn test_insertion_bin() {\n    //     let mut vector_in = vec![10, 20, 11, 24];\n    //     insertion_bin_sort(&mut vector_in);\n    //     debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    // }\n    // #[test]\n    // fn test_insertion_bin_empty() {\n    //     let mut vector_in:Vec<i32> = vec![];\n    //     insertion_bin_sort(&mut vector_in);\n    //     debug_assert_eq!(vector_in, &[]);\n    // }\n    // #[test]\n    // fn test_insertion_bin_len1() {\n    //     let mut vector_in = vec![1];\n    //     insertion_bin_sort(&mut vector_in);\n    //     debug_assert_eq!(vector_in, vec![1]);\n    // }\n}\n",
    "filename": "src/insertion_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31985": {
    "text": "/// Sorts a slice in-place using\n/// [Cocktail sort](https://en.wikipedia.org/wiki/Cocktail_shaker_sort).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// \n/// Cocktail sort is a variation of bubble sort. The difference is that bubble\n/// sort only makes forward passes, whereas cocktail sort goes back and forth,\n/// like a cocktail shaker. In practice cocktail sort is faster than bubble\n/// most of the time.  A small optimization can be made where the last swap\n/// position is remembered, since all elements beyond that point are already\n/// sorted.\n///\n/// # Examples\n/// ```rust\n/// let mut slice = vec![2,3,4,5,1];\n/// sorting_rs::cocktail_sort(&mut slice);\n/// assert_eq!(slice, &[1,2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::cocktail_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn cocktail_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let mut index_st = 0;\n    let mut index_end = input.len() - 1;\n\n    while index_st < index_end {\n        let slice = index_st..index_end;\n        index_end = index_st;\n        for i in slice {\n            if input[i] > input[i + 1] {\n                input.swap(i, i + 1);\n                index_end = i;\n            }\n        }\n        \n        let slice = (index_st..index_end).rev();\n        index_st = index_end;\n        for i in slice {\n            if input[i] > input[i + 1] {\n                input.swap(i, i + 1);\n                index_st = i;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cocktail() {\n        let mut vector_in = vec![30, 10, 20, 11, 24, 44, 12, 11];\n        cocktail_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 11, 12, 20, 24, 30, 44]);\n    }\n    #[test]\n    fn test_cocktail_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        cocktail_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_cocktail_len1() {\n        let mut vector_in = vec![1];\n        cocktail_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/cocktail_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31986": {
    "text": "/// Sorts a slice in-place using\n/// [Slow sort](https://en.wikipedia.org/wiki/Slowsort)\n/// \n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// It's of humorous nature and not useful.\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::slow_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::slow_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn slow_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    slow_sort_sorting(input, 0, input.len() - 1);\n}\n\nfn slow_sort_sorting<T: PartialOrd>(input: &mut [T], start: usize, end: usize) {\n    if start >= end {return;}\n\n    let mid = (start + end) / 2;\n    slow_sort_sorting(input, start, mid);\n    slow_sort_sorting(input, mid + 1, end);\n    if input[end] < input[mid] {input.swap(end, mid);}\n    slow_sort_sorting(input, start, end - 1);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slow() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        slow_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_slow_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        slow_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_slow_len1() {\n        let mut vector_in = vec![1];\n        slow_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/slow_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31987": {
    "text": "/// Sorts a slice in-place using\n/// [Quick sort](https://en.wikipedia.org/wiki/Quicksort), \n/// [Dual-Pivot Quicksort](https://www.researchgate.net/publication/259264490_Dual_pivot_Quicksort)\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// Dual pivot quicksort additionally needs [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html)\n/// \n/// Quicksort can be compared to merge sort as it also is a divide-and-conquer\n/// algorithm. However, quicksort does all the heavy work before the recursive\n/// calls, so it could also be called a conquer-and-divide algorithm. This\n/// implementation uses the\n/// [Lomuto partition scheme](https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme).\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![0, -1, -2, -3,];\n/// sorting_rs::quick_sort(&mut vec);\n/// assert_eq!(vec, &[-3, -2, -1, 0]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::quick_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n/// ```rust\n/// let mut vec = vec![0, -1, -2, -3,];\n/// sorting_rs::quick_dual_sort(&mut vec);\n/// assert_eq!(vec, &[-3, -2, -1, 0]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::quick_dual_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn quick_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() > 1 {\n        let pivot = lomuto_partition(input);\n        quick_sort(&mut input[..pivot]);\n        quick_sort(&mut input[pivot + 1..]);\n    }\n}\n\n/// Partitions a slice according to the Lomuto partition scheme.\nfn lomuto_partition<T: PartialOrd>(input: &mut [T]) -> usize {\n    let pivot = input.len() - 1;\n    let mut swap = 0;\n    for i in 0..pivot {\n        if input[i] < input[pivot] {\n            if swap != i {\n                input.swap(swap, i);\n            }\n            swap += 1;\n        }\n    }\n\n    if swap != pivot {\n        input.swap(swap, pivot);\n    }\n    swap\n}\n\npub fn quick_dual_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    dual_pivot(input, 0, input.len() - 1);\n}\n\nfn dual_pivot<T: PartialOrd + Copy>(input: &mut [T], start: usize,\nend: usize) {\n    if start >= end {return;}\n    if input[start] > input[end] {\n        input.swap(start, end);\n    }\n    let lpivot = input[start];\n    let rpivot = input[end];\n\n    let mut startm = start + 1;\n    let mut endm = end - 1;\n\n    let mut point = startm;\n\n    while point <= endm {\n        if input[point] < lpivot {\n            input.swap(point, startm);\n            startm += 1;\n        }\n        else if input[point] >= rpivot {\n            while input[endm] > rpivot && point < endm {\n                endm -= 1;\n            }\n            input.swap(point, endm);\n\n            if input[point] < lpivot {\n                input.swap(point, startm);\n                startm += 1;\n            }\n        }\n        point += 1;\n    }\n    startm -= 1;\n    endm += 1;\n    input.swap(start, startm);\n    input.swap(end, endm);\n\n    dual_pivot(input, start, startm);\n    dual_pivot(input, startm + 1, endm);\n    dual_pivot(input, endm, end);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_quick() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        quick_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_quick_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        quick_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_quick_len1() {\n        let mut vector_in = vec![1];\n        quick_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n    #[test]\n    fn test_quick_dual() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_quick_two_elem() {\n        let mut vector_in = [20, 10];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, [10, 20]);\n    }\n    #[test]\n    fn test_quick_dual_longer() {\n        let mut vector_in = [10, 20, 11, 24, 22, 21, 19];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, [10, 11, 19, 20, 21, 22, 24]);\n    }\n    #[test]\n    fn test_quick_dual_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_quick_dual_len1() {\n        let mut vector_in = vec![1];\n        quick_dual_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/quick_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31988": {
    "text": "/// Sorts a slice in-place using\n/// [Gnome sort](https://en.wikipedia.org/wiki/Gnome_sort).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// Gnome sort is also known as stupid sort, because it is very easy to\n/// understand and not very efficient. It is based on how a gnome would sort\n/// flower pots.\n/// \n/// Upgraded version of algorithm just remember last sort position, so it\n/// doesn't try to sort already sorted data.\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::gnome_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::gnome_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::gnome_up_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::gnome_up_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn gnome_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let mut i = 0;\n    \n    while i < input.len() {\n        if i == 0 || input[i - 1] < input[i] {\n            i += 1;\n        } else {\n            input.swap(i - 1, i);\n            i -= 1;\n        }\n    }\n}\n\npub fn gnome_up_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let mut i = 1;\n    let mut j = 2;\n    let in_len = input.len();\n\n    while i < in_len {\n        if input[i - 1] <= input[i] {\n            i = j;\n            j += 1;\n        }\n        else {\n            input.swap(i - 1, i);\n            i -= 1;\n            if i == 0 {\n                i = j;\n                j += 1;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_gnome() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        gnome_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_gnome_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        gnome_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_gnome_len1() {\n        let mut vector_in = vec![1];\n        gnome_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n    #[test]\n    fn test_gnome_up() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        gnome_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_gnome_up_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        gnome_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_gnome_up_len1() {\n        let mut vector_in = vec![1];\n        gnome_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/gnome_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31989": {
    "text": "/// Sorts a slice in-place using\n/// [K-sort](https://arxiv.org/abs/1107.3622)\n/// \n/// This sorting algorithm is in fact a modification of quick sort which should\n/// be faster than quicksort for arrays with less than 7 million elements\n/// This algorithm is generally compared to heapsort and quicksort, it doesn't\n/// need to construct the heap and generally wins in benchmarks because of this.\n/// \n/// # Examples\n/// ```rust\n/// let mut vec = vec![5, 2, 7, 3, 9];\n/// sorting_rs::ksort(&mut vec);\n/// debug_assert_eq!(vec, &[2, 3, 5, 7, 9]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::ksort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn ksort<T: PartialOrd + Clone + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    ksort_lr(input, 0, input.len() - 1);\n}\n\nfn ksort_lr<T: PartialOrd + Clone + Copy>(input: &mut [T], left: usize,\nright: usize) {\n    let key = input[left].clone();\n    // just init it, so no unsafe calls needed, otherwise use of uninit\n    // is prohibited by Rust compiler\n    let mut temp = key.clone();\n    let mut i = left;\n    let mut j = right + 1;\n    let mut k = i + 1;\n    let mut p = i + 1;\n    let mut flag = false;\n\n    while j - i >= 2 {\n        if key <= input[p] {\n            if p != j && j != right + 1 {\n                input.swap(j, p);\n            } else if j == right + 1 {\n                flag = true;\n                temp = input[p].clone();\n            }\n            j -= 1;\n            p = j;\n        } else {\n            input.swap(i, p);\n            i += 1;\n            k += 1;\n            p = k;\n        }\n    }\n\n    input[i] = key;\n    if flag {input[i + 1] = temp;}\n\n    if left < i.saturating_sub(1) {\n        ksort_lr(input, left, i - 1);\n    }\n    if right > i + 1 {\n        ksort_lr(input, i + 1, right);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ksort() {\n        let mut vector_in = [10, 20, 11, 24];\n        ksort(&mut vector_in);\n        debug_assert_eq!(vector_in, [10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_ksort_01() {\n        let mut vector_in = [10, 9, 20, 22, 11, 21, 12, 24, 4, 6, 3];\n        ksort(&mut vector_in);\n        debug_assert_eq!(vector_in, [3, 4, 6, 9, 10, 11, 12, 20, 21, 22, 24]);\n    }\n    #[test]\n    fn test_ksort_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        ksort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_ksort_len1() {\n        let mut vector_in = vec![1];\n        ksort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/ksort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31990": {
    "text": "/// Sorts a slice in-place using\n/// [Stooge sort](https://en.wikipedia.org/wiki/Stooge_sort)\n/// \n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// Well, it's a bit faster than slow sort...\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::stooge_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::stooge_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn stooge_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    stooge_sort_sorting(input, 0, input.len() - 1);\n}\n\nfn stooge_sort_sorting<T: PartialOrd>(input: &mut [T], start: usize,\nend: usize) {\n    if input[start] > input[end] {input.swap(start, end);}\n    if start <= end {\n        if (end - start + 1) > 2 {\n            let temp = (end - start + 1) / 3;\n            stooge_sort_sorting(input, start, end - temp);\n            stooge_sort_sorting(input, start + temp, end);\n            stooge_sort_sorting(input, start, end - temp);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_stooge() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        stooge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_slow_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        stooge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_slow_len1() {\n        let mut vector_in = vec![1];\n        stooge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/stooge_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31991": {
    "text": "/// Sorts a slice in-place using\n/// [Pancake sort](https://en.wikipedia.org/wiki/Pancake_sorting).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// \n/// This algorithm aims to minimize number of comparisons, though amount of\n/// data swaps is pretty high, which doesn't make it very effective in practical\n/// use.\n/// \n/// # Examples\n/// ```rust\n/// let mut vec = vec![56, 32, 78, 16];\n/// sorting_rs::pancake_sort(&mut vec);\n/// assert_eq!(vec, &[16, 32, 56, 78]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::pancake_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn pancake_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let in_len = input.len() - 1;\n    for item in (0..in_len + 1).rev() {\n        let cut = largest_pancake(input, item);\n\n        flip(input, cut);\n        flip(input, item);\n    }\n}\n\nfn largest_pancake<T: PartialOrd + Copy>(input: &[T], index: usize)\n-> usize {\n    let mut pancake = input[index];\n    let mut largest = index;\n\n    for i in 0..index {\n        if input[i] > pancake {\n            pancake = input[i];\n            largest = i;\n        }\n    }\n    largest\n}\n\nfn flip<T: PartialOrd + Copy>(input: &mut [T], index: usize) {\n    input[..=index].reverse();\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pancake() {\n        let mut vector_in = vec![10, 20, 11, 24, 15];\n        pancake_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 15, 20, 24]);\n    }\n    #[test]\n    fn test_pancake_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        pancake_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_pancake_len1() {\n        let mut vector_in = vec![1];\n        pancake_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/pancake_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31992": {
    "text": "/// Sorts a slice out-of-place using\n/// [Merge sort](https://en.wikipedia.org/wiki/Merge_sort) and\n/// [Bottom Up Merge sort](https://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation)\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// \n/// # Examples\n/// ```rust\n/// let mut slice = vec![3,2,1,4];\n/// sorting_rs::merge_sort(&mut slice);\n/// assert_eq!(slice, &[1,2,3,4]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::merge_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n/// ```rust\n/// let mut slice = vec![3,2,1,4];\n/// sorting_rs::merge_bottom_up_sort(&mut slice);\n/// assert_eq!(slice, &[1,2,3,4]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::merge_bottom_up_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\nuse std::cmp::min;\n\npub fn merge_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let len = input.len();\n    let mid = len / 2;\n    merge_sort(&mut input[..mid]);\n    merge_sort(&mut input[mid..]);\n\n    let mut tmp = Vec::with_capacity(len);\n    let mut i = 0;\n    let mut j = mid;\n\n    while i < mid && j < len {\n        if input[i] < input[j] {\n            tmp.push(input[i]);\n            i += 1;\n        } else {\n            tmp.push(input[j]);\n            j += 1;\n        }\n    }\n    if i < mid {\n        tmp.extend_from_slice(&input[i..mid]);\n    } else if j < len {\n        tmp.extend_from_slice(&input[j..len]);\n    }\n\n    input.copy_from_slice(&tmp[..]);\n}\n\npub fn merge_bottom_up_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    let mut width = 1;\n\n    let mut tmp = input.to_vec();\n    let len = input.len();\n\n    while width < len {\n        let mut i = 0;\n        while i < len {\n            let start = min(i + 2 * width, len);\n            let mid = min(i + width, len);\n\n            merge(&input[i..mid], &input[mid..start], &mut tmp[i..start]);\n            input[i..start].copy_from_slice(&tmp[i..start]);\n\n            i += 2 * width;\n        }\n        width *= 2;\n    }\n}\n\nfn merge<T: PartialOrd + Copy>(in1: &[T], in2: &[T], tmp: &mut [T]) {\n    let mut left = 0;\n    let mut right = 0;\n    let mut index = 0;\n\n    while left < in1.len() && right < in2.len() {\n        if in1[left] <= in2[right] {\n            tmp[index] = in1[left];\n            index += 1;\n            left += 1;\n        } else {\n            tmp[index] = in2[right];\n            index += 1;\n            right += 1;\n        }\n    }\n\n    if left < in1.len() {\n        tmp[index..].copy_from_slice(&in1[left..]);\n    }\n    if right < in2.len() {\n        tmp[index..].copy_from_slice(&in2[right..]);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_merge() {\n        let mut vector_in = vec![10, 20, 11, 13, 24];\n        merge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 13, 20, 24]);\n    }\n    #[test]\n    fn test_merge_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        merge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_merge_len1() {\n        let mut vector_in = vec![1];\n        merge_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n    #[test]\n    fn test_merge_bu() {\n        let mut vector_in = vec![24, 20, 11, 13, 10];\n        merge_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 13, 20, 24]);\n    }\n    #[test]\n    fn test_merge_bu_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        merge_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_merge_bu_len1() {\n        let mut vector_in = vec![1];\n        merge_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/merge_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31993": {
    "text": "/// Sorts a slice in-place using\n/// [Bitonic sort](https://en.wikipedia.org/wiki/Bitonic_sorter).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// Bitonic sort is one of the fastest sorting networks. Sorting network has the\n/// sequence of comparisons that are not data-dependent.\n/// \n/// Default implementations of this algorithm demand power of two elements in\n/// array, but for API consistency any length is supported in case of this\n/// implementation. This flexibility comes at cost though: the least effective\n/// operation is `Vec::drain(..index)`, which removes additional values from the\n/// beginning of Vec. Also algotithm has to place new <T> instances to make\n/// array compatible with logic.\n/// \n/// In the current implementation maximum supported array length is\n/// `9223372036854775808`. Next power of two which is `usize::MAX` is actually\n/// 2<sup>64</sup>-1, but isn't supported in most of known cases anyway, as it\n/// occupies 147.6 exabytes of memory.\n/// \n/// Performance-wise all the available 64 bit powers of two are calculated and\n/// placed into const.\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::bitonic_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::bitonic_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn bitonic_sort<T: PartialOrd + Default + Clone>(input: &mut Vec<T>) {\n    if input.len() < 2 {return;}\n    else if input.len() > 9223372036854775808 {panic!(\"Array is too big\")}\n    \n    let in_len = input.len();\n\n    // Check if input array has length of power of 2 and add None to fill it up\n    let mut add_len = 0;\n    println!(\"{}\", add_len);\n\n    for (i, num) in crate::POWERS_OF_TWO.iter().enumerate() {\n        if in_len == *num {add_len = 0;}\n        if i > 0 {\n            if in_len < *num {if in_len > crate::POWERS_OF_TWO[i - 1] {\n                add_len = num - in_len;}\n            }\n        }\n    }\n\n    if add_len > 0 {\n        input.append(&mut vec![T::default(); add_len]);\n    }\n    \n    bit_sort(input, true);\n    input.drain(..add_len);\n}\n\n\nfn bit_sort<T: PartialOrd>(input: &mut [T], mode: bool) {\n    if input.len() > 1 {\n        let mid_point = input.len() / 2;\n        bit_sort(&mut input[..mid_point], true);\n        bit_sort(&mut input[mid_point..], false);\n        sub_sort(input, mode);\n    }\n}\nfn sub_sort<T: PartialOrd>(input: &mut [T], mode: bool) {\n    if input.len() > 1 {\n        compare_and_swap(input, mode);\n        let mid_point = input.len() / 2;\n        sub_sort(&mut input[..mid_point], mode);\n        sub_sort(&mut input[mid_point..], mode);\n    }\n}\nfn compare_and_swap<T: PartialOrd>(input: &mut [T], mode: bool) {\n    let mid_point = input.len() / 2;\n    for i in 0..mid_point {\n        if (input[i] > input[mid_point + i]) == mode {\n            input.swap(i, mid_point + i);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_bitonic_usize() {\n        let mut vector_in = vec![10, 20, 11, 24, 15];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 15, 20, 24]);\n    }\n    #[test]\n    fn test_bitonic_usize_pow_2() {\n        let mut vector_in = vec![10, 20, 11, 24, 15];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 15, 20, 24]);\n    }\n    #[test]\n    fn test_bitonic_bool() {\n        let mut vector_in = vec![false, true, false, false, true];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![false, false, false, true, true]);\n    }\n    #[test]\n    fn test_bitonic_char() {\n        let mut vector_in = vec!['r', 'u', 's', 't', 'c'];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec!['c', 'r', 's', 't', 'u']);\n    }\n    #[test]\n    fn test_bitonic_empty() {\n        let mut vector_in:Vec<u8> = vec![];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![]);\n    }\n    #[test]\n    fn test_bitonic_len1() {\n        let mut vector_in = vec![1];\n        bitonic_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/bitonic_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31994": {
    "text": "/// Sorts a slice in-place using\n/// [Comb sort](https://en.wikipedia.org/wiki/Comb_sort).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// \n/// Comb sort is a simple algorithms that improves on bubble sort. It does so\n/// by eliminating small values at the end of the list quickly, since these\n/// slow down bubble sort. This is solved by comparing elements at the\n/// beginning of the list to the end with a so-called gap. As the algorithm\n/// the gap size shrinks until it is finally 1, where it is the same as bubble\n/// sort.\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![9, 7, 8, 5, 1];\n/// sorting_rs::comb_sort(&mut vec);\n/// assert_eq!(vec, &[1, 5, 7, 8, 9]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::comb_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn comb_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let len = input.len();\n    let inv_shrink: f32 = 1.0 / 1.3;\n\n    let mut gap = len;\n    let mut sorted = len < 2;\n\n    while !sorted {\n        gap = (gap as f32 * inv_shrink).floor() as usize;\n\n        if gap <= 1 {\n            gap = 1;\n            sorted = true;\n        }\n\n        for i in 0..len - gap {\n            if input[i] > input[i + gap] {\n                input.swap(i, i + gap);\n                sorted = false;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_comb() {\n        let mut vector_in = vec![30, 10, 20, 11, 24, 44, 12, 11];\n        comb_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 11, 12, 20, 24, 30, 44]);\n    }\n    #[test]\n    fn test_comb_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        comb_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_comb_len1() {\n        let mut vector_in = vec![1];\n        comb_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/comb_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31995": {
    "text": "/// Sorts a slice in-place using\n/// [Odd-even sort](https://en.wikipedia.org/wiki/Odd-even_sort)\n/// Sorts a slice in-place using\n/// [Batcher Odd-even sort](https://en.wikipedia.org/wiki/Batcher_odd-even_mergesort)\n/// \n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// It's a relatively simple algorithm developed originally for use\n/// on parallel processors with local interconnections.\n/// \n/// Batcher algorithm is the enchanced version of odd-even algorithm.\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::oddeven_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::oddeven_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n/// ```rust\n/// let mut vec = vec![5,3,2,4];\n/// sorting_rs::oddeven_batcher_sort(&mut vec);\n/// assert_eq!(vec, &[2,3,4,5]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::oddeven_batcher_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn oddeven_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let mut sorted = false;\n    let in_len = input.len();\n    while !sorted {\n        sorted = true;\n        \n        let mut i = 1;\n        while i < in_len - 1 {\n            if input[i] > input[i + 1] {\n                input.swap(i, i + 1);\n                sorted = false;\n            }\n            i += 2;\n        }\n\n        i = 0;\n        while i < in_len - 1 {\n            if input[i] > input[i + 1] {\n                input.swap(i, i + 1);\n                sorted = false;\n            }\n            i += 2;\n        }\n    }\n}\n\npub fn oddeven_batcher_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    oddeven_batcher_sort_ranges(input, 0, input.len() - 1);\n}\n\nfn oddeven_batcher_sort_ranges<T: PartialOrd>(input: &mut [T], start:usize,\nend:usize) {\n    if end >= start {\n        let mid = start + (end - start) / 2;\n        oddeven_batcher_sort_ranges(input, end, mid);\n        oddeven_batcher_sort_ranges(input, mid + 1, start);\n        oddeven_batcher_merge(input, start, end, 1);\n    } \n}\n\nfn oddeven_batcher_merge<T: PartialOrd>(input: &mut [T], start:usize, end:usize,\nr: usize) {\n    let step = r * 2;\n    \n    if step < end - start {\n        oddeven_batcher_merge(input, start, end, step);\n        oddeven_batcher_merge(input, start + r, end, step);\n\n        for i in start + r..=end - r {\n            if input[i] > input[i + r] {input.swap(i, i + r);}\n        }\n    }\n    else {\n        if input[start] > input[start + r] {input.swap(start, start + r);}\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_oddeven() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        oddeven_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_oddeven_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        oddeven_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_oddeven_len1() {\n        let mut vector_in = vec![1];\n        oddeven_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n    #[test]\n    fn test_oddeven_batcher() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        oddeven_batcher_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_oddeven_batcher_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        oddeven_batcher_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_oddeven_batcher_len1() {\n        let mut vector_in = vec![1];\n        oddeven_batcher_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/oddeven_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31996": {
    "text": "/// Sorts a slice in-place using\n/// [Heap sort](https://en.wikipedia.org/wiki/Heapsort),\n/// [Bottom-up heap sort](https://en.wikipedia.org/wiki/Heapsort#Bottom-up_heapsort),\n/// [Weak heap sort](https://en.wikipedia.org/wiki/Weak_heap#Weak-heap_sort).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// Heap sort is basically an improved version of selection sort. Where the\n/// selection is now done in logarithmic time instead of linear.\n///\n/// First it transforms the array into a max-heap and then swaps the first\n/// element with the last element of the array, effectively shrinking the\n/// heap. Then it must max heapify again since the swapped value is smaller\n/// than the original max value. This process is repeated until there is no\n/// heap left.\n/// \n/// Bottom-up version is modified version of this algorithm with decreased\n/// number of comparisons require function call or complex logic, then bottom-up\n/// version of algorithm is more effective.\n/// \n/// Weak-heap sort main aim is to minimize amount of comparisons between\n/// elements. Amount of comparisons is basically lowered down to nearly\n/// nlogn - n / ln2 + O(logn).\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![5, 2, 7, 3, 9];\n/// sorting_rs::heap_sort(&mut vec);\n/// debug_assert_eq!(vec, &[2, 3, 5, 7, 9]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::heap_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n/// ```rust\n/// let mut vec = vec![5, 2, 7, 3, 9];\n/// sorting_rs::heap_bottom_up_sort(&mut vec);\n/// debug_assert_eq!(vec, &[2, 3, 5, 7, 9]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::heap_bottom_up_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n/// ```rust\n/// let mut vec = vec![5, 2, 7, 3, 9];\n/// sorting_rs::weak_heap_sort(&mut vec);\n/// debug_assert_eq!(vec, &[2, 3, 5, 7, 9]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::weak_heap_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn heap_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    for i in (0..input.len() / 2).rev() {\n        heap_max(input, i, input.len());\n    }\n\n    for i in (0..input.len()).rev() {\n        input.swap(0, i);\n        heap_max(input, 0, i);\n    }\n}\n\n/// Max heapifies an embedded heap from given index.\nfn heap_max<T: PartialOrd>(input: &mut [T], i: usize, heap_len: usize) {\n    let left = 2 * i + 1;\n    let right = left + 1;\n\n    let mut largest = i;\n    if left < heap_len && input[left] > input[largest] {\n        largest = left;\n    }\n    if right < heap_len && input[right] > input[largest] {\n        largest = right;\n    }\n\n    if largest != i {\n        input.swap(i, largest);\n        heap_max(input, largest, heap_len);\n    }\n}\n\npub fn heap_bottom_up_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let in_len = input.len();\n    for start in (0..=(in_len - 2) / 2).rev() {\n        hbu_sift(input, start, in_len - 1);\n    }\n    for end in (1..in_len).rev() {\n        input.swap(end, 0);\n        hbu_sift(input, 0, end - 1);\n    }\n}\n\nfn hbu_leaf_search<T: PartialOrd>(input: &mut [T], start: usize, end: usize)\n-> usize {\n    let mut current = start;\n\n    loop {\n        let child = current * 2 + 1; // Left leaf\n\n        if (child + 1) > end {\n            break;\n        }\n        if input[child + 1] > input[child] {\n            current = child + 1;\n        }\n        else {\n            current = child;\n        }\n    }\n    let child = current * 2 + 1; // Only left leaf is present\n    if child <= end {\n        current = child;\n    }\n    current\n}\n\nfn hbu_sift<T: PartialOrd>(input: &mut [T], start: usize, end: usize) {\n    let mut current = hbu_leaf_search(input, start, end);\n    \n    while input[start] > input[current] {\n        current = (current - 1) / 2;\n    }\n    input.swap(current, start);\n\n    while current > start {\n        current = (current - 1) / 2;\n        input.swap(current, start);\n    }\n}\n\npub fn weak_heap_sort<T: PartialOrd>(input: &mut [T]) {\n    let n = input.len();\n\n    if n < 2 {return;}\n    else {\n        let mut r = vec![0; (n + 7) / 8];\n        for i in (1..n).rev() {\n            let mut j = i;\n            while j & 1 == get_flag(&r, j >> 1) {j >>= 1;}\n            let gparent = j >> 1;\n            weak_heap_merge(input, &mut r, gparent, i);\n        }\n\n        for i in (2..n).rev() {\n            input.swap(0, i);\n            let mut x = 1;\n            let mut y = 2 * x + get_flag(&r, x);\n            while y < i {\n                x = y;\n                y = 2 * x + get_flag(&r, x);\n            }\n            while x > 0 {\n                weak_heap_merge(input, &mut r, 0, x);\n                x >>= 1;\n            }\n        }\n        input.swap(0, 1);\n    }\n}\n\nfn weak_heap_merge<T: PartialOrd>(input: &mut [T], r: &mut Vec<usize>,\ni: usize, j: usize) {\n    if input[i] < input[j] {\n        tog_flag(r, j);\n        input.swap(i, j);\n    }\n}\n\nfn get_flag(r: &Vec<usize>, x: usize) -> usize {\n    (r[x >> 3] >> (x & 7)) & 1\n}\n\nfn tog_flag(r: &mut Vec<usize>, x: usize) {\n    r[x >> 3] ^= 1 << (x & 7)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_heap() {\n        let mut vector_in = vec![10, 20, 11, 24];\n        heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 20, 24]);\n    }\n    #[test]\n    fn test_heap_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_heap_len1() {\n        let mut vector_in = vec![1];\n        heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n    #[test]\n    fn test_heap_bottom_up() {\n        let mut array = [10, 20, 11, 24, 22, 21, 19];\n        heap_bottom_up_sort(&mut array);\n        debug_assert_eq!(array, [10, 11, 19, 20, 21, 22, 24]);\n    }\n    #[test]\n    fn test_heap_bottom_up_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        heap_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_heap_bottom_up_len1() {\n        let mut vector_in = vec![1];\n        heap_bottom_up_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n    #[test]\n    fn test_weak_heap_small() {\n        let mut vector_in = vec![10, 20, 11, 24, 13];\n        weak_heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 13, 20, 24]);\n    }\n    #[test]\n    fn test_weak_heap_big() {\n        let mut array = [10, 20, 11, 24, 22, 21, 19, 9, 7, 8, 6, 5];\n        weak_heap_sort(&mut array);\n        debug_assert_eq!(array, [5, 6, 7, 8, 9, 10, 11, 19, 20, 21, 22, 24]);\n    }\n    #[test]\n    fn test_weak_heap_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        weak_heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_weak_heap_len1() {\n        let mut vector_in = vec![1];\n        weak_heap_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/heap_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31997": {
    "text": "/// Sorts an input slice in-place using\n/// [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// \n/// # Examples\n/// ```rust\n/// let mut slice = vec![3,2,1,4];\n/// sorting_rs::bubble_sort(&mut slice);\n/// assert_eq!(slice, &[1,2,3,4]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::bubble_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn bubble_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let input_len = input.len();\n\n    for i in (0..input_len).rev() {\n        let mut has_swapped = false;\n        for j in 0..i {\n            if input[j] > input[j + 1] {\n                input.swap(j, j + 1);\n                has_swapped = true;\n            }\n        }\n        if !has_swapped {\n            break;\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_bubble() {\n        let mut vector_in = vec![30, 10, 20, 11, 24, 44, 12, 11];\n        bubble_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 11, 12, 20, 24, 30, 44]);\n    }\n    #[test]\n    fn test_bubble_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        bubble_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_buble_len() {\n        let mut vector_in = vec![1];\n        bubble_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/bubble_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31998": {
    "text": "//! # This library contains following sorting algorithms:\n//! \n//! | Sorting algorithm | Features and downsides                                               | Worst-case performance O(): comparisons; swaps | Best-case performance O(): comparisons; swaps | Space complexity O()   |\n//! | ----------------- | -------------------------------------------------------------------- | ---------------------------------------------- | --------------------------------------------- | ---------------------- |\n//! | Bingo             | aims to be faster than selection sort if there are duplicates        | `n + m`<sup>2</sup>                            | `nm`                                          |                        |\n//! | Bitonic           | method based on building a sorting network                           | `nlog`<sup>`2`</sup>`n`                        | `nlog`<sup>`2`</sup>`n`                       | `nlog`<sup>`2`</sup>`n`|\n//! | Bubble            | bad for sorted or reversed input                                     | `n`<sup>`2`</sup>; `n`<sup>`2`</sup>           | `n`; `1`                                      | `1`                    |\n//! | Cocktail          | little performance improvement over bubble sort                      | `n`<sup>`2`</sup>                              | `n`                                           | `1`                    |\n//! | Comb              | speeds up when data is nearly sorted                                 | `n`<sup>`2`</sup>                              | `nlogn`                                       | `1`                    |\n//! | Cycle             | uses minimum amount of writes, good for memory with limited TBW      | `n`<sup>`2`</sup>                              | `n`<sup>`2`</sup>                             | `1`                    |\n//! | Gnome             | simple and slow, works with one item at a time                       | `n`<sup>`2`</sup>                              | `n`                                           | `1`                    |\n//! | Heap              | independent of data distribution                                     | `nlogn`                                        | `nlogn`                                       | `1`                    |\n//! | Weak Heap         | independent of data distribution, decreased number of comparisons    | `nlogn`                                        | `nlogn`                                       | `1`                    |\n//! | N-Heap            | should be faster than default heap. N = 3                            | `nlogn`                                        | `nlogn`                                       | `1`                    |\n//! | Bottom-up Heap    | upgraded version of heapsort with decreased number of comparisons    | `nlogn`                                        | `nlogn`                                       | `1`                    |\n//! | Insertion         | simple, but less effective than quicksort, heapsort or merge sort    | `n`<sup>`2`</sup>; `n`<sup>`2`</sup>           | `n`; `1`                                      | `1`                    |\n//! | Merge             | independent of data distribution                                     | `nlogn`                                        | `nlogn`                                       | `n`                    |\n//! | Merge Bottom-up   | independent of data distribution, modified version of mergesort      | `nlogn`                                        | `nlogn`                                       | `n`                    |\n//! | Odd-even          | presented to be effective on processors with local interconnections  | `n`<sup>`2`</sup>                              | `n`                                           | `1`                    |\n//! | Odd-even Batcher  | more efficient version of odd-even sort                              | `log`<sup>`2`</sup>`n`                         | `log`<sup>`2`</sup>`n`                        | `logn`<sup>`2`</sup>   |\n//! | Pancake           | swaps data a lot and not so effective in practice                    | `n`<sup>`3`</sup>; `2n - 3`                    | `n`<sup>`2`</sup>                             | `n`                    |\n//! | Quick             | bad for sorted or reversed input                                     | `n`<sup>`2`</sup>                              | `nlogn`                                       | `logn`                 |\n//! | Quick dual        | enchanced version of quicksort                                       | `n`<sup>`2`</sup>                              | `2nlnn`                                       | `logn`                 |\n//! | Ksort             | quicksort variant, faster than heap at less than 7 million elements  | `n`<sup>`2`</sup>                              | `nlog`<sub>2</sub>`n`                         | `logn`                 |\n//! | Selection         | the least number of swaps among all the algorithms                   | `n`<sup>`2`</sup>; `n`                         | `n`<sup>`2`</sup>; `1`                        | `1`                    |\n//! | Double selection  | modified selection sort with more workload, but better efficiency    | `n`<sup>`2`</sup>; `n`                         | `n`<sup>`2`</sup>; `1`                        | higher than Selection  |\n//! | Shellsort         | it is optimization of insertion sort                                 | `n`<sup>`3/2`</sup> or `nlogn`<sup>`2`</sup>   | `nlogn`                                       | `1`                    |\n//! | Slow              | it's slow, who would ever need it?                                   |                                                |                                               |                        |\n//! | Smooth            | variant of heapsort, good for nearly sorted data                     | `nlogn`                                        | `n`                                           | `1`                    |\n//! | Stooge            | it's a bit faster than slow sort                                     | `n`<sup>`2.7095`</sup>                         |                                               | `n`                    |\n\npub mod bingo_sort;\npub mod bitonic_sort;\npub mod bubble_sort;\npub mod cocktail_sort;\npub mod comb_sort;\npub mod cycle_sort;\npub mod gnome_sort;\npub mod heap_sort;\npub mod insertion_sort;\npub mod ksort;\npub mod merge_sort;\npub mod nheap_sort;\npub mod oddeven_sort;\npub mod pancake_sort;\npub mod quick_sort;\npub mod selection_sort;\npub mod shell_sort;\npub mod slow_sort;\npub mod smooth_sort;\npub mod stooge_sort;\n\npub use self::bingo_sort::bingo_sort;\npub use self::bitonic_sort::bitonic_sort;\npub use self::bubble_sort::bubble_sort;\npub use self::cocktail_sort::cocktail_sort;\npub use self::comb_sort::comb_sort;\npub use self::cycle_sort::cycle_sort;\npub use self::gnome_sort::{gnome_sort, gnome_up_sort};\npub use self::heap_sort::{heap_sort, heap_bottom_up_sort, weak_heap_sort};\npub use self::nheap_sort::nheap_sort;\npub use self::insertion_sort::insertion_sort;\npub use self::ksort::ksort;\npub use self::merge_sort::{merge_sort, merge_bottom_up_sort};\npub use self::oddeven_sort::{oddeven_sort, oddeven_batcher_sort};\npub use self::pancake_sort::pancake_sort;\npub use self::quick_sort::{quick_sort, quick_dual_sort};\npub use self::selection_sort::{selection_sort, selection_double_sort};\npub use self::shell_sort::shell_sort;\npub use self::slow_sort::slow_sort;\npub use self::smooth_sort::smooth_sort;\npub use self::stooge_sort::stooge_sort;\n\n/// Calculated powers of 2\npub(crate) const POWERS_OF_TWO: [usize; 63] = [\n2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536,\n131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432,\n67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296,\n8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944,\n549755813888, 1099511627776, 2199023255552, 4398046511104, 8796093022208,\n17592186044416, 35184372088832, 70368744177664, 140737488355328,\n281474976710656, 562949953421312, 1125899906842624, 2251799813685248,\n4503599627370496, 9007199254740992, 18014398509481984, 36028797018963968,\n72057594037927936, 144115188075855872, 288230376151711744, 576460752303423488,\n1152921504606846976, 2305843009213693952, 4611686018427387904,\n9223372036854775808\n];\n\n/// Calculated Leonardo numbers\npub(crate) const LEO_NUMS: [usize; 90] = [\n    1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193,\n    5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049, 242785, 392835,\n    635621, 1028457, 1664079, 2692537, 4356617, 7049155, 11405773, 18454929,\n    29860703, 48315633, 78176337, 126491971, 204668309, 331160281, 535828591,\n    866988873, 1402817465, 2269806339, 3672623805, 5942430145, 9615053951,\n    15557484097, 25172538049, 40730022147, 65902560197, 106632582345,\n    172535142543, 279167724889, 451702867433, 730870592323, 1182573459757,\n    1913444052081, 3096017511839, 5009461563921, 8105479075761,\n    13114940639683, 21220419715445, 34335360355129, 55555780070575,\n    89891140425705, 145446920496281, 235338060921987, 380784981418269,\n    616123042340257, 996908023758527, 1613031066098785, 2609939089857313,\n    4222970155956099, 6832909245813413, 11055879401769513, 17888788647582927,\n    28944668049352441, 46833456696935369, 75778124746287811, 122611581443223181,\n    198389706189510993, 321001287632734175, 519390993822245169,\n    840392281454979345, 1359783275277224515, 2200175556732203861,\n    3559958832009428377, 5760134388741632239,\n];",
    "filename": "src/lib.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "31999": {
    "text": "/// Sorts a slice in-place using\n/// [Selection sort](https://en.wikipedia.org/wiki/Selection_sort).\n/// [Double selection sort](http://warp.povusers.org/DoubleBurstSelectionSort/).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n///\n/// # Examples\n/// ```rust\n/// let mut vec = vec![56, 32, 78, 16];\n/// sorting_rs::selection_sort(&mut vec);\n/// assert_eq!(vec, &[16, 32, 56, 78]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::selection_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n/// ```rust\n/// let mut vec = vec![56, 32, 78, 16];\n/// sorting_rs::selection_double_sort(&mut vec);\n/// assert_eq!(vec, &[16, 32, 56, 78]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::selection_double_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn selection_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    for i in 0..input.len() {\n        let swap_val = {\n            let mut min = &input[i];\n            let mut index_min = i;\n            \n            for j in i + 1..input.len() {\n                if input[j] < *min {\n                    min = &input[j];\n                    index_min = j;\n                }\n            }\n            index_min\n        };\n\n        if i != swap_val {\n            input.swap(i, swap_val);\n        }\n    }\n}\n\npub fn selection_double_sort<T: PartialOrd>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let mut left = 0;\n    let mut right = input.len() - 1;\n    let mut min = left;\n    let mut max = left;\n\n    while left <= right {\n        for i in left..=right {\n            if input[i] > input[max] {\n                max = i;\n            }\n            if input[i] < input[min] {\n                min = i;\n            }\n        }\n        if max == left {max = min;}\n        input.swap(left, min);\n        input.swap(right, max);\n\n        left += 1;\n        right -= 1;\n\n        min = left;\n        max = right;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_selection() {\n        let mut vector_in = vec![11, 20, 21, 40, 11, 60, 5];\n        selection_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![5, 11, 11, 20, 21, 40, 60]);\n    }\n    #[test]\n    fn test_selection_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        selection_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_selection_len1() {\n        let mut vector_in = vec![1];\n        selection_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n    #[test]\n    fn test_selection_double() {\n        let mut vector_in = vec![11, 20, 21, 40, 11, 60, 5];\n        selection_double_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![5, 11, 11, 20, 21, 40, 60]);\n    }\n    #[test]\n    fn test_selection_double_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        selection_double_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_selection_double_len1() {\n        let mut vector_in = vec![1];\n        selection_double_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/selection_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "32000": {
    "text": "/// Sorts a slice in-place using\n/// [Bingo sort](https://xlinux.nist.gov/dads/HTML/bingosort.html).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// \n/// This algorithm aims to be more effective than selection sort in cases there\n/// are many duplicate values.\n/// \n/// # Examples\n/// ```rust\n/// let mut vec = vec![56, 32, 78, 16];\n/// sorting_rs::bingo_sort(&mut vec);\n/// assert_eq!(vec, &[16, 32, 56, 78]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::bingo_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn bingo_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n\n    let in_len = input.len();\n\n    let minmax = get_min_max(input);\n    let min = minmax[0];\n    let max = minmax[1];\n\n    let mut bingo = min;\n    let mut n_bingo = max;\n    let mut n_index = 0;\n\n    while bingo < max {\n        let start = n_index;\n        for i in start..in_len {\n            if input[i] == bingo {input.swap(i, n_index); n_index += 1;}\n            if input[i] < n_bingo {n_bingo = input[i];}\n        }\n        bingo = n_bingo;\n        n_bingo = max;\n    }\n}\n\nfn get_min_max<T: PartialOrd + Copy>(input: &[T]) -> [T; 2] {\n    let mut min = input[0];\n    let mut max = input[0];\n    for i in 1..input.len() {\n        if input[i] < min {min = input[i];}\n        if input[i] > max {max = input[i];}\n    }\n    [min, max]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_bingo() {\n        let mut vector_in = vec![10, 20, 11, 24, 15];\n        bingo_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![10, 11, 15, 20, 24]);\n    }\n    #[test]\n    fn test_bingo_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        bingo_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![]);\n    }\n    #[test]\n    fn test_bingo_len1() {\n        let mut vector_in = vec![1];\n        bingo_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/bingo_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  },
  "32001": {
    "text": "/// Sorts a slice in-place using\n/// [Cycle sort](https://en.wikipedia.org/wiki/Cycle_sort).\n/// All kinds of slices can be sorted as long as they implement\n/// [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).\n/// \n/// This kind of sort is pretty good in case you need as low writes as\n/// possible, for example, using SSD or NAND memory.\n/// \n/// # Examples\n/// ```rust\n/// let mut vec = vec![56, 32, 78, 16];\n/// sorting_rs::cycle_sort(&mut vec);\n/// assert_eq!(vec, &[16, 32, 56, 78]);\n/// ```\n/// ```rust\n/// let mut strings = vec![\"rustc\", \"cargo\", \"rustup\"];\n/// sorting_rs::cycle_sort(&mut strings);\n/// assert_eq!(strings, &[\"cargo\", \"rustc\", \"rustup\"]);\n/// ```\n\npub fn cycle_sort<T: PartialOrd + Copy>(input: &mut [T]) {\n    if input.len() < 2 {return;}\n    \n    let in_len = input.len();\n    for index in 0..in_len {\n        let mut key = input[index];\n        let mut pos = index;\n\n        for i in index + 1..in_len {\n            if input[i] < key {pos += 1;}\n        }\n\n        if pos == index {continue;}\n\n        while key == input[pos] {\n            pos += 1;\n        }\n        // One does not simply swap by indexes, but copies item into buffer\n        let tmp = input[pos];\n        input[pos] = key;\n        key = tmp;\n\n        while pos != index {\n            pos = index;\n            for i in index + 1..in_len {\n                if input[i] < key {pos += 1;}\n            }\n            while key == input[pos] {\n                pos += 1;\n            }\n            let tmp = input[pos];\n            input[pos] = key;\n            key = tmp;\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cycle() {\n        let mut vector_in = vec![11, 20, 21, 40, 11, 60, 5];\n        cycle_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![5, 11, 11, 20, 21, 40, 60]);\n    }\n    #[test]\n    fn test_cycle_empty() {\n        let mut vector_in:Vec<i32> = vec![];\n        cycle_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, &[]);\n    }\n    #[test]\n    fn test_cycle_len1() {\n        let mut vector_in = vec![1];\n        cycle_sort(&mut vector_in);\n        debug_assert_eq!(vector_in, vec![1]);\n    }\n}",
    "filename": "src/cycle_sort.rs",
    "filepath": null,
    "folder_id": 7140,
    "user_id": 460154
  }
}