{
  "38778": {
    "text": "//@ [coq] aeneas-args=-use-fuel\r\n//@ [fstar] aeneas-args=-decreases-clauses\r\n//@ [fstar] aeneas-args=-split-files\r\n//@ [coq,fstar] subdir=misc\r\nuse std::vec::Vec;\r\n\r\n/// No borrows\r\npub fn sum(max: u32) -> u32 {\r\n    let mut i = 0;\r\n    let mut s = 0;\r\n    while i < max {\r\n        s += i;\r\n        i += 1;\r\n    }\r\n\r\n    s *= 2;\r\n    s\r\n}\r\n\r\n/// Same as [sum], but we use borrows in order tocreate loans inside a loop\r\n/// iteration, and those borrows will have to be ended by the end of the\r\n/// iteration.\r\npub fn sum_with_mut_borrows(max: u32) -> u32 {\r\n    let mut i = 0;\r\n    let mut s = 0;\r\n    while i < max {\r\n        let ms = &mut s;\r\n        *ms += i;\r\n        let mi = &mut i;\r\n        *mi += 1;\r\n    }\r\n\r\n    s *= 2;\r\n    s\r\n}\r\n\r\n/// Similar to [sum_with_mut_borrows].\r\npub fn sum_with_shared_borrows(max: u32) -> u32 {\r\n    let mut i = 0;\r\n    let mut s = 0;\r\n    while i < max {\r\n        i += 1;\r\n        // We changed the order compared to [sum_with_mut_borrows]:\r\n        // we want to have a shared borrow surviving until the end\r\n        // of the iteration.\r\n        let mi = &i;\r\n        s += *mi;\r\n    }\r\n\r\n    s *= 2;\r\n    s\r\n}\r\n\r\npub fn sum_array<const N: usize>(a: [u32; N]) -> u32 {\r\n    let mut i = 0;\r\n    let mut s = 0;\r\n    while i < N {\r\n        s += a[i];\r\n        i += 1;\r\n    }\r\n    s\r\n}\r\n\r\n/// This case is interesting, because the fixed point for the loop doesn't\r\n/// introduce new abstractions.\r\npub fn clear(v: &mut Vec<u32>) {\r\n    let mut i = 0;\r\n    while i < v.len() {\r\n        v[i] = 0;\r\n        i += 1;\r\n    }\r\n}\r\n\r\npub enum List<T> {\r\n    Cons(T, Box<List<T>>),\r\n    Nil,\r\n}\r\n\r\n/// The parameter `x` is a borrow on purpose\r\npub fn list_mem(x: &u32, mut ls: &List<u32>) -> bool {\r\n    while let List::Cons(y, tl) = ls {\r\n        if *y == *x {\r\n            return true;\r\n        } else {\r\n            ls = tl;\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\n/// Same as [list_nth_mut] but with a loop\r\npub fn list_nth_mut_loop<T>(mut ls: &mut List<T>, mut i: u32) -> &mut T {\r\n    while let List::Cons(x, tl) = ls {\r\n        if i == 0 {\r\n            return x;\r\n        } else {\r\n            ls = tl;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n/// Same as [list_nth_mut_loop] but with shared borrows\r\npub fn list_nth_shared_loop<T>(mut ls: &List<T>, mut i: u32) -> &T {\r\n    while let List::Cons(x, tl) = ls {\r\n        if i == 0 {\r\n            return x;\r\n        } else {\r\n            ls = tl;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\npub fn get_elem_mut(slots: &mut Vec<List<usize>>, x: usize) -> &mut usize {\r\n    let mut ls = &mut slots[0];\r\n    loop {\r\n        match ls {\r\n            List::Nil => panic!(),\r\n            List::Cons(y, tl) => {\r\n                if *y == x {\r\n                    return y;\r\n                } else {\r\n                    ls = tl;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub fn get_elem_shared(slots: &Vec<List<usize>>, x: usize) -> &usize {\r\n    let mut ls = &slots[0];\r\n    loop {\r\n        match ls {\r\n            List::Nil => panic!(),\r\n            List::Cons(y, tl) => {\r\n                if *y == x {\r\n                    return y;\r\n                } else {\r\n                    ls = tl;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub fn id_mut<T>(ls: &mut List<T>) -> &mut List<T> {\r\n    ls\r\n}\r\n\r\npub fn id_shared<T>(ls: &List<T>) -> &List<T> {\r\n    ls\r\n}\r\n\r\n/// Small variation of [list_nth_mut_loop]\r\npub fn list_nth_mut_loop_with_id<T>(ls: &mut List<T>, mut i: u32) -> &mut T {\r\n    let mut ls = id_mut(ls);\r\n    while let List::Cons(x, tl) = ls {\r\n        if i == 0 {\r\n            return x;\r\n        } else {\r\n            ls = tl;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n/// Small variation of [list_nth_shared_loop]\r\npub fn list_nth_shared_loop_with_id<T>(ls: &List<T>, mut i: u32) -> &T {\r\n    let mut ls = id_shared(ls);\r\n    while let List::Cons(x, tl) = ls {\r\n        if i == 0 {\r\n            return x;\r\n        } else {\r\n            ls = tl;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n/// Same as [list_nth_mut] but on a pair of lists.\r\n///\r\n/// This test checks that we manage to decompose a loop into disjoint regions.\r\npub fn list_nth_mut_loop_pair<'a, 'b, T>(\r\n    mut ls0: &'a mut List<T>,\r\n    mut ls1: &'b mut List<T>,\r\n    mut i: u32,\r\n) -> (&'a mut T, &'b mut T) {\r\n    loop {\r\n        match (ls0, ls1) {\r\n            (List::Nil, _) | (_, List::Nil) => {\r\n                panic!()\r\n            }\r\n            (List::Cons(x0, tl0), List::Cons(x1, tl1)) => {\r\n                if i == 0 {\r\n                    return (x0, x1);\r\n                } else {\r\n                    ls0 = tl0;\r\n                    ls1 = tl1;\r\n                    i -= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Same as [list_nth_mut_loop_pair] but with shared borrows.\r\npub fn list_nth_shared_loop_pair<'a, 'b, T>(\r\n    mut ls0: &'a List<T>,\r\n    mut ls1: &'b List<T>,\r\n    mut i: u32,\r\n) -> (&'a T, &'b T) {\r\n    loop {\r\n        match (ls0, ls1) {\r\n            (List::Nil, _) | (_, List::Nil) => {\r\n                panic!()\r\n            }\r\n            (List::Cons(x0, tl0), List::Cons(x1, tl1)) => {\r\n                if i == 0 {\r\n                    return (x0, x1);\r\n                } else {\r\n                    ls0 = tl0;\r\n                    ls1 = tl1;\r\n                    i -= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Same as [list_nth_mut_loop_pair] but this time we force the two loop\r\n/// regions to be merged.\r\npub fn list_nth_mut_loop_pair_merge<'a, T>(\r\n    mut ls0: &'a mut List<T>,\r\n    mut ls1: &'a mut List<T>,\r\n    mut i: u32,\r\n) -> (&'a mut T, &'a mut T) {\r\n    while let (List::Cons(x0, tl0), List::Cons(x1, tl1)) = (ls0, ls1) {\r\n        if i == 0 {\r\n            return (x0, x1);\r\n        } else {\r\n            ls0 = tl0;\r\n            ls1 = tl1;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n/// Same as [list_nth_mut_loop_pair_merge] but with shared borrows.\r\npub fn list_nth_shared_loop_pair_merge<'a, T>(\r\n    mut ls0: &'a List<T>,\r\n    mut ls1: &'a List<T>,\r\n    mut i: u32,\r\n) -> (&'a T, &'a T) {\r\n    while let (List::Cons(x0, tl0), List::Cons(x1, tl1)) = (ls0, ls1) {\r\n        if i == 0 {\r\n            return (x0, x1);\r\n        } else {\r\n            ls0 = tl0;\r\n            ls1 = tl1;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n/// Mixing mutable and shared borrows.\r\npub fn list_nth_mut_shared_loop_pair<'a, 'b, T>(\r\n    mut ls0: &'a mut List<T>,\r\n    mut ls1: &'b List<T>,\r\n    mut i: u32,\r\n) -> (&'a mut T, &'b T) {\r\n    while let (List::Cons(x0, tl0), List::Cons(x1, tl1)) = (ls0, ls1) {\r\n        if i == 0 {\r\n            return (x0, x1);\r\n        } else {\r\n            ls0 = tl0;\r\n            ls1 = tl1;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n/// Same as [list_nth_mut_shared_loop_pair] but this time we force the two loop\r\n/// regions to be merged.\r\npub fn list_nth_mut_shared_loop_pair_merge<'a, T>(\r\n    mut ls0: &'a mut List<T>,\r\n    mut ls1: &'a List<T>,\r\n    mut i: u32,\r\n) -> (&'a mut T, &'a T) {\r\n    while let (List::Cons(x0, tl0), List::Cons(x1, tl1)) = (ls0, ls1) {\r\n        if i == 0 {\r\n            return (x0, x1);\r\n        } else {\r\n            ls0 = tl0;\r\n            ls1 = tl1;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n/// Same as [list_nth_mut_shared_loop_pair], but we switched the positions of\r\n/// the mutable and shared borrows.\r\npub fn list_nth_shared_mut_loop_pair<'a, 'b, T>(\r\n    mut ls0: &'a List<T>,\r\n    mut ls1: &'b mut List<T>,\r\n    mut i: u32,\r\n) -> (&'a T, &'b mut T) {\r\n    while let (List::Cons(x0, tl0), List::Cons(x1, tl1)) = (ls0, ls1) {\r\n        if i == 0 {\r\n            return (x0, x1);\r\n        } else {\r\n            ls0 = tl0;\r\n            ls1 = tl1;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n/// Same as [list_nth_mut_shared_loop_pair_merge], but we switch the positions of\r\n/// the mutable and shared borrows.\r\npub fn list_nth_shared_mut_loop_pair_merge<'a, T>(\r\n    mut ls0: &'a List<T>,\r\n    mut ls1: &'a mut List<T>,\r\n    mut i: u32,\r\n) -> (&'a T, &'a mut T) {\r\n    while let (List::Cons(x0, tl0), List::Cons(x1, tl1)) = (ls0, ls1) {\r\n        if i == 0 {\r\n            return (x0, x1);\r\n        } else {\r\n            ls0 = tl0;\r\n            ls1 = tl1;\r\n            i -= 1;\r\n        }\r\n    }\r\n    panic!()\r\n}\r\n\r\n// We do not use the input borrow inside the loop\r\n#[allow(clippy::empty_loop)]\r\npub fn ignore_input_mut_borrow(_a: &mut u32, mut i: u32) {\r\n    while i > 0 {\r\n        i -= 1;\r\n    }\r\n}\r\n\r\n// We do not use the input borrow inside the loop\r\n#[allow(clippy::empty_loop)]\r\npub fn incr_ignore_input_mut_borrow(a: &mut u32, mut i: u32) {\r\n    *a += 1;\r\n    while i > 0 {\r\n        i -= 1;\r\n    }\r\n}\r\n\r\n// We do not use the input borrow inside the loop\r\n#[allow(clippy::empty_loop)]\r\npub fn ignore_input_shared_borrow(_a: &mut u32, mut i: u32) {\r\n    while i > 0 {\r\n        i -= 1;\r\n    }\r\n}",
    "filename": "RustLoop.rs",
    "filepath": null,
    "folder_id": null,
    "user_id": 460160
  }
}