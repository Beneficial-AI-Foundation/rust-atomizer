{
  "65031": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! **INTERNALS:** Pluggable implementations for different architectures.\n//!\n//! The backend code is split into two parts: a serial backend,\n//! and a vector backend.\n//!\n//! The [`serial`] backend contains 32- and 64-bit implementations of\n//! field arithmetic and scalar arithmetic, as well as implementations\n//! of point operations using the mixed-model strategy (passing\n//! between different curve models depending on the operation).\n//!\n//! The [`vector`] backend contains implementations of vectorized\n//! field arithmetic, used to implement point operations using a novel\n//! implementation strategy derived from parallel formulas of Hisil,\n//! Wong, Carter, and Dawson.\n//!\n//! Because the two strategies give rise to different curve models,\n//! it's not possible to reuse exactly the same scalar multiplication\n//! code (or to write it generically), so both serial and vector\n//! backends contain matching implementations of scalar multiplication\n//! algorithms.  These are intended to be selected by a `#[cfg]`-based\n//! type alias.\n//!\n//! The [`vector`] backend is selected by the `simd_backend` cargo\n//! feature; it uses the [`serial`] backend for non-vectorized operations.\n\nuse crate::EdwardsPoint;\nuse crate::Scalar;\n\npub mod serial;\n\n// #[cfg(curve25519_dalek_backend = \"simd\")]\n// pub mod vector;\n\n#[derive(Copy, Clone)]\nenum BackendKind {\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // Avx2,\n    // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    // Avx512,\n    Serial,\n}\n\n#[inline]\nfn get_selected_backend() -> BackendKind {\n    // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    // {\n    //     cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n    //     let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n    //     if token_avx512.get() {\n    //         return BackendKind::Avx512;\n    //     }\n    // }\n\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // {\n    //     cpufeatures::new!(cpuid_avx2, \"avx2\");\n    //     let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n    //     if token_avx2.get() {\n    //         return BackendKind::Avx2;\n    //     }\n    // }\n\n    BackendKind::Serial\n}\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub fn pippenger_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 =>\n        //     vector::scalar_mul::pippenger::spec_avx2::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 =>\n        //     vector::scalar_mul::pippenger::spec_avx512ifma_avx512vl::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        BackendKind::Serial =>\n            serial::scalar_mul::pippenger::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n    }\n}\n\n#[cfg(feature = \"alloc\")]\npub(crate) enum VartimePrecomputedStraus {\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus),\n    // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    // Avx512ifma(\n    //     vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus,\n    // ),\n    Scalar(serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus),\n}\n\n#[cfg(feature = \"alloc\")]\nimpl VartimePrecomputedStraus {\n    pub fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<EdwardsPoint>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match get_selected_backend() {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // BackendKind::Avx2 =>\n            //     VartimePrecomputedStraus::Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus::new(static_points)),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // BackendKind::Avx512 =>\n            //     VartimePrecomputedStraus::Avx512ifma(vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus::new(static_points)),\n            BackendKind::Serial =>\n                VartimePrecomputedStraus::Scalar(serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus::new(static_points))\n        }\n    }\n\n    /// Return the number of static points in the precomputation.\n    pub fn len(&self) -> usize {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.len(),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.len(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.len(),\n        }\n    }\n\n    /// Determine if the precomputation is empty.\n    pub fn is_empty(&self) -> bool {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.is_empty(),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.is_empty(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.is_empty(),\n        }\n    }\n\n    pub fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: core::borrow::Borrow<Scalar>,\n        K: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }\n}\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub fn straus_multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator,\n    J::Item: core::borrow::Borrow<EdwardsPoint>,\n{\n    use crate::traits::MultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::multiscalar_mul::<I, J>(scalars, points)\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub fn straus_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::optional_multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::optional_multiscalar_mul::<\n        //         I,\n        //         J,\n        //     >(scalars, points)\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::optional_multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}\n\n/// Perform constant-time, variable-base scalar multiplication.\npub fn variable_base_mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => vector::scalar_mul::variable_base::spec_avx2::mul(point, scalar),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::variable_base::spec_avx512ifma_avx512vl::mul(point, scalar)\n        // }\n        BackendKind::Serial => serial::scalar_mul::variable_base::mul(point, scalar),\n    }\n}\n\n/// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.\n#[allow(non_snake_case)]\npub fn vartime_double_base_mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => vector::scalar_mul::vartime_double_base::spec_avx2::mul(a, A, b),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::vartime_double_base::spec_avx512ifma_avx512vl::mul(a, A, b)\n        // }\n        BackendKind::Serial => serial::scalar_mul::vartime_double_base::mul(a, A, b),\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/mod.rs",
    "filepath": null,
    "folder_id": 16163,
    "user_id": 460160
  },
  "65032": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Internal curve representations which are not part of the public API.\n//!\n//! # Curve representations\n//!\n//! Internally, we use several different models for the curve.  Here\n//! is a sketch of the relationship between the models, following [a\n//! post][smith-moderncrypto]\n//! by Ben Smith on the `moderncrypto` mailing list.  This is also briefly\n//! discussed in section 2.5 of [_Montgomery curves and their\n//! arithmetic_][costello-smith-2017] by Costello and Smith.\n//!\n//! Begin with the affine equation for the curve,\n//! $$\n//!     -x\\^2 + y\\^2 = 1 + dx\\^2y\\^2.\n//! $$\n//! Next, pass to the projective closure \\\\(\\mathbb P\\^1 \\times \\mathbb\n//! P\\^1 \\\\) by setting \\\\(x=X/Z\\\\), \\\\(y=Y/T.\\\\)  Clearing denominators\n//! gives the model\n//! $$\n//!     -X\\^2T\\^2 + Y\\^2Z\\^2 = Z\\^2T\\^2 + dX\\^2Y\\^2.\n//! $$\n//! In `curve25519-dalek`, this is represented as the `CompletedPoint`\n//! struct.\n//! To map from \\\\(\\mathbb P\\^1 \\times \\mathbb P\\^1 \\\\), a product of\n//! two lines, to \\\\(\\mathbb P\\^3\\\\), we use the [Segre\n//! embedding](https://en.wikipedia.org/wiki/Segre_embedding)\n//! $$\n//!     \\sigma : ((X:Z),(Y:T)) \\mapsto (XY:XT:ZY:ZT).\n//! $$\n//! Using coordinates \\\\( (W_0:W_1:W_2:W_3) \\\\) for \\\\(\\mathbb P\\^3\\\\),\n//! the image \\\\(\\sigma (\\mathbb P\\^1 \\times \\mathbb P\\^1) \\\\) is the\n//! surface defined by \\\\( W_0 W_3 = W_1 W_2 \\\\), and under \\\\(\n//! \\sigma\\\\), the equation above becomes\n//! $$\n//!     -W\\_1\\^2 + W\\_2\\^2 = W\\_3\\^2 + dW\\_0\\^2,\n//! $$\n//! so that the curve is given by the pair of equations\n//! $$\n//! \\begin{aligned}\n//!     -W\\_1\\^2 + W\\_2\\^2 &= W\\_3\\^2 + dW\\_0\\^2, \\\\\\\\  W_0 W_3 &= W_1 W_2.\n//! \\end{aligned}\n//! $$\n//! Up to variable naming, this is exactly the \"extended\" curve model\n//! introduced in [_Twisted Edwards Curves\n//! Revisited_][hisil-wong-carter-dawson-2008] by Hisil, Wong, Carter,\n//! and Dawson.  In `curve25519-dalek`, it is represented as the\n//! `EdwardsPoint` struct.  We can map from \\\\(\\mathbb P\\^3 \\\\) to\n//! \\\\(\\mathbb P\\^2 \\\\) by sending \\\\( (W\\_0:W\\_1:W\\_2:W\\_3) \\\\) to \\\\(\n//! (W\\_1:W\\_2:W\\_3) \\\\).  Notice that\n//! $$\n//!     \\frac {W\\_1} {W\\_3} = \\frac {XT} {ZT} = \\frac X Z = x,\n//! $$\n//! and\n//! $$\n//!     \\frac {W\\_2} {W\\_3} = \\frac {YZ} {ZT} = \\frac Y T = y,\n//! $$\n//! so this is the same as if we had started with the affine model\n//! and passed to \\\\( \\mathbb P\\^2 \\\\) by setting \\\\( x = W\\_1 / W\\_3\n//! \\\\), \\\\(y = W\\_2 / W\\_3 \\\\).\n//! Up to variable naming, this is the projective representation\n//! introduced in [_Twisted Edwards\n//! Curves_][bernstein-birkner-joye-lange-peters-2008] by Bernstein,\n//! Birkner, Joye, Lange, and Peters.  In `curve25519-dalek`, it is\n//! represented by the `ProjectivePoint` struct.\n//!\n//! # Passing between curve models\n//!\n//! Although the \\\\( \\mathbb P\\^3 \\\\) model provides faster addition\n//! formulas, the \\\\( \\mathbb P\\^2 \\\\) model provides faster doubling\n//! formulas.  Hisil, Wong, Carter, and Dawson therefore suggest mixing\n//! coordinate systems for scalar multiplication, attributing the idea\n//! to [a 1998 paper][cohen-miyaji-ono-1998] of Cohen, Miyagi, and Ono.\n//!\n//! Their suggestion is to vary the formulas used by context, using a\n//! \\\\( \\mathbb P\\^2 \\rightarrow \\mathbb P\\^2 \\\\) doubling formula when\n//! a doubling is followed\n//! by another doubling, a \\\\( \\mathbb P\\^2 \\rightarrow \\mathbb P\\^3 \\\\)\n//! doubling formula when a doubling is followed by an addition, and\n//! computing point additions using a \\\\( \\mathbb P\\^3 \\times \\mathbb P\\^3\n//! \\rightarrow \\mathbb P\\^2 \\\\) formula.\n//!\n//! The `ref10` reference implementation of [Ed25519][ed25519], by\n//! Bernstein, Duif, Lange, Schwabe, and Yang, tweaks\n//! this strategy, factoring the addition formulas through the\n//! completion \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1 \\\\), so that the\n//! output of an addition or doubling always lies in \\\\( \\mathbb P\\^1 \\times\n//! \\mathbb P\\^1\\\\), and the choice of which formula to use is replaced\n//! by a choice of whether to convert the result to \\\\( \\mathbb P\\^2 \\\\)\n//! or \\\\(\\mathbb P\\^3 \\\\).  However, this tweak is not described in\n//! their paper, only in their software.\n//!\n//! Our naming for the `CompletedPoint` (\\\\(\\mathbb P\\^1 \\times \\mathbb\n//! P\\^1 \\\\)), `ProjectivePoint` (\\\\(\\mathbb P\\^2 \\\\)), and\n//! `EdwardsPoint` (\\\\(\\mathbb P\\^3 \\\\)) structs follows the naming in\n//! Adam Langley's [Golang ed25519][agl-ed25519] implementation, which\n//! `curve25519-dalek` was originally derived from.\n//!\n//! Finally, to accelerate readditions, we use two cached point formats\n//! in \"Niels coordinates\", named for Niels Duif,\n//! one for the affine model and one for the \\\\( \\mathbb P\\^3 \\\\) model:\n//!\n//! * `AffineNielsPoint`: \\\\( (y+x, y-x, 2dxy) \\\\)\n//! * `ProjectiveNielsPoint`: \\\\( (Y+X, Y-X, Z, 2dXY) \\\\)\n//!\n//! [smith-moderncrypto]: https://moderncrypto.org/mail-archive/curves/2016/000807.html\n//! [costello-smith-2017]: https://eprint.iacr.org/2017/212\n//! [hisil-wong-carter-dawson-2008]: https://www.iacr.org/archive/asiacrypt2008/53500329/53500329.pdf\n//! [bernstein-birkner-joye-lange-peters-2008]: https://eprint.iacr.org/2008/013\n//! [cohen-miyaji-ono-1998]: https://link.springer.com/content/pdf/10.1007%2F3-540-49649-1_6.pdf\n//! [ed25519]: https://eprint.iacr.org/2011/368\n//! [agl-ed25519]: https://github.com/agl/ed25519\n\n#![allow(non_snake_case)]\n\nuse core::fmt::Debug;\nuse core::ops::{Add, Neg, Sub};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::Zeroize;\n\nuse crate::constants;\n\nuse crate::edwards::EdwardsPoint;\nuse crate::field::FieldElement;\nuse crate::traits::ValidityCheck;\n\n// ------------------------------------------------------------------------\n// Internal point representations\n// ------------------------------------------------------------------------\n\n/// A `ProjectivePoint` is a point \\\\((X:Y:Z)\\\\) on the \\\\(\\mathbb\n/// P\\^2\\\\) model of the curve.\n/// A point \\\\((x,y)\\\\) in the affine model corresponds to\n/// \\\\((x:y:1)\\\\).\n///\n/// More details on the relationships between the different curve models\n/// can be found in the module-level documentation.\n#[allow(missing_docs)]\n#[derive(Copy, Clone)]\npub struct ProjectivePoint {\n    pub X: FieldElement,\n    pub Y: FieldElement,\n    pub Z: FieldElement,\n}\n\n/// A `CompletedPoint` is a point \\\\(((X:Z), (Y:T))\\\\) on the \\\\(\\mathbb\n/// P\\^1 \\times \\mathbb P\\^1 \\\\) model of the curve.\n/// A point (x,y) in the affine model corresponds to \\\\( ((x:1),(y:1))\n/// \\\\).\n///\n/// More details on the relationships between the different curve models\n/// can be found in the module-level documentation.\n#[derive(Copy, Clone)]\n#[allow(missing_docs)]\npub struct CompletedPoint {\n    pub X: FieldElement,\n    pub Y: FieldElement,\n    pub Z: FieldElement,\n    pub T: FieldElement,\n}\n\n/// A pre-computed point in the affine model for the curve, represented as\n/// \\\\((y+x, y-x, 2dxy)\\\\) in \"Niels coordinates\".\n///\n/// More details on the relationships between the different curve models\n/// can be found in the module-level documentation.\n// Safe to derive Eq because affine coordinates.\n#[derive(Copy, Clone, Eq, PartialEq)]\n#[allow(missing_docs)]\npub struct AffineNielsPoint {\n    pub y_plus_x: FieldElement,\n    pub y_minus_x: FieldElement,\n    pub xy2d: FieldElement,\n}\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for AffineNielsPoint {\n//     fn zeroize(&mut self) {\n//         self.y_plus_x.zeroize();\n//         self.y_minus_x.zeroize();\n//         self.xy2d.zeroize();\n//     }\n// }\n\n/// A pre-computed point on the \\\\( \\mathbb P\\^3 \\\\) model for the\n/// curve, represented as \\\\((Y+X, Y-X, Z, 2dXY)\\\\) in \"Niels coordinates\".\n///\n/// More details on the relationships between the different curve models\n/// can be found in the module-level documentation.\n#[derive(Copy, Clone)]\n#[allow(missing_docs)]\npub struct ProjectiveNielsPoint {\n    pub Y_plus_X: FieldElement,\n    pub Y_minus_X: FieldElement,\n    pub Z: FieldElement,\n    pub T2d: FieldElement,\n}\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for ProjectiveNielsPoint {\n//     fn zeroize(&mut self) {\n//         self.Y_plus_X.zeroize();\n//         self.Y_minus_X.zeroize();\n//         self.Z.zeroize();\n//         self.T2d.zeroize();\n//     }\n// }\n\n// ------------------------------------------------------------------------\n// Constructors\n// ------------------------------------------------------------------------\n\nuse crate::traits::Identity;\n\nimpl Identity for ProjectivePoint {\n    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n        }\n    }\n}\n\nimpl Identity for ProjectiveNielsPoint {\n    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for ProjectiveNielsPoint {\n    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }\n}\n\nimpl Identity for AffineNielsPoint {\n    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for AffineNielsPoint {\n    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Validity checks (for debugging, not CT)\n// ------------------------------------------------------------------------\n\nimpl ValidityCheck for ProjectivePoint {\n    fn is_valid(&self) -> bool {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        let ZZZZ = ZZ.square();\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n\n        lhs == rhs\n    }\n}\n\n// ------------------------------------------------------------------------\n// Constant-time assignment\n// ------------------------------------------------------------------------\n\nimpl ConditionallySelectable for ProjectiveNielsPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }\n}\n\nimpl ConditionallySelectable for AffineNielsPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }\n}\n\n// ------------------------------------------------------------------------\n// Point conversions\n// ------------------------------------------------------------------------\n\nimpl ProjectivePoint {\n    /// Convert this point from the \\\\( \\mathbb P\\^2 \\\\) model to the\n    /// \\\\( \\mathbb P\\^3 \\\\) model.\n    ///\n    /// This costs \\\\(3 \\mathrm M + 1 \\mathrm S\\\\).\n    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.Z,\n            Y: &self.Y * &self.Z,\n            Z: self.Z.square(),\n            T: &self.X * &self.Y,\n        }\n    }\n}\n\nimpl CompletedPoint {\n    /// Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1\n    /// \\\\) model to the \\\\( \\mathbb P\\^2 \\\\) model.\n    ///\n    /// This costs \\\\(3 \\mathrm M \\\\).\n    pub fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n        }\n    }\n\n    /// Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1\n    /// \\\\) model to the \\\\( \\mathbb P\\^3 \\\\) model.\n    ///\n    /// This costs \\\\(4 \\mathrm M \\\\).\n    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n            T: &self.X * &self.Y,\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Doubling\n// ------------------------------------------------------------------------\n\nimpl ProjectivePoint {\n    /// Double this point: return self + self\n    pub fn double(&self) -> CompletedPoint {\n        // Double()\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ2 = self.Z.square2();\n        let X_plus_Y = &self.X + &self.Y;\n        let X_plus_Y_sq = X_plus_Y.square();\n        let YY_plus_XX = &YY + &XX;\n        let YY_minus_XX = &YY - &XX;\n\n        CompletedPoint {\n            X: &X_plus_Y_sq - &YY_plus_XX,\n            Y: YY_plus_XX,\n            Z: YY_minus_XX,\n            T: &ZZ2 - &YY_minus_XX,\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Addition and Subtraction\n// ------------------------------------------------------------------------\n\n// XXX(hdevalence) These were doc(hidden) so they don't appear in the\n// public API docs.\n// However, that prevents them being used with --document-private-items,\n// so comment out the doc(hidden) for now until this is resolved\n//\n// upstream rust issue: https://github.com/rust-lang/rust/issues/46380\n//#[doc(hidden)]\nimpl<'a> Add<&'a ProjectiveNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn add(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.Y_plus_X;\n        let MM = &Y_minus_X * &other.Y_minus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &ZZ2 + &TT2d,\n            T: &ZZ2 - &TT2d,\n        }\n    }\n}\n\n//#[doc(hidden)]\nimpl<'a> Sub<&'a ProjectiveNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn sub(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.Y_minus_X;\n        let MP = &Y_minus_X * &other.Y_plus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &ZZ2 - &TT2d,\n            T: &ZZ2 + &TT2d,\n        }\n    }\n}\n\n//#[doc(hidden)]\nimpl<'a> Add<&'a AffineNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn add(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.y_plus_x;\n        let MM = &Y_minus_X * &other.y_minus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &Z2 + &Txy2d,\n            T: &Z2 - &Txy2d,\n        }\n    }\n}\n\n//#[doc(hidden)]\nimpl<'a> Sub<&'a AffineNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn sub(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.y_minus_x;\n        let MP = &Y_minus_X * &other.y_plus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &Z2 - &Txy2d,\n            T: &Z2 + &Txy2d,\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Negation\n// ------------------------------------------------------------------------\n\nimpl Neg for &ProjectiveNielsPoint {\n    type Output = ProjectiveNielsPoint;\n\n    fn neg(self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: self.Y_minus_X,\n            Y_minus_X: self.Y_plus_X,\n            Z: self.Z,\n            T2d: -(&self.T2d),\n        }\n    }\n}\n\nimpl Neg for &AffineNielsPoint {\n    type Output = AffineNielsPoint;\n\n    fn neg(self) -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: self.y_minus_x,\n            y_minus_x: self.y_plus_x,\n            xy2d: -(&self.xy2d),\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Debug traits\n// ------------------------------------------------------------------------\n\nimpl Debug for ProjectivePoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectivePoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z\n        )\n    }\n}\n\nimpl Debug for CompletedPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"CompletedPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }\n}\n\nimpl Debug for AffineNielsPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"AffineNielsPoint{{\\n\\ty_plus_x: {:?},\\n\\ty_minus_x: {:?},\\n\\txy2d: {:?}\\n}}\",\n            &self.y_plus_x, &self.y_minus_x, &self.xy2d\n        )\n    }\n}\n\nimpl Debug for ProjectiveNielsPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectiveNielsPoint{{\\n\\tY_plus_X: {:?},\\n\\tY_minus_X: {:?},\\n\\tZ: {:?},\\n\\tT2d: {:?}\\n}}\",\n            &self.Y_plus_X, &self.Y_minus_X, &self.Z, &self.T2d\n        )\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "filepath": null,
    "folder_id": 16165,
    "user_id": 460160
  },
  "65033": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2019 Henry de Valence.\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Precomputation for Straus's method.\n\n#![allow(non_snake_case)]\n\nuse alloc::vec::Vec;\n\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\n\nuse crate::backend::serial::curve_models::{\n    AffineNielsPoint, CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n};\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::Identity;\nuse crate::traits::VartimePrecomputedMultiscalarMul;\nuse crate::window::{NafLookupTable5, NafLookupTable8};\n\n#[allow(missing_docs)]\npub struct VartimePrecomputedStraus {\n    static_lookup_tables: Vec<NafLookupTable8<AffineNielsPoint>>,\n}\n\nimpl VartimePrecomputedMultiscalarMul for VartimePrecomputedStraus {\n    type Point = EdwardsPoint;\n\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self {\n            static_lookup_tables: static_points\n                .into_iter()\n                .map(|P| NafLookupTable8::<AffineNielsPoint>::from(P.borrow()))\n                .collect(),\n        }\n    }\n\n    fn len(&self) -> usize {\n        self.static_lookup_tables.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.static_lookup_tables.is_empty()\n    }\n\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        let static_nafs = static_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n        let dynamic_nafs: Vec<_> = dynamic_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n\n        let dynamic_lookup_tables = dynamic_points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let sp = self.static_lookup_tables.len();\n        let dp = dynamic_lookup_tables.len();\n        assert!(sp >= static_nafs.len());\n        assert_eq!(dp, dynamic_nafs.len());\n\n        // We could save some doublings by looking for the highest\n        // nonzero NAF coefficient, but since we might have a lot of\n        // them to search, it's not clear it's worthwhile to check.\n        let mut S = ProjectivePoint::identity();\n        for j in (0..256).rev() {\n            let mut R: CompletedPoint = S.double();\n\n            for i in 0..dp {\n                let t_ij = dynamic_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &dynamic_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &dynamic_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            #[allow(clippy::needless_range_loop)]\n            for i in 0..static_nafs.len() {\n                let t_ij = static_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &self.static_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &self.static_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            S = R.as_projective();\n        }\n\n        Some(S.as_extended())\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "filepath": null,
    "folder_id": 16166,
    "user_id": 460160
  },
  "65034": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2019 Oleg Andreev\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Oleg Andreev <oleganza@gmail.com>\n\n//! Implementation of a variant of Pippenger's algorithm.\n\n#![allow(non_snake_case)]\n\nuse alloc::vec::Vec;\n\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\n\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::VartimeMultiscalarMul;\n\n/// Implements a version of Pippenger's algorithm.\n///\n/// The algorithm works as follows:\n///\n/// Let `n` be a number of point-scalar pairs.\n/// Let `w` be a window of bits (6..8, chosen based on `n`, see cost factor).\n///\n/// 1. Prepare `2^(w-1) - 1` buckets with indices `[1..2^(w-1))` initialized with identity points.\n///    Bucket 0 is not needed as it would contain points multiplied by 0.\n/// 2. Convert scalars to a radix-`2^w` representation with signed digits in `[-2^w/2, 2^w/2]`.\n///    Note: only the last digit may equal `2^w/2`.\n/// 3. Starting with the last window, for each point `i=[0..n)` add it to a bucket indexed by\n///    the point's scalar's value in the window.\n/// 4. Once all points in a window are sorted into buckets, add buckets by multiplying each\n///    by their index. Efficient way of doing it is to start with the last bucket and compute two sums:\n///    intermediate sum from the last to the first, and the full sum made of all intermediate sums.\n/// 5. Shift the resulting sum of buckets by `w` bits by using `w` doublings.\n/// 6. Add to the return value.\n/// 7. Repeat the loop.\n///\n/// Approximate cost w/o wNAF optimizations (A = addition, D = doubling):\n///\n/// ```ascii\n/// cost = (n*A + 2*(2^w/2)*A + w*D + A)*256/w\n///          |          |       |     |   |\n///          |          |       |     |   looping over 256/w windows\n///          |          |       |     adding to the result\n///    sorting points   |       shifting the sum by w bits (to the next window, starting from last window)\n///    one by one       |\n///    into buckets     adding/subtracting all buckets\n///                     multiplied by their indexes\n///                     using a sum of intermediate sums\n/// ```\n///\n/// For large `n`, dominant factor is (n*256/w) additions.\n/// However, if `w` is too big and `n` is not too big, then `(2^w/2)*A` could dominate.\n/// Therefore, the optimal choice of `w` grows slowly as `n` grows.\n///\n/// This algorithm is adapted from section 4 of <https://eprint.iacr.org/2012/549.pdf>.\npub struct Pippenger;\n\nimpl VartimeMultiscalarMul for Pippenger {\n    type Point = EdwardsPoint;\n\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::Identity;\n\n        let mut scalars = scalars.into_iter();\n        let size = scalars.by_ref().size_hint().0;\n\n        // Digit width in bits. As digit width grows,\n        // number of point additions goes down, but amount of\n        // buckets and bucket additions grows exponentially.\n        let w = if size < 500 {\n            6\n        } else if size < 800 {\n            7\n        } else {\n            8\n        };\n\n        let max_digit: usize = 1 << w;\n        let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n        let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n        // Collect optimized scalars and points in buffers for repeated access\n        // (scanning the whole set per digit position).\n        let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n        let points = points\n            .into_iter()\n            .map(|p| p.map(|P| P.as_projective_niels()));\n\n        let scalars_points = scalars\n            .zip(points)\n            .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n            .collect::<Option<Vec<_>>>()?;\n\n        // Prepare 2^w/2 buckets.\n        // buckets[i] corresponds to a multiplication factor (i+1).\n        let mut buckets: Vec<_> = (0..buckets_count)\n            .map(|_| EdwardsPoint::identity())\n            .collect();\n\n        let mut columns = (0..digits_count).rev().map(|digit_index| {\n            // Clear the buckets when processing another digit.\n            for bucket in &mut buckets {\n                *bucket = EdwardsPoint::identity();\n            }\n\n            // Iterate over pairs of (point, scalar)\n            // and add/sub the point to the corresponding bucket.\n            // Note: if we add support for precomputed lookup tables,\n            // we'll be adding/subtracting point premultiplied by `digits[i]` to buckets[0].\n            for (digits, pt) in scalars_points.iter() {\n                // Widen digit so that we don't run into edge cases when w=8.\n                let digit = digits[digit_index] as i16;\n                match digit.cmp(&0) {\n                    Ordering::Greater => {\n                        let b = (digit - 1) as usize;\n                        buckets[b] = (&buckets[b] + pt).as_extended();\n                    }\n                    Ordering::Less => {\n                        let b = (-digit - 1) as usize;\n                        buckets[b] = (&buckets[b] - pt).as_extended();\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            // Add the buckets applying the multiplication factor to each bucket.\n            // The most efficient way to do that is to have a single sum with two running sums:\n            // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n            //\n            // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n            //   C\n            //   C B\n            //   C B A   Sum = C + (C+B) + (C+B+A)\n            let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n            let mut buckets_sum = buckets[buckets_count - 1];\n            for i in (0..(buckets_count - 1)).rev() {\n                buckets_intermediate_sum += buckets[i];\n                buckets_sum += buckets_intermediate_sum;\n            }\n\n            buckets_sum\n        });\n\n        // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n        let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n        Some(columns.fold(hi_column, |total, p| total.mul_by_pow_2(w as u32) + p))\n    }\n}\n\n// #[cfg(test)]\n// mod test {\n//     use super::*;\n//     use crate::constants;\n\n//     #[test]\n//     fn test_vartime_pippenger() {\n//         // Reuse points across different tests\n//         let mut n = 512;\n//         let x = Scalar::from(2128506u64).invert();\n//         let y = Scalar::from(4443282u64).invert();\n//         let points: Vec<_> = (0..n)\n//             .map(|i| constants::ED25519_BASEPOINT_POINT * Scalar::from(1 + i as u64))\n//             .collect();\n//         let scalars: Vec<_> = (0..n)\n//             .map(|i| x + (Scalar::from(i as u64) * y)) // fast way to make ~random but deterministic scalars\n//             .collect();\n\n//         let premultiplied: Vec<EdwardsPoint> = scalars\n//             .iter()\n//             .zip(points.iter())\n//             .map(|(sc, pt)| sc * pt)\n//             .collect();\n\n//         while n > 0 {\n//             let scalars = &scalars[0..n].to_vec();\n//             let points = &points[0..n].to_vec();\n//             let control: EdwardsPoint = premultiplied[0..n].iter().sum();\n\n//             let subject = Pippenger::vartime_multiscalar_mul(scalars.clone(), points.clone());\n\n//             assert_eq!(subject.compress(), control.compress());\n\n//             n /= 2;\n//         }\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "filepath": null,
    "folder_id": 16166,
    "user_id": 460160
  },
  "65035": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Implementation of the interleaved window method, also known as Straus' method.\n\n#![allow(non_snake_case)]\n\nuse alloc::vec::Vec;\n\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\n\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::MultiscalarMul;\nuse crate::traits::VartimeMultiscalarMul;\n\n/// Perform multiscalar multiplication by the interleaved window\n/// method, also known as Straus' method (since it was apparently\n/// [first published][solution] by Straus in 1964, as a solution to [a\n/// problem][problem] posted in the American Mathematical Monthly in\n/// 1963).\n///\n/// It is easy enough to reinvent, and has been repeatedly.  The basic\n/// idea is that when computing\n/// \\\\[\n/// Q = s_1 P_1 + \\cdots + s_n P_n\n/// \\\\]\n/// by means of additions and doublings, the doublings can be shared\n/// across the \\\\( P_i \\\\\\).\n///\n/// We implement two versions, a constant-time algorithm using fixed\n/// windows and a variable-time algorithm using sliding windows.  They\n/// are slight variations on the same idea, and are described in more\n/// detail in the respective implementations.\n///\n/// [solution]: https://www.jstor.org/stable/2310929\n/// [problem]: https://www.jstor.org/stable/2312273\npub struct Straus {}\n\nimpl MultiscalarMul for Straus {\n    type Point = EdwardsPoint;\n\n    /// Constant-time Straus using a fixed window of size \\\\(4\\\\).\n    ///\n    /// Our goal is to compute\n    /// \\\\[\n    /// Q = s_1 P_1 + \\cdots + s_n P_n.\n    /// \\\\]\n    ///\n    /// For each point \\\\( P_i \\\\), precompute a lookup table of\n    /// \\\\[\n    /// P_i, 2P_i, 3P_i, 4P_i, 5P_i, 6P_i, 7P_i, 8P_i.\n    /// \\\\]\n    ///\n    /// For each scalar \\\\( s_i \\\\), compute its radix-\\\\(2^4\\\\)\n    /// signed digits \\\\( s_{i,j} \\\\), i.e.,\n    /// \\\\[\n    ///    s_i = s_{i,0} + s_{i,1} 16^1 + ... + s_{i,63} 16^{63},\n    /// \\\\]\n    /// with \\\\( -8 \\leq s_{i,j} < 8 \\\\).  Since \\\\( 0 \\leq |s_{i,j}|\n    /// \\leq 8 \\\\), we can retrieve \\\\( s_{i,j} P_i \\\\) from the\n    /// lookup table with a conditional negation: using signed\n    /// digits halves the required table size.\n    ///\n    /// Then as in the single-base fixed window case, we have\n    /// \\\\[\n    /// \\begin{aligned}\n    /// s_i P_i &= P_i (s_{i,0} +     s_{i,1} 16^1 + \\cdots +     s_{i,63} 16^{63})   \\\\\\\\\n    /// s_i P_i &= P_i s_{i,0} + P_i s_{i,1} 16^1 + \\cdots + P_i s_{i,63} 16^{63}     \\\\\\\\\n    /// s_i P_i &= P_i s_{i,0} + 16(P_i s_{i,1} + 16( \\cdots +16P_i s_{i,63})\\cdots )\n    /// \\end{aligned}\n    /// \\\\]\n    /// so each \\\\( s_i P_i \\\\) can be computed by alternately adding\n    /// a precomputed multiple \\\\( P_i s_{i,j} \\\\) of \\\\( P_i \\\\) and\n    /// repeatedly doubling.\n    ///\n    /// Now consider the two-dimensional sum\n    /// \\\\[\n    /// \\begin{aligned}\n    /// s\\_1 P\\_1 &=& P\\_1 s\\_{1,0} &+& 16 (P\\_1 s\\_{1,1} &+& 16 ( \\cdots &+& 16 P\\_1 s\\_{1,63}&) \\cdots ) \\\\\\\\\n    ///     +     & &      +        & &      +            & &             & &     +            &           \\\\\\\\\n    /// s\\_2 P\\_2 &=& P\\_2 s\\_{2,0} &+& 16 (P\\_2 s\\_{2,1} &+& 16 ( \\cdots &+& 16 P\\_2 s\\_{2,63}&) \\cdots ) \\\\\\\\\n    ///     +     & &      +        & &      +            & &             & &     +            &           \\\\\\\\\n    /// \\vdots    & &  \\vdots       & &   \\vdots          & &             & &  \\vdots          &           \\\\\\\\\n    ///     +     & &      +        & &      +            & &             & &     +            &           \\\\\\\\\n    /// s\\_n P\\_n &=& P\\_n s\\_{n,0} &+& 16 (P\\_n s\\_{n,1} &+& 16 ( \\cdots &+& 16 P\\_n s\\_{n,63}&) \\cdots )\n    /// \\end{aligned}\n    /// \\\\]\n    /// The sum of the left-hand column is the result \\\\( Q \\\\); by\n    /// computing the two-dimensional sum on the right column-wise,\n    /// top-to-bottom, then right-to-left, we need to multiply by \\\\(\n    /// 16\\\\) only once per column, sharing the doublings across all\n    /// of the input points.\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        use crate::backend::serial::curve_models::ProjectiveNielsPoint;\n        use crate::traits::Identity;\n        use crate::window::LookupTable;\n\n        let lookup_tables: Vec<_> = points\n            .into_iter()\n            .map(|point| LookupTable::<ProjectiveNielsPoint>::from(point.borrow()))\n            .collect();\n\n        // This puts the scalar digits into a heap-allocated Vec.\n        // To ensure that these are erased, pass ownership of the Vec into a\n        // Zeroizing wrapper.\n        #[cfg_attr(not(feature = \"zeroize\"), allow(unused_mut))]\n        let mut scalar_digits: Vec<_> = scalars\n            .into_iter()\n            .map(|s| s.borrow().as_radix_16())\n            .collect();\n\n        let mut Q = EdwardsPoint::identity();\n        for j in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            let it = scalar_digits.iter().zip(lookup_tables.iter());\n            for (s_i, lookup_table_i) in it {\n                // R_i = s_{i,j} * P_i\n                let R_i = lookup_table_i.select(s_i[j]);\n                // Q = Q + R_i\n                Q = (&Q + &R_i).as_extended();\n            }\n        }\n\n        // #[cfg(feature = \"zeroize\")]\n        // zeroize::Zeroize::zeroize(&mut scalar_digits);\n\n        Q\n    }\n}\n\nimpl VartimeMultiscalarMul for Straus {\n    type Point = EdwardsPoint;\n\n    /// Variable-time Straus using a non-adjacent form of width \\\\(5\\\\).\n    ///\n    /// This is completely similar to the constant-time code, but we\n    /// use a non-adjacent form for the scalar, and do not do table\n    /// lookups in constant time.\n    ///\n    /// The non-adjacent form has signed, odd digits.  Using only odd\n    /// digits halves the table size (since we only need odd\n    /// multiples), or gives fewer additions for the same table size.\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::backend::serial::curve_models::{\n            CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n        };\n        use crate::traits::Identity;\n        use crate::window::NafLookupTable5;\n\n        let nafs: Vec<_> = scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect();\n\n        let lookup_tables = points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let mut r = ProjectivePoint::identity();\n\n        for i in (0..256).rev() {\n            let mut t: CompletedPoint = r.double();\n\n            for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                match naf[i].cmp(&0) {\n                    Ordering::Greater => {\n                        t = &t.as_extended() + &lookup_table.select(naf[i] as usize)\n                    }\n                    Ordering::Less => t = &t.as_extended() - &lookup_table.select(-naf[i] as usize),\n                    Ordering::Equal => {}\n                }\n            }\n\n            r = t.as_projective();\n        }\n\n        Some(r.as_extended())\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "filepath": null,
    "folder_id": 16166,
    "user_id": 460160
  },
  "65036": {
    "text": "#![allow(non_snake_case)]\n\nuse crate::backend::serial::curve_models::ProjectiveNielsPoint;\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::Identity;\nuse crate::window::LookupTable;\n\n/// Perform constant-time, variable-base scalar multiplication.\n#[rustfmt::skip] // keep alignment of explanatory comments\npub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n    let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);\n    // Setting s = scalar, compute\n    //\n    //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n    //\n    // with `-8  s_i < 8` for `0  i < 63` and `-8  s_63  8`.\n    // This decomposition requires s < 2^255, which is guaranteed by Scalar invariant #1.\n    let scalar_digits = scalar.as_radix_16();\n    // Compute s*P as\n    //\n    //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n    //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n    //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n    //\n    // We sum right-to-left.\n\n    // Unwrap first loop iteration to save computing 16*identity\n    let mut tmp2;\n    let mut tmp3 = EdwardsPoint::identity();\n    let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);\n    // Now tmp1 = s_63*P in P1xP1 coords\n    for i in (0..63).rev() {\n        tmp2 = tmp1.as_projective(); // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();   // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }\n    tmp1.as_extended()\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
    "filepath": null,
    "folder_id": 16166,
    "user_id": 460160
  },
  "65037": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Implementations of various scalar multiplication algorithms.\n//!\n//! Note that all of these implementations use serial code for field\n//! arithmetic with the multi-model strategy described in the\n//! `curve_models` module.  The vectorized AVX2 backend has its own\n//! scalar multiplication implementations, since it only uses one\n//! curve model.\n\n#[allow(missing_docs)]\npub mod variable_base;\n\n#[allow(missing_docs)]\npub mod vartime_double_base;\n\n#[cfg(feature = \"alloc\")]\npub mod straus;\n\n#[cfg(feature = \"alloc\")]\npub mod precomputed_straus;\n\n#[cfg(feature = \"alloc\")]\npub mod pippenger;\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/mod.rs",
    "filepath": null,
    "folder_id": 16166,
    "user_id": 460160
  },
  "65038": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n#![allow(non_snake_case)]\n\nuse core::cmp::Ordering;\n\nuse crate::backend::serial::curve_models::{ProjectiveNielsPoint, ProjectivePoint};\nuse crate::constants;\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::Identity;\nuse crate::window::NafLookupTable5;\n\n/// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.\npub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    let a_naf = a.non_adjacent_form(5);\n\n    #[cfg(feature = \"precomputed-tables\")]\n    let b_naf = b.non_adjacent_form(8);\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let b_naf = b.non_adjacent_form(5);\n\n    // Find starting index\n    let mut i: usize = 255;\n    for j in (0..256).rev() {\n        i = j;\n        if a_naf[i] != 0 || b_naf[i] != 0 {\n            break;\n        }\n    }\n\n    let table_A = NafLookupTable5::<ProjectiveNielsPoint>::from(A);\n    #[cfg(feature = \"precomputed-tables\")]\n    let table_B = &constants::AFFINE_ODD_MULTIPLES_OF_BASEPOINT;\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let table_B =\n        &NafLookupTable5::<ProjectiveNielsPoint>::from(&constants::ED25519_BASEPOINT_POINT);\n\n    let mut r = ProjectivePoint::identity();\n    loop {\n        let mut t = r.double();\n\n        match a_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_A.select(a_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_A.select(-a_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        match b_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_B.select(b_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_B.select(-b_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        r = t.as_projective();\n\n        if i == 0 {\n            break;\n        }\n        i -= 1;\n    }\n\n    r.as_extended()\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
    "filepath": null,
    "folder_id": 16166,
    "user_id": 460160
  },
  "65039": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Serial implementations of field, scalar, point arithmetic.\n//!\n//! When the vector backend is disabled, the crate uses the mixed-model strategy\n//! for implementing point operations and scalar multiplication; see the\n//! [`curve_models`] and [`scalar_mul`] documentation for more information.\n//!\n//! When the vector backend is enabled, the field and scalar\n//! implementations are still used for non-vectorized operations.\n\n// use cfg_if::cfg_if;\n\n// cfg_if! {\n//     if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n\n//         #[cfg(curve25519_dalek_bits = \"32\")]\n//         #[doc(hidden)]\n//         pub mod fiat_u32;\n\n//         #[cfg(curve25519_dalek_bits = \"64\")]\n//         #[doc(hidden)]\n//         pub mod fiat_u64;\n\n//     } else {\n\n//         #[cfg(curve25519_dalek_bits = \"32\")]\n//         #[doc(hidden)]\n//         pub mod u32;\n\n//         #[cfg(curve25519_dalek_bits = \"64\")]\n//         #[doc(hidden)]\n//         pub mod u64;\n\n//     }\n// }\n\npub mod u64;\n\npub mod curve_models;\n\npub mod scalar_mul;\n",
    "filename": "curve25519-dalek/src/backend/serial/mod.rs",
    "filepath": null,
    "folder_id": 16164,
    "user_id": 460160
  },
  "65040": {
    "text": "// field.rs\n#![allow(unused)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::arithmetic::power::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::prelude::*;\n\nuse super::common_verus::*;\nuse super::field_lemmas::*;\n\n// ADAPTED CODE LINES: X.0 globally replaced with X.limbs\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64; // 2^51  -1\n\n// Basic properties of LOW_51_BIT_MASK:\n// - It's the value of low_bits_mask (spec function defined in vstd and used in its lemmas)\n// - it's less than 2^51\npub proof fn l51_bit_mask_lt()\n    ensures\n        LOW_51_BIT_MASK == low_bits_mask(51),\n        LOW_51_BIT_MASK < (1u64 << 51) as nat,\n{\n    lemma2_to64_rest();\n    assert(LOW_51_BIT_MASK < (1u64 << 51) as nat) by (compute);\n}\n\n// Masking with low_bits_mask(51) gives a value bounded by 2^51\npub proof fn masked_lt_51(v: u64)\n    ensures\n        v & LOW_51_BIT_MASK < (1u64 << 51),\n{\n    l51_bit_mask_lt(); // LOW_51_BIT_MASK == low_bits_mask(51)\n    masked_lt(v, 51);\n}\n\n// lemma_div_and_mod specialization for k = 51, using LOW_51_BIT_MASK == low_bits_mask(51)\npub proof fn lemma_div_and_mod_51(ai:u64, bi: u64, v: u64)\n    requires\n        ai == v >> 51,\n        bi == v & LOW_51_BIT_MASK\n    ensures\n        ai == v / (pow2(51) as u64),\n        bi == v % (pow2(51) as u64),\n        v == ai * pow2(51) + bi\n{\n    l51_bit_mask_lt(); // LOW_51_BIT_MASK == low_bits_mask(51)\n    lemma_div_and_mod(ai, bi, v, 51);\n}\n\npub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & LOW_51_BIT_MASK]\n        (x as u64) & LOW_51_BIT_MASK == x & (LOW_51_BIT_MASK as u128)\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}\n\npub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5]) {\n    let r = [\n        ((limbs[0] & LOW_51_BIT_MASK) + (limbs[4] >> 51) * 19) as u64,\n        ((limbs[1] & LOW_51_BIT_MASK) + (limbs[0] >> 51)) as u64,\n        ((limbs[2] & LOW_51_BIT_MASK) + (limbs[1] >> 51)) as u64,\n        ((limbs[3] & LOW_51_BIT_MASK) + (limbs[2] >> 51)) as u64,\n        ((limbs[4] & LOW_51_BIT_MASK) + (limbs[3] >> 51)) as u64,\n    ];\n    r\n}\n\n// Each component of spec_reduce is bounded.\n// The reason we _don't_ write\n// ensures forall |i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52)\n// is that the solver treats `spec_reduce`` above as symbolic and does _not_ instantiate e.g.\n// ((limbs[4] & LOW_51_BIT_MASK) + (limbs[3] >> 51)) as u64 < (1u64 << 52)\npub proof fn lemma_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & LOW_51_BIT_MASK) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & LOW_51_BIT_MASK) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & LOW_51_BIT_MASK) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & LOW_51_BIT_MASK) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & LOW_51_BIT_MASK) + (limbs[3] >> 51)) < (1u64 << 52)\n\n{\n    // \\A i. limbs[i] < 2^13\n    shifted_lt(limbs[0], 51);\n    shifted_lt(limbs[1], 51);\n    shifted_lt(limbs[2], 51);\n    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & LOW_51_BIT_MASK < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}\n\npub proof fn lemma_reduce(limbs: [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52),\n        // Suppose l = (l0, l1, l2, l3, l4) are the input limbs.\n        // They represent a number\n        // e(l) =  l0 + l1 * 2^51 + l2 * 2^102 + l3 * 2^153 + l4 * 2^204\n        // in Z_p, for p = 2^255 - 19\n        // reduce(l) returns v = (v0, v1, v2, v3, v4), such that\n        // v0 = 19 * a4 + b0\n        // v1 =      a0 + b1\n        // v2 =      a1 + b2\n        // v3 =      a2 + b3\n        // v4 =      a3 + b4\n        // where ai = li >> 51 and bi = li & LOW_51_BIT_MASK\n        // we can reformulate this as ai = li / 2^51 (flooring division) and bi = li % 2^51\n        // Using the following identity connecting integer division and remainder:\n        // x = y * (x / y) + x % y\n        // we can see that li = ai * 2^51 + bi\n        // Plugging the above identities into the equations for v, we can observe that\n        // e(v) = e(l) - p * (l4 >> 51)\n        // IOW, e(reduce(l)) = e(l) (mod p)\n        // additionally, if all limbs are below 2^51, reduce(l) = l\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (spec_reduce(limbs) =~= limbs),\n        as_nat(spec_reduce(limbs)) == as_nat(limbs) - p() * (limbs[4] >> 51)\n{\n\n    // -----\n    // reduce identity for small limbs\n\n    // Can't seem to reference r within this proof block, we reconstruct it here\n    let rr: [u64; 5] = spec_reduce(limbs);\n\n    assert((forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) ==> (rr =~= limbs)) by {\n        if (forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) {\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] & LOW_51_BIT_MASK == limbs[i] by {\n                l51_bit_mask_lt(); // LOW_51_BIT_MASK = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_low_bits_mask_is_mod(limbs[i], 51);\n                lemma_small_mod(limbs[i] as nat, pow2(51));\n            }\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] >> 51 == 0 by {\n                l51_bit_mask_lt(); // LOW_51_BIT_MASK = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_shr_is_div(limbs[i], 51);\n                lemma_basic_div(limbs[i] as int, pow2(51) as int);\n            }\n        }\n    }\n\n    // -- as_nat identity\n\n    // ai = limbs[i] / 2^52\n    let a0 = (limbs[0] >> 51);\n    let a1 = (limbs[1] >> 51);\n    let a2 = (limbs[2] >> 51);\n    let a3 = (limbs[3] >> 51);\n    let a4 = (limbs[4] >> 51);\n\n    // bi = limbs[i] % 2^52\n    let b0 = (limbs[0] & LOW_51_BIT_MASK);\n    let b1 = (limbs[1] & LOW_51_BIT_MASK);\n    let b2 = (limbs[2] & LOW_51_BIT_MASK);\n    let b3 = (limbs[3] & LOW_51_BIT_MASK);\n    let b4 = (limbs[4] & LOW_51_BIT_MASK);\n\n    lemma_boundaries(limbs);\n\n    // distribute\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(102) * a1 + pow2(102) * b2 +\n        pow2(153) * a2 + pow2(153) * b3 +\n        pow2(204) * a3 + pow2(204) * b4\n    ) by {\n        lemma_mul_is_distributive_add(pow2( 51) as int, a0 as int, b1 as int);\n        lemma_mul_is_distributive_add(pow2(102) as int, a1 as int, b2 as int);\n        lemma_mul_is_distributive_add(pow2(153) as int, a2 as int, b3 as int);\n        lemma_mul_is_distributive_add(pow2(204) as int, a3 as int, b4 as int);\n    }\n\n    // factor out\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(51) * (pow2(51) * a1) + pow2(102) * b2 +\n        pow2(102) * (pow2(51) * a2) + pow2(153) * b3 +\n        pow2(153) * (pow2(51) * a3) + pow2(204) * b4\n    ) by {\n        lemma_two_factoring_51(51, a1);\n        lemma_two_factoring_51(102, a2);\n        lemma_two_factoring_51(153, a3);\n    }\n\n    // change groupings\n    assert(as_nat(rr) ==\n        (b0 + pow2(51) * a0) +\n        pow2(51) * (b1 + pow2(51) * a1) +\n        pow2(102) * (b2 + pow2(51) * a2) +\n        pow2(153) * (b3 + pow2(51) * a3) +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_mul_is_distributive_add(pow2( 51) as int, b1 as int, pow2(51) * a1);\n        lemma_mul_is_distributive_add(pow2(102) as int, b2 as int, pow2(51) * a2);\n        lemma_mul_is_distributive_add(pow2(153) as int, b3 as int, pow2(51) * a3);\n    }\n\n    // invoke div/mod identity\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a0, b0, limbs[0]);\n        lemma_div_and_mod_51(a1, b1, limbs[1]);\n        lemma_div_and_mod_51(a2, b2, limbs[2]);\n        lemma_div_and_mod_51(a3, b3, limbs[3]);\n    }\n\n    // Add missing limbs[4] parts\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * limbs[4] - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a4, b4, limbs[4]);\n        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204)* (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }\n    }\n\n    // The solver can collect components of as_nat(limbs) automatically:\n    // as_nat(rr) == as_nat(limbs) - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    // ... as well as pull in minus\n    // as_nat(rr) == as_nat(limbs) - (pow2(204) * (pow2(51) * a4 ) - 19 * a4)\n\n    // collect components of p() * a4\n    assert(pow2(204) * (pow2(51) * a4) - 19 * a4 == p() * a4) by {\n        lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, a4 as int);\n        lemma_pow2_adds(204, 51);\n        lemma_mul_is_distributive_sub_other_way(a4 as int, pow2(255) as int, 19 );\n        pow255_gt_19(); // we need to prove 2^255 - 19 doesn't underflow\n    }\n}\n\n/* MANUALLY moved outside, named return value */\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        0 <= r <= (u64::MAX as nat),\n{\n        (input[i] as u64)\n    | ((input[i + 1] as u64) << 8)\n    | ((input[i + 2] as u64) << 16)\n    | ((input[i + 3] as u64) << 24)\n    | ((input[i + 4] as u64) << 32)\n    | ((input[i + 5] as u64) << 40)\n    | ((input[i + 6] as u64) << 48)\n    | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX\n\n{\n    proof {\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl FieldElement51 {\n    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }\n\n    // Modified to use direct struct\n    pub const ZERO: FieldElement51 = FieldElement51{limbs: [0, 0, 0, 0, 0]};\n    pub const ONE: FieldElement51 = FieldElement51{limbs: [1, 0, 0, 0, 0]};\n    pub const MINUS_ONE: FieldElement51 = FieldElement51{limbs: [\n        2251799813685228,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n    ]};\n\n    /// Invert the sign of this field element\n    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, as_nat((c0, c, c, c, c)) = p, so\n            // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n            // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            as_nat(self.limbs) == 16 * p() - as_nat(old(self).limbs) - p() * ((36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n            (as_nat(self.limbs) + as_nat(old(self).limbs)) % p() == 0\n    {\n        proof {\n            let c0 = (pow2(51) - 19);\n            let c  = (pow2(51) - 1);\n            lemma2_to64_rest(); // get pow2(51)\n            // solver knows 36028797018963664u64 == 16 * c0\n            // solver knows 36028797018963952u64 == 16 * c;\n\n            assert forall |i: int| 0 <= i < 5 implies old(self).limbs[i] < 16 * c0 by {\n                shift_is_pow2(51);\n            }\n\n            // Introduce 16p as a vector\n            let v = [(16 * c0) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64];\n\n            assert(as_nat(v) == 16 * p()) by {\n                // by definition of as_nat\n                assert( as_nat(v) ==\n                    16 * c0 +\n                    pow2(51) * (16 * c) +\n                    pow2(102) * (16 * c) +\n                    pow2(153) * (16 * c) +\n                    pow2(204) * (16 * c)\n                );\n\n                // solver can reorder factors and pull out 16 on its own\n                // ...\n\n                // Write out `c`s and sum up powers\n                assert( p() ==\n                    c0 +\n                    pow2(51) * c +\n                    pow2(102) * c +\n                    pow2(153) * c +\n                    pow2(204) * c\n                ) by {\n                    lemma_pow2_adds(51, 51);\n                    lemma_pow2_adds(51, 102);\n                    lemma_pow2_adds(51, 153);\n                    lemma_pow2_adds(51, 204);\n                }\n            }\n\n            let l0 = old(self).limbs[0];\n            let l1 = old(self).limbs[1];\n            let l2 = old(self).limbs[2];\n            let l3 = old(self).limbs[3];\n            let l4 = old(self).limbs[4];\n\n            assert(as_nat([\n                (16 * c0 - l0) as u64,\n                (16 * c - l1) as u64,\n                (16 * c - l2) as u64,\n                (16 * c - l3) as u64,\n                (16 * c - l4) as u64,\n                ]) == as_nat(v) - as_nat(old(self).limbs)\n            ) by {\n                lemma_as_nat_sub(v, old(self).limbs);\n            }\n\n            let k = (16 * c - l4) as u64 >> 51;\n\n            assert(\n                16 * p() - as_nat(old(self).limbs) - p() * k + as_nat(old(self).limbs)\n                ==\n                p() * (16 - k)\n            ) by {\n                lemma_mul_is_distributive_sub(p() as int, 16, k as int)\n            }\n\n            assert((p() * (16 - k)) as nat % p() == 0) by {\n                assert(k <= 16) by {\n                    assert(k <= (16 * pow2(51)) as u64 >> 51) by {\n                        lemma_shr_le_u64((16 * c - l4) as u64, (16 * pow2(51)) as u64, 51);\n                    }\n                    // 16 * 2^51 / 2^51 = 16\n                    assert(((16 * 0x8000000000000) as u64 >> 51) == 16) by (compute);\n                }\n                lemma_mod_multiples_basic((16 - k) as int, p() as int);\n            }\n        }\n        // See commentary in the Sub impl: (copied below)\n            // To avoid underflow, first add a multiple of p.\n            // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n            //\n            // If we could statically track the bitlengths of the limbs\n            // of every FieldElement51, we could choose a multiple of p\n            // just bigger than _rhs and avoid having to do a reduction.\n            //\n            // Since we don't yet have type-level integers to do this, we\n            // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.limbs[0],\n            36028797018963952u64 - self.limbs[1],\n            36028797018963952u64 - self.limbs[2],\n            36028797018963952u64 - self.limbs[3],\n            36028797018963952u64 - self.limbs[4],\n        ]);\n        self.limbs = neg.limbs;\n    }\n\n    /// Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).\n    #[inline(always)]\n    fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n        ensures\n            r.limbs == spec_reduce(limbs),\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n            (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n            as_nat(r.limbs) == as_nat(limbs) - p() * (limbs[4] >> 51),\n            as_nat(r.limbs) % p() == as_nat(limbs) % p()\n    {\n        proof {\n            lemma_boundaries(limbs);\n            lemma_reduce(limbs);\n            pow255_gt_19();\n            lemma_mod_multiples_vanish((limbs[4] >> 51) as int, as_nat(spec_reduce(limbs)) as int, p() as int);\n        }\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }\n\n    /// Load a `FieldElement51` from the low 255 bits of a 256-bit\n    /// input.\n    ///\n    /// # Warning\n    ///\n    /// This function does not check that the input used the canonical\n    /// representative.  It masks the high bit, but it will happily\n    /// decode 2^255 - 18 to 1.  Applications that require a canonical\n    /// encoding of every field element should decode, re-encode to\n    /// the canonical encoding, and check that the input was\n    /// canonical.\n    ///\n    #[rustfmt::skip] // keep alignment of bit shifts\n    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)\n        ensures\n            true\n            // TODO:\n            // as_nat(r.limbs) =?= as_nat_32_u8(bytes)\n    {\n        proof {\n            l51_bit_mask_lt() // No over/underflow in the below let-def\n        }\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{ limbs:\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ]}\n    }\n\n    /// Serialize this `FieldElement51` to a 32-byte array.  The\n    /// encoding is canonical.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_bytes(self) -> (r: [u8; 32])\n        ensures\n            true // No overflow\n            // TODO:\n            // as_nat(self.limbs) =?= as_nat_32_u8(r),\n            // canonical encoding\n            // forall|i: int| 0 <= i < 5 ==> r[i] < (1u64 << 51)\n    {\n        proof {\n            let l = spec_reduce(self.limbs);\n            lemma_reduce(self.limbs);\n\n            let q0 = (l[0] + 19) as u64 >> 51;\n            let q1 = (l[1] + q0) as u64 >> 51;\n            let q2 = (l[2] + q1) as u64 >> 51;\n            let q3 = (l[3] + q2) as u64 >> 51;\n            let q4 = (l[4] + q3) as u64 >> 51;\n\n            assert(19 < (1u64 << 52)) by (bit_vector);\n            lemma_add_then_shift(l[0], 19);\n            lemma_add_then_shift(l[1], q0);\n            lemma_add_then_shift(l[2], q1);\n            lemma_add_then_shift(l[3], q2);\n            lemma_add_then_shift(l[4], q3);\n\n            let l0 = (l[0] + 19 * q4) as u64;\n            let l1 = (l[1] + (l0 >> 51)) as u64;\n            let l2 = (l[2] + (l1 >> 51)) as u64;\n            let l3 = (l[3] + (l2 >> 51)) as u64;\n            let l4 = (l[3] + (l3 >> 51)) as u64;\n\n            assert( 19 * q4 < 1u64 << 7) by {\n                // Explicit values for pow2(k) for k < 64\n                lemma2_to64();\n                shift_is_pow2(5); // now we know 19 < 1u64 << 5 for free\n                shift_is_pow2(2);\n                shift_is_pow2(7);\n                lemma_pow2_adds(5, 2);\n            }\n            assert(((1u64 << 7)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            assert(((1u64 << 13)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            shifted_lt(l0, 51);\n            shifted_lt(l1, 51);\n            shifted_lt(l2, 51);\n            shifted_lt(l3, 51);\n\n            l51_bit_mask_lt();\n\n            // TODO\n            // let rr = [\n            //     l0 & LOW_51_BIT_MASK,\n            //     l1 & LOW_51_BIT_MASK,\n            //     l2 & LOW_51_BIT_MASK,\n            //     l3 & LOW_51_BIT_MASK,\n            //     l4 & LOW_51_BIT_MASK\n            // ];\n\n            // let r = [\n            //     rr[0]                           as u8,\n            //     (rr[0] >>  8)                    as u8,\n            //     (rr[0] >> 16)                    as u8,\n            //     (rr[0] >> 24)                    as u8,\n            //     (rr[0] >> 32)                    as u8,\n            //     (rr[0] >> 40)                    as u8,\n            //     ((rr[0] >> 48) | (rr[1] << 3)) as u8,\n            //     (rr[1] >>  5)                    as u8,\n            //     (rr[1] >> 13)                    as u8,\n            //     (rr[1] >> 21)                    as u8,\n            //     (rr[1] >> 29)                    as u8,\n            //     (rr[1] >> 37)                    as u8,\n            //     ((rr[1] >> 45) | (rr[2] << 6)) as u8,\n            //     (rr[2] >>  2)                    as u8,\n            //     (rr[2] >> 10)                    as u8,\n            //     (rr[2] >> 18)                    as u8,\n            //     (rr[2] >> 26)                    as u8,\n            //     (rr[2] >> 34)                    as u8,\n            //     (rr[2] >> 42)                    as u8,\n            //     ((rr[2] >> 50) | (rr[3] << 1)) as u8,\n            //     (rr[3] >>  7)                    as u8,\n            //     (rr[3] >> 15)                    as u8,\n            //     (rr[3] >> 23)                    as u8,\n            //     (rr[3] >> 31)                    as u8,\n            //     (rr[3] >> 39)                    as u8,\n            //     ((rr[3] >> 47) | (rr[4] << 4)) as u8,\n            //     (rr[4] >>  4)                    as u8,\n            //     (rr[4] >> 12)                    as u8,\n            //     (rr[4] >> 20)                    as u8,\n            //     (rr[4] >> 28)                    as u8,\n            //     (rr[4] >> 36)                    as u8,\n            //     (rr[4] >> 44)                    as u8\n            // ];\n\n        }\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.limbs).limbs;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n        // debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }\n\n    /// Given `k > 0`, return `self^(2^k)`.\n    #[rustfmt::skip] // keep alignment of c* calculations\n    pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n        requires\n            k > 0, // debug_assert!( k > 0 );\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54 // 51 + b for b = 3\n        ensures\n            forall |i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(k as nat)) as nat % p()\n    {\n        let mut a: [u64; 5] = self.limbs;\n\n        // pre-loop invariant, i = 0\n        proof {\n            assert(as_nat(a) == pow(as_nat(self.limbs) as int, pow2(0))) by {\n                lemma2_to64(); // pow2(0) = 1\n                lemma_pow1(as_nat(self.limbs) as int);\n            }\n        }\n\n        for i in 0..k\n            invariant\n                forall |i: int| 0 <= i < 5 ==> a[i] < 1u64 << 54,\n                as_nat(a) % p() == pow(as_nat(self.limbs) as int, pow2(i as nat)) as nat % p(),\n        {\n            proof {\n                pow255_gt_19(); // p > 0\n                lemma2_to64_rest(); // pow2(51 | 54)\n                shift_is_pow2(54);\n\n                let bound = 1u64 << 54;\n                let bound19 = (19 * bound) as u64;\n                let bound_sq = 1u128 << 108;\n\n                // u64 to u128 conversion forces extra assert\n                assert( (1u64 << 54) * ((19 * (1u64 << 54)) as u64) == 19 * (1u128 << 108)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 54) as u128) == (1u128 << 108)) by (bit_vector);\n\n                // precond for term_product_bounds\n                assert( 19 * bound <= u64::MAX) by {\n                    assert( 19 * (1u64 << 54) <= u64::MAX) by (compute);\n                }\n                // If a[i] < 2^54 then a[i] * a[j] < 2^108 and a[i] * (19 * a[j]) < 19 * 2^108\n                term_product_bounds(a, bound);\n\n                // ci_0 < 77 * (1u128 << 108)\n                c_i_0_bounded(a, bound);\n\n                // precond for c_i_shift_bounded\n                assert(77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51)) by {\n                    assert( 77 * (1u128 << 108)+ u64::MAX <= ((u64::MAX as u128) << 51)) by (compute);\n                }\n                // ci >> 51 <= u64::MAX\n                c_i_shift_bounded(a, bound);\n\n                // bv arithmetic\n                assert(19 < (1u64 << 5)) by (bit_vector);\n                assert((1u64 << 51) < (1u64 << 52)) by (bit_vector);\n                assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 54) < (1u64 << 59)) by (bit_vector);\n                assert((1u64 << 54) * (1u64 << 5) == (1u64 << 59)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 59) as u128) == (1u128 << 113)) by (bit_vector);\n\n                let a3_19 = (19 * a[3]) as u64;\n                let a4_19 = (19 * a[4]) as u64;\n\n                // NOTE: we assert the properties derived from c_i_0_bounded\n                // and c_i_shift_bounded after every variable declaration,\n                // to trigger the solver instantiation\n\n                // ci_0 defs\n\n                let c0_0: u128 = c0_0_val(a); // a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19\n                assert(c0_0 < 77 * bound_sq);\n\n                let c1_0: u128 = c1_0_val(a); // a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19\n                assert(c1_0 < 59 * bound_sq);\n\n                let c2_0: u128 = c2_0_val(a); // a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19\n                assert(c2_0 < 41 * bound_sq);\n\n                let c3_0: u128 =  c3_0_val(a); // a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]\n                assert(c3_0 < 23 * bound_sq);\n\n                let c4_0: u128 =  c4_0_val(a); // a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]\n                assert(c4_0 < 5 * bound_sq);\n\n                // ci defs\n\n                let c1 = c1_val(a); // (c1_0 + ((c0_0 >> 51) as u64) as u128) as u128;\n                assert((c1 >> 51) <= (u64::MAX as u128));\n\n                let c2 = c2_val(a); // (c2_0 + ((c1 >> 51) as u64) as u128) as u128;\n                assert((c2 >> 51) <= (u64::MAX as u128));\n\n                let c3 = c3_val(a); // (c3_0 + ((c2 >> 51) as u64) as u128) as u128;\n                assert((c3 >> 51) <= (u64::MAX as u128));\n\n                let c4 = c4_val(a); // (c4_0 + ((c3 >> 51) as u64) as u128) as u128;\n                assert((c4 >> 51) <= (u64::MAX as u128));\n\n                let a0_0 = (c0_0 as u64) & LOW_51_BIT_MASK;\n                // a0_0 < (1u64 << 51)\n                masked_lt_51(c0_0 as u64);\n\n                let a1_0 = (c1 as u64) & LOW_51_BIT_MASK;\n                // a1_0 < (1u64 << 51)\n                masked_lt_51(c1 as u64);\n\n                let a2 = (c2 as u64) & LOW_51_BIT_MASK;\n                // a2 < (1u64 << 51)\n                masked_lt_51(c2 as u64);\n\n                let a3 = (c3 as u64) & LOW_51_BIT_MASK;\n                // a3 < (1u64 << 51)\n                masked_lt_51(c3 as u64);\n\n                let carry: u64 = (c4 >> 51) as u64;\n                let a4 = (c4 as u64) & LOW_51_BIT_MASK;\n                // a4 < (1u64 << 51)\n                masked_lt_51(c4 as u64);\n\n                assert(c4 <= c4_0 + (u64::MAX as u128));\n                lemma_shr_51_le(c4, (5 * bound_sq + (u64::MAX as u128)) as u128 );\n\n                // From the comments below:\n                // c4 < 2^110.33  so that carry < 2^59.33\n                // and\n                // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n\n                // ceil(2^59.33)\n                let pow2_5933 = 724618875532318195u64;\n\n                assert((5 * (1u128 << 108) + (u64::MAX as u128)) as u128 >> 51 < (pow2_5933 as u128)) by (compute);\n                assert(carry < pow2_5933);\n\n                // a[0] += carry * 19 fits in u64\n                assert(a0_0 + carry * 19 <= u64::MAX) by {\n                    assert((1u64 << 51) + 19 * pow2_5933 <= u64::MAX) by (compute);\n                }\n\n                let a0_1 = (a0_0 + carry * 19) as u64;\n\n                lemma_shr_51_le(a0_1 as u128, u64::MAX as u128);\n                assert( ((u64::MAX as u128) >> 51) < (1u64 << 13) ) by (compute);\n\n                // a1_0 < (1u64 << 51)\n                assert((1u64 << 51) + (1u64 << 13) < (1u64 << 52)) by (compute);\n\n                // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n                assert(a1_0 + (a0_1 >> 51) < (1u64 << 52));\n                let a1_1 = (a1_0 + (a0_1 >> 51)) as u64;\n\n                let a0_2 = a0_1 & LOW_51_BIT_MASK;\n                // a0_2 < (1u64 << 51)\n                masked_lt_51(a0_1 as u64);\n\n                //---- end of no-overflow proof ----\n                // Loop invariant: after i loops we have as_nat(a) % p = as_nat(self.limbs) ^ (2 ^ i) % p\n                let a_hat = [a0_2, a1_1, a2, a3, a4];\n                assert(as_nat(a_hat) % p() == (as_nat(a) * as_nat(a)) % p() ) by {\n                    // it suffices to prove as_nat(a_hat) == (as_nat(a))^2 (mod p)\n                    // let s = pow2(51) for brevity\n\n                    // By definition, as_nat(a_hat) = a0_2 + s * a1_1 + s^2 * a2 + s^3 * a3 + s^4 * a4\n                    // a0_2 + s * a1_1 cancel out terms via the div/mod identity:\n                    assert(as_nat(a_hat) ==\n                        a0_1 +\n                        pow2(51) * a1_0 +\n                        pow2(102) * a2 +\n                        pow2(153) * a3 +\n                        pow2(204) * a4\n                    ) by {\n                        // a0_2 + s * a1_1 =\n                        // a0_1 % s  + s * (a1_0 + s * (a0_1 / s)) =\n                        // s * a1_0 + [s * (a0_1 / s) + a0_1 % s] = (by the div-mod identity)\n                        // s * a1_0 + a0_1\n                        assert(a0_2 + pow2(51) * a1_1 == a0_1 + pow2(51) * a1_0) by {\n                            lemma_div_and_mod_51((a0_1 >> 51), a0_2, a0_1);\n                        }\n                    }\n\n                    // Next, we replace all _ & LOW_BITS_MASK with (mod s)\n                    assert(as_nat(a_hat) ==\n                        ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry +\n                        pow2( 51) * ((c1 as u64) % (pow2(51) as u64)) +\n                        pow2(102) * ((c2 as u64) % (pow2(51) as u64)) +\n                        pow2(153) * ((c3 as u64) % (pow2(51) as u64)) +\n                        pow2(204) * ((c4 as u64) % (pow2(51) as u64))\n                    ) by {\n                        l51_bit_mask_lt();\n\n                        assert((pow2(51) as u64) == (pow2(51) as u128));\n\n                        assert(a0_1 == ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry) by {\n                            lemma_u64_low_bits_mask_is_mod(c0_0 as u64, 51);\n                        }\n\n                        assert(a1_0 == (c1 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c1 as u64, 51);\n                        }\n\n                        assert(a2 == (c2 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c2 as u64, 51);\n                        }\n\n                        assert(a3 == (c3 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c3 as u64, 51);\n                        }\n\n                        assert(a4 == (c4 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c4 as u64, 51);\n                        }\n                    }\n\n                    // We can see all mod operations in u128\n                    assert(as_nat(a_hat) ==\n                        (c0_0 % (pow2(51) as u128)) + 19 * carry +\n                        pow2( 51) * (c1 % (pow2(51) as u128)) +\n                        pow2(102) * (c2 % (pow2(51) as u128)) +\n                        pow2(153) * (c3 % (pow2(51) as u128)) +\n                        pow2(204) * (c4 % (pow2(51) as u128))\n                    ) by {\n                        // pow2(51) is the same in u64 and 128\n                        lemma_cast_then_mod_51(c0_0);\n                        lemma_cast_then_mod_51(c1);\n                        lemma_cast_then_mod_51(c2);\n                        lemma_cast_then_mod_51(c3);\n                        lemma_cast_then_mod_51(c4);\n                    }\n\n                    // Next, we categorically replace a % s with a - s * ( a / s )\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c0_0 / (pow2(51) as u128))) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c1/ (pow2(51) as u128))) +\n                        pow2(102) * (c2 - pow2(51) * (c2/ (pow2(51) as u128))) +\n                        pow2(153) * (c3 - pow2(51) * (c3/ (pow2(51) as u128))) +\n                        pow2(204) * (c4 - pow2(51) * (c4/ (pow2(51) as u128)))\n                    ) by {\n                        lemma_fundamental_div_mod(c0_0 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c1 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c2 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c3 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c4 as int, pow2(51) as int);\n                    }\n\n                    // Then, we know that\n                    // carry = c4/s\n                    // c4 = c4_0 + c3/s <=> c3/s = c4 - c4_0\n                    // c3 = c3_0 + c2/s <=> c2/s = c3 - c3_0\n                    // c2 = c2_0 + c1/s <=> c1/s = c2 - c2_0\n                    // c1 = c1_0 + c0_0/s <=> c0_0/s = c1 - c1_0\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c1 - c1_0)) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) +\n                        pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) +\n                        pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) +\n                        pow2(204) * (c4 - pow2(51) * carry)\n                    ) by {\n                        lemma_u128_shr_is_div(c0_0, 51);\n                        lemma_u128_shr_is_div(c1, 51);\n                        lemma_u128_shr_is_div(c2, 51);\n                        lemma_u128_shr_is_div(c3, 51);\n                        lemma_u128_shr_is_div(c4, 51);\n                    }\n\n                    // Now we use distributivity and pow exponent sums, which cancels out any ci terms and leaves only ci_0 terms\n                    // Conveniently, we're left with a difference of c * p\n                    assert(as_nat(a_hat) ==\n                        c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0 -\n                        p() * carry\n                    ) by {\n                        assert(c0_0 - pow2(51) * (c1 - c1_0) == c0_0 - pow2(51) * c1 + pow2(51) * c1_0) by {\n                            lemma_mul_is_distributive_sub(pow2(51) as int, c1 as int, c1_0 as int);\n                        }\n\n                        assert(pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) == pow2( 51) * c1 - pow2(102) * c2 + pow2(102) * c2_0) by {\n                            lemma_mul_sub(c1 as int, c2 as int, c2_0 as int, 51);\n                        }\n\n                        assert(pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) == pow2(102) * c2 - pow2(153) * c3 + pow2(153) * c3_0) by {\n                            lemma_mul_sub(c2 as int, c3 as int, c3_0 as int, 102);\n                        }\n\n                        assert(pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) == pow2(153) * c3 - pow2(204) * c4 + pow2(204) * c4_0) by {\n                            lemma_mul_sub(c3 as int, c4 as int, c4_0 as int, 153);\n                        }\n\n                        assert(pow2(204) * (c4 - pow2(51) * carry) == pow2(204) * c4 - pow2(255) * carry) by {\n                            lemma_mul_is_distributive_sub(pow2(204) as int, c4 as int, pow2(51) * carry);\n                            lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, carry as int);\n                            lemma_pow2_adds(204, 51);\n                        }\n\n                        // carry on the right, get p\n                        assert(\n                            c0_0 +\n                            pow2(51) * c1_0 +\n                            pow2(102) * c2_0 +\n                            pow2(153) * c3_0 +\n                            pow2(204) * c4_0 +\n                            19 * carry - pow2(255) * carry\n                            ==\n                            c0_0 +\n                            pow2(51) * c1_0 +\n                            pow2(102) * c2_0 +\n                            pow2(153) * c3_0 +\n                            pow2(204) * c4_0 -\n                            p() * carry\n                        ) by {\n                            pow255_gt_19();\n                            lemma_mul_is_distributive_sub_other_way(carry as int, pow2(255) as int, 19);\n                        }\n                    }\n\n                    let c_arr_as_nat = (c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0\n                        );\n\n\n                    assert(as_nat(a_hat) % p() == c_arr_as_nat as nat % p()) by {\n                        lemma_mod_diff_factor(carry as int, c_arr_as_nat as int, p() as int);\n                    }\n\n                    // We use the as_nat_squared lemma to see what (as_nat(a)^2) evaluates to (mod p)\n\n                    // The nat_squared lemma gives us the following:\n                    // as_nat(a) * as_nat(a) ==\n                    // pow2(8 * 51) * (a[4] * a[4]) +\n                    // pow2(7 * 51) * (2 * (a[3] * a[4])) +\n                    // pow2(6 * 51) * (a[3] * a[3] + 2 * (a[2] * a[4])) +\n                    // pow2(5 * 51) * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])) +\n                    // pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    // pow2(3 * 51) * (2 * (a[1] * a[2]) + 2 * (a[0] * a[3])) +\n                    // pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] * a[2])) +\n                    // pow2(1 * 51) * (2 * (a[0] * a[1])) +\n                    //                (a[0] * a[0])\n                    //\n                    // AND\n                    //\n                    // (as_nat(a) * as_nat(a)) % p() ==\n                    // (\n                    //     pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    //     pow2(3 * 51) * (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])) +\n                    //     pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))) +\n                    //     pow2(1 * 51) * (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))) +\n                    //                    (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))\n                    // ) as nat % p()\n                    as_nat_squared(a);\n\n                    // We're basically done, what remains is to prove that the coefficients next to pow2(i * 51)\n                    // are exactly ci_0s (via distributivity and associativity)\n\n                    // let c0_0: u128 = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                    assert(c0_0 == (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))) by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                        //     = a[0] *  a[0] + 2*( a[1] * a4_19 ) + 2 * (a[2] * a3_19);\n                        // RHS = a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))\n                        //     = a[0] *  a[0] + 19 * (2 * (a[2] * a[3])) + 19 * (2 * (a[1] * a[4]))\n\n                        // goals\n                        // 1) 2 * (a[1] * a4_19) = 19 * (2 * (a[1] * a[4]))\n                        // 2) 2 * (a[2] * a3_19) = 19 * (2 * (a[2] * a[3]))\n\n                        assert(2*(a[1] * a4_19) == 19 * (2 * (a[1] * a[4]))) by {\n                            lemma_reorder_mul(a[1] as int, a[4] as int);\n                        }\n\n                        assert(2*(a[2] * a3_19) == 19 * (2 * (a[2] * a[3]))) by {\n                            lemma_reorder_mul(a[2] as int, a[3] as int);\n                        }\n                    }\n\n                    // let c1_0: u128 = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19);\n                    assert(c1_0 == (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)\n                        //     = a[3] * a3_19 + 2*( a[0] *  a[1]) + 2 * (a[2] * a4_19)\n                        // RHS = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))\n                        //     = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3]) + 19 * (2 * (a[2] * a[4]))\n\n                        // goals: 1) a[3] * a3_19 = 19 * (a[3] * a[3])\n                        //        2) 2 * (a[2] * a4_19) = 19 * (2 * (a[2] * a[4]))\n\n                        assert(a[3] * a3_19 == 19 * (a[3] * a[3])) by {\n                            lemma_mul_is_associative(a[3] as int, a[3] as int, 19);\n                        }\n\n                        assert(2*(a[2] * a4_19) == 19 * (2 * (a[2] * a[4]))) by {\n                            lemma_reorder_mul(a[2] as int, a[4] as int);\n                        }\n                    }\n\n                    // let c2_0: u128 = a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19);\n                    assert(c2_0 == (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[1] * a[1] + 2 * (a[0] *  a[2] + a[4] * a3_19)\n                        //     = a[1] * a[1] + 2 * (a[0] *  a[2]) +  2 * (a[4] * a3_19)\n                        // RHS = a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))\n\n                        // goals: 2 * (a[4] * a3_19) = 19 * (2 * (a[3] * a[4]))\n\n                        assert(2 * (a[4] * a3_19) == 19 * (2 * (a[3] * a[4]))) by {\n                            lemma_mul_is_associative(a[4] as int, a[3] as int, 19);\n                        }\n                    }\n\n                    // let c3_0: u128 = a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]);\n                    assert(c3_0 == (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[4] * a4_19 + 2 * (a[0] *  a[3] + a[1] *  a[2])\n                        //     = a[4] * a4_19 + 2 * (a[0] *  a[3]) + 2 * (a[1] *  a[2])\n                        // RHS = 2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])\n\n                        // goals: a[4] * a4_19 = 19 * (a[4] * a[4])\n\n                        assert(a[4] * a4_19 == 19 * (a[4] * a[4])) by {\n                            lemma_mul_is_associative(a[4] as int, a[4] as int, 19);\n                        }\n                    }\n\n                    // let c4_0: u128 = a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]);\n                    assert(c4_0 == (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])\n                        //     = a[2] * a[2] + 2 * (a[0] * a[4]) + 2 * (a[1] * a[3])\n                        // RHS = a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])\n\n                        // goals: none\n                    }\n                }\n\n                let a_pow_2i_int = pow(as_nat(self.limbs) as int, pow2(i as nat));\n                assert(a_pow_2i_int >= 0) by {\n                    lemma_pow_nat_is_nat(as_nat(self.limbs), i as nat);\n                }\n                let a_pow_2i: nat = a_pow_2i_int as nat;\n\n                assert(as_nat(a_hat) % p() ==\n                    ((as_nat(a) % p()) * (as_nat(a) % p())) % p()\n                ) by {\n                    lemma_mul_mod_noop(as_nat(a) as int, as_nat(a) as int, p() as int);\n                }\n\n                // (a_pow_2i % p)^2 % p = (a_pow_2i^2) % p\n                lemma_mul_mod_noop(a_pow_2i as int, a_pow_2i as int, p() as int);\n\n                // We know, by the loop inv, that\n                // as_nat(a) % p == a_pow_2i % p\n                // and, by the above\n                // as_nat(a_hat) % p  = (as_nat(a) * as_nat(a)) % p = (a_pow_2i ^ 2)) % p\n                // It suffices to prove that\n                // (v^(2^i))^2 = v^(2^(i + 1))\n                lemma_pow2_square(as_nat(self.limbs) as int, i as nat);\n            }\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n            // debug_assert!(a[0] < (1 << 54));\n            // debug_assert!(a[1] < (1 << 54));\n            // debug_assert!(a[2] < (1 << 54));\n            // debug_assert!(a[3] < (1 << 54));\n            // debug_assert!(a[4] < (1 << 54));\n\n            // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n        }\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs: a}\n    }\n\n    /// Returns the square of this field element.\n    pub fn square(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, 2) as nat % p()\n\n    {\n        proof {\n            // pow2(1) == 2\n            lemma2_to64();\n        }\n        self.pow2k(1)\n    }\n\n    /// Returns 2 times the square of this field element.\n    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            as_nat(r.limbs) % p() == (2 * pow(as_nat(self.limbs) as int, 2)) as nat % p()\n    {\n        let mut square = self.pow2k(1);\n\n        // invisible to Rust, can be referenced in proofs\n        // Since square is mut, we save the initial value\n        let ghost old_limbs = square.limbs;\n\n        proof {\n            // forall |i: int| 0 <= i < 5 ==> 2 * old_limbs[i] <= u64::MAX\n            assert forall |i: int| 0 <= i < 5 implies 2 * square.limbs[i] <= u64::MAX by {\n                // if LHS < RHS, then 2 * LHS < 2 * RHS\n                lemma_mul_left_inequality(2, square.limbs[i] as int, (1u64 << 54) as int);\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n            }\n\n            let ka = [\n                (2 * square.limbs[0]) as u64,\n                (2 * square.limbs[1]) as u64,\n                (2 * square.limbs[2]) as u64,\n                (2 * square.limbs[3]) as u64,\n                (2 * square.limbs[4]) as u64\n            ];\n\n            // as_nat(ka) == 2 * as_nat(square.limbs)\n            // and\n            // as_nat(ka) % p() == (2 * as_nat(square.limbs)) % p()\n            as_nat_k(square.limbs, 2);\n\n            // By pow2k ensures:\n            // as_nat(square.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(1)) as nat % p()\n            // We just need pow2(1) == 2\n            lemma2_to64();\n\n            // p > 0\n            pow255_gt_19();\n\n            assert(as_nat(ka) % p() ==\n                ((2nat % p()) * (as_nat(square.limbs) % p())) % p()\n                ==\n                ((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()\n            ) by {\n                lemma_mul_mod_noop(2, as_nat(square.limbs) as int, p() as int);\n            }\n\n            // as_nat(self.limbs)^2 >= 0\n            assert(pow(as_nat(self.limbs) as int, 2) >= 0) by {\n                lemma_pow_nat_is_nat(as_nat(self.limbs), 1);\n            }\n\n            assert(\n                ((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()\n                ==\n                (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p()\n            ) by {\n                lemma_mul_mod_noop(2, pow(as_nat(self.limbs) as int, 2) as int, p() as int);\n            }\n\n            assert(as_nat(ka) % p() == (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p());\n        }\n\n        for i in 0..5\n            invariant\n                forall |j: int| 0 <= j < 5 ==> old_limbs[j] < (1u64 << 54),\n                forall |j: int| 0 <= j < i ==> #[trigger] square.limbs[j] == 2 * old_limbs[j],\n                forall |j: int| i <= j < 5 ==> #[trigger] square.limbs[j] == old_limbs[j],\n        {\n            proof {\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n                lemma_mul_strict_inequality(square.limbs[i as int] as int, (1u64 << 54) as int, 2);\n            }\n\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }\n}\n\nfn main()\n{}\n\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65041": {
    "text": "#![allow(unused)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::arithmetic::power::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// Auxiliary lemma for multiplication (of nat!)\npub proof fn mul_lt(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 < b1,\n        a2 < b2,\n    ensures\n        a1 * a2 < b1 * b2,\n{\n    if (a2 == 0) {\n        assert(b1 * b2 > 0) by {\n            // a * b != 0 <==> a != 0 /\\ b != 0\n            lemma_mul_nonzero(b1 as int, b2 as int);\n        }\n    }\n    else {\n        // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n        lemma_mul_strict_inequality(a1 as int, b1  as int, a2 as int);\n        // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n        lemma_mul_strict_inequality(a2 as int, b2 as int, b1 as int);\n    }\n}\n\npub proof fn mul_le(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 <= b1,\n        a2 <= b2,\n    ensures\n        a1 * a2 <= b1 * b2,\n{\n    // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n    lemma_mul_inequality(a1 as int, b1  as int, a2 as int);\n    // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n    lemma_mul_inequality(a2 as int, b2 as int, b1 as int);\n}\n\n// Auxiliary lemma for exponentiation\npub proof fn pow2_le_max64(k: nat)\n    requires\n        k < 64,\n    ensures\n        pow2(k) <= u64::MAX\n    {\n        lemma2_to64();\n        lemma2_to64_rest();\n    }\n\n// Rewriting lemma; 2^(a + b) * x = 2^a * (2^b * x)\n// Parenthesis placement matters here\npub proof fn lemma_two_factoring(a : nat, b: nat, v: u64)\n    ensures\n        pow2(a + b) * v == pow2(a) * (pow2(b) * v)\n{\n    lemma_pow2_adds(a, b);\n    lemma_mul_is_associative(pow2(a) as int, pow2(b) as int, v as int);\n}\n\n// Specialization of lemma_u64_shl_is_mul for x = 1\npub proof fn shift_is_pow2(k: nat)\n    requires\n        k < 64,\n    ensures\n        (1u64 << k) == pow2(k)\n{\n    pow2_le_max64(k);\n    lemma_u64_shl_is_mul(1u64, k as u64);\n}\n\n// v << 0 == v for all v\npub broadcast proof fn shl_zero_is_id(v: u64)\n    ensures\n        #![trigger v << 0]\n        v << 0 == v\n{\n    assert(v << 0 == v) by (bit_vector);\n}\n\n// v << (a + b) == (v << a) << b\npub proof fn shl_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n        v * pow2(a + b) <= u64::MAX\n    ensures\n        (v << (a + b)) == ((v << a) << b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shl_zero_is_id;\n    }\n    else {\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // 2^a < 2^(a + b) ...\n        lemma_pow2_strictly_increases(a, a + b);\n        // ..., which implies v * 2^a < v * 2^(a + b) <= u64::MAX\n        mul_le(v as nat, v as nat, pow2(a), pow2(a + b));\n        // v << a + b = v * 2^(a+b)\n        lemma_u64_shl_is_mul(v, (a + b) as u64);\n        // v << a = v * 2^a\n        lemma_u64_shl_is_mul(v, a as u64);\n        // (v * 2^a) * 2^b = v * (2^a * 2^b)\n        lemma_mul_is_associative(v as int, pow2(a) as int, pow2(b) as int);\n        // (v * 2^a) << b = (v * 2^a) * 2^b\n        lemma_u64_shl_is_mul((v * pow2(a)) as u64, b as u64);\n    }\n}\n\n// [<<] preserves [<=] (u64 version)\npub proof fn lemma_shl_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64,\n        (b * pow2(k)) <= u64::MAX,\n    ensures\n        (a << k) <= (b << k)\n{\n    mul_le(a as nat, b as nat, pow2(k), pow2(k));\n    lemma_u64_shl_is_mul(a, k as u64);\n    lemma_u64_shl_is_mul(b, k as u64);\n}\n\n// // If a <= b then v << a <= v << b (up to overflow)\npub proof fn shl_nondecreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b < 64,\n        v * pow2(b) <= u64::MAX\n    ensures\n        (v << a) <= (v << b)\n{\n    lemma2_to64(); // pow2(0)\n\n    if (a == b) {\n        // trivial\n    }\n    else if (a == 0) {\n        // a != b <=> b > 0\n        lemma_pow2_strictly_increases(0, b);\n        lemma_u64_shl_is_mul(v, 0);\n        lemma_u64_shl_is_mul(v, b as u64);\n        mul_le(v as nat, v as nat, pow2(0), pow2(b));\n    }\n    else {\n        // if a != 0 and a != b then 0 < d < b\n        let d = b - a;\n\n        // v << b = (v << (b - a)) << a\n        shl_decomposition(v, d as nat, a);\n\n        assert(v << d == v * pow2(d as nat)) by {\n            // we need the precond v * pow2(d) < M\n            lemma_pow2_strictly_increases(d as nat, b);\n            mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));\n            lemma_u64_shl_is_mul(v, d as u64);\n        }\n\n        assert(v <= v << d) by {\n            shl_zero_is_id(v);\n            lemma_u64_shl_is_mul(v, 0);\n            lemma_pow2_strictly_increases(0, d as nat);\n            mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));\n        }\n\n        lemma_pow2_adds(a, d as nat);\n\n        assert( (v << (d as u64)) * pow2(a) <= u64::MAX ) by {\n            lemma_mul_is_associative(v as int, pow2(d as nat) as int, pow2(a) as int);\n        }\n\n        // [v <= v << d] => [(v << a) <= (v << d) << a]\n        lemma_shl_le_u64(v, v << (d as u64), a);\n    }\n}\n\n// v >> 0 == v for all v\npub broadcast proof fn shr_zero_is_id(v: u64)\n    ensures\n        #![trigger v >> 0]\n        v >> 0 == v\n{\n    assert(v >> 0 == v) by (bit_vector);\n}\n\n// v >> (a + b) == (v >> a) >> b\npub proof fn shr_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64\n    ensures\n        (v >> (a + b)) == ((v >> a) >> b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shr_zero_is_id;\n    }\n    else {\n        lemma2_to64_rest(); // pow2(64)\n        lemma_pow2_strictly_increases(a, a + b);\n        lemma_pow2_strictly_increases(b, a + b);\n        lemma_pow2_strictly_increases(a + b, 64); // pow2(a + b) fits in u64\n\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // v >> a + b = v / 2^(a+b)\n        lemma_u64_shr_is_div(v, (a + b) as u64);\n        // v >> a = v / 2^a\n        lemma_u64_shr_is_div(v, a as u64);\n        // (v / 2^a) << b = (v / 2^a) / 2^b\n        lemma_u64_shr_is_div((v / (pow2(a) as u64)) as u64, b as u64);\n\n        // 2^k > 0\n        lemma_pow2_pos(a);\n        lemma_pow2_pos(b);\n\n        // v / 2^a / 2^b = v / 2^(a + b)\n        lemma_div_denominator(v as int, pow2(a) as int, pow2(b) as int);\n    }\n}\n\n// [>>] preserves [<=] (u64 version)\npub proof fn lemma_shr_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64\n    ensures\n        (a >> k) <= (b >> k)\n{\n    lemma_pow2_pos(k);\n    lemma_u64_shr_is_div(a, k as u64);\n    lemma_u64_shr_is_div(b, k as u64);\n    lemma_div_is_ordered(a as int, b as int, pow2(k) as int);\n}\n\n// If a <= b then v >> a >= v >> b\npub proof fn shr_nonincreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b <= 64\n    ensures\n        v >> b <= v >> a\n{\n    if (b == 64) {\n        assert(v >> 64 == 0) by (bit_vector);\n    }\n    else {\n        let d = (b - a) as u64;\n        // v >> b = (v >> (b - a)) >> a\n        shr_decomposition(v, d as nat, a);\n        assert(v >> d <= v) by (bit_vector);\n        // a <= b => a >> x <= b >> x\n        lemma_shr_le_u64(v >> d, v, a);\n    }\n}\n\n// u64::MAX = 2^64 - 1\n// u64::MAX >> k = 2^(64 - k) - 1\n// 1u64 << (64 - k) = 2^(64 - k)\npub proof fn lemma_u64_max_shifting(k:nat)\n    requires\n        1 <= k < 64\n    ensures\n        u64::MAX >> k < 1u64 << (64 - k)\n    decreases 64-k\n{\n    let M = u64::MAX;\n\n    // recursion base case\n    if (k == 63){\n        assert(u64::MAX >> 63 < 1u64 << 1) by (compute);\n    }\n    else {\n        // M >> (k + 1) < 1 << (63 - k)\n        lemma_u64_max_shifting(k + 1);\n\n        // M >> (k + 1) = (M >> k) >> 1\n        shr_decomposition(M, k, 1);\n\n        // precondition\n        lemma2_to64_rest(); // pow2(63)\n        lemma_pow2_strictly_increases((63 - k) as nat, (64 - k) as nat);\n\n        assert(1u64 * pow2((64 - k) as nat) <= 1u64 * pow2(63)) by {\n            if (k == 1) {\n                // 64 - k = 63\n                // tautology\n            }\n            else {\n                // 64 - k < 63\n                lemma_pow2_strictly_increases((64 - k) as nat, 63);\n            }\n            mul_le(1u64 as nat, 1u64 as nat, pow2((64 - k) as nat), pow2(63));\n        }\n        assert( 1u64 * pow2(63) <= u64::MAX) by (compute);\n\n        // 1 << 64 - k = (1 << 63 - k) << 1\n        shl_decomposition(1u64, (63 - k) as nat, 1);\n\n        // (M >> k) >> 1 = (M >> k) / pow2(1);\n        lemma_u64_shr_is_div( M >> k, 1);\n\n        // lemma_u64_shl_is_mul(x, n) precondition: x * pow2(n) <= u64::MAX\n        assert((1u64 << ((63 - k))) * pow2(1) <= u64::MAX) by {\n            shift_is_pow2((63 - k) as nat);\n            lemma_pow2_adds((63-k) as nat, 1);\n        }\n\n        // (1 << 63 - k) << 1 = (1 << 63 - k) * pow2(1);\n        lemma_u64_shl_is_mul( 1u64 << ((63 - k)), 1);\n\n        lemma2_to64(); // pow2(1) = 2\n\n        assert((1u64 << ((64 - k) as u64)) / 2 == (1u64 << ((63 - k) as u64))) by {\n            lemma_div_multiples_vanish((1u64 << (63 - k) as u64) as int, 2);\n        }\n    }\n}\n\n// Corollary of lemma_u64_max_shifting, since for any\n// v: u64 it holds that v <= u64::MAX and >> preserves [<=]\npub proof fn shifted_lt(v: u64, k: nat)\n    requires\n        1 <= k <= 64\n    ensures\n        v >> k < 1u64 << (64 - k)\n{\n    if (k == 64) {\n        assert( v >> 64 == 0) by (bit_vector);\n        shl_zero_is_id(1u64);\n    }\n    else {\n        // (v >> k) <= (u64::MAX >> k)\n        lemma_shr_le_u64(v, u64::MAX, k);\n        // u64::MAX >> k < 1u64 << (64 - k)\n        lemma_u64_max_shifting(k);\n    }\n}\n\n// Because &-ing low_bits_mask(k) is a mod operation, it follows that\n// v & (low_bits_mask(k) as u64) = v % pow2(k) < pow2(k)\npub proof fn masked_lt(v: u64, k: nat)\n    requires\n        0 <= k < 64\n    ensures\n        v & (low_bits_mask(k) as u64) < (1u64 << k)\n{\n    // v & (low_bits_mask(k) as u64) = v % pow2(k)\n    lemma_u64_low_bits_mask_is_mod(v, k);\n    // pow2(k) > 0\n    lemma_pow2_pos(k);\n    // v % pow2(k) < pow2(k)\n    lemma_mod_bound(v as int, pow2(k) as int);\n    // 1 << k = pow2(k)\n    shift_is_pow2(k);\n}\n\n// a < b => (2^a - 1) < (2^b - 1)\npub proof fn low_bits_mask_increases(a: nat, b: nat)\n    requires\n        a < b\n    ensures\n        low_bits_mask(a) < low_bits_mask(b)\n    decreases a + b\n{\n    if (a == 0){\n         // lbm(0) = 0\n        lemma_low_bits_mask_values();\n        // lbm(b) = 2 * lbm(b - 1) + 1, in particular, > 0\n        lemma_low_bits_mask_unfold(b);\n    }\n    else {\n        // lbm(b) / 2 = lbm(b - 1)\n        lemma_low_bits_mask_div2(b);\n        // lbm(a) / 2 = lbm(a - 1)\n        lemma_low_bits_mask_div2(a);\n        // lbm(a - 1) < lbm(b - 1)\n        low_bits_mask_increases((a - 1) as nat, (b - 1) as nat);\n    }\n\n}\n\n// k <= 64 => 2^k - 1 <= u64::MAX = 2^64 - 1\npub proof fn low_bits_masks_fit_u64(k: nat)\n    requires\n        k <= 64\n    ensures\n        low_bits_mask(k) <= u64::MAX\n{\n    lemma_low_bits_mask_values(); // lbm(0) = 0, lbm(64) = 2^64\n    assert(low_bits_mask(64) <= u64::MAX) by (compute);\n    if (k < 64){\n        low_bits_mask_increases(k, 64);\n    }\n}\n\npub proof fn lemma_div_and_mod(ai:u64, bi: u64, v: u64, k: nat)\n    requires\n        k < 64,\n        ai == v >> k,\n        bi == v & (low_bits_mask(k) as u64)\n    ensures\n        ai == v / (pow2(k) as u64),\n        bi == v % (pow2(k) as u64),\n        v == ai * pow2(k) + bi\n{\n    lemma2_to64();\n    lemma2_to64_rest(); // pow2(63) = 0x8000000000000000\n\n    // v >> k = v / pow2(k);\n    lemma_u64_shr_is_div(v, k as u64);\n\n    // v & low_bits_mask(k) = v % pow2(k);\n    lemma_u64_low_bits_mask_is_mod(v, k);\n\n    // 0 < pow2(k) <= u64::MAX\n    lemma_pow2_pos(k);\n    assert(pow2(k) <= u64::MAX) by {\n        assert(0x8000000000000000 <= u64::MAX) by (compute);\n        if (k < 63) {\n            lemma_pow2_strictly_increases(k, 63);\n        }\n    }\n\n    // v = (pow2(k) * (v / pow2(k)) + (v % pow2(k)))\n    lemma_fundamental_div_mod(v as int, pow2(k) as int);\n}\n\n// m(_,_) multiplication is bounded by the product of the individual bounds\npub proof fn lemma_m(x: u64, y: u64, bx: u64, by: u64)\n    requires\n        x < bx,\n        y < by\n    ensures\n        (x as u128) * (y as u128) < (bx as u128) * (by as u128)\n{\n    mul_lt(x as nat, bx as nat, y as nat, by as nat);\n}\n\n// (v^(2^k))^2 = v^(2^(k + 1))\npub proof fn lemma_pow2_square(v: int, i: nat)\n    ensures\n        pow(v, pow2(i)) * pow(v, pow2(i)) == pow(v, pow2(i + 1))\n{\n    // pow(v, pow2(i)) * pow(v, pow2(i)) = pow(v, pow2(i) + pow2(i));\n    lemma_pow_adds(v as int, pow2(i), pow2(i));\n    // 2 * pow2(i) = pow2(i + 1)\n    lemma_pow2_unfold(i + 1);\n}\n\n// Combination of mod lemmas, (b +- a * m) % m = b % m\npub proof fn lemma_mod_sum_factor(a: int, b: int, m: int)\n    requires\n        m > 0\n    ensures\n        (a * m + b) % m == b % m\n{\n    // (a * m + b) % m == ((a * m) % m + b % m) % m\n    lemma_add_mod_noop(a * m, b, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}\n\npub proof fn lemma_mod_diff_factor(a: int, b: int, m: int)\n    requires\n        m > 0,\n    ensures\n        (b - a * m) % m == b % m\n{\n    // (b - a * m) % m == (b % m - (a * m) % m) % m\n    lemma_sub_mod_noop(b, a * m, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}\n\n// v^(2^i) >= 0\npub proof fn lemma_pow_nat_is_nat(v: nat, i: nat)\n    ensures\n        pow(v as int, pow2(i)) >= 0\n{\n    lemma_pow2_pos(i); // pow2(i) > 0\n    if (v == 0) {\n        lemma0_pow(pow2(i));\n    }\n    else {\n        lemma_pow_positive(v as int, pow2(i));\n    }\n}\n\npub proof fn mul_5_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int)\n    ensures\n        n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5\n{\n    // N * ((((x0 + x1) + x2) + x3) + x4) = N * (((x0 + x1) + x2) + x3) + N * x4\n    lemma_mul_is_distributive_add(n, x1 + x2 + x3 + x4, x5);\n    // N * (((x0 + x1) + x2) + x3) = N * ((x0 + x1) + x2) + N * x3\n    lemma_mul_is_distributive_add(n, x1 + x2 + x3, x4);\n    // N * ((x0 + x1) + x2) = N * (x0 + x1) + N * x2\n    lemma_mul_is_distributive_add(n, x1 + x2, x3);\n    // N * (x0 + x1) = N * x0 + N * x1\n    lemma_mul_is_distributive_add(n, x1, x2);\n}\n\npub proof fn mul_5_terms_other_way(n: int, x1: int, x2: int, x3: int, x4: int, x5: int)\n    ensures\n        (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n{\n    // N * ((((x0 + x1) + x2) + x3) + x4) = N * (((x0 + x1) + x2) + x3) + N * x4\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2 + x3 + x4, x5);\n    // N * (((x0 + x1) + x2) + x3) = N * ((x0 + x1) + x2) + N * x3\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2 + x3, x4);\n    // N * ((x0 + x1) + x2) = N * (x0 + x1) + N * x2\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2, x3);\n    // N * (x0 + x1) = N * x0 + N * x1\n    lemma_mul_is_distributive_add_other_way(n, x1, x2);\n}\n\npub proof fn mul_v0_and_reorder(\n    v0: int,\n    s1: int, v1: int,\n    s2: int, v2: int,\n    s3: int, v3: int,\n    s4: int, v4: int\n)\n    ensures\n        v0 * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n             (v0 * v0)\n{\n    mul_5_terms(\n        v0,\n        v0,\n        s1 * v1,\n        s2 * v2,\n        s3 * v3,\n        s4 * v4\n    );\n\n    lemma_mul_is_associative(v0, v1, s1);\n    lemma_mul_is_associative(v0, v2, s2);\n    lemma_mul_is_associative(v0, v3, s3);\n    lemma_mul_is_associative(v0, v4, s4);\n}\n\npub proof fn mul_quad_prod(a1: int, b1: int, a2: int, b2: int)\n    ensures\n        (a1 * b1) * (a2 * b2) == (a1 * a2) * (b1 * b2)\n{\n    // commutativity is baked-in\n\n    // (a1 * b1) * (a2 * b2) =  ((a1 * b1) * a2) * b2\n    lemma_mul_is_associative(a1 * b1, a2, b2);\n    // (a1 * b1) * a2 = a2 * (a1 * b1) = (a2 * a1) * b1\n    lemma_mul_is_associative(a2, a1, b1);\n    // ((a2 * a1) * b1) * b2 = (a2 * a1) * (b1 * b2)\n    lemma_mul_is_associative(a2 * a1, b1, b2);\n}\n\npub proof fn mul_si_vi_and_reorder(\n    si: int, vi: int,\n    v0: int,\n    s1: int, v1: int,\n    s2: int, v2: int,\n    s3: int, v3: int,\n    s4: int, v4: int\n)\n    ensures\n        (si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) ==\n        (si     ) * (vi * v0) +\n        (si * s1) * (vi * v1) +\n        (si * s2) * (vi * v2) +\n        (si * s3) * (vi * v3) +\n        (si * s4) * (vi * v4)\n{\n    // n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5\n    mul_5_terms(\n        si * vi,\n        v0,\n        s1 * v1,\n        s2 * v2,\n        s3 * v3,\n        s4 * v4\n    );\n\n    assert(\n        (si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4)\n        ==\n        (si * vi) * v0 +\n        (si * vi) * (s1 * v1) +\n        (si * vi) * (s2 * v2) +\n        (si * vi) * (s3 * v3) +\n        (si * vi) * (s4 * v4)\n    );\n\n    lemma_mul_is_associative(si, vi, v0);\n    mul_quad_prod(si, vi, s1, v1);\n    mul_quad_prod(si, vi, s2, v2);\n    mul_quad_prod(si, vi, s3, v3);\n    mul_quad_prod(si, vi, s4, v4);\n}\n\n// dummy, so we can call `verus common_verus.rs`\nfn main() {}\n\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65042": {
    "text": "#[allow(unused_imports)]\nuse super::common_verus::*;\n#[allow(unused_imports)]\nuse super::constants;\n#[allow(unused_imports)]\nuse super::scalar::Scalar52;\n#[allow(unused_imports)]\nuse super::scalar_specs::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\n/// Verification: scalar * scalar.invert()  1 mod L\nproof fn verify_invert_correct(x: Scalar52)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}\n\npub proof fn lemma_52_52(x: u64, y: u64)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures (x as u128) * (y as u128) < (1u128 << 104)\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert( x * y < x * (1u128 << 52)  );\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}\n\npub proof fn lemma_square_internal_no_overflow()\n    ensures\n         (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n         (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n         (1u128 << 104) * 2 == (1u128 << 105),\n         (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}\n\n\npub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]) ,\n        z[1] == (a[0] * a[1])  * 2,\n        z[2] == (a[0] * a[2])  * 2 + (a[1] * a[1]) ,\n        z[3] == (a[0] * a[3])  * 2 + (a[1] * a[2])  * 2,\n        z[4] == (a[0] * a[4])  * 2 + (a[1] * a[3])  * 2 + (a[2] * a[2]) ,\n        z[5] == (a[1] * a[4])  * 2 + (a[2] * a[3])  * 2,\n        z[6] == (a[2] * a[4])  * 2 + (a[3] * a[3]) ,\n        z[7] == (a[3] * a[4])  * 2,\n        z[8] == (a[4] * a[4]) ,\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n\n{\n        assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n            broadcast use group_mul_is_commutative_and_distributive;\n            broadcast use lemma_mul_is_associative;\n\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(52, 104);\n            lemma_pow2_adds(52, 156);\n            lemma_pow2_adds(52, 208);\n            lemma_pow2_adds(104, 104);\n            lemma_pow2_adds(104, 156);\n            lemma_pow2_adds(104, 208);\n            lemma_pow2_adds(156, 156);\n            lemma_pow2_adds(156, 208);\n            lemma_pow2_adds(208, 208);\n        };\n        lemma_nine_limbs_equals_slice128_to_nat(&z);\n        lemma_five_limbs_equals_to_nat(&a);\n}\n\npub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}\n\n\npub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\nensures\n    nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs)\n{\n\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            ((limbs[4] as nat) +\n            ((limbs[5] as nat) +\n                ((limbs[6] as nat) +\n                ((limbs[7] as nat) +\n                (limbs[8] as nat) * pow2(52)\n                ) * pow2(52)\n                ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        lemma_pow2_adds(208, 52);\n        lemma_pow2_adds(260, 52);\n        lemma_pow2_adds(312, 52);\n        lemma_pow2_adds(364, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}\n\npub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\nensures\n    five_limbs_to_nat_aux(*limbs) == to_nat(limbs)\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            (limbs[4] as nat) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        (limbs[0] as nat) +\n        pow2(52) * (limbs[1] as nat) +\n        pow2(104) * (limbs[2] as nat) +\n        pow2(156) * (limbs[3] as nat) +\n        pow2(208) * (limbs[4] as nat); {\n        }\n        five_limbs_to_nat_aux(*limbs);\n    }\n}\n\n\npub proof fn lemma_scalar_subtract_no_overflow(carry: u64, difference_limb: u64, addend: u64, i: u32, l_value: &Scalar52)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}\n\npub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}\n\n\npub proof fn lemma_from_montgomery_limbs_conversion(\n    limbs: &[u128; 9],\n    self_limbs: &[u64; 5]\n)\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) +\n           (self_limbs[1] as nat) * pow2(52) +\n           (self_limbs[2] as nat) * pow2(104) +\n           (self_limbs[3] as nat) * pow2(156) +\n           (self_limbs[4] as nat) * pow2(208) +\n           0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(416));\n}\n\n\n\npub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}\n\n/// Need to use induction because the postcondition expands\n/// seq_u64_to_nat in the opposite way from how it's defined.\n/// The base case is straightforward, but it takes a few steps\n/// to get Verus to prove it.\n/// Induction case: Take off the first element using definition of\n/// seq_u64_to_nat, apply induction hypothesis to the remaining sequence,\n/// then put the first element back on and simplify all the powers.\npub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) ==\n        seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)\n    decreases i\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len()>0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(nat_single.subrange(1, 1)) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {lemma2_to64();}\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return;\n    }\n    else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert( seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(1, limbs1.len() as int));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i-1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i-1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) ==\n                    seq_u64_to_nat(tail.subrange(0, i - 1)) + tail[i -1 ] * pow2(52 * (i-1) as nat));\n                assert( tail.subrange(0, i) == seq.subrange(1, i + 1) );\n                assert( tail.subrange(0, i - 1) == seq.subrange(1, i ) );\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) ==\n                    seq_u64_to_nat(seq.subrange(1, i )) + seq[i] * pow2(52 * (i-1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i )) + seq[i] * pow2(52 * (i-1) as nat)) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i )) * pow2(52) + seq[i] * pow2(52 * (i-1) as nat) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n                lemma_pow2_adds(52 * (i-1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i )) * pow2(52) + seq[i] * pow2(52 * i as nat)) as nat; {\n                assert(seq.subrange(1, i ).map(|i, x| x as nat) == limbs2.subrange(1, limbs2.len() as int));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i] * pow2(52 * i as nat)) as nat; {\n                assert( seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {\n            }\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n\n        }\n    }\n}\n\n/// Verus times out when this assertion is inside\n/// lemma_seq_u64_to_nat_subrange_extend\npub proof fn lemma_empty_seq_as_nat(a: Seq<u64>)\n    ensures seq_u64_to_nat(a.subrange(0, 0)) == 0\n{\n    assert(seq_u64_to_nat(a.subrange(0, 0)) == 0);\n}\n\n\n/// Using lemma_mod_add_multiples_vanish in a big proof made the proof hang\npub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) ==\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int)\n{\n    lemma_mod_add_multiples_vanish((to_nat(&a.limbs) - to_nat(&b.limbs)) as int, group_order() as int);\n}\n\n\n/// The corollary of limbs_bounded(a)\npub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires limbs_bounded(a)\n    ensures to_nat(&a.limbs) < pow2((52 * (5) as nat))\n{\n    lemma_general_bound(a.limbs@);\n}\n\n/// The general case of lemma_bound_scalar so we\n/// can prove via straightforward induction.\npub proof fn lemma_general_bound(a: Seq<u64>)\n    requires forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52)\n    ensures seq_u64_to_nat(a) < pow2((52 * a.len() as nat))\n    decreases a.len()\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64(); // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(1, a.len() as int).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int)) * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52)) by {\n            lemma_mul_inequality((pow2(52 * (a.len() - 1) as nat) - 1) as int, pow2(52 * (a.len() - 1) as nat) as int, pow2(52) as int);\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) ==\n               pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) ==\n               pow2(52 * (a.len() - 1) as nat) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}\n\n/// Claude wrote this proof. Could the proof be shorter?\n/// Moved this to a lemma to get under rlimit.\npub proof fn lemma_decompose(a: u64, mask: u64)\n    requires mask == (1u64 << 52) - 1\n    ensures a == (a >> 52) * pow2(52) + (a & mask)\n{\n    // First, establish that bit shifting is division by pow2(52)\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    lemma2_to64_rest(); // Establishes pow2(52) == 0x10000000000000\n    assert((1u64 << 52) == 0x10000000000000) by (bit_vector);\n    assert(pow2(52) == 0x10000000000000);\n    assert((1u64 << 52) as nat == pow2(52));\n\n    assert(a >> 52 == a / (1u64 << 52));\n\n    // Apply fundamental division theorem: a = q * d + r\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n    let q = a as nat / pow2(52);\n    let r = a as nat % pow2(52);\n    assert(a as nat == q * pow2(52) + r);\n    assert(0 <= r < pow2(52));\n\n    // Now prove that (a & mask) == r\n    // mask is all 1s in the lower 52 bits\n    assert(mask == (1u64 << 52) - 1);\n\n    // Key insight: a & mask gives us the lower 52 bits, which is exactly a % pow2(52)\n    lemma_u64_low_bits_mask_is_mod(a, 52);\n    assert(a & mask == a % (1u64 << 52));\n    assert((a % (1u64 << 52)) as nat == a as nat % pow2(52));\n    assert((a & mask) as nat == r);\n\n    // Now show that a >> 52 == q\n    assert((a >> 52) as nat == a as nat / pow2(52));\n    assert((a >> 52) as nat == q);\n\n    // Combine everything\n    assert(a as nat == (a >> 52) as nat * pow2(52) + (a & mask) as nat);\n}\n\n/// The loop invariant says that subtraction is correct if we only subtract\n/// the first i items of each array, plus there's a borrow term.\n/// The first parts of the calc statement expand using the previous invariant.\n/// Then we have cases depending if the wrapping_sub wrapped.\n/// If it didn't wrap, we show that borrow must be small, and borrow >> 52 == 0.\n/// If it did wrap, we show that borrow is so large that its bit-shifts are all\n/// the maximum amount.\n/// Either way, we then use the preconditions about what was mutated,\n/// and shuffle around the powers of 52.\npub proof fn lemma_sub_loop1_invariant(difference: Scalar52, borrow: u64, i: usize, a: &Scalar52, b: &Scalar52, old_borrow: u64, mask: u64, difference_loop1_start: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                    seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int )) - (old_borrow >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64)\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat))\n        == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1))\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) -\n        (seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int)) +\n        (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(52 * i as nat) +\n        (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n        (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52) + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n                    (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        ((borrow >> 52) * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                        assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                                lemma_mul_is_associative((borrow >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                        };\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) + difference.limbs[i as int] * pow2(52 * i as nat) -\n                        0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                            lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64<<12) - 1) by (bit_vector)\n                                requires borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52);\n                        assert( 0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(52 * (i + 1) as nat) ) by\n                        {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(pow2(52 * (i+1) as nat) as int, (1u64<<12) - 1, (1u64 << 12) as int);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) +\n                        (-1) * pow2(52 * (i+1) as nat) ; {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                                requires borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n                }\n            }\n            else {\n\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n                    (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        ((borrow >> 52) * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                        assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                                lemma_mul_is_associative((borrow >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                        };\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                            lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert (borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                                requires borrow < 1u64 << 52;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                                requires borrow < 1u64 << 52;\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n    }\n}\n\n/// Just a proof by computation\npub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {lemma2_to64_rest();};\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    assert(pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000) by\n    {\n        assert(pow2(63) == 0x8000000000000000) by {lemma2_to64_rest();}\n        lemma_pow2_adds(63, 63);\n        assert(pow2(126) == 0x40000000000000000000000000000000);\n        lemma_pow2_adds(126, 126);\n    }\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}\n\n/// If borrow >> 63 == 0, we apply\n/// (1) `-group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()`,\n/// and that's enough to show that to_nat(&difference.limbs) is between\n/// 0 and group order.\n/// If borrow >> 63 == 1, we apply (1) to show that carry >> 52 can't be 0.\n/// This makes the excess terms in the borrow >> 63 == 1 precondition disappear\npub(crate) proof fn lemma_sub_correct_after_loops(difference: Scalar52, carry: u64, a: &Scalar52, b: &Scalar52, difference_after_loop1: Scalar52, borrow: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==>\n        seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) ==\n        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)),\n    ensures\n            to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int)\n{\n        assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n        assert( seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs)) by {\n            assert( seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n            assert( difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n        }\n        assert( seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n            assert( seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n            assert( b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        }\n        assert( seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n            assert( seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n            assert( a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        }\n        if borrow >> 63 == 0 {\n\n            assert(              seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                                        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)) );\n            assert(              seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                                        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) );\n            assert(              to_nat(&a.limbs) - to_nat(&b.limbs) ==\n                                        to_nat(&difference.limbs) );\n            assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n            assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n            lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n            assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int));\n        }\n        if borrow >> 63 == 1 {\n            assert(\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n            );\n            assert(\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                    - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int))\n            );\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int )) - pow2((52 * (5) as nat)) );\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                    - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)) );\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                     - pow2((52 * (5) as nat)) );\n            if carry >> 52 == 0 {\n                // Get a contradiction because the sides in the above equation have different signs\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                    seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) >=0) by {\n                    assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order()) by {\n                        lemma_l_equals_group_order();\n                    };\n                    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n                };\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2((52 * (5) as nat))) by {\n                    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs));\n                    lemma_bound_scalar(&difference);\n                };\n                assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n                assert(false);\n            }\n            assert(carry >> 52 ==1);\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int))  );\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   to_nat(&a.limbs) - to_nat(&b.limbs) ==\n                   to_nat(&difference.limbs)  );\n            assert(to_nat(&constants::L.limbs) == group_order()) by {\n                lemma_l_equals_group_order();\n            };\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n                lemma_l_equals_group_order();\n            };\n            assert(group_order() > 0);\n            calc! {\n                (==)\n                to_nat(&difference.limbs) as int; {\n                }\n                group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                    assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()) by {\n                        assert( seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) == to_nat(&difference_after_loop1.limbs)) by {\n                            assert( seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(&difference_after_loop1.limbs));\n                            assert( difference_after_loop1.limbs@ == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                        }\n                        assert(to_nat(&a.limbs) - to_nat(&b.limbs ) ==\n                        to_nat(&difference_after_loop1.limbs ) - pow2((52 * (5) as nat)) );\n                        lemma_bound_scalar(&difference_after_loop1);\n                    };\n                    lemma_small_mod((group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n                }\n                (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                    lemma_mod_cancel(a, b);\n                }\n                (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n            }\n        }\n}\n\n/// Moving this out to get under rlimit\npub proof fn lemma_old_carry(old_carry: u64)\n    requires old_carry < 1u64 <<52,\n    ensures old_carry >> 52 == 0,\n{\n    assert(old_carry >> 52 == 0) by (bit_vector)\n        requires old_carry < 1u64 <<52;\n}\n\n/// If borrow >> 63 == 0, we just prove that the loop step has no effect.\n/// If borrow >> 63 == 1, we substitute in the loop's updates\n/// like `difference.limbs[i as int] == carry & mask`.\n/// In that case we're proving that subtraction is correct if we only\n/// consider the first i items of each array, except there's also a\n/// `(carry >> 52) * pow2(52 * (i+1) as nat)` term that doesn't go away.\npub(crate) proof fn lemma_sub_loop2_invariant(difference: Scalar52, i: usize, a: &Scalar52, b: &Scalar52, mask: u64, difference_after_loop1: Scalar52, difference_loop2_start: Scalar52, carry: u64, old_carry: u64, addend: u64, borrow: u64)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int| i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int| (0 <= j < 5 && j!=i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >=1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i-1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==>\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i+1 >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==>\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1 as int)) ==\n            seq_u64_to_nat(difference.limbs@.subrange(0, i+1 as int)) + (carry >> 52) * pow2(52 * (i+1) as nat)\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert( carry & mask == carry ) by (bit_vector)\n            requires\n            carry < 1u64 <<52,\n            mask == (1u64 << 52) - 1;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall |j :int| 0<=j<5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1)); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat) +\n            seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use group_mul_is_distributive;\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int) );\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat +\n            difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int] + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(52 * i as nat); {\n                assert(carry == (carry >> 52) * (1u64<<52) + (carry & mask)) by (bit_vector)\n                    requires mask == (1u64 << 52) - 1;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);};\n                    assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                        lemma_mul_is_associative((carry >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i+1)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat);\n        }\n    }\n}\n\n} // verus!\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65043": {
    "text": "#![allow(unused)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::prelude::*;\n\nuse super::common_verus::*;\n\n// Lemmas and spec functions only used in field_verus.rs\n// A lemma should be in this file instead of `common_verus` if:\n//  - It references some constant prominent in `field_verus` (e.g. 51 for bit operations, 2^255 -19)\n//  - It defines or reasons about a spec function relevant only to `field_verus`\nverus! {\n\n// p = 2^255 - 19\npub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n}\n\n// Proof that 2^255 > 19\npub proof fn pow255_gt_19()\n    ensures\n        pow2(255) > 19\n{\n    lemma2_to64(); // 2^5\n    lemma_pow2_strictly_increases(5, 255);\n}\n\npub open spec const mask51: u64 = 2251799813685247u64;\n\n// Specialization for b = 51\npub proof fn lemma_two_factoring_51(k : nat, ai: u64)\n    ensures\n        pow2(k + 51) * ai == pow2(k) * (pow2(51) * ai)\n{\n    lemma_two_factoring(k, 51, ai);\n}\n\n// Evaluation function, given a field element as limbs, reconstruct the nat value it represents.\npub open spec fn as_nat(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n}\n\n// Evaluation function, given a field element as limbs, reconstruct the nat value it represents.\npub open spec fn as_nat_32_u8(limbs: [u8; 32]) -> nat {\n    // Verus error: `core::iter::range::impl&%15::fold` is not supported\n    // we write them out manually\n    (limbs[0] as nat) +\n    pow2( 1 * 8) * (limbs[ 1] as nat) +\n    pow2( 2 * 8) * (limbs[ 2] as nat) +\n    pow2( 3 * 8) * (limbs[ 3] as nat) +\n    pow2( 4 * 8) * (limbs[ 4] as nat) +\n    pow2( 5 * 8) * (limbs[ 5] as nat) +\n    pow2( 6 * 8) * (limbs[ 6] as nat) +\n    pow2( 7 * 8) * (limbs[ 7] as nat) +\n    pow2( 8 * 8) * (limbs[ 8] as nat) +\n    pow2( 9 * 8) * (limbs[ 9] as nat) +\n    pow2(10 * 8) * (limbs[10] as nat) +\n    pow2(11 * 8) * (limbs[11] as nat) +\n    pow2(12 * 8) * (limbs[12] as nat) +\n    pow2(13 * 8) * (limbs[13] as nat) +\n    pow2(14 * 8) * (limbs[14] as nat) +\n    pow2(15 * 8) * (limbs[15] as nat) +\n    pow2(16 * 8) * (limbs[16] as nat) +\n    pow2(17 * 8) * (limbs[17] as nat) +\n    pow2(18 * 8) * (limbs[18] as nat) +\n    pow2(19 * 8) * (limbs[19] as nat) +\n    pow2(20 * 8) * (limbs[20] as nat) +\n    pow2(21 * 8) * (limbs[21] as nat) +\n    pow2(22 * 8) * (limbs[22] as nat) +\n    pow2(23 * 8) * (limbs[23] as nat) +\n    pow2(24 * 8) * (limbs[24] as nat) +\n    pow2(25 * 8) * (limbs[25] as nat) +\n    pow2(26 * 8) * (limbs[26] as nat) +\n    pow2(27 * 8) * (limbs[27] as nat) +\n    pow2(28 * 8) * (limbs[28] as nat) +\n    pow2(29 * 8) * (limbs[29] as nat) +\n    pow2(30 * 8) * (limbs[30] as nat) +\n    pow2(31 * 8) * (limbs[31] as nat)\n}\n\n// Lemma: If a > b pointwise, then as_nat(a - b) = as_nat(a) - as_nat(b)\npub proof fn lemma_as_nat_sub(a: [u64;5], b: [u64;5])\n    requires\n        forall |i:int| 0 <= i < 5 ==> b[i] < a[i]\n    ensures\n        as_nat([\n            (a[0] - b[0]) as u64,\n            (a[1] - b[1]) as u64,\n            (a[2] - b[2]) as u64,\n            (a[3] - b[3]) as u64,\n            (a[4] - b[4]) as u64\n        ]) == as_nat(a) - as_nat(b)\n{\n    let c: [u64;5] = [\n        (a[0] - b[0]) as u64,\n        (a[1] - b[1]) as u64,\n        (a[2] - b[2]) as u64,\n        (a[3] - b[3]) as u64,\n        (a[4] - b[4]) as u64\n    ];\n    // distribute pow2\n    assert( as_nat(c) ==\n        (a[0] - b[0]) +\n        pow2(51) * a[1] - pow2(51) * b[1] +\n        pow2(102) * a[2] - pow2(102) * b[2] +\n        pow2(153) * a[3] - pow2(153) * b[3] +\n        pow2(204) * a[4] - pow2(204) * b[4]\n    ) by {\n        lemma_mul_is_distributive_sub(pow2(1 * 51) as int, a[1] as int, b[1] as int);\n        lemma_mul_is_distributive_sub(pow2(2 * 51) as int, a[2] as int, b[2] as int);\n        lemma_mul_is_distributive_sub(pow2(3 * 51) as int, a[3] as int, b[3] as int);\n        lemma_mul_is_distributive_sub(pow2(4 * 51) as int, a[4] as int, b[4] as int);\n    }\n}\n\npub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52)\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}\n\n// >> preserves [<=]. Unfortunately, these operations are u128 and\n// we need lemma_u128_shr_is_div.\npub proof fn lemma_shr_51_le(a: u128, b: u128)\n    requires\n        a <= b\n    ensures\n        (a >> 51) <= (b >> 51)\n{\n    lemma_pow2_pos(51);\n    lemma2_to64_rest(); // pow2(51) value\n    lemma_u128_shr_is_div(a, 51);\n    lemma_u128_shr_is_div(b, 51);\n    lemma_div_is_ordered(a as int, b as int, 51);\n}\n\n// Corollary of above, using the identity (a << x) >> x == a for u64::MAX\npub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51\n    ensures\n        (a >> 51) <= (u64::MAX as u128)\n\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}\n\n// Auxiliary datatype lemma\n// Should work for any k <= 64, but the proofs are convoluted and we can't use BV\n// (x as u64) = x % 2^64, so x = 2^64 * (x / 2^64) + (x as u64). Thus\n// (x as u64) % 2^k = (x as u64) % 2^k, because 2^k | 2^64 * (...) for k <= 64\npub proof fn lemma_cast_then_mod_51(x: u128)\n    ensures\n        (x as u64) % (pow2(51) as u64) == x % (pow2(51) as u128)\n{\n    lemma2_to64_rest(); // pow2(51 | 64)\n    assert( (x as u64) % 0x8000000000000 == x % 0x8000000000000) by (bit_vector);\n}\n\n// Explicit and mod-p identities for squaring as_nat conversion\npub proof fn as_nat_squared(v: [u64; 5])\n    ensures\n        as_nat(v) * as_nat(v) ==\n        pow2(8 * 51) * (v[4] * v[4]) +\n        pow2(7 * 51) * (2 * (v[3] * v[4])) +\n        pow2(6 * 51) * (v[3] * v[3] + 2 * (v[2] * v[4])) +\n        pow2(5 * 51) * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])) +\n        pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n        pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3])) +\n        pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2])) +\n        pow2(1 * 51) * (2 * (v[0] * v[1])) +\n                       (v[0] * v[0]),\n        // and the mod equality\n        (as_nat(v) * as_nat(v)) % p() ==\n        (\n            pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n            pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])) +\n            pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))) +\n            pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))) +\n                           (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])))\n        ) as nat % p()\n{\n    let v0 = v[0];\n    let v1 = v[1];\n    let v2 = v[2];\n    let v3 = v[3];\n    let v4 = v[4];\n\n    let s1 = pow2(1 * 51);\n    let s2 = pow2(2 * 51);\n    let s3 = pow2(3 * 51);\n    let s4 = pow2(4 * 51);\n    let s5 = pow2(5 * 51);\n    let s6 = pow2(6 * 51);\n    let s7 = pow2(7 * 51);\n    let s8 = pow2(8 * 51);\n\n    assert(s1 * s1 == s2) by {\n        lemma_pow2_adds(51, 51)\n    }\n    assert(s1 * s2 == s2 * s1 == s3) by {\n        lemma_pow2_adds(51, 102)\n    }\n    assert(s1 * s3 == s3 * s1 == s4) by {\n        lemma_pow2_adds(51, 153)\n    }\n    assert(s1 * s4 == s4 * s1 == s5) by {\n        lemma_pow2_adds(51, 204)\n    }\n    assert(s2 * s2 == s4) by {\n        lemma_pow2_adds(102, 102)\n    }\n    assert(s2 * s3 == s3 * s2 == s5) by {\n        lemma_pow2_adds(102, 153)\n    }\n    assert(s2 * s4 == s4 * s2 == s6) by {\n        lemma_pow2_adds(102, 204)\n    }\n    assert(s3 * s3 == s6) by {\n        lemma_pow2_adds(153, 153)\n    }\n    assert(s3 * s4 == s4 * s3 == s7) by {\n        lemma_pow2_adds(153, 204)\n    }\n    assert(s4 * s4 == s8) by {\n        lemma_pow2_adds(204, 204)\n    }\n\n    assert(as_nat(v) * as_nat(v) ==\n        v0 * as_nat(v) +\n        (s1 * v1) * as_nat(v) +\n        (s2 * v2) * as_nat(v) +\n        (s3 * v3) * as_nat(v) +\n        (s4 * v4) * as_nat(v)\n    ) by {\n        // (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n        mul_5_terms_other_way(\n            as_nat(v) as int,\n            v0 as int,\n            s1 * v1,\n            s2 * v2,\n            s3 * v3,\n            s4 * v4\n        );\n    }\n\n    // because of the sheer number of possible associativity/distributivity groupings we have\n    // to help the solver along by intermittently asserting chunks\n    assert(v0 * as_nat(v) ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n        v0 * v0\n    ) by {\n        mul_v0_and_reorder(\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        );\n    }\n\n    assert((s1 * v1) * as_nat(v) ==\n        s5 * (v1 * v4) +\n        s4 * (v1 * v3) +\n        s3 * (v1 * v2) +\n        s2 * (v1 * v1) +\n        s1 * (v0 * v1)\n    ) by {\n        mul_si_vi_and_reorder(\n            s1 as int, v1 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s2 * v2) * as_nat(v) ==\n        s6 * (v2 * v4) +\n        s5 * (v2 * v3) +\n        s4 * (v2 * v2) +\n        s3 * (v1 * v2) +\n        s2 * (v0 * v2)\n    ) by {\n        mul_si_vi_and_reorder(\n            s2 as int, v2 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s3 * v3) * as_nat(v) ==\n        s7 * (v3 * v4) +\n        s6 * (v3 * v3) +\n        s5 * (v2 * v3) +\n        s4 * (v1 * v3) +\n        s3 * (v0 * v3)\n    ) by {\n        mul_si_vi_and_reorder(\n            s3 as int, v3 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s4 * v4) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (v3 * v4) +\n        s6 * (v2 * v4) +\n        s5 * (v1 * v4) +\n        s4 * (v0 * v4)\n    ) by {\n        mul_si_vi_and_reorder(\n            s4 as int, v4 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    // we now mash them all together\n    assert(as_nat(v) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (2 * (v3 * v4)) +\n        s6 * (v3 * v3 + 2 * (v2 * v4)) +\n        s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) +\n        s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4)) +\n        s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) +\n        s2 * (v1 * v1 + 2 * (v0 * v2)) +\n        s1 * (2 * (v0 * v1)) +\n             (v0 * v0)\n    ) by {\n        // These assert(a + a = 2a) statements aren't strictly necessary, but they improve the solve time\n\n        // s1 terms\n        assert(\n            s1 * (v0 * v1) + s1 * (v0 * v1)\n            ==\n            s1 * (2 * (v0 * v1))\n        ) by {\n            assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n            lemma_mul_is_distributive_add(s1 as int, v0 * v1, v0 * v1);\n        }\n\n        // s2 terms\n        assert(\n            s2 * (v0 * v2) + s2 * (v1 * v1) + s2 * (v0 * v2)\n            ==\n            s2 * (v1 * v1 + 2 * (v0 * v2))\n        ) by {\n            assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n            lemma_mul_is_distributive_add(s2 as int, v0 * v2, v0 * v2);\n            lemma_mul_is_distributive_add(s2 as int, 2 * (v0 * v2), v1 * v1);\n        }\n\n        // s3 terms\n        assert(\n            s3 * (v0 * v3) + s3 * (v1 * v2) + s3 * (v1 * v2) + s3 * (v0 * v3)\n            ==\n            s3 * (2 * (v1 * v2) + 2 * (v0 * v3))\n        ) by {\n            assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n            assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n            lemma_mul_is_distributive_add(s3 as int, v1 * v2, v1 * v2);\n            lemma_mul_is_distributive_add(s3 as int, v0 * v3, v0 * v3);\n            lemma_mul_is_distributive_add(s3 as int, 2 * (v1 * v2), 2 * (v0 * v3));\n        }\n\n        // s4 terms\n        assert(\n            s4 * (v0 * v4) + s4 * (v1 * v3) + s4 * (v2 * v2) + s4 * (v1 * v3) + s4 * (v0 * v4)\n            ==\n            s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4))\n        ) by {\n            assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n            assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v0 * v4, v0 * v4);\n            lemma_mul_is_distributive_add(s4 as int, v1 * v3, v1 * v3);\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2, 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2 + 2 * (v1 * v3), 2 * (v0 * v4));\n        }\n\n        // s5 terms\n        assert(\n            s5 * (v1 * v4) + s5 * (v2 * v3) + s5 * (v2 * v3) + s5 * (v1 * v4)\n            ==\n            s5 * (2 * (v2 * v3) + 2 * (v1 * v4))\n        ) by {\n            assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n            assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n            lemma_mul_is_distributive_add(s5 as int, v1 * v4, v1 * v4);\n            lemma_mul_is_distributive_add(s5 as int, v2 * v3, v2 * v3);\n            lemma_mul_is_distributive_add(s5 as int, 2 * (v1 * v4), 2 * (v2 * v3));\n        }\n\n        // s6 terms\n        assert(\n            s6 * (v2 * v4) + s6 * (v3 * v3) + s6 * (v2 * v4)\n            ==\n            s6 * (v3 * v3 + 2 * (v2 * v4))\n        ) by {\n            assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n            lemma_mul_is_distributive_add(s6 as int, v2 * v4, v2 * v4);\n            lemma_mul_is_distributive_add(s6 as int, 2 * (v2 * v4), v3 * v3);\n        }\n\n        // s7 terms\n        assert(\n            s7 * (v3 * v4) + s7 * (v3 * v4)\n            ==\n            s7 * (2 * (v3 * v4))\n        ) by {\n            assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n            lemma_mul_is_distributive_add(s7 as int, v3 * v4, v3 * v4);\n        }\n    }\n\n    // This is the explicit version, now we can take everything mod p\n\n    // p well defined\n    pow255_gt_19();\n\n    // By definition, p = s^5 - 19\n    // equivalently,\n    // s^5 = (p + 19)\n    // s^6 = s * (p + 19)\n    // s^7 = s^2 * (p + 19)\n    // s^8 = s^3 * (p + 19)\n    assert(s5 == (p() + 19));\n\n    // we pack together terms to slim down expressions;\n\n    let c0_base = v0 *  v0;\n    let c0_x19 = 2 * (v2 * v3) + 2 * (v1 * v4);\n    let c0 = c0_base + 19 * c0_x19;\n\n    let c1_base = 2 * (v0 *  v1);\n    let c1_x19 = v3 * v3 + 2 * (v2 * v4);\n    let c1 = c1_base + 19 * c1_x19;\n\n    let c2_base = v1 * v1 + 2 * (v0 *  v2);\n    let c2_x19 = 2 * (v3 * v4);\n    let c2 = c2_base + 19 * c2_x19;\n\n    let c3_base = 2 * (v1 *  v2) + 2 * (v0 *  v3);\n    let c3_x19 = v4 * v4;\n    let c3 = c3_base + 19 * c3_x19;\n\n    let c4 = v2 *  v2 + 2 * (v1 *  v3) + 2 * (v0 *  v4);\n\n    // group in preparation for the substitution\n    assert(as_nat(v) * as_nat(v) ==\n        s4 * c4 +\n        s3 * (s5 * c3_x19 + c3_base) +\n        s2 * (s5 * c2_x19 + c2_base) +\n        s1 * (s5 * c1_x19 + c1_base) +\n             (s5 * c0_x19 + c0_base)\n    ) by {\n        // s3 terms\n        assert(\n            s8 * c3_x19 + s3 * c3_base\n            ==\n            s3 * (s5 * c3_x19 + c3_base)\n        ) by {\n            assert(s8 == (s3 * s5)) by {\n                lemma_pow2_adds(3 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s3 as int, s5 as int, c3_x19);\n            lemma_mul_is_distributive_add(s3 as int, s5 * c3_x19, c3_base)\n        }\n\n        // s2 terms\n        assert(\n            s7 * c2_x19 + s2 * c2_base\n            ==\n            s2 * (s5 * c2_x19 + c2_base)\n        ) by {\n            assert(s7 == (s2 * s5)) by {\n                lemma_pow2_adds(2 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s2 as int, s5 as int, c2_x19);\n            lemma_mul_is_distributive_add(s2 as int, s5 * c2_x19, c2_base)\n        }\n\n        // s1 terms\n        assert(\n            s6 * c1_x19 + s1 * c1_base\n            ==\n            s1 * (s5 * c1_x19 + c1_base)\n        ) by {\n            assert(s6 == (s1 * s5)) by {\n                lemma_pow2_adds(1 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s1 as int, s5 as int, c1_x19);\n            lemma_mul_is_distributive_add(s1 as int, s5 * c1_x19, c1_base)\n        }\n    }\n\n    // Next we use the identity s5 = p + 19\n    assert(s5 * c3_x19 + c3_base == p() * c3_x19 + c3) by {\n        lemma_mul_is_distributive_add(c3_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c2_x19 + c2_base == p() * c2_x19 + c2) by {\n        lemma_mul_is_distributive_add(c2_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c1_x19 + c1_base == p() * c1_x19 + c1) by {\n        lemma_mul_is_distributive_add(c1_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c0_x19 + c0_base == p() * c0_x19 + c0) by {\n        lemma_mul_is_distributive_add(c0_x19 as int, p() as int, 19);\n    }\n\n    // in summary, we can reorder and regroup terms to get X * p() + Y\n    assert(as_nat(v) * as_nat(v) ==\n        p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 ) +\n        (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        )\n    ) by {\n        lemma_mul_is_distributive_add(s3 as int, p() * c3_x19, c3 as int);\n        lemma_mul_is_distributive_add(s2 as int, p() * c2_x19, c2 as int);\n        lemma_mul_is_distributive_add(s1 as int, p() * c1_x19, c1 as int);\n\n        assert(\n            s3 * (p() * c3_x19) + s2 * (p() * c2_x19) + s1 * (p() * c1_x19) + p() * c0_x19\n            ==\n            p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 )\n        ) by {\n            lemma_mul_is_associative(s3 as int, c3_x19 as int, p() as int);\n            lemma_mul_is_associative(s2 as int, c2_x19 as int, p() as int);\n            lemma_mul_is_associative(s1 as int, c1_x19 as int, p() as int);\n\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19, s2 * c2_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19, s1 * c1_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19, c0_x19 as int);\n        }\n    }\n\n\n    let k = ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 );\n    let sum = (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        );\n\n    assert(as_nat(v) * as_nat(v) == k * p() + sum);\n    assert(k * p() + sum == (k as nat) * p() + (sum as nat));\n\n    // Now, we simply move to mod p\n\n    assert((as_nat(v) * as_nat(v)) % p() == ((k as nat) * p() + (sum as nat)) % p() );\n    assert(\n        ((k as nat) * p() + (sum as nat)) % p() ==\n        (sum as nat) % p()\n    ) by {\n        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}\n\npub proof fn as_nat_k(a: [u64;5], k: u64)\n    requires\n        forall |i:int| 0 <= i < 5 ==> (k * a[i]) <= u64::MAX\n    ensures\n        as_nat([\n            (k * a[0]) as u64,\n            (k * a[1]) as u64,\n            (k * a[2]) as u64,\n            (k * a[3]) as u64,\n            (k * a[4]) as u64\n            ]) == k * as_nat(a)\n{\n    let ka = [\n            (k * a[0]) as u64,\n            (k * a[1]) as u64,\n            (k * a[2]) as u64,\n            (k * a[3]) as u64,\n            (k * a[4]) as u64\n            ];\n\n    assert(as_nat(ka) ==\n        k * a[0] +\n        k * (pow2( 51) * a[1]) +\n        k * (pow2(102) * a[2]) +\n        k * (pow2(153) * a[3]) +\n        k * (pow2(204) * a[4])\n    ) by {\n        lemma_mul_is_associative(pow2( 51) as int, a[1] as int, k as int);\n        lemma_mul_is_associative(pow2(102) as int, a[2] as int, k as int);\n        lemma_mul_is_associative(pow2(153) as int, a[3] as int, k as int);\n        lemma_mul_is_associative(pow2(204) as int, a[4] as int, k as int);\n    }\n\n    assert(\n        k * a[0] +\n        k * (pow2( 51) * a[1]) +\n        k * (pow2(102) * a[2]) +\n        k * (pow2(153) * a[3]) +\n        k * (pow2(204) * a[4])\n        ==\n        k * (\n            a[0] +\n            (pow2( 51) * a[1]) +\n            (pow2(102) * a[2]) +\n            (pow2(153) * a[3]) +\n            (pow2(204) * a[4])\n        )\n    ) by {\n        lemma_mul_is_distributive_add(k as int, a[0] as int, pow2( 51) * a[1]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1], pow2(102) * a[2]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1] + pow2(102) * a[2], pow2(153) * a[3]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1] + pow2(102) * a[2] + pow2(153) * a[3], (pow2(204) * a[4]));\n    }\n}\n\n// Auxiliary lemma for reordering terms in the pow2k proof\npub proof fn lemma_reorder_mul(a: int, b: int)\n    ensures\n        2 * (a * (19 * b)) == 19 * (2 * (a * b))\n{\n    // 2*( a * (19 * b)) = (2 * a) * (19 * b)\n    lemma_mul_is_associative(2, a, 19 * b);\n    // (2 * a) * (19 * b) = (19 * b) * (2 * a) = 19 * (b * (2 * a))\n    lemma_mul_is_associative(19, b, 2 * a);\n    // (b * (2 * a)) = (b * (a * 2)) = 2 * (a * b)\n    lemma_mul_is_associative(b, a, 2);\n}\n\npub proof fn lemma_mul_sub(ci: int, cj: int, cj_0: int, k: nat)\n    ensures\n        pow2(k) * (ci - pow2(51) * (cj - cj_0)) == pow2(k) * ci - pow2(k + 51) * cj + pow2(k + 51) * cj_0\n{\n    // 2^k (ci - X) = 2^k ci - 2^k X\n    lemma_mul_is_distributive_sub(pow2(k) as int, ci, pow2(51) * (cj - cj_0));\n    // 2^k (2^51 * Y) = (2^k * 2^51) * Y\n    lemma_mul_is_associative(pow2(k) as int, pow2(51) as int, cj - cj_0);\n    // 2^k * 2^51 = 2^(k + 51)\n    lemma_pow2_adds(k, 51);\n    // 2^(k + 51) * (cj - cj_0) = 2^(k + 51) * cj - 2^(k + 51) * cj_0\n    lemma_mul_is_distributive_sub(pow2(k + 51) as int, cj, cj_0);\n}\n\npub proof fn term_product_bounds(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        // c0\n        (a[0] as u128) * (a[0] as u128) < bound * bound,\n        (a[1] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        (a[2] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        // c1\n        (a[3] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        (a[0] as u128) * (a[1] as u128) < (bound * bound),\n        (a[2] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        // c2\n        (a[1] as u128) * (a[1] as u128) < (bound * bound),\n        (a[0] as u128) * (a[2] as u128) < (bound * bound),\n        (a[4] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        // c3\n        (a[4] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        (a[0] as u128) * (a[3] as u128) < (bound * bound),\n        (a[1] as u128) * (a[2] as u128) < (bound * bound),\n        // c4\n        (a[2] as u128) * (a[2] as u128) < (bound * bound),\n        (a[0] as u128) * (a[4] as u128) < (bound * bound),\n        (a[1] as u128) * (a[3] as u128) < (bound * bound)\n{\n    let bound19 = (19 * bound) as u64;\n\n    let a3_19 = (19 * a[3]) as u64;\n    let a4_19 = (19 * a[4]) as u64;\n\n    assert(bound * (19 * bound) == 19 * (bound * bound)) by {\n        lemma_mul_is_associative(19, bound as int, bound as int);\n    }\n\n    // c0\n    lemma_m(a[0], a[0], bound, bound);\n    lemma_m(a[1], a4_19, bound, bound19);\n    lemma_m(a[2], a3_19, bound, bound19);\n\n    // c1\n    lemma_m(a[3], a3_19, bound, bound19);\n    lemma_m(a[0],  a[1], bound, bound);\n    lemma_m(a[2], a4_19, bound, bound19);\n\n    // c2\n    lemma_m(a[1],  a[1], bound, bound);\n    lemma_m(a[0],  a[2], bound, bound);\n    lemma_m(a[4], a3_19, bound, bound19);\n\n    // c3\n    lemma_m(a[4], a4_19, bound, bound19);\n    lemma_m(a[0],  a[3], bound, bound);\n    lemma_m(a[1],  a[2], bound, bound);\n\n    // c4\n    lemma_m(a[2],  a[2], bound, bound);\n    lemma_m(a[0],  a[4], bound, bound);\n    lemma_m(a[1],  a[3], bound, bound);\n}\n\npub open spec fn c0_0_val(a: [u64; 5]) -> u128 {\n    (a[0] *  a[0] + 2*( a[1] * (19 * a[4]) + a[2] * (19 * a[3]))) as u128\n}\npub open spec fn c1_0_val(a: [u64; 5]) -> u128 {\n    (a[3] *  (19 * a[3]) + 2 *( a[0] * a[1] + a[2] * (19 * a[4]))) as u128\n}\npub open spec fn c2_0_val(a: [u64;5]) -> u128{\n    (a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * (19 * a[3]))) as u128\n}\npub open spec fn c3_0_val(a: [u64;5]) -> u128{\n    (a[4] * (19 * a[4]) + 2*( a[0] *  a[3] + a[1] * a[2])) as u128\n}\npub open spec fn c4_0_val(a: [u64;5]) -> u128{\n    (a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3])) as u128\n}\n\npub proof fn c_i_0_bounded(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        c0_0_val(a) < 77 * (bound * bound),\n        c1_0_val(a) < 59 * (bound * bound),\n        c2_0_val(a) < 41 * (bound * bound),\n        c3_0_val(a) < 23 * (bound * bound),\n        c4_0_val(a) <  5 * (bound * bound)\n{\n    term_product_bounds(a, bound);\n}\n\npub open spec fn c0_val(a: [u64; 5]) -> u128 {\n    c0_0_val(a)\n}\npub open spec fn c1_val(a: [u64; 5]) -> u128 {\n    (c1_0_val(a) + ((c0_val(a) >> 51) as u64) as u128) as u128\n}\npub open spec fn c2_val(a: [u64;5]) -> u128{\n    (c2_0_val(a) + ((c1_val(a) >> 51) as u64) as u128) as u128\n}\npub open spec fn c3_val(a: [u64;5]) -> u128{\n    (c3_0_val(a) + ((c2_val(a) >> 51) as u64) as u128) as u128\n}\npub open spec fn c4_val(a: [u64;5]) -> u128{\n    (c4_0_val(a) + ((c3_val(a) >> 51) as u64) as u128) as u128\n}\n\npub proof fn c_i_shift_bounded(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51),\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        (c0_val(a) >> 51) <= (u64::MAX as u128),\n        (c1_val(a) >> 51) <= (u64::MAX as u128),\n        (c2_val(a) >> 51) <= (u64::MAX as u128),\n        (c3_val(a) >> 51) <= (u64::MAX as u128),\n        (c4_val(a) >> 51) <= (u64::MAX as u128)\n\n{\n    c_i_0_bounded(a, bound);\n\n    lemma_shr_51_fits_u64(c0_val(a));\n    lemma_shr_51_fits_u64(c1_val(a));\n    lemma_shr_51_fits_u64(c2_val(a));\n    lemma_shr_51_fits_u64(c3_val(a));\n    lemma_shr_51_fits_u64(c4_val(a));\n}\n\npub open spec fn carry_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) >> 51) as u64\n}\n\npub open spec fn a0_0_val(a: [u64; 5]) -> u64 {\n    (c0_val(a) as u64) & mask51\n}\npub open spec fn a1_0_val(a: [u64; 5]) -> u64 {\n    (c1_val(a) as u64) & mask51\n}\npub open spec fn a2_0_val(a: [u64; 5]) -> u64 {\n    (c2_val(a) as u64) & mask51\n}\npub open spec fn a3_0_val(a: [u64; 5]) -> u64 {\n    (c3_val(a) as u64) & mask51\n}\npub open spec fn a4_0_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) as u64) & mask51\n}\n\n\n// dummy, so we can call `verus`\nfn main() {}\n\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65044": {
    "text": "//! Arithmetic mod \\\\(2\\^{252} + 27742317777372353535851937790883648493\\\\)\n//! with five \\\\(52\\\\)-bit unsigned limbs.\n//!\n//! \\\\(51\\\\)-bit limbs would cover the desired bit range (\\\\(253\\\\)\n//! bits), but isn't large enough to reduce a \\\\(512\\\\)-bit number with\n//! Montgomery multiplication, so \\\\(52\\\\) bits is used instead.  To see\n//! that this is safe for intermediate results, note that the largest\n//! limb in a \\\\(5\\times 5\\\\) product of \\\\(52\\\\)-bit limbs will be\n//!\n//! ```text\n//! (0xfffffffffffff^2) * 5 = 0x4ffffffffffff60000000000005 (107 bits).\n//! ```\n\nuse core::fmt::Debug;\nuse core::ops::{Index, IndexMut};\nuse subtle::Choice;\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::Zeroize;\n\nuse crate::constants;\n\n#[allow(unused_imports)]\nuse super::scalar_lemmas::*;\n#[allow(unused_imports)]\nuse super::scalar_specs::*;\nuse super::subtle_assumes::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\nuse vstd::prelude::*;\n\nverus! {\n/// The `Scalar52` struct represents an element in\n/// \\\\(\\mathbb Z / \\ell \\mathbb Z\\\\) as 5 \\\\(52\\\\)-bit limbs.\n#[derive(Copy, Clone)]\npub struct Scalar52 {\n    pub limbs: [u64; 5],\n}\n\n} // verus!\n\nimpl Debug for Scalar52 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", self.limbs)\n    }\n}\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for Scalar52 {\n//     fn zeroize(&mut self) {\n//         self.limbs.zeroize();\n//     }\n// }\n\nverus! {\nimpl Index<usize> for Scalar52 {\n    type Output = u64;\n    // TODO Verify this\n    #[verifier::external_body]\n    fn index(&self, _index: usize) -> &u64 {\n        &(self.limbs[_index])\n    }\n}\n} // verus!\n\nimpl IndexMut<usize> for Scalar52 {\n    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.limbs[_index])\n    }\n}\n\nverus! {\n\n/// u64 * u64 = u128 multiply helper\n#[inline(always)]\nfn m(x: u64, y: u64) -> (z: u128)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures\n    z < (1u128 << 104),\n    z == x * y\n{\n    proof {lemma_52_52(x, y);}\n    (x as u128) * (y as u128)\n}\n\nimpl Scalar52 {\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: Scalar52 = Scalar52 { limbs: [0, 0, 0, 0, 0] };\n\n    /// Unpack a 32 byte / 256 bit scalar into 5 52-bit limbs.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n    ensures bytes_to_nat(bytes) == to_nat(&s.limbs)\n    {\n        let mut words = [0u64; 4];\n        for i in 0..4\n            invariant 0 <= i <= 4 // proof\n        {\n            for j in 0..8\n                invariant 0 <= j <= 8 && i < 4\n            {\n                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64)*8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)\n        assume(bytes_to_nat(bytes) == words_to_nat(&words));\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        //test workflow graphs\n        s.limbs[0] =   words[0]                            & mask;\n        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] =  (words[3] >> 16)                     & top_mask;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }\n\n    /// Reduce a 64 byte / 512 bit scalar mod l\n    #[rustfmt::skip] // keep alignment of lo[*] and hi[*] calculations\n    #[verifier::external_body] // TODO Verify this function\n    pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n    ensures\n        limbs_bounded(&s),\n        to_nat(&s.limbs) == bytes_wide_to_nat(bytes) % group_order(),\n    {\n        assume(false); // TODO: complete the proof\n        let mut words = [0u64; 8];\n        for i in 0..8 {\n            for j in 0..8 {\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        let mut hi = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n\n        lo[0] =   words[0]                             & mask;\n        lo[1] = ((words[0] >> 52) | (words[ 1] << 12)) & mask;\n        lo[2] = ((words[1] >> 40) | (words[ 2] << 24)) & mask;\n        lo[3] = ((words[2] >> 28) | (words[ 3] << 36)) & mask;\n        lo[4] = ((words[3] >> 16) | (words[ 4] << 48)) & mask;\n        hi[0] =  (words[4] >>  4)                      & mask;\n        hi[1] = ((words[4] >> 56) | (words[ 5] <<  8)) & mask;\n        hi[2] = ((words[5] >> 44) | (words[ 6] << 20)) & mask;\n        hi[3] = ((words[6] >> 32) | (words[ 7] << 32)) & mask;\n        hi[4] =   words[7] >> 20                             ;\n\n        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar52::add(&hi, &lo)\n    }\n\n    /// Pack the limbs of this `Scalar52` into 32 bytes\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    #[allow(clippy::identity_op)]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_bytes(self) -> (s: [u8; 32])\n    ensures bytes_to_nat(&s) == to_nat(&self.limbs)\n    {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.limbs[ 0] >>  0)                      as u8;\n        s[ 1] =  (self.limbs[ 0] >>  8)                      as u8;\n        s[ 2] =  (self.limbs[ 0] >> 16)                      as u8;\n        s[ 3] =  (self.limbs[ 0] >> 24)                      as u8;\n        s[ 4] =  (self.limbs[ 0] >> 32)                      as u8;\n        s[ 5] =  (self.limbs[ 0] >> 40)                      as u8;\n        s[ 6] = ((self.limbs[ 0] >> 48) | (self.limbs[ 1] << 4)) as u8;\n        s[ 7] =  (self.limbs[ 1] >>  4)                      as u8;\n        s[ 8] =  (self.limbs[ 1] >> 12)                      as u8;\n        s[ 9] =  (self.limbs[ 1] >> 20)                      as u8;\n        s[10] =  (self.limbs[ 1] >> 28)                      as u8;\n        s[11] =  (self.limbs[ 1] >> 36)                      as u8;\n        s[12] =  (self.limbs[ 1] >> 44)                      as u8;\n        s[13] =  (self.limbs[ 2] >>  0)                      as u8;\n        s[14] =  (self.limbs[ 2] >>  8)                      as u8;\n        s[15] =  (self.limbs[ 2] >> 16)                      as u8;\n        s[16] =  (self.limbs[ 2] >> 24)                      as u8;\n        s[17] =  (self.limbs[ 2] >> 32)                      as u8;\n        s[18] =  (self.limbs[ 2] >> 40)                      as u8;\n        s[19] = ((self.limbs[ 2] >> 48) | (self.limbs[ 3] << 4)) as u8;\n        s[20] =  (self.limbs[ 3] >>  4)                      as u8;\n        s[21] =  (self.limbs[ 3] >> 12)                      as u8;\n        s[22] =  (self.limbs[ 3] >> 20)                      as u8;\n        s[23] =  (self.limbs[ 3] >> 28)                      as u8;\n        s[24] =  (self.limbs[ 3] >> 36)                      as u8;\n        s[25] =  (self.limbs[ 3] >> 44)                      as u8;\n        s[26] =  (self.limbs[ 4] >>  0)                      as u8;\n        s[27] =  (self.limbs[ 4] >>  8)                      as u8;\n        s[28] =  (self.limbs[ 4] >> 16)                      as u8;\n        s[29] =  (self.limbs[ 4] >> 24)                      as u8;\n        s[30] =  (self.limbs[ 4] >> 32)                      as u8;\n        s[31] =  (self.limbs[ 4] >> 40)                      as u8;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }\n\n    /// Compute `a + b` (mod l)\n    pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order(),\n    {\n        let mut sum = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector); }\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        for i in 0..5\n           invariant\n                    forall|j: int| 0 <= j < i ==> sum.limbs[j] < 1u64 << 52,\n                    limbs_bounded(a),\n                    limbs_bounded(b),\n                    mask == (1u64 << 52) - 1,\n                    i == 0 ==> carry == 0,\n                    i >= 1 ==> (carry >> 52) < 2,\n        {\n            proof {lemma_add_loop_bounds(i as int, carry, a.limbs[i as int], b.limbs[i as int]);}\n            carry = a.limbs[i] + b.limbs[i] + (carry >> 52);\n            sum.limbs[i] = carry & mask;\n            proof {lemma_add_carry_and_sum_bounds(carry, mask);}\n        }\n\n        // subtract l if the sum is >= l\n        proof { lemma_l_value_properties(&constants::L, &sum); }\n        assume(to_nat(&sum.limbs) < 2 * group_order());\n        assert(group_order() > to_nat(&sum.limbs) - group_order() >= -group_order());\n        proof{lemma_l_equals_group_order();}\n        let result = Scalar52::sub(&sum, &constants::L);\n        assume(to_nat(&result.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order());\n        result\n\n    }\n\n    /// Compute `a - b` (mod l)\n    pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        // Without the following condition, all we can prove is something like:\n        // to_nat(&a.limbs) >= to_nat(&b.limbs) ==> to_nat(&s.limbs) == to_nat(&a.limbs) - to_nat(&b.limbs),\n        // to_nat(&a.limbs) < to_nat(&b.limbs) ==> to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs) + pow2(260) + group_order()) % (pow2(260) as int),\n        // In the 2nd case, `sub` doesn't always do subtraction mod group_order\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n        limbs_bounded(&s),\n    {\n        let mut difference = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector);}\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 0 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int )));\n        assert( (borrow >> 63) == 0 ) by (bit_vector)\n            requires borrow == 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 0 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int )) - (borrow >> 63) * pow2((52 * (0) as nat)));\n        for i in 0..5\n            invariant\n                      limbs_bounded(b),\n                      limbs_bounded(a),\n                      forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n                      mask == (1u64 << 52) - 1,\n                      seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int )) - (borrow >> 63) * pow2((52 * (i) as nat))\n        {\n            proof { assert ((borrow >> 63) < 2) by (bit_vector); }\n            let ghost old_borrow = borrow;\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            let ghost difference_loop1_start = difference;\n            difference.limbs[i] = borrow & mask;\n            assert(difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n            assert(\n            seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                        seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int )) - (old_borrow >> 63) * pow2((52 * (i) as nat)));\n            proof{\n                lemma_sub_loop1_invariant(difference, borrow, i, a, b, old_borrow, mask, difference_loop1_start);\n            }\n            proof { lemma_borrow_and_mask_bounded(borrow, mask); }\n        }\n\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)) );\n        // conditionally add l if the difference is negative\n        assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n        let mut carry: u64 = 0;\n        let ghost difference_after_loop1 = difference;\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int)) == 0);\n        assert(carry >> 52 == 0) by (bit_vector)\n            requires carry == 0;\n        for i in 0..5\n            invariant\n                      forall|j: int| 0 <= j < 5 ==> difference.limbs[j] < (1u64 << 52),  // from first loop\n                      forall|j: int| i <= j < 5 ==> difference.limbs[j] == difference_after_loop1.limbs[j],\n                      mask == (1u64 << 52) - 1,\n                      i == 0 ==> carry == 0,\n                      i >= 1 ==> (carry >> 52) < 2,\n                      (i >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i-1],\n                      borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n                      borrow >> 63 == 1 ==>\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) * pow2(52 * i as nat)\n\n        {\n            let ghost old_carry = carry;\n            let underflow = Choice::from((borrow >> 63) as u8);\n            let addend = select(&0, &constants::L.limbs[i], underflow);\n            if borrow >> 63 == 0 {\n                assert(addend == 0);\n            }\n            if borrow >> 63 == 1 {\n                assert(addend == constants::L.limbs[i as int]);\n            }\n            proof {lemma_scalar_subtract_no_overflow(carry, difference.limbs[i as int], addend, i as u32, &constants::L);}\n            carry = (carry >> 52) + difference.limbs[i] + addend;\n            let ghost difference_loop2_start = difference;\n            difference.limbs[i] = carry & mask;\n            proof {\n                lemma_carry_bounded_after_mask(carry, mask);\n                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n                lemma_sub_loop2_invariant(difference, i, a, b, mask, difference_after_loop1, difference_loop2_start, carry, old_carry, addend, borrow);\n            }\n        }\n        proof { lemma_sub_correct_after_loops(difference, carry, a, b, difference_after_loop1, borrow);}\n        difference\n    }\n\n    /// Compute `a * b`\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of z[*] calculations\n    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&b.limbs),\n    {\n        proof {lemma_mul_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n\n        z[0] = m(a.limbs[0], b.limbs[0]);\n        z[1] = m(a.limbs[0], b.limbs[1]) + m(a.limbs[1], b.limbs[0]);\n        z[2] = m(a.limbs[0], b.limbs[2]) + m(a.limbs[1], b.limbs[1]) + m(a.limbs[2], b.limbs[0]);\n        z[3] = m(a.limbs[0], b.limbs[3]) + m(a.limbs[1], b.limbs[2]) + m(a.limbs[2], b.limbs[1]) + m(a.limbs[3], b.limbs[0]);\n        z[4] = m(a.limbs[0], b.limbs[4]) + m(a.limbs[1], b.limbs[3]) + m(a.limbs[2], b.limbs[2]) + m(a.limbs[3], b.limbs[1]) + m(a.limbs[4], b.limbs[0]);\n        z[5] =                 m(a.limbs[1], b.limbs[4]) + m(a.limbs[2], b.limbs[3]) + m(a.limbs[3], b.limbs[2]) + m(a.limbs[4], b.limbs[1]);\n        z[6] =                                 m(a.limbs[2], b.limbs[4]) + m(a.limbs[3], b.limbs[3]) + m(a.limbs[4], b.limbs[2]);\n        z[7] =                                                 m(a.limbs[3], b.limbs[4]) + m(a.limbs[4], b.limbs[3]);\n        z[8] =                                                                 m(a.limbs[4], b.limbs[4]);\n\n        proof {lemma_mul_internal_correct(&a.limbs, &b.limbs, &z);}\n\n        z\n    }\n\n\n    // TODO Make this function more like the original?\n    /// Compute `a^2`\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of calculations\n    pub (crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n    {\n        proof {lemma_square_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(a.limbs[2], a.limbs[2]);\n        z[5] =                 m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] =                                 m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] =                                                 m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] =                                                                 m(a.limbs[4], a.limbs[4]);\n\n        proof {lemma_square_internal_correct(&a.limbs, &z);}\n\n        z\n    }\n\n    /// Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^260\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of n* and r* calculations\n    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    ensures\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == slice128_to_nat(limbs) % group_order(),\n        limbs_bounded(&result),\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = Self::part1(limbs[0]);\n        let (carry, n1) = Self::part1(carry + limbs[1] + m(n0, l.limbs[1]));\n        let (carry, n2) = Self::part1(carry + limbs[2] + m(n0, l.limbs[2]) + m(n1, l.limbs[1]));\n        let (carry, n3) = Self::part1(carry + limbs[3] + m(n1, l.limbs[2]) + m(n2, l.limbs[1]));\n        let (carry, n4) = Self::part1(carry + limbs[4] + m(n0, l.limbs[4]) + m(n2, l.limbs[2]) + m(n3, l.limbs[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = Self::part2(carry + limbs[5] + m(n1, l.limbs[4]) + m(n3, l.limbs[2]) + m(n4, l.limbs[1]));\n        let (carry, r1) = Self::part2(carry + limbs[6] + m(n2, l.limbs[4]) + m(n4, l.limbs[2]));\n        let (carry, r2) = Self::part2(carry + limbs[7] + m(n3, l.limbs[4]));\n        let (carry, r3) = Self::part2(carry + limbs[8] + m(n4, l.limbs[4]));\n        let r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52 { limbs: [r0, r1, r2, r3, r4] }, l)\n    }\n\n\n    /// Helper function for Montgomery reduction\n    #[inline(always)]\n    fn part1(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n        let carry = (sum + m(p, constants::L.limbs[0])) >> 52;\n        (carry, p)\n    }\n\n    /// Helper function for Montgomery reduction\n    #[inline(always)]\n    fn part2(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let w = (sum as u64) & ((1u64 << 52) - 1);\n        let carry = sum >> 52;\n        (carry, w)\n    }\n\n    /// Compute `a * b` (mod l)\n    #[inline(never)]\n    pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR))\n    }\n\n    /// Compute `a^2` (mod l)\n    #[inline(never)]\n    #[allow(dead_code)] // XXX we don't expose square() via the Scalar API\n    pub fn square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR))\n    }\n\n    /// Compute `(a * b) / R` (mod l), where R is the Montgomery modulus 2^260\n    #[inline(never)]\n    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }\n\n    /// Compute `(a^2) / R` (mod l) in Montgomery form, where R is the Montgomery modulus 2^260\n    #[inline(never)]\n    pub fn montgomery_square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }\n\n    /// Puts a Scalar52 in to Montgomery form, i.e. computes `a*R (mod l)`\n    #[inline(never)]\n    pub fn as_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order(),\n    {\n        proof {\n            lemma_rr_limbs_bounded();\n        }\n        let result = Scalar52::montgomery_mul(self, &constants::RR);\n        assume(to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order());\n        result\n    }\n\n    /// Takes a Scalar52 out of Montgomery form, i.e. computes `a/R (mod l)`\n    #[allow(clippy::wrong_self_convention)]\n    #[inline(never)]\n    pub fn from_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == to_nat(&self.limbs) % group_order(),\n    {\n        let mut limbs = [0u128; 9];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5\n            invariant\n                forall|j: int| #![auto] 0 <= j < i ==> limbs[j] == self.limbs[j] as u128,\n                forall|j: int| #![auto] i <= j < 9 ==> limbs[j] == 0,\n        {\n            limbs[i] = self.limbs[i] as u128;\n        }\n        let result = Scalar52::montgomery_reduce(&limbs);\n        proof {\n            lemma_from_montgomery_limbs_conversion(&limbs, &self.limbs);\n        }\n        result\n    }\n}\n\n\n} // verus!\n\n// #[cfg(test)]\n// mod test {\n//     use super::*;\n\n//     /// Note: x is 2^253-1 which is slightly larger than the largest scalar produced by\n//     /// this implementation (l-1), and should show there are no overflows for valid scalars\n//     ///\n//     /// x = 14474011154664524427946373126085988481658748083205070504932198000989141204991\n//     /// x = 7237005577332262213973186563042994240801631723825162898930247062703686954002 mod l\n//     /// x = 3057150787695215392275360544382990118917283750546154083604586903220563173085*R mod l in Montgomery form\n//     pub static X: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x000fffffffffffff,\n//             0x000fffffffffffff,\n//             0x000fffffffffffff,\n//             0x000fffffffffffff,\n//             0x00001fffffffffff,\n//         ],\n//     };\n\n//     /// x^2 = 3078544782642840487852506753550082162405942681916160040940637093560259278169 mod l\n//     pub static XX: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x0001668020217559,\n//             0x000531640ffd0ec0,\n//             0x00085fd6f9f38a31,\n//             0x000c268f73bb1cf4,\n//             0x000006ce65046df0,\n//         ],\n//     };\n\n//     /// x^2 = 4413052134910308800482070043710297189082115023966588301924965890668401540959*R mod l in Montgomery form\n//     pub static XX_MONT: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x000c754eea569a5c,\n//             0x00063b6ed36cb215,\n//             0x0008ffa36bf25886,\n//             0x000e9183614e7543,\n//             0x0000061db6c6f26f,\n//         ],\n//     };\n\n//     /// y = 6145104759870991071742105800796537629880401874866217824609283457819451087098\n//     pub static Y: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x000b75071e1458fa,\n//             0x000bf9d75e1ecdac,\n//             0x000433d2baf0672b,\n//             0x0005fffcc11fad13,\n//             0x00000d96018bb825,\n//         ],\n//     };\n\n//     /// x*y = 36752150652102274958925982391442301741 mod l\n//     pub static XY: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x000ee6d76ba7632d,\n//             0x000ed50d71d84e02,\n//             0x00000000001ba634,\n//             0x0000000000000000,\n//             0x0000000000000000,\n//         ],\n//     };\n\n//     /// x*y = 658448296334113745583381664921721413881518248721417041768778176391714104386*R mod l in Montgomery form\n//     pub static XY_MONT: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x0006d52bf200cfd5,\n//             0x00033fb1d7021570,\n//             0x000f201bc07139d8,\n//             0x0001267e3e49169e,\n//             0x000007b839c00268,\n//         ],\n//     };\n\n//     /// a = 2351415481556538453565687241199399922945659411799870114962672658845158063753\n//     pub static A: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x0005236c07b3be89,\n//             0x0001bc3d2a67c0c4,\n//             0x000a4aa782aae3ee,\n//             0x0006b3f6e4fec4c4,\n//             0x00000532da9fab8c,\n//         ],\n//     };\n\n//     /// b = 4885590095775723760407499321843594317911456947580037491039278279440296187236\n//     pub static B: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x000d3fae55421564,\n//             0x000c2df24f65a4bc,\n//             0x0005b5587d69fb0b,\n//             0x00094c091b013b3b,\n//             0x00000acd25605473,\n//         ],\n//     };\n\n//     /// a+b = 0\n//     /// a-b = 4702830963113076907131374482398799845891318823599740229925345317690316127506\n//     pub static AB: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x000a46d80f677d12,\n//             0x0003787a54cf8188,\n//             0x0004954f0555c7dc,\n//             0x000d67edc9fd8989,\n//             0x00000a65b53f5718,\n//         ],\n//     };\n\n//     // c = (2^512 - 1) % l = 1627715501170711445284395025044413883736156588369414752970002579683115011840\n//     pub static C: Scalar52 = Scalar52 {\n//         limbs: [\n//             0x000611e3449c0f00,\n//             0x000a768859347a40,\n//             0x0007f5be65d00e1b,\n//             0x0009a3dceec73d21,\n//             0x00000399411b7c30,\n//         ],\n//     };\n\n//     #[test]\n//     fn mul_max() {\n//         let res = Scalar52::mul(&X, &X);\n//         for i in 0..5 {\n//             assert!(res[i] == XX[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn square_max() {\n//         let res = X.square();\n//         for i in 0..5 {\n//             assert!(res[i] == XX[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn montgomery_mul_max() {\n//         let res = Scalar52::montgomery_mul(&X, &X);\n//         for i in 0..5 {\n//             assert!(res[i] == XX_MONT[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn montgomery_square_max() {\n//         let res = X.montgomery_square();\n//         for i in 0..5 {\n//             assert!(res[i] == XX_MONT[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn mul() {\n//         let res = Scalar52::mul(&X, &Y);\n//         for i in 0..5 {\n//             assert!(res[i] == XY[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn montgomery_mul() {\n//         let res = Scalar52::montgomery_mul(&X, &Y);\n//         for i in 0..5 {\n//             assert!(res[i] == XY_MONT[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn add() {\n//         let res = Scalar52::add(&A, &B);\n//         let zero = Scalar52::ZERO;\n//         for i in 0..5 {\n//             assert!(res[i] == zero[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn sub() {\n//         let res = Scalar52::sub(&A, &B);\n//         for i in 0..5 {\n//             assert!(res[i] == AB[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn from_bytes_wide() {\n//         let bignum = [255u8; 64]; // 2^512 - 1\n//         let reduced = Scalar52::from_bytes_wide(&bignum);\n//         for i in 0..5 {\n//             assert!(reduced[i] == C[i]);\n//         }\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65045": {
    "text": "//! Tell Verus what Choice does\nuse subtle::{Choice, ConditionallySelectable};\n\nuse vstd::prelude::*;\n\nverus! {\n\n#[allow(dead_code)]\npub enum RevealedChoice {\n    Choice0,\n    Choice1,\n}\n\n#[verifier::external_type_specification]\n#[verifier::external_body]\n#[allow(dead_code)]\npub struct ExChoice(Choice);\n\npub uninterp spec fn reveal_choice(c: Choice) -> RevealedChoice;\n\npub assume_specification [Choice::from](u: u8) -> (c: Choice)\n    ensures u == 0 ==> reveal_choice(c) == RevealedChoice::Choice0,\n            u == 1 ==> reveal_choice(c) == RevealedChoice::Choice1;\n\n#[verifier::external_body]\n/// See https://docs.rs/subtle/latest/subtle/trait.ConditionallySelectable.html#tymethod.conditional_select\npub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64)\n    ensures reveal_choice(c) == RevealedChoice::Choice0 ==> res == a,\n            reveal_choice(c) == RevealedChoice::Choice1 ==> res == b\n{\n    u64::conditional_select(a, b, c)\n}\n\n} // verus!\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65046": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Field arithmetic modulo \\\\(p = 2\\^{255} - 19\\\\), using \\\\(64\\\\)-bit\n//! limbs with \\\\(128\\\\)-bit products.\n\nuse core::fmt::Debug;\nuse core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};\nuse core::ops::{Sub, SubAssign};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::Zeroize;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51(pub(crate) [u64; 5]);\n\nimpl Debug for FieldElement51 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.0[..])\n    }\n}\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for FieldElement51 {\n//     fn zeroize(&mut self) {\n//         self.0.zeroize();\n//     }\n// }\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(&mut self, _rhs: &'a FieldElement51) {\n        for i in 0..5 {\n            self.0[i] += _rhs.0[i];\n        }\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n    fn add(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n    fn sub(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        FieldElement51::reduce([\n            (self.0[0] + 36028797018963664u64) - _rhs.0[0],\n            (self.0[1] + 36028797018963952u64) - _rhs.0[1],\n            (self.0[2] + 36028797018963952u64) - _rhs.0[2],\n            (self.0[3] + 36028797018963952u64) - _rhs.0[3],\n            (self.0[4] + 36028797018963952u64) - _rhs.0[4],\n        ])\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) * _rhs;\n        self.0 = result.0;\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip] // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.0;\n        let b: &[u64; 5] = &_rhs.0;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        // Multiply to get 128-bit coefficients of output\n        let     c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(a[1], b4_19);\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0],  b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(a[2], b4_19);\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1],  b[1]) + m(a[0],  b[2]) + m(a[4], b3_19) + m(a[3], b4_19);\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2],  b[1]) + m(a[1],  b[2]) + m(a[0],  b[3]) + m(a[4], b4_19);\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3],  b[1]) + m(a[2],  b[2]) + m(a[1],  b[3]) + m(a[0] , b[4]);\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));\n        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));\n        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));\n        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));\n        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n        let mut out = [0u64; 5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51(out)\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n    fn neg(self) -> FieldElement51 {\n        let mut output = *self;\n        output.negate();\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        FieldElement51([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice) {\n        self.0[0].conditional_assign(&other.0[0], choice);\n        self.0[1].conditional_assign(&other.0[1], choice);\n        self.0[2].conditional_assign(&other.0[2], choice);\n        self.0[3].conditional_assign(&other.0[3], choice);\n        self.0[4].conditional_assign(&other.0[4], choice);\n    }\n}\n\nimpl FieldElement51 {\n    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51(limbs)\n    }\n\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: FieldElement51 = FieldElement51::from_limbs([0, 0, 0, 0, 0]);\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: FieldElement51 = FieldElement51::from_limbs([1, 0, 0, 0, 0]);\n    /// The scalar \\\\( -1 \\\\).\n    pub const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n        2251799813685228,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n    ]);\n\n    /// Invert the sign of this field element\n    pub fn negate(&mut self) {\n        // See commentary in the Sub impl\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.0[0],\n            36028797018963952u64 - self.0[1],\n            36028797018963952u64 - self.0[2],\n            36028797018963952u64 - self.0[3],\n            36028797018963952u64 - self.0[4],\n        ]);\n        self.0 = neg.0;\n    }\n\n    /// Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).\n    #[inline(always)]\n    fn reduce(mut limbs: [u64; 5]) -> FieldElement51 {\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        FieldElement51(limbs)\n    }\n\n    /// Load a `FieldElement51` from the low 255 bits of a 256-bit\n    /// input.\n    ///\n    /// # Warning\n    ///\n    /// This function does not check that the input used the canonical\n    /// representative.  It masks the high bit, but it will happily\n    /// decode 2^255 - 18 to 1.  Applications that require a canonical\n    /// encoding of every field element should decode, re-encode to\n    /// the canonical encoding, and check that the input was\n    /// canonical.\n    ///\n    #[rustfmt::skip] // keep alignment of bit shifts\n    pub const fn from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }\n\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        FieldElement51(\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ])\n    }\n\n    /// Serialize this `FieldElement51` to a 32-byte array.  The\n    /// encoding is canonical.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    pub fn to_bytes(self) -> [u8; 32] {\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.0).0;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }\n\n    /// Given `k > 0`, return `self^(2^k)`.\n    #[rustfmt::skip] // keep alignment of c* calculations\n    pub fn pow2k(&self, mut k: u32) -> FieldElement51 {\n\n        debug_assert!( k > 0 );\n\n        /// Multiply two 64-bit integers with 128 bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }\n\n        let mut a: [u64; 5] = self.0;\n\n        loop {\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n\n            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n\n            k -= 1;\n            if k == 0 {\n                break;\n            }\n        }\n\n        FieldElement51(a)\n    }\n\n    /// Returns the square of this field element.\n    pub fn square(&self) -> FieldElement51 {\n        self.pow2k(1)\n    }\n\n    /// Returns 2 times the square of this field element.\n    pub fn square2(&self) -> FieldElement51 {\n        let mut square = self.pow2k(1);\n        for i in 0..5 {\n            square.0[i] *= 2;\n        }\n\n        square\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65047": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! This module contains backend-specific constant values, such as the 64-bit limbs of curve constants.\n\nuse super::field::FieldElement51;\nuse super::scalar::Scalar52;\nuse crate::edwards::EdwardsPoint;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::{\n    backend::serial::curve_models::AffineNielsPoint,\n    edwards::EdwardsBasepointTable,\n    window::{LookupTable, NafLookupTable8},\n};\n\nuse vstd::prelude::*;\n\n/// The value of minus one, equal to `-&FieldElement::ONE`\npub(crate) const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n    2251799813685228,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n]);\n\n/// sqrt(-486664)\n// #[cfg(feature = \"digest\")]\n// pub(crate) const ED25519_SQRTAM2: FieldElement51 = FieldElement51::from_limbs([\n//     1693982333959686,\n//     608509411481997,\n//     2235573344831311,\n//     947681270984193,\n//     266558006233600,\n// ]);\n\n/// Edwards `d` value, equal to `-121665/121666 mod p`.\npub(crate) const EDWARDS_D: FieldElement51 = FieldElement51::from_limbs([\n    929955233495203,\n    466365720129213,\n    1662059464998953,\n    2033849074728123,\n    1442794654840575,\n]);\n\n/// Edwards `2*d` value, equal to `2*(-121665/121666) mod p`.\npub(crate) const EDWARDS_D2: FieldElement51 = FieldElement51::from_limbs([\n    1859910466990425,\n    932731440258426,\n    1072319116312658,\n    1815898335770999,\n    633789495995903,\n]);\n\n/// One minus edwards `d` value squared, equal to `(1 - (-121665/121666) mod p) pow 2`\npub(crate) const ONE_MINUS_EDWARDS_D_SQUARED: FieldElement51 = FieldElement51::from_limbs([\n    1136626929484150,\n    1998550399581263,\n    496427632559748,\n    118527312129759,\n    45110755273534,\n]);\n\n/// Edwards `d` value minus one squared, equal to `(((-121665/121666) mod p) - 1) pow 2`\npub(crate) const EDWARDS_D_MINUS_ONE_SQUARED: FieldElement51 = FieldElement51::from_limbs([\n    1507062230895904,\n    1572317787530805,\n    683053064812840,\n    317374165784489,\n    1572899562415810,\n]);\n\n/// `= sqrt(a*d - 1)`, where `a = -1 (mod p)`, `d` are the Edwards curve parameters.\npub(crate) const SQRT_AD_MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n    2241493124984347,\n    425987919032274,\n    2207028919301688,\n    1220490630685848,\n    974799131293748,\n]);\n\n/// `= 1/sqrt(a-d)`, where `a = -1 (mod p)`, `d` are the Edwards curve parameters.\npub(crate) const INVSQRT_A_MINUS_D: FieldElement51 = FieldElement51::from_limbs([\n    278908739862762,\n    821645201101625,\n    8113234426968,\n    1777959178193151,\n    2118520810568447,\n]);\n\n/// Precomputed value of one of the square roots of -1 (mod p)\npub(crate) const SQRT_M1: FieldElement51 = FieldElement51::from_limbs([\n    1718705420411056,\n    234908883556509,\n    2233514472574048,\n    2117202627021982,\n    765476049583133,\n]);\n\n/// `APLUS2_OVER_FOUR` is (A+2)/4. (This is used internally within the Montgomery ladder.)\npub(crate) const APLUS2_OVER_FOUR: FieldElement51 =\n    FieldElement51::from_limbs([121666, 0, 0, 0, 0]);\n\n/// `MONTGOMERY_A` is equal to 486662, which is a constant of the curve equation\n/// for Curve25519 in its Montgomery form. (This is used internally within the\n/// Elligator map.)\npub(crate) const MONTGOMERY_A: FieldElement51 = FieldElement51::from_limbs([486662, 0, 0, 0, 0]);\n\n/// `MONTGOMERY_A_NEG` is equal to -486662. (This is used internally within the\n/// Elligator map.)\npub(crate) const MONTGOMERY_A_NEG: FieldElement51 = FieldElement51::from_limbs([\n    2251799813198567,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n]);\n\nverus! {\n/// `L` is the order of base point, i.e. 2^252 + 27742317777372353535851937790883648493\npub(crate) const L: Scalar52 = Scalar52 {\n    limbs: [\n        0x0002631a5cf5d3ed,\n        0x000dea2f79cd6581,\n        0x000000000014def9,\n        0x0000000000000000,\n        0x0000100000000000,\n    ],\n};\n\n/// `L` * `LFACTOR` = -1 (mod 2^52)\npub(crate) const LFACTOR: u64 = 0x51da312547e1b;\n\n/// `R` = R % L where R = 2^260\npub(crate) const R: Scalar52 = Scalar52 {\n    limbs: [\n        0x000f48bd6721e6ed,\n        0x0003bab5ac67e45a,\n        0x000fffffeb35e51b,\n        0x000fffffffffffff,\n        0x00000fffffffffff,\n    ],\n};\n\n/// `RR` = (R^2) % L where R = 2^260\npub(crate) const RR: Scalar52 = Scalar52 {\n    limbs: [\n        0x0009d265e952d13b,\n        0x000d63c715bea69f,\n        0x0005be65cb687604,\n        0x0003dceec73d217f,\n        0x000009411b7c309a,\n    ],\n};\n}\n\n/// The Ed25519 basepoint, as an `EdwardsPoint`.\n///\n/// This is called `_POINT` to distinguish it from\n/// `ED25519_BASEPOINT_TABLE`, which should be used for scalar\n/// multiplication (it's much faster).\npub const ED25519_BASEPOINT_POINT: EdwardsPoint = EdwardsPoint {\n    X: FieldElement51::from_limbs([\n        1738742601995546,\n        1146398526822698,\n        2070867633025821,\n        562264141797630,\n        587772402128613,\n    ]),\n    Y: FieldElement51::from_limbs([\n        1801439850948184,\n        1351079888211148,\n        450359962737049,\n        900719925474099,\n        1801439850948198,\n    ]),\n    Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n    T: FieldElement51::from_limbs([\n        1841354044333475,\n        16398895984059,\n        755974180946558,\n        900171276175154,\n        1821297809914039,\n    ]),\n};\n\n/// The 8-torsion subgroup \\\\(\\mathcal E \\[8\\]\\\\).\n///\n/// In the case of Curve25519, it is cyclic; the \\\\(i\\\\)-th element of\n/// the array is \\\\(\\[i\\]P\\\\), where \\\\(P\\\\) is a point of order \\\\(8\\\\)\n/// generating \\\\(\\mathcal E\\[8\\]\\\\).\n///\n/// Thus \\\\(\\mathcal E\\[4\\]\\\\) is the points indexed by `0,2,4,6`, and\n/// \\\\(\\mathcal E\\[2\\]\\\\) is the points indexed by `0,4`.\npub const EIGHT_TORSION: [EdwardsPoint; 8] = EIGHT_TORSION_INNER_DOC_HIDDEN;\n\n/// Inner item used to hide limb constants from cargo doc output.\n#[doc(hidden)]\npub const EIGHT_TORSION_INNER_DOC_HIDDEN: [EdwardsPoint; 8] = [\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Y: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            358744748052810,\n            1691584618240980,\n            977650209285361,\n            1429865912637724,\n            560044844278676,\n        ]),\n        Y: FieldElement51::from_limbs([\n            84926274344903,\n            473620666599931,\n            365590438845504,\n            1028470286882429,\n            2146499180330972,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            1448326834587521,\n            1857896831960481,\n            1093722731865333,\n            1677408490711241,\n            1915505153018406,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            533094393274173,\n            2016890930128738,\n            18285341111199,\n            134597186663265,\n            1486323764102114,\n        ]),\n        Y: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            358744748052810,\n            1691584618240980,\n            977650209285361,\n            1429865912637724,\n            560044844278676,\n        ]),\n        Y: FieldElement51::from_limbs([\n            2166873539340326,\n            1778179147085316,\n            1886209374839743,\n            1223329526802818,\n            105300633354275,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            803472979097708,\n            393902981724766,\n            1158077081819914,\n            574391322974006,\n            336294660666841,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Y: FieldElement51::from_limbs([\n            2251799813685228,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1893055065632419,\n            560215195444267,\n            1274149604399886,\n            821933901047523,\n            1691754969406571,\n        ]),\n        Y: FieldElement51::from_limbs([\n            2166873539340326,\n            1778179147085316,\n            1886209374839743,\n            1223329526802818,\n            105300633354275,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            1448326834587521,\n            1857896831960481,\n            1093722731865333,\n            1677408490711241,\n            1915505153018406,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1718705420411056,\n            234908883556509,\n            2233514472574048,\n            2117202627021982,\n            765476049583133,\n        ]),\n        Y: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1893055065632419,\n            560215195444267,\n            1274149604399886,\n            821933901047523,\n            1691754969406571,\n        ]),\n        Y: FieldElement51::from_limbs([\n            84926274344903,\n            473620666599931,\n            365590438845504,\n            1028470286882429,\n            2146499180330972,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            803472979097708,\n            393902981724766,\n            1158077081819914,\n            574391322974006,\n            336294660666841,\n        ]),\n    },\n];\n\n/// Table containing precomputed multiples of the Ed25519 basepoint \\\\(B = (x, 4/5)\\\\).\n#[cfg(feature = \"precomputed-tables\")]\npub static ED25519_BASEPOINT_TABLE: &EdwardsBasepointTable =\n    &ED25519_BASEPOINT_TABLE_INNER_DOC_HIDDEN;\n\n/// Inner constant, used to avoid filling the docs with precomputed points.\n#[doc(hidden)]\n#[cfg(feature = \"precomputed-tables\")]\nstatic ED25519_BASEPOINT_TABLE_INNER_DOC_HIDDEN: EdwardsBasepointTable = EdwardsBasepointTable([\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3540182452943730,\n                2497478415033846,\n                2521227595762870,\n                1462984067271729,\n                2389212253076811,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                62697248952638,\n                204681361388450,\n                631292143396476,\n                338455783676468,\n                1213667448819585,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                301289933810280,\n                1259582250014073,\n                1422107436869536,\n                796239922652654,\n                1953934009299142,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3632771708514775,\n                790832306631235,\n                2067202295274102,\n                1995808275510000,\n                1566530869037010,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                463307831301544,\n                432984605774163,\n                1610641361907204,\n                750899048855000,\n                1894842303421586,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                748439484463711,\n                1033211726465151,\n                1396005112841647,\n                1611506220286469,\n                1972177495910992,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1601611775252272,\n                1720807796594148,\n                1132070835939856,\n                3512254832574799,\n                2147779492816910,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                316559037616741,\n                2177824224946892,\n                1459442586438991,\n                1461528397712656,\n                751590696113597,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1850748884277385,\n                1200145853858453,\n                1068094770532492,\n                672251375690438,\n                1586055907191707,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                934282339813791,\n                1846903124198670,\n                1172395437954843,\n                1007037127761661,\n                1830588347719256,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1694390458783935,\n                1735906047636159,\n                705069562067493,\n                648033061693059,\n                696214010414170,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1121406372216585,\n                192876649532226,\n                190294192191717,\n                1994165897297032,\n                2245000007398739,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                769950342298400,\n                2384754244604994,\n                3095885746880802,\n                3225892188161580,\n                2977876099231263,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                425251763115706,\n                608463272472562,\n                442562545713235,\n                837766094556764,\n                374555092627893,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1086255230780037,\n                274979815921559,\n                1960002765731872,\n                929474102396301,\n                1190409889297339,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1388594989461809,\n                316767091099457,\n                2646098655878230,\n                1230079486801004,\n                1440737038838979,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                7380825640100,\n                146210432690483,\n                304903576448906,\n                1198869323871120,\n                997689833219095,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1181317918772081,\n                114573476638901,\n                262805072233344,\n                265712217171332,\n                294181933805782,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2916800678241215,\n                2065379846933858,\n                2622030924071124,\n                2602788184473875,\n                1233371373142984,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2019367628972465,\n                676711900706637,\n                110710997811333,\n                1108646842542025,\n                517791959672113,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                965130719900578,\n                247011430587952,\n                526356006571389,\n                91986625355052,\n                2157223321444601,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4320419353804412,\n                4218074731744053,\n                957728544705548,\n                729906502578991,\n                2411634706750414,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2073601412052185,\n                31021124762708,\n                264500969797082,\n                248034690651703,\n                1030252227928288,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                551790716293402,\n                1989538725166328,\n                801169423371717,\n                2052451893578887,\n                678432056995012,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1368953770187805,\n                3042147450398169,\n                2689308289352409,\n                2142576377050579,\n                1932081720066286,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                953638594433374,\n                1092333936795051,\n                1419774766716690,\n                805677984380077,\n                859228993502513,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1200766035879111,\n                20142053207432,\n                1465634435977050,\n                1645256912097844,\n                295121984874596,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1735718747031538,\n                1248237894295956,\n                1204753118328107,\n                976066523550493,\n                2317743583219840,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1060098822528990,\n                1586825862073490,\n                212301317240126,\n                1975302711403555,\n                666724059764335,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1091990273418756,\n                1572899409348578,\n                80968014455247,\n                306009358661350,\n                1520450739132526,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3732317023121341,\n                1511153322193951,\n                3496143672676420,\n                2556587964178488,\n                2620936670181690,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2151330273626164,\n                762045184746182,\n                1688074332551515,\n                823046109005759,\n                907602769079491,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2047386910586836,\n                168470092900250,\n                1552838872594810,\n                340951180073789,\n                360819374702533,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1982622644432037,\n                2014393600336956,\n                2380709022489462,\n                3869592437614438,\n                2357094095599062,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                980234343912898,\n                1712256739246056,\n                588935272190264,\n                204298813091998,\n                841798321043288,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                197561292938973,\n                454817274782871,\n                1963754960082318,\n                2113372252160468,\n                971377527342673,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2416499262514576,\n                2254927265442919,\n                3451304785234000,\n                1766155447043651,\n                1899238924683527,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                732262946680281,\n                1674412764227063,\n                2182456405662809,\n                1350894754474250,\n                558458873295247,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2103305098582922,\n                1960809151316468,\n                715134605001343,\n                1454892949167181,\n                40827143824949,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1239289043050193,\n                1744654158124578,\n                758702410031698,\n                4048562808759936,\n                2253402870349013,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2232056027107988,\n                987343914584615,\n                2115594492994461,\n                1819598072792159,\n                1119305654014850,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                320153677847348,\n                939613871605645,\n                641883205761567,\n                1930009789398224,\n                329165806634126,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3232730304159378,\n                1242488692177892,\n                1251446316964684,\n                1086618677993530,\n                1961430968465772,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                276821765317453,\n                1536835591188030,\n                1305212741412361,\n                61473904210175,\n                2051377036983058,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                833449923882501,\n                1750270368490475,\n                1123347002068295,\n                185477424765687,\n                278090826653186,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                794524995833413,\n                1849907304548286,\n                2305148486158393,\n                1272368559505216,\n                1147304168324779,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1504846112759364,\n                1203096289004681,\n                562139421471418,\n                274333017451844,\n                1284344053775441,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                483048732424432,\n                2116063063343382,\n                30120189902313,\n                292451576741007,\n                1156379271702225,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3180171966714267,\n                2147692869914563,\n                1455665844462196,\n                1986737809425946,\n                2437006863943337,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                137732961814206,\n                706670923917341,\n                1387038086865771,\n                1965643813686352,\n                1384777115696347,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                481144981981577,\n                2053319313589856,\n                2065402289827512,\n                617954271490316,\n                1106602634668125,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2948097833334040,\n                3145099472726142,\n                1148636718636008,\n                2278533891034865,\n                2203955659340680,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                657390353372855,\n                998499966885562,\n                991893336905797,\n                810470207106761,\n                343139804608786,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                791736669492960,\n                934767652997115,\n                824656780392914,\n                1759463253018643,\n                361530362383518,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2022541353055578,\n                4346500076272714,\n                3802807888710933,\n                2494585331103411,\n                2947785218648809,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1287487199965223,\n                2215311941380308,\n                1552928390931986,\n                1664859529680196,\n                1125004975265243,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                677434665154918,\n                989582503122485,\n                1817429540898386,\n                1052904935475344,\n                1143826298169798,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2619066141993637,\n                2570231002607651,\n                2947429167440602,\n                2885885471266079,\n                2276381426249673,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                773360688841258,\n                1815381330538070,\n                363773437667376,\n                539629987070205,\n                783280434248437,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                180820816194166,\n                168937968377394,\n                748416242794470,\n                1227281252254508,\n                1567587861004268,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2730575372268893,\n                2062896624554806,\n                2951191072970647,\n                2609899222113120,\n                1277310261461760,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1984740906540026,\n                1079164179400229,\n                1056021349262661,\n                1659958556483663,\n                1088529069025527,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                580736401511151,\n                1842931091388998,\n                1177201471228238,\n                2075460256527244,\n                1301133425678027,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1515728832059163,\n                1575261009617579,\n                1510246567196186,\n                2442877836294952,\n                2368461529974388,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1295295738269652,\n                1714742313707026,\n                545583042462581,\n                2034411676262552,\n                1513248090013606,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                230710545179830,\n                30821514358353,\n                760704303452229,\n                390668103790604,\n                573437871383156,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3421179921230875,\n                2514967047430861,\n                4274701112739695,\n                3071700566936367,\n                4275698278559832,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2102254323485823,\n                1570832666216754,\n                34696906544624,\n                1993213739807337,\n                70638552271463,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                894132856735058,\n                548675863558441,\n                845349339503395,\n                1942269668326667,\n                1615682209874691,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3539470031223082,\n                1222355136884919,\n                1846481788678694,\n                1150426571265110,\n                1613523400722047,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                793388516527298,\n                1315457083650035,\n                1972286999342417,\n                1901825953052455,\n                338269477222410,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                550201530671806,\n                778605267108140,\n                2063911101902983,\n                115500557286349,\n                2041641272971022,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                717255318455100,\n                519313764361315,\n                2080406977303708,\n                541981206705521,\n                774328150311600,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                261715221532238,\n                1795354330069993,\n                1496878026850283,\n                499739720521052,\n                389031152673770,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1997217696294013,\n                1717306351628065,\n                1684313917746180,\n                1644426076011410,\n                1857378133465451,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3727234538477877,\n                2328731709971226,\n                3368528843456914,\n                2002544139318041,\n                2977347647489186,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2022306639183567,\n                726296063571875,\n                315345054448644,\n                1058733329149221,\n                1448201136060677,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1710065158525665,\n                1895094923036397,\n                123988286168546,\n                1145519900776355,\n                1607510767693874,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2813405189107769,\n                1071733543815036,\n                2383296312486238,\n                1946868434569998,\n                3079937947649451,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1548495173745801,\n                442310529226540,\n                998072547000384,\n                553054358385281,\n                644824326376171,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1445526537029440,\n                2225519789662536,\n                914628859347385,\n                1064754194555068,\n                1660295614401091,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3451490036797185,\n                2275827949507588,\n                2318438102929588,\n                2309425969971222,\n                2816893781664854,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                876926774220824,\n                554618976488214,\n                1012056309841565,\n                839961821554611,\n                1414499340307677,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                703047626104145,\n                1266841406201770,\n                165556500219173,\n                486991595001879,\n                1011325891650656,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1622861044480487,\n                1156394801573634,\n                4120932379100752,\n                2578903799462977,\n                2095342781472283,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                334886927423922,\n                489511099221528,\n                129160865966726,\n                1720809113143481,\n                619700195649254,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1646545795166119,\n                1758370782583567,\n                714746174550637,\n                1472693650165135,\n                898994790308209,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2585203586724508,\n                2547572356138185,\n                1693106465353609,\n                912330357530760,\n                2723035471635610,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1811196219982022,\n                1068969825533602,\n                289602974833439,\n                1988956043611592,\n                863562343398367,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                906282429780072,\n                2108672665779781,\n                432396390473936,\n                150625823801893,\n                1708930497638539,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                925664675702309,\n                2273216662253932,\n                4083236455546587,\n                601157008940112,\n                2623617868729744,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1479786007267725,\n                1738881859066675,\n                68646196476567,\n                2146507056100328,\n                1247662817535471,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                52035296774456,\n                939969390708103,\n                312023458773250,\n                59873523517659,\n                1231345905848899,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2895154920100990,\n                2541986621181021,\n                2013561737429022,\n                2571447883196794,\n                2645536492181409,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                129358342392716,\n                1932811617704777,\n                1176749390799681,\n                398040349861790,\n                1170779668090425,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2051980782668029,\n                121859921510665,\n                2048329875753063,\n                1235229850149665,\n                519062146124755,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3859970785658325,\n                2667608874045675,\n                1350468408164765,\n                2038620059057678,\n                3278704299674360,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1837656083115103,\n                1510134048812070,\n                906263674192061,\n                1821064197805734,\n                565375124676301,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                578027192365650,\n                2034800251375322,\n                2128954087207123,\n                478816193810521,\n                2196171989962750,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1633188840273120,\n                3104586986058956,\n                1548762607215795,\n                1266275218902681,\n                3359018017010381,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                462189358480054,\n                1784816734159228,\n                1611334301651368,\n                1303938263943540,\n                707589560319424,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1038829280972848,\n                38176604650029,\n                753193246598573,\n                1136076426528122,\n                595709990562434,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3660251634545082,\n                2194984964010832,\n                2198361797561729,\n                1061962440055713,\n                1645147963442934,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                4701053362120,\n                1647641066302348,\n                1047553002242085,\n                1923635013395977,\n                206970314902065,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1750479161778571,\n                1362553355169293,\n                1891721260220598,\n                966109370862782,\n                1024913988299801,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2464498862816952,\n                1117950018299774,\n                1873945661751056,\n                3655602735669306,\n                2382695896337945,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                636808533673210,\n                1262201711667560,\n                390951380330599,\n                1663420692697294,\n                561951321757406,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                520731594438141,\n                1446301499955692,\n                273753264629267,\n                1565101517999256,\n                1019411827004672,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3178327305714638,\n                3443653291096626,\n                734233225181170,\n                2435838701226518,\n                4042225960010590,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1464651961852572,\n                1483737295721717,\n                1519450561335517,\n                1161429831763785,\n                405914998179977,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                996126634382301,\n                796204125879525,\n                127517800546509,\n                344155944689303,\n                615279846169038,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2990523894660505,\n                2188666632415295,\n                1961313708559162,\n                1506545807547587,\n                3403101452654988,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                622917337413835,\n                1218989177089035,\n                1284857712846592,\n                970502061709359,\n                351025208117090,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2067814584765580,\n                1677855129927492,\n                2086109782475197,\n                235286517313238,\n                1416314046739645,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2838644076315587,\n                2559244195637442,\n                458399356043425,\n                2853867838192310,\n                3280348017100490,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                678489922928203,\n                2016657584724032,\n                90977383049628,\n                1026831907234582,\n                615271492942522,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                301225714012278,\n                1094837270268560,\n                1202288391010439,\n                644352775178361,\n                1647055902137983,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1210746697896459,\n                1416608304244708,\n                2938287290903104,\n                3496931005119382,\n                3303038150540984,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1135604073198207,\n                1683322080485474,\n                769147804376683,\n                2086688130589414,\n                900445683120379,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1971518477615628,\n                401909519527336,\n                448627091057375,\n                1409486868273821,\n                1214789035034363,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1364039144731711,\n                1897497433586190,\n                2203097701135459,\n                2397261210496499,\n                1349844460790698,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1045230323257973,\n                818206601145807,\n                630513189076103,\n                1672046528998132,\n                807204017562437,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                439961968385997,\n                386362664488986,\n                1382706320807688,\n                309894000125359,\n                2207801346498567,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3480804500082836,\n                3172443782216110,\n                2375775707596425,\n                2933223806901024,\n                1400559197080972,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2003766096898049,\n                170074059235165,\n                1141124258967971,\n                1485419893480973,\n                1573762821028725,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                729905708611432,\n                1270323270673202,\n                123353058984288,\n                426460209632942,\n                2195574535456672,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1271140255321216,\n                2044363183174497,\n                2303925201319937,\n                3696920060379952,\n                3194341800024331,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1761608437466135,\n                583360847526804,\n                1586706389685493,\n                2157056599579261,\n                1170692369685772,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                871476219910823,\n                1878769545097794,\n                2241832391238412,\n                548957640601001,\n                690047440233174,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2548994545820755,\n                1366347803776819,\n                3552985325930849,\n                561849853336293,\n                1533554921345731,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                999628998628371,\n                1132836708493400,\n                2084741674517453,\n                469343353015612,\n                678782988708035,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2189427607417022,\n                699801937082607,\n                412764402319267,\n                1478091893643349,\n                2244675696854460,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3964091869651792,\n                2456213404310121,\n                3657538451018088,\n                2660781114515010,\n                3112882032961968,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                508561155940631,\n                966928475686665,\n                2236717801150132,\n                424543858577297,\n                2089272956986143,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                221245220129925,\n                1156020201681217,\n                491145634799213,\n                542422431960839,\n                828100817819207,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2405556784925632,\n                1299874139923976,\n                2644898978945750,\n                1058234455773021,\n                996989038681183,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                559086812798481,\n                573177704212711,\n                1629737083816402,\n                1399819713462595,\n                1646954378266038,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1887963056288059,\n                228507035730124,\n                1468368348640282,\n                930557653420194,\n                613513962454686,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1224529808187534,\n                1577022856702685,\n                2206946542980843,\n                625883007765001,\n                2531730607197406,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1076287717051609,\n                1114455570543035,\n                187297059715481,\n                250446884292121,\n                1885187512550540,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                902497362940219,\n                76749815795675,\n                1657927525633846,\n                1420238379745202,\n                1340321636548352,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1129576631190765,\n                3533793823712575,\n                996844254743017,\n                2509676177174497,\n                3402650555740265,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                628740660038789,\n                1943038498527841,\n                467786347793886,\n                1093341428303375,\n                235413859513003,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                237425418909360,\n                469614029179605,\n                1512389769174935,\n                1241726368345357,\n                441602891065214,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3988217766743784,\n                726531315520507,\n                1833335034432527,\n                1629442561574747,\n                2876218732971333,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1960754663920689,\n                497040957888962,\n                1909832851283095,\n                1271432136996826,\n                2219780368020940,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1537037379417136,\n                1358865369268262,\n                2130838645654099,\n                828733687040705,\n                1999987652890901,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                629042105241795,\n                1098854999137608,\n                887281544569320,\n                3674901833560025,\n                2259711072636808,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1811562332665373,\n                1501882019007673,\n                2213763501088999,\n                359573079719636,\n                36370565049116,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                218907117361280,\n                1209298913016966,\n                1944312619096112,\n                1130690631451061,\n                1342327389191701,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1369976867854685,\n                1396479602419169,\n                4017456468084104,\n                2203659200586298,\n                3250127649802489,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2230701885562825,\n                1348173180338974,\n                2172856128624598,\n                1426538746123771,\n                444193481326151,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                784210426627951,\n                918204562375674,\n                1284546780452985,\n                1324534636134684,\n                1872449409642708,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2571438643225542,\n                2848082470493653,\n                2037902696412607,\n                1557219121643918,\n                341938082688094,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1901860206695915,\n                2004489122065736,\n                1625847061568236,\n                973529743399879,\n                2075287685312905,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1371853944110545,\n                1042332820512553,\n                1949855697918254,\n                1791195775521505,\n                37487364849293,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                687200189577836,\n                1082536651125675,\n                2896024754556794,\n                2592723009743198,\n                2595381160432643,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2082717129583892,\n                27829425539422,\n                145655066671970,\n                1690527209845512,\n                1865260509673478,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1059729620568824,\n                2163709103470266,\n                1440302280256872,\n                1769143160546397,\n                869830310425069,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3861316033464273,\n                777277757338816,\n                2101121130363987,\n                550762194946473,\n                1905542338659364,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2024821921041576,\n                426948675450149,\n                595133284085473,\n                471860860885970,\n                600321679413000,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                598474602406721,\n                1468128276358244,\n                1191923149557635,\n                1501376424093216,\n                1281662691293476,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1721138489890688,\n                1264336102277790,\n                2684864359106535,\n                1359988423149465,\n                3813671107094695,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                719520245587143,\n                393380711632345,\n                132350400863381,\n                1543271270810729,\n                1819543295798660,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                396397949784152,\n                1811354474471839,\n                1362679985304303,\n                2117033964846756,\n                498041172552279,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1812471844975748,\n                1856491995543149,\n                126579494584102,\n                3288044672967868,\n                1975108050082549,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                650623932407995,\n                1137551288410575,\n                2125223403615539,\n                1725658013221271,\n                2134892965117796,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                522584000310195,\n                1241762481390450,\n                1743702789495384,\n                2227404127826575,\n                1686746002148897,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                427904865186293,\n                1703211129693455,\n                1585368107547509,\n                3688784302429584,\n                3012988348299225,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                318101947455002,\n                248138407995851,\n                1481904195303927,\n                309278454311197,\n                1258516760217879,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1275068538599310,\n                513726919533379,\n                349926553492294,\n                688428871968420,\n                1702400196000666,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3313663849950481,\n                3213411074010628,\n                2573659446386085,\n                3297400443644764,\n                1985130202504037,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1558816436882417,\n                1962896332636523,\n                1337709822062152,\n                1501413830776938,\n                294436165831932,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                818359826554971,\n                1862173000996177,\n                626821592884859,\n                573655738872376,\n                1749691246745455,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1988022651432119,\n                3333911312271288,\n                1834020786104820,\n                3706626690108935,\n                692929915223121,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2146513703733331,\n                584788900394667,\n                464965657279958,\n                2183973639356127,\n                238371159456790,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1129007025494441,\n                2197883144413266,\n                265142755578169,\n                971864464758890,\n                1983715884903702,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1291366624493056,\n                2633256531874362,\n                1711482489312443,\n                1815233647702022,\n                3144079596677715,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                444548969917454,\n                1452286453853356,\n                2113731441506810,\n                645188273895859,\n                810317625309512,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2242724082797924,\n                1373354730327868,\n                1006520110883049,\n                2147330369940688,\n                1151816104883620,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3997520014069025,\n                4163522956860564,\n                2056329390702073,\n                2607026987995097,\n                3131032608056347,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                163723479936298,\n                115424889803150,\n                1156016391581227,\n                1894942220753364,\n                1970549419986329,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                681981452362484,\n                267208874112496,\n                1374683991933094,\n                638600984916117,\n                646178654558546,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2265178468539480,\n                2358037120714814,\n                1944412051589650,\n                4093776581610705,\n                2482502633520820,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                260683893467075,\n                854060306077237,\n                913639551980112,\n                4704576840123,\n                280254810808712,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                715374893080287,\n                1173334812210491,\n                1806524662079626,\n                1894596008000979,\n                398905715033393,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2751826223412909,\n                3848231101880618,\n                1420380351989369,\n                3237011375206737,\n                392444930785632,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2096421546958141,\n                1922523000950363,\n                789831022876840,\n                427295144688779,\n                320923973161730,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1927770723575450,\n                1485792977512719,\n                1850996108474547,\n                551696031508956,\n                2126047405475647,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2112099158080129,\n                2994370617594963,\n                2258284371762679,\n                1951119898618915,\n                2344890196388664,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                383905201636970,\n                859946997631870,\n                855623867637644,\n                1017125780577795,\n                794250831877809,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                77571826285752,\n                999304298101753,\n                487841111777762,\n                1038031143212339,\n                339066367948762,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2926794589205781,\n                2517835660016036,\n                826951213393477,\n                1405007746162285,\n                1781791018620876,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1001412661522686,\n                348196197067298,\n                1666614366723946,\n                888424995032760,\n                580747687801357,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1939560076207777,\n                1409892634407635,\n                552574736069277,\n                383854338280405,\n                190706709864139,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2177087163428741,\n                1439255351721944,\n                3459870654068041,\n                2230616362004768,\n                1396886392021913,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                676962063230039,\n                1880275537148808,\n                2046721011602706,\n                888463247083003,\n                1318301552024067,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1466980508178206,\n                617045217998949,\n                652303580573628,\n                757303753529064,\n                207583137376902,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3762856566592150,\n                2357202940576524,\n                2745234706458093,\n                1091943425335975,\n                1802717338077427,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1853982405405128,\n                1878664056251147,\n                1528011020803992,\n                1019626468153565,\n                1128438412189035,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1963939888391106,\n                293456433791664,\n                697897559513649,\n                985882796904380,\n                796244541237972,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2668570812315008,\n                2641455366112301,\n                1314476859406755,\n                1749382513022778,\n                3413705412424739,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1428358296490651,\n                1027115282420478,\n                304840698058337,\n                441410174026628,\n                1819358356278573,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                204943430200135,\n                1554861433819175,\n                216426658514651,\n                264149070665950,\n                2047097371738319,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1934415182909015,\n                1393285083565062,\n                2768209145458208,\n                3409490548679139,\n                2372839480279515,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                662035583584445,\n                286736105093098,\n                1131773000510616,\n                818494214211439,\n                472943792054479,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                665784778135882,\n                1893179629898606,\n                808313193813106,\n                276797254706413,\n                1563426179676396,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                945205108984213,\n                2778077376644543,\n                1324180513733565,\n                1666970227868664,\n                2405347422974421,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2031433403516252,\n                203996615228162,\n                170487168837083,\n                981513604791390,\n                843573964916831,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1476570093962618,\n                838514669399805,\n                1857930577281364,\n                2017007352225784,\n                317085545220047,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1461557121912823,\n                1600674043318359,\n                2157134900399597,\n                1670641601940616,\n                2379565397488531,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1293543509393474,\n                2143624609202546,\n                1058361566797508,\n                214097127393994,\n                946888515472729,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                357067959932916,\n                1290876214345711,\n                521245575443703,\n                1494975468601005,\n                800942377643885,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2817916472785262,\n                820247422481739,\n                994464017954148,\n                2578957425371613,\n                2344391131796991,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                617256647603209,\n                1652107761099439,\n                1857213046645471,\n                1085597175214970,\n                817432759830522,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                771808161440705,\n                1323510426395069,\n                680497615846440,\n                851580615547985,\n                1320806384849017,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1219260086131896,\n                2898968820282063,\n                2331400938444953,\n                2161724213426747,\n                2656661710745446,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1327968293887866,\n                1335500852943256,\n                1401587164534264,\n                558137311952440,\n                1551360549268902,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                417621685193956,\n                1429953819744454,\n                396157358457099,\n                1940470778873255,\n                214000046234152,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1268047918491954,\n                2172375426948536,\n                1533916099229249,\n                1761293575457130,\n                3842422480712013,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1627072914981959,\n                2211603081280073,\n                1912369601616504,\n                1191770436221309,\n                2187309757525860,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1149147819689533,\n                378692712667677,\n                828475842424202,\n                2218619146419342,\n                70688125792186,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3551539230764990,\n                3690416477138006,\n                3788528892189659,\n                2053896748919837,\n                3260220846276494,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2040723824657366,\n                399555637875075,\n                632543375452995,\n                872649937008051,\n                1235394727030233,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2211311599327900,\n                2139787259888175,\n                938706616835350,\n                12609661139114,\n                2081897930719789,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1324994503390431,\n                2588782144267879,\n                1183998925654176,\n                3343454479598522,\n                2300527487656566,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1845522914617879,\n                1222198248335542,\n                150841072760134,\n                1927029069940982,\n                1189913404498011,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1079559557592645,\n                2215338383666441,\n                1903569501302605,\n                49033973033940,\n                305703433934152,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2346453219102138,\n                3637921163538246,\n                3313930291577009,\n                2288353761164521,\n                3085469462634093,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1432015813136298,\n                440364795295369,\n                1395647062821501,\n                1976874522764578,\n                934452372723352,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1296625309219774,\n                2068273464883862,\n                1858621048097805,\n                1492281814208508,\n                2235868981918946,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1490330266465551,\n                1858795661361448,\n                3688040948655011,\n                2546373032584894,\n                3459939824714180,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1282462923712748,\n                741885683986255,\n                2027754642827561,\n                518989529541027,\n                1826610009555945,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1525827120027511,\n                723686461809551,\n                1597702369236987,\n                244802101764964,\n                1502833890372311,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2365421849929742,\n                3485539881431101,\n                2925909765963743,\n                2114345180342964,\n                2418564326541511,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2041668749310338,\n                2184405322203901,\n                1633400637611036,\n                2110682505536899,\n                2048144390084644,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                503058759232932,\n                760293024620937,\n                2027152777219493,\n                666858468148475,\n                1539184379870952,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1916168475367211,\n                3167426246226591,\n                883217071712574,\n                363427871374304,\n                1976029821251593,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                678039535434506,\n                570587290189340,\n                1605302676614120,\n                2147762562875701,\n                1706063797091704,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1439489648586438,\n                2194580753290951,\n                832380563557396,\n                561521973970522,\n                584497280718389,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2439789269177838,\n                681223515948274,\n                1933493571072456,\n                1872921007304880,\n                2739962177820919,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1413466089534451,\n                410844090765630,\n                1397263346404072,\n                408227143123410,\n                1594561803147811,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2102170800973153,\n                719462588665004,\n                1479649438510153,\n                1097529543970028,\n                1302363283777685,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3193865531532443,\n                3321113493038208,\n                2007341951411050,\n                2322773230131539,\n                1419433790163705,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1146565545556377,\n                1661971299445212,\n                406681704748893,\n                564452436406089,\n                1109109865829139,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2214421081775077,\n                1165671861210569,\n                1890453018796184,\n                3556249878661,\n                442116172656317,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3005630360306059,\n                1666955059895018,\n                1530775289309243,\n                3371786842789394,\n                2164156153857579,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                615171919212796,\n                1523849404854568,\n                854560460547503,\n                2067097370290715,\n                1765325848586042,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1094538949313667,\n                1796592198908825,\n                870221004284388,\n                2025558921863561,\n                1699010892802384,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1951351290725195,\n                1916457206844795,\n                2449824998123274,\n                1909076887557594,\n                1938542290318919,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1014323197538413,\n                869150639940606,\n                1756009942696599,\n                1334952557375672,\n                1544945379082874,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                764055910920305,\n                1603590757375439,\n                146805246592357,\n                1843313433854297,\n                954279890114939,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                80113526615731,\n                764536758732259,\n                3306939158785481,\n                2721052465444637,\n                2869697326116762,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                74497112547268,\n                740094153192149,\n                1745254631717581,\n                727713886503130,\n                1283034364416928,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                525892105991110,\n                1723776830270342,\n                1476444848991936,\n                573789489857760,\n                133864092632978,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2794411533877810,\n                1986812262899320,\n                1162535242465837,\n                2733298779828712,\n                2796400347268869,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                64123227344372,\n                1239927720647794,\n                1360722983445904,\n                222610813654661,\n                62429487187991,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1793193323953132,\n                91096687857833,\n                70945970938921,\n                2158587638946380,\n                1537042406482111,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1895854577604590,\n                3646695522634664,\n                1728548428495943,\n                3392664713925397,\n                2815445147288308,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                141358280486863,\n                91435889572504,\n                1087208572552643,\n                1829599652522921,\n                1193307020643647,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1611230858525381,\n                950720175540785,\n                499589887488610,\n                2001656988495019,\n                88977313255908,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3440880315164906,\n                2184348804772596,\n                3292618539427567,\n                2018318290311833,\n                1712060030915354,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                873966876953756,\n                1090638350350440,\n                1708559325189137,\n                672344594801910,\n                1320437969700239,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1508590048271766,\n                1131769479776094,\n                101550868699323,\n                428297785557897,\n                561791648661744,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3008217384184691,\n                2489682092917849,\n                2136263418594015,\n                1701968045454886,\n                2955512998822720,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1781187809325462,\n                1697624151492346,\n                1381393690939988,\n                175194132284669,\n                1483054666415238,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2175517777364616,\n                708781536456029,\n                955668231122942,\n                1967557500069555,\n                2021208005604118,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3366935780292116,\n                2476017186636029,\n                915967306279221,\n                593866251291540,\n                2813546907893254,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1443163092879439,\n                391875531646162,\n                2180847134654632,\n                464538543018753,\n                1594098196837178,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                850858855888869,\n                319436476624586,\n                327807784938441,\n                740785849558761,\n                17128415486016,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2132756334090048,\n                2788047633840893,\n                2300706964962114,\n                2860273011285942,\n                3513489358708031,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1525176236978354,\n                974205476721062,\n                293436255662638,\n                148269621098039,\n                137961998433963,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1121075518299410,\n                2071745529082111,\n                1265567917414828,\n                1648196578317805,\n                496232102750820,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2374121042985030,\n                3274721891178932,\n                2001275453369483,\n                2017441881607947,\n                3245005694463250,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                654925550560074,\n                1168810995576858,\n                575655959430926,\n                905758704861388,\n                496774564663534,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1954109525779738,\n                2117022646152485,\n                338102630417180,\n                1194140505732026,\n                107881734943492,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1714785840001267,\n                4288299832366837,\n                1876380234251965,\n                2056717182974196,\n                1645855254384642,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                106431476499341,\n                62482972120563,\n                1513446655109411,\n                807258751769522,\n                538491469114,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2002850762893643,\n                1243624520538135,\n                1486040410574605,\n                2184752338181213,\n                378495998083531,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                922510868424903,\n                1089502620807680,\n                402544072617374,\n                1131446598479839,\n                1290278588136533,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1867998812076769,\n                715425053580701,\n                39968586461416,\n                2173068014586163,\n                653822651801304,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                162892278589453,\n                182585796682149,\n                75093073137630,\n                497037941226502,\n                133871727117371,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4166396390264918,\n                1608999621851577,\n                1987629837704609,\n                1519655314857977,\n                1819193753409464,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1949315551096831,\n                1069003344994464,\n                1939165033499916,\n                1548227205730856,\n                1933767655861407,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1730519386931635,\n                1393284965610134,\n                1597143735726030,\n                416032382447158,\n                1429665248828629,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                360275475604546,\n                2799635544748326,\n                2467160717872776,\n                2848446553564254,\n                2584509464110332,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                47602113726801,\n                1522314509708010,\n                437706261372925,\n                814035330438027,\n                335930650933545,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1291597595523886,\n                1058020588994081,\n                402837842324045,\n                1363323695882781,\n                2105763393033193,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2361321796251793,\n                3967057562270386,\n                1112231216891515,\n                2046641005101484,\n                2386048970842261,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2156991030936798,\n                2227544497153325,\n                1869050094431622,\n                754875860479115,\n                1754242344267058,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1846089562873800,\n                98894784984326,\n                1412430299204844,\n                171351226625762,\n                1100604760929008,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2335972195815721,\n                2751510784385293,\n                425749630620777,\n                1762872794206857,\n                2864642415813208,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                868309334532756,\n                1703010512741873,\n                1952690008738057,\n                4325269926064,\n                2071083554962116,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                523094549451158,\n                401938899487815,\n                1407690589076010,\n                2022387426254453,\n                158660516411257,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                612867287630009,\n                2700012425789062,\n                2823428891104443,\n                1466796750919375,\n                1728478129663858,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1723848973783452,\n                2208822520534681,\n                1718748322776940,\n                1974268454121942,\n                1194212502258141,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1254114807944608,\n                977770684047110,\n                2010756238954993,\n                1783628927194099,\n                1525962994408256,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2484263871921055,\n                1948628555342433,\n                1835348780427694,\n                1031609499437291,\n                2316271920603621,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                767338676040683,\n                754089548318405,\n                1523192045639075,\n                435746025122062,\n                512692508440385,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1255955808701983,\n                1700487367990941,\n                1166401238800299,\n                1175121994891534,\n                1190934801395380,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2600943821853521,\n                1337012557669161,\n                1475912332999108,\n                3573418268585706,\n                2299411105589567,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                877519947135419,\n                2172838026132651,\n                272304391224129,\n                1655143327559984,\n                886229406429814,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                375806028254706,\n                214463229793940,\n                572906353144089,\n                572168269875638,\n                697556386112979,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1168827102357825,\n                823864273033637,\n                4323338565789945,\n                788062026895923,\n                2851378154428610,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1948116082078088,\n                2054898304487796,\n                2204939184983900,\n                210526805152138,\n                786593586607626,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1915320147894736,\n                156481169009469,\n                655050471180417,\n                592917090415421,\n                2165897438660879,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1726336468579724,\n                1119932070398949,\n                1929199510967666,\n                2285718602008207,\n                1836837863503149,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                829996854845988,\n                217061778005138,\n                1686565909803640,\n                1346948817219846,\n                1723823550730181,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                384301494966394,\n                687038900403062,\n                2211195391021739,\n                254684538421383,\n                1245698430589680,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1247567493562669,\n                4229981908141095,\n                2435671288478202,\n                806570235643434,\n                2540261331753164,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1449077384734201,\n                38285445457996,\n                2136537659177832,\n                2146493000841573,\n                725161151123125,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1201928866368855,\n                800415690605445,\n                1703146756828343,\n                997278587541744,\n                1858284414104014,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2608268623334125,\n                3034173730618399,\n                1718002439402869,\n                3644022065904502,\n                663171266061950,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                759628738230460,\n                1012693474275852,\n                353780233086498,\n                246080061387552,\n                2030378857679162,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2040672435071076,\n                888593182036908,\n                1298443657189359,\n                1804780278521327,\n                354070726137060,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1894938527423184,\n                3715012855162525,\n                2726210319182898,\n                2499094776718546,\n                877975941029127,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                207937160991127,\n                12966911039119,\n                820997788283092,\n                1010440472205286,\n                1701372890140810,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                218882774543183,\n                533427444716285,\n                1233243976733245,\n                435054256891319,\n                1509568989549904,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4140638349397055,\n                3303977572025869,\n                3465353617009382,\n                2420981822812579,\n                2715174081801119,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                299137589460312,\n                1594371588983567,\n                868058494039073,\n                257771590636681,\n                1805012993142921,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1806842755664364,\n                2098896946025095,\n                1356630998422878,\n                1458279806348064,\n                347755825962072,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1402334161391744,\n                3811883484731547,\n                1008585416617746,\n                1147797150908892,\n                1420416683642459,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                665506704253369,\n                273770475169863,\n                799236974202630,\n                848328990077558,\n                1811448782807931,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1468412523962641,\n                771866649897997,\n                1931766110147832,\n                799561180078482,\n                524837559150077,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2223212657821831,\n                2882216061048914,\n                2144451165500327,\n                3068710944633039,\n                3276150872095279,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1266603897524861,\n                156378408858100,\n                1275649024228779,\n                447738405888420,\n                253186462063095,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2022215964509735,\n                136144366993649,\n                1800716593296582,\n                1193970603800203,\n                871675847064218,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1862751661970309,\n                851596246739884,\n                1519315554814041,\n                3794598280232697,\n                3669775149586767,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1228168094547481,\n                334133883362894,\n                587567568420081,\n                433612590281181,\n                603390400373205,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                121893973206505,\n                1843345804916664,\n                1703118377384911,\n                497810164760654,\n                101150811654673,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2710146069631716,\n                2542709749304591,\n                1452768413850678,\n                2802722688939463,\n                1537286854336537,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                584322311184395,\n                380661238802118,\n                114839394528060,\n                655082270500073,\n                2111856026034852,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                996965581008991,\n                2148998626477022,\n                1012273164934654,\n                1073876063914522,\n                1688031788934939,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3175286832534829,\n                2085106799623354,\n                2779882615305384,\n                1606206360876187,\n                2987706905397772,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1697697887804317,\n                1335343703828273,\n                831288615207040,\n                949416685250051,\n                288760277392022,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1419122478109648,\n                1325574567803701,\n                602393874111094,\n                2107893372601700,\n                1314159682671307,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2201150872731785,\n                2180241023425241,\n                2349463270108411,\n                1633405770247823,\n                3100744856129234,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1173339555550611,\n                818605084277583,\n                47521504364289,\n                924108720564965,\n                735423405754506,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                830104860549448,\n                1886653193241086,\n                1600929509383773,\n                1475051275443631,\n                286679780900937,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3828911108518224,\n                3282698983453994,\n                2396700729978777,\n                4216472406664814,\n                2820189914640497,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                278388655910247,\n                487143369099838,\n                927762205508727,\n                181017540174210,\n                1616886700741287,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1191033906638969,\n                940823957346562,\n                1606870843663445,\n                861684761499847,\n                658674867251089,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1875032594195527,\n                1427106132796197,\n                2976536204647406,\n                3153660325729987,\n                2887068310954007,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                622869792298357,\n                1903919278950367,\n                1922588621661629,\n                1520574711600434,\n                1087100760174640,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                25465949416618,\n                1693639527318811,\n                1526153382657203,\n                125943137857169,\n                145276964043999,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2466539671654587,\n                920212862967914,\n                4191701364657517,\n                3463662605460468,\n                2336897329405367,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2006245852772938,\n                734762734836159,\n                254642929763427,\n                1406213292755966,\n                239303749517686,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1619678837192149,\n                1919424032779215,\n                1357391272956794,\n                1525634040073113,\n                1310226789796241,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3292563523447371,\n                1704449869235351,\n                2857062884141577,\n                1998838089036354,\n                1312142911487502,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1996723311435669,\n                1844342766567060,\n                985455700466044,\n                1165924681400960,\n                311508689870129,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                43173156290518,\n                2202883069785309,\n                1137787467085917,\n                1733636061944606,\n                1394992037553852,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                670078326344559,\n                2807454838744604,\n                2723759199967685,\n                2141455487356408,\n                849015953823125,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2197214573372804,\n                794254097241315,\n                1030190060513737,\n                267632515541902,\n                2040478049202624,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1812516004670529,\n                1609256702920783,\n                1706897079364493,\n                258549904773295,\n                996051247540686,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1540374301420565,\n                1764656898914615,\n                1810104162020396,\n                3175608592848336,\n                2916189887881826,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1323460699404750,\n                1262690757880991,\n                871777133477900,\n                1060078894988977,\n                1712236889662886,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1696163952057966,\n                1391710137550823,\n                608793846867416,\n                1034391509472039,\n                1780770894075012,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1367603834210822,\n                4383788460268472,\n                890353773628143,\n                1908908219165595,\n                2522636708938139,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                597536315471731,\n                40375058742586,\n                1942256403956049,\n                1185484645495932,\n                312666282024145,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1919411405316294,\n                1234508526402192,\n                1066863051997083,\n                1008444703737597,\n                1348810787701552,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2102881477513865,\n                3822074379630609,\n                1573617900503707,\n                2270462449417831,\n                2232324307922097,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1853931367696942,\n                8107973870707,\n                350214504129299,\n                775206934582587,\n                1752317649166792,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1417148368003523,\n                721357181628282,\n                505725498207811,\n                373232277872983,\n                261634707184480,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2186733281493248,\n                2250694917008620,\n                1014829812957440,\n                2731797975137637,\n                2335366007561721,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1268116367301224,\n                560157088142809,\n                802626839600444,\n                2210189936605713,\n                1129993785579988,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                615183387352312,\n                917611676109240,\n                878893615973325,\n                978940963313282,\n                938686890583575,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                522024729211672,\n                3296859129001056,\n                1892245413707789,\n                1907891107684253,\n                2059998109500714,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1799679152208884,\n                912132775900387,\n                25967768040979,\n                432130448590461,\n                274568990261996,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                98698809797682,\n                2144627600856209,\n                1907959298569602,\n                811491302610148,\n                1262481774981493,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1791451399743152,\n                1713538728337276,\n                2370149810942738,\n                1882306388849953,\n                158235232210248,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1217809823321928,\n                2173947284933160,\n                1986927836272325,\n                1388114931125539,\n                12686131160169,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1650875518872272,\n                1136263858253897,\n                1732115601395988,\n                734312880662190,\n                1252904681142109,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2624786269799113,\n                2777230729143418,\n                2116279931702134,\n                2753222527273063,\n                1907002872974924,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                803147181835288,\n                868941437997146,\n                316299302989663,\n                943495589630550,\n                571224287904572,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                227742695588364,\n                1776969298667369,\n                628602552821802,\n                457210915378118,\n                2041906378111140,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                815000523470260,\n                3164885502413555,\n                3303859931956420,\n                1345536665214222,\n                541623413135555,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1580216071604333,\n                1877997504342444,\n                857147161260913,\n                703522726778478,\n                2182763974211603,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1870080310923419,\n                71988220958492,\n                1783225432016732,\n                615915287105016,\n                1035570475990230,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2982787564515398,\n                857613889540279,\n                1083813157271766,\n                1002817255970169,\n                1719228484436074,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                377616581647602,\n                1581980403078513,\n                804044118130621,\n                2034382823044191,\n                643844048472185,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                176957326463017,\n                1573744060478586,\n                528642225008045,\n                1816109618372371,\n                1515140189765006,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1888911448245718,\n                3638910709296328,\n                4176303607751676,\n                1731539523700948,\n                2230378382645454,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                443392177002051,\n                233793396845137,\n                2199506622312416,\n                1011858706515937,\n                974676837063129,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1846351103143623,\n                1949984838808427,\n                671247021915253,\n                1946756846184401,\n                1929296930380217,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                849646212451983,\n                1410198775302919,\n                2325567699868943,\n                1641663456615811,\n                3014056086137659,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                692017667358279,\n                723305578826727,\n                1638042139863265,\n                748219305990306,\n                334589200523901,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                22893968530686,\n                2235758574399251,\n                1661465835630252,\n                925707319443452,\n                1203475116966621,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3053098849470395,\n                3985092410411378,\n                1664508947088595,\n                2719548934677170,\n                3899298398220870,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                903105258014366,\n                427141894933047,\n                561187017169777,\n                1884330244401954,\n                1914145708422219,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1344191060517578,\n                1960935031767890,\n                1518838929955259,\n                1781502350597190,\n                1564784025565682,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2925523165433334,\n                1979969272514922,\n                3427087126180756,\n                1187589090978665,\n                1881897672213940,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1917185587363432,\n                1098342571752737,\n                5935801044414,\n                2000527662351839,\n                1538640296181569,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2495540013192,\n                678856913479236,\n                224998292422872,\n                219635787698590,\n                1972465269000940,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                271413961212179,\n                3604851875156899,\n                2596511104968730,\n                2014925838520661,\n                2006221033113941,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                194583029968109,\n                514316781467765,\n                829677956235672,\n                1676415686873082,\n                810104584395840,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1980510813313589,\n                1948645276483975,\n                152063780665900,\n                129968026417582,\n                256984195613935,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1860190562533083,\n                1936576191345085,\n                2712900106391212,\n                1811043097042829,\n                3209286562992083,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                796664815624365,\n                1543160838872951,\n                1500897791837765,\n                1667315977988401,\n                599303877030711,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1151480509533204,\n                2136010406720455,\n                738796060240027,\n                319298003765044,\n                1150614464349587,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1731069268103131,\n                2987442261301335,\n                1364750481334267,\n                2669032653668119,\n                3178908082812908,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1017222050227968,\n                1987716148359,\n                2234319589635701,\n                621282683093392,\n                2132553131763026,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1567828528453324,\n                1017807205202360,\n                565295260895298,\n                829541698429100,\n                307243822276582,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                249079270936229,\n                1501514259790706,\n                3199709537890096,\n                944551802437486,\n                2804458577667728,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2089966982947227,\n                1854140343916181,\n                2151980759220007,\n                2139781292261749,\n                158070445864917,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1338766321464554,\n                1906702607371284,\n                1519569445519894,\n                115384726262267,\n                1393058953390992,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3616421371950629,\n                3764188048593604,\n                1926731583198685,\n                2041482526432505,\n                3172200936019022,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1884844597333588,\n                601480070269079,\n                620203503079537,\n                1079527400117915,\n                1202076693132015,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                840922919763324,\n                727955812569642,\n                1303406629750194,\n                522898432152867,\n                294161410441865,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2605560604520539,\n                1598361541848742,\n                3374705511887547,\n                4174333403844152,\n                2670907514351827,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                359856369838236,\n                180914355488683,\n                861726472646627,\n                218807937262986,\n                575626773232501,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                755467689082474,\n                909202735047934,\n                730078068932500,\n                936309075711518,\n                2007798262842972,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1609384177904054,\n                2614544999293875,\n                1335318541768200,\n                3052765584121496,\n                2799677792952659,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                984339177776787,\n                815727786505884,\n                1645154585713747,\n                1659074964378553,\n                1686601651984156,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1697863093781930,\n                599794399429786,\n                1104556219769607,\n                830560774794755,\n                12812858601017,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1168737550514982,\n                897832437380552,\n                463140296333799,\n                2554364413707795,\n                2008360505135500,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1856930662813910,\n                678090852002597,\n                1920179140755167,\n                1259527833759868,\n                55540971895511,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1158643631044921,\n                476554103621892,\n                178447851439725,\n                1305025542653569,\n                103433927680625,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2176793111709008,\n                3828525530035639,\n                2009350167273522,\n                2012390194631546,\n                2125297410909580,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                825403285195098,\n                2144208587560784,\n                1925552004644643,\n                1915177840006985,\n                1015952128947864,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1807108316634472,\n                1534392066433717,\n                347342975407218,\n                1153820745616376,\n                7375003497471,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3234860815484973,\n                2683011703586488,\n                2201903782961092,\n                3069193724749589,\n                2214616493042166,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                228567918409756,\n                865093958780220,\n                358083886450556,\n                159617889659320,\n                1360637926292598,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                234147501399755,\n                2229469128637390,\n                2175289352258889,\n                1397401514549353,\n                1885288963089922,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3363562226636810,\n                2504649386192636,\n                3300514047508588,\n                2397910909286693,\n                1237505378776769,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1113790697840279,\n                1051167139966244,\n                1045930658550944,\n                2011366241542643,\n                1686166824620755,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1054097349305049,\n                1872495070333352,\n                182121071220717,\n                1064378906787311,\n                100273572924182,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3558210666856834,\n                1627717417672446,\n                2302783034773665,\n                1109249951172249,\n                3122001602766640,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                104233794644221,\n                1548919791188248,\n                2224541913267306,\n                2054909377116478,\n                1043803389015153,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                216762189468802,\n                707284285441622,\n                190678557969733,\n                973969342604308,\n                1403009538434867,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3530824104723725,\n                2596576648903557,\n                2525521909702446,\n                4086000250496689,\n                634517197663803,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                343805853118335,\n                1302216857414201,\n                566872543223541,\n                2051138939539004,\n                321428858384280,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                470067171324852,\n                1618629234173951,\n                2000092177515639,\n                7307679772789,\n                1117521120249968,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2529951391976704,\n                1810282338562946,\n                1771599529530998,\n                3635459223356879,\n                2937173228157088,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                577009397403102,\n                1791440261786291,\n                2177643735971638,\n                174546149911960,\n                1412505077782326,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                893719721537457,\n                1201282458018197,\n                1522349501711173,\n                58011597740583,\n                1130406465887139,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                412607348255434,\n                1280455764199780,\n                2233277987330768,\n                2265979894086913,\n                2583384512102412,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                262483770854550,\n                990511055108216,\n                526885552771698,\n                571664396646158,\n                354086190278723,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1820352417585487,\n                24495617171480,\n                1547899057533253,\n                10041836186225,\n                480457105094042,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2023310314989233,\n                2889705151211129,\n                2106474638900686,\n                2809620524769320,\n                1687858215057825,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1144168702609745,\n                604444390410187,\n                1544541121756138,\n                1925315550126027,\n                626401428894002,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1922168257351784,\n                2018674099908659,\n                1776454117494445,\n                956539191509034,\n                36031129147635,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2796444352433270,\n                1039872944430373,\n                3128550222815858,\n                2962457525011798,\n                3468752501170219,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                58242421545916,\n                2035812695641843,\n                2118491866122923,\n                1191684463816273,\n                46921517454099,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                272268252444639,\n                1374166457774292,\n                2230115177009552,\n                1053149803909880,\n                1354288411641016,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1857910905368338,\n                1754729879288912,\n                3137745277795125,\n                1516096106802165,\n                1602902393369811,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1193437069800958,\n                901107149704790,\n                999672920611411,\n                477584824802207,\n                364239578697845,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                886299989548838,\n                1538292895758047,\n                1590564179491896,\n                1944527126709657,\n                837344427345298,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3006358179063534,\n                1712186480903617,\n                3955456640022779,\n                3002110732175033,\n                2770795853936147,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1309847803895382,\n                1462151862813074,\n                211370866671570,\n                1544595152703681,\n                1027691798954090,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                803217563745370,\n                1884799722343599,\n                1357706345069218,\n                2244955901722095,\n                730869460037413,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2941099284981214,\n                1831210565161070,\n                3626987155270686,\n                3358084791231418,\n                1893781834054268,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                696351368613042,\n                1494385251239250,\n                738037133616932,\n                636385507851544,\n                927483222611406,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1949114198209333,\n                1104419699537997,\n                783495707664463,\n                1747473107602770,\n                2002634765788641,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1607325776830197,\n                2782683755100581,\n                1451089452727894,\n                3833490970768671,\n                496100432831153,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1068900648804224,\n                2006891997072550,\n                1134049269345549,\n                1638760646180091,\n                2055396084625778,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2222475519314561,\n                1870703901472013,\n                1884051508440561,\n                1344072275216753,\n                1318025677799069,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                155711679280637,\n                681100400509288,\n                389811735211209,\n                2135723811340709,\n                2660533024889373,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                7813206966729,\n                194444201427550,\n                2071405409526507,\n                1065605076176312,\n                1645486789731291,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                16625790644959,\n                1647648827778410,\n                1579910185572704,\n                436452271048548,\n                121070048451050,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3289062842237779,\n                2820185594063076,\n                2549752917829677,\n                3810384325616458,\n                2238221839292470,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                190565267697443,\n                672855706028058,\n                338796554369226,\n                337687268493904,\n                853246848691734,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1763863028400139,\n                766498079432444,\n                1321118624818005,\n                69494294452268,\n                858786744165651,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3543856582248253,\n                1456632109855637,\n                3352431060735432,\n                1386133165675320,\n                3484698163879000,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                366253102478259,\n                525676242508811,\n                1449610995265438,\n                1183300845322183,\n                185960306491545,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                28315355815982,\n                460422265558930,\n                1799675876678724,\n                1969256312504498,\n                1051823843138725,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2408714813047231,\n                3857948219405196,\n                1665208410108429,\n                2569443092377519,\n                1383783705665319,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                54684536365732,\n                2210010038536222,\n                1194984798155308,\n                535239027773705,\n                1516355079301361,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1484387703771650,\n                198537510937949,\n                2186282186359116,\n                617687444857508,\n                647477376402122,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2147715541830533,\n                2751832352131065,\n                2898179830570073,\n                2604027669016369,\n                1488268620408051,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                159386186465542,\n                1877626593362941,\n                618737197060512,\n                1026674284330807,\n                1158121760792685,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1744544377739822,\n                1964054180355661,\n                1685781755873170,\n                2169740670377448,\n                1286112621104591,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2333777063470241,\n                3919742931398333,\n                3920783633320113,\n                1605016835177614,\n                1353960708075544,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1602253788689063,\n                439542044889886,\n                2220348297664483,\n                657877410752869,\n                157451572512238,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1029287186166717,\n                65860128430192,\n                525298368814832,\n                1491902500801986,\n                1461064796385400,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2660016802414475,\n                2121095722306988,\n                913562102267595,\n                1879708920318308,\n                2492861262121979,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1185483484383269,\n                1356339572588553,\n                584932367316448,\n                102132779946470,\n                1792922621116791,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1966196870701923,\n                2230044620318636,\n                1425982460745905,\n                261167817826569,\n                46517743394330,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2358877405280588,\n                3136759755857592,\n                2279106683482647,\n                2224911448949389,\n                3216151871930471,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1730194207717538,\n                431790042319772,\n                1831515233279467,\n                1372080552768581,\n                1074513929381760,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1450880638731607,\n                1019861580989005,\n                1229729455116861,\n                1174945729836143,\n                826083146840706,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1899935429242705,\n                1602068751520477,\n                940583196550370,\n                2334230882739107,\n                1540863155745695,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2136688454840028,\n                2099509000964294,\n                1690800495246475,\n                1217643678575476,\n                828720645084218,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                765548025667841,\n                462473984016099,\n                998061409979798,\n                546353034089527,\n                2212508972466858,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2298375097456408,\n                3144370785258318,\n                1281983193144089,\n                1491520128287375,\n                75847005908304,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1801436127943107,\n                1734436817907890,\n                1268728090345068,\n                167003097070711,\n                2233597765834956,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1997562060465113,\n                1048700225534011,\n                7615603985628,\n                1855310849546841,\n                2242557647635213,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1161017320376250,\n                2744424393854291,\n                2169815802355236,\n                3228296595417790,\n                1770879511019628,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1357044908364776,\n                729130645262438,\n                1762469072918979,\n                1365633616878458,\n                181282906404941,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1080413443139865,\n                1155205815510486,\n                1848782073549786,\n                622566975152580,\n                124965574467971,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1184526762066993,\n                247622751762817,\n                2943928830891604,\n                3071818503097743,\n                2188697339828084,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2020536369003019,\n                202261491735136,\n                1053169669150884,\n                2056531979272544,\n                778165514694311,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                237404399610207,\n                1308324858405118,\n                1229680749538400,\n                720131409105291,\n                1958958863624906,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2767383321724075,\n                2269456792542436,\n                1717918437373988,\n                1568052070792483,\n                2298775616809171,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                281527309158085,\n                36970532401524,\n                866906920877543,\n                2222282602952734,\n                1289598729589882,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1278207464902042,\n                494742455008756,\n                1262082121427081,\n                1577236621659884,\n                1888786707293291,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                353042527954210,\n                1830056151907359,\n                1111731275799225,\n                2426760769524072,\n                404312815582674,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2064251142068628,\n                1666421603389706,\n                1419271365315441,\n                468767774902855,\n                191535130366583,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1716987058588002,\n                1859366439773457,\n                1767194234188234,\n                64476199777924,\n                1117233614485261,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3236091949205521,\n                2386938060636506,\n                2220652137473166,\n                1722843421165029,\n                2442282371698157,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                298845952651262,\n                1166086588952562,\n                1179896526238434,\n                1347812759398693,\n                1412945390096208,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1143239552672925,\n                906436640714209,\n                2177000572812152,\n                2075299936108548,\n                325186347798433,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2972824668060020,\n                2936287674948563,\n                3625238557779406,\n                2193186935276994,\n                1387043709851261,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                418098668140962,\n                715065997721283,\n                1471916138376055,\n                2168570337288357,\n                937812682637044,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1043584187226485,\n                2143395746619356,\n                2209558562919611,\n                482427979307092,\n                847556718384018,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1248731221520740,\n                1465200936117687,\n                2792603306395388,\n                2304778448366139,\n                2513234303861356,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1057329623869501,\n                620334067429122,\n                461700859268034,\n                2012481616501857,\n                297268569108938,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1055352180870759,\n                1553151421852298,\n                1510903185371259,\n                1470458349428097,\n                1226259419062731,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3744788603986897,\n                3042126439258578,\n                3441906842094992,\n                3641194565844440,\n                3872208010289441,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                47000654413729,\n                1004754424173864,\n                1868044813557703,\n                173236934059409,\n                588771199737015,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                30498470091663,\n                1082245510489825,\n                576771653181956,\n                806509986132686,\n                1317634017056939,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2672107869436803,\n                3745154677001249,\n                2417006535213335,\n                4136645508605033,\n                2065456951573058,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1115636332012334,\n                1854340990964155,\n                83792697369514,\n                1972177451994021,\n                457455116057587,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1698968457310898,\n                1435137169051090,\n                1083661677032510,\n                938363267483709,\n                340103887207182,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1995325341336555,\n                911500251774648,\n                2415810569088940,\n                855378419194761,\n                3825401211214090,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                241719380661528,\n                310028521317150,\n                1215881323380194,\n                1408214976493624,\n                2141142156467363,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1315157046163473,\n                727368447885818,\n                1363466668108618,\n                1668921439990361,\n                1398483384337907,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2326829491984875,\n                3267188020145720,\n                1849729037055211,\n                4191614430138232,\n                2696204044080201,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2053597130993710,\n                2024431685856332,\n                2233550957004860,\n                2012407275509545,\n                872546993104440,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1217269667678610,\n                599909351968693,\n                1390077048548598,\n                1471879360694802,\n                739586172317596,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3970118453066023,\n                1560510726633957,\n                3156262694845170,\n                1418028351780051,\n                2346204163137185,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2132502667405250,\n                214379346175414,\n                1502748313768060,\n                1960071701057800,\n                1353971822643138,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                319394212043702,\n                2127459436033571,\n                717646691535162,\n                663366796076914,\n                318459064945314,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2657789238608841,\n                1960452633787082,\n                2919148848086913,\n                3744474074452359,\n                1451061489880786,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                947085906234007,\n                323284730494107,\n                1485778563977200,\n                728576821512394,\n                901584347702286,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1575783124125742,\n                2126210792434375,\n                1569430791264065,\n                1402582372904727,\n                1891780248341114,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3090232019245924,\n                4249503325136911,\n                3270591693593114,\n                1662001808174330,\n                2330127946643001,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                739152638255629,\n                2074935399403557,\n                505483666745895,\n                1611883356514088,\n                628654635394878,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1822054032121349,\n                643057948186973,\n                7306757352712,\n                577249257962099,\n                284735863382083,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3618358370049178,\n                1448606567552085,\n                3730680834630016,\n                2417602993041145,\n                1115718458123497,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                204146226972102,\n                1630511199034723,\n                2215235214174763,\n                174665910283542,\n                956127674017216,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1562934578796716,\n                1070893489712745,\n                11324610642270,\n                958989751581897,\n                2172552325473805,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1770564423056008,\n                2987323445349813,\n                1326060113795288,\n                1509650369341127,\n                2317692235267932,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                623682558650637,\n                1337866509471512,\n                990313350206649,\n                1314236615762469,\n                1164772974270275,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                223256821462517,\n                723690150104139,\n                1000261663630601,\n                933280913953265,\n                254872671543046,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1969087237026022,\n                2876595539132372,\n                1335555107635968,\n                2069986355593023,\n                3963899963027150,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1236103475266979,\n                1837885883267218,\n                1026072585230455,\n                1025865513954973,\n                1801964901432134,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1115241013365517,\n                1712251818829143,\n                2148864332502771,\n                2096001471438138,\n                2235017246626125,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3551068012286861,\n                2047148477845620,\n                2165648650132450,\n                1612539282026145,\n                2765997725314138,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                118352772338543,\n                1067608711804704,\n                1434796676193498,\n                1683240170548391,\n                230866769907437,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1850689576796636,\n                1601590730430274,\n                1139674615958142,\n                1954384401440257,\n                76039205311,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1723387471374172,\n                3249101280723658,\n                2785727448808904,\n                2272728458379212,\n                1756575222802512,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2146711623855116,\n                503278928021499,\n                625853062251406,\n                1109121378393107,\n                1033853809911861,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                571005965509422,\n                2005213373292546,\n                1016697270349626,\n                56607856974274,\n                914438579435146,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1346698876211176,\n                2076651707527589,\n                3336561384795453,\n                2517134292513653,\n                1068954492309670,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1769967932677654,\n                1695893319756416,\n                1151863389675920,\n                1781042784397689,\n                400287774418285,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1851867764003121,\n                403841933237558,\n                820549523771987,\n                761292590207581,\n                1743735048551143,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                410915148140008,\n                2107072311871739,\n                3256167275561751,\n                2351484709082008,\n                1180818713503223,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                285945406881439,\n                648174397347453,\n                1098403762631981,\n                1366547441102991,\n                1505876883139217,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                672095903120153,\n                1675918957959872,\n                636236529315028,\n                1569297300327696,\n                2164144194785875,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1902708175321798,\n                3287143344600686,\n                1178560808893262,\n                2552895497743394,\n                1280977479761117,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1615357281742403,\n                404257611616381,\n                2160201349780978,\n                1160947379188955,\n                1578038619549541,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2013087639791217,\n                822734930507457,\n                1785668418619014,\n                1668650702946164,\n                389450875221715,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2705718263383616,\n                2358206633614248,\n                2072540975937134,\n                308588860670238,\n                1304394580755385,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1295082798350326,\n                2091844511495996,\n                1851348972587817,\n                3375039684596,\n                789440738712837,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2083069137186154,\n                848523102004566,\n                993982213589257,\n                1405313299916317,\n                1532824818698468,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3747761112537659,\n                1397203457344778,\n                4026750030752190,\n                2391102557240943,\n                2318403398028034,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1782411379088302,\n                1096724939964781,\n                27593390721418,\n                542241850291353,\n                1540337798439873,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                693543956581437,\n                171507720360750,\n                1557908942697227,\n                1074697073443438,\n                1104093109037196,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                345288228393400,\n                3351443383432420,\n                2386681722088990,\n                1740551994106739,\n                2500011992985018,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                231429562203065,\n                1526290236421172,\n                2021375064026423,\n                1520954495658041,\n                806337791525116,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1079623667189886,\n                872403650198613,\n                766894200588288,\n                2163700860774109,\n                2023464507911816,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                854645372543796,\n                1936406001954827,\n                2403260476226501,\n                3077125552956802,\n                1554306377287555,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1497138821904622,\n                1044820250515590,\n                1742593886423484,\n                1237204112746837,\n                849047450816987,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                667962773375330,\n                1897271816877105,\n                1399712621683474,\n                1143302161683099,\n                2081798441209593,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2378947665252234,\n                1936114012888109,\n                1704424366552046,\n                3108474694401560,\n                2968403435020606,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1072409664800960,\n                2146937497077528,\n                1508780108920651,\n                935767602384853,\n                1112800433544068,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                333549023751292,\n                280219272863308,\n                2104176666454852,\n                1036466864875785,\n                536135186520207,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2625466093568366,\n                2398257055215356,\n                2555916080813104,\n                2667888562832962,\n                3510376944868638,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1186115062588401,\n                2251609796968486,\n                1098944457878953,\n                1153112761201374,\n                1791625503417267,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1870078460219737,\n                2129630962183380,\n                852283639691142,\n                292865602592851,\n                401904317342226,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1361070124828016,\n                815664541425524,\n                3278598711049919,\n                1951790935390646,\n                2807674705520038,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1546301003424277,\n                459094500062839,\n                1097668518375311,\n                1780297770129643,\n                720763293687608,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1212405311403990,\n                1536693382542438,\n                61028431067459,\n                1863929423417129,\n                1223219538638038,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1294303766540260,\n                3435357279640341,\n                3134071170918340,\n                2315654383110622,\n                2213283684565086,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                339050984211414,\n                601386726509773,\n                413735232134068,\n                966191255137228,\n                1839475899458159,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                235605972169408,\n                2174055643032978,\n                1538335001838863,\n                1281866796917192,\n                1815940222628465,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1632352921721536,\n                1833328609514701,\n                2092779091951987,\n                4175756015558474,\n                2210068022482918,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                35271216625062,\n                1712350667021807,\n                983664255668860,\n                98571260373038,\n                1232645608559836,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1998172393429622,\n                1798947921427073,\n                784387737563581,\n                1589352214827263,\n                1589861734168180,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1733739258725305,\n                2283515530744786,\n                2453769758904107,\n                3243892858242237,\n                1194308773174555,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                846415389605137,\n                746163495539180,\n                829658752826080,\n                592067705956946,\n                957242537821393,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1758148849754419,\n                619249044817679,\n                168089007997045,\n                1371497636330523,\n                1867101418880350,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2578433797894864,\n                2513559319756263,\n                1700682323676192,\n                1577907266349064,\n                3469447477068264,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1714182387328607,\n                1477856482074168,\n                574895689942184,\n                2159118410227270,\n                1555532449716575,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                853828206885131,\n                998498946036955,\n                1835887550391235,\n                207627336608048,\n                258363815956050,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2392941288336925,\n                3488528558590503,\n                2894901233585134,\n                1646615130509172,\n                1208239602291765,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1501663228068911,\n                1354879465566912,\n                1444432675498247,\n                897812463852601,\n                855062598754348,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                714380763546606,\n                1032824444965790,\n                1774073483745338,\n                1063840874947367,\n                1738680636537158,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1640635546696233,\n                2884968766877360,\n                2212651044092395,\n                2282390772269100,\n                2620315074574625,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1171650314802029,\n                1567085444565577,\n                1453660792008405,\n                757914533009261,\n                1619511342778196,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                420958967093237,\n                971103481109486,\n                2169549185607107,\n                1301191633558497,\n                1661514101014240,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3158923465503550,\n                1332556122804145,\n                4075855067109735,\n                3619414031128206,\n                1982558335973171,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1121533090144639,\n                1021251337022187,\n                110469995947421,\n                1511059774758394,\n                2110035908131662,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                303213233384524,\n                2061932261128138,\n                352862124777736,\n                40828818670255,\n                249879468482660,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                856559257852200,\n                2760317478634258,\n                3629993581580163,\n                3975258940632376,\n                1962275756614520,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1445691340537320,\n                40614383122127,\n                402104303144865,\n                485134269878232,\n                1659439323587426,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                20057458979482,\n                1183363722525800,\n                2140003847237215,\n                2053873950687614,\n                2112017736174909,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2228654250927986,\n                3735391177100515,\n                1368661293910955,\n                3328311098862539,\n                526650682059607,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                709481497028540,\n                531682216165724,\n                316963769431931,\n                1814315888453765,\n                258560242424104,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1053447823660455,\n                1955135194248683,\n                1010900954918985,\n                1182614026976701,\n                1240051576966610,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1957943897155478,\n                1788667368028035,\n                2389492723714354,\n                2252839333292309,\n                3078204576998275,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1848942433095597,\n                1582009882530495,\n                1849292741020143,\n                1068498323302788,\n                2001402229799484,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1528282417624269,\n                2142492439828191,\n                2179662545816034,\n                362568973150328,\n                1591374675250271,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2411826493119617,\n                2484141002903963,\n                2149181472355544,\n                598041771119831,\n                2435658815595421,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2013278155187349,\n                662660471354454,\n                793981225706267,\n                411706605985744,\n                804490933124791,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2051892037280204,\n                488391251096321,\n                2230187337030708,\n                930221970662692,\n                679002758255210,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1530723630438670,\n                875873929577927,\n                2593359947955236,\n                2701702933216000,\n                1055551308214178,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1461835919309432,\n                1955256480136428,\n                180866187813063,\n                1551979252664528,\n                557743861963950,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                359179641731115,\n                1324915145732949,\n                902828372691474,\n                294254275669987,\n                1887036027752957,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4295071423139571,\n                2038225437857463,\n                1317528426475850,\n                1398989128982787,\n                2027639881006861,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2072902725256516,\n                312132452743412,\n                309930885642209,\n                996244312618453,\n                1590501300352303,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1397254305160710,\n                695734355138021,\n                2233992044438756,\n                1776180593969996,\n                1085588199351115,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2692366865016258,\n                2506694600041928,\n                2745669038615469,\n                1556322069683365,\n                3819256354004466,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1950722461391320,\n                1907845598854797,\n                1822757481635527,\n                2121567704750244,\n                73811931471221,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                387139307395758,\n                2058036430315676,\n                1220915649965325,\n                1794832055328951,\n                1230009312169328,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1765973779329498,\n                2911143873132225,\n                2271621715291913,\n                3553728154996461,\n                3368065817761132,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1127572801181483,\n                1224743760571696,\n                1276219889847274,\n                1529738721702581,\n                1589819666871853,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2181229378964934,\n                2190885205260020,\n                1511536077659137,\n                1246504208580490,\n                668883326494241,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2689666469258543,\n                2920826224880015,\n                2333696811665585,\n                523874406393177,\n                2496851874620484,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1975438052228868,\n                1071801519999806,\n                594652299224319,\n                1877697652668809,\n                1489635366987285,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                958592545673770,\n                233048016518599,\n                851568750216589,\n                567703851596087,\n                1740300006094761,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2014540178270324,\n                192672779514432,\n                2465676996326778,\n                2194819933853410,\n                1716422829364835,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1540769606609725,\n                2148289943846077,\n                1597804156127445,\n                1230603716683868,\n                815423458809453,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1738560251245018,\n                1779576754536888,\n                1783765347671392,\n                1880170990446751,\n                1088225159617541,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2911103727614740,\n                1956447718227572,\n                1830568515922666,\n                3092868863429656,\n                1669607124206367,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1143465490433355,\n                1532194726196059,\n                1093276745494697,\n                481041706116088,\n                2121405433561163,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1686424298744462,\n                1451806974487153,\n                266296068846582,\n                1834686947542675,\n                1720762336132256,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3141016840074207,\n                3295090436969907,\n                3107924901237156,\n                1669272323124635,\n                1603340330827879,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1206396181488998,\n                333158148435054,\n                1402633492821422,\n                1120091191722026,\n                1945474114550509,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                766720088232571,\n                1512222781191002,\n                1189719893490790,\n                2091302129467914,\n                2141418006894941,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2671463460991841,\n                1998875112167986,\n                3678399683938955,\n                3406728169064757,\n                2738338345823434,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                938160078005954,\n                1421776319053174,\n                1941643234741774,\n                180002183320818,\n                1414380336750546,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                398001940109652,\n                1577721237663248,\n                1012748649830402,\n                1540516006905144,\n                1011684812884559,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1653276489969611,\n                2257881638852872,\n                1921777941170835,\n                1604139841794531,\n                3113010867325889,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                996661541407379,\n                1455877387952927,\n                744312806857277,\n                139213896196746,\n                1000282908547789,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1450817495603008,\n                1476865707053229,\n                1030490562252053,\n                620966950353376,\n                1744760161539058,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2811528223687828,\n                2288856475326432,\n                2038622963352005,\n                1637244893271723,\n                3278365165924196,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                962165956135846,\n                1116599660248791,\n                182090178006815,\n                1455605467021751,\n                196053588803284,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                796863823080135,\n                1897365583584155,\n                420466939481601,\n                2165972651724672,\n                932177357788289,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                877047233620613,\n                1375632631944375,\n                2895573425567369,\n                2911822552533124,\n                2271153746017078,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2216943882299338,\n                394841323190322,\n                2222656898319671,\n                558186553950529,\n                1077236877025190,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                801118384953213,\n                1914330175515892,\n                574541023311511,\n                1471123787903705,\n                1526158900256288,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3201417702772463,\n                2207116611267330,\n                3164719852826535,\n                2752958352884036,\n                2314162374456719,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1474518386765335,\n                1760793622169197,\n                1157399790472736,\n                1622864308058898,\n                165428294422792,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1961673048027128,\n                102619413083113,\n                1051982726768458,\n                1603657989805485,\n                1941613251499678,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1401939116319247,\n                2587106153588320,\n                2323846009771033,\n                862423201496005,\n                3102318568216632,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1234706593321979,\n                1083343891215917,\n                898273974314935,\n                1640859118399498,\n                157578398571149,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1143483057726416,\n                1992614991758919,\n                674268662140796,\n                1773370048077526,\n                674318359920189,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1835401379538542,\n                173900035308392,\n                818247630716732,\n                4013900225838034,\n                1021506399448290,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1506632088156630,\n                2127481795522179,\n                513812919490255,\n                140643715928370,\n                442476620300318,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2056683376856736,\n                219094741662735,\n                2193541883188309,\n                1841182310235800,\n                556477468664293,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3566819241596075,\n                1049075855992602,\n                4318372866671791,\n                2518704280870781,\n                2040482348591519,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                94096246544434,\n                922482381166992,\n                24517828745563,\n                2139430508542503,\n                2097139044231004,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                537697207950515,\n                1399352016347350,\n                1563663552106345,\n                2148749520888918,\n                549922092988516,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1747985413252415,\n                680511052635695,\n                1809559829982725,\n                2846074064615302,\n                2453472984431229,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                323583936109569,\n                1973572998577657,\n                1192219029966558,\n                79354804385273,\n                1374043025560347,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                213277331329947,\n                416202017849623,\n                1950535221091783,\n                1313441578103244,\n                2171386783823658,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2440888617915079,\n                993969372859109,\n                3147669935222235,\n                3799101348983503,\n                1477373024911349,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1620578418245010,\n                541035331188469,\n                2235785724453865,\n                2154865809088198,\n                1974627268751826,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1346805451740245,\n                1350981335690626,\n                942744349501813,\n                2155094562545502,\n                1012483751693409,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2107080134091762,\n                1132567062788208,\n                1824935377687210,\n                769194804343737,\n                1857941799971888,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1074666112436467,\n                249279386739593,\n                1174337926625354,\n                1559013532006480,\n                1472287775519121,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1872620123779532,\n                1892932666768992,\n                1921559078394978,\n                1270573311796160,\n                1438913646755037,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3089190001333428,\n                3264053113908846,\n                989780015893986,\n                1351393287739814,\n                2580427560230798,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1028328827183114,\n                1711043289969857,\n                1350832470374933,\n                1923164689604327,\n                1495656368846911,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1900828492104143,\n                430212361082163,\n                687437570852799,\n                832514536673512,\n                1685641495940794,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3094432661621646,\n                605670026766215,\n                290836444839585,\n                2415010588577604,\n                2213815011799644,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1176336383453996,\n                1725477294339771,\n                12700622672454,\n                678015708818208,\n                162724078519879,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1448049969043497,\n                1789411762943521,\n                385587766217753,\n                90201620913498,\n                832999441066823,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2767886146978542,\n                2240508292484615,\n                3603469341851756,\n                3475055379001735,\n                3002035638112385,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1263624896582495,\n                1102602401673328,\n                526302183714372,\n                2152015839128799,\n                1483839308490010,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                442991718646863,\n                1599275157036458,\n                1925389027579192,\n                899514691371390,\n                350263251085160,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1689713572022124,\n                2845654372939621,\n                3229894858477217,\n                1985127338729498,\n                3927868934032873,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1557207018622683,\n                340631692799603,\n                1477725909476187,\n                614735951619419,\n                2033237123746766,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                968764929340557,\n                1225534776710944,\n                662967304013036,\n                1155521416178595,\n                791142883466590,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1487081286167458,\n                3244839255500182,\n                1792378982844639,\n                2950452258685122,\n                2153908693179753,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1123181311102823,\n                685575944875442,\n                507605465509927,\n                1412590462117473,\n                568017325228626,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                560258797465417,\n                2193971151466401,\n                1824086900849026,\n                579056363542056,\n                1690063960036441,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1918407319222397,\n                2605567366745211,\n                1930426334528098,\n                1564816146005724,\n                4113142195393344,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2131325168777276,\n                1176636658428908,\n                1756922641512981,\n                1390243617176012,\n                1966325177038383,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2063958120364491,\n                2140267332393533,\n                699896251574968,\n                273268351312140,\n                375580724713232,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2024297515263178,\n                2668759143407935,\n                3330814048702549,\n                2423412039258430,\n                1031677520051052,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2033900009388450,\n                1744902869870788,\n                2190580087917640,\n                1949474984254121,\n                231049754293748,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                343868674606581,\n                550155864008088,\n                1450580864229630,\n                481603765195050,\n                896972360018042,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2151139328380127,\n                2566545695770176,\n                2311556639460451,\n                1676664391494650,\n                2048348075599360,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1528930066340597,\n                1605003907059576,\n                1055061081337675,\n                1458319101947665,\n                1234195845213142,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                830430507734812,\n                1780282976102377,\n                1425386760709037,\n                362399353095425,\n                2168861579799910,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3407562046415562,\n                980662895504005,\n                2053766700883521,\n                2742766027762854,\n                2762205690726604,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1683750316716132,\n                652278688286128,\n                1221798761193539,\n                1897360681476669,\n                319658166027343,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                618808732869972,\n                72755186759744,\n                2060379135624181,\n                1730731526741822,\n                48862757828238,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3714971784278753,\n                3394840525452699,\n                614590986558882,\n                1409210575145591,\n                1882816996436803,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2230133264691131,\n                563950955091024,\n                2042915975426398,\n                827314356293472,\n                672028980152815,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                264204366029760,\n                1654686424479449,\n                2185050199932931,\n                2207056159091748,\n                506015669043634,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1784446333136550,\n                1973746527984364,\n                334856327359575,\n                3408569589569858,\n                3275749938360725,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2065270940578383,\n                31477096270353,\n                306421879113491,\n                181958643936686,\n                1907105536686083,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1496516440779464,\n                1748485652986458,\n                872778352227340,\n                818358834654919,\n                97932669284220,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2723435829455580,\n                2924255216478824,\n                1804995246884102,\n                1842309243470804,\n                3753662318666930,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1013216974933691,\n                538921919682598,\n                1915776722521558,\n                1742822441583877,\n                1886550687916656,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2094270000643336,\n                303971879192276,\n                40801275554748,\n                649448917027930,\n                1818544418535447,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2241737709499146,\n                549397817447461,\n                838180519319392,\n                1725686958520781,\n                3957438894582995,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1216074541925116,\n                50120933933509,\n                1565829004133810,\n                721728156134580,\n                349206064666188,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                948617110470858,\n                346222547451945,\n                1126511960599975,\n                1759386906004538,\n                493053284802266,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1454933046815146,\n                3126495827951610,\n                1467170975468587,\n                1432316382418897,\n                2111710746366763,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2105387117364450,\n                1996463405126433,\n                1303008614294500,\n                851908115948209,\n                1353742049788635,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                750300956351719,\n                1487736556065813,\n                15158817002104,\n                1511998221598392,\n                971739901354129,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1874648163531674,\n                2124487685930551,\n                1810030029384882,\n                918400043048335,\n                2838148440985898,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1235084464747900,\n                1166111146432082,\n                1745394857881591,\n                1405516473883040,\n                4463504151617,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1663810156463827,\n                327797390285791,\n                1341846161759410,\n                1964121122800605,\n                1747470312055380,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                660005247548214,\n                2071860029952887,\n                3610548013635355,\n                911703252219106,\n                3266179736709079,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2206641276178231,\n                1690587809721504,\n                1600173622825126,\n                2156096097634421,\n                1106822408548216,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1344788193552206,\n                1949552134239140,\n                1735915881729557,\n                675891104100469,\n                1834220014427292,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1920949492387945,\n                2410685102072778,\n                2322108077349280,\n                2877838278583064,\n                3719881539786256,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                622221042073383,\n                1210146474039168,\n                1742246422343683,\n                1403839361379025,\n                417189490895736,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                22727256592983,\n                168471543384997,\n                1324340989803650,\n                1839310709638189,\n                504999476432775,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3565040332441556,\n                1721896294296941,\n                2304063388272514,\n                2065069734239231,\n                3056710287109878,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1337466662091884,\n                1287645354669772,\n                2018019646776184,\n                652181229374245,\n                898011753211715,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1969792547910734,\n                779969968247557,\n                2011350094423418,\n                1823964252907487,\n                1058949448296945,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2459143550747250,\n                1118176942430252,\n                3010694408233412,\n                806764629546265,\n                1157700123092949,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1273565321399022,\n                1638509681964574,\n                759235866488935,\n                666015124346707,\n                897983460943405,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1717263794012298,\n                1059601762860786,\n                1837819172257618,\n                1054130665797229,\n                680893204263559,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2237039662793603,\n                2249022333361206,\n                2058613546633703,\n                2401253908530527,\n                2215176649164581,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                79472182719605,\n                1851130257050174,\n                1825744808933107,\n                821667333481068,\n                781795293511946,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                755822026485370,\n                152464789723500,\n                1178207602290608,\n                410307889503239,\n                156581253571278,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3669985309815545,\n                2736319981413860,\n                3898537095128197,\n                3653287498355512,\n                1349185550126960,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1495380034400429,\n                325049476417173,\n                46346894893933,\n                1553408840354856,\n                828980101835683,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1280337889310282,\n                2070832742866672,\n                1640940617225222,\n                2098284908289951,\n                450929509534434,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2659503167684029,\n                2378371955168899,\n                2537839641198868,\n                1999255076709337,\n                2030511179441770,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1254958221100483,\n                1153235960999843,\n                942907704968834,\n                637105404087392,\n                1149293270147267,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                894249020470196,\n                400291701616810,\n                406878712230981,\n                1599128793487393,\n                1145868722604026,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3749755063888563,\n                2361916158338507,\n                1128535642171975,\n                1900106496009660,\n                2381592531146157,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                452487513298665,\n                1352120549024569,\n                1173495883910956,\n                1999111705922009,\n                367328130454226,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1717539401269642,\n                1475188995688487,\n                891921989653942,\n                836824441505699,\n                1885988485608364,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3493583935107776,\n                2439136865632830,\n                3370281625921440,\n                2680547565621609,\n                2282158712612572,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2022432361201842,\n                1088816090685051,\n                1977843398539868,\n                1854834215890724,\n                564238862029357,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                938868489100585,\n                1100285072929025,\n                1017806255688848,\n                1957262154788833,\n                152787950560442,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3119119231364171,\n                2872271776627789,\n                2477832016990963,\n                2593801257642876,\n                1761675818237335,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1295072362439987,\n                931227904689414,\n                1355731432641687,\n                922235735834035,\n                892227229410209,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1680989767906154,\n                535362787031440,\n                2136691276706570,\n                1942228485381244,\n                1267350086882274,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2617818047455756,\n                2684460443440843,\n                2378209521329782,\n                1973842949591661,\n                2897427157127624,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                535509430575217,\n                546885533737322,\n                1524675609547799,\n                2138095752851703,\n                1260738089896827,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1159906385590467,\n                2198530004321610,\n                714559485023225,\n                81880727882151,\n                1484020820037082,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1377485731340769,\n                2046328105512000,\n                1802058637158797,\n                2313945950453421,\n                1356993908853900,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2013612215646735,\n                1830770575920375,\n                536135310219832,\n                609272325580394,\n                270684344495013,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1237542585982777,\n                2228682050256790,\n                1385281931622824,\n                593183794882890,\n                493654978552689,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2299141301692989,\n                1891414891220256,\n                983894663308928,\n                2427961581972066,\n                3378060928864955,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1694030170963455,\n                502038567066200,\n                1691160065225467,\n                949628319562187,\n                275110186693066,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1124515748676336,\n                1661673816593408,\n                1499640319059718,\n                1584929449166988,\n                558148594103306,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1784525599998356,\n                1619698033617383,\n                2097300287550715,\n                2510065271789004,\n                1905684794832757,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1288941072872766,\n                931787902039402,\n                190731008859042,\n                2006859954667190,\n                1005931482221702,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1465551264822703,\n                152905080555927,\n                680334307368453,\n                173227184634745,\n                666407097159852,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2111017076203943,\n                3630560299479595,\n                1248583954016455,\n                3604089008549670,\n                1895180776543895,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                171348223915638,\n                662766099800389,\n                462338943760497,\n                466917763340314,\n                656911292869115,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                488623681976577,\n                866497561541722,\n                1708105560937768,\n                1673781214218839,\n                1506146329818807,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2412225278142205,\n                950394373239688,\n                2682296937026182,\n                711676555398831,\n                320964687779005,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                988979367990485,\n                1359729327576302,\n                1301834257246029,\n                294141160829308,\n                29348272277475,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1434382743317910,\n                100082049942065,\n                221102347892623,\n                186982837860588,\n                1305765053501834,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2205916462268190,\n                2751663643476068,\n                961960554686615,\n                2409862576442233,\n                1841471168298304,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1191737341426592,\n                1847042034978363,\n                1382213545049056,\n                1039952395710448,\n                788812858896859,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1346965964571152,\n                1291881610839830,\n                2142916164336056,\n                786821641205979,\n                1571709146321039,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                787164375951248,\n                2454669019058437,\n                3608390234717387,\n                1431233331032509,\n                786341368775957,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                492448143532951,\n                304105152670757,\n                1761767168301056,\n                233782684697790,\n                1981295323106089,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                665807507761866,\n                1343384868355425,\n                895831046139653,\n                439338948736892,\n                1986828765695105,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3007896024559801,\n                1721699973539148,\n                2510565115413133,\n                1390588532210644,\n                1212530909934781,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                852891097972275,\n                1816988871354562,\n                1543772755726524,\n                1174710635522444,\n                202129090724628,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1205281565824323,\n                22430498399418,\n                992947814485516,\n                1392458699738672,\n                688441466734558,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3302427242100220,\n                1955849529137134,\n                2171162376368357,\n                2343545681983462,\n                447733118757825,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1287181461435438,\n                622722465530711,\n                880952150571872,\n                741035693459198,\n                311565274989772,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1003649078149734,\n                545233927396469,\n                1849786171789880,\n                1318943684880434,\n                280345687170552,\n            ]),\n        },\n    ]),\n]);\n\n/// Odd multiples of the basepoint `[B, 3B, 5B, 7B, 9B, 11B, 13B, 15B, ..., 127B]`.\n#[cfg(feature = \"precomputed-tables\")]\n#[allow(dead_code)]\npub(crate) const AFFINE_ODD_MULTIPLES_OF_BASEPOINT: NafLookupTable8<AffineNielsPoint> =\n    NafLookupTable8([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3540182452943730,\n                2497478415033846,\n                2521227595762870,\n                1462984067271729,\n                2389212253076811,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                62697248952638,\n                204681361388450,\n                631292143396476,\n                338455783676468,\n                1213667448819585,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                301289933810280,\n                1259582250014073,\n                1422107436869536,\n                796239922652654,\n                1953934009299142,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1601611775252272,\n                1720807796594148,\n                1132070835939856,\n                3512254832574799,\n                2147779492816910,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                316559037616741,\n                2177824224946892,\n                1459442586438991,\n                1461528397712656,\n                751590696113597,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1850748884277385,\n                1200145853858453,\n                1068094770532492,\n                672251375690438,\n                1586055907191707,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                769950342298400,\n                2384754244604994,\n                3095885746880802,\n                3225892188161580,\n                2977876099231263,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                425251763115706,\n                608463272472562,\n                442562545713235,\n                837766094556764,\n                374555092627893,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1086255230780037,\n                274979815921559,\n                1960002765731872,\n                929474102396301,\n                1190409889297339,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2916800678241215,\n                2065379846933858,\n                2622030924071124,\n                2602788184473875,\n                1233371373142984,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2019367628972465,\n                676711900706637,\n                110710997811333,\n                1108646842542025,\n                517791959672113,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                965130719900578,\n                247011430587952,\n                526356006571389,\n                91986625355052,\n                2157223321444601,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1802695059464988,\n                1664899123557221,\n                2845359304426105,\n                2160434469266658,\n                3179370264440279,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1725674970513508,\n                1933645953859181,\n                1542344539275782,\n                1767788773573747,\n                1297447965928905,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1381809363726107,\n                1430341051343062,\n                2061843536018959,\n                1551778050872521,\n                2036394857967624,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4222693909998302,\n                2779866139518454,\n                1619374932191226,\n                2207306624415883,\n                1169170329061080,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2070390218572616,\n                1458919061857835,\n                624171843017421,\n                1055332792707765,\n                433987520732508,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                893653801273833,\n                1168026499324677,\n                1242553501121234,\n                1306366254304474,\n                1086752658510815,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2465253816303469,\n                3191571337672685,\n                1159882208056013,\n                2569188183312765,\n                621213314200686,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1971678598905747,\n                338026507889165,\n                762398079972271,\n                655096486107477,\n                42299032696322,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                177130678690680,\n                1754759263300204,\n                1864311296286618,\n                1180675631479880,\n                1292726903152791,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1913163449625248,\n                2712579013977241,\n                2193883288642313,\n                1008900146920800,\n                1721983679009502,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1070401523076875,\n                1272492007800961,\n                1910153608563310,\n                2075579521696771,\n                1191169788841221,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                692896803108118,\n                500174642072499,\n                2068223309439677,\n                1162190621851337,\n                1426986007309901,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1819621230288238,\n                2735700366193240,\n                1755134670739586,\n                3080648199451191,\n                4172807995775876,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                992069868904071,\n                799011518185730,\n                1777586403832768,\n                1134820506145684,\n                1999461475558530,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                425204543703124,\n                2040469794090382,\n                1651690622153809,\n                1500530168597569,\n                1253908377065966,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2105824306960939,\n                1387520302709358,\n                3633176580451016,\n                2211816663841753,\n                1629085891776489,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1485201376284999,\n                1022406647424656,\n                504181009209019,\n                962621520820995,\n                590876713147230,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                265873406365287,\n                1192742653492898,\n                88553098803050,\n                525037770869640,\n                1266933811251234,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3552316659826612,\n                1254279525791875,\n                1609927932077699,\n                3578654071679972,\n                3750681296069893,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                37186803519861,\n                1404297334376301,\n                578519728836650,\n                1740727951192592,\n                2095534282477028,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                833234263154399,\n                2023862470013762,\n                1854137933982069,\n                853924318090959,\n                1589812702805850,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3679150557957763,\n                1319179453661745,\n                497496853611112,\n                2665464286942351,\n                1208137952365560,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1654513078530905,\n                907489875842908,\n                126098711296368,\n                1726320004173677,\n                28269495058173,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                114436686957443,\n                532739313025996,\n                115428841215897,\n                2191499400074366,\n                370280402676434,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1111146849833253,\n                2016430049079759,\n                1860522747477948,\n                3537164738290194,\n                4137142824844184,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                429069864577128,\n                975327637149449,\n                237881983565075,\n                1654761232378630,\n                2122527599091807,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2093793463548278,\n                754827233241879,\n                1420389751719629,\n                1829952782588138,\n                2011865756773717,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                676293365438898,\n                2850296017886344,\n                1205350322490195,\n                2763699392265669,\n                2133931188538142,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                48340340349120,\n                1299261101494832,\n                1137329686775218,\n                1534848106674340,\n                1351662218216799,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1904520614137939,\n                1590301001714014,\n                215781420985270,\n                2043534301034629,\n                1970888949300424,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2365217962409710,\n                2061307169694064,\n                1887478590157603,\n                2169639621284316,\n                2373810867477200,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1020052624656948,\n                1260412094216707,\n                366721640607121,\n                585331442306596,\n                345876457758061,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                975390299880933,\n                1066555195234642,\n                12651997758352,\n                1184252205433068,\n                1058378155074223,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1431537716602643,\n                2024827957433813,\n                3746434518400495,\n                1087794891033550,\n                2156817571680455,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                929288033346881,\n                255179964546973,\n                711057989588035,\n                208899572612840,\n                185348357387383,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                823689746424808,\n                47266130989546,\n                209403309368097,\n                1100966895202707,\n                710792075292719,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2311213117823762,\n                3296668540922318,\n                2004276520649823,\n                1861500579441125,\n                3148029033359833,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1563693677475261,\n                1843782073741194,\n                1950700654453170,\n                911540858113949,\n                2085151496302359,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1427880892005482,\n                106216431121745,\n                42608394782284,\n                1217295886989793,\n                1514235272796882,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3544335535746750,\n                2367994491347456,\n                2567261456502612,\n                1854058085060971,\n                2263545563461076,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                787426011300053,\n                2105981035769060,\n                1130476291127206,\n                1748659348100075,\n                53470983013756,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                553548273865386,\n                5927805718390,\n                65184587381926,\n                633576679686953,\n                576048559439973,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                993787326657446,\n                3868807161609258,\n                1615796046728943,\n                2514644292681953,\n                2059021068660907,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                251010270518880,\n                1681684095763484,\n                1521949356387564,\n                431593457045116,\n                1855308922422910,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                618490909691959,\n                1257497595618257,\n                202952467594088,\n                35577762721238,\n                1494883566841973,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1673474571932262,\n                2409784519770613,\n                2636095316260487,\n                2761112584601925,\n                3333713288149876,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1600640202645197,\n                1019569075331823,\n                1041916487915822,\n                1680448171313267,\n                2126903137527901,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                894964745143659,\n                106116880092678,\n                1009869382959477,\n                317866368542032,\n                1986983122763912,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1765281781276487,\n                2863247187455184,\n                2589075472439062,\n                1386435905543054,\n                2182338478845320,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1144730936996693,\n                2213315231278180,\n                1489676672185125,\n                665039429138074,\n                1131283313040268,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2004734176670602,\n                1738311085075235,\n                418866995976618,\n                1050782508034394,\n                577747313404652,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2185209688340293,\n                1309276076461009,\n                2514740038571278,\n                3994889904012999,\n                3018098826231021,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1405936970888515,\n                1754621155316654,\n                1211862168554999,\n                1813045702919083,\n                997853418197172,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                82037622045021,\n                1646398333621944,\n                613095452763466,\n                1312329542583705,\n                81014679202721,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2389287991277873,\n                403851022333257,\n                1597473361477193,\n                2953351602509212,\n                2135174663049062,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1826548187201150,\n                302299893734126,\n                1475477168615781,\n                842617616347376,\n                1438600873676130,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                663049852468609,\n                1649295727846569,\n                1048009692742781,\n                628866177992421,\n                1914360327429204,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1795645928096646,\n                306878154408959,\n                2924901319092394,\n                2801261341654799,\n                1653782432983523,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2077597317438627,\n                212642017882064,\n                674844477518888,\n                875487498687554,\n                2060550250171182,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1420448018683809,\n                1032663994771382,\n                1341927003385267,\n                1340360916546159,\n                1988547473895228,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1082660122598844,\n                2545055705583789,\n                3888919679589007,\n                1670283344995811,\n                3403239134794618,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                90430593339788,\n                1838338032241275,\n                571293238480915,\n                1639938867416883,\n                257378872001111,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1528535658865034,\n                1516636853043960,\n                787000569996728,\n                1464531394704506,\n                1684822625133795,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                811329918113934,\n                2783463529007378,\n                1769095754634835,\n                2970819621866866,\n                881037178164325,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1784566501964517,\n                433890943689325,\n                1186055625589419,\n                1496077405487512,\n                1731807117886548,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                424909811816304,\n                1355993963741797,\n                409606483251841,\n                455665350637068,\n                1617009023642808,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2478728492077816,\n                2780289048655501,\n                2328687177473769,\n                4107341333582032,\n                1316147724308250,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1617420574301156,\n                1741273341070467,\n                667135503486508,\n                2100436564640123,\n                1032223920000865,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1753947659404033,\n                247279202390193,\n                1819288880178945,\n                737334285670249,\n                1037873664856104,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1762568490530034,\n                673742465299012,\n                2054571050635888,\n                2040165159255111,\n                3040123733327257,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1627187989987422,\n                1686331580821752,\n                1309895873498183,\n                719718719104086,\n                300063199808722,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                238176707016164,\n                1440454788877048,\n                203336037573144,\n                1437789888677072,\n                101522256664211,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1895216760098480,\n                1934324337975022,\n                3677350688973167,\n                2536415965456176,\n                714678003308640,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                508185358728815,\n                1691320535341855,\n                2168887448239256,\n                1035124393070661,\n                1936603999698584,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                390562831571647,\n                1390223890708972,\n                1383183990676371,\n                435998174196410,\n                1882086414390730,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3747620842612921,\n                2081794785291195,\n                3284594056262745,\n                2090090346797895,\n                2581692978935809,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                244144781251265,\n                1290834426417077,\n                1888701171101942,\n                1233922456644870,\n                241117402207491,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1266169390045455,\n                1148042013187970,\n                878921907853942,\n                1815738019658093,\n                908920199341621,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2521768507305118,\n                953557056811112,\n                2015863732865770,\n                1358382511861315,\n                2835421647899992,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2239837206240498,\n                330928973149665,\n                422268062913642,\n                1481280019493032,\n                619879520439841,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1360166735366017,\n                1770556573948510,\n                1395061284191031,\n                1814003148068126,\n                522781147076884,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2611794802645686,\n                707234844948070,\n                1314059396506491,\n                2919250341703934,\n                2161831667832785,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                934831784182383,\n                433734253968318,\n                1660867106725771,\n                1968393082772831,\n                873946300968490,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                26306827827554,\n                430884999378685,\n                1504310424376419,\n                1761358720837522,\n                542195685418530,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1762131062631725,\n                3123952634417535,\n                3619918390837537,\n                2909990877347294,\n                1411594230004385,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                538272372224622,\n                1425714779586199,\n                588313661410172,\n                1497062084392578,\n                1602174047128512,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                907490361939255,\n                1963620338391363,\n                626927432296975,\n                1250748516081414,\n                959901171882527,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1335066153744413,\n                2887804660779657,\n                2653073855954038,\n                2765226981667422,\n                938831784476763,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                296699434737224,\n                2047543711075683,\n                2076451038937139,\n                227783599906901,\n                1602062110967627,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1574834773194203,\n                1384279952062839,\n                393652417255803,\n                2166968242848859,\n                1552890441390820,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1619646774410947,\n                1576090644023562,\n                3035228391320965,\n                1735328519940543,\n                2355324535937066,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1024074573633446,\n                957088456885874,\n                1690425531356997,\n                2102187380180052,\n                1082544623222033,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1871906170635853,\n                1719383891167200,\n                1584032250247862,\n                823764804192117,\n                2244048510084261,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                642147846489775,\n                3334304977145699,\n                305205716788147,\n                2589176626729533,\n                2224680511484174,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1734162377166545,\n                260713621840346,\n                157174591942595,\n                952544272517991,\n                222818702471733,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1213115494182947,\n                286778704335711,\n                2130189536016490,\n                308349182281342,\n                1217623948685491,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3360052266973635,\n                1843486583624091,\n                1561693837124349,\n                1084041964025479,\n                1866270922024009,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                460705465481210,\n                1968151453817859,\n                497005926994844,\n                625618055866751,\n                2176893440866887,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1655800250476757,\n                2036588542300609,\n                666447448675243,\n                1615721995750683,\n                1508669225186765,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2245948203759141,\n                1058306669699396,\n                1452898014240582,\n                3961024141962768,\n                1633235287338608,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                986647273684279,\n                1507266907811370,\n                1260572633649005,\n                2071672342077446,\n                695976026010857,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1312356620823495,\n                1635278548098567,\n                901946076841033,\n                585120475533168,\n                1240667113237384,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2313723935779695,\n                1506054666773895,\n                996040223525031,\n                636592914999692,\n                1497801917020297,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                292042016419794,\n                1158932298133044,\n                2062611870323738,\n                1946058478962569,\n                1749165808126286,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                654683942212830,\n                1526897351349087,\n                2006818439922838,\n                2194919327350361,\n                1451960776874416,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3015041017808905,\n                2951823141773809,\n                2584865668253675,\n                2508192032998563,\n                2582137700042019,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1628123495344283,\n                2072923641214546,\n                1647225812023982,\n                855655925244679,\n                1758126430071140,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1615895096489599,\n                275295258643784,\n                937665541219916,\n                1313496726746346,\n                1186468946422626,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1603070202850694,\n                2072127623773242,\n                1692648737212158,\n                2493373404187852,\n                1248948672117105,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                11167836031898,\n                596565174397990,\n                2196351068723859,\n                314744641791907,\n                1102014997250781,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1409047922401191,\n                69960384467966,\n                688103515547600,\n                1309746102488044,\n                150292892873778,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1986083055103168,\n                691715819340300,\n                1361811659746933,\n                3459052030333434,\n                1063594696046061,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1201987338414749,\n                2198784582460616,\n                1203335513981498,\n                489243077045066,\n                2205278143582433,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2034744376624534,\n                2077387101466387,\n                148448542974969,\n                1502697574577258,\n                473186584705655,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                472016956315960,\n                720786972252993,\n                2840633661190043,\n                3150798753357827,\n                2816563335499153,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                253464247569755,\n                168314237403057,\n                511780806170295,\n                1058862316549135,\n                1646858476817137,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                595092995922219,\n                1491311840717691,\n                291581784452778,\n                1569186646367854,\n                1031385061400544,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3483137021572755,\n                1526955102024322,\n                2778006642704458,\n                457549634924205,\n                1097420237736736,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1246991699537710,\n                81367319519439,\n                530844036072196,\n                163656863755855,\n                1950742455979290,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                191532664076407,\n                539378506082089,\n                1021612562876554,\n                1026603384732632,\n                1773368780410653,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4144620731387879,\n                590179521333342,\n                4034023318016108,\n                2255745030335426,\n                2699746851701250,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2206599697359952,\n                553895797384417,\n                181689161933786,\n                1153123447919104,\n                778568064152659,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1706307000059211,\n                1885601289314487,\n                889758608505788,\n                550131729999853,\n                1006862664714268,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3210197754285058,\n                2048500453422630,\n                3403309827888207,\n                927154428508963,\n                4199813798872019,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                992058915374933,\n                476120535358775,\n                1973648780784340,\n                2025282643598818,\n                2182318983793230,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1343440812005821,\n                1316045839091795,\n                1884951299078063,\n                1765919609219175,\n                2197567554627988,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3129247779382818,\n                4415026969054274,\n                1900265885969643,\n                1528796215447059,\n                2172730393748688,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1773355092297603,\n                64654329538271,\n                1332124041660957,\n                748492100858001,\n                895500006200535,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2000840647851980,\n                546565968824914,\n                420633283457524,\n                195470736374507,\n                1958689297569520,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                743138980705446,\n                3411117504637167,\n                2591389959690621,\n                2380042066577202,\n                3022267940115114,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                165947002229363,\n                115186103724967,\n                1068573292121517,\n                1842565776920938,\n                1969395681111987,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                553322266190633,\n                234265665613185,\n                484544650202821,\n                1238773526575826,\n                2017991917953668,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2581954631514051,\n                1245093644265357,\n                3537016673825374,\n                1834216551713857,\n                923978372152807,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1855378315339552,\n                890045579230758,\n                1764718173975590,\n                197904186055854,\n                1718129022310327,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1278162928734862,\n                1894118254109862,\n                987503995465517,\n                177406744098996,\n                781538103127693,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1996603431230215,\n                1191888797552937,\n                1207440075928499,\n                2765853449051137,\n                2525314961343288,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                808903879370889,\n                990820108751280,\n                1084429472258867,\n                1078562781312589,\n                254514692695625,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                615855140068469,\n                586046731175395,\n                693470779212674,\n                1964537100203868,\n                1350330550265229,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3344544372023708,\n                720386671449874,\n                2480841360702110,\n                2036034126860286,\n                2015744690201389,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1337446193390478,\n                1984110761311871,\n                746489405020285,\n                407347127604128,\n                1740475330360596,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                140840424783613,\n                1063284623568331,\n                1136446106453878,\n                372042229029799,\n                442607248430694,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2330781679120937,\n                376801425148230,\n                2032603686676107,\n                1488926293635130,\n                1317278311532959,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1290116731380016,\n                2166899563471713,\n                831997001838078,\n                870954980505220,\n                2108537278055823,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1912719171026343,\n                846194720551034,\n                2043988124740726,\n                993234269653961,\n                421229796383281,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2651184584992902,\n                2775702557638963,\n                2539786009779572,\n                2575974880015305,\n                2122619079836732,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1154054290132562,\n                931753998725577,\n                1647742001778052,\n                865765466488226,\n                1083816107290025,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                986341121095108,\n                1522330369638573,\n                1990880546211047,\n                501525962272123,\n                198539304862139,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1496414019192687,\n                3991034436173951,\n                3380311659062196,\n                2854747485359158,\n                3346958036643152,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                805612068303425,\n                1891790027761335,\n                1587008567571549,\n                722120737390201,\n                378156757163816,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1588994517921951,\n                977362751042302,\n                1329302387067714,\n                2069348224564088,\n                1586007159625211,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2490539421551682,\n                1985699850375015,\n                2331762317128172,\n                4145097393776678,\n                2521049460190674,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                615817553313996,\n                2245962768078178,\n                482564324326173,\n                2101336843140780,\n                1240914880829407,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1438242482238189,\n                874267817785463,\n                1620810389770625,\n                866155221338671,\n                1040426546798301,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2403083624110300,\n                2548561409802975,\n                2492699136535911,\n                2358289519456539,\n                3203964320363148,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1913986535403097,\n                1977163223054199,\n                1972905914623196,\n                1650122133472502,\n                1905849310819035,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                858174816360838,\n                614595356564037,\n                1099584959044836,\n                636998087084906,\n                1070393269058348,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3666695924830668,\n                3585640662737501,\n                2372994528684236,\n                2628565977288995,\n                3482812783469694,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1994161359147952,\n                2198039369802658,\n                62790022842537,\n                1522306785848169,\n                951223194802833,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                852296621440717,\n                431889737774209,\n                370755457746189,\n                437604073958073,\n                627857326892757,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1794955764684156,\n                2586904290013612,\n                1322647643615887,\n                856117964085888,\n                2652432778663153,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                933592377399646,\n                78031722952813,\n                926049890685253,\n                1471649501316246,\n                33789909190376,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1479319468832059,\n                203906207621608,\n                659828362330083,\n                44358398435755,\n                1273573524210803,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1592342143350813,\n                3227219208247713,\n                2345240352078765,\n                2577750109932929,\n                2933512841197243,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2184946892642995,\n                1517382324576002,\n                1557940277419806,\n                2170635134813213,\n                747314658627002,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1823193620577742,\n                1135817878516419,\n                1731253819308581,\n                1031652967267804,\n                2123506616999453,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1346190246005805,\n                2052692552023851,\n                1718128041785940,\n                2491557332978474,\n                3474370880388305,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                424776012994573,\n                281050757243423,\n                626466040846420,\n                990194703866532,\n                38571969885982,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                192408346595466,\n                1054889725292349,\n                584097975693004,\n                1447909807397749,\n                2134645004369136,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3169895788615063,\n                3503097743181446,\n                601598510029975,\n                1422812237223371,\n                2121009661378329,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1603348391996783,\n                2066143816131699,\n                1789627290363958,\n                2145705961178118,\n                1985578641438222,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                352633958653380,\n                856927627345554,\n                793925083122702,\n                93551575767286,\n                1222010153634215,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1756866499986349,\n                911731956999969,\n                2707505543214075,\n                4006920335263786,\n                822501008147910,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1094036422864347,\n                1897208881572508,\n                1503607738246960,\n                1901060196071406,\n                294068411105729,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                587776484399576,\n                1116861711228807,\n                343398777436088,\n                936544065763093,\n                1643746750211060,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3477749685790410,\n                267997399528836,\n                2953780922004404,\n                3252368924080907,\n                3787792887348381,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2042368155872443,\n                41662387210459,\n                1676313264498480,\n                1333968523426810,\n                1765708383352310,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1453394896690938,\n                1585795827439909,\n                1469309456804303,\n                1294645324464404,\n                2042954198665899,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1810069207599881,\n                1358344669503239,\n                1989371257548167,\n                2316270051121225,\n                3019675451276507,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1866114438287676,\n                1663420339568364,\n                1437691317033088,\n                538298302628038,\n                1212711449614363,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1769235035677897,\n                1562012115317882,\n                31277513664750,\n                536198657928416,\n                1976134212537183,\n            ]),\n        },\n    ]);\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/constants.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65048": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2018 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! The `u64` backend uses `u64`s and a `(u64, u64) -> u128` multiplier.\n//!\n//! On x86_64, the idiom `(x as u128) * (y as u128)` lowers to `MUL`\n//! instructions taking 64-bit inputs and producing 128-bit outputs.  On\n//! other platforms, this implementation is not recommended.\n//!\n//! On Haswell and newer, the BMI2 extension provides `MULX`, and on\n//! Broadwell and newer, the ADX extension provides `ADCX` and `ADOX`\n//! (allowing the CPU to compute two carry chains in parallel).  These\n//! will be used if available.\n\npub mod field;\n\npub mod scalar;\n\npub mod constants;\n\npub mod field_verus;\n\npub mod field_lemmas;\n\npub mod common_verus;\n\npub mod subtle_assumes;\n\npub mod scalar_lemmas;\n\npub mod scalar_specs;\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/mod.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65049": {
    "text": "#[allow(unused_imports)]\nuse super::scalar::Scalar52;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\nuse vstd::prelude::*;\n\nverus! {\npub open spec fn seq_to_nat(limbs: Seq<nat>) -> nat\ndecreases limbs.len()\n{\n    if limbs.len() == 0 {\n        0\n    } else {\n        limbs[0] + seq_to_nat(limbs.subrange(1, limbs.len() as int)) * pow2(52)\n    }\n}\n\npub open spec fn slice128_to_nat(limbs: &[u128]) -> nat\n{\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}\n\npub open spec fn seq_u64_to_nat(limbs: Seq<u64>) -> nat\n{\n    seq_to_nat(limbs.map(|i, x| x as nat))\n}\n\npub open spec fn to_nat(limbs: &[u64]) -> nat\n{\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}\n\npub open spec fn nine_limbs_to_nat_aux(limbs: &[u128; 9]) -> nat {\n    (limbs[0] as nat) +\n    (limbs[1] as nat) * pow2(52) +\n    (limbs[2] as nat) * pow2(104) +\n    (limbs[3] as nat) * pow2(156) +\n    (limbs[4] as nat) * pow2(208) +\n    (limbs[5] as nat) * pow2(260) +\n    (limbs[6] as nat) * pow2(312) +\n    (limbs[7] as nat) * pow2(364) +\n    (limbs[8] as nat) * pow2(416)\n}\n\npub open spec fn five_limbs_to_nat_aux(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(52) * (limbs[1] as nat) +\n    pow2(104) * (limbs[2] as nat) +\n    pow2(156) * (limbs[3] as nat) +\n    pow2(208) * (limbs[4] as nat)\n}\n\n// Modular reduction of to_nat mod L\nspec fn to_scalar(limbs: &[u64; 5]) -> nat {\n    to_nat(limbs) % group_order()\n}\n\n/// natural value of a 256 bit bitstring represented as array of 32 bytes\npub open spec fn bytes_to_nat(bytes: &[u8; 32]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_to_nat_rec(bytes, 0)\n}\n\npub open spec fn bytes_to_nat_rec(bytes: &[u8; 32], index: int) -> nat\ndecreases 32 - index\n{\n    if index >= 32 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_to_nat_rec(bytes, index + 1)\n    }\n}\n\n/// natural value of a 512 bit bitstring represented as array of 64 bytes\npub open spec fn bytes_wide_to_nat(bytes: &[u8; 64]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_wide_to_nat_rec(bytes, 0)\n}\n\npub open spec fn bytes_wide_to_nat_rec(bytes: &[u8; 64], index: int) -> nat\ndecreases 64 - index\n{\n    if index >= 64 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_wide_to_nat_rec(bytes, index + 1)\n    }\n}\n\n// Generic function to convert array of words to natural number\n// Takes: array of words, number of words, bits per word\n// Note: This is a specification function that works with concrete types\npub open spec fn words_to_nat_gen_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u64(words, num_words - 1, bits_per_word)\n    }\n}\n\npub open spec fn words_to_nat_gen_u32(words: &[u32], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u32(words, num_words - 1, bits_per_word)\n    }\n}\n\n// natural value of a 256 bit bitstring represented as an array of 4 words of 64 bits\n// Now implemented using the generic function\npub open spec fn words_to_nat(words: &[u64; 4]) -> nat {\n    words_to_nat_gen_u64(words, 4, 64)\n}\n\n// Group order: the value of L as a natural number\npub open spec fn group_order() -> nat {\n    pow2(252) + 27742317777372353535851937790883648493nat\n}\n\n// Montgomery radix R = 2^260\npub open spec fn montgomery_radix() -> nat {\n    pow2(260)\n}\n\n// Check that all limbs of a Scalar52 are properly bounded (< 2^52)\npub open spec fn limbs_bounded(s: &Scalar52) -> bool {\n    forall|i: int| 0 <= i < 5 ==> s.limbs[i] < (1u64 << 52)\n}\n\n} // verus!\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "filepath": null,
    "folder_id": 16167,
    "user_id": 460160
  },
  "65050": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Scalar multiplication on the Montgomery form of Curve25519.\n//!\n//! To avoid notational confusion with the Edwards code, we use\n//! variables \\\\( u, v \\\\) for the Montgomery curve, so that Montgomery\n//! \\\\(u\\\\) here corresponds to Montgomery \\\\(x\\\\) elsewhere.\n//!\n//! Montgomery arithmetic works not on the curve itself, but on the\n//! \\\\(u\\\\)-line, which discards sign information and unifies the curve\n//! and its quadratic twist.  See [_Montgomery curves and their\n//! arithmetic_][costello-smith] by Costello and Smith for more details.\n//!\n//! The `MontgomeryPoint` struct contains the affine \\\\(u\\\\)-coordinate\n//! \\\\(u\\_0(P)\\\\) of a point \\\\(P\\\\) on either the curve or the twist.\n//! Here the map \\\\(u\\_0 : \\mathcal M \\rightarrow \\mathbb F\\_p \\\\) is\n//! defined by \\\\(u\\_0((u,v)) = u\\\\); \\\\(u\\_0(\\mathcal O) = 0\\\\).  See\n//! section 5.4 of Costello-Smith for more details.\n//!\n//! # Scalar Multiplication\n//!\n//! Scalar multiplication on `MontgomeryPoint`s is provided by the `*`\n//! operator, which implements the Montgomery ladder.\n//!\n//! # Edwards Conversion\n//!\n//! The \\\\(2\\\\)-to-\\\\(1\\\\) map from the Edwards model to the Montgomery\n//! \\\\(u\\\\)-line is provided by `EdwardsPoint::to_montgomery()`.\n//!\n//! To lift a `MontgomeryPoint` to an `EdwardsPoint`, use\n//! `MontgomeryPoint::to_edwards()`, which takes a sign parameter.\n//! This function rejects `MontgomeryPoints` which correspond to points\n//! on the twist.\n//!\n//! [costello-smith]: https://eprint.iacr.org/2017/212.pdf\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nuse core::{\n    hash::{Hash, Hasher},\n    ops::{Mul, MulAssign},\n};\n\nuse crate::constants::{APLUS2_OVER_FOUR, MONTGOMERY_A, MONTGOMERY_A_NEG};\nuse crate::edwards::{CompressedEdwardsY, EdwardsPoint};\nuse crate::field::FieldElement;\nuse crate::scalar::{Scalar, clamp_integer};\n\nuse crate::traits::Identity;\n\nuse subtle::Choice;\nuse subtle::ConstantTimeEq;\nuse subtle::{ConditionallyNegatable, ConditionallySelectable};\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::Zeroize;\n\n/// Holds the \\\\(u\\\\)-coordinate of a point on the Montgomery form of\n/// Curve25519 or its twist.\n#[derive(Copy, Clone, Debug, Default)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct MontgomeryPoint(pub [u8; 32]);\n\n/// Equality of `MontgomeryPoint`s is defined mod p.\nimpl ConstantTimeEq for MontgomeryPoint {\n    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }\n}\n\nimpl ConditionallySelectable for MontgomeryPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(<[u8; 32]>::conditional_select(&a.0, &b.0, choice))\n    }\n}\n\nimpl PartialEq for MontgomeryPoint {\n    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for MontgomeryPoint {}\n\n// Equal MontgomeryPoints must hash to the same value. So we have to get them into a canonical\n// encoding first\nimpl Hash for MontgomeryPoint {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        // Do a round trip through a `FieldElement`. `as_bytes` is guaranteed to give a canonical\n        // 32-byte encoding\n        let canonical_bytes = FieldElement::from_bytes(&self.0).to_bytes();\n        canonical_bytes.hash(state);\n    }\n}\n\nimpl Identity for MontgomeryPoint {\n    /// Return the group identity element, which has order 4.\n    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }\n}\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for MontgomeryPoint {\n//     fn zeroize(&mut self) {\n//         self.0.zeroize();\n//     }\n// }\n\nimpl MontgomeryPoint {\n    /// Fixed-base scalar multiplication (i.e. multiplication by the base point).\n    pub fn mul_base(scalar: &Scalar) -> Self {\n        EdwardsPoint::mul_base(scalar).to_montgomery()\n    }\n\n    /// Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }\n\n    /// Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }\n\n    /// Given `self` \\\\( = u\\_0(P) \\\\), and a big-endian bit representation of an integer\n    /// \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\). This is constant time in the length of `bits`.\n    ///\n    /// **NOTE:** You probably do not want to use this function. Almost every protocol built on\n    /// Curve25519 uses _clamped multiplication_, explained\n    /// [here](https://neilmadden.blog/2020/05/28/whats-the-curve25519-clamping-all-about/).\n    /// When in doubt, use [`Self::mul_clamped`].\n    pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2\n        let mut prev_bit = false;\n        for cur_bit in bits {\n            let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        // #[cfg(feature = \"zeroize\")]\n        // prev_bit.zeroize();\n\n        x0.as_affine()\n    }\n\n    /// View this `MontgomeryPoint` as an array of bytes.\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n\n    /// Convert this `MontgomeryPoint` to an array of bytes.\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// Attempt to convert to an `EdwardsPoint`, using the supplied\n    /// choice of sign for the `EdwardsPoint`.\n    ///\n    /// # Inputs\n    ///\n    /// * `sign`: a `u8` donating the desired sign of the resulting\n    ///   `EdwardsPoint`.  `0` denotes positive and `1` negative.\n    ///\n    /// # Return\n    ///\n    /// * `Some(EdwardsPoint)` if `self` is the \\\\(u\\\\)-coordinate of a\n    ///   point on (the Montgomery form of) Curve25519;\n    ///\n    /// * `None` if `self` is the \\\\(u\\\\)-coordinate of a point on the\n    ///   twist of (the Montgomery form of) Curve25519;\n    ///\n    pub fn to_edwards(&self, sign: u8) -> Option<EdwardsPoint> {\n        // To decompress the Montgomery u coordinate to an\n        // `EdwardsPoint`, we apply the birational map to obtain the\n        // Edwards y coordinate, then do Edwards decompression.\n        //\n        // The birational map is y = (u-1)/(u+1).\n        //\n        // The exceptional points are the zeros of the denominator,\n        // i.e., u = -1.\n        //\n        // But when u = -1, v^2 = u*(u^2+486662*u+1) = 486660.\n        //\n        // Since this is nonsquare mod p, u = -1 corresponds to a point\n        // on the twist, not the curve, so we can reject it early.\n\n        let u = FieldElement::from_bytes(&self.0);\n\n        if u == FieldElement::MINUS_ONE {\n            return None;\n        }\n\n        let one = FieldElement::ONE;\n\n        let y = &(&u - &one) * &(&u + &one).invert();\n\n        let mut y_bytes = y.to_bytes();\n        y_bytes[31] ^= sign << 7;\n\n        CompressedEdwardsY(y_bytes).decompress()\n    }\n}\n\n/// Perform the Elligator2 mapping to a Montgomery point. Returns a Montgomery point and a `Choice`\n/// determining whether eps is a square. This is required by the standard to determine the\n/// sign of the v coordinate.\n///\n/// See <https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method>\n//\n#[allow(unused)]\npub(crate) fn elligator_encode(r_0: &FieldElement) -> (MontgomeryPoint, Choice) {\n    let one = FieldElement::ONE;\n    let d_1 = &one + &r_0.square2(); /* 2r^2 */\n\n    let d = &MONTGOMERY_A_NEG * &(d_1.invert()); /* A/(1+2r^2) */\n\n    let d_sq = &d.square();\n    let au = &MONTGOMERY_A * &d;\n\n    let inner = &(d_sq + &au) + &one;\n    let eps = &d * &inner; /* eps = d^3 + Ad^2 + d */\n\n    let (eps_is_sq, _eps) = FieldElement::sqrt_ratio_i(&eps, &one);\n\n    let zero = FieldElement::ZERO;\n    let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/\n    let mut u = &d + &Atemp; /* d, or d+A if nonsquare */\n    u.conditional_negate(!eps_is_sq); /* d, or -d-A if nonsquare */\n\n    (MontgomeryPoint(u.to_bytes()), eps_is_sq)\n}\n\n/// A `ProjectivePoint` holds a point on the projective line\n/// \\\\( \\mathbb P(\\mathbb F\\_p) \\\\), which we identify with the Kummer\n/// line of the Montgomery curve.\n#[derive(Copy, Clone, Debug)]\nstruct ProjectivePoint {\n    pub U: FieldElement,\n    pub W: FieldElement,\n}\n\nimpl Identity for ProjectivePoint {\n    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for ProjectivePoint {\n    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }\n}\n\nimpl ConditionallySelectable for ProjectivePoint {\n    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }\n}\n\nimpl ProjectivePoint {\n    /// Dehomogenize this point to affine coordinates.\n    ///\n    /// # Return\n    ///\n    /// * \\\\( u = U / W \\\\) if \\\\( W \\neq 0 \\\\);\n    /// * \\\\( 0 \\\\) if \\\\( W \\eq 0 \\\\);\n    pub fn as_affine(&self) -> MontgomeryPoint {\n        let u = &self.U * &self.W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }\n}\n\n/// Perform the double-and-add step of the Montgomery ladder.\n///\n/// Given projective points\n/// \\\\( (U\\_P : W\\_P) = u(P) \\\\),\n/// \\\\( (U\\_Q : W\\_Q) = u(Q) \\\\),\n/// and the affine difference\n/// \\\\(      u\\_{P-Q} = u(P-Q) \\\\), set\n/// $$\n///     (U\\_P : W\\_P) \\gets u(\\[2\\]P)\n/// $$\n/// and\n/// $$\n///     (U\\_Q : W\\_Q) \\gets u(P + Q).\n/// $$\n#[rustfmt::skip] // keep alignment of explanatory comments\nfn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = &P.U + &P.W;\n    let t1 = &P.U - &P.W;\n    let t2 = &Q.U + &Q.W;\n    let t3 = &Q.U - &Q.W;\n\n    let t4 = t0.square();   // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square();   // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = &t4 - &t5;     // 4 U_P W_P\n\n    let t7 = &t0 * &t3;     // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = &t1 * &t2;     // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9  = &t7 + &t8;    // 2 (U_P U_Q - W_P W_Q)\n    let t10 = &t7 - &t8;    // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 =  t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n\n    let t13 = &APLUS2_OVER_FOUR * &t6; // (A + 2) U_P U_Q\n\n    let t14 = &t4 * &t5;    // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = &t13 + &t5;   // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = &t6 * &t15;   // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n\n    let t17 = affine_PmQ * &t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11;               // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14;  // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16;  // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18;  // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17;  // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}\n\ndefine_mul_assign_variants!(LHS = MontgomeryPoint, RHS = Scalar);\n\ndefine_mul_variants!(\n    LHS = MontgomeryPoint,\n    RHS = Scalar,\n    Output = MontgomeryPoint\n);\ndefine_mul_variants!(\n    LHS = Scalar,\n    RHS = MontgomeryPoint,\n    Output = MontgomeryPoint\n);\n\n/// Multiply this `MontgomeryPoint` by a `Scalar`.\nimpl Mul<&Scalar> for &MontgomeryPoint {\n    type Output = MontgomeryPoint;\n\n    /// Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)\n    fn mul(self, scalar: &Scalar) -> MontgomeryPoint {\n        // We multiply by the integer representation of the given Scalar. By scalar invariant #1,\n        // the MSB is 0, so we can skip it.\n        self.mul_bits_be(scalar.bits_le().rev().skip(1))\n    }\n}\n\nimpl MulAssign<&Scalar> for MontgomeryPoint {\n    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }\n}\n\nimpl Mul<&MontgomeryPoint> for &Scalar {\n    type Output = MontgomeryPoint;\n\n    fn mul(self, point: &MontgomeryPoint) -> MontgomeryPoint {\n        point * self\n    }\n}\n\n// ------------------------------------------------------------------------\n// Tests\n// ------------------------------------------------------------------------\n\n// #[cfg(test)]\n// mod test {\n//     use super::*;\n//     use crate::constants;\n\n//     #[cfg(feature = \"alloc\")]\n//     use alloc::vec::Vec;\n\n//     use rand_core::{CryptoRng, RngCore, TryRngCore};\n\n//     #[test]\n//     fn identity_in_different_coordinates() {\n//         let id_projective = ProjectivePoint::identity();\n//         let id_montgomery = id_projective.as_affine();\n\n//         assert!(id_montgomery == MontgomeryPoint::identity());\n//     }\n\n//     #[test]\n//     fn identity_in_different_models() {\n//         assert!(EdwardsPoint::identity().to_montgomery() == MontgomeryPoint::identity());\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"serde\")]\n//     fn serde_bincode_basepoint_roundtrip() {\n//         use bincode;\n\n//         let encoded = bincode::serialize(&constants::X25519_BASEPOINT).unwrap();\n//         let decoded: MontgomeryPoint = bincode::deserialize(&encoded).unwrap();\n\n//         assert_eq!(encoded.len(), 32);\n//         assert_eq!(decoded, constants::X25519_BASEPOINT);\n\n//         let raw_bytes = constants::X25519_BASEPOINT.as_bytes();\n//         let bp: MontgomeryPoint = bincode::deserialize(raw_bytes).unwrap();\n//         assert_eq!(bp, constants::X25519_BASEPOINT);\n//     }\n\n//     /// Test Montgomery -> Edwards on the X/Ed25519 basepoint\n//     #[test]\n//     fn basepoint_montgomery_to_edwards() {\n//         // sign bit = 0 => basepoint\n//         assert_eq!(\n//             constants::ED25519_BASEPOINT_POINT,\n//             constants::X25519_BASEPOINT.to_edwards(0).unwrap()\n//         );\n//         // sign bit = 1 => minus basepoint\n//         assert_eq!(\n//             -constants::ED25519_BASEPOINT_POINT,\n//             constants::X25519_BASEPOINT.to_edwards(1).unwrap()\n//         );\n//     }\n\n//     /// Test Edwards -> Montgomery on the X/Ed25519 basepoint\n//     #[test]\n//     fn basepoint_edwards_to_montgomery() {\n//         assert_eq!(\n//             constants::ED25519_BASEPOINT_POINT.to_montgomery(),\n//             constants::X25519_BASEPOINT\n//         );\n//     }\n\n//     /// Check that Montgomery -> Edwards fails for points on the twist.\n//     #[test]\n//     fn montgomery_to_edwards_rejects_twist() {\n//         let one = FieldElement::ONE;\n\n//         // u = 2 corresponds to a point on the twist.\n//         let two = MontgomeryPoint((&one + &one).to_bytes());\n\n//         assert!(two.to_edwards(0).is_none());\n\n//         // u = -1 corresponds to a point on the twist, but should be\n//         // checked explicitly because it's an exceptional point for the\n//         // birational map.  For instance, libsignal will accept it.\n//         let minus_one = MontgomeryPoint((-&one).to_bytes());\n\n//         assert!(minus_one.to_edwards(0).is_none());\n//     }\n\n//     #[test]\n//     fn eq_defined_mod_p() {\n//         let mut u18_bytes = [0u8; 32];\n//         u18_bytes[0] = 18;\n//         let u18 = MontgomeryPoint(u18_bytes);\n//         let u18_unred = MontgomeryPoint([255; 32]);\n\n//         assert_eq!(u18, u18_unred);\n//     }\n\n//     /// Returns a random point on the prime-order subgroup\n//     fn rand_prime_order_point<R: CryptoRng + ?Sized>(rng: &mut R) -> EdwardsPoint {\n//         let s: Scalar = Scalar::random(rng);\n//         EdwardsPoint::mul_base(&s)\n//     }\n\n//     /// Given a bytestring that's little-endian at the byte level, return an iterator over all the\n//     /// bits, in little-endian order.\n//     fn bytestring_bits_le(x: &[u8]) -> impl DoubleEndedIterator<Item = bool> + Clone + '_ {\n//         let bitlen = x.len() * 8;\n//         (0..bitlen).map(|i| {\n//             // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n//             // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n//             // little-endian on the bit level\n//             ((x[i >> 3] >> (i & 7)) & 1u8) == 1\n//         })\n//     }\n\n//     #[test]\n//     fn montgomery_ladder_matches_edwards_scalarmult() {\n//         let mut csprng = rand_core::OsRng.unwrap_err();\n\n//         for _ in 0..100 {\n//             let p_edwards = rand_prime_order_point(&mut csprng);\n//             let p_montgomery: MontgomeryPoint = p_edwards.to_montgomery();\n\n//             let s: Scalar = Scalar::random(&mut csprng);\n//             let expected = s * p_edwards;\n//             let result = s * p_montgomery;\n\n//             assert_eq!(result, expected.to_montgomery())\n//         }\n//     }\n\n//     // Tests that, on the prime-order subgroup, MontgomeryPoint::mul_bits_be is the same as\n//     // multiplying by the Scalar representation of the same bits\n//     #[test]\n//     fn montgomery_mul_bits_be() {\n//         let mut csprng = rand_core::OsRng.unwrap_err();\n\n//         for _ in 0..100 {\n//             // Make a random prime-order point P\n//             let p_edwards = rand_prime_order_point(&mut csprng);\n//             let p_montgomery: MontgomeryPoint = p_edwards.to_montgomery();\n\n//             // Make a random integer b\n//             let mut bigint = [0u8; 64];\n//             csprng.fill_bytes(&mut bigint[..]);\n//             let bigint_bits_be = bytestring_bits_le(&bigint).rev();\n\n//             // Check that bP is the same whether calculated as scalar-times-edwards or\n//             // integer-times-montgomery.\n//             let expected = Scalar::from_bytes_mod_order_wide(&bigint) * p_edwards;\n//             let result = p_montgomery.mul_bits_be(bigint_bits_be);\n//             assert_eq!(result, expected.to_montgomery())\n//         }\n//     }\n\n//     // Tests that MontgomeryPoint::mul_bits_be is consistent on any point, even ones that might be\n//     // on the curve's twist. Specifically, this tests that b(bP) == b(bP) for random\n//     // integers b, b and random (curve or twist) point P.\n//     #[test]\n//     fn montgomery_mul_bits_be_twist() {\n//         let mut csprng = rand_core::OsRng.unwrap_err();\n\n//         for _ in 0..100 {\n//             // Make a random point P on the curve or its twist\n//             let p_montgomery = {\n//                 let mut buf = [0u8; 32];\n//                 csprng.fill_bytes(&mut buf);\n//                 MontgomeryPoint(buf)\n//             };\n\n//             // Compute two big integers b and b\n//             let mut bigint1 = [0u8; 64];\n//             let mut bigint2 = [0u8; 64];\n//             csprng.fill_bytes(&mut bigint1[..]);\n//             csprng.fill_bytes(&mut bigint2[..]);\n\n//             // Compute bP and bP\n//             let bigint1_bits_be = bytestring_bits_le(&bigint1).rev();\n//             let bigint2_bits_be = bytestring_bits_le(&bigint2).rev();\n//             let prod1 = p_montgomery.mul_bits_be(bigint1_bits_be.clone());\n//             let prod2 = p_montgomery.mul_bits_be(bigint2_bits_be.clone());\n\n//             // Check that b(bP) == b(bP)\n//             assert_eq!(\n//                 prod1.mul_bits_be(bigint2_bits_be),\n//                 prod2.mul_bits_be(bigint1_bits_be)\n//             );\n//         }\n//     }\n\n//     /// Check that mul_base_clamped and mul_clamped agree\n//     #[test]\n//     fn mul_base_clamped() {\n//         let mut csprng = rand_core::OsRng;\n\n//         // Test agreement on a large integer. Even after clamping, this is not reduced mod l.\n//         let a_bytes = [0xff; 32];\n//         assert_eq!(\n//             MontgomeryPoint::mul_base_clamped(a_bytes),\n//             constants::X25519_BASEPOINT.mul_clamped(a_bytes)\n//         );\n\n//         // Test agreement on random integers\n//         for _ in 0..100 {\n//             // This will be reduced mod l with probability l / 2^256  6.25%\n//             let mut a_bytes = [0u8; 32];\n//             csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n//             assert_eq!(\n//                 MontgomeryPoint::mul_base_clamped(a_bytes),\n//                 constants::X25519_BASEPOINT.mul_clamped(a_bytes)\n//             );\n//         }\n//     }\n\n//     #[cfg(feature = \"alloc\")]\n//     const ELLIGATOR_CORRECT_OUTPUT: [u8; 32] = [\n//         0x5f, 0x35, 0x20, 0x00, 0x1c, 0x6c, 0x99, 0x36, 0xa3, 0x12, 0x06, 0xaf, 0xe7, 0xc7, 0xac,\n//         0x22, 0x4e, 0x88, 0x61, 0x61, 0x9b, 0xf9, 0x88, 0x72, 0x44, 0x49, 0x15, 0x89, 0x9d, 0x95,\n//         0xf4, 0x6e,\n//     ];\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn montgomery_elligator_correct() {\n//         let bytes: Vec<u8> = (0u8..32u8).collect();\n//         let bits_in: [u8; 32] = (&bytes[..]).try_into().expect(\"Range invariant broken\");\n\n//         let fe = FieldElement::from_bytes(&bits_in);\n//         let (eg, _) = elligator_encode(&fe);\n//         assert_eq!(eg.to_bytes(), ELLIGATOR_CORRECT_OUTPUT);\n//     }\n\n//     #[test]\n//     fn montgomery_elligator_zero_zero() {\n//         let zero = [0u8; 32];\n//         let fe = FieldElement::from_bytes(&zero);\n//         let (eg, _) = elligator_encode(&fe);\n//         assert_eq!(eg.to_bytes(), zero);\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/montgomery.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65051": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2020 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Group operations for Curve25519, in Edwards form.\n//!\n//! ## Encoding and Decoding\n//!\n//! Encoding is done by converting to and from a `CompressedEdwardsY`\n//! struct, which is a typed wrapper around `[u8; 32]`.\n//!\n//! ## Equality Testing\n//!\n//! The `EdwardsPoint` struct implements the [`subtle::ConstantTimeEq`]\n//! trait for constant-time equality checking, and also uses this to\n//! ensure `Eq` equality checking runs in constant time.\n//!\n//! ## Cofactor-related functions\n//!\n//! The order of the group of points on the curve \\\\(\\mathcal E\\\\)\n//! is \\\\(|\\mathcal E| = 8\\ell \\\\), so its structure is \\\\( \\mathcal\n//! E = \\mathcal E\\[8\\] \\times \\mathcal E[\\ell]\\\\).  The torsion\n//! subgroup \\\\( \\mathcal E\\[8\\] \\\\) consists of eight points of small\n//! order.  Technically, all of \\\\(\\mathcal E\\\\) is torsion, but we\n//! use the word only to refer to the small \\\\(\\mathcal E\\[8\\]\\\\) part, not\n//! the large prime-order \\\\(\\mathcal E[\\ell]\\\\) part.\n//!\n//! To test if a point is in \\\\( \\mathcal E\\[8\\] \\\\), use\n//! [`EdwardsPoint::is_small_order`].\n//!\n//! To test if a point is in \\\\( \\mathcal E[\\ell] \\\\), use\n//! [`EdwardsPoint::is_torsion_free`].\n//!\n//! To multiply by the cofactor, use [`EdwardsPoint::mul_by_cofactor`].\n//!\n//! To avoid dealing with cofactors entirely, consider using Ristretto.\n//!\n//! ## Scalars\n//!\n//! Scalars are represented by the [`Scalar`] struct. To construct a scalar, see\n//! [`Scalar::from_canonical_bytes`] or [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! ## Scalar Multiplication\n//!\n//! Scalar multiplication on Edwards points is provided by:\n//!\n//! * the `*` operator between a `Scalar` and a `EdwardsPoint`, which\n//!   performs constant-time variable-base scalar multiplication;\n//!\n//! * the `*` operator between a `Scalar` and a\n//!   `EdwardsBasepointTable`, which performs constant-time fixed-base\n//!   scalar multiplication;\n//!\n//! * an implementation of the\n//!   [`MultiscalarMul`](../traits/trait.MultiscalarMul.html) trait for\n//!   constant-time variable-base multiscalar multiplication;\n//!\n//! * an implementation of the\n//!   [`VartimeMultiscalarMul`](../traits/trait.VartimeMultiscalarMul.html)\n//!   trait for variable-time variable-base multiscalar multiplication;\n//!\n//! ## Implementation\n//!\n//! The Edwards arithmetic is implemented using the extended twisted\n//! coordinates of Hisil, Wong, Carter, and Dawson, and the\n//! corresponding complete formulas.  For more details,\n//! see the [`curve_models` submodule][curve_models]\n//! of the internal documentation.\n//!\n//! ## Validity Checking\n//!\n//! There is no function for checking whether a point is valid.\n//! Instead, the `EdwardsPoint` struct is guaranteed to hold a valid\n//! point on the curve.\n//!\n//! We use the Rust type system to make invalid points\n//! unrepresentable: `EdwardsPoint` objects can only be created via\n//! successful decompression of a compressed point, or else by\n//! operations on other (valid) `EdwardsPoint`s.\n//!\n//! [curve_models]: https://docs.rs/curve25519-dalek/latest/curve25519-dalek/backend/serial/curve_models/index.html\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nmod affine;\n\nuse cfg_if::cfg_if;\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};\nuse core::ops::{Mul, MulAssign};\n\n// #[cfg(feature = \"digest\")]\n// use digest::{\n//     FixedOutput, HashMarker, array::typenum::U64, consts::True, crypto_common::BlockSizeUser,\n//     typenum::IsGreater,\n// };\n\n#[cfg(feature = \"group\")]\nuse {\n    group::{GroupEncoding, cofactor::CofactorGroup, prime::PrimeGroup},\n    rand_core::TryRngCore,\n    subtle::CtOption,\n};\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::RngCore;\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::Zeroize;\n\nuse crate::constants;\n\nuse crate::field::FieldElement;\nuse crate::scalar::{Scalar, clamp_integer};\n\nuse crate::montgomery::MontgomeryPoint;\n\nuse crate::backend::serial::curve_models::AffineNielsPoint;\nuse crate::backend::serial::curve_models::CompletedPoint;\nuse crate::backend::serial::curve_models::ProjectiveNielsPoint;\nuse crate::backend::serial::curve_models::ProjectivePoint;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::window::{\n    LookupTableRadix16, LookupTableRadix32, LookupTableRadix64, LookupTableRadix128,\n    LookupTableRadix256,\n};\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::traits::BasepointTable;\n\nuse crate::traits::ValidityCheck;\nuse crate::traits::{Identity, IsIdentity};\n\nuse affine::AffinePoint;\n\n#[cfg(feature = \"alloc\")]\nuse crate::traits::MultiscalarMul;\n#[cfg(feature = \"alloc\")]\nuse crate::traits::{VartimeMultiscalarMul, VartimePrecomputedMultiscalarMul};\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\n// ------------------------------------------------------------------------\n// Compressed points\n// ------------------------------------------------------------------------\n\n/// In \"Edwards y\" / \"Ed25519\" format, the curve point \\\\((x,y)\\\\) is\n/// determined by the \\\\(y\\\\)-coordinate and the sign of \\\\(x\\\\).\n///\n/// The first 255 bits of a `CompressedEdwardsY` represent the\n/// \\\\(y\\\\)-coordinate.  The high bit of the 32nd byte gives the sign of \\\\(x\\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct CompressedEdwardsY(pub [u8; 32]);\n\nimpl ConstantTimeEq for CompressedEdwardsY {\n    fn ct_eq(&self, other: &CompressedEdwardsY) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }\n}\n\nimpl Eq for CompressedEdwardsY {}\nimpl PartialEq for CompressedEdwardsY {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Debug for CompressedEdwardsY {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }\n}\n\nimpl CompressedEdwardsY {\n    /// View this `CompressedEdwardsY` as an array of bytes.\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n\n    /// Copy this `CompressedEdwardsY` to an array of bytes.\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// Attempt to decompress to an `EdwardsPoint`.\n    ///\n    /// Returns `None` if the input is not the \\\\(y\\\\)-coordinate of a\n    /// curve point.\n    pub fn decompress(&self) -> Option<EdwardsPoint> {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        if is_valid_y_coord.into() {\n            Some(decompress::step_2(self, X, Y, Z))\n        } else {\n            None\n        }\n    }\n}\n\nmod decompress {\n    use super::*;\n\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }\n\n    #[rustfmt::skip]\n    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> EdwardsPoint {\n         // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n         // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n        X.conditional_negate(compressed_sign_bit);\n\n        EdwardsPoint {\n            X,\n            Y,\n            Z,\n            T: &X * &Y,\n        }\n    }\n}\n\nimpl TryFrom<&[u8]> for CompressedEdwardsY {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Serde support\n// ------------------------------------------------------------------------\n// Serializes to and from `EdwardsPoint` directly, doing compression\n// and decompression internally.  This means that users can create\n// structs containing `EdwardsPoint`s and use Serde's derived\n// serializers to serialize those structures.\n\n// #[cfg(feature = \"digest\")]\n// use constants::ED25519_SQRTAM2;\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for EdwardsPoint {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.compress().as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for CompressedEdwardsY {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for EdwardsPoint {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct EdwardsPointVisitor;\n\n        impl<'de> Visitor<'de> for EdwardsPointVisitor {\n            type Value = EdwardsPoint;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"a valid point in Edwards y + sign format\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<EdwardsPoint, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                CompressedEdwardsY(bytes)\n                    .decompress()\n                    .ok_or_else(|| serde::de::Error::custom(\"decompression failed\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, EdwardsPointVisitor)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for CompressedEdwardsY {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct CompressedEdwardsYVisitor;\n\n        impl<'de> Visitor<'de> for CompressedEdwardsYVisitor {\n            type Value = CompressedEdwardsY;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"32 bytes of data\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<CompressedEdwardsY, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Ok(CompressedEdwardsY(bytes))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, CompressedEdwardsYVisitor)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Internal point representations\n// ------------------------------------------------------------------------\n\n/// An `EdwardsPoint` represents a point on the Edwards form of Curve25519.\n#[derive(Copy, Clone)]\n#[allow(missing_docs)]\npub struct EdwardsPoint {\n    pub(crate) X: FieldElement,\n    pub(crate) Y: FieldElement,\n    pub(crate) Z: FieldElement,\n    pub(crate) T: FieldElement,\n}\n\n// ------------------------------------------------------------------------\n// Constructors\n// ------------------------------------------------------------------------\n\nimpl Identity for CompressedEdwardsY {\n    fn identity() -> CompressedEdwardsY {\n        CompressedEdwardsY([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ])\n    }\n}\n\nimpl Default for CompressedEdwardsY {\n    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }\n}\n\nimpl CompressedEdwardsY {\n    /// Construct a `CompressedEdwardsY` from a slice of bytes.\n    ///\n    /// # Errors\n    ///\n    /// Returns [`TryFromSliceError`] if the input `bytes` slice does not have\n    /// a length of 32.\n    pub fn from_slice(bytes: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        bytes.try_into().map(CompressedEdwardsY)\n    }\n}\n\nimpl Identity for EdwardsPoint {\n    fn identity() -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for EdwardsPoint {\n    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Zeroize implementations for wiping points from memory\n// ------------------------------------------------------------------------\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for CompressedEdwardsY {\n//     /// Reset this `CompressedEdwardsY` to the compressed form of the identity element.\n//     fn zeroize(&mut self) {\n//         self.0.zeroize();\n//         self.0[0] = 1;\n//     }\n// }\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for EdwardsPoint {\n//     /// Reset this `EdwardsPoint` to the identity element.\n//     fn zeroize(&mut self) {\n//         self.X.zeroize();\n//         self.Y = FieldElement::ONE;\n//         self.Z = FieldElement::ONE;\n//         self.T.zeroize();\n//     }\n// }\n\n// ------------------------------------------------------------------------\n// Validity checks (for debugging, not CT)\n// ------------------------------------------------------------------------\n\nimpl ValidityCheck for EdwardsPoint {\n    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }\n}\n\n// ------------------------------------------------------------------------\n// Constant-time assignment\n// ------------------------------------------------------------------------\n\nimpl ConditionallySelectable for EdwardsPoint {\n    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Equality\n// ------------------------------------------------------------------------\n\nimpl ConstantTimeEq for EdwardsPoint {\n    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }\n}\n\nimpl PartialEq for EdwardsPoint {\n    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for EdwardsPoint {}\n\n// ------------------------------------------------------------------------\n// Point conversions\n// ------------------------------------------------------------------------\n\nimpl EdwardsPoint {\n    /// Convert to a ProjectiveNielsPoint\n    pub(crate) fn as_projective_niels(&self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: &self.Y + &self.X,\n            Y_minus_X: &self.Y - &self.X,\n            Z: self.Z,\n            T2d: &self.T * &constants::EDWARDS_D2,\n        }\n    }\n\n    /// Convert the representation of this point from extended\n    /// coordinates to projective coordinates.\n    ///\n    /// Free.\n    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n        }\n    }\n\n    /// Dehomogenize to a `AffineNielsPoint`.\n    /// Mainly for testing.\n    pub(crate) fn as_affine_niels(&self) -> AffineNielsPoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let xy2d = &(&x * &y) * &constants::EDWARDS_D2;\n        AffineNielsPoint {\n            y_plus_x: &y + &x,\n            y_minus_x: &y - &x,\n            xy2d,\n        }\n    }\n\n    /// Dehomogenize to `AffinePoint`.\n    pub(crate) fn to_affine(self) -> AffinePoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        AffinePoint { x, y }\n    }\n\n    /// Convert this `EdwardsPoint` on the Edwards model to the\n    /// corresponding `MontgomeryPoint` on the Montgomery model.\n    ///\n    /// This function has one exceptional case; the identity point of\n    /// the Edwards curve is sent to the 2-torsion point \\\\((0,0)\\\\)\n    /// on the Montgomery curve.\n    ///\n    /// Note that this is a one-way conversion, since the Montgomery\n    /// model does not retain sign information.\n    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        let u = &U * &W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }\n\n    /// Converts a large batch of points to Edwards at once. This has the same\n    /// behavior on identity elements as [`Self::to_montgomery`].\n    #[cfg(feature = \"alloc\")]\n    pub fn to_montgomery_batch(eds: &[Self]) -> Vec<MontgomeryPoint> {\n        // Do the same thing as the above function. u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        // We will do this in a batch, ie compute (Z-Y) for all the input\n        // points, then invert them all at once\n\n        // Compute the denominators in a batch\n        let mut denominators = eds.iter().map(|p| &p.Z - &p.Y).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut denominators);\n\n        // Now compute the Montgomery u coordinate for every point\n        let mut ret = Vec::with_capacity(eds.len());\n        for (ed, d) in eds.iter().zip(denominators.iter()) {\n            let u = &(&ed.Z + &ed.Y) * d;\n            ret.push(MontgomeryPoint(u.to_bytes()));\n        }\n\n        ret\n    }\n\n    /// Compress this point to `CompressedEdwardsY` format.\n    pub fn compress(&self) -> CompressedEdwardsY {\n        self.to_affine().compress()\n    }\n\n    /// Compress several `EdwardsPoint`s into `CompressedEdwardsY` format, using a batch inversion\n    /// for a significant speedup.\n    #[cfg(feature = \"alloc\")]\n    pub fn compress_batch(inputs: &[EdwardsPoint]) -> Vec<CompressedEdwardsY> {\n        let mut zs = inputs.iter().map(|input| input.Z).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut zs);\n\n        inputs\n            .iter()\n            .zip(&zs)\n            .map(|(input, recip)| {\n                let x = &input.X * recip;\n                let y = &input.Y * recip;\n                AffinePoint { x, y }.compress()\n            })\n            .collect()\n    }\n\n    // #[cfg(feature = \"digest\")]\n    // /// Perform hashing to curve, with explicit hash function and domain separator, `domain_sep`,\n    // /// using the suite `edwards25519_XMD:SHA-512_ELL2_NU_`. The input is the concatenation of the\n    // /// elements of `bytes`. Likewise for the domain separator with `domain_sep`. At least one\n    // /// element of `domain_sep`, MUST be nonempty, and the concatenation MUST NOT exceed\n    // /// 255 bytes.\n    // ///\n    // /// # Panics\n    // /// Panics if `domain_sep.collect().len() == 0` or `> 255`\n    // pub fn hash_to_curve<D>(bytes: &[&[u8]], domain_sep: &[&[u8]]) -> EdwardsPoint\n    // where\n    //     D: BlockSizeUser + Default + FixedOutput<OutputSize = U64> + HashMarker,\n    //     D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    // {\n    //     // For reference see\n    //     // https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method-2\n\n    //     let fe = FieldElement::hash_to_field::<D>(bytes, domain_sep);\n    //     let (M1, is_sq) = crate::montgomery::elligator_encode(&fe);\n\n    //     // The `to_edwards` conversion we're performing takes as input the sign of the Edwards\n    //     // `y` coordinate. However, the specification uses `is_sq` to determine the sign of the\n    //     // Montgomery `v` coordinate. Our approach reconciles this mismatch as follows:\n    //     //\n    //     // * We arbitrarily fix the sign of the Edwards `y` coordinate (we choose 0).\n    //     // * Using the Montgomery `u` coordinate and the Edwards `X` coordinate, we recover `v`.\n    //     // * We verify that the sign of `v` matches the expected one, i.e., `is_sq == mont_v.is_negative()`.\n    //     // * If it does not match, we conditionally negate to correct the sign.\n    //     //\n    //     // Note: This logic aligns with the RFC draft specification:\n    //     //     https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method-2\n    //     // followed by the mapping\n    //     //     https://www.rfc-editor.org/rfc/rfc9380.html#name-mappings-for-twisted-edward\n    //     // The only difference is that our `elligator_encode` returns only the Montgomery `u` coordinate,\n    //     // so we apply this workaround to reconstruct and validate the sign.\n\n    //     let mut E1_opt = M1\n    //         .to_edwards(0)\n    //         .expect(\"Montgomery conversion to Edwards point in Elligator failed\");\n\n    //     // Now we recover v, to ensure that we got the sign right.\n    //     let mont_v =\n    //         &(&ED25519_SQRTAM2 * &FieldElement::from_bytes(&M1.to_bytes())) * &E1_opt.X.invert();\n    //     E1_opt.X.conditional_negate(is_sq ^ mont_v.is_negative());\n    //     E1_opt.mul_by_cofactor()\n    // }\n\n    /// Return an `EdwardsPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `RngCore`\n    ///\n    /// # Returns\n    ///\n    /// A random `EdwardsPoint`.\n    ///\n    /// # Implementation\n    ///\n    /// Uses rejection sampling, generating a random `CompressedEdwardsY` and then attempting point\n    /// decompression, rejecting invalid points.\n    #[cfg(any(test, feature = \"rand_core\"))]\n    pub fn random<R: RngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.fill_bytes(&mut repr.0);\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break p;\n                }\n            }\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Doubling\n// ------------------------------------------------------------------------\n\nimpl EdwardsPoint {\n    /// Add this point to itself.\n    pub(crate) fn double(&self) -> EdwardsPoint {\n        self.as_projective().double().as_extended()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Addition and Subtraction\n// ------------------------------------------------------------------------\n\nimpl<'a> Add<&'a EdwardsPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }\n}\n\ndefine_add_variants!(\n    LHS = EdwardsPoint,\n    RHS = EdwardsPoint,\n    Output = EdwardsPoint\n);\n\nimpl<'a> AddAssign<&'a EdwardsPoint> for EdwardsPoint {\n    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = EdwardsPoint, RHS = EdwardsPoint);\n\nimpl<'a> Sub<&'a EdwardsPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }\n}\n\ndefine_sub_variants!(\n    LHS = EdwardsPoint,\n    RHS = EdwardsPoint,\n    Output = EdwardsPoint\n);\n\nimpl<'a> SubAssign<&'a EdwardsPoint> for EdwardsPoint {\n    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = EdwardsPoint, RHS = EdwardsPoint);\n\nimpl<T> Sum<T> for EdwardsPoint\nwhere\n    T: Borrow<EdwardsPoint>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }\n}\n\n// ------------------------------------------------------------------------\n// Negation\n// ------------------------------------------------------------------------\n\nimpl Neg for &EdwardsPoint {\n    type Output = EdwardsPoint;\n\n    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }\n}\n\nimpl Neg for EdwardsPoint {\n    type Output = EdwardsPoint;\n\n    fn neg(self) -> EdwardsPoint {\n        -&self\n    }\n}\n\n// ------------------------------------------------------------------------\n// Scalar multiplication\n// ------------------------------------------------------------------------\n\nimpl<'a> MulAssign<&'a Scalar> for EdwardsPoint {\n    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }\n}\n\ndefine_mul_assign_variants!(LHS = EdwardsPoint, RHS = Scalar);\n\ndefine_mul_variants!(LHS = EdwardsPoint, RHS = Scalar, Output = EdwardsPoint);\ndefine_mul_variants!(LHS = Scalar, RHS = EdwardsPoint, Output = EdwardsPoint);\n\nimpl<'a> Mul<&'a Scalar> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, scalar: &'a Scalar) -> EdwardsPoint {\n        crate::backend::variable_base_mul(self, scalar)\n    }\n}\n\nimpl<'a> Mul<&'a EdwardsPoint> for &Scalar {\n    type Output = EdwardsPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, point: &'a EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }\n}\n\nimpl EdwardsPoint {\n    /// Fixed-base scalar multiplication by the Ed25519 base point.\n    ///\n    /// Uses precomputed basepoint tables when the `precomputed-tables` feature\n    /// is enabled, trading off increased code size for ~4x better performance.\n    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::ED25519_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::ED25519_BASEPOINT_TABLE\n        }\n    }\n\n    /// Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }\n\n    /// Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Multiscalar Multiplication impls\n// ------------------------------------------------------------------------\n\n// These use the iterator's size hint and the target settings to\n// forward to a specific backend implementation.\n\n#[cfg(feature = \"alloc\")]\nimpl MultiscalarMul for EdwardsPoint {\n    type Point = EdwardsPoint;\n\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.  When we do\n        // size-dependent algorithm dispatch, use this as the hint.\n        let _size = s_lo;\n\n        crate::backend::straus_multiscalar_mul(scalars, points)\n    }\n}\n\n#[cfg(feature = \"alloc\")]\nimpl VartimeMultiscalarMul for EdwardsPoint {\n    type Point = EdwardsPoint;\n\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.\n        // Use this as the hint to decide which algorithm to use.\n        let size = s_lo;\n\n        if size < 190 {\n            crate::backend::straus_optional_multiscalar_mul(scalars, points)\n        } else {\n            crate::backend::pippenger_optional_multiscalar_mul(scalars, points)\n        }\n    }\n}\n\n/// Precomputation for variable-time multiscalar multiplication with `EdwardsPoint`s.\n// This wraps the inner implementation in a facade type so that we can\n// decouple stability of the inner type from the stability of the\n// outer type.\n#[cfg(feature = \"alloc\")]\npub struct VartimeEdwardsPrecomputation(crate::backend::VartimePrecomputedStraus);\n\n#[cfg(feature = \"alloc\")]\nimpl VartimePrecomputedMultiscalarMul for VartimeEdwardsPrecomputation {\n    type Point = EdwardsPoint;\n\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(static_points))\n    }\n\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }\n\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }\n}\n\nimpl EdwardsPoint {\n    /// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.\n    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &EdwardsPoint,\n        b: &Scalar,\n    ) -> EdwardsPoint {\n        crate::backend::vartime_double_base_mul(a, A, b)\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nmacro_rules! impl_basepoint_table {\n    (Name = $name:ident, LookupTable = $table:ident, Point = $point:ty, Radix = $radix:expr, Additions = $adds:expr) => {\n        /// A precomputed table of multiples of a basepoint, for accelerating\n        /// fixed-base scalar multiplication.  One table, for the Ed25519\n        /// basepoint, is provided in the [`constants`] module.\n        ///\n        /// The basepoint tables are reasonably large, so they should probably be boxed.\n        ///\n        /// The sizes for the tables and the number of additions required for one scalar\n        /// multiplication are as follows:\n        ///\n        /// * [`EdwardsBasepointTableRadix16`]: 30KB, 64A\n        ///   (this is the default size, and is used for\n        ///   [`constants::ED25519_BASEPOINT_TABLE`])\n        /// * [`EdwardsBasepointTableRadix64`]: 120KB, 43A\n        /// * [`EdwardsBasepointTableRadix128`]: 240KB, 37A\n        /// * [`EdwardsBasepointTableRadix256`]: 480KB, 33A\n        ///\n        /// # Why 33 additions for radix-256?\n        ///\n        /// Normally, the radix-256 tables would allow for only 32 additions per scalar\n        /// multiplication.  However, due to the fact that standardised definitions of\n        /// legacy protocolssuch as x25519require allowing unreduced 255-bit scalars\n        /// invariants, when converting such an unreduced scalar's representation to\n        /// radix-\\\\(2^{8}\\\\), we cannot guarantee the carry bit will fit in the last\n        /// coefficient (the coefficients are `i8`s).  When, \\\\(w\\\\), the power-of-2 of\n        /// the radix, is \\\\(w < 8\\\\), we can fold the final carry onto the last\n        /// coefficient, \\\\(d\\\\), because \\\\(d < 2^{w/2}\\\\), so\n        /// $$\n        ///     d + carry \\cdot 2^{w} = d + 1 \\cdot 2^{w} < 2^{w+1} < 2^{8}\n        /// $$\n        /// When \\\\(w = 8\\\\), we can't fit \\\\(carry \\cdot 2^{w}\\\\) into an `i8`, so we\n        /// add the carry bit onto an additional coefficient.\n        #[derive(Clone)]\n        #[repr(transparent)]\n        pub struct $name(pub(crate) [$table<AffineNielsPoint>; 32]);\n\n        impl BasepointTable for $name {\n            type Point = $point;\n\n            /// Create a table of precomputed multiples of `basepoint`.\n            fn create(basepoint: &$point) -> $name {\n                // XXX use init_with\n                let mut table = $name([$table::default(); 32]);\n                let mut P = *basepoint;\n                for i in 0..32 {\n                    // P = (2w)^i * B\n                    table.0[i] = $table::from(&P);\n                    P = P.mul_by_pow_2($radix + $radix);\n                }\n                table\n            }\n\n            /// Get the basepoint for this table as an `EdwardsPoint`.\n            fn basepoint(&self) -> $point {\n                // self.0[0].select(1) = 1*(16^2)^0*B\n                // but as an `AffineNielsPoint`, so add identity to convert to extended.\n                (&<$point>::identity() + &self.0[0].select(1)).as_extended()\n            }\n\n            /// The computation uses Pippeneger's algorithm, as described for the\n            /// specific case of radix-16 on page 13 of the Ed25519 paper.\n            ///\n            /// # Piggenger's Algorithm Generalised\n            ///\n            /// Write the scalar \\\\(a\\\\) in radix-\\\\(w\\\\), where \\\\(w\\\\) is a power of\n            /// 2, with coefficients in \\\\([\\frac{-w}{2},\\frac{w}{2})\\\\), i.e.,\n            /// $$\n            ///     a = a\\_0 + a\\_1 w\\^1 + \\cdots + a\\_{x} w\\^{x},\n            /// $$\n            /// with\n            /// $$\n            /// \\begin{aligned}\n            ///     \\frac{-w}{2} \\leq a_i < \\frac{w}{2}\n            ///     &&\\cdots&&\n            ///     \\frac{-w}{2} \\leq a\\_{x} \\leq \\frac{w}{2}\n            /// \\end{aligned}\n            /// $$\n            /// and the number of additions, \\\\(x\\\\), is given by\n            /// \\\\(x = \\lceil \\frac{256}{w} \\rceil\\\\). Then\n            /// $$\n            ///     a B = a\\_0 B + a\\_1 w\\^1 B + \\cdots + a\\_{x-1} w\\^{x-1} B.\n            /// $$\n            /// Grouping even and odd coefficients gives\n            /// $$\n            /// \\begin{aligned}\n            ///     a B = \\quad a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B    \\\\\\\\\n            ///               + a\\_1 w\\^1 B +& a\\_3 w\\^3 B + \\cdots + a\\_{x-1} w\\^{x-1} B    \\\\\\\\\n            ///         = \\quad(a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B)   \\\\\\\\\n            ///             + w(a\\_1 w\\^0 B +& a\\_3 w\\^2 B + \\cdots + a\\_{x-1} w\\^{x-2} B).  \\\\\\\\\n            /// \\end{aligned}\n            /// $$\n            /// For each \\\\(i = 0 \\ldots 31\\\\), we create a lookup table of\n            /// $$\n            /// [w\\^{2i} B, \\ldots, \\frac{w}{2}\\cdot w\\^{2i} B],\n            /// $$\n            /// and use it to select \\\\( y \\cdot w\\^{2i} \\cdot B \\\\) in constant time.\n            ///\n            /// The radix-\\\\(w\\\\) representation requires that the scalar is bounded\n            /// by \\\\(2\\^{255}\\\\), which is always the case.\n            ///\n            /// The above algorithm is trivially generalised to other powers-of-2 radices.\n            fn mul_base(&self, scalar: &Scalar) -> $point {\n                let a = scalar.as_radix_2w($radix);\n\n                let tables = &self.0;\n                let mut P = <$point>::identity();\n\n                for i in (0..$adds).filter(|x| x % 2 == 1) {\n                    P = (&P + &tables[i / 2].select(a[i])).as_extended();\n                }\n\n                P = P.mul_by_pow_2($radix);\n\n                for i in (0..$adds).filter(|x| x % 2 == 0) {\n                    P = (&P + &tables[i / 2].select(a[i])).as_extended();\n                }\n\n                P\n            }\n        }\n\n        impl<'a, 'b> Mul<&'b Scalar> for &'a $name {\n            type Output = $point;\n\n            /// Construct an `EdwardsPoint` from a `Scalar` \\\\(a\\\\) by\n            /// computing the multiple \\\\(aB\\\\) of this basepoint \\\\(B\\\\).\n            fn mul(self, scalar: &'b Scalar) -> $point {\n                // delegate to a private function so that its documentation appears in internal docs\n                self.mul_base(scalar)\n            }\n        }\n\n        impl<'a, 'b> Mul<&'a $name> for &'b Scalar {\n            type Output = $point;\n\n            /// Construct an `EdwardsPoint` from a `Scalar` \\\\(a\\\\) by\n            /// computing the multiple \\\\(aB\\\\) of this basepoint \\\\(B\\\\).\n            fn mul(self, basepoint_table: &'a $name) -> $point {\n                basepoint_table * self\n            }\n        }\n\n        impl Debug for $name {\n            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(f, \"{:?}([\\n\", stringify!($name))?;\n                for i in 0..32 {\n                    write!(f, \"\\t{:?},\\n\", &self.0[i])?;\n                }\n                write!(f, \"])\")\n            }\n        }\n    };\n} // End macro_rules! impl_basepoint_table\n\n// The number of additions required is ceil(256/w) where w is the radix representation.\ncfg_if! {\n    if #[cfg(feature = \"precomputed-tables\")] {\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTable,\n            LookupTable = LookupTableRadix16,\n            Point = EdwardsPoint,\n            Radix = 4,\n            Additions = 64\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix32,\n            LookupTable = LookupTableRadix32,\n            Point = EdwardsPoint,\n            Radix = 5,\n            Additions = 52\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix64,\n            LookupTable = LookupTableRadix64,\n            Point = EdwardsPoint,\n            Radix = 6,\n            Additions = 43\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix128,\n            LookupTable = LookupTableRadix128,\n            Point = EdwardsPoint,\n            Radix = 7,\n            Additions = 37\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix256,\n            LookupTable = LookupTableRadix256,\n            Point = EdwardsPoint,\n            Radix = 8,\n            Additions = 33\n        }\n\n        /// A type-alias for [`EdwardsBasepointTable`] because the latter is\n        /// used as a constructor in the [`constants`] module.\n        //\n        // Same as for `LookupTableRadix16`, we have to define `EdwardsBasepointTable`\n        // first, because it's used as a constructor, and then provide a type alias for\n        // it.\n        pub type EdwardsBasepointTableRadix16 = EdwardsBasepointTable;\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nmacro_rules! impl_basepoint_table_conversions {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl<'a> From<&'a $lhs> for $rhs {\n            fn from(table: &'a $lhs) -> $rhs {\n                <$rhs>::create(&table.basepoint())\n            }\n        }\n\n        impl<'a> From<&'a $rhs> for $lhs {\n            fn from(table: &'a $rhs) -> $lhs {\n                <$lhs>::create(&table.basepoint())\n            }\n        }\n    };\n}\n\ncfg_if! {\n    if #[cfg(feature = \"precomputed-tables\")] {\n        // Conversions from radix 16\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix32\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix64\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 32\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix64\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 64\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix64,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix64,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 128\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix128,\n            RHS = EdwardsBasepointTableRadix256\n        }\n    }\n}\n\nimpl EdwardsPoint {\n    /// Multiply by the cofactor: return \\\\(\\[8\\]P\\\\).\n    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }\n\n    /// Compute \\\\([2\\^k] P \\\\) by successive doublings. Requires \\\\( k > 0 \\\\).\n    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        for _ in 0..(k - 1) {\n            r = s.double();\n            s = r.as_projective();\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        s.double().as_extended()\n    }\n\n    /// Determine if this point is of small order.\n    ///\n    /// # Return\n    ///\n    /// * `true` if `self` is in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\);\n    /// * `false` if `self` is not in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::constants;\n    ///\n    /// // Generator of the prime-order subgroup\n    /// let P = constants::ED25519_BASEPOINT_POINT;\n    /// // Generator of the torsion subgroup\n    /// let Q = constants::EIGHT_TORSION[1];\n    ///\n    /// // P has large order\n    /// assert_eq!(P.is_small_order(), false);\n    ///\n    /// // Q has small order\n    /// assert_eq!(Q.is_small_order(), true);\n    /// ```\n    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }\n\n    /// Determine if this point is torsion-free, i.e., is contained in\n    /// the prime-order subgroup.\n    ///\n    /// # Return\n    ///\n    /// * `true` if `self` has zero torsion component and is in the\n    ///   prime-order subgroup;\n    /// * `false` if `self` has a nonzero torsion component and is not\n    ///   in the prime-order subgroup.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::constants;\n    ///\n    /// // Generator of the prime-order subgroup\n    /// let P = constants::ED25519_BASEPOINT_POINT;\n    /// // Generator of the torsion subgroup\n    /// let Q = constants::EIGHT_TORSION[1];\n    ///\n    /// // P is torsion-free\n    /// assert_eq!(P.is_torsion_free(), true);\n    ///\n    /// // P + Q is not torsion-free\n    /// assert_eq!((P+Q).is_torsion_free(), false);\n    /// ```\n    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER).is_identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Debug traits\n// ------------------------------------------------------------------------\n\nimpl Debug for EdwardsPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }\n}\n\n// ------------------------------------------------------------------------\n// group traits\n// ------------------------------------------------------------------------\n\n// Use the full trait path to avoid Group::identity overlapping Identity::identity in the\n// rest of the module (e.g. tests).\n#[cfg(feature = \"group\")]\nimpl group::Group for EdwardsPoint {\n    type Scalar = Scalar;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.try_fill_bytes(&mut repr.0)?;\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break Ok(p);\n                }\n            }\n        }\n    }\n\n    fn identity() -> Self {\n        Identity::identity()\n    }\n\n    fn generator() -> Self {\n        constants::ED25519_BASEPOINT_POINT\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        self.double()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl GroupEncoding for EdwardsPoint {\n    type Repr = [u8; 32];\n\n    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        let repr = CompressedEdwardsY(*bytes);\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(&repr);\n        CtOption::new(decompress::step_2(&repr, X, Y, Z), is_valid_y_coord)\n    }\n\n    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // Just use the checked API; there are no checks we can skip.\n        Self::from_bytes(bytes)\n    }\n\n    fn to_bytes(&self) -> Self::Repr {\n        self.compress().to_bytes()\n    }\n}\n\n/// A `SubgroupPoint` represents a point on the Edwards form of Curve25519, that is\n/// guaranteed to be in the prime-order subgroup.\n#[cfg(feature = \"group\")]\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct SubgroupPoint(EdwardsPoint);\n\n#[cfg(feature = \"group\")]\nimpl From<SubgroupPoint> for EdwardsPoint {\n    fn from(p: SubgroupPoint) -> Self {\n        p.0\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Neg for SubgroupPoint {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        SubgroupPoint(-self.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Add<&SubgroupPoint> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n    fn add(self, other: &SubgroupPoint) -> SubgroupPoint {\n        SubgroupPoint(self.0 + other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_variants!(\n    LHS = SubgroupPoint,\n    RHS = SubgroupPoint,\n    Output = SubgroupPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl Add<&SubgroupPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn add(self, other: &SubgroupPoint) -> EdwardsPoint {\n        self + other.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_variants!(\n    LHS = EdwardsPoint,\n    RHS = SubgroupPoint,\n    Output = EdwardsPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl AddAssign<&SubgroupPoint> for SubgroupPoint {\n    fn add_assign(&mut self, rhs: &SubgroupPoint) {\n        self.0 += rhs.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_assign_variants!(LHS = SubgroupPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl AddAssign<&SubgroupPoint> for EdwardsPoint {\n    fn add_assign(&mut self, rhs: &SubgroupPoint) {\n        *self += rhs.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_assign_variants!(LHS = EdwardsPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl Sub<&SubgroupPoint> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n    fn sub(self, other: &SubgroupPoint) -> SubgroupPoint {\n        SubgroupPoint(self.0 - other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_variants!(\n    LHS = SubgroupPoint,\n    RHS = SubgroupPoint,\n    Output = SubgroupPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl Sub<&SubgroupPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn sub(self, other: &SubgroupPoint) -> EdwardsPoint {\n        self - other.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_variants!(\n    LHS = EdwardsPoint,\n    RHS = SubgroupPoint,\n    Output = EdwardsPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl SubAssign<&SubgroupPoint> for SubgroupPoint {\n    fn sub_assign(&mut self, rhs: &SubgroupPoint) {\n        self.0 -= rhs.0;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_assign_variants!(LHS = SubgroupPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl SubAssign<&SubgroupPoint> for EdwardsPoint {\n    fn sub_assign(&mut self, rhs: &SubgroupPoint) {\n        *self -= rhs.0;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_assign_variants!(LHS = EdwardsPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl<T> Sum<T> for SubgroupPoint\nwhere\n    T: Borrow<SubgroupPoint>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        use group::Group;\n        iter.fold(SubgroupPoint::identity(), |acc, item| acc + item.borrow())\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Mul<&Scalar> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, scalar: &Scalar) -> SubgroupPoint {\n        SubgroupPoint(self.0 * scalar)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_variants!(LHS = Scalar, RHS = SubgroupPoint, Output = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl Mul<&SubgroupPoint> for &Scalar {\n    type Output = SubgroupPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, point: &SubgroupPoint) -> SubgroupPoint {\n        point * self\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_variants!(LHS = SubgroupPoint, RHS = Scalar, Output = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl MulAssign<&Scalar> for SubgroupPoint {\n    fn mul_assign(&mut self, scalar: &Scalar) {\n        self.0 *= scalar;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_assign_variants!(LHS = SubgroupPoint, RHS = Scalar);\n\n#[cfg(feature = \"group\")]\nimpl ConstantTimeEq for SubgroupPoint {\n    fn ct_eq(&self, other: &SubgroupPoint) -> Choice {\n        self.0.ct_eq(&other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl ConditionallySelectable for SubgroupPoint {\n    fn conditional_select(a: &SubgroupPoint, b: &SubgroupPoint, choice: Choice) -> SubgroupPoint {\n        SubgroupPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }\n}\n\n// #[cfg(all(feature = \"group\", feature = \"zeroize\"))]\n// impl Zeroize for SubgroupPoint {\n//     fn zeroize(&mut self) {\n//         self.0.zeroize();\n//     }\n// }\n\n#[cfg(feature = \"group\")]\nimpl group::Group for SubgroupPoint {\n    type Scalar = Scalar;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        use group::ff::Field;\n\n        // This will almost never loop, but `Group::random` is documented as returning a\n        // non-identity element.\n        let s = loop {\n            let s: Scalar = Field::try_from_rng(rng)?;\n            if !s.is_zero_vartime() {\n                break s;\n            }\n        };\n\n        // This gives an element of the prime-order subgroup.\n        Ok(Self::generator() * s)\n    }\n\n    fn identity() -> Self {\n        SubgroupPoint(Identity::identity())\n    }\n\n    fn generator() -> Self {\n        SubgroupPoint(EdwardsPoint::generator())\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.0.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        SubgroupPoint(self.0.double())\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl GroupEncoding for SubgroupPoint {\n    type Repr = <EdwardsPoint as GroupEncoding>::Repr;\n\n    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        EdwardsPoint::from_bytes(bytes).and_then(|p| p.into_subgroup())\n    }\n\n    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        EdwardsPoint::from_bytes_unchecked(bytes).and_then(|p| p.into_subgroup())\n    }\n\n    fn to_bytes(&self) -> Self::Repr {\n        self.0.compress().to_bytes()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl PrimeGroup for SubgroupPoint {}\n\n#[cfg(feature = \"group\")]\nimpl CofactorGroup for EdwardsPoint {\n    type Subgroup = SubgroupPoint;\n\n    fn clear_cofactor(&self) -> Self::Subgroup {\n        SubgroupPoint(self.mul_by_cofactor())\n    }\n\n    fn into_subgroup(self) -> CtOption<Self::Subgroup> {\n        CtOption::new(SubgroupPoint(self), CofactorGroup::is_torsion_free(&self))\n    }\n\n    fn is_torsion_free(&self) -> Choice {\n        (self * constants::BASEPOINT_ORDER).ct_eq(&Self::identity())\n    }\n}\n\n// ------------------------------------------------------------------------\n// Tests\n// ------------------------------------------------------------------------\n\n// #[cfg(test)]\n// mod test {\n//     use super::*;\n\n//     use rand_core::TryRngCore;\n\n//     #[cfg(feature = \"alloc\")]\n//     use alloc::vec::Vec;\n\n//     #[cfg(feature = \"precomputed-tables\")]\n//     use crate::constants::ED25519_BASEPOINT_TABLE;\n\n//     /// X coordinate of the basepoint.\n//     /// = 15112221349535400772501151409588531511454012693041857206046113283949847762202\n//     static BASE_X_COORD_BYTES: [u8; 32] = [\n//         0x1a, 0xd5, 0x25, 0x8f, 0x60, 0x2d, 0x56, 0xc9, 0xb2, 0xa7, 0x25, 0x95, 0x60, 0xc7, 0x2c,\n//         0x69, 0x5c, 0xdc, 0xd6, 0xfd, 0x31, 0xe2, 0xa4, 0xc0, 0xfe, 0x53, 0x6e, 0xcd, 0xd3, 0x36,\n//         0x69, 0x21,\n//     ];\n\n//     /// Compressed Edwards Y form of 2*basepoint.\n//     static BASE2_CMPRSSD: CompressedEdwardsY = CompressedEdwardsY([\n//         0xc9, 0xa3, 0xf8, 0x6a, 0xae, 0x46, 0x5f, 0xe, 0x56, 0x51, 0x38, 0x64, 0x51, 0x0f, 0x39,\n//         0x97, 0x56, 0x1f, 0xa2, 0xc9, 0xe8, 0x5e, 0xa2, 0x1d, 0xc2, 0x29, 0x23, 0x09, 0xf3, 0xcd,\n//         0x60, 0x22,\n//     ]);\n\n//     /// Compressed Edwards Y form of 16*basepoint.\n//     static BASE16_CMPRSSD: CompressedEdwardsY = CompressedEdwardsY([\n//         0xeb, 0x27, 0x67, 0xc1, 0x37, 0xab, 0x7a, 0xd8, 0x27, 0x9c, 0x07, 0x8e, 0xff, 0x11, 0x6a,\n//         0xb0, 0x78, 0x6e, 0xad, 0x3a, 0x2e, 0x0f, 0x98, 0x9f, 0x72, 0xc3, 0x7f, 0x82, 0xf2, 0x96,\n//         0x96, 0x70,\n//     ]);\n\n//     /// 4493907448824000747700850167940867464579944529806937181821189941592931634714\n//     pub static A_SCALAR: Scalar = Scalar {\n//         bytes: [\n//             0x1a, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n//             0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n//             0x23, 0x76, 0xef, 0x09,\n//         ],\n//     };\n\n//     /// 2506056684125797857694181776241676200180934651973138769173342316833279714961\n//     pub static B_SCALAR: Scalar = Scalar {\n//         bytes: [\n//             0x91, 0x26, 0x7a, 0xcf, 0x25, 0xc2, 0x09, 0x1b, 0xa2, 0x17, 0x74, 0x7b, 0x66, 0xf0,\n//             0xb3, 0x2e, 0x9d, 0xf2, 0xa5, 0x67, 0x41, 0xcf, 0xda, 0xc4, 0x56, 0xa7, 0xd4, 0xaa,\n//             0xb8, 0x60, 0x8a, 0x05,\n//         ],\n//     };\n\n//     /// A_SCALAR * basepoint, computed with ed25519.py\n//     pub static A_TIMES_BASEPOINT: CompressedEdwardsY = CompressedEdwardsY([\n//         0xea, 0x27, 0xe2, 0x60, 0x53, 0xdf, 0x1b, 0x59, 0x56, 0xf1, 0x4d, 0x5d, 0xec, 0x3c, 0x34,\n//         0xc3, 0x84, 0xa2, 0x69, 0xb7, 0x4c, 0xc3, 0x80, 0x3e, 0xa8, 0xe2, 0xe7, 0xc9, 0x42, 0x5e,\n//         0x40, 0xa5,\n//     ]);\n\n//     /// A_SCALAR * (A_TIMES_BASEPOINT) + B_SCALAR * BASEPOINT\n//     /// computed with ed25519.py\n//     static DOUBLE_SCALAR_MULT_RESULT: CompressedEdwardsY = CompressedEdwardsY([\n//         0x7d, 0xfd, 0x6c, 0x45, 0xaf, 0x6d, 0x6e, 0x0e, 0xba, 0x20, 0x37, 0x1a, 0x23, 0x64, 0x59,\n//         0xc4, 0xc0, 0x46, 0x83, 0x43, 0xde, 0x70, 0x4b, 0x85, 0x09, 0x6f, 0xfe, 0x35, 0x4f, 0x13,\n//         0x2b, 0x42,\n//     ]);\n\n//     /// Test round-trip decompression for the basepoint.\n//     #[test]\n//     fn basepoint_decompression_compression() {\n//         let base_X = FieldElement::from_bytes(&BASE_X_COORD_BYTES);\n//         let bp = constants::ED25519_BASEPOINT_COMPRESSED\n//             .decompress()\n//             .unwrap();\n//         assert!(bp.is_valid());\n//         // Check that decompression actually gives the correct X coordinate\n//         assert_eq!(base_X, bp.X);\n//         assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n//     }\n\n//     /// Test sign handling in decompression\n//     #[test]\n//     fn decompression_sign_handling() {\n//         // Manually set the high bit of the last byte to flip the sign\n//         let mut minus_basepoint_bytes = *constants::ED25519_BASEPOINT_COMPRESSED.as_bytes();\n//         minus_basepoint_bytes[31] |= 1 << 7;\n//         let minus_basepoint = CompressedEdwardsY(minus_basepoint_bytes)\n//             .decompress()\n//             .unwrap();\n//         // Test projective coordinates exactly since we know they should\n//         // only differ by a flipped sign.\n//         assert_eq!(minus_basepoint.X, -(&constants::ED25519_BASEPOINT_POINT.X));\n//         assert_eq!(minus_basepoint.Y, constants::ED25519_BASEPOINT_POINT.Y);\n//         assert_eq!(minus_basepoint.Z, constants::ED25519_BASEPOINT_POINT.Z);\n//         assert_eq!(minus_basepoint.T, -(&constants::ED25519_BASEPOINT_POINT.T));\n//     }\n\n//     /// Test that computing 1*basepoint gives the correct basepoint.\n//     #[cfg(feature = \"precomputed-tables\")]\n//     #[test]\n//     fn basepoint_mult_one_vs_basepoint() {\n//         let bp = ED25519_BASEPOINT_TABLE * &Scalar::ONE;\n//         let compressed = bp.compress();\n//         assert_eq!(compressed, constants::ED25519_BASEPOINT_COMPRESSED);\n//     }\n\n//     /// Test that `EdwardsBasepointTable::basepoint()` gives the correct basepoint.\n//     #[cfg(feature = \"precomputed-tables\")]\n//     #[test]\n//     fn basepoint_table_basepoint_function_correct() {\n//         let bp = ED25519_BASEPOINT_TABLE.basepoint();\n//         assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n//     }\n\n//     /// Test `impl Add<EdwardsPoint> for EdwardsPoint`\n//     /// using basepoint + basepoint versus the 2*basepoint constant.\n//     #[test]\n//     fn basepoint_plus_basepoint_vs_basepoint2() {\n//         let bp = constants::ED25519_BASEPOINT_POINT;\n//         let bp_added = bp + bp;\n//         assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n//     }\n\n//     /// Test `impl Add<ProjectiveNielsPoint> for EdwardsPoint`\n//     /// using the basepoint, basepoint2 constants\n//     #[test]\n//     fn basepoint_plus_basepoint_projective_niels_vs_basepoint2() {\n//         let bp = constants::ED25519_BASEPOINT_POINT;\n//         let bp_added = (&bp + &bp.as_projective_niels()).as_extended();\n//         assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n//     }\n\n//     /// Test `impl Add<AffineNielsPoint> for EdwardsPoint`\n//     /// using the basepoint, basepoint2 constants\n//     #[test]\n//     fn basepoint_plus_basepoint_affine_niels_vs_basepoint2() {\n//         let bp = constants::ED25519_BASEPOINT_POINT;\n//         let bp_affine_niels = bp.as_affine_niels();\n//         let bp_added = (&bp + &bp_affine_niels).as_extended();\n//         assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n//     }\n\n//     /// Check that equality of `EdwardsPoints` handles projective\n//     /// coordinates correctly.\n//     #[test]\n//     fn extended_point_equality_handles_scaling() {\n//         let mut two_bytes = [0u8; 32];\n//         two_bytes[0] = 2;\n//         let id1 = EdwardsPoint::identity();\n//         let id2 = EdwardsPoint {\n//             X: FieldElement::ZERO,\n//             Y: FieldElement::from_bytes(&two_bytes),\n//             Z: FieldElement::from_bytes(&two_bytes),\n//             T: FieldElement::ZERO,\n//         };\n//         assert!(bool::from(id1.ct_eq(&id2)));\n//     }\n\n//     /// Sanity check for conversion to precomputed points\n//     #[cfg(feature = \"precomputed-tables\")]\n//     #[test]\n//     fn to_affine_niels_clears_denominators() {\n//         // construct a point as aB so it has denominators (ie. Z != 1)\n//         let aB = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n//         let aB_affine_niels = aB.as_affine_niels();\n//         let also_aB = (&EdwardsPoint::identity() + &aB_affine_niels).as_extended();\n//         assert_eq!(aB.compress(), also_aB.compress());\n//     }\n\n//     /// Test mul_base versus a known scalar multiple from ed25519.py\n//     #[test]\n//     fn basepoint_mult_vs_ed25519py() {\n//         let aB = EdwardsPoint::mul_base(&A_SCALAR);\n//         assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n//     }\n\n//     /// Test that multiplication by the basepoint order kills the basepoint\n//     #[test]\n//     fn basepoint_mult_by_basepoint_order() {\n//         let should_be_id = EdwardsPoint::mul_base(&constants::BASEPOINT_ORDER);\n//         assert!(should_be_id.is_identity());\n//     }\n\n//     /// Test precomputed basepoint mult\n//     #[cfg(feature = \"precomputed-tables\")]\n//     #[test]\n//     fn test_precomputed_basepoint_mult() {\n//         let aB_1 = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n//         let aB_2 = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n//         assert_eq!(aB_1.compress(), aB_2.compress());\n//     }\n\n//     /// Test scalar_mul versus a known scalar multiple from ed25519.py\n//     #[test]\n//     fn scalar_mul_vs_ed25519py() {\n//         let aB = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n//         assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n//     }\n\n//     /// Test basepoint.double() versus the 2*basepoint constant.\n//     #[test]\n//     fn basepoint_double_vs_basepoint2() {\n//         assert_eq!(\n//             constants::ED25519_BASEPOINT_POINT.double().compress(),\n//             BASE2_CMPRSSD\n//         );\n//     }\n\n//     /// Test that computing 2*basepoint is the same as basepoint.double()\n//     #[test]\n//     fn basepoint_mult_two_vs_basepoint2() {\n//         let two = Scalar::from(2u64);\n//         let bp2 = EdwardsPoint::mul_base(&two);\n//         assert_eq!(bp2.compress(), BASE2_CMPRSSD);\n//     }\n\n//     /// Test that all the basepoint table types compute the same results.\n//     #[cfg(feature = \"precomputed-tables\")]\n//     #[test]\n//     fn basepoint_tables() {\n//         let P = &constants::ED25519_BASEPOINT_POINT;\n//         let a = A_SCALAR;\n\n//         let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n//         let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n//         let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n//         let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n//         let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n//         let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n//         let aP16 = (&table_radix16 * &a).compress();\n//         let aP32 = (&table_radix32 * &a).compress();\n//         let aP64 = (&table_radix64 * &a).compress();\n//         let aP128 = (&table_radix128 * &a).compress();\n//         let aP256 = (&table_radix256 * &a).compress();\n\n//         assert_eq!(aP, aP16);\n//         assert_eq!(aP16, aP32);\n//         assert_eq!(aP32, aP64);\n//         assert_eq!(aP64, aP128);\n//         assert_eq!(aP128, aP256);\n//     }\n\n//     /// Check unreduced scalar multiplication by the basepoint tables is the same no matter what\n//     /// radix the table is.\n//     #[cfg(feature = \"precomputed-tables\")]\n//     #[test]\n//     fn basepoint_tables_unreduced_scalar() {\n//         let P = &constants::ED25519_BASEPOINT_POINT;\n//         let a = crate::scalar::test::LARGEST_UNREDUCED_SCALAR;\n\n//         let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n//         let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n//         let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n//         let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n//         let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n//         let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n//         let aP16 = (&table_radix16 * &a).compress();\n//         let aP32 = (&table_radix32 * &a).compress();\n//         let aP64 = (&table_radix64 * &a).compress();\n//         let aP128 = (&table_radix128 * &a).compress();\n//         let aP256 = (&table_radix256 * &a).compress();\n\n//         assert_eq!(aP, aP16);\n//         assert_eq!(aP16, aP32);\n//         assert_eq!(aP32, aP64);\n//         assert_eq!(aP64, aP128);\n//         assert_eq!(aP128, aP256);\n//     }\n\n//     /// Check that converting to projective and then back to extended round-trips.\n//     #[test]\n//     fn basepoint_projective_extended_round_trip() {\n//         assert_eq!(\n//             constants::ED25519_BASEPOINT_POINT\n//                 .as_projective()\n//                 .as_extended()\n//                 .compress(),\n//             constants::ED25519_BASEPOINT_COMPRESSED\n//         );\n//     }\n\n//     /// Test computing 16*basepoint vs mul_by_pow_2(4)\n//     #[test]\n//     fn basepoint16_vs_mul_by_pow_2_4() {\n//         let bp16 = constants::ED25519_BASEPOINT_POINT.mul_by_pow_2(4);\n//         assert_eq!(bp16.compress(), BASE16_CMPRSSD);\n//     }\n\n//     /// Check that mul_base_clamped and mul_clamped agree\n//     #[test]\n//     fn mul_base_clamped() {\n//         let mut csprng = rand_core::OsRng;\n\n//         // Make a random curve point in the curve. Give it torsion to make things interesting.\n//         #[cfg(feature = \"precomputed-tables\")]\n//         let random_point = {\n//             let mut b = [0u8; 32];\n//             csprng.try_fill_bytes(&mut b).unwrap();\n//             EdwardsPoint::mul_base_clamped(b) + constants::EIGHT_TORSION[1]\n//         };\n//         // Make a basepoint table from the random point. We'll use this with mul_base_clamped\n//         #[cfg(feature = \"precomputed-tables\")]\n//         let random_table = EdwardsBasepointTableRadix256::create(&random_point);\n\n//         // Now test scalar mult. agreement on the default basepoint as well as random_point\n\n//         // Test that mul_base_clamped and mul_clamped agree on a large integer. Even after\n//         // clamping, this integer is not reduced mod l.\n//         let a_bytes = [0xff; 32];\n//         assert_eq!(\n//             EdwardsPoint::mul_base_clamped(a_bytes),\n//             constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n//         );\n//         #[cfg(feature = \"precomputed-tables\")]\n//         assert_eq!(\n//             random_table.mul_base_clamped(a_bytes),\n//             random_point.mul_clamped(a_bytes)\n//         );\n\n//         // Test agreement on random integers\n//         for _ in 0..100 {\n//             // This will be reduced mod l with probability l / 2^256  6.25%\n//             let mut a_bytes = [0u8; 32];\n//             csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n//             assert_eq!(\n//                 EdwardsPoint::mul_base_clamped(a_bytes),\n//                 constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n//             );\n//             #[cfg(feature = \"precomputed-tables\")]\n//             assert_eq!(\n//                 random_table.mul_base_clamped(a_bytes),\n//                 random_point.mul_clamped(a_bytes)\n//             );\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn impl_sum() {\n//         // Test that sum works for non-empty iterators\n//         let BASE = constants::ED25519_BASEPOINT_POINT;\n\n//         let s1 = Scalar::from(999u64);\n//         let P1 = BASE * s1;\n\n//         let s2 = Scalar::from(333u64);\n//         let P2 = BASE * s2;\n\n//         let vec = vec![P1, P2];\n//         let sum: EdwardsPoint = vec.iter().sum();\n\n//         assert_eq!(sum, P1 + P2);\n\n//         // Test that sum works for the empty iterator\n//         let empty_vector: Vec<EdwardsPoint> = vec![];\n//         let sum: EdwardsPoint = empty_vector.iter().sum();\n\n//         assert_eq!(sum, EdwardsPoint::identity());\n\n//         // Test that sum works on owning iterators\n//         let s = Scalar::from(2u64);\n//         let mapped = vec.iter().map(|x| x * s);\n//         let sum: EdwardsPoint = mapped.sum();\n\n//         assert_eq!(sum, P1 * s + P2 * s);\n//     }\n\n//     /// Test that the conditional assignment trait works for AffineNielsPoints.\n//     #[test]\n//     fn conditional_assign_for_affine_niels_point() {\n//         let id = AffineNielsPoint::identity();\n//         let mut p1 = AffineNielsPoint::identity();\n//         let bp = constants::ED25519_BASEPOINT_POINT.as_affine_niels();\n\n//         p1.conditional_assign(&bp, Choice::from(0));\n//         assert_eq!(p1, id);\n//         p1.conditional_assign(&bp, Choice::from(1));\n//         assert_eq!(p1, bp);\n//     }\n\n//     #[test]\n//     fn is_small_order() {\n//         // The basepoint has large prime order\n//         assert!(!constants::ED25519_BASEPOINT_POINT.is_small_order());\n//         // constants::EIGHT_TORSION has all points of small order.\n//         for torsion_point in &constants::EIGHT_TORSION {\n//             assert!(torsion_point.is_small_order());\n//         }\n//     }\n\n//     #[test]\n//     fn compressed_identity() {\n//         assert_eq!(\n//             EdwardsPoint::identity().compress(),\n//             CompressedEdwardsY::identity()\n//         );\n\n//         #[cfg(feature = \"alloc\")]\n//         {\n//             let compressed = EdwardsPoint::compress_batch(&[EdwardsPoint::identity()]);\n//             assert_eq!(&compressed, &[CompressedEdwardsY::identity()]);\n//         }\n//     }\n\n//     #[cfg(feature = \"alloc\")]\n//     #[test]\n//     fn compress_batch() {\n//         let mut rng = rand::rng();\n\n//         // TODO(tarcieri): proptests?\n//         // Make some points deterministically then randomly\n//         let mut points = (1u64..16)\n//             .map(|n| constants::ED25519_BASEPOINT_POINT * Scalar::from(n))\n//             .collect::<Vec<_>>();\n//         points.extend(core::iter::repeat_with(|| EdwardsPoint::random(&mut rng)).take(100));\n//         let compressed = EdwardsPoint::compress_batch(&points);\n\n//         // Check that the batch-compressed points match the individually compressed ones\n//         for (point, compressed) in points.iter().zip(&compressed) {\n//             assert_eq!(&point.compress(), compressed);\n//         }\n//     }\n\n//     #[test]\n//     fn is_identity() {\n//         assert!(EdwardsPoint::identity().is_identity());\n//         assert!(!constants::ED25519_BASEPOINT_POINT.is_identity());\n//     }\n\n//     /// Rust's debug builds have overflow and underflow trapping,\n//     /// and enable `debug_assert!()`.  This performs many scalar\n//     /// multiplications to attempt to trigger possible overflows etc.\n//     ///\n//     /// For instance, the `u64` `Mul` implementation for\n//     /// `FieldElements` requires the input `Limb`s to be bounded by\n//     /// 2^54, but we cannot enforce this dynamically at runtime, or\n//     /// statically at compile time (until Rust gets type-level\n//     /// integers, at which point we can encode \"bits of headroom\" into\n//     /// the type system and prove correctness).\n//     #[test]\n//     fn monte_carlo_overflow_underflow_debug_assert_test() {\n//         let mut P = constants::ED25519_BASEPOINT_POINT;\n//         // N.B. each scalar_mul does 1407 field mults, 1024 field squarings,\n//         // so this does ~ 1M of each operation.\n//         for _ in 0..1_000 {\n//             P *= &A_SCALAR;\n//         }\n//     }\n\n//     #[test]\n//     fn scalarmult_extended_point_works_both_ways() {\n//         let G: EdwardsPoint = constants::ED25519_BASEPOINT_POINT;\n//         let s: Scalar = A_SCALAR;\n\n//         let P1 = G * s;\n//         let P2 = s * G;\n\n//         assert!(P1.compress().to_bytes() == P2.compress().to_bytes());\n//     }\n\n//     // A single iteration of a consistency check for MSM.\n//     #[cfg(feature = \"alloc\")]\n//     fn multiscalar_consistency_iter(n: usize) {\n//         let mut rng = rand::rng();\n\n//         // Construct random coefficients x0, ..., x_{n-1},\n//         // followed by some extra hardcoded ones.\n//         let xs = (0..n).map(|_| Scalar::random(&mut rng)).collect::<Vec<_>>();\n//         let check = xs.iter().map(|xi| xi * xi).sum::<Scalar>();\n\n//         // Construct points G_i = x_i * B\n//         let Gs = xs.iter().map(EdwardsPoint::mul_base).collect::<Vec<_>>();\n\n//         // Compute H1 = <xs, Gs> (consttime)\n//         let H1 = EdwardsPoint::multiscalar_mul(&xs, &Gs);\n//         // Compute H2 = <xs, Gs> (vartime)\n//         let H2 = EdwardsPoint::vartime_multiscalar_mul(&xs, &Gs);\n//         // Compute H3 = <xs, Gs> = sum(xi^2) * B\n//         let H3 = EdwardsPoint::mul_base(&check);\n\n//         assert_eq!(H1, H3);\n//         assert_eq!(H2, H3);\n//     }\n\n//     // Use different multiscalar sizes to hit different internal\n//     // parameters.\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn multiscalar_consistency_n_100() {\n//         let iters = 50;\n//         for _ in 0..iters {\n//             multiscalar_consistency_iter(100);\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn multiscalar_consistency_n_250() {\n//         let iters = 50;\n//         for _ in 0..iters {\n//             multiscalar_consistency_iter(250);\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn multiscalar_consistency_n_500() {\n//         let iters = 50;\n//         for _ in 0..iters {\n//             multiscalar_consistency_iter(500);\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn multiscalar_consistency_n_1000() {\n//         let iters = 50;\n//         for _ in 0..iters {\n//             multiscalar_consistency_iter(1000);\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn batch_to_montgomery() {\n//         let mut rng = rand::rng();\n\n//         let scalars = (0..128)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         let points = scalars\n//             .iter()\n//             .map(EdwardsPoint::mul_base)\n//             .collect::<Vec<_>>();\n\n//         let single_monts = points\n//             .iter()\n//             .map(EdwardsPoint::to_montgomery)\n//             .collect::<Vec<_>>();\n\n//         for i in [0, 1, 2, 3, 10, 50, 128] {\n//             let invs = EdwardsPoint::to_montgomery_batch(&points[..i]);\n//             assert_eq!(&invs, &single_monts[..i]);\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n//         let mut rng = rand::rng();\n\n//         let static_scalars = (0..128)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         let dynamic_scalars = (0..128)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         let check_scalar: Scalar = static_scalars\n//             .iter()\n//             .chain(dynamic_scalars.iter())\n//             .map(|s| s * s)\n//             .sum();\n\n//         let static_points = static_scalars\n//             .iter()\n//             .map(EdwardsPoint::mul_base)\n//             .collect::<Vec<_>>();\n//         let dynamic_points = dynamic_scalars\n//             .iter()\n//             .map(EdwardsPoint::mul_base)\n//             .collect::<Vec<_>>();\n\n//         let precomputation = VartimeEdwardsPrecomputation::new(static_points.iter());\n\n//         assert_eq!(precomputation.len(), 128);\n//         assert!(!precomputation.is_empty());\n\n//         let P = precomputation.vartime_mixed_multiscalar_mul(\n//             &static_scalars,\n//             &dynamic_scalars,\n//             &dynamic_points,\n//         );\n\n//         use crate::traits::VartimeMultiscalarMul;\n//         let Q = EdwardsPoint::vartime_multiscalar_mul(\n//             static_scalars.iter().chain(dynamic_scalars.iter()),\n//             static_points.iter().chain(dynamic_points.iter()),\n//         );\n\n//         let R = EdwardsPoint::mul_base(&check_scalar);\n\n//         assert_eq!(P.compress(), R.compress());\n//         assert_eq!(Q.compress(), R.compress());\n//     }\n\n//     mod vartime {\n//         use super::super::*;\n//         use super::{A_SCALAR, A_TIMES_BASEPOINT, B_SCALAR, DOUBLE_SCALAR_MULT_RESULT};\n\n//         /// Test double_scalar_mul_vartime vs ed25519.py\n//         #[test]\n//         fn double_scalar_mul_basepoint_vs_ed25519py() {\n//             let A = A_TIMES_BASEPOINT.decompress().unwrap();\n//             let result =\n//                 EdwardsPoint::vartime_double_scalar_mul_basepoint(&A_SCALAR, &A, &B_SCALAR);\n//             assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n//         }\n\n//         #[test]\n//         #[cfg(feature = \"alloc\")]\n//         fn multiscalar_mul_vs_ed25519py() {\n//             let A = A_TIMES_BASEPOINT.decompress().unwrap();\n//             let result = EdwardsPoint::vartime_multiscalar_mul(\n//                 &[A_SCALAR, B_SCALAR],\n//                 &[A, constants::ED25519_BASEPOINT_POINT],\n//             );\n//             assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n//         }\n\n//         #[test]\n//         #[cfg(feature = \"alloc\")]\n//         fn multiscalar_mul_vartime_vs_consttime() {\n//             let A = A_TIMES_BASEPOINT.decompress().unwrap();\n//             let result_vartime = EdwardsPoint::vartime_multiscalar_mul(\n//                 &[A_SCALAR, B_SCALAR],\n//                 &[A, constants::ED25519_BASEPOINT_POINT],\n//             );\n//             let result_consttime = EdwardsPoint::multiscalar_mul(\n//                 &[A_SCALAR, B_SCALAR],\n//                 &[A, constants::ED25519_BASEPOINT_POINT],\n//             );\n\n//             assert_eq!(result_vartime.compress(), result_consttime.compress());\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"serde\")]\n//     fn serde_bincode_basepoint_roundtrip() {\n//         use bincode;\n\n//         let encoded = bincode::serialize(&constants::ED25519_BASEPOINT_POINT).unwrap();\n//         let enc_compressed = bincode::serialize(&constants::ED25519_BASEPOINT_COMPRESSED).unwrap();\n//         assert_eq!(encoded, enc_compressed);\n\n//         // Check that the encoding is 32 bytes exactly\n//         assert_eq!(encoded.len(), 32);\n\n//         let dec_uncompressed: EdwardsPoint = bincode::deserialize(&encoded).unwrap();\n//         let dec_compressed: CompressedEdwardsY = bincode::deserialize(&encoded).unwrap();\n\n//         assert_eq!(dec_uncompressed, constants::ED25519_BASEPOINT_POINT);\n//         assert_eq!(dec_compressed, constants::ED25519_BASEPOINT_COMPRESSED);\n\n//         // Check that the encoding itself matches the usual one\n//         let raw_bytes = constants::ED25519_BASEPOINT_COMPRESSED.as_bytes();\n//         let bp: EdwardsPoint = bincode::deserialize(raw_bytes).unwrap();\n//         assert_eq!(bp, constants::ED25519_BASEPOINT_POINT);\n//     }\n\n//     // Hash-to-curve test vectors from\n//     // https://www.rfc-editor.org/rfc/rfc9380.html#name-edwards25519_xmdsha-512_ell2\n//     // These are of the form (input_msg, output_x, output_y)\n//     #[cfg(all(feature = \"alloc\", feature = \"digest\"))]\n//     const RFC_HASH_TO_CURVE_KAT: &[(&[u8], &str, &str)] = &[\n//         (\n//             b\"\",\n//             \"1ff2b70ecf862799e11b7ae744e3489aa058ce805dd323a936375a84695e76da\",\n//             \"222e314d04a4d5725e9f2aff9fb2a6b69ef375a1214eb19021ceab2d687f0f9b\",\n//         ),\n//         (\n//             b\"abc\",\n//             \"5f13cc69c891d86927eb37bd4afc6672360007c63f68a33ab423a3aa040fd2a8\",\n//             \"67732d50f9a26f73111dd1ed5dba225614e538599db58ba30aaea1f5c827fa42\",\n//         ),\n//         (\n//             b\"abcdef0123456789\",\n//             \"1dd2fefce934ecfd7aae6ec998de088d7dd03316aa1847198aecf699ba6613f1\",\n//             \"2f8a6c24dd1adde73909cada6a4a137577b0f179d336685c4a955a0a8e1a86fb\",\n//         ),\n//         (\n//             b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\\\n//             qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\",\n//             \"35fbdc5143e8a97afd3096f2b843e07df72e15bfca2eaf6879bf97c5d3362f73\",\n//             \"2af6ff6ef5ebba128b0774f4296cb4c2279a074658b083b8dcca91f57a603450\",\n//         ),\n//         (\n//             b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n//             \"6e5e1f37e99345887fc12111575fc1c3e36df4b289b8759d23af14d774b66bff\",\n//             \"2c90c3d39eb18ff291d33441b35f3262cdd307162cc97c31bfcc7a4245891a37\"\n//         )\n//     ];\n\n//     #[test]\n//     #[cfg(all(feature = \"alloc\", feature = \"digest\"))]\n//     fn elligator_hash_to_curve_test_vectors() {\n//         let dst = b\"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n//         for (index, vector) in RFC_HASH_TO_CURVE_KAT.iter().enumerate() {\n//             let input = vector.0;\n\n//             let expected_output = {\n//                 let mut x_bytes = hex::decode(vector.1).unwrap();\n//                 x_bytes.reverse();\n//                 let x = FieldElement::from_bytes(&x_bytes.try_into().unwrap());\n\n//                 let mut y_bytes = hex::decode(vector.2).unwrap();\n//                 y_bytes.reverse();\n//                 let y = FieldElement::from_bytes(&y_bytes.try_into().unwrap());\n\n//                 EdwardsPoint {\n//                     X: x,\n//                     Y: y,\n//                     Z: FieldElement::ONE,\n//                     T: &x * &y,\n//                 }\n//             };\n\n//             let computed = EdwardsPoint::hash_to_curve::<sha2::Sha512>(&[&input], &[dst]);\n//             assert_eq!(computed, expected_output, \"Failed in test {}\", index);\n//         }\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/edwards.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65052": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// Portions Copyright 2017 Brian Smith\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Isis Agora Lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n// - Brian Smith <brian@briansmith.org>\n\n//! Arithmetic on scalars (integers mod the group order).\n//!\n//! Both the Ristretto group and the Ed25519 basepoint have prime order\n//! \\\\( \\ell = 2\\^{252} + 27742317777372353535851937790883648493 \\\\).\n//!\n//! This code is intended to be useful with both the Ristretto group\n//! (where everything is done modulo \\\\( \\ell \\\\)), and the X/Ed25519\n//! setting, which mandates specific bit-twiddles that are not\n//! well-defined modulo \\\\( \\ell \\\\).\n//!\n//! All arithmetic on `Scalars` is done modulo \\\\( \\ell \\\\).\n//!\n//! # Constructing a scalar\n//!\n//! To create a [`Scalar`](struct.Scalar.html) from a supposedly canonical encoding, use\n//! [`Scalar::from_canonical_bytes`](struct.Scalar.html#method.from_canonical_bytes).\n//!\n//! This function does input validation, ensuring that the input bytes\n//! are the canonical encoding of a `Scalar`.\n//! If they are, we'll get\n//! `Some(Scalar)` in return:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let one_as_bytes: [u8; 32] = Scalar::ONE.to_bytes();\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(one_as_bytes).into();\n//!\n//! assert!(a.is_some());\n//! ```\n//!\n//! However, if we give it bytes representing a scalar larger than \\\\( \\ell \\\\)\n//! (in this case, \\\\( \\ell + 2 \\\\)), we'll get `None` back:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(l_plus_two_bytes).into();\n//!\n//! assert!(a.is_none());\n//! ```\n//!\n//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n// #![cfg_attr(feature = \"digest\", doc = \"```\")]\n// #![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n// //! # fn main() {\n// //! use sha2::{Digest, Sha512};\n// //! use curve25519_dalek::scalar::Scalar;\n// //!\n// //! // Hashing a single byte slice\n// //! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n// //!\n// //! // Streaming data into a hash object\n// //! let mut hasher = Sha512::default();\n// //! hasher.update(b\"Abolish \");\n// //! hasher.update(b\"ICE\");\n// //! let a2 = Scalar::from_hash(hasher);\n// //!\n// //! assert_eq!(a, a2);\n// //! # }\n// //! ```\n//!\n//! See also `Scalar::hash_from_bytes` and `Scalar::from_hash` that\n//! reduces a \\\\(512\\\\)-bit integer, if the optional `digest` feature\n//! has been enabled.\n\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::{Product, Sum};\nuse core::ops::Index;\nuse core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};\nuse core::ops::{Sub, SubAssign};\n\nuse cfg_if::cfg_if;\n\n#[cfg(feature = \"group\")]\nuse group::ff::{Field, FromUniformBytes, PrimeField};\n#[cfg(feature = \"group-bits\")]\nuse group::ff::{FieldBits, PrimeFieldBits};\n\n#[cfg(feature = \"group\")]\nuse rand_core::TryRngCore;\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::CryptoRng;\n\n// #[cfg(feature = \"digest\")]\n// use digest::Digest;\n// #[cfg(feature = \"digest\")]\n// use digest::array::typenum::U64;\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\nuse subtle::CtOption;\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::Zeroize;\n\nuse crate::backend;\nuse crate::constants;\n\ncfg_if! {\n    if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        #[cfg_attr(\n            docsrs,\n            doc(cfg(all(feature = \"fiat_backend\", curve25519_dalek_bits = \"32\")))\n        )]\n        type UnpackedScalar = backend::serial::fiat_u32::scalar::Scalar29;\n\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        #[cfg_attr(\n            docsrs,\n            doc(cfg(all(feature = \"fiat_backend\", curve25519_dalek_bits = \"64\")))\n        )]\n        type UnpackedScalar = backend::serial::fiat_u64::scalar::Scalar52;\n    } else if #[cfg(curve25519_dalek_bits = \"64\")] {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg_attr(docsrs, doc(cfg(curve25519_dalek_bits = \"64\")))]\n        type UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n    } else {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg_attr(docsrs, doc(cfg(curve25519_dalek_bits = \"64\")))]\n        type UnpackedScalar = backend::serial::u32::scalar::Scalar29;\n    }\n}\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    pub(crate) bytes: [u8; 32],\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> Scalar {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    #[cfg(feature = \"legacy_compatibility\")]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Debug for Scalar {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl Eq for Scalar {}\nimpl PartialEq for Scalar {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> Choice {\n        self.bytes.ct_eq(&other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\nimpl<'a> Mul<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\nimpl<'a> Sub<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n    fn neg(self) -> Scalar {\n        -&self\n    }\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct ScalarVisitor;\n\n        impl<'de> Visitor<'de> for ScalarVisitor {\n            type Value = Scalar;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\n                    \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                    basepoint order \",\n                )\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Option::from(Scalar::from_canonical_bytes(bytes))\n                    .ok_or_else(|| serde::de::Error::custom(\"scalar was not canonically encoded\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\nimpl<T> Product<T> for Scalar\nwhere\n    T: Borrow<Scalar>,\n{\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n}\n\nimpl<T> Sum<T> for Scalar\nwhere\n    T: Borrow<Scalar>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }\n}\n\nimpl Default for Scalar {\n    fn default() -> Scalar {\n        Scalar::ZERO\n    }\n}\n\nimpl From<u8> for Scalar {\n    fn from(x: u8) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        s_bytes[0] = x;\n        Scalar { bytes: s_bytes }\n    }\n}\n\nimpl From<u16> for Scalar {\n    fn from(x: u16) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}\n\nimpl From<u32> for Scalar {\n    fn from(x: u32) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    fn from(x: u64) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}\n\nimpl From<u128> for Scalar {\n    fn from(x: u128) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for Scalar {\n//     fn zeroize(&mut self) {\n//         self.bytes.zeroize();\n//     }\n// }\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n    };\n\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRng` interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::{OsRng, TryRngCore};\n    ///\n    /// let mut csprng = OsRng.unwrap_err();\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        let mut scalar_bytes = [0u8; 64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    // #[cfg(feature = \"digest\")]\n    // /// Hash a slice of bytes into a scalar.\n    // ///\n    // /// Takes a type parameter `D`, which is any `Digest` producing 64\n    // /// bytes (512 bits) of output.\n    // ///\n    // /// Convenience wrapper around `from_hash`.\n    // ///\n    // /// # Example\n    // ///\n    // #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    // #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    // /// # use curve25519_dalek::scalar::Scalar;\n    // /// use sha2::Sha512;\n    // ///\n    // /// # // Need fn main() here in comment so the doctest compiles\n    // /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    // /// # fn main() {\n    // /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    // /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    // /// # }\n    // /// ```\n    // pub fn hash_from_bytes<D>(input: &[u8]) -> Scalar\n    // where\n    //     D: Digest<OutputSize = U64> + Default,\n    // {\n    //     let mut hash = D::default();\n    //     hash.update(input);\n    //     Scalar::from_hash(hash)\n    // }\n\n    // #[cfg(feature = \"digest\")]\n    // /// Construct a scalar from an existing `Digest` instance.\n    // ///\n    // /// Use this instead of `hash_from_bytes` if it is more convenient\n    // /// to stream data into the `Digest` than to pass a single byte\n    // /// slice.\n    // ///\n    // /// # Example\n    // ///\n    // /// ```\n    // /// # use curve25519_dalek::scalar::Scalar;\n    // /// use curve25519_dalek::digest::Update;\n    // ///\n    // /// use sha2::Digest;\n    // /// use sha2::Sha512;\n    // ///\n    // /// # fn main() {\n    // /// let mut h = Sha512::new()\n    // ///     .chain(\"To really appreciate architecture, you may even need to commit a murder.\")\n    // ///     .chain(\"While the programs used for The Manhattan Transcripts are of the most extreme\")\n    // ///     .chain(\"nature, they also parallel the most common formula plot: the archetype of\")\n    // ///     .chain(\"murder. Other phantasms were occasionally used to underline the fact that\")\n    // ///     .chain(\"perhaps all architecture, rather than being about functional standards, is\")\n    // ///     .chain(\"about love and death.\");\n    // ///\n    // /// let s = Scalar::from_hash(h);\n    // ///\n    // /// println!(\"{:?}\", s.to_bytes());\n    // /// assert_eq!(\n    // ///     s.to_bytes(),\n    // ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    // ///       154,  38,  15,  23,  16, 167,  80, 150,\n    // ///       192, 221,  77, 226,  62,  25, 224, 148,\n    // ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    // /// );\n    // /// # }\n    // /// ```\n    // pub fn from_hash<D>(hash: D) -> Scalar\n    // where\n    //     D: Digest<OutputSize = U64>,\n    // {\n    //     let mut output = [0u8; 64];\n    //     output.copy_from_slice(hash.finalize().as_slice());\n    //     Scalar::from_bytes_mod_order_wide(&output)\n    // }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.bytes\n    }\n\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    pub fn invert(&self) -> Scalar {\n        self.unpack().invert().pack()\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    pub fn batch_invert(inputs: &mut [Scalar]) -> Scalar {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n\n        let n = inputs.len();\n        let one: UnpackedScalar = Scalar::ONE.unpack().as_montgomery();\n\n        let mut scratch = vec![one; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = Scalar::ONE.unpack().as_montgomery();\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n            *scratch = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        acc = acc.montgomery_invert().from_montgomery();\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n            acc = tmp;\n        }\n\n        // #[cfg(feature = \"zeroize\")]\n        // Zeroize::zeroize(&mut scratch);\n\n        ret\n    }\n\n    /// Get the bits of the scalar, in little-endian order\n    pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n        (0..256).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }\n\n    /// Compute a width-\\\\(w\\\\) \"Non-Adjacent Form\" of this scalar.\n    ///\n    /// A width-\\\\(w\\\\) NAF of a positive integer \\\\(k\\\\) is an expression\n    /// $$\n    /// k = \\sum_{i=0}\\^m n\\_i 2\\^i,\n    /// $$\n    /// where each nonzero\n    /// coefficient \\\\(n\\_i\\\\) is odd and bounded by \\\\(|n\\_i| < 2\\^{w-1}\\\\),\n    /// \\\\(n\\_{m-1}\\\\) is nonzero, and at most one of any \\\\(w\\\\) consecutive\n    /// coefficients is nonzero.  (Hankerson, Menezes, Vanstone; def 3.32).\n    ///\n    /// The length of the NAF is at most one more than the length of\n    /// the binary representation of \\\\(k\\\\).  This is why the\n    /// `Scalar` type maintains an invariant (invariant #1) that the top bit is\n    /// \\\\(0\\\\), so that the NAF of a scalar has at most 256 digits.\n    ///\n    /// Intuitively, this is like a binary expansion, except that we\n    /// allow some coefficients to grow in magnitude up to\n    /// \\\\(2\\^{w-1}\\\\) so that the nonzero coefficients are as sparse\n    /// as possible.\n    ///\n    /// When doing scalar multiplication, we can then use a lookup\n    /// table of precomputed multiples of a point to add the nonzero\n    /// terms \\\\( k_i P \\\\).  Using signed digits cuts the table size\n    /// in half, and using odd digits cuts the table size in half\n    /// again.\n    ///\n    /// To compute a \\\\(w\\\\)-NAF, we use a modification of Algorithm 3.35 of HMV:\n    ///\n    /// 1. \\\\( i \\gets 0 \\\\)\n    /// 2. While \\\\( k \\ge 1 \\\\):\n    ///     1. If \\\\(k\\\\) is odd, \\\\( n_i \\gets k \\operatorname{mods} 2^w \\\\), \\\\( k \\gets k - n_i \\\\).\n    ///     2. If \\\\(k\\\\) is even, \\\\( n_i \\gets 0 \\\\).\n    ///     3. \\\\( k \\gets k / 2 \\\\), \\\\( i \\gets i + 1 \\\\).\n    /// 3. Return \\\\( n_0, n_1, ... , \\\\)\n    ///\n    /// Here \\\\( \\bar x = x \\operatorname{mods} 2^w \\\\) means the\n    /// \\\\( \\bar x \\\\) with \\\\( \\bar x \\equiv x \\pmod{2^w} \\\\) and\n    /// \\\\( -2^{w-1} \\leq \\bar x < 2^{w-1} \\\\).\n    ///\n    /// We implement this by scanning across the bits of \\\\(k\\\\) from\n    /// least-significant bit to most-significant-bit.\n    /// Write the bits of \\\\(k\\\\) as\n    /// $$\n    /// k = \\sum\\_{i=0}\\^m k\\_i 2^i,\n    /// $$\n    /// and split the sum as\n    /// $$\n    /// k = \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n    /// $$\n    /// where the first part is \\\\( k \\mod 2^w \\\\).\n    ///\n    /// If \\\\( k \\mod 2^w\\\\) is odd, and \\\\( k \\mod 2^w < 2^{w-1} \\\\), then we emit\n    /// \\\\( n_0 = k \\mod 2^w \\\\).  Instead of computing\n    /// \\\\( k - n_0 \\\\), we just advance \\\\(w\\\\) bits and reindex.\n    ///\n    /// If \\\\( k \\mod 2^w\\\\) is odd, and \\\\( k \\mod 2^w \\ge 2^{w-1} \\\\), then\n    /// \\\\( n_0 = k \\operatorname{mods} 2^w = k \\mod 2^w - 2^w \\\\).\n    /// The quantity \\\\( k - n_0 \\\\) is\n    /// $$\n    /// \\begin{aligned}\n    /// k - n_0 &= \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n    ///          - \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\\\\\\\\n    /// &= 2^w + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n    /// \\end{aligned}\n    /// $$\n    /// so instead of computing the subtraction, we can set a carry\n    /// bit, advance \\\\(w\\\\) bits, and reindex.\n    ///\n    /// If \\\\( k \\mod 2^w\\\\) is even, we emit \\\\(0\\\\), advance 1 bit\n    /// and reindex.  In fact, by setting all digits to \\\\(0\\\\)\n    /// initially, we don't need to emit anything.\n    pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {\n        // required by the NAF definition\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        debug_assert!(w <= 8);\n\n        let mut naf = [0i8; 256];\n\n        let mut x_u64 = [0u64; 5];\n        read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }\n\n        naf\n    }\n\n    /// Write this scalar in radix 16, with coefficients in \\\\([-8,8)\\\\),\n    /// i.e., compute \\\\(a\\_i\\\\) such that\n    /// $$\n    ///    a = a\\_0 + a\\_1 16\\^1 + \\cdots + a_{63} 16\\^{63},\n    /// $$\n    /// with \\\\(-8 \\leq a_i < 8\\\\) for \\\\(0 \\leq i < 63\\\\) and \\\\(-8 \\leq a_{63} \\leq 8\\\\).\n    ///\n    /// The largest value that can be decomposed like this is just over \\\\(2^{255}\\\\). Thus, in\n    /// order to not error, the top bit MUST NOT be set, i.e., `Self` MUST be less than\n    /// \\\\(2^{255}\\\\).\n    pub(crate) fn as_radix_16(&self) -> [i8; 64] {\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8; 64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[allow(clippy::identity_op)]\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        for i in 0..32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        output\n    }\n\n    /// Returns a size hint indicating how many entries of the return\n    /// value of `to_radix_2w` are nonzero.\n    #[cfg(any(feature = \"alloc\", all(test, feature = \"precomputed-tables\")))]\n    pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        let digits_count = match w {\n            4..=7 => 256_usize.div_ceil(w),\n            // See comment in to_radix_2w on handling the terminal carry.\n            8 => 256_usize.div_ceil(w) + 1_usize,\n            _ => panic!(\"invalid radix parameter\"),\n        };\n\n        debug_assert!(digits_count <= 64);\n        digits_count\n    }\n\n    /// Creates a representation of a Scalar in radix \\\\( 2^w \\\\) with \\\\(w = 4, 5, 6, 7, 8\\\\) for\n    /// use with the Pippenger algorithm. Higher radixes are not supported to save cache space.\n    /// Radix 256 is near-optimal even for very large inputs.\n    ///\n    /// Radix below 16 or above 256 is prohibited.\n    /// This method returns digits in a fixed-sized array, excess digits are zeroes.\n    ///\n    /// For radix 16, `Self` must be less than \\\\(2^{255}\\\\). This is because most integers larger\n    /// than \\\\(2^{255}\\\\) are unrepresentable in the form described below for \\\\(w = 4\\\\). This\n    /// would be true for \\\\(w = 8\\\\) as well, but it is compensated for by increasing the size\n    /// hint by 1.\n    ///\n    /// ## Scalar representation\n    ///\n    /// Radix \\\\(2\\^w\\\\), with \\\\(n = ceil(256/w)\\\\) coefficients in \\\\([-(2\\^w)/2,(2\\^w)/2)\\\\),\n    /// i.e., scalar is represented using digits \\\\(a\\_i\\\\) such that\n    /// $$\n    ///    a = a\\_0 + a\\_1 2\\^1w + \\cdots + a_{n-1} 2\\^{w*(n-1)},\n    /// $$\n    /// with \\\\(-2\\^w/2 \\leq a_i < 2\\^w/2\\\\) for \\\\(0 \\leq i < (n-1)\\\\) and \\\\(-2\\^w/2 \\leq a_{n-1} \\leq 2\\^w/2\\\\).\n    ///\n    #[cfg(any(feature = \"alloc\", feature = \"precomputed-tables\"))]\n    pub(crate) fn as_radix_2w(&self, w: usize) -> [i8; 64] {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        if w == 4 {\n            return self.as_radix_16();\n        }\n\n        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.\n        let mut scalar64x4 = [0u64; 4];\n        read_le_u64_into(&self.bytes, &mut scalar64x4[0..4]);\n\n        let radix: u64 = 1 << w;\n        let window_mask: u64 = radix - 1;\n\n        let mut carry = 0u64;\n        let mut digits = [0i8; 64];\n        let digits_count = 256_usize.div_ceil(w);\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }\n\n        // When 4 < w < 8, we can fold the final carry onto the last digit d,\n        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.\n        //\n        // When w = 8, we can't fit carry*2^w into an i8.  This should\n        // not happen anyways, because the final carry will be 0 for\n        // reduced scalars, but Scalar invariant #1 allows 255-bit scalars.\n        // To handle this, we expand the size_hint by 1 when w=8,\n        // and accumulate the final carry onto another digit.\n        match w {\n            8 => digits[digits_count] += carry as i8,\n            _ => digits[digits_count - 1] += (carry << w) as i8,\n        }\n\n        digits\n    }\n\n    /// Unpack this `Scalar` to an `UnpackedScalar` for faster arithmetic.\n    pub(crate) fn unpack(&self) -> UnpackedScalar {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }\n\n    /// Reduce this `Scalar` modulo \\\\(\\ell\\\\).\n    #[allow(non_snake_case)]\n    fn reduce(&self) -> Scalar {\n        let x = self.unpack();\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        x_mod_l.pack()\n    }\n\n    /// Check whether this `Scalar` is the canonical representative mod \\\\(\\ell\\\\). This is not\n    /// public because any `Scalar` that is publicly observed is reduced, by scalar invariant #2.\n    fn is_canonical(&self) -> Choice {\n        self.ct_eq(&self.reduce())\n    }\n}\n\nimpl UnpackedScalar {\n    /// Pack the limbs of this `UnpackedScalar` into a `Scalar`.\n    fn pack(&self) -> Scalar {\n        Scalar {\n            bytes: self.to_bytes(),\n        }\n    }\n\n    /// Inverts an UnpackedScalar in Montgomery form.\n    #[rustfmt::skip] // keep alignment of addition chain and squarings\n    #[allow(clippy::just_underscores_and_digits)]\n    pub fn montgomery_invert(&self) -> UnpackedScalar {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let    _1 = *self;\n        let   _10 = _1.montgomery_square();\n        let  _100 = _10.montgomery_square();\n        let   _11 = UnpackedScalar::montgomery_mul(&_10,     &_1);\n        let  _101 = UnpackedScalar::montgomery_mul(&_10,    &_11);\n        let  _111 = UnpackedScalar::montgomery_mul(&_10,   &_101);\n        let _1001 = UnpackedScalar::montgomery_mul(&_10,   &_111);\n        let _1011 = UnpackedScalar::montgomery_mul(&_10,  &_1001);\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n\n        #[inline]\n        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,       4, &_1001);\n        square_multiply(&mut y,       2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 3, &_101);\n        square_multiply(&mut y,   3 + 3, &_101);\n        square_multiply(&mut y,       3, &_111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   2 + 3, &_111);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,   2 + 4, &_1011);\n        square_multiply(&mut y,   6 + 4, &_1001);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1001);\n        square_multiply(&mut y,   1 + 3, &_111);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   1 + 2, &_11);\n\n        y\n    }\n\n    /// Inverts an UnpackedScalar not in Montgomery form.\n    pub fn invert(&self) -> UnpackedScalar {\n        self.as_montgomery().montgomery_invert().from_montgomery()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Field for Scalar {\n    const ZERO: Self = Self::ZERO;\n    const ONE: Self = Self::ONE;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        // NOTE: this is duplicated due to different `rng` bounds\n        let mut scalar_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut scalar_bytes)?;\n        Ok(Self::from_bytes_mod_order_wide(&scalar_bytes))\n    }\n\n    fn square(&self) -> Self {\n        self * self\n    }\n\n    fn double(&self) -> Self {\n        self + self\n    }\n\n    fn invert(&self) -> CtOption<Self> {\n        CtOption::new(self.invert(), !self.is_zero())\n    }\n\n    fn sqrt_ratio(num: &Self, div: &Self) -> (Choice, Self) {\n        #[allow(unused_qualifications)]\n        group::ff::helpers::sqrt_ratio_generic(num, div)\n    }\n\n    fn sqrt(&self) -> CtOption<Self> {\n        #[allow(unused_qualifications)]\n        group::ff::helpers::sqrt_tonelli_shanks(\n            self,\n            [\n                0xcb02_4c63_4b9e_ba7d,\n                0x029b_df3b_d45e_f39a,\n                0x0000_0000_0000_0000,\n                0x0200_0000_0000_0000,\n            ],\n        )\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl PrimeField for Scalar {\n    type Repr = [u8; 32];\n\n    fn from_repr(repr: Self::Repr) -> CtOption<Self> {\n        Self::from_canonical_bytes(repr)\n    }\n\n    fn from_repr_vartime(repr: Self::Repr) -> Option<Self> {\n        // Check that the high bit is not set\n        if (repr[31] >> 7) != 0u8 {\n            return None;\n        }\n\n        let candidate = Scalar { bytes: repr };\n\n        if candidate == candidate.reduce() {\n            Some(candidate)\n        } else {\n            None\n        }\n    }\n\n    fn to_repr(&self) -> Self::Repr {\n        self.to_bytes()\n    }\n\n    fn is_odd(&self) -> Choice {\n        Choice::from(self.as_bytes()[0] & 1)\n    }\n\n    const MODULUS: &'static str =\n        \"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\";\n    const NUM_BITS: u32 = 253;\n    const CAPACITY: u32 = 252;\n\n    const TWO_INV: Self = Self {\n        bytes: [\n            0xf7, 0xe9, 0x7a, 0x2e, 0x8d, 0x31, 0x09, 0x2c, 0x6b, 0xce, 0x7b, 0x51, 0xef, 0x7c,\n            0x6f, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x08,\n        ],\n    };\n    const MULTIPLICATIVE_GENERATOR: Self = Self {\n        bytes: [\n            2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n    };\n    const S: u32 = 2;\n    const ROOT_OF_UNITY: Self = Self {\n        bytes: [\n            0xd4, 0x07, 0xbe, 0xeb, 0xdf, 0x75, 0x87, 0xbe, 0xfe, 0x83, 0xce, 0x42, 0x53, 0x56,\n            0xf0, 0x0e, 0x7a, 0xc2, 0xc1, 0xab, 0x60, 0x6d, 0x3d, 0x7d, 0xe7, 0x81, 0x79, 0xe0,\n            0x10, 0x73, 0x4a, 0x09,\n        ],\n    };\n    const ROOT_OF_UNITY_INV: Self = Self {\n        bytes: [\n            0x19, 0xcc, 0x37, 0x71, 0x3a, 0xed, 0x8a, 0x99, 0xd7, 0x18, 0x29, 0x60, 0x8b, 0xa3,\n            0xee, 0x05, 0x86, 0x3d, 0x3e, 0x54, 0x9f, 0x92, 0xc2, 0x82, 0x18, 0x7e, 0x86, 0x1f,\n            0xef, 0x8c, 0xb5, 0x06,\n        ],\n    };\n    const DELTA: Self = Self {\n        bytes: [\n            16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n    };\n}\n\n#[cfg(feature = \"group-bits\")]\nimpl PrimeFieldBits for Scalar {\n    type ReprBits = [u8; 32];\n\n    fn to_le_bits(&self) -> FieldBits<Self::ReprBits> {\n        self.to_repr().into()\n    }\n\n    fn char_le_bits() -> FieldBits<Self::ReprBits> {\n        constants::BASEPOINT_ORDER.to_bytes().into()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl FromUniformBytes<64> for Scalar {\n    fn from_uniform_bytes(bytes: &[u8; 64]) -> Self {\n        Scalar::from_bytes_mod_order_wide(bytes)\n    }\n}\n\n/// Read one or more u64s stored as little endian bytes.\n///\n/// ## Panics\n/// Panics if `src.len() != 8 * dst.len()`.\nfn read_le_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(\n        src.len() == 8 * dst.len(),\n        \"src.len() = {}, dst.len() = {}\",\n        src.len(),\n        dst.len()\n    );\n    for (bytes, val) in src.chunks(8).zip(dst.iter_mut()) {\n        *val = u64::from_le_bytes(\n            bytes\n                .try_into()\n                .expect(\"Incorrect src length, should be 8 * dst.len()\"),\n        );\n    }\n}\n\n/// _Clamps_ the given little-endian representation of a 32-byte integer. Clamping the value puts\n/// it in the range:\n///\n/// **n  2^254 + 8\\*{0, 1, 2, 3, . . ., 2^251  1}**\n///\n/// # Explanation of clamping\n///\n/// For Curve25519, h = 8, and multiplying by 8 is the same as a binary left-shift by 3 bits.\n/// If you take a secret scalar value between 2^251 and 2^252  1 and left-shift by 3 bits\n/// then you end up with a 255-bit number with the most significant bit set to 1 and\n/// the least-significant three bits set to 0.\n///\n/// The Curve25519 clamping operation takes **an arbitrary 256-bit random value** and\n/// clears the most-significant bit (making it a 255-bit number), sets the next bit, and then\n/// clears the 3 least-significant bits. In other words, it directly creates a scalar value that is\n/// in the right form and pre-multiplied by the cofactor.\n///\n/// See [here](https://neilmadden.blog/2020/05/28/whats-the-curve25519-clamping-all-about/) for\n/// more details.\n#[must_use]\npub const fn clamp_integer(mut bytes: [u8; 32]) -> [u8; 32] {\n    bytes[0] &= 0b1111_1000;\n    bytes[31] &= 0b0111_1111;\n    bytes[31] |= 0b0100_0000;\n    bytes\n}\n\n// #[cfg(test)]\n// pub(crate) mod test {\n//     use super::*;\n//     use rand_core::RngCore;\n\n//     #[cfg(feature = \"alloc\")]\n//     use alloc::vec::Vec;\n\n//     /// x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n//     pub static X: Scalar = Scalar {\n//         bytes: [\n//             0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84, 0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2,\n//             0x7d, 0x52, 0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44, 0xd4, 0x49, 0xf4, 0xa8,\n//             0x79, 0xd9, 0xf2, 0x04,\n//         ],\n//     };\n//     /// 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n//     pub static XINV: Scalar = Scalar {\n//         bytes: [\n//             0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb, 0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01,\n//             0x63, 0x47, 0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96, 0xd5, 0x0b, 0xcd, 0x7a,\n//             0x3f, 0x96, 0x2a, 0x0f,\n//         ],\n//     };\n//     /// y = 2592331292931086675770238855846338635550719849568364935475441891787804997264\n//     pub static Y: Scalar = Scalar {\n//         bytes: [\n//             0x90, 0x76, 0x33, 0xfe, 0x1c, 0x4b, 0x66, 0xa4, 0xa2, 0x8d, 0x2d, 0xd7, 0x67, 0x83,\n//             0x86, 0xc3, 0x53, 0xd0, 0xde, 0x54, 0x55, 0xd4, 0xfc, 0x9d, 0xe8, 0xef, 0x7a, 0xc3,\n//             0x1f, 0x35, 0xbb, 0x05,\n//         ],\n//     };\n\n//     /// The largest scalar that satisfies invariant #1, i.e., the largest scalar with the top bit\n//     /// set to 0. Since this scalar violates invariant #2, i.e., it's greater than the modulus `l`,\n//     /// addition and subtraction are broken. The only thing you can do with this is scalar-point\n//     /// multiplication (and actually also scalar-scalar multiplication, but that's just a quirk of\n//     /// our implementation).\n//     pub(crate) static LARGEST_UNREDUCED_SCALAR: Scalar = Scalar {\n//         bytes: [\n//             0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//             0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//             0xff, 0xff, 0xff, 0x7f,\n//         ],\n//     };\n\n//     /// x*y = 5690045403673944803228348699031245560686958845067437804563560795922180092780\n//     static X_TIMES_Y: Scalar = Scalar {\n//         bytes: [\n//             0x6c, 0x33, 0x74, 0xa1, 0x89, 0x4f, 0x62, 0x21, 0x0a, 0xaa, 0x2f, 0xe1, 0x86, 0xa6,\n//             0xf9, 0x2c, 0xe0, 0xaa, 0x75, 0xc2, 0x77, 0x95, 0x81, 0xc2, 0x95, 0xfc, 0x08, 0x17,\n//             0x9a, 0x73, 0x94, 0x0c,\n//         ],\n//     };\n\n//     /// sage: l = 2^252 + 27742317777372353535851937790883648493\n//     /// sage: big = 2^256 - 1\n//     /// sage: repr((big % l).digits(256))\n//     static CANONICAL_2_256_MINUS_1: Scalar = Scalar {\n//         bytes: [\n//             28, 149, 152, 141, 116, 49, 236, 214, 112, 207, 125, 115, 244, 91, 239, 198, 254, 255,\n//             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 15,\n//         ],\n//     };\n\n//     static A_SCALAR: Scalar = Scalar {\n//         bytes: [\n//             0x1a, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n//             0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n//             0x23, 0x76, 0xef, 0x09,\n//         ],\n//     };\n\n//     static A_NAF: [i8; 256] = [\n//         0, 13, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, -9, 0, 0, 0, 0, -11, 0, 0, 0, 0, 3, 0, 0,\n//         0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, -5, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 11, 0, 0, 0, 0,\n//         11, 0, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,\n//         0, -1, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, -15, 0, 0, 0, 0, -7, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 5,\n//         0, 0, 0, 0, 13, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, -11, 0, 0, 0, 0, -7, 0, 0, 0, 0, -13, 0, 0,\n//         0, 0, 11, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n//         7, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 15,\n//         0, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, -15, 0,\n//         0, 0, 0, 0, 15, 0, 0, 0, 0, 15, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n//     ];\n\n//     const BASEPOINT_ORDER_MINUS_ONE: Scalar = Scalar {\n//         bytes: [\n//             0xec, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9,\n//             0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//             0x00, 0x00, 0x00, 0x10,\n//         ],\n//     };\n\n//     /// The largest clamped integer\n//     static LARGEST_CLAMPED_INTEGER: [u8; 32] = clamp_integer(LARGEST_UNREDUCED_SCALAR.bytes);\n\n//     #[test]\n//     fn fuzzer_testcase_reduction() {\n//         // LE bytes of 24519928653854221733733552434404946937899825954937634815\n//         let a_bytes = [\n//             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n//             255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//         ];\n//         // LE bytes of 4975441334397345751130612518500927154628011511324180036903450236863266160640\n//         let b_bytes = [\n//             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 210, 210,\n//             210, 255, 255, 255, 255, 10,\n//         ];\n//         // LE bytes of 6432735165214683820902750800207468552549813371247423777071615116673864412038\n//         let c_bytes = [\n//             134, 171, 119, 216, 180, 128, 178, 62, 171, 132, 32, 62, 34, 119, 104, 193, 47, 215,\n//             181, 250, 14, 207, 172, 93, 75, 207, 211, 103, 144, 204, 56, 14,\n//         ];\n\n//         let a = Scalar::from_bytes_mod_order(a_bytes);\n//         let b = Scalar::from_bytes_mod_order(b_bytes);\n//         let c = Scalar::from_bytes_mod_order(c_bytes);\n\n//         let mut tmp = [0u8; 64];\n\n//         // also_a = (a mod l)\n//         tmp[0..32].copy_from_slice(&a_bytes[..]);\n//         let also_a = Scalar::from_bytes_mod_order_wide(&tmp);\n\n//         // also_b = (b mod l)\n//         tmp[0..32].copy_from_slice(&b_bytes[..]);\n//         let also_b = Scalar::from_bytes_mod_order_wide(&tmp);\n\n//         let expected_c = a * b;\n//         let also_expected_c = also_a * also_b;\n\n//         assert_eq!(c, expected_c);\n//         assert_eq!(c, also_expected_c);\n//     }\n\n//     #[test]\n//     fn non_adjacent_form_test_vector() {\n//         let naf = A_SCALAR.non_adjacent_form(5);\n//         for i in 0..256 {\n//             assert_eq!(naf[i], A_NAF[i]);\n//         }\n//     }\n\n//     fn non_adjacent_form_iter(w: usize, x: &Scalar) {\n//         let naf = x.non_adjacent_form(w);\n\n//         // Reconstruct the scalar from the computed NAF\n//         let mut y = Scalar::ZERO;\n//         for i in (0..256).rev() {\n//             y += y;\n//             let digit = if naf[i] < 0 {\n//                 -Scalar::from((-naf[i]) as u64)\n//             } else {\n//                 Scalar::from(naf[i] as u64)\n//             };\n//             y += digit;\n//         }\n\n//         assert_eq!(*x, y);\n//     }\n\n//     #[test]\n//     fn non_adjacent_form_random() {\n//         let mut rng = rand::rng();\n//         for _ in 0..1_000 {\n//             let x = Scalar::random(&mut rng);\n//             for w in &[5, 6, 7, 8] {\n//                 non_adjacent_form_iter(*w, &x);\n//             }\n//         }\n//     }\n\n//     #[test]\n//     fn from_u64() {\n//         let val: u64 = 0xdeadbeefdeadbeef;\n//         let s = Scalar::from(val);\n//         assert_eq!(s[7], 0xde);\n//         assert_eq!(s[6], 0xad);\n//         assert_eq!(s[5], 0xbe);\n//         assert_eq!(s[4], 0xef);\n//         assert_eq!(s[3], 0xde);\n//         assert_eq!(s[2], 0xad);\n//         assert_eq!(s[1], 0xbe);\n//         assert_eq!(s[0], 0xef);\n//     }\n\n//     #[test]\n//     fn scalar_mul_by_one() {\n//         let test_scalar = X * Scalar::ONE;\n//         for i in 0..32 {\n//             assert!(test_scalar[i] == X[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn add_reduces() {\n//         // Check that addition wraps around the modulus\n//         assert_eq!(BASEPOINT_ORDER_MINUS_ONE + Scalar::ONE, Scalar::ZERO);\n//     }\n\n//     #[test]\n//     fn sub_reduces() {\n//         // Check that subtraction wraps around the modulus\n//         assert_eq!(Scalar::ZERO - Scalar::ONE, BASEPOINT_ORDER_MINUS_ONE);\n//     }\n\n//     #[test]\n//     fn impl_add() {\n//         let two = Scalar::from(2u64);\n//         let one = Scalar::ONE;\n//         let should_be_two = one + one;\n//         assert_eq!(should_be_two, two);\n//     }\n\n//     #[allow(non_snake_case)]\n//     #[test]\n//     fn impl_mul() {\n//         let should_be_X_times_Y = X * Y;\n//         assert_eq!(should_be_X_times_Y, X_TIMES_Y);\n//     }\n\n//     #[allow(non_snake_case)]\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn impl_product() {\n//         // Test that product works for non-empty iterators\n//         let X_Y_vector = [X, Y];\n//         let should_be_X_times_Y: Scalar = X_Y_vector.iter().product();\n//         assert_eq!(should_be_X_times_Y, X_TIMES_Y);\n\n//         // Test that product works for the empty iterator\n//         let one = Scalar::ONE;\n//         let empty_vector = [];\n//         let should_be_one: Scalar = empty_vector.iter().product();\n//         assert_eq!(should_be_one, one);\n\n//         // Test that product works for iterators where Item = Scalar\n//         let xs = [Scalar::from(2u64); 10];\n//         let ys = [Scalar::from(3u64); 10];\n//         // now zs is an iterator with Item = Scalar\n//         let zs = xs.iter().zip(ys.iter()).map(|(x, y)| x * y);\n\n//         let x_prod: Scalar = xs.iter().product();\n//         let y_prod: Scalar = ys.iter().product();\n//         let z_prod: Scalar = zs.product();\n\n//         assert_eq!(x_prod, Scalar::from(1024u64));\n//         assert_eq!(y_prod, Scalar::from(59049u64));\n//         assert_eq!(z_prod, Scalar::from(60466176u64));\n//         assert_eq!(x_prod * y_prod, z_prod);\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn impl_sum() {\n//         // Test that sum works for non-empty iterators\n//         let two = Scalar::from(2u64);\n//         let one_vector = [Scalar::ONE, Scalar::ONE];\n//         let should_be_two: Scalar = one_vector.iter().sum();\n//         assert_eq!(should_be_two, two);\n\n//         // Test that sum works for the empty iterator\n//         let zero = Scalar::ZERO;\n//         let empty_vector = [];\n//         let should_be_zero: Scalar = empty_vector.iter().sum();\n//         assert_eq!(should_be_zero, zero);\n\n//         // Test that sum works for owned types\n//         let xs = [Scalar::from(1u64); 10];\n//         let ys = [Scalar::from(2u64); 10];\n//         // now zs is an iterator with Item = Scalar\n//         let zs = xs.iter().zip(ys.iter()).map(|(x, y)| x + y);\n\n//         let x_sum: Scalar = xs.iter().sum();\n//         let y_sum: Scalar = ys.iter().sum();\n//         let z_sum: Scalar = zs.sum();\n\n//         assert_eq!(x_sum, Scalar::from(10u64));\n//         assert_eq!(y_sum, Scalar::from(20u64));\n//         assert_eq!(z_sum, Scalar::from(30u64));\n//         assert_eq!(x_sum + y_sum, z_sum);\n//     }\n\n//     #[test]\n//     fn square() {\n//         let expected = X * X;\n//         let actual = X.unpack().square().pack();\n//         for i in 0..32 {\n//             assert!(expected[i] == actual[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn reduce() {\n//         let biggest = Scalar::from_bytes_mod_order([0xff; 32]);\n//         assert_eq!(biggest, CANONICAL_2_256_MINUS_1);\n//     }\n\n//     #[test]\n//     fn from_bytes_mod_order_wide() {\n//         let mut bignum = [0u8; 64];\n//         // set bignum = x + 2^256x\n//         for i in 0..32 {\n//             bignum[i] = X[i];\n//             bignum[32 + i] = X[i];\n//         }\n//         // 3958878930004874126169954872055634648693766179881526445624823978500314864344\n//         // = x + 2^256x (mod l)\n//         let reduced = Scalar {\n//             bytes: [\n//                 216, 154, 179, 139, 210, 121, 2, 71, 69, 99, 158, 216, 23, 173, 63, 100, 204, 0,\n//                 91, 50, 219, 153, 57, 249, 28, 82, 31, 197, 100, 165, 192, 8,\n//             ],\n//         };\n//         let test_red = Scalar::from_bytes_mod_order_wide(&bignum);\n//         for i in 0..32 {\n//             assert!(test_red[i] == reduced[i]);\n//         }\n//     }\n\n//     #[allow(non_snake_case)]\n//     #[test]\n//     fn invert() {\n//         let inv_X = X.invert();\n//         assert_eq!(inv_X, XINV);\n//         let should_be_one = inv_X * X;\n//         assert_eq!(should_be_one, Scalar::ONE);\n//     }\n\n//     // Negating a scalar twice should result in the original scalar.\n//     #[allow(non_snake_case)]\n//     #[test]\n//     fn neg_twice_is_identity() {\n//         let negative_X = -&X;\n//         let should_be_X = -&negative_X;\n\n//         assert_eq!(should_be_X, X);\n//     }\n\n//     #[test]\n//     fn to_bytes_from_bytes_roundtrips() {\n//         let unpacked = X.unpack();\n//         let bytes = unpacked.to_bytes();\n//         let should_be_unpacked = UnpackedScalar::from_bytes(&bytes);\n\n//         assert_eq!(should_be_unpacked.limbs, unpacked.limbs);\n//     }\n\n//     #[test]\n//     fn montgomery_reduce_matches_from_bytes_mod_order_wide() {\n//         let mut bignum = [0u8; 64];\n\n//         // set bignum = x + 2^256x\n//         for i in 0..32 {\n//             bignum[i] = X[i];\n//             bignum[32 + i] = X[i];\n//         }\n//         // x + 2^256x (mod l)\n//         //         = 3958878930004874126169954872055634648693766179881526445624823978500314864344\n//         let expected = Scalar {\n//             bytes: [\n//                 216, 154, 179, 139, 210, 121, 2, 71, 69, 99, 158, 216, 23, 173, 63, 100, 204, 0,\n//                 91, 50, 219, 153, 57, 249, 28, 82, 31, 197, 100, 165, 192, 8,\n//             ],\n//         };\n//         let reduced = Scalar::from_bytes_mod_order_wide(&bignum);\n\n//         // The reduced scalar should match the expected\n//         assert_eq!(reduced.bytes, expected.bytes);\n\n//         //  (x + 2^256x) * R\n//         let interim =\n//             UnpackedScalar::mul_internal(&UnpackedScalar::from_bytes_wide(&bignum), &constants::R);\n//         // ((x + 2^256x) * R) / R  (mod l)\n//         let montgomery_reduced = UnpackedScalar::montgomery_reduce(&interim);\n\n//         // The Montgomery reduced scalar should match the reduced one, as well as the expected\n//         assert_eq!(montgomery_reduced.limbs, reduced.unpack().limbs);\n//         assert_eq!(montgomery_reduced.limbs, expected.unpack().limbs)\n//     }\n\n//     #[test]\n//     fn canonical_decoding() {\n//         // canonical encoding of 1667457891\n//         let canonical_bytes = [\n//             99, 99, 99, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//             0, 0, 0, 0,\n//         ];\n\n//         // encoding of\n//         //   7265385991361016183439748078976496179028704920197054998554201349516117938192\n//         // = 28380414028753969466561515933501938171588560817147392552250411230663687203 (mod l)\n//         // non_canonical because unreduced mod l\n//         let non_canonical_bytes_because_unreduced = [16; 32];\n\n//         // encoding with high bit set, to check that the parser isn't pre-masking the high bit\n//         let non_canonical_bytes_because_highbit = [\n//             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//             0, 0, 128,\n//         ];\n\n//         assert!(bool::from(\n//             Scalar::from_canonical_bytes(canonical_bytes).is_some()\n//         ));\n//         assert!(bool::from(\n//             Scalar::from_canonical_bytes(non_canonical_bytes_because_unreduced).is_none()\n//         ));\n//         assert!(bool::from(\n//             Scalar::from_canonical_bytes(non_canonical_bytes_because_highbit).is_none()\n//         ));\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"serde\")]\n//     fn serde_bincode_scalar_roundtrip() {\n//         use bincode;\n//         let encoded = bincode::serialize(&X).unwrap();\n//         let parsed: Scalar = bincode::deserialize(&encoded).unwrap();\n//         assert_eq!(parsed, X);\n\n//         // Check that the encoding is 32 bytes exactly\n//         assert_eq!(encoded.len(), 32);\n\n//         // Check that the encoding itself matches the usual one\n//         assert_eq!(X, bincode::deserialize(X.as_bytes()).unwrap(),);\n//     }\n\n//     #[cfg(all(debug_assertions, feature = \"alloc\"))]\n//     #[test]\n//     #[should_panic]\n//     fn batch_invert_with_a_zero_input_panics() {\n//         let mut xs = vec![Scalar::ONE; 16];\n//         xs[3] = Scalar::ZERO;\n//         // This should panic in debug mode.\n//         Scalar::batch_invert(&mut xs);\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn batch_invert_empty() {\n//         assert_eq!(Scalar::ONE, Scalar::batch_invert(&mut []));\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn batch_invert_consistency() {\n//         let mut x = Scalar::from(1u64);\n//         let mut v1: Vec<_> = (0..16)\n//             .map(|_| {\n//                 let tmp = x;\n//                 x = x + x;\n//                 tmp\n//             })\n//             .collect();\n//         let v2 = v1.clone();\n\n//         let expected: Scalar = v1.iter().product();\n//         let expected = expected.invert();\n//         let ret = Scalar::batch_invert(&mut v1);\n//         assert_eq!(ret, expected);\n\n//         for (a, b) in v1.iter().zip(v2.iter()) {\n//             assert_eq!(a * b, Scalar::ONE);\n//         }\n//     }\n\n//     #[cfg(feature = \"precomputed-tables\")]\n//     fn test_pippenger_radix_iter(scalar: Scalar, w: usize) {\n//         let digits_count = Scalar::to_radix_2w_size_hint(w);\n//         let digits = scalar.as_radix_2w(w);\n\n//         let radix = Scalar::from((1 << w) as u64);\n//         let mut term = Scalar::ONE;\n//         let mut recovered_scalar = Scalar::ZERO;\n//         for digit in &digits[0..digits_count] {\n//             let digit = *digit;\n//             if digit != 0 {\n//                 let sdigit = if digit < 0 {\n//                     -Scalar::from((-(digit as i64)) as u64)\n//                 } else {\n//                     Scalar::from(digit as u64)\n//                 };\n//                 recovered_scalar += term * sdigit;\n//             }\n//             term *= radix;\n//         }\n//         // When the input is unreduced, we may only recover the scalar mod l.\n//         assert_eq!(recovered_scalar, scalar.reduce());\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"precomputed-tables\")]\n//     fn test_pippenger_radix() {\n//         use core::iter;\n//         // For each valid radix it tests that 1000 random-ish scalars can be restored\n//         // from the produced representation precisely.\n//         let cases = (2..100)\n//             .map(|s| Scalar::from(s as u64).invert())\n//             // The largest unreduced scalar, s = 2^255-1. This is not reduced mod l. Scalar mult\n//             // still works though.\n//             .chain(iter::once(LARGEST_UNREDUCED_SCALAR));\n\n//         for scalar in cases {\n//             test_pippenger_radix_iter(scalar, 6);\n//             test_pippenger_radix_iter(scalar, 7);\n//             test_pippenger_radix_iter(scalar, 8);\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn test_read_le_u64_into() {\n//         let cases: &[(&[u8], &[u64])] = &[\n//             (\n//                 &[0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F, 0xF0],\n//                 &[0xF00F_F11F_0110_EFFE],\n//             ),\n//             (\n//                 &[\n//                     0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A,\n//                     0xBC, 0xDE, 0xF0,\n//                 ],\n//                 &[0xF00F_F11F_0110_EFFE, 0xF0DE_BC9A_7856_3412],\n//             ),\n//         ];\n\n//         for (src, expected) in cases {\n//             let mut dst = vec![0; expected.len()];\n//             read_le_u64_into(src, &mut dst);\n\n//             assert_eq!(&dst, expected, \"Expected {:x?} got {:x?}\", expected, dst);\n//         }\n//     }\n\n//     // Tests consistency of From<{integer}> impls for Scalar\n//     #[test]\n//     fn test_scalar_from_int() {\n//         let s1 = Scalar::ONE;\n\n//         // For `x` in `u8`, `u16`, `u32`, `u64`, and `u128`, check that\n//         // `Scalar::from(x + 1) == Scalar::from(x) + Scalar::from(1)`\n\n//         let x = 0x23u8;\n//         let sx = Scalar::from(x);\n//         assert_eq!(sx + s1, Scalar::from(x + 1));\n\n//         let x = 0x2323u16;\n//         let sx = Scalar::from(x);\n//         assert_eq!(sx + s1, Scalar::from(x + 1));\n\n//         let x = 0x2323_2323u32;\n//         let sx = Scalar::from(x);\n//         assert_eq!(sx + s1, Scalar::from(x + 1));\n\n//         let x = 0x2323_2323_2323_2323u64;\n//         let sx = Scalar::from(x);\n//         assert_eq!(sx + s1, Scalar::from(x + 1));\n\n//         let x = 0x2323_2323_2323_2323_2323_2323_2323_2323u128;\n//         let sx = Scalar::from(x);\n//         assert_eq!(sx + s1, Scalar::from(x + 1));\n//     }\n\n//     #[cfg(feature = \"group\")]\n//     #[test]\n//     fn ff_constants() {\n//         assert_eq!(Scalar::from(2u64) * Scalar::TWO_INV, Scalar::ONE);\n\n//         assert_eq!(\n//             Scalar::ROOT_OF_UNITY * Scalar::ROOT_OF_UNITY_INV,\n//             Scalar::ONE,\n//         );\n\n//         // ROOT_OF_UNITY^{2^s} mod m == 1\n//         assert_eq!(\n//             Scalar::ROOT_OF_UNITY.pow(&[1u64 << Scalar::S, 0, 0, 0]),\n//             Scalar::ONE,\n//         );\n\n//         // DELTA^{t} mod m == 1\n//         assert_eq!(\n//             Scalar::DELTA.pow(&[\n//                 0x9604_98c6_973d_74fb,\n//                 0x0537_be77_a8bd_e735,\n//                 0x0000_0000_0000_0000,\n//                 0x0400_0000_0000_0000,\n//             ]),\n//             Scalar::ONE,\n//         );\n//     }\n\n//     #[cfg(feature = \"group\")]\n//     #[test]\n//     fn ff_impls() {\n//         assert!(bool::from(Scalar::ZERO.is_even()));\n//         assert!(bool::from(Scalar::ONE.is_odd()));\n//         assert!(bool::from(Scalar::from(2u64).is_even()));\n//         assert!(bool::from(Scalar::DELTA.is_even()));\n\n//         assert!(bool::from(Field::invert(&Scalar::ZERO).is_none()));\n//         assert_eq!(Field::invert(&X).unwrap(), XINV);\n\n//         let x_sq = X.square();\n//         // We should get back either the positive or negative root.\n//         assert!([X, -X].contains(&x_sq.sqrt().unwrap()));\n\n//         assert_eq!(Scalar::from_repr_vartime(X.to_repr()), Some(X));\n//         assert_eq!(Scalar::from_repr_vartime([0xff; 32]), None);\n\n//         assert_eq!(Scalar::from_repr(X.to_repr()).unwrap(), X);\n//         assert!(bool::from(Scalar::from_repr([0xff; 32]).is_none()));\n//     }\n\n//     #[test]\n//     #[should_panic]\n//     fn test_read_le_u64_into_should_panic_on_bad_input() {\n//         let mut dst = [0_u64; 1];\n//         // One byte short\n//         read_le_u64_into(&[0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F], &mut dst);\n//     }\n\n//     #[test]\n//     fn test_scalar_clamp() {\n//         let input = A_SCALAR.bytes;\n//         let expected = [\n//             0x18, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n//             0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n//             0x23, 0x76, 0xef, 0x49,\n//         ];\n//         let actual = clamp_integer(input);\n//         assert_eq!(actual, expected);\n\n//         let expected = [\n//             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//             0, 0, 0x40,\n//         ];\n//         let actual = clamp_integer([0; 32]);\n//         assert_eq!(expected, actual);\n//         let expected = [\n//             0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//             0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//             0xff, 0xff, 0xff, 0x7f,\n//         ];\n//         let actual = clamp_integer([0xff; 32]);\n//         assert_eq!(actual, expected);\n\n//         assert_eq!(\n//             LARGEST_CLAMPED_INTEGER,\n//             clamp_integer(LARGEST_CLAMPED_INTEGER)\n//         );\n//     }\n\n//     // Check that a * b == a.reduce() * a.reduce() for ANY scalars a,b, even ones that violate\n//     // invariant #1, i.e., a,b > 2^255. Old versions of ed25519-dalek did multiplication where a\n//     // was reduced and b was clamped and unreduced. This checks that was always well-defined.\n//     #[test]\n//     fn test_mul_reduction_invariance() {\n//         let mut rng = rand::rng();\n\n//         for _ in 0..10 {\n//             // Also define c that's clamped. We'll make sure that clamping doesn't affect\n//             // computation\n//             let (a, b, c) = {\n//                 let mut a_bytes = [0u8; 32];\n//                 let mut b_bytes = [0u8; 32];\n//                 let mut c_bytes = [0u8; 32];\n//                 rng.fill_bytes(&mut a_bytes);\n//                 rng.fill_bytes(&mut b_bytes);\n//                 rng.fill_bytes(&mut c_bytes);\n//                 (\n//                     Scalar { bytes: a_bytes },\n//                     Scalar { bytes: b_bytes },\n//                     Scalar {\n//                         bytes: clamp_integer(c_bytes),\n//                     },\n//                 )\n//             };\n\n//             // Make sure this is the same product no matter how you cut it\n//             let reduced_mul_ab = a.reduce() * b.reduce();\n//             let reduced_mul_ac = a.reduce() * c.reduce();\n//             assert_eq!(a * b, reduced_mul_ab);\n//             assert_eq!(a.reduce() * b, reduced_mul_ab);\n//             assert_eq!(a * b.reduce(), reduced_mul_ab);\n//             assert_eq!(a * c, reduced_mul_ac);\n//             assert_eq!(a.reduce() * c, reduced_mul_ac);\n//             assert_eq!(a * c.reduce(), reduced_mul_ac);\n//         }\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/scalar.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65053": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis agora lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Internal macros.\n\n/// Define borrow and non-borrow variants of `Add`.\nmacro_rules! define_add_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty, Output = $out:ty) => {\n        impl<'b> Add<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: &'b $rhs) -> $out {\n                &self + rhs\n            }\n        }\n\n        impl<'a> Add<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                self + &rhs\n            }\n        }\n\n        impl Add<$rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                &self + &rhs\n            }\n        }\n    };\n}\n\n/// Define non-borrow variants of `AddAssign`.\nmacro_rules! define_add_assign_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl AddAssign<$rhs> for $lhs {\n            fn add_assign(&mut self, rhs: $rhs) {\n                *self += &rhs;\n            }\n        }\n    };\n}\n\n/// Define borrow and non-borrow variants of `Sub`.\nmacro_rules! define_sub_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty, Output = $out:ty) => {\n        impl<'b> Sub<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: &'b $rhs) -> $out {\n                &self - rhs\n            }\n        }\n\n        impl<'a> Sub<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                self - &rhs\n            }\n        }\n\n        impl Sub<$rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                &self - &rhs\n            }\n        }\n    };\n}\n\n/// Define non-borrow variants of `SubAssign`.\nmacro_rules! define_sub_assign_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl SubAssign<$rhs> for $lhs {\n            fn sub_assign(&mut self, rhs: $rhs) {\n                *self -= &rhs;\n            }\n        }\n    };\n}\n\n/// Define borrow and non-borrow variants of `Mul`.\nmacro_rules! define_mul_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty, Output = $out:ty) => {\n        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }\n\n        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }\n\n        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }\n    };\n}\n\n/// Define non-borrow variants of `MulAssign`.\nmacro_rules! define_mul_assign_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl MulAssign<$rhs> for $lhs {\n            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }\n        }\n    };\n}\n",
    "filename": "curve25519-dalek/src/macros.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65054": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis agora lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Isis Agora Lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Field arithmetic modulo \\\\(p = 2\\^{255} - 19\\\\).\n//!\n//! The `curve25519_dalek::field` module provides a type alias\n//! `curve25519_dalek::field::FieldElement` to a field element type\n//! defined in the `backend` module; either `FieldElement51` or\n//! `FieldElement2625`.\n//!\n//! Field operations defined in terms of machine\n//! operations, such as field multiplication or squaring, are defined in\n//! the backend implementation.\n//!\n//! Field operations defined in terms of other field operations, such as\n//! field inversion or square roots, are defined here.\n\n#![allow(unused_qualifications)]\n\nuse cfg_if::cfg_if;\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\nuse crate::backend;\nuse crate::constants;\n\n// #[cfg(feature = \"digest\")]\n// use digest::{\n//     Digest, FixedOutput, HashMarker,\n//     array::{Array, typenum::U64},\n//     block_api::BlockSizeUser,\n//     typenum::{IsGreater, True},\n// };\n\ncfg_if! {\n    if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n        /// A `FieldElement` represents an element of the field\n        /// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n        ///\n        /// The `FieldElement` type is an alias for one of the platform-specific\n        /// implementations.\n        ///\n        /// Using formally-verified field arithmetic from fiat-crypto.\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        pub(crate) type FieldElement = backend::serial::fiat_u32::field::FieldElement2625;\n\n        /// A `FieldElement` represents an element of the field\n        /// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n        ///\n        /// The `FieldElement` type is an alias for one of the platform-specific\n        /// implementations.\n        ///\n        /// Using formally-verified field arithmetic from fiat-crypto.\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        pub(crate) type FieldElement = backend::serial::fiat_u64::field::FieldElement51;\n    } else if #[cfg(curve25519_dalek_bits = \"64\")] {\n        /// A `FieldElement` represents an element of the field\n        /// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n        ///\n        /// The `FieldElement` type is an alias for one of the platform-specific\n        /// implementations.\n        pub(crate) type FieldElement = backend::serial::u64::field::FieldElement51;\n    } else {\n        /// A `FieldElement` represents an element of the field\n        /// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n        ///\n        /// The `FieldElement` type is an alias for one of the platform-specific\n        /// implementations.\n        pub(crate) type FieldElement = backend::serial::u32::field::FieldElement2625;\n    }\n}\n\nimpl Eq for FieldElement {}\n\nimpl PartialEq for FieldElement {\n    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl ConstantTimeEq for FieldElement {\n    /// Test equality between two `FieldElement`s.  Since the\n    /// internal representation is not canonical, the field elements\n    /// are normalized to wire format before comparison.\n    fn ct_eq(&self, other: &FieldElement) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }\n}\n\nimpl FieldElement {\n    /// Load a `FieldElement` from 64 bytes, by reducing modulo q.\n    // #[cfg(feature = \"digest\")]\n    // pub(crate) fn from_bytes_wide(bytes: &[u8; 64]) -> Self {\n    //     let mut fl = [0u8; 32];\n    //     let mut gl = [0u8; 32];\n    //     fl.copy_from_slice(&bytes[..32]);\n    //     gl.copy_from_slice(&bytes[32..]);\n    //     // Mask off the top bits of both halves, since from_bytes masks them off anyway. We'll add\n    //     // them back in later.\n    //     let fl_top_bit = (fl[31] >> 7) as u16;\n    //     let gl_top_bit = (gl[31] >> 7) as u16;\n    //     fl[31] &= 0x7f;\n    //     gl[31] &= 0x7f;\n\n    //     // Interpret both sides as field elements\n    //     let mut fe_f = Self::from_bytes(&fl);\n    //     let fe_g = Self::from_bytes(&gl);\n\n    //     // The full field elem is now fe_f + 2 fl_top_bit + 2 fe_g + 2 gl_top_bit\n\n    //     // Add the masked off bits back to fe_f. fl_top_bit, if set, is 2^255  19 (mod q).\n    //     // gl_top_bit, if set, is 2^511  722 (mod q)\n    //     let top_bits_sum = {\n    //         // This only need to be a u16 because the max value is 741\n    //         let addend: u16 = fl_top_bit * 19 + gl_top_bit * 722;\n    //         let mut addend_bytes = [0u8; 32];\n    //         addend_bytes[..2].copy_from_slice(&addend.to_le_bytes());\n    //         Self::from_bytes(&addend_bytes)\n    //     };\n    //     fe_f += &top_bits_sum;\n\n    //     // Now add the high half into fe_f. The RHS is multiplied by 2^256  38 (mod q)\n    //     const THIRTY_EIGHT: FieldElement = FieldElement::from_bytes(&[\n    //         38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    //         0, 0, 0,\n    //     ]);\n    //     fe_f += &(&THIRTY_EIGHT * &fe_g);\n\n    //     fe_f\n    // }\n\n    /// Determine if this `FieldElement` is negative, in the sense\n    /// used in the ed25519 paper: `x` is negative if the low bit is\n    /// set.\n    ///\n    /// # Return\n    ///\n    /// If negative, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_negative(&self) -> Choice {\n        let bytes = self.to_bytes();\n        (bytes[0] & 1).into()\n    }\n\n    /// Determine if this `FieldElement` is zero.\n    ///\n    /// # Return\n    ///\n    /// If zero, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_zero(&self) -> Choice {\n        let zero = [0u8; 32];\n        let bytes = self.to_bytes();\n\n        bytes.ct_eq(&zero)\n    }\n\n    /// Compute (self^(2^250-1), self^11), used as a helper function\n    /// within invert() and pow22523().\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    fn pow22501(&self) -> (FieldElement, FieldElement) {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        let t0  = self.square();           // 1         e_0 = 2^1\n        let t1  = t0.square().square();    // 3         e_1 = 2^3\n        let t2  = self * &t1;              // 3,0       e_2 = 2^3 + 2^0\n        let t3  = &t0 * &t2;               // 3,1,0\n        let t4  = t3.square();             // 4,2,1\n        let t5  = &t2 * &t4;               // 4,3,2,1,0\n        let t6  = t5.pow2k(5);             // 9,8,7,6,5\n        let t7  = &t6 * &t5;               // 9,8,7,6,5,4,3,2,1,0\n        let t8  = t7.pow2k(10);            // 19..10\n        let t9  = &t8 * &t7;               // 19..0\n        let t10 = t9.pow2k(20);            // 39..20\n        let t11 = &t10 * &t9;              // 39..0\n        let t12 = t11.pow2k(10);           // 49..10\n        let t13 = &t12 * &t7;              // 49..0\n        let t14 = t13.pow2k(50);           // 99..50\n        let t15 = &t14 * &t13;             // 99..0\n        let t16 = t15.pow2k(100);          // 199..100\n        let t17 = &t16 * &t15;             // 199..0\n        let t18 = t17.pow2k(50);           // 249..50\n        let t19 = &t18 * &t13;             // 249..0\n\n        (t19, t3)\n    }\n\n    /// Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n    ///\n    /// When an input `FieldElement` is zero, its value is unchanged.\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn batch_invert(inputs: &mut [FieldElement]) {\n        // Montgomerys Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        let n = inputs.len();\n        let mut scratch = vec![FieldElement::ONE; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = FieldElement::ONE;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        assert!(bool::from(!acc.is_zero()));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n    }\n\n    /// Given a nonzero field element, compute its inverse.\n    ///\n    /// The inverse is computed as self^(p-2), since\n    /// x^(p-2)x = x^(p-1) = 1 (mod p).\n    ///\n    /// This function returns zero on input zero.\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    pub(crate) fn invert(&self) -> FieldElement {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);            // 254..5\n        let t21 = &t20 * &t3;              // 254..5,3,1,0\n\n        t21\n    }\n\n    /// Raise this field element to the power (p-5)/8 = 2^252 -3.\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    fn pow_p58(&self) -> FieldElement {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();    // 249..0\n        let t20 = t19.pow2k(2);            // 251..2\n        let t21 = self * &t20;             // 251..2,0\n\n        t21\n    }\n\n    /// Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`\n    /// or `sqrt(i*u/v)` in constant time.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(u/v))  ` if `v` is nonzero and `u/v` is square;\n    /// - `(Choice(1), zero)        ` if `u` is zero;\n    /// - `(Choice(0), zero)        ` if `v` is zero and `u` is nonzero;\n    /// - `(Choice(0), +sqrt(i*u/v))` if `u/v` is nonsquare (so `i*u/v` is square).\n    ///\n    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (Choice, FieldElement) {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(), we can compute  = ^((p+3)/8).\n        // Then ^2 = , so multiplying  by sqrt(-1) if necessary\n        // gives sqrt().\n        //\n        // To compute 1/sqrt(), we observe that\n        //    1/ = ^(p-1 - (p+3)/8) = ^((7p-11)/8)\n        //                            = ^3 * (^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = u/v,\n        //                                     so vr^2 = u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n        let flipped_sign_sqrt = check.ct_eq(&(-u));\n        let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        r.conditional_negate(r_is_negative);\n\n        let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n\n        (was_nonzero_square, r)\n    }\n\n    /// Attempt to compute `sqrt(1/self)` in constant time.\n    ///\n    /// Convenience wrapper around `sqrt_ratio_i`.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(1/self))  ` if `self` is a nonzero square;\n    /// - `(Choice(0), zero)           ` if `self` is zero;\n    /// - `(Choice(0), +sqrt(i/self))  ` if `self` is a nonzero nonsquare;\n    ///\n    pub(crate) fn invsqrt(&self) -> (Choice, FieldElement) {\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }\n\n    // #[cfg(feature = \"digest\")]\n    // /// Perform hashing to a [`FieldElement`], per the\n    // /// [`hash_to_curve`](https://www.rfc-editor.org/rfc/rfc9380.html#section-5.2) specification.\n    // /// Uses the suite `edwards25519_XMD:SHA-512_ELL2_NU_`. The input is the concatenation of the\n    // /// elements of `bytes`. Likewise for the domain separator with `domain_sep`. At least one\n    // /// element of `domain_sep`, MUST be nonempty, and the concatenation MUST NOT exceed 255 bytes.\n    // ///\n    // /// # Panics\n    // /// Panics if `domain_sep.collect().len() == 0` or `> 255`\n    // pub fn hash_to_field<D>(bytes: &[&[u8]], domain_sep: &[&[u8]]) -> Self\n    // where\n    //     D: BlockSizeUser + Default + FixedOutput<OutputSize = U64> + HashMarker,\n    //     D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    // {\n    //     let l_i_b_str = 48u16.to_be_bytes();\n    //     let z_pad = Array::<u8, D::BlockSize>::default();\n\n    //     let mut hasher = D::new().chain_update(z_pad);\n\n    //     for slice in bytes {\n    //         hasher = hasher.chain_update(slice);\n    //     }\n\n    //     hasher = hasher.chain_update(l_i_b_str).chain_update([0u8]);\n\n    //     let mut domain_sep_len = 0usize;\n    //     for slice in domain_sep {\n    //         hasher = hasher.chain_update(slice);\n    //         domain_sep_len += slice.len();\n    //     }\n\n    //     let domain_sep_len = u8::try_from(domain_sep_len)\n    //         .expect(\"Unexpected overflow from domain separator's size.\");\n    //     assert_ne!(\n    //         domain_sep_len, 0,\n    //         \"Domain separator MUST have nonzero length.\"\n    //     );\n\n    //     let b_0 = hasher.chain_update([domain_sep_len]).finalize();\n\n    //     let mut hasher = D::new().chain_update(b_0.as_slice()).chain_update([1u8]);\n\n    //     for slice in domain_sep {\n    //         hasher = hasher.chain_update(slice)\n    //     }\n\n    //     let b_1 = hasher.chain_update([domain_sep_len]).finalize();\n\n    //     // 5.2, we only generate count * m * L = 1 * 1 * (256 + 128)/8 = 48 bytes\n    //     let mut bytes_wide = [0u8; 64];\n    //     bytes_wide[..48].copy_from_slice(&b_1.as_slice()[..48]);\n    //     bytes_wide[..48].reverse();\n\n    //     FieldElement::from_bytes_wide(&bytes_wide)\n    // }\n}\n\n// #[cfg(test)]\n// mod test {\n//     use crate::field::*;\n\n//     /// Random element a of GF(2^255-19), from Sage\n//     /// a = 1070314506888354081329385823235218444233221\\\n//     ///     2228051251926706380353716438957572\n//     static A_BYTES: [u8; 32] = [\n//         0x04, 0xfe, 0xdf, 0x98, 0xa7, 0xfa, 0x0a, 0x68, 0x84, 0x92, 0xbd, 0x59, 0x08, 0x07, 0xa7,\n//         0x03, 0x9e, 0xd1, 0xf6, 0xf2, 0xe1, 0xd9, 0xe2, 0xa4, 0xa4, 0x51, 0x47, 0x36, 0xf3, 0xc3,\n//         0xa9, 0x17,\n//     ];\n\n//     /// Byte representation of a**2\n//     static ASQ_BYTES: [u8; 32] = [\n//         0x75, 0x97, 0x24, 0x9e, 0xe6, 0x06, 0xfe, 0xab, 0x24, 0x04, 0x56, 0x68, 0x07, 0x91, 0x2d,\n//         0x5d, 0x0b, 0x0f, 0x3f, 0x1c, 0xb2, 0x6e, 0xf2, 0xe2, 0x63, 0x9c, 0x12, 0xba, 0x73, 0x0b,\n//         0xe3, 0x62,\n//     ];\n\n//     /// Byte representation of 1/a\n//     static AINV_BYTES: [u8; 32] = [\n//         0x96, 0x1b, 0xcd, 0x8d, 0x4d, 0x5e, 0xa2, 0x3a, 0xe9, 0x36, 0x37, 0x93, 0xdb, 0x7b, 0x4d,\n//         0x70, 0xb8, 0x0d, 0xc0, 0x55, 0xd0, 0x4c, 0x1d, 0x7b, 0x90, 0x71, 0xd8, 0xe9, 0xb6, 0x18,\n//         0xe6, 0x30,\n//     ];\n\n//     /// Byte representation of a^((p-5)/8)\n//     static AP58_BYTES: [u8; 32] = [\n//         0x6a, 0x4f, 0x24, 0x89, 0x1f, 0x57, 0x60, 0x36, 0xd0, 0xbe, 0x12, 0x3c, 0x8f, 0xf5, 0xb1,\n//         0x59, 0xe0, 0xf0, 0xb8, 0x1b, 0x20, 0xd2, 0xb5, 0x1f, 0x15, 0x21, 0xf9, 0xe3, 0xe1, 0x61,\n//         0x21, 0x55,\n//     ];\n\n//     #[test]\n//     fn a_mul_a_vs_a_squared_constant() {\n//         let a = FieldElement::from_bytes(&A_BYTES);\n//         let asq = FieldElement::from_bytes(&ASQ_BYTES);\n//         assert_eq!(asq, &a * &a);\n//     }\n\n//     #[test]\n//     fn a_square_vs_a_squared_constant() {\n//         let a = FieldElement::from_bytes(&A_BYTES);\n//         let asq = FieldElement::from_bytes(&ASQ_BYTES);\n//         assert_eq!(asq, a.square());\n//     }\n\n//     #[test]\n//     fn a_square2_vs_a_squared_constant() {\n//         let a = FieldElement::from_bytes(&A_BYTES);\n//         let asq = FieldElement::from_bytes(&ASQ_BYTES);\n//         assert_eq!(a.square2(), &asq + &asq);\n//     }\n\n//     #[test]\n//     fn a_invert_vs_inverse_of_a_constant() {\n//         let a = FieldElement::from_bytes(&A_BYTES);\n//         let ainv = FieldElement::from_bytes(&AINV_BYTES);\n//         let should_be_inverse = a.invert();\n//         assert_eq!(ainv, should_be_inverse);\n//         assert_eq!(FieldElement::ONE, &a * &should_be_inverse);\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn batch_invert_a_matches_nonbatched() {\n//         let a = FieldElement::from_bytes(&A_BYTES);\n//         let ap58 = FieldElement::from_bytes(&AP58_BYTES);\n//         let asq = FieldElement::from_bytes(&ASQ_BYTES);\n//         let ainv = FieldElement::from_bytes(&AINV_BYTES);\n//         let a0 = &a - &a;\n//         let a2 = &a + &a;\n//         let a_list = vec![a, ap58, asq, ainv, a0, a2];\n//         let mut ainv_list = a_list.clone();\n//         FieldElement::batch_invert(&mut ainv_list[..]);\n//         for i in 0..6 {\n//             assert_eq!(a_list[i].invert(), ainv_list[i]);\n//         }\n//     }\n\n//     #[test]\n//     fn sqrt_ratio_behavior() {\n//         let zero = FieldElement::ZERO;\n//         let one = FieldElement::ONE;\n//         let i = constants::SQRT_M1;\n//         let two = &one + &one; // 2 is nonsquare mod p.\n//         let four = &two + &two; // 4 is square mod p.\n\n//         // 0/0 should return (1, 0) since u is 0\n//         let (choice, sqrt) = FieldElement::sqrt_ratio_i(&zero, &zero);\n//         assert!(bool::from(choice));\n//         assert_eq!(sqrt, zero);\n//         assert!(bool::from(!sqrt.is_negative()));\n\n//         // 1/0 should return (0, 0) since v is 0, u is nonzero\n//         let (choice, sqrt) = FieldElement::sqrt_ratio_i(&one, &zero);\n//         assert!(bool::from(!choice));\n//         assert_eq!(sqrt, zero);\n//         assert!(bool::from(!sqrt.is_negative()));\n\n//         // 2/1 is nonsquare, so we expect (0, sqrt(i*2))\n//         let (choice, sqrt) = FieldElement::sqrt_ratio_i(&two, &one);\n//         assert!(bool::from(!choice));\n//         assert_eq!(sqrt.square(), &two * &i);\n//         assert!(bool::from(!sqrt.is_negative()));\n\n//         // 4/1 is square, so we expect (1, sqrt(4))\n//         let (choice, sqrt) = FieldElement::sqrt_ratio_i(&four, &one);\n//         assert!(bool::from(choice));\n//         assert_eq!(sqrt.square(), four);\n//         assert!(bool::from(!sqrt.is_negative()));\n\n//         // 1/4 is square, so we expect (1, 1/sqrt(4))\n//         let (choice, sqrt) = FieldElement::sqrt_ratio_i(&one, &four);\n//         assert!(bool::from(choice));\n//         assert_eq!(&sqrt.square() * &four, one);\n//         assert!(bool::from(!sqrt.is_negative()));\n//     }\n\n//     #[test]\n//     fn a_p58_vs_ap58_constant() {\n//         let a = FieldElement::from_bytes(&A_BYTES);\n//         let ap58 = FieldElement::from_bytes(&AP58_BYTES);\n//         assert_eq!(ap58, a.pow_p58());\n//     }\n\n//     #[test]\n//     fn equality() {\n//         let a = FieldElement::from_bytes(&A_BYTES);\n//         let ainv = FieldElement::from_bytes(&AINV_BYTES);\n//         assert!(a == a);\n//         assert!(a != ainv);\n//     }\n\n//     /// Notice that the last element has the high bit set, which\n//     /// should be ignored\n//     static B_BYTES: [u8; 32] = [\n//         113, 191, 169, 143, 91, 234, 121, 15, 241, 131, 217, 36, 230, 101, 92, 234, 8, 208, 170,\n//         251, 97, 127, 70, 210, 58, 23, 166, 87, 240, 169, 184, 178,\n//     ];\n\n//     #[test]\n//     fn from_bytes_highbit_is_ignored() {\n//         let mut cleared_bytes = B_BYTES;\n//         cleared_bytes[31] &= 127u8;\n//         let with_highbit_set = FieldElement::from_bytes(&B_BYTES);\n//         let without_highbit_set = FieldElement::from_bytes(&cleared_bytes);\n//         assert_eq!(without_highbit_set, with_highbit_set);\n//     }\n\n//     #[test]\n//     fn conditional_negate() {\n//         let one = FieldElement::ONE;\n//         let minus_one = FieldElement::MINUS_ONE;\n//         let mut x = one;\n//         x.conditional_negate(Choice::from(1));\n//         assert_eq!(x, minus_one);\n//         x.conditional_negate(Choice::from(0));\n//         assert_eq!(x, minus_one);\n//         x.conditional_negate(Choice::from(1));\n//         assert_eq!(x, one);\n//     }\n\n//     #[test]\n//     fn encoding_is_canonical() {\n//         // Encode 1 wrongly as 1 + (2^255 - 19) = 2^255 - 18\n//         let one_encoded_wrongly_bytes: [u8; 32] = [\n//             0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//             0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//             0xff, 0xff, 0xff, 0x7f,\n//         ];\n//         // Decode to a field element\n//         let one = FieldElement::from_bytes(&one_encoded_wrongly_bytes);\n//         // .. then check that the encoding is correct\n//         let one_bytes = one.to_bytes();\n//         assert_eq!(one_bytes[0], 1);\n//         for byte in &one_bytes[1..] {\n//             assert_eq!(*byte, 0);\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn batch_invert_empty() {\n//         FieldElement::batch_invert(&mut []);\n//     }\n\n//     // The following two consts were generated with the following sage script:\n//     //\n//     // import random\n//     //\n//     // F = GF(2**255 - 19)\n//     // # Use a seed to make sure we produce the same test vectors every time\n//     // random.seed(\"Ozamataz Buckshank\")\n//     //\n//     // # Generates test vectors, each of the form (input_bytes, reduced_field_elem_bytes),\n//     // # where input_bytes is length input_bytes_len\n//     // def gen_example(input_bytes_len):\n//     //     # Generate random bytes\n//     //     input_bytes = [random.randint(0, 255) for _ in range(input_bytes_len)]\n//     //\n//     //     # Now convert to a field element and get the reduced byte representation\n//     //     elem = F(int.from_bytes(input_bytes, byteorder='little'))\n//     //     reduced_bytes = list(int(elem).to_bytes(32, byteorder='little'))\n//     //\n//     //     # Format input and output as hex strings\n//     //     input_bytes_hex = ''.join(f'{byte:02x}' for byte in input_bytes)\n//     //     reduced_bytes_hex = ''.join(f'{byte:02x}' for byte in reduced_bytes)\n//     //     return f\"(\\\"{input_bytes_hex}\\\", \\\"{reduced_bytes_hex}\\\")\"\n//     //\n//     // print(\"SET 1: Input bytes are length 64\")\n//     // for _ in range(5):\n//     //     print(gen_example(64))\n//     //\n//     // print(\"SET 2: Input bytes are length 48\")\n//     // for _ in range(5):\n//     //     print(gen_example(48))\n\n//     /// Test vectors for FieldElement::from_bytes_wide. Elements are of the form (len-64 bytestring,\n//     /// reduced field element)\n//     #[cfg(feature = \"digest\")]\n//     const FROM_BYTES_WIDE_KAT_BIG: &[(&str, &str)] = &[\n//         (\n//             \"77b663085cac0e916f40dbeea5116f201816406e68ccf01b32a97162ae1d5bf95d0d01c2c72fbeeb27a63\\\n//             5b85b715d5ce6f74118a60a7aec53c798ad648a482f\",\n//             \"62b38bd402c4498f5cead14643e54dd649e20a0810610e36a73f1f27a0a81f7e\",\n//         ),\n//         (\n//             \"d437c75ec79886650243a79c62933bb307eb12ff16d05db4a6a8a877f4a91abb6eeb64d2e20519c021799\\\n//             3a1dc5639283a06639985a2c892208171503335afb5\",\n//             \"3d2ec29972783de9043e8b982278beaba9d7c5c3ebef257e7cd38168928f1c33\",\n//         ),\n//         (\n//             \"6daa9e1abe6c604fb6e841c04bf90a6ef88aef6b1eab17dd44f7207ef472cd2d54bac849f703e64f36e56\\\n//             77e7e86b82be7d26aa220daf1f208bb36dcc1a12338\",\n//             \"28546a0e7303852bc6eead8312f06eeb48d9ca87f60bfeec98ba402ebb751703\",\n//         ),\n//         (\n//             \"c3920e326dbf806a50105be78263c1dc9390fb4741587b250cd758c2bfa3ed70faedbbc5f9b1d024e00fe\\\n//             7d7daf796866853f42e72d638e6533c5eb5b7caf3c6\",\n//             \"40eaf38b802a7be1956ba7f3fe2d2ad717f23f40342deb5180cb55ae04bb1d79\",\n//         ),\n//         (\n//             \"23f143c72ead6c0f336b4e746a06921f0eb180002e8ce916d196de16216788617c6aeb90a074a85196f03\\\n//             81375011248927c1215e9ec65b382a6ec556fb3f504\",\n//             \"b1bf354a04fd6d2e8321c24ecb3d3ed2c42e3f21c7b60ab8374effd7a709011e\",\n//         ),\n//     ];\n\n//     /// Test vectors for FieldElement::from_bytes_wide. Elements are of the form (len-48 bytestring,\n//     /// reduced field element)\n//     #[cfg(feature = \"digest\")]\n//     const FROM_BYTES_WIDE_KAT_MEDIUM: &[(&str, &str)] = &[\n//         (\n//             \"82e9cbe4928e3d0bbf1f91824a91acfb30d929f7a2fa5cbcc967c63ea0f3357c29c19f1bc9dcad69d85c1\\\n//             c6265970685\",\n//             \"989582fe6c540cbbdee7c612570aa7ba44d929f7a2fa5cbcc967c63ea0f3357c\",\n//         ),\n//         (\n//             \"5480494df4fb3a3b19da17e1c8b9192ccb09ec76720321977079300c42c17b9e95b01eb37ffe7048fcd1c\\\n//             9e6094da6c4\",\n//             \"85b6d7e3e8c200fc8b050d234129c95ce809ec76720321977079300c42c17b1e\",\n//         ),\n//         (\n//             \"93ec8a480dde098f74bcd341ef4f248f6440cc6e631d7000784f66975a4fd628438bb1350ba4c1421fec3\\\n//             670decced06\",\n//             \"8598e540b737c87718c9fae9f3b870966540cc6e631d7000784f66975a4fd628\",\n//         ),\n//         (\n//             \"fd0154ff9a5c4c9ee4e8183c23db97018e0e6201a812f6d4faedda50652d51f65c110b9a1a100a3fc3ff1\\\n//             c4ea3cf22e4\",\n//             \"b895f8dc8dc0caf9dfdf66d460adc2deaf0e6201a812f6d4faedda50652d5176\",\n//         ),\n//         (\n//             \"0e829dc955e0a1e0dbda9849cb2022b295275782348bd6308b3d0c5836f3ca0130911a17fd54054c3a0f8\\\n//             b2486f8ce85\",\n//             \"2e0f8f37e77d6c29831d3db6b404db8ea9275782348bd6308b3d0c5836f3ca01\",\n//         ),\n//     ];\n\n//     #[cfg(feature = \"digest\")]\n//     #[test]\n//     fn from_bytes_wide() {\n//         // Do the 64-byte input ones first\n//         for (input_bytes, expected_reduced) in FROM_BYTES_WIDE_KAT_BIG {\n//             let reduce_fe = FieldElement::from_bytes_wide(\n//                 &hex::decode(input_bytes)\n//                     .unwrap()\n//                     .as_slice()\n//                     .try_into()\n//                     .unwrap(),\n//             );\n//             assert_eq!(\n//                 &reduce_fe.to_bytes(),\n//                 hex::decode(expected_reduced).unwrap().as_slice()\n//             );\n//         }\n\n//         // Now do the 48-byte inputs\n//         for (input_bytes, expected_reduced) in FROM_BYTES_WIDE_KAT_MEDIUM {\n//             let mut padded_input_bytes = [0u8; 64];\n//             padded_input_bytes[..48].copy_from_slice(&hex::decode(input_bytes).unwrap());\n//             let reduce_fe = FieldElement::from_bytes_wide(&padded_input_bytes);\n//             assert_eq!(\n//                 &reduce_fe.to_bytes(),\n//                 hex::decode(expected_reduced).unwrap().as_slice()\n//             );\n//         }\n//     }\n\n//     /// Hash to field test vectors from\n//     /// https://www.rfc-editor.org/rfc/rfc9380.html#name-edwards25519_xmdsha-512_ell2\n//     /// These are of the form (input_msg, output_field_elem)\n//     #[cfg(feature = \"digest\")]\n//     const RFC_HASH_TO_FIELD_KAT: &[(&[u8], &str)] = &[\n//         (\n//             b\"\",\n//             \"7f3e7fb9428103ad7f52db32f9df32505d7b427d894c5093f7a0f0374a30641d\"\n//         ),\n//         (\n//             b\"abc\",\n//             \"09cfa30ad79bd59456594a0f5d3a76f6b71c6787b04de98be5cd201a556e253b\"\n//         ),\n//         (\n//             b\"abcdef0123456789\",\n//             \"475ccff99225ef90d78cc9338e9f6a6bb7b17607c0c4428937de75d33edba941\",\n//         ),\n//         (\n//             b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\\\n//             qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\",\n//             \"049a1c8bd51bcb2aec339f387d1ff51428b88d0763a91bcdf6929814ac95d03d\"\n//         ),\n//         (\n//             b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n//             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n//             \"3cb0178a8137cefa5b79a3a57c858d7eeeaa787b2781be4a362a2f0750d24fa0\"\n//         )\n//     ];\n\n//     #[test]\n//     #[cfg(feature = \"digest\")]\n//     fn hash_to_field() {\n//         use sha2::Sha512;\n//         let dst = \"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n\n//         for (msg, expected_hash_hex) in RFC_HASH_TO_FIELD_KAT {\n//             let fe = FieldElement::hash_to_field::<Sha512>(&[msg], &[dst.as_bytes()]);\n//             let expected_fe = {\n//                 let mut expected_hash = hex::decode(expected_hash_hex).unwrap();\n//                 expected_hash.reverse();\n//                 FieldElement::from_bytes(&expected_hash.try_into().unwrap())\n//             };\n\n//             assert_eq!(fe, expected_fe);\n//         }\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/field.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65055": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2020 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\n//! An implementation of [Ristretto][ristretto_main], which provides a\n//! prime-order group.\n//!\n//! # The Ristretto Group\n//!\n//! Ristretto is a modification of Mike Hamburg's Decaf scheme to work\n//! with cofactor-\\\\(8\\\\) curves, such as Curve25519.\n//!\n//! The introduction of the Decaf paper, [_Decaf:\n//! Eliminating cofactors through point\n//! compression_](https://eprint.iacr.org/2015/673.pdf), notes that while\n//! most cryptographic systems require a group of prime order, most\n//! concrete implementations using elliptic curve groups fall short \n//! they either provide a group of prime order, but with incomplete or\n//! variable-time addition formulae (for instance, most Weierstrass\n//! models), or else they provide a fast and safe implementation of a\n//! group whose order is not quite a prime \\\\(q\\\\), but \\\\(hq\\\\) for a\n//! small cofactor \\\\(h\\\\) (for instance, Edwards curves, which have\n//! cofactor at least \\\\(4\\\\)).\n//!\n//! This abstraction mismatch is commonly handled by pushing the\n//! complexity upwards, adding ad-hoc protocol modifications.  But\n//! these modifications require careful analysis and are a recurring\n//! source of [vulnerabilities][cryptonote] and [design\n//! complications][ed25519_hkd].\n//!\n//! Instead, Decaf (and Ristretto) use a quotient group to implement a\n//! prime-order group using a non-prime-order curve.  This provides\n//! the correct abstraction for cryptographic systems, while retaining\n//! the speed and safety benefits of an Edwards curve.\n//!\n//! Decaf is named after the procedure which divides the effect of\n//! coffee by \\\\(4\\\\).  However, Curve25519 has a cofactor of\n//! \\\\(8\\\\).  To eliminate its cofactor, Ristretto restricts further;\n//! this [additional restriction][ristretto_coffee] gives the\n//! _Ristretto_ encoding.\n//!\n//! More details on why Ristretto is necessary can be found in the\n//! [Why Ristretto?][why_ristretto] section of the Ristretto website.\n//!\n//! Ristretto\n//! points are provided in `curve25519-dalek` by the `RistrettoPoint`\n//! struct.\n//!\n//! ## Encoding and Decoding\n//!\n//! Encoding is done by converting to and from a `CompressedRistretto`\n//! struct, which is a typed wrapper around `[u8; 32]`.\n//!\n//! The encoding is not batchable, but it is possible to\n//! double-and-encode in a batch using\n//! `RistrettoPoint::double_and_compress_batch`.\n//!\n//! ## Equality Testing\n//!\n//! Testing equality of points on an Edwards curve in projective\n//! coordinates requires an expensive inversion.  By contrast, equality\n//! checking in the Ristretto group can be done in projective\n//! coordinates without requiring an inversion, so it is much faster.\n//!\n//! The `RistrettoPoint` struct implements the\n//! [`subtle::ConstantTimeEq`] trait for constant-time equality\n//! checking, and also uses this to ensure `Eq` equality checking\n//! runs in constant time.\n//!\n//! ## Scalars\n//!\n//! Scalars are represented by the `Scalar` struct.  Each scalar has a\n//! canonical representative mod the group order.  To attempt to load\n//! a supposedly-canonical scalar, use\n//! `Scalar::from_canonical_bytes()`. To check whether a\n//! representative is canonical, use `Scalar::is_canonical()`.\n//!\n//! ## Scalar Multiplication\n//!\n//! Scalar multiplication on Ristretto points is provided by:\n//!\n//! * the `*` operator between a `Scalar` and a `RistrettoPoint`, which\n//!   performs constant-time variable-base scalar multiplication;\n//!\n//! * the `*` operator between a `Scalar` and a\n//!   `RistrettoBasepointTable`, which performs constant-time fixed-base\n//!   scalar multiplication;\n//!\n//! * an implementation of the\n//!   [`MultiscalarMul`](../traits/trait.MultiscalarMul.html) trait for\n//!   constant-time variable-base multiscalar multiplication;\n//!\n//! * an implementation of the\n//!   [`VartimeMultiscalarMul`](../traits/trait.VartimeMultiscalarMul.html)\n//!   trait for variable-time variable-base multiscalar multiplication;\n//!\n//! ## Random Points and Hashing to Ristretto\n//!\n//! The Ristretto group comes equipped with an Elligator map.  This is\n//! used to implement\n//!\n//! * `RistrettoPoint::random()`, which generates random points from an\n//!   RNG - enabled by `rand_core` feature;\n//!\n//! * `RistrettoPoint::from_hash()` and\n//!   `RistrettoPoint::hash_from_bytes()`, which perform hashing to the\n//!   group.\n//!\n//! The Elligator map itself is not currently exposed.\n//!\n//! ## Implementation\n//!\n//! The Decaf suggestion is to use a quotient group, such as \\\\(\\mathcal\n//! E / \\mathcal E\\[4\\]\\\\) or \\\\(2 \\mathcal E / \\mathcal E\\[2\\] \\\\), to\n//! implement a prime-order group using a non-prime-order curve.\n//!\n//! This requires only changing\n//!\n//! 1. the function for equality checking (so that two representatives\n//!    of the same coset are considered equal);\n//! 2. the function for encoding (so that two representatives of the\n//!    same coset are encoded as identical bitstrings);\n//! 3. the function for decoding (so that only the canonical encoding of\n//!    a coset is accepted).\n//!\n//! Internally, each coset is represented by a curve point; two points\n//! \\\\( P, Q \\\\) may represent the same coset in the same way that two\n//! points with different \\\\(X,Y,Z\\\\) coordinates may represent the\n//! same point.  The group operations are carried out with no overhead\n//! using Edwards formulas.\n//!\n//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};\nuse core::ops::{Mul, MulAssign};\n\n// #[cfg(feature = \"digest\")]\n// use digest::Digest;\n// #[cfg(feature = \"digest\")]\n// use digest::array::typenum::U64;\n\nuse crate::constants;\nuse crate::field::FieldElement;\n\n#[cfg(feature = \"group\")]\nuse {\n    group::{GroupEncoding, cofactor::CofactorGroup, prime::PrimeGroup},\n    rand_core::TryRngCore,\n    subtle::CtOption,\n};\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse {\n    core::convert::Infallible,\n    rand_core::{CryptoRng, TryCryptoRng},\n};\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::Zeroize;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::edwards::EdwardsBasepointTable;\nuse crate::edwards::EdwardsPoint;\n\nuse crate::scalar::Scalar;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::traits::BasepointTable;\nuse crate::traits::Identity;\n#[cfg(feature = \"alloc\")]\nuse crate::traits::{MultiscalarMul, VartimeMultiscalarMul, VartimePrecomputedMultiscalarMul};\n\n// ------------------------------------------------------------------------\n// Compressed points\n// ------------------------------------------------------------------------\n\n/// A Ristretto point, in compressed wire format.\n///\n/// The Ristretto encoding is canonical, so two points are equal if and\n/// only if their encodings are equal.\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct CompressedRistretto(pub [u8; 32]);\n\nimpl Eq for CompressedRistretto {}\nimpl PartialEq for CompressedRistretto {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl ConstantTimeEq for CompressedRistretto {\n    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }\n}\n\nimpl CompressedRistretto {\n    /// Copy the bytes of this `CompressedRistretto`.\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// View this `CompressedRistretto` as an array of bytes.\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n\n    /// Construct a `CompressedRistretto` from a slice of bytes.\n    ///\n    /// # Errors\n    ///\n    /// Returns [`TryFromSliceError`] if the input `bytes` slice does not have\n    /// a length of 32.\n    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }\n\n    /// Attempt to decompress to an `RistrettoPoint`.\n    ///\n    /// # Return\n    ///\n    /// - `Some(RistrettoPoint)` if `self` was the canonical encoding of a point;\n    ///\n    /// - `None` if `self` was not the canonical encoding of a point.\n    pub fn decompress(&self) -> Option<RistrettoPoint> {\n        let (s_encoding_is_canonical, s_is_negative, s) = decompress::step_1(self);\n\n        if (!s_encoding_is_canonical | s_is_negative).into() {\n            return None;\n        }\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        if (!ok | t_is_negative | y_is_zero).into() {\n            None\n        } else {\n            Some(res)\n        }\n    }\n}\n\nmod decompress {\n    use super::*;\n\n    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.to_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }\n\n    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as\n        let u2 = &one + &ss; //  1 - as    where a=-1\n        let u2_sqr = u2.square(); // (1 - as)\n\n        // v == ad(1+as) - (1-as)            where d=-121665/121666\n        let v = &(&(-&constants::EDWARDS_D) * &u1.square()) - &u2_sqr;\n\n        let (ok, I) = (&v * &u2_sqr).invsqrt(); // 1/sqrt(v*u_2)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dy = &I * &(&Dx * &v); // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s/(ad(1+as) - (1-as)))\n        let mut x = &(&s + &s) * &Dx;\n        let x_neg = x.is_negative();\n        x.conditional_negate(x_neg);\n\n        // y == (1-as)/(1+as)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as) sqrt(4s/(ad(1+as) - (1-as))))/(1-as)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }\n}\n\nimpl Identity for CompressedRistretto {\n    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }\n}\n\nimpl Default for CompressedRistretto {\n    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }\n}\n\nimpl TryFrom<&[u8]> for CompressedRistretto {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Serde support\n// ------------------------------------------------------------------------\n// Serializes to and from `RistrettoPoint` directly, doing compression\n// and decompression internally.  This means that users can create\n// structs containing `RistrettoPoint`s and use Serde's derived\n// serializers to serialize those structures.\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for RistrettoPoint {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.compress().as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for CompressedRistretto {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for RistrettoPoint {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct RistrettoPointVisitor;\n\n        impl<'de> Visitor<'de> for RistrettoPointVisitor {\n            type Value = RistrettoPoint;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"a valid point in Ristretto format\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<RistrettoPoint, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                CompressedRistretto(bytes)\n                    .decompress()\n                    .ok_or_else(|| serde::de::Error::custom(\"decompression failed\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, RistrettoPointVisitor)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for CompressedRistretto {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct CompressedRistrettoVisitor;\n\n        impl<'de> Visitor<'de> for CompressedRistrettoVisitor {\n            type Value = CompressedRistretto;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"32 bytes of data\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<CompressedRistretto, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Ok(CompressedRistretto(bytes))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, CompressedRistrettoVisitor)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Internal point representations\n// ------------------------------------------------------------------------\n\n/// A `RistrettoPoint` represents a point in the Ristretto group for\n/// Curve25519.  Ristretto, a variant of Decaf, constructs a\n/// prime-order group as a quotient group of a subgroup of (the\n/// Edwards form of) Curve25519.\n///\n/// Internally, a `RistrettoPoint` is implemented as a wrapper type\n/// around `EdwardsPoint`, with custom equality, compression, and\n/// decompression routines to account for the quotient.  This means that\n/// operations on `RistrettoPoint`s are exactly as fast as operations on\n/// `EdwardsPoint`s.\n///\n#[derive(Copy, Clone)]\npub struct RistrettoPoint(pub(crate) EdwardsPoint);\n\nimpl RistrettoPoint {\n    /// Compress this point using the Ristretto encoding.\n    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let u1 = &(Z + &Y) * &(Z - &Y);\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let (_, invsqrt) = (&u1 * &u2.square()).invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let z_inv = &i1 * &(&i2 * T);\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let rotate = (T * &z_inv).is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        Y.conditional_negate((&X * &z_inv).is_negative());\n\n        let mut s = &den_inv * &(Z - &Y);\n        let s_is_negative = s.is_negative();\n        s.conditional_negate(s_is_negative);\n\n        CompressedRistretto(s.to_bytes())\n    }\n\n    /// Double-and-compress a batch of points.  The Ristretto encoding\n    /// is not batchable, since it requires an inverse square root.\n    ///\n    /// However, given input points \\\\( P\\_1, \\ldots, P\\_n, \\\\)\n    /// it is possible to compute the encodings of their doubles \\\\(\n    /// \\mathrm{enc}( \\[2\\]P\\_1), \\ldots, \\mathrm{enc}( \\[2\\]P\\_n ) \\\\)\n    /// in a batch.\n    ///\n    #[cfg_attr(feature = \"rand_core\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use rand_core::{OsRng, TryRngCore};\n    ///\n    /// # // Need fn main() here in comment so the doctest compiles\n    /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    /// # fn main() {\n    /// let mut rng = OsRng.unwrap_err();\n    ///\n    /// let points: Vec<RistrettoPoint> =\n    ///     (0..32).map(|_| RistrettoPoint::random(&mut rng)).collect();\n    ///\n    /// let compressed = RistrettoPoint::double_and_compress_batch(&points);\n    ///\n    /// for (P, P2_compressed) in points.iter().zip(compressed.iter()) {\n    ///     assert_eq!(*P2_compressed, (P + P).compress());\n    /// }\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.to_bytes())\n            })\n            .collect()\n    }\n\n    /// Return the coset self + E\\[4\\], for debugging.\n    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }\n\n    /// Computes the Ristretto Elligator map. This is the\n    /// [`MAP`](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4)\n    /// function defined in the Ristretto spec.\n    ///\n    /// # Note\n    ///\n    /// This method is not public because it's just used for hashing\n    /// to a point -- proper elligator support is deferred for now.\n    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }\n\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `RistrettoPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRng` interface.\n    ///\n    /// # Returns\n    ///\n    /// A random element of the Ristretto group.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self::try_from_rng(rng)\n            .map_err(|_: Infallible| {})\n            .expect(\"[bug] unfallible rng failed\")\n    }\n\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `RistrettoPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `TryCryptoRng` interface.\n    ///\n    /// # Returns\n    ///\n    /// A random element of the Ristretto group.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    pub fn try_from_rng<R: TryCryptoRng + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut uniform_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n\n        Ok(RistrettoPoint::from_uniform_bytes(&uniform_bytes))\n    }\n\n    // #[cfg(feature = \"digest\")]\n    // /// Hash a slice of bytes into a `RistrettoPoint`.\n    // ///\n    // /// Takes a type parameter `D`, which is any `Digest` producing 64\n    // /// bytes of output.\n    // ///\n    // /// Convenience wrapper around `from_hash`.\n    // ///\n    // /// # Implementation\n    // ///\n    // /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    // /// discrete log of the output point with respect to any other\n    // /// point should be unknown.  The map is applied twice and the\n    // /// results are added, to ensure a uniform distribution.\n    // ///\n    // /// # Example\n    // ///\n    // #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    // #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    // /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    // /// use sha2::Sha512;\n    // ///\n    // /// # // Need fn main() here in comment so the doctest compiles\n    // /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    // /// # fn main() {\n    // /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    // /// let P = RistrettoPoint::hash_from_bytes::<Sha512>(msg.as_bytes());\n    // /// # }\n    // /// ```\n    // ///\n    // pub fn hash_from_bytes<D>(input: &[u8]) -> RistrettoPoint\n    // where\n    //     D: Digest<OutputSize = U64> + Default,\n    // {\n    //     let mut hash = D::default();\n    //     hash.update(input);\n    //     RistrettoPoint::from_hash(hash)\n    // }\n\n    // #[cfg(feature = \"digest\")]\n    // /// Construct a `RistrettoPoint` from an existing `Digest` instance.\n    // ///\n    // /// Use this instead of `hash_from_bytes` if it is more convenient\n    // /// to stream data into the `Digest` than to pass a single byte\n    // /// slice.\n    // pub fn from_hash<D>(hash: D) -> RistrettoPoint\n    // where\n    //     D: Digest<OutputSize = U64> + Default,\n    // {\n    //     // dealing with generic arrays is clumsy, until const generics land\n    //     let output = hash.finalize();\n    //     let mut output_bytes = [0u8; 64];\n    //     output_bytes.copy_from_slice(output.as_slice());\n\n    //     RistrettoPoint::from_uniform_bytes(&output_bytes)\n    // }\n\n    /// Construct a `RistrettoPoint` from 64 bytes of data.\n    ///\n    /// If the input bytes are uniformly distributed, the resulting\n    /// point will be uniformly distributed over the group, and its\n    /// discrete log with respect to other points should be unknown.\n    ///\n    /// # Implementation\n    ///\n    /// This function splits the input array into two 32-byte halves,\n    /// takes the low 255 bits of each half mod p, applies the\n    /// Ristretto-flavored Elligator map to each, and adds the results.\n    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }\n}\n\nimpl Identity for RistrettoPoint {\n    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }\n}\n\nimpl Default for RistrettoPoint {\n    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Equality\n// ------------------------------------------------------------------------\n\nimpl PartialEq for RistrettoPoint {\n    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl ConstantTimeEq for RistrettoPoint {\n    /// Test equality between two `RistrettoPoint`s.\n    ///\n    /// # Returns\n    ///\n    /// * `Choice(1)` if the two `RistrettoPoint`s are equal;\n    /// * `Choice(0)` otherwise.\n    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }\n}\n\nimpl Eq for RistrettoPoint {}\n\n// ------------------------------------------------------------------------\n// Arithmetic\n// ------------------------------------------------------------------------\n\nimpl<'a> Add<&'a RistrettoPoint> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn add(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }\n}\n\ndefine_add_variants!(\n    LHS = RistrettoPoint,\n    RHS = RistrettoPoint,\n    Output = RistrettoPoint\n);\n\nimpl AddAssign<&RistrettoPoint> for RistrettoPoint {\n    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = RistrettoPoint, RHS = RistrettoPoint);\n\nimpl<'a> Sub<&'a RistrettoPoint> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn sub(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }\n}\n\ndefine_sub_variants!(\n    LHS = RistrettoPoint,\n    RHS = RistrettoPoint,\n    Output = RistrettoPoint\n);\n\nimpl SubAssign<&RistrettoPoint> for RistrettoPoint {\n    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = RistrettoPoint, RHS = RistrettoPoint);\n\nimpl<T> Sum<T> for RistrettoPoint\nwhere\n    T: Borrow<RistrettoPoint>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }\n}\n\nimpl Neg for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }\n}\n\nimpl Neg for RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn neg(self) -> RistrettoPoint {\n        -&self\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for RistrettoPoint {\n    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }\n}\n\nimpl<'a> Mul<&'a Scalar> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n    /// Scalar multiplication: compute `scalar * self`.\n    fn mul(self, scalar: &'a Scalar) -> RistrettoPoint {\n        RistrettoPoint(self.0 * scalar)\n    }\n}\n\nimpl<'a> Mul<&'a RistrettoPoint> for &Scalar {\n    type Output = RistrettoPoint;\n\n    /// Scalar multiplication: compute `self * scalar`.\n    fn mul(self, point: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self * point.0)\n    }\n}\n\nimpl RistrettoPoint {\n    /// Fixed-base scalar multiplication by the Ristretto base point.\n    ///\n    /// Uses precomputed basepoint tables when the `precomputed-tables` feature\n    /// is enabled, trading off increased code size for ~4x better performance.\n    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }\n}\n\ndefine_mul_assign_variants!(LHS = RistrettoPoint, RHS = Scalar);\n\ndefine_mul_variants!(LHS = RistrettoPoint, RHS = Scalar, Output = RistrettoPoint);\ndefine_mul_variants!(LHS = Scalar, RHS = RistrettoPoint, Output = RistrettoPoint);\n\n// ------------------------------------------------------------------------\n// Multiscalar Multiplication impls\n// ------------------------------------------------------------------------\n\n// These use iterator combinators to unwrap the underlying points and\n// forward to the EdwardsPoint implementations.\n\n#[cfg(feature = \"alloc\")]\nimpl MultiscalarMul for RistrettoPoint {\n    type Point = RistrettoPoint;\n\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> RistrettoPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<RistrettoPoint>,\n    {\n        let extended_points = points.into_iter().map(|P| P.borrow().0);\n        RistrettoPoint(EdwardsPoint::multiscalar_mul(scalars, extended_points))\n    }\n}\n\n#[cfg(feature = \"alloc\")]\nimpl VartimeMultiscalarMul for RistrettoPoint {\n    type Point = RistrettoPoint;\n\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<RistrettoPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<RistrettoPoint>>,\n    {\n        let extended_points = points.into_iter().map(|opt_P| opt_P.map(|P| P.0));\n\n        EdwardsPoint::optional_multiscalar_mul(scalars, extended_points).map(RistrettoPoint)\n    }\n}\n\n/// Precomputation for variable-time multiscalar multiplication with `RistrettoPoint`s.\n///\n/// Note that for large numbers of `RistrettoPoint`s, this functionality may be less\n/// efficient than the corresponding `VartimeMultiscalarMul` implementation.\n// This wraps the inner implementation in a facade type so that we can\n// decouple stability of the inner type from the stability of the\n// outer type.\n#[cfg(feature = \"alloc\")]\npub struct VartimeRistrettoPrecomputation(crate::backend::VartimePrecomputedStraus);\n\n#[cfg(feature = \"alloc\")]\nimpl VartimePrecomputedMultiscalarMul for VartimeRistrettoPrecomputation {\n    type Point = RistrettoPoint;\n\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(\n            static_points.into_iter().map(|P| P.borrow().0),\n        ))\n    }\n\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }\n\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points.into_iter().map(|P_opt| P_opt.map(|P| P.0)),\n            )\n            .map(RistrettoPoint)\n    }\n}\n\nimpl RistrettoPoint {\n    /// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the\n    /// Ristretto basepoint.\n    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &RistrettoPoint,\n        b: &Scalar,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::vartime_double_scalar_mul_basepoint(\n            a, &A.0, b,\n        ))\n    }\n}\n\n/// A precomputed table of multiples of a basepoint, used to accelerate\n/// scalar multiplication.\n///\n/// A precomputed table of multiples of the Ristretto basepoint is\n/// available in the `constants` module:\n/// ```\n/// use curve25519_dalek::constants::RISTRETTO_BASEPOINT_TABLE;\n/// use curve25519_dalek::scalar::Scalar;\n///\n/// let a = Scalar::from(87329482u64);\n/// let P = &a * RISTRETTO_BASEPOINT_TABLE;\n/// ```\n#[cfg(feature = \"precomputed-tables\")]\n#[derive(Clone)]\n#[repr(transparent)]\npub struct RistrettoBasepointTable(pub(crate) EdwardsBasepointTable);\n\n#[cfg(feature = \"precomputed-tables\")]\nimpl<'b> Mul<&'b Scalar> for &RistrettoBasepointTable {\n    type Output = RistrettoPoint;\n\n    fn mul(self, scalar: &'b Scalar) -> RistrettoPoint {\n        RistrettoPoint(&self.0 * scalar)\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nimpl<'a> Mul<&'a RistrettoBasepointTable> for &Scalar {\n    type Output = RistrettoPoint;\n\n    fn mul(self, basepoint_table: &'a RistrettoBasepointTable) -> RistrettoPoint {\n        RistrettoPoint(self * &basepoint_table.0)\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nimpl RistrettoBasepointTable {\n    /// Create a precomputed table of multiples of the given `basepoint`.\n    pub fn create(basepoint: &RistrettoPoint) -> RistrettoBasepointTable {\n        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }\n\n    /// Get the basepoint for this table as a `RistrettoPoint`.\n    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }\n}\n\n// ------------------------------------------------------------------------\n// Constant-time conditional selection\n// ------------------------------------------------------------------------\n\nimpl ConditionallySelectable for RistrettoPoint {\n    /// Conditionally select between `self` and `other`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use subtle::ConditionallySelectable;\n    /// use subtle::Choice;\n    /// #\n    /// # use curve25519_dalek::traits::Identity;\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// # use curve25519_dalek::constants;\n    /// # fn main() {\n    ///\n    /// let A = RistrettoPoint::identity();\n    /// let B = constants::RISTRETTO_BASEPOINT_POINT;\n    ///\n    /// let mut P = A;\n    ///\n    /// P = RistrettoPoint::conditional_select(&A, &B, Choice::from(0));\n    /// assert_eq!(P, A);\n    /// P = RistrettoPoint::conditional_select(&A, &B, Choice::from(1));\n    /// assert_eq!(P, B);\n    /// # }\n    /// ```\n    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }\n}\n\n// ------------------------------------------------------------------------\n// Debug traits\n// ------------------------------------------------------------------------\n\nimpl Debug for CompressedRistretto {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedRistretto: {:?}\", self.as_bytes())\n    }\n}\n\nimpl Debug for RistrettoPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let coset = self.coset4();\n        write!(\n            f,\n            \"RistrettoPoint: coset \\n{:?}\\n{:?}\\n{:?}\\n{:?}\",\n            coset[0], coset[1], coset[2], coset[3]\n        )\n    }\n}\n\n// ------------------------------------------------------------------------\n// group traits\n// ------------------------------------------------------------------------\n\n// Use the full trait path to avoid Group::identity overlapping Identity::identity in the\n// rest of the module (e.g. tests).\n#[cfg(feature = \"group\")]\nimpl group::Group for RistrettoPoint {\n    type Scalar = Scalar;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        // NOTE: this is duplicated due to different `rng` bounds\n        let mut uniform_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n        Ok(RistrettoPoint::from_uniform_bytes(&uniform_bytes))\n    }\n\n    fn identity() -> Self {\n        Identity::identity()\n    }\n\n    fn generator() -> Self {\n        constants::RISTRETTO_BASEPOINT_POINT\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        self + self\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl GroupEncoding for RistrettoPoint {\n    type Repr = [u8; 32];\n\n    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        let (s_encoding_is_canonical, s_is_negative, s) =\n            decompress::step_1(&CompressedRistretto(*bytes));\n\n        let s_is_valid = s_encoding_is_canonical & !s_is_negative;\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        CtOption::new(res, s_is_valid & ok & !t_is_negative & !y_is_zero)\n    }\n\n    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // Just use the checked API; the checks we could skip aren't expensive.\n        Self::from_bytes(bytes)\n    }\n\n    fn to_bytes(&self) -> Self::Repr {\n        self.compress().to_bytes()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl PrimeGroup for RistrettoPoint {}\n\n/// Ristretto has a cofactor of 1.\n#[cfg(feature = \"group\")]\nimpl CofactorGroup for RistrettoPoint {\n    type Subgroup = Self;\n\n    fn clear_cofactor(&self) -> Self::Subgroup {\n        *self\n    }\n\n    fn into_subgroup(self) -> CtOption<Self::Subgroup> {\n        CtOption::new(self, Choice::from(1))\n    }\n\n    fn is_torsion_free(&self) -> Choice {\n        Choice::from(1)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Zeroize traits\n// ------------------------------------------------------------------------\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for CompressedRistretto {\n//     fn zeroize(&mut self) {\n//         self.0.zeroize();\n//     }\n// }\n\n// #[cfg(feature = \"zeroize\")]\n// impl Zeroize for RistrettoPoint {\n//     fn zeroize(&mut self) {\n//         self.0.zeroize();\n//     }\n// }\n\n// ------------------------------------------------------------------------\n// Tests\n// ------------------------------------------------------------------------\n\n// #[cfg(test)]\n// mod test {\n//     use super::*;\n//     use crate::edwards::CompressedEdwardsY;\n\n//     use rand_core::{OsRng, TryRngCore};\n\n//     #[test]\n//     #[cfg(feature = \"serde\")]\n//     fn serde_bincode_basepoint_roundtrip() {\n//         use bincode;\n\n//         let encoded = bincode::serialize(&constants::RISTRETTO_BASEPOINT_POINT).unwrap();\n//         let enc_compressed =\n//             bincode::serialize(&constants::RISTRETTO_BASEPOINT_COMPRESSED).unwrap();\n//         assert_eq!(encoded, enc_compressed);\n\n//         // Check that the encoding is 32 bytes exactly\n//         assert_eq!(encoded.len(), 32);\n\n//         let dec_uncompressed: RistrettoPoint = bincode::deserialize(&encoded).unwrap();\n//         let dec_compressed: CompressedRistretto = bincode::deserialize(&encoded).unwrap();\n\n//         assert_eq!(dec_uncompressed, constants::RISTRETTO_BASEPOINT_POINT);\n//         assert_eq!(dec_compressed, constants::RISTRETTO_BASEPOINT_COMPRESSED);\n\n//         // Check that the encoding itself matches the usual one\n//         let raw_bytes = constants::RISTRETTO_BASEPOINT_COMPRESSED.as_bytes();\n//         let bp: RistrettoPoint = bincode::deserialize(raw_bytes).unwrap();\n//         assert_eq!(bp, constants::RISTRETTO_BASEPOINT_POINT);\n//     }\n\n//     #[test]\n//     fn scalarmult_ristrettopoint_works_both_ways() {\n//         let P = constants::RISTRETTO_BASEPOINT_POINT;\n//         let s = Scalar::from(999u64);\n\n//         let P1 = P * s;\n//         let P2 = s * P;\n\n//         assert!(P1.compress().as_bytes() == P2.compress().as_bytes());\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn impl_sum() {\n//         // Test that sum works for non-empty iterators\n//         let BASE = constants::RISTRETTO_BASEPOINT_POINT;\n\n//         let s1 = Scalar::from(999u64);\n//         let P1 = BASE * s1;\n\n//         let s2 = Scalar::from(333u64);\n//         let P2 = BASE * s2;\n\n//         let vec = vec![P1, P2];\n//         let sum: RistrettoPoint = vec.iter().sum();\n\n//         assert_eq!(sum, P1 + P2);\n\n//         // Test that sum works for the empty iterator\n//         let empty_vector: Vec<RistrettoPoint> = vec![];\n//         let sum: RistrettoPoint = empty_vector.iter().sum();\n\n//         assert_eq!(sum, RistrettoPoint::identity());\n\n//         // Test that sum works on owning iterators\n//         let s = Scalar::from(2u64);\n//         let mapped = vec.iter().map(|x| x * s);\n//         let sum: RistrettoPoint = mapped.sum();\n\n//         assert_eq!(sum, P1 * s + P2 * s);\n//     }\n\n//     #[test]\n//     fn decompress_negative_s_fails() {\n//         // constants::d is neg, so decompression should fail as |d| != d.\n//         let bad_compressed = CompressedRistretto(constants::EDWARDS_D.to_bytes());\n//         assert!(bad_compressed.decompress().is_none());\n//     }\n\n//     #[test]\n//     fn decompress_id() {\n//         let compressed_id = CompressedRistretto::identity();\n//         let id = compressed_id.decompress().unwrap();\n//         let mut identity_in_coset = false;\n//         for P in &id.coset4() {\n//             if P.compress() == CompressedEdwardsY::identity() {\n//                 identity_in_coset = true;\n//             }\n//         }\n//         assert!(identity_in_coset);\n//     }\n\n//     #[test]\n//     fn compress_id() {\n//         let id = RistrettoPoint::identity();\n//         assert_eq!(id.compress(), CompressedRistretto::identity());\n//     }\n\n//     #[test]\n//     fn basepoint_roundtrip() {\n//         let bp_compressed_ristretto = constants::RISTRETTO_BASEPOINT_POINT.compress();\n//         let bp_recaf = bp_compressed_ristretto.decompress().unwrap().0;\n//         // Check that bp_recaf differs from bp by a point of order 4\n//         let diff = constants::RISTRETTO_BASEPOINT_POINT.0 - bp_recaf;\n//         let diff4 = diff.mul_by_pow_2(2);\n//         assert_eq!(diff4.compress(), CompressedEdwardsY::identity());\n//     }\n\n//     #[test]\n//     fn encodings_of_small_multiples_of_basepoint() {\n//         // Table of encodings of i*basepoint\n//         // Generated using ristretto.sage\n//         let compressed = [\n//             CompressedRistretto([\n//                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//                 0, 0, 0, 0,\n//             ]),\n//             CompressedRistretto([\n//                 226, 242, 174, 10, 106, 188, 78, 113, 168, 132, 169, 97, 197, 0, 81, 95, 88, 227,\n//                 11, 106, 165, 130, 221, 141, 182, 166, 89, 69, 224, 141, 45, 118,\n//             ]),\n//             CompressedRistretto([\n//                 106, 73, 50, 16, 247, 73, 156, 209, 127, 236, 181, 16, 174, 12, 234, 35, 161, 16,\n//                 232, 213, 185, 1, 248, 172, 173, 211, 9, 92, 115, 163, 185, 25,\n//             ]),\n//             CompressedRistretto([\n//                 148, 116, 31, 93, 93, 82, 117, 94, 206, 79, 35, 240, 68, 238, 39, 213, 209, 234,\n//                 30, 43, 209, 150, 180, 98, 22, 107, 22, 21, 42, 157, 2, 89,\n//             ]),\n//             CompressedRistretto([\n//                 218, 128, 134, 39, 115, 53, 139, 70, 111, 250, 223, 224, 179, 41, 58, 179, 217,\n//                 253, 83, 197, 234, 108, 149, 83, 88, 245, 104, 50, 45, 175, 106, 87,\n//             ]),\n//             CompressedRistretto([\n//                 232, 130, 177, 49, 1, 107, 82, 193, 211, 51, 112, 128, 24, 124, 247, 104, 66, 62,\n//                 252, 203, 181, 23, 187, 73, 90, 184, 18, 196, 22, 15, 244, 78,\n//             ]),\n//             CompressedRistretto([\n//                 246, 71, 70, 211, 201, 43, 19, 5, 14, 216, 216, 2, 54, 167, 240, 0, 124, 59, 63,\n//                 150, 47, 91, 167, 147, 209, 154, 96, 30, 187, 29, 244, 3,\n//             ]),\n//             CompressedRistretto([\n//                 68, 245, 53, 32, 146, 110, 200, 31, 189, 90, 56, 120, 69, 190, 183, 223, 133, 169,\n//                 106, 36, 236, 225, 135, 56, 189, 207, 166, 167, 130, 42, 23, 109,\n//             ]),\n//             CompressedRistretto([\n//                 144, 50, 147, 216, 242, 40, 126, 190, 16, 226, 55, 77, 193, 165, 62, 11, 200, 135,\n//                 229, 146, 105, 159, 2, 208, 119, 213, 38, 60, 221, 85, 96, 28,\n//             ]),\n//             CompressedRistretto([\n//                 2, 98, 42, 206, 143, 115, 3, 163, 28, 175, 198, 63, 143, 196, 143, 220, 22, 225,\n//                 200, 200, 210, 52, 178, 240, 214, 104, 82, 130, 169, 7, 96, 49,\n//             ]),\n//             CompressedRistretto([\n//                 32, 112, 111, 215, 136, 178, 114, 10, 30, 210, 165, 218, 212, 149, 43, 1, 244, 19,\n//                 188, 240, 231, 86, 77, 232, 205, 200, 22, 104, 158, 45, 185, 95,\n//             ]),\n//             CompressedRistretto([\n//                 188, 232, 63, 139, 165, 221, 47, 165, 114, 134, 76, 36, 186, 24, 16, 249, 82, 43,\n//                 198, 0, 74, 254, 149, 135, 122, 199, 50, 65, 202, 253, 171, 66,\n//             ]),\n//             CompressedRistretto([\n//                 228, 84, 158, 225, 107, 154, 160, 48, 153, 202, 32, 140, 103, 173, 175, 202, 250,\n//                 76, 63, 62, 78, 83, 3, 222, 96, 38, 227, 202, 143, 248, 68, 96,\n//             ]),\n//             CompressedRistretto([\n//                 170, 82, 224, 0, 223, 46, 22, 245, 95, 177, 3, 47, 195, 59, 196, 39, 66, 218, 214,\n//                 189, 90, 143, 192, 190, 1, 103, 67, 108, 89, 72, 80, 31,\n//             ]),\n//             CompressedRistretto([\n//                 70, 55, 107, 128, 244, 9, 178, 157, 194, 181, 246, 240, 197, 37, 145, 153, 8, 150,\n//                 229, 113, 111, 65, 71, 124, 211, 0, 133, 171, 127, 16, 48, 30,\n//             ]),\n//             CompressedRistretto([\n//                 224, 196, 24, 247, 200, 217, 196, 205, 215, 57, 91, 147, 234, 18, 79, 58, 217, 144,\n//                 33, 187, 104, 29, 252, 51, 2, 169, 217, 154, 46, 83, 230, 78,\n//             ]),\n//         ];\n//         let mut bp = RistrettoPoint::identity();\n//         for point in compressed {\n//             assert_eq!(bp.compress(), point);\n//             bp += constants::RISTRETTO_BASEPOINT_POINT;\n//         }\n//     }\n\n//     #[test]\n//     fn four_torsion_basepoint() {\n//         let bp = constants::RISTRETTO_BASEPOINT_POINT;\n//         let bp_coset = bp.coset4();\n//         for point in bp_coset {\n//             assert_eq!(bp, RistrettoPoint(point));\n//         }\n//     }\n\n//     #[test]\n//     fn four_torsion_random() {\n//         let mut rng = OsRng.unwrap_err();\n//         let P = RistrettoPoint::mul_base(&Scalar::random(&mut rng));\n//         let P_coset = P.coset4();\n//         for point in P_coset {\n//             assert_eq!(P, RistrettoPoint(point));\n//         }\n//     }\n\n//     #[test]\n//     fn elligator_vs_ristretto_sage() {\n//         // Test vectors extracted from ristretto.sage.\n//         //\n//         // Notice that all of the byte sequences have bit 255 set to 0; this is because\n//         // ristretto.sage does not mask the high bit of a field element.  When the high bit is set,\n//         // the ristretto.sage elligator implementation gives different results, since it takes a\n//         // different field element as input.\n//         let bytes: [[u8; 32]; 16] = [\n//             [\n//                 184, 249, 135, 49, 253, 123, 89, 113, 67, 160, 6, 239, 7, 105, 211, 41, 192, 249,\n//                 185, 57, 9, 102, 70, 198, 15, 127, 7, 26, 160, 102, 134, 71,\n//             ],\n//             [\n//                 229, 14, 241, 227, 75, 9, 118, 60, 128, 153, 226, 21, 183, 217, 91, 136, 98, 0,\n//                 231, 156, 124, 77, 82, 139, 142, 134, 164, 169, 169, 62, 250, 52,\n//             ],\n//             [\n//                 115, 109, 36, 220, 180, 223, 99, 6, 204, 169, 19, 29, 169, 68, 84, 23, 21, 109,\n//                 189, 149, 127, 205, 91, 102, 172, 35, 112, 35, 134, 69, 186, 34,\n//             ],\n//             [\n//                 16, 49, 96, 107, 171, 199, 164, 9, 129, 16, 64, 62, 241, 63, 132, 173, 209, 160,\n//                 112, 215, 105, 50, 157, 81, 253, 105, 1, 154, 229, 25, 120, 83,\n//             ],\n//             [\n//                 156, 131, 161, 162, 236, 251, 5, 187, 167, 171, 17, 178, 148, 210, 90, 207, 86, 21,\n//                 79, 161, 167, 215, 234, 1, 136, 242, 182, 248, 38, 85, 79, 86,\n//             ],\n//             [\n//                 251, 177, 124, 54, 18, 101, 75, 235, 245, 186, 19, 46, 133, 157, 229, 64, 10, 136,\n//                 181, 185, 78, 144, 254, 167, 137, 49, 107, 10, 61, 10, 21, 25,\n//             ],\n//             [\n//                 232, 193, 20, 68, 240, 77, 186, 77, 183, 40, 44, 86, 150, 31, 198, 212, 76, 81, 3,\n//                 217, 197, 8, 126, 128, 126, 152, 164, 208, 153, 44, 189, 77,\n//             ],\n//             [\n//                 173, 229, 149, 177, 37, 230, 30, 69, 61, 56, 172, 190, 219, 115, 167, 194, 71, 134,\n//                 59, 75, 28, 244, 118, 26, 162, 97, 64, 16, 15, 189, 30, 64,\n//             ],\n//             [\n//                 106, 71, 61, 107, 250, 117, 42, 151, 91, 202, 212, 100, 52, 188, 190, 21, 125, 218,\n//                 31, 18, 253, 241, 160, 133, 57, 242, 3, 164, 189, 68, 111, 75,\n//             ],\n//             [\n//                 112, 204, 182, 90, 220, 198, 120, 73, 173, 107, 193, 17, 227, 40, 162, 36, 150,\n//                 141, 235, 55, 172, 183, 12, 39, 194, 136, 43, 153, 244, 118, 91, 89,\n//             ],\n//             [\n//                 111, 24, 203, 123, 254, 189, 11, 162, 51, 196, 163, 136, 204, 143, 10, 222, 33,\n//                 112, 81, 205, 34, 35, 8, 66, 90, 6, 164, 58, 170, 177, 34, 25,\n//             ],\n//             [\n//                 225, 183, 30, 52, 236, 82, 6, 183, 109, 25, 227, 181, 25, 82, 41, 193, 80, 77, 161,\n//                 80, 242, 203, 79, 204, 136, 245, 131, 110, 237, 106, 3, 58,\n//             ],\n//             [\n//                 207, 246, 38, 56, 30, 86, 176, 90, 27, 200, 61, 42, 221, 27, 56, 210, 79, 178, 189,\n//                 120, 68, 193, 120, 167, 77, 185, 53, 197, 124, 128, 191, 126,\n//             ],\n//             [\n//                 1, 136, 215, 80, 240, 46, 63, 147, 16, 244, 230, 207, 82, 189, 74, 50, 106, 169,\n//                 138, 86, 30, 131, 214, 202, 166, 125, 251, 228, 98, 24, 36, 21,\n//             ],\n//             [\n//                 210, 207, 228, 56, 155, 116, 207, 54, 84, 195, 251, 215, 249, 199, 116, 75, 109,\n//                 239, 196, 251, 194, 246, 252, 228, 70, 146, 156, 35, 25, 39, 241, 4,\n//             ],\n//             [\n//                 34, 116, 123, 9, 8, 40, 93, 189, 9, 103, 57, 103, 66, 227, 3, 2, 157, 107, 134,\n//                 219, 202, 74, 230, 154, 78, 107, 219, 195, 214, 14, 84, 80,\n//             ],\n//         ];\n//         let encoded_images: [CompressedRistretto; 16] = [\n//             CompressedRistretto([\n//                 176, 157, 237, 97, 66, 29, 140, 166, 168, 94, 26, 157, 212, 216, 229, 160, 195,\n//                 246, 232, 239, 169, 112, 63, 193, 64, 32, 152, 69, 11, 190, 246, 86,\n//             ]),\n//             CompressedRistretto([\n//                 234, 141, 77, 203, 181, 225, 250, 74, 171, 62, 15, 118, 78, 212, 150, 19, 131, 14,\n//                 188, 238, 194, 244, 141, 138, 166, 162, 83, 122, 228, 201, 19, 26,\n//             ]),\n//             CompressedRistretto([\n//                 232, 231, 51, 92, 5, 168, 80, 36, 173, 179, 104, 68, 186, 149, 68, 40, 140, 170,\n//                 27, 103, 99, 140, 21, 242, 43, 62, 250, 134, 208, 255, 61, 89,\n//             ]),\n//             CompressedRistretto([\n//                 208, 120, 140, 129, 177, 179, 237, 159, 252, 160, 28, 13, 206, 5, 211, 241, 192,\n//                 218, 1, 97, 130, 241, 20, 169, 119, 46, 246, 29, 79, 80, 77, 84,\n//             ]),\n//             CompressedRistretto([\n//                 202, 11, 236, 145, 58, 12, 181, 157, 209, 6, 213, 88, 75, 147, 11, 119, 191, 139,\n//                 47, 142, 33, 36, 153, 193, 223, 183, 178, 8, 205, 120, 248, 110,\n//             ]),\n//             CompressedRistretto([\n//                 26, 66, 231, 67, 203, 175, 116, 130, 32, 136, 62, 253, 215, 46, 5, 214, 166, 248,\n//                 108, 237, 216, 71, 244, 173, 72, 133, 82, 6, 143, 240, 104, 41,\n//             ]),\n//             CompressedRistretto([\n//                 40, 157, 102, 96, 201, 223, 200, 197, 150, 181, 106, 83, 103, 126, 143, 33, 145,\n//                 230, 78, 6, 171, 146, 210, 143, 112, 5, 245, 23, 183, 138, 18, 120,\n//             ]),\n//             CompressedRistretto([\n//                 220, 37, 27, 203, 239, 196, 176, 131, 37, 66, 188, 243, 185, 250, 113, 23, 167,\n//                 211, 154, 243, 168, 215, 54, 171, 159, 36, 195, 81, 13, 150, 43, 43,\n//             ]),\n//             CompressedRistretto([\n//                 232, 121, 176, 222, 183, 196, 159, 90, 238, 193, 105, 52, 101, 167, 244, 170, 121,\n//                 114, 196, 6, 67, 152, 80, 185, 221, 7, 83, 105, 176, 208, 224, 121,\n//             ]),\n//             CompressedRistretto([\n//                 226, 181, 183, 52, 241, 163, 61, 179, 221, 207, 220, 73, 245, 242, 25, 236, 67, 84,\n//                 179, 222, 167, 62, 167, 182, 32, 9, 92, 30, 165, 127, 204, 68,\n//             ]),\n//             CompressedRistretto([\n//                 226, 119, 16, 242, 200, 139, 240, 87, 11, 222, 92, 146, 156, 243, 46, 119, 65, 59,\n//                 1, 248, 92, 183, 50, 175, 87, 40, 206, 53, 208, 220, 148, 13,\n//             ]),\n//             CompressedRistretto([\n//                 70, 240, 79, 112, 54, 157, 228, 146, 74, 122, 216, 88, 232, 62, 158, 13, 14, 146,\n//                 115, 117, 176, 222, 90, 225, 244, 23, 94, 190, 150, 7, 136, 96,\n//             ]),\n//             CompressedRistretto([\n//                 22, 71, 241, 103, 45, 193, 195, 144, 183, 101, 154, 50, 39, 68, 49, 110, 51, 44,\n//                 62, 0, 229, 113, 72, 81, 168, 29, 73, 106, 102, 40, 132, 24,\n//             ]),\n//             CompressedRistretto([\n//                 196, 133, 107, 11, 130, 105, 74, 33, 204, 171, 133, 221, 174, 193, 241, 36, 38,\n//                 179, 196, 107, 219, 185, 181, 253, 228, 47, 155, 42, 231, 73, 41, 78,\n//             ]),\n//             CompressedRistretto([\n//                 58, 255, 225, 197, 115, 208, 160, 143, 39, 197, 82, 69, 143, 235, 92, 170, 74, 40,\n//                 57, 11, 171, 227, 26, 185, 217, 207, 90, 185, 197, 190, 35, 60,\n//             ]),\n//             CompressedRistretto([\n//                 88, 43, 92, 118, 223, 136, 105, 145, 238, 186, 115, 8, 214, 112, 153, 253, 38, 108,\n//                 205, 230, 157, 130, 11, 66, 101, 85, 253, 110, 110, 14, 148, 112,\n//             ]),\n//         ];\n//         for i in 0..16 {\n//             let r_0 = FieldElement::from_bytes(&bytes[i]);\n//             let Q = RistrettoPoint::elligator_ristretto_flavor(&r_0);\n//             assert_eq!(Q.compress(), encoded_images[i]);\n//         }\n//     }\n\n//     // Known answer tests for the one-way mapping function in the Ristretto RFC\n//     #[test]\n//     fn one_way_map() {\n//         // These inputs are from\n//         // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#appendix-A.3\n//         let test_vectors: &[([u8; 64], CompressedRistretto)] = &[\n//             (\n//                 [\n//                     0x5d, 0x1b, 0xe0, 0x9e, 0x3d, 0x0c, 0x82, 0xfc, 0x53, 0x81, 0x12, 0x49, 0x0e,\n//                     0x35, 0x70, 0x19, 0x79, 0xd9, 0x9e, 0x06, 0xca, 0x3e, 0x2b, 0x5b, 0x54, 0xbf,\n//                     0xfe, 0x8b, 0x4d, 0xc7, 0x72, 0xc1, 0x4d, 0x98, 0xb6, 0x96, 0xa1, 0xbb, 0xfb,\n//                     0x5c, 0xa3, 0x2c, 0x43, 0x6c, 0xc6, 0x1c, 0x16, 0x56, 0x37, 0x90, 0x30, 0x6c,\n//                     0x79, 0xea, 0xca, 0x77, 0x05, 0x66, 0x8b, 0x47, 0xdf, 0xfe, 0x5b, 0xb6,\n//                 ],\n//                 CompressedRistretto([\n//                     0x30, 0x66, 0xf8, 0x2a, 0x1a, 0x74, 0x7d, 0x45, 0x12, 0x0d, 0x17, 0x40, 0xf1,\n//                     0x43, 0x58, 0x53, 0x1a, 0x8f, 0x04, 0xbb, 0xff, 0xe6, 0xa8, 0x19, 0xf8, 0x6d,\n//                     0xfe, 0x50, 0xf4, 0x4a, 0x0a, 0x46,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0xf1, 0x16, 0xb3, 0x4b, 0x8f, 0x17, 0xce, 0xb5, 0x6e, 0x87, 0x32, 0xa6, 0x0d,\n//                     0x91, 0x3d, 0xd1, 0x0c, 0xce, 0x47, 0xa6, 0xd5, 0x3b, 0xee, 0x92, 0x04, 0xbe,\n//                     0x8b, 0x44, 0xf6, 0x67, 0x8b, 0x27, 0x01, 0x02, 0xa5, 0x69, 0x02, 0xe2, 0x48,\n//                     0x8c, 0x46, 0x12, 0x0e, 0x92, 0x76, 0xcf, 0xe5, 0x46, 0x38, 0x28, 0x6b, 0x9e,\n//                     0x4b, 0x3c, 0xdb, 0x47, 0x0b, 0x54, 0x2d, 0x46, 0xc2, 0x06, 0x8d, 0x38,\n//                 ],\n//                 CompressedRistretto([\n//                     0xf2, 0x6e, 0x5b, 0x6f, 0x7d, 0x36, 0x2d, 0x2d, 0x2a, 0x94, 0xc5, 0xd0, 0xe7,\n//                     0x60, 0x2c, 0xb4, 0x77, 0x3c, 0x95, 0xa2, 0xe5, 0xc3, 0x1a, 0x64, 0xf1, 0x33,\n//                     0x18, 0x9f, 0xa7, 0x6e, 0xd6, 0x1b,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0x84, 0x22, 0xe1, 0xbb, 0xda, 0xab, 0x52, 0x93, 0x8b, 0x81, 0xfd, 0x60, 0x2e,\n//                     0xff, 0xb6, 0xf8, 0x91, 0x10, 0xe1, 0xe5, 0x72, 0x08, 0xad, 0x12, 0xd9, 0xad,\n//                     0x76, 0x7e, 0x2e, 0x25, 0x51, 0x0c, 0x27, 0x14, 0x07, 0x75, 0xf9, 0x33, 0x70,\n//                     0x88, 0xb9, 0x82, 0xd8, 0x3d, 0x7f, 0xcf, 0x0b, 0x2f, 0xa1, 0xed, 0xff, 0xe5,\n//                     0x19, 0x52, 0xcb, 0xe7, 0x36, 0x5e, 0x95, 0xc8, 0x6e, 0xaf, 0x32, 0x5c,\n//                 ],\n//                 CompressedRistretto([\n//                     0x00, 0x6c, 0xcd, 0x2a, 0x9e, 0x68, 0x67, 0xe6, 0xa2, 0xc5, 0xce, 0xa8, 0x3d,\n//                     0x33, 0x02, 0xcc, 0x9d, 0xe1, 0x28, 0xdd, 0x2a, 0x9a, 0x57, 0xdd, 0x8e, 0xe7,\n//                     0xb9, 0xd7, 0xff, 0xe0, 0x28, 0x26,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0xac, 0x22, 0x41, 0x51, 0x29, 0xb6, 0x14, 0x27, 0xbf, 0x46, 0x4e, 0x17, 0xba,\n//                     0xee, 0x8d, 0xb6, 0x59, 0x40, 0xc2, 0x33, 0xb9, 0x8a, 0xfc, 0xe8, 0xd1, 0x7c,\n//                     0x57, 0xbe, 0xeb, 0x78, 0x76, 0xc2, 0x15, 0x0d, 0x15, 0xaf, 0x1c, 0xb1, 0xfb,\n//                     0x82, 0x4b, 0xbd, 0x14, 0x95, 0x5f, 0x2b, 0x57, 0xd0, 0x8d, 0x38, 0x8a, 0xab,\n//                     0x43, 0x1a, 0x39, 0x1c, 0xfc, 0x33, 0xd5, 0xba, 0xfb, 0x5d, 0xbb, 0xaf,\n//                 ],\n//                 CompressedRistretto([\n//                     0xf8, 0xf0, 0xc8, 0x7c, 0xf2, 0x37, 0x95, 0x3c, 0x58, 0x90, 0xae, 0xc3, 0x99,\n//                     0x81, 0x69, 0x00, 0x5d, 0xae, 0x3e, 0xca, 0x1f, 0xbb, 0x04, 0x54, 0x8c, 0x63,\n//                     0x59, 0x53, 0xc8, 0x17, 0xf9, 0x2a,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0x16, 0x5d, 0x69, 0x7a, 0x1e, 0xf3, 0xd5, 0xcf, 0x3c, 0x38, 0x56, 0x5b, 0xee,\n//                     0xfc, 0xf8, 0x8c, 0x0f, 0x28, 0x2b, 0x8e, 0x7d, 0xbd, 0x28, 0x54, 0x4c, 0x48,\n//                     0x34, 0x32, 0xf1, 0xce, 0xc7, 0x67, 0x5d, 0xeb, 0xea, 0x8e, 0xbb, 0x4e, 0x5f,\n//                     0xe7, 0xd6, 0xf6, 0xe5, 0xdb, 0x15, 0xf1, 0x55, 0x87, 0xac, 0x4d, 0x4d, 0x4a,\n//                     0x1d, 0xe7, 0x19, 0x1e, 0x0c, 0x1c, 0xa6, 0x66, 0x4a, 0xbc, 0xc4, 0x13,\n//                 ],\n//                 CompressedRistretto([\n//                     0xae, 0x81, 0xe7, 0xde, 0xdf, 0x20, 0xa4, 0x97, 0xe1, 0x0c, 0x30, 0x4a, 0x76,\n//                     0x5c, 0x17, 0x67, 0xa4, 0x2d, 0x6e, 0x06, 0x02, 0x97, 0x58, 0xd2, 0xd7, 0xe8,\n//                     0xef, 0x7c, 0xc4, 0xc4, 0x11, 0x79,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0xa8, 0x36, 0xe6, 0xc9, 0xa9, 0xca, 0x9f, 0x1e, 0x8d, 0x48, 0x62, 0x73, 0xad,\n//                     0x56, 0xa7, 0x8c, 0x70, 0xcf, 0x18, 0xf0, 0xce, 0x10, 0xab, 0xb1, 0xc7, 0x17,\n//                     0x2d, 0xdd, 0x60, 0x5d, 0x7f, 0xd2, 0x97, 0x98, 0x54, 0xf4, 0x7a, 0xe1, 0xcc,\n//                     0xf2, 0x04, 0xa3, 0x31, 0x02, 0x09, 0x5b, 0x42, 0x00, 0xe5, 0xbe, 0xfc, 0x04,\n//                     0x65, 0xac, 0xcc, 0x26, 0x31, 0x75, 0x48, 0x5f, 0x0e, 0x17, 0xea, 0x5c,\n//                 ],\n//                 CompressedRistretto([\n//                     0xe2, 0x70, 0x56, 0x52, 0xff, 0x9f, 0x5e, 0x44, 0xd3, 0xe8, 0x41, 0xbf, 0x1c,\n//                     0x25, 0x1c, 0xf7, 0xdd, 0xdb, 0x77, 0xd1, 0x40, 0x87, 0x0d, 0x1a, 0xb2, 0xed,\n//                     0x64, 0xf1, 0xa9, 0xce, 0x86, 0x28,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0x2c, 0xdc, 0x11, 0xea, 0xeb, 0x95, 0xda, 0xf0, 0x11, 0x89, 0x41, 0x7c, 0xdd,\n//                     0xdb, 0xf9, 0x59, 0x52, 0x99, 0x3a, 0xa9, 0xcb, 0x9c, 0x64, 0x0e, 0xb5, 0x05,\n//                     0x8d, 0x09, 0x70, 0x2c, 0x74, 0x62, 0x2c, 0x99, 0x65, 0xa6, 0x97, 0xa3, 0xb3,\n//                     0x45, 0xec, 0x24, 0xee, 0x56, 0x33, 0x5b, 0x55, 0x6e, 0x67, 0x7b, 0x30, 0xe6,\n//                     0xf9, 0x0a, 0xc7, 0x7d, 0x78, 0x10, 0x64, 0xf8, 0x66, 0xa3, 0xc9, 0x82,\n//                 ],\n//                 CompressedRistretto([\n//                     0x80, 0xbd, 0x07, 0x26, 0x25, 0x11, 0xcd, 0xde, 0x48, 0x63, 0xf8, 0xa7, 0x43,\n//                     0x4c, 0xef, 0x69, 0x67, 0x50, 0x68, 0x1c, 0xb9, 0x51, 0x0e, 0xea, 0x55, 0x70,\n//                     0x88, 0xf7, 0x6d, 0x9e, 0x50, 0x65,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                 ],\n//                 CompressedRistretto([\n//                     0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n//                     0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n//                     0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                     0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                 ],\n//                 CompressedRistretto([\n//                     0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n//                     0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n//                     0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n//                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,\n//                 ],\n//                 CompressedRistretto([\n//                     0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n//                     0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n//                     0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n//                 ]),\n//             ),\n//             (\n//                 [\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n//                 ],\n//                 CompressedRistretto([\n//                     0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n//                     0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n//                     0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n//                 ]),\n//             ),\n//         ];\n//         // Check that onewaymap(input) == output for all the above vectors\n//         for (input, output) in test_vectors {\n//             let Q = RistrettoPoint::from_uniform_bytes(input);\n//             assert_eq!(&Q.compress(), output);\n//         }\n//     }\n\n//     #[test]\n//     fn random_roundtrip() {\n//         let mut rng = OsRng.unwrap_err();\n//         for _ in 0..100 {\n//             let P = RistrettoPoint::mul_base(&Scalar::random(&mut rng));\n//             let compressed_P = P.compress();\n//             let Q = compressed_P.decompress().unwrap();\n//             assert_eq!(P, Q);\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(all(feature = \"alloc\", feature = \"rand_core\", feature = \"group\"))]\n//     fn double_and_compress_1024_random_points() {\n//         use group::Group;\n//         let mut rng = OsRng;\n\n//         let mut points: Vec<RistrettoPoint> = (0..1024)\n//             .map(|_| RistrettoPoint::try_from_rng(&mut rng).unwrap())\n//             .collect();\n//         points[500] = <RistrettoPoint as Group>::identity();\n\n//         let compressed = RistrettoPoint::double_and_compress_batch(&points);\n\n//         for (P, P2_compressed) in points.iter().zip(compressed.iter()) {\n//             assert_eq!(*P2_compressed, (P + P).compress());\n//         }\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n//         let mut rng = rand::rng();\n\n//         let static_scalars = (0..128)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         let dynamic_scalars = (0..128)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         let check_scalar: Scalar = static_scalars\n//             .iter()\n//             .chain(dynamic_scalars.iter())\n//             .map(|s| s * s)\n//             .sum();\n\n//         let static_points = static_scalars\n//             .iter()\n//             .map(RistrettoPoint::mul_base)\n//             .collect::<Vec<_>>();\n//         let dynamic_points = dynamic_scalars\n//             .iter()\n//             .map(RistrettoPoint::mul_base)\n//             .collect::<Vec<_>>();\n\n//         let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n\n//         assert_eq!(precomputation.len(), 128);\n//         assert!(!precomputation.is_empty());\n\n//         let P = precomputation.vartime_mixed_multiscalar_mul(\n//             &static_scalars,\n//             &dynamic_scalars,\n//             &dynamic_points,\n//         );\n\n//         use crate::traits::VartimeMultiscalarMul;\n//         let Q = RistrettoPoint::vartime_multiscalar_mul(\n//             static_scalars.iter().chain(dynamic_scalars.iter()),\n//             static_points.iter().chain(dynamic_points.iter()),\n//         );\n\n//         let R = RistrettoPoint::mul_base(&check_scalar);\n\n//         assert_eq!(P.compress(), R.compress());\n//         assert_eq!(Q.compress(), R.compress());\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn partial_precomputed_mixed_multiscalar_empty() {\n//         let mut rng = rand::rng();\n\n//         let n_static = 16;\n//         let n_dynamic = 8;\n\n//         let static_points = (0..n_static)\n//             .map(|_| RistrettoPoint::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         // Use zero scalars\n//         let static_scalars = Vec::new();\n\n//         let dynamic_points = (0..n_dynamic)\n//             .map(|_| RistrettoPoint::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         let dynamic_scalars = (0..n_dynamic)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         // Compute the linear combination using precomputed multiscalar multiplication\n//         let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n//         let result_multiscalar = precomputation.vartime_mixed_multiscalar_mul(\n//             &static_scalars,\n//             &dynamic_scalars,\n//             &dynamic_points,\n//         );\n\n//         // Compute the linear combination manually\n//         let mut result_manual = RistrettoPoint::identity();\n//         for i in 0..static_scalars.len() {\n//             result_manual += static_points[i] * static_scalars[i];\n//         }\n//         for i in 0..n_dynamic {\n//             result_manual += dynamic_points[i] * dynamic_scalars[i];\n//         }\n\n//         assert_eq!(result_multiscalar, result_manual);\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn partial_precomputed_mixed_multiscalar() {\n//         let mut rng = rand::rng();\n\n//         let n_static = 16;\n//         let n_dynamic = 8;\n\n//         let static_points = (0..n_static)\n//             .map(|_| RistrettoPoint::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         // Use one fewer scalars\n//         let static_scalars = (0..n_static - 1)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         let dynamic_points = (0..n_dynamic)\n//             .map(|_| RistrettoPoint::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         let dynamic_scalars = (0..n_dynamic)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         // Compute the linear combination using precomputed multiscalar multiplication\n//         let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n//         let result_multiscalar = precomputation.vartime_mixed_multiscalar_mul(\n//             &static_scalars,\n//             &dynamic_scalars,\n//             &dynamic_points,\n//         );\n\n//         // Compute the linear combination manually\n//         let mut result_manual = RistrettoPoint::identity();\n//         for i in 0..static_scalars.len() {\n//             result_manual += static_points[i] * static_scalars[i];\n//         }\n//         for i in 0..n_dynamic {\n//             result_manual += dynamic_points[i] * dynamic_scalars[i];\n//         }\n\n//         assert_eq!(result_multiscalar, result_manual);\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn partial_precomputed_multiscalar() {\n//         let mut rng = rand::rng();\n\n//         let n_static = 16;\n\n//         let static_points = (0..n_static)\n//             .map(|_| RistrettoPoint::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         // Use one fewer scalars\n//         let static_scalars = (0..n_static - 1)\n//             .map(|_| Scalar::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         // Compute the linear combination using precomputed multiscalar multiplication\n//         let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n//         let result_multiscalar = precomputation.vartime_multiscalar_mul(&static_scalars);\n\n//         // Compute the linear combination manually\n//         let mut result_manual = RistrettoPoint::identity();\n//         for i in 0..static_scalars.len() {\n//             result_manual += static_points[i] * static_scalars[i];\n//         }\n\n//         assert_eq!(result_multiscalar, result_manual);\n//     }\n\n//     #[test]\n//     #[cfg(feature = \"alloc\")]\n//     fn partial_precomputed_multiscalar_empty() {\n//         let mut rng = rand::rng();\n\n//         let n_static = 16;\n\n//         let static_points = (0..n_static)\n//             .map(|_| RistrettoPoint::random(&mut rng))\n//             .collect::<Vec<_>>();\n\n//         // Use zero scalars\n//         let static_scalars = Vec::new();\n\n//         // Compute the linear combination using precomputed multiscalar multiplication\n//         let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n//         let result_multiscalar = precomputation.vartime_multiscalar_mul(&static_scalars);\n\n//         // Compute the linear combination manually\n//         let mut result_manual = RistrettoPoint::identity();\n//         for i in 0..static_scalars.len() {\n//             result_manual += static_points[i] * static_scalars[i];\n//         }\n\n//         assert_eq!(result_multiscalar, result_manual);\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/ristretto.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65056": {
    "text": "//! Build time diagnostics\n\n// auto is assumed or selected\n#[cfg(curve25519_dalek_backend = \"auto\")]\ncompile_error!(\"curve25519_dalek_backend is 'auto'\");\n\n// fiat was overridden\n#[cfg(curve25519_dalek_backend = \"fiat\")]\ncompile_error!(\"curve25519_dalek_backend is 'fiat'\");\n\n// serial was assumed or overridden\n#[cfg(curve25519_dalek_backend = \"serial\")]\ncompile_error!(\"curve25519_dalek_backend is 'serial'\");\n\n// simd was assumed over overridden\n#[cfg(curve25519_dalek_backend = \"simd\")]\ncompile_error!(\"curve25519_dalek_backend is 'simd'\");\n\n// 32 bits target_pointer_width was assumed or overridden\n#[cfg(curve25519_dalek_bits = \"32\")]\ncompile_error!(\"curve25519_dalek_bits is '32'\");\n\n// 64 bits target_pointer_width was assumed or overridden\n#[cfg(curve25519_dalek_bits = \"64\")]\ncompile_error!(\"curve25519_dalek_bits is '64'\");\n",
    "filename": "curve25519-dalek/src/diagnostics.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65057": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n#![no_std]\n#![cfg_attr(docsrs, feature(doc_auto_cfg, doc_cfg, doc_cfg_hide))]\n#![cfg_attr(docsrs, doc(cfg_hide(docsrs)))]\n//------------------------------------------------------------------------\n// Documentation:\n//------------------------------------------------------------------------\n#![doc(\n    html_logo_url = \"https://cdn.jsdelivr.net/gh/dalek-cryptography/curve25519-dalek/docs/assets/dalek-logo-clear.png\"\n)]\n#![doc = include_str!(\"../README.md\")]\n//------------------------------------------------------------------------\n// Linting:\n//------------------------------------------------------------------------\n#![cfg_attr(allow_unused_unsafe, allow(unused_unsafe))]\n#![warn(clippy::unwrap_used, missing_docs, rust_2018_idioms, unused_lifetimes)]\n\n//------------------------------------------------------------------------\n// External dependencies:\n//------------------------------------------------------------------------\n\n#[cfg(feature = \"alloc\")]\n#[allow(unused_imports)]\n#[macro_use]\nextern crate alloc;\n\n// TODO: move std-dependent tests to `tests/`\n#[cfg(test)]\n#[macro_use]\nextern crate std;\n\n// #[cfg(feature = \"digest\")]\n// pub use digest;\n\n// Internal macros. Must come first!\n#[macro_use]\npub(crate) mod macros;\n\n//------------------------------------------------------------------------\n// curve25519-dalek public modules\n//------------------------------------------------------------------------\n\n// Scalar arithmetic mod l = 2^252 + ..., the order of the Ristretto group\npub mod scalar;\n\n// Point operations on the Montgomery form of Curve25519\npub mod montgomery;\n\n// Point operations on the Edwards form of Curve25519\npub mod edwards;\n\n// Group operations on the Ristretto group\npub mod ristretto;\n\n// Useful constants, like the Ed25519 basepoint\npub mod constants;\n\n// External (and internal) traits.\npub mod traits;\n\n//------------------------------------------------------------------------\n// curve25519-dalek internal modules\n//------------------------------------------------------------------------\n\n// Finite field arithmetic mod p = 2^255 - 19\npub(crate) mod field;\n\n// Arithmetic backends (using u32, u64, etc) live here\n#[cfg(docsrs)]\npub mod backend;\n#[cfg(not(docsrs))]\npub(crate) mod backend;\n\n// Generic code for window lookups\npub(crate) mod window;\n\npub use crate::{\n    edwards::EdwardsPoint, montgomery::MontgomeryPoint, ristretto::RistrettoPoint, scalar::Scalar,\n};\n\n// Build time diagnostics for validation\n#[cfg(curve25519_dalek_diagnostics = \"build\")]\nmod diagnostics;\n",
    "filename": "curve25519-dalek/src/lib.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65058": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n//! Various constants, such as the Ristretto and Ed25519 basepoints.\n\n#![allow(non_snake_case)]\n\nuse cfg_if::cfg_if;\n\nuse crate::edwards::CompressedEdwardsY;\nuse crate::montgomery::MontgomeryPoint;\nuse crate::ristretto::{CompressedRistretto, RistrettoPoint};\nuse crate::scalar::Scalar;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::edwards::EdwardsBasepointTable;\n\ncfg_if! {\n    if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        pub use crate::backend::serial::fiat_u32::constants::*;\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        pub use crate::backend::serial::fiat_u64::constants::*;\n    } else {\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        pub use crate::backend::serial::u32::constants::*;\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        pub use crate::backend::serial::u64::constants::*;\n    }\n}\n\n/// The Ed25519 basepoint, in `CompressedEdwardsY` format.\n///\n/// This is the little-endian byte encoding of \\\\( 4/5 \\pmod p \\\\),\n/// which is the \\\\(y\\\\)-coordinate of the Ed25519 basepoint.\n///\n/// The sign bit is 0 since the basepoint has \\\\(x\\\\) chosen to be positive.\npub const ED25519_BASEPOINT_COMPRESSED: CompressedEdwardsY = CompressedEdwardsY([\n    0x58, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n]);\n\n/// The X25519 basepoint, in `MontgomeryPoint` format.\npub const X25519_BASEPOINT: MontgomeryPoint = MontgomeryPoint([\n    0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n]);\n\n/// The Ristretto basepoint, in `CompressedRistretto` format.\npub const RISTRETTO_BASEPOINT_COMPRESSED: CompressedRistretto = CompressedRistretto([\n    0xe2, 0xf2, 0xae, 0x0a, 0x6a, 0xbc, 0x4e, 0x71, 0xa8, 0x84, 0xa9, 0x61, 0xc5, 0x00, 0x51, 0x5f,\n    0x58, 0xe3, 0x0b, 0x6a, 0xa5, 0x82, 0xdd, 0x8d, 0xb6, 0xa6, 0x59, 0x45, 0xe0, 0x8d, 0x2d, 0x76,\n]);\n\n/// The Ristretto basepoint, as a `RistrettoPoint`.\n///\n/// This is called `_POINT` to distinguish it from `_TABLE`, which\n/// provides fast scalar multiplication.\npub const RISTRETTO_BASEPOINT_POINT: RistrettoPoint = RistrettoPoint(ED25519_BASEPOINT_POINT);\n\n/// `BASEPOINT_ORDER` is the order of the Ristretto group and of the Ed25519 basepoint, i.e.,\n/// $$\n/// \\ell = 2^\\{252\\} + 27742317777372353535851937790883648493.\n/// $$\npub(crate) const BASEPOINT_ORDER: Scalar = Scalar {\n    bytes: [\n        0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde,\n        0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x10,\n    ],\n};\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::ristretto::RistrettoBasepointTable;\n\n/// The Ristretto basepoint, as a `RistrettoBasepointTable` for scalar multiplication.\n#[cfg(feature = \"precomputed-tables\")]\npub static RISTRETTO_BASEPOINT_TABLE: &RistrettoBasepointTable = unsafe {\n    // SAFETY: `RistrettoBasepointTable` is a `#[repr(transparent)]` newtype of\n    // `EdwardsBasepointTable`\n    &*(ED25519_BASEPOINT_TABLE as *const EdwardsBasepointTable as *const RistrettoBasepointTable)\n};\n\n// #[cfg(test)]\n// mod test {\n//     use crate::constants;\n//     use crate::field::FieldElement;\n//     use crate::traits::{IsIdentity, ValidityCheck};\n\n//     #[test]\n//     fn test_eight_torsion() {\n//         for i in 0..8 {\n//             let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(3);\n//             assert!(Q.is_valid());\n//             assert!(Q.is_identity());\n//         }\n//     }\n\n//     #[test]\n//     fn test_four_torsion() {\n//         for i in (0..8).filter(|i| i % 2 == 0) {\n//             let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(2);\n//             assert!(Q.is_valid());\n//             assert!(Q.is_identity());\n//         }\n//     }\n\n//     #[test]\n//     fn test_two_torsion() {\n//         for i in (0..8).filter(|i| i % 4 == 0) {\n//             let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(1);\n//             assert!(Q.is_valid());\n//             assert!(Q.is_identity());\n//         }\n//     }\n\n//     /// Test that SQRT_M1 is the positive square root of -1\n//     #[test]\n//     fn test_sqrt_minus_one() {\n//         let minus_one = FieldElement::MINUS_ONE;\n//         let sqrt_m1_sq = &constants::SQRT_M1 * &constants::SQRT_M1;\n//         assert_eq!(minus_one, sqrt_m1_sq);\n//         assert!(bool::from(!constants::SQRT_M1.is_negative()));\n//     }\n\n//     #[test]\n//     fn test_sqrt_constants_sign() {\n//         let minus_one = FieldElement::MINUS_ONE;\n//         let (was_nonzero_square, invsqrt_m1) = minus_one.invsqrt();\n//         assert!(bool::from(was_nonzero_square));\n//         let sign_test_sqrt = &invsqrt_m1 * &constants::SQRT_M1;\n//         assert_eq!(sign_test_sqrt, minus_one);\n//     }\n\n//     /// Test that d = -121665/121666\n//     #[test]\n//     #[cfg(all(curve25519_dalek_bits = \"32\", not(curve25519_dalek_backend = \"fiat\")))]\n//     fn test_d_vs_ratio() {\n//         use crate::backend::serial::u32::field::FieldElement2625;\n//         let a = -&FieldElement2625([121665, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n//         let b = FieldElement2625([121666, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n//         let d = &a * &b.invert();\n//         let d2 = &d + &d;\n//         assert_eq!(d, constants::EDWARDS_D);\n//         assert_eq!(d2, constants::EDWARDS_D2);\n//     }\n\n//     /// Test that d = -121665/121666\n//     #[test]\n//     #[cfg(all(curve25519_dalek_bits = \"64\", not(curve25519_dalek_backend = \"fiat\")))]\n//     fn test_d_vs_ratio() {\n//         use crate::backend::serial::u64::field::FieldElement51;\n//         let a = -&FieldElement51([121665, 0, 0, 0, 0]);\n//         let b = FieldElement51([121666, 0, 0, 0, 0]);\n//         let d = &a * &b.invert();\n//         let d2 = &d + &d;\n//         assert_eq!(d, constants::EDWARDS_D);\n//         assert_eq!(d2, constants::EDWARDS_D2);\n//     }\n\n//     #[test]\n//     fn test_sqrt_ad_minus_one() {\n//         let a = FieldElement::MINUS_ONE;\n//         let ad_minus_one = &(&a * &constants::EDWARDS_D) + &a;\n//         let should_be_ad_minus_one = constants::SQRT_AD_MINUS_ONE.square();\n//         assert_eq!(should_be_ad_minus_one, ad_minus_one);\n//     }\n\n//     /// Test that ED25519_SQRTAM2 squared is MONTGOMERY_A_NEG - 2\n//     #[test]\n//     #[cfg(feature = \"digest\")]\n//     fn test_sqrt_a_minus_2() {\n//         let one = FieldElement::ONE;\n//         let a_minus_two = &(&constants::MONTGOMERY_A_NEG - &one) - &one;\n\n//         assert_eq!(constants::ED25519_SQRTAM2.square(), a_minus_two)\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/constants.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65059": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Module for common traits.\n\n#![allow(non_snake_case)]\n\nuse core::borrow::Borrow;\n\nuse crate::scalar::{Scalar, clamp_integer};\nuse subtle::ConstantTimeEq;\n\n// ------------------------------------------------------------------------\n// Public Traits\n// ------------------------------------------------------------------------\n\n/// Trait for getting the identity element of a point type.\npub trait Identity {\n    /// Returns the identity element of the curve.\n    /// Can be used as a constructor.\n    fn identity() -> Self;\n}\n\n/// Trait for testing if a curve point is equivalent to the identity point.\npub trait IsIdentity {\n    /// Return true if this element is the identity element of the curve.\n    fn is_identity(&self) -> bool;\n}\n\n/// Implement generic identity equality testing for a point representations\n/// which have constant-time equality testing and a defined identity\n/// constructor.\nimpl<T> IsIdentity for T\nwhere\n    T: ConstantTimeEq + Identity,\n{\n    fn is_identity(&self) -> bool {\n        self.ct_eq(&T::identity()).into()\n    }\n}\n\n/// A precomputed table of basepoints, for optimising scalar multiplications.\npub trait BasepointTable {\n    /// The type of point contained within this table.\n    type Point;\n\n    /// Generate a new precomputed basepoint table from the given basepoint.\n    fn create(basepoint: &Self::Point) -> Self;\n\n    /// Retrieve the original basepoint from this table.\n    fn basepoint(&self) -> Self::Point;\n\n    /// Multiply a `scalar` by this precomputed basepoint table, in constant time.\n    fn mul_base(&self, scalar: &Scalar) -> Self::Point;\n\n    /// Multiply `clamp_integer(bytes)` by this precomputed basepoint table, in constant time. For\n    /// a description of clamping, see [`clamp_integer`].\n    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }\n}\n\n/// A trait for constant-time multiscalar multiplication without precomputation.\npub trait MultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of (possibly secret) scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n.\n    /// $$\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// # #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::MultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>;\n}\n\n/// A trait for variable-time multiscalar multiplication without precomputation.\npub trait VartimeMultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// `Option`s of points, compute either `Some(Q)`, where\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// if all points were `Some(P_i)`, or else return `None`.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    /// let abc = [a,b,c];\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    /// let PQR = [P, Q, R];\n    ///\n    /// let compressed = [P.compress(), Q.compress(), R.compress()];\n    ///\n    /// // Now we can compute A1 = a*P + b*Q + c*R using P, Q, R:\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &PQR);\n    ///\n    /// // Or using the compressed points:\n    /// let A2 = RistrettoPoint::optional_multiscalar_mul(\n    ///     &abc,\n    ///     compressed.iter().map(|pt| pt.decompress()),\n    /// );\n    ///\n    /// assert_eq!(A2, Some(A1));\n    ///\n    /// // It's also possible to mix compressed and uncompressed points:\n    /// let A3 = RistrettoPoint::optional_multiscalar_mul(\n    ///     abc.iter()\n    ///         .chain(abc.iter()),\n    ///     compressed.iter().map(|pt| pt.decompress())\n    ///         .chain(PQR.iter().map(|&pt| Some(pt))),\n    /// );\n    ///\n    /// assert_eq!(A3, Some(A1+A1));\n    /// # }\n    /// ```\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n}\n\n/// A trait for variable-time multiscalar multiplication with precomputation.\n///\n/// A general multiscalar multiplication with precomputation can be written as\n/// $$\n/// Q = a_1 A_1 + \\cdots + a_n A_n + b_1 B_1 + \\cdots + b_m B_m,\n/// $$\n/// where the \\\\(B_i\\\\) are *static* points, for which precomputation\n/// is possible, and the \\\\(A_j\\\\) are *dynamic* points, for which\n/// precomputation is not possible.\n///\n/// This trait has three methods for performing this computation:\n///\n/// * [`Self::vartime_multiscalar_mul`], which handles the special case where\n///   \\\\(n = 0\\\\) and there are no dynamic points;\n///\n/// * [`Self::vartime_mixed_multiscalar_mul`], which takes the dynamic points as\n///   already-validated `Point`s and is infallible;\n///\n/// * [`Self::optional_mixed_multiscalar_mul`], which takes the dynamic points\n///   as `Option<Point>`s and returns an `Option<Point>`, allowing decompression\n///   to be composed into the input iterators.\n///\n/// All methods require that the lengths of the input iterators be\n/// known, as if they were `ExactSizeIterator`s.  (It\n/// does not require `ExactSizeIterator` only because that trait is\n/// broken).\npub trait VartimePrecomputedMultiscalarMul: Sized {\n    /// The type of point to be multiplied, e.g., `RistrettoPoint`.\n    type Point: Clone;\n\n    /// Given the static points \\\\( B_i \\\\), perform precomputation\n    /// and return the precomputation data.\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Return the number of static points in the precomputation.\n    fn len(&self) -> usize;\n\n    /// Determine if the precomputation is empty.\n    fn is_empty(&self) -> bool;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\).\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), `dynamic_scalars`, an iterator of public scalars\n    /// \\\\(a_i\\\\), and `dynamic_points`, an iterator of points\n    /// \\\\(A_i\\\\), compute\n    /// $$\n    /// Q = a_1 A_1 + \\cdots + a_n A_n + b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\), or if \\\\(a_i\\\\) and \\\\(A_i\\\\) do not have\n    /// the same length.\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    fn vartime_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator,\n        K::Item: Borrow<Self::Point>,\n    {\n        Self::optional_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            dynamic_scalars,\n            dynamic_points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), `dynamic_scalars`, an iterator of public scalars\n    /// \\\\(a_i\\\\), and `dynamic_points`, an iterator of points\n    /// \\\\(A_i\\\\), compute\n    /// $$\n    /// Q = a_1 A_1 + \\cdots + a_n A_n + b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// If any of the dynamic points were `None`, return `None`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\), or if \\\\(a_i\\\\) and \\\\(A_i\\\\) do not have\n    /// the same length.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>;\n}\n\n// ------------------------------------------------------------------------\n// Private Traits\n// ------------------------------------------------------------------------\n\n/// Trait for checking whether a point is on the curve.\n///\n/// This trait is only for debugging/testing, since it should be\n/// impossible for a `curve25519-dalek` user to construct an invalid\n/// point.\n#[allow(dead_code)]\npub(crate) trait ValidityCheck {\n    /// Checks whether the point is on the curve. Not CT.\n    fn is_valid(&self) -> bool;\n}\n",
    "filename": "curve25519-dalek/src/traits.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65060": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Code for fixed- and sliding-window functionality\n\n#![allow(non_snake_case)]\n\nuse core::fmt::Debug;\n\nuse cfg_if::cfg_if;\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\nuse crate::traits::Identity;\n\nuse crate::backend::serial::curve_models::AffineNielsPoint;\nuse crate::backend::serial::curve_models::ProjectiveNielsPoint;\nuse crate::edwards::EdwardsPoint;\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::Zeroize;\n\nmacro_rules! impl_lookup_table {\n    (Name = $name:ident, Size = $size:expr, SizeNeg = $neg:expr, SizeRange = $range:expr, ConversionRange = $conv_range:expr) => {\n        /// A lookup table of precomputed multiples of a point \\\\(P\\\\), used to\n        /// compute \\\\( xP \\\\) for \\\\( -8 \\leq x \\leq 8 \\\\).\n        ///\n        /// The computation of \\\\( xP \\\\) is done in constant time by the `select` function.\n        ///\n        /// Since `LookupTable` does not implement `Index`, it's more difficult\n        /// to accidentally use the table directly.  Unfortunately the table is\n        /// only `pub(crate)` so that we can write hardcoded constants, so it's\n        /// still technically possible.  It would be nice to prevent direct\n        /// access to the table.\n        #[derive(Copy, Clone)]\n        pub struct $name<T>(pub(crate) [T; $size]);\n\n        impl<T> $name<T>\n        where\n            T: Identity + ConditionallySelectable + ConditionallyNegatable,\n        {\n            /// Given \\\\(-8 \\leq x \\leq 8\\\\), return \\\\(xP\\\\) in constant time.\n            pub fn select(&self, x: i8) -> T {\n                debug_assert!(x >= $neg);\n                debug_assert!(x as i16 <= $size as i16); // XXX We have to convert to i16s here for the radix-256 case.. this is wrong.\n\n                // Compute xabs = |x|\n                let xmask = x as i16 >> 7;\n                let xabs = (x as i16 + xmask) ^ xmask;\n\n                // Set t = 0 * P = identity\n                let mut t = T::identity();\n                for j in $range {\n                    // Copy `points[j-1] == j*P` onto `t` in constant time if `|x| == j`.\n                    let c = (xabs as u16).ct_eq(&(j as u16));\n                    t.conditional_assign(&self.0[j - 1], c);\n                }\n                // Now t == |x| * P.\n\n                let neg_mask = Choice::from((xmask & 1) as u8);\n                t.conditional_negate(neg_mask);\n                // Now t == x * P.\n\n                t\n            }\n        }\n\n        impl<T: Copy + Default> Default for $name<T> {\n            fn default() -> $name<T> {\n                $name([T::default(); $size])\n            }\n        }\n\n        impl<T: Debug> Debug for $name<T> {\n            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(f, \"{:?}(\", stringify!($name))?;\n\n                for x in self.0.iter() {\n                    write!(f, \"{:?}\", x)?;\n                }\n\n                write!(f, \")\")\n            }\n        }\n\n        impl<'a> From<&'a EdwardsPoint> for $name<ProjectiveNielsPoint> {\n            fn from(P: &'a EdwardsPoint) -> Self {\n                let mut points = [P.as_projective_niels(); $size];\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_projective_niels();\n                }\n                $name(points)\n            }\n        }\n\n        impl<'a> From<&'a EdwardsPoint> for $name<AffineNielsPoint> {\n            fn from(P: &'a EdwardsPoint) -> Self {\n                let mut points = [P.as_affine_niels(); $size];\n                // XXX batch inversion would be good if perf mattered here\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_affine_niels()\n                }\n                $name(points)\n            }\n        }\n\n        // #[cfg(feature = \"zeroize\")]\n        // impl<T> Zeroize for $name<T>\n        // where\n        //     T: Copy + Default + Zeroize,\n        // {\n        //     fn zeroize(&mut self) {\n        //         self.0.iter_mut().zeroize();\n        //     }\n        // }\n    };\n} // End macro_rules! impl_lookup_table\n\n// The first one has to be named \"LookupTable\" because it's used as a constructor for consts.\n// This is radix-16\nimpl_lookup_table! {\n    Name = LookupTable,\n    Size = 8,\n    SizeNeg = -8,\n    SizeRange = 1..9,\n    ConversionRange = 0..7\n}\n\n// The rest only get used to make basepoint tables\ncfg_if! {\n    if #[cfg(feature = \"precomputed-tables\")] {\n        // radix-32\n        impl_lookup_table! {\n            Name = LookupTableRadix32,\n            Size = 16,\n            SizeNeg = -16,\n            SizeRange = 1..17,\n            ConversionRange = 0..15\n        }\n        // radix-64\n        impl_lookup_table! {\n            Name = LookupTableRadix64,\n            Size = 32,\n            SizeNeg = -32,\n            SizeRange = 1..33,\n            ConversionRange = 0..31\n        }\n        // radix-128\n        impl_lookup_table! {\n            Name = LookupTableRadix128,\n            Size = 64,\n            SizeNeg = -64,\n            SizeRange = 1..65,\n            ConversionRange = 0..63\n        }\n        // radix-256\n        impl_lookup_table! {\n            Name = LookupTableRadix256,\n            Size = 128,\n            SizeNeg = -128,\n            SizeRange = 1..129,\n            ConversionRange = 0..127\n        }\n\n        // For homogeneity we then alias it to \"LookupTableRadix16\".\n        pub(crate) type LookupTableRadix16<T> = LookupTable<T>;\n    }\n}\n\n/// Holds odd multiples 1A, 3A, ..., 15A of a point A.\n#[derive(Copy, Clone)]\npub(crate) struct NafLookupTable5<T>(pub(crate) [T; 8]);\n\nimpl<T: Copy> NafLookupTable5<T> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 16);\n\n        self.0[x / 2]\n    }\n}\n\nimpl<T: Debug> Debug for NafLookupTable5<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"NafLookupTable5({:?})\", self.0)\n    }\n}\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<ProjectiveNielsPoint> {\n    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }\n}\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<AffineNielsPoint> {\n    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }\n}\n\n/// Holds stuff up to 8. The only time we use tables this big is for precomputed basepoint tables\n/// and multiscalar multiplication (which requires alloc).\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n#[derive(Copy, Clone)]\npub(crate) struct NafLookupTable8<T>(pub(crate) [T; 64]);\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> NafLookupTable8<T> {\n    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 128);\n\n        self.0[x / 2]\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        writeln!(f, \"NafLookupTable8([\")?;\n        for i in 0..64 {\n            writeln!(f, \"\\t{:?},\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }\n}\n",
    "filename": "curve25519-dalek/src/window.rs",
    "filepath": null,
    "folder_id": 16162,
    "user_id": 460160
  },
  "65061": {
    "text": "use super::{CompressedEdwardsY, EdwardsPoint};\nuse crate::traits::Identity;\nuse crate::{Scalar, field::FieldElement};\nuse core::ops::Mul;\nuse subtle::{Choice, ConditionallySelectable, ConstantTimeEq};\n\n// #[cfg(feature = \"zeroize\")]\n// use zeroize::DefaultIsZeroes;\n\n/// Affine Edwards point on untwisted curve.\n#[derive(Copy, Clone, Debug)]\npub struct AffinePoint {\n    pub(super) x: FieldElement,\n    pub(super) y: FieldElement,\n}\n\nimpl ConstantTimeEq for AffinePoint {\n    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }\n}\n\nimpl ConditionallySelectable for AffinePoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }\n}\n\nimpl Default for AffinePoint {\n    fn default() -> AffinePoint {\n        AffinePoint::identity()\n    }\n}\n\nimpl Identity for AffinePoint {\n    fn identity() -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::ZERO,\n            y: FieldElement::ONE,\n        }\n    }\n}\n\nimpl PartialEq for AffinePoint {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for AffinePoint {}\n\n// #[cfg(feature = \"zeroize\")]\n// impl DefaultIsZeroes for AffinePoint {}\n\nimpl AffinePoint {\n    /// Convert to extended coordinates.\n    pub fn to_edwards(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T: &self.x * &self.y,\n        }\n    }\n\n    /// Compress affine Edwards coordinates into `CompressedEdwardsY` format.\n    #[inline]\n    pub fn compress(self) -> CompressedEdwardsY {\n        let mut s = self.y.to_bytes();\n        s[31] ^= self.x.is_negative().unwrap_u8() << 7;\n        CompressedEdwardsY(s)\n    }\n}\n\nimpl Mul<AffinePoint> for Scalar {\n    type Output = EdwardsPoint;\n\n    #[inline]\n    fn mul(self, rhs: AffinePoint) -> EdwardsPoint {\n        self * &rhs\n    }\n}\n\nimpl Mul<&AffinePoint> for Scalar {\n    type Output = EdwardsPoint;\n\n    #[inline]\n    fn mul(self, rhs: &AffinePoint) -> EdwardsPoint {\n        rhs.to_edwards() * self\n    }\n}\n\n// #[cfg(test)]\n// mod tests {\n//     use super::{AffinePoint, EdwardsPoint, Identity};\n//     use crate::constants;\n\n//     #[test]\n//     fn identity_conversion() {\n//         assert_eq!(\n//             AffinePoint::identity().to_edwards(),\n//             EdwardsPoint::identity()\n//         );\n//     }\n\n//     #[test]\n//     fn generator_round_trip() {\n//         let basepoint = constants::ED25519_BASEPOINT_POINT;\n//         assert_eq!(basepoint.to_affine().to_edwards(), basepoint);\n//     }\n// }\n",
    "filename": "curve25519-dalek/src/edwards/affine.rs",
    "filepath": null,
    "folder_id": 16168,
    "user_id": 460160
  },
  "65062": {
    "text": "//! This selects the curve25519_dalek_bits either by default from target_pointer_width or explicitly set\n\n#![deny(clippy::unwrap_used, dead_code)]\n\n#[allow(non_camel_case_types)]\n#[derive(PartialEq, Debug)]\nenum DalekBits {\n    Dalek32,\n    Dalek64,\n}\n\nuse std::fmt::Formatter;\n\nimpl std::fmt::Display for DalekBits {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let w_bits = match self {\n            DalekBits::Dalek32 => \"32\",\n            DalekBits::Dalek64 => \"64\",\n        };\n        write!(f, \"{}\", w_bits)\n    }\n}\n\nfn main() {\n    let target_arch = match std::env::var(\"CARGO_CFG_TARGET_ARCH\") {\n        Ok(arch) => arch,\n        _ => \"\".to_string(),\n    };\n\n    let curve25519_dalek_bits = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BITS\").as_deref() {\n        Ok(\"32\") => DalekBits::Dalek32,\n        Ok(\"64\") => DalekBits::Dalek64,\n        _ => deterministic::determine_curve25519_dalek_bits(&target_arch),\n    };\n\n    println!(\"cargo:rustc-cfg=curve25519_dalek_bits=\\\"{curve25519_dalek_bits}\\\"\");\n\n    let nightly = if rustc_version::version_meta()\n        .expect(\"failed to detect rustc version\")\n        .channel\n        == rustc_version::Channel::Nightly\n    {\n        println!(\"cargo:rustc-cfg=nightly\");\n        true\n    } else {\n        false\n    };\n\n    let rustc_version = rustc_version::version().expect(\"failed to detect rustc version\");\n    if rustc_version.major == 1 && rustc_version.minor <= 64 {\n        // Old versions of Rust complain when you have an `unsafe fn` and you use `unsafe {}` inside,\n        // so for those we want to apply the `#[allow(unused_unsafe)]` attribute to get rid of that warning.\n        println!(\"cargo:rustc-cfg=allow_unused_unsafe\");\n    }\n\n    // Backend overrides / defaults\n    let curve25519_dalek_backend = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BACKEND\")\n        .as_deref()\n    {\n        Ok(\"fiat\") => \"fiat\",\n        Ok(\"serial\") => \"serial\",\n        Ok(\"simd\") => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => \"simd\",\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to simd\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if nightly => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => {\n                    // In addition enable Avx2 fallback through simd stable backend\n                    // NOTE: Compiler permits duplicate / multi value on the same key\n                    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"simd\\\"\");\n\n                    \"unstable_avx512\"\n                }\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to unstable_avx512\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if !nightly => {\n            panic!(\n                \"Could not override curve25519_dalek_backend to unstable_avx512, as this is nightly only\"\n            );\n        }\n        // default between serial / simd (if potentially capable)\n        _ => match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n            true => \"simd\",\n            false => \"serial\",\n        },\n    };\n    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"{curve25519_dalek_backend}\\\"\");\n}\n\n// Is the target arch & curve25519_dalek_bits potentially simd capable ?\nfn is_capable_simd(arch: &str, bits: DalekBits) -> bool {\n    arch == \"x86_64\" && bits == DalekBits::Dalek64\n}\n\n// Deterministic cfg(curve25519_dalek_bits) when this is not explicitly set.\nmod deterministic {\n\n    use super::*;\n\n    // Custom Rust non-cargo build tooling needs to set CARGO_CFG_TARGET_POINTER_WIDTH\n    static ERR_MSG_NO_POINTER_WIDTH: &str =\n        \"Standard Cargo TARGET_POINTER_WIDTH environment variable is not set.\";\n\n    // When either non-32 or 64 TARGET_POINTER_WIDTH detected\n    static ERR_MSG_UNKNOWN_POINTER_WIDTH: &str = \"Unknown TARGET_POINTER_WIDTH detected.\";\n\n    // Warning when the curve25519_dalek_bits cannot be determined\n    fn determine_curve25519_dalek_bits_warning(cause: &str) {\n        println!(\"cargo:warning=\\\"Defaulting to curve25519_dalek_bits=32: {cause}\\\"\");\n    }\n\n    // Determine the curve25519_dalek_bits based on Rust standard TARGET triplet\n    pub(super) fn determine_curve25519_dalek_bits(target_arch: &String) -> DalekBits {\n        let target_pointer_width = match std::env::var(\"CARGO_CFG_TARGET_POINTER_WIDTH\") {\n            Ok(pw) => pw,\n            Err(_) => {\n                determine_curve25519_dalek_bits_warning(ERR_MSG_NO_POINTER_WIDTH);\n                return DalekBits::Dalek32;\n            }\n        };\n\n        #[allow(clippy::match_single_binding)]\n        match &target_arch {\n            //Issues: 449 and 456\n            //TODO: When adding arch defaults use proper types not String match\n            //TODO(Arm): Needs tests + benchmarks to back this up\n            //TODO(Wasm32): Needs tests + benchmarks to back this up\n            _ => match target_pointer_width.as_ref() {\n                \"64\" => DalekBits::Dalek64,\n                \"32\" => DalekBits::Dalek32,\n                // Intended default solely for non-32/64 target pointer widths\n                // Otherwise known target platforms only.\n                _ => {\n                    determine_curve25519_dalek_bits_warning(ERR_MSG_UNKNOWN_POINTER_WIDTH);\n                    DalekBits::Dalek32\n                }\n            },\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/build.rs",
    "filepath": null,
    "folder_id": 16161,
    "user_id": 460160
  }
}