{
  "63564": {
    "text": "#![cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n#![allow(dead_code)]\n#![allow(unused_imports)]\n\nuse curve25519_dalek_derive::{unsafe_target_feature, unsafe_target_feature_specialize};\n\n#[unsafe_target_feature(\"sse2\")]\n/// A doc comment.\nfn function(a: u32, b: u32) -> u32 {\n    a - b\n}\n\n#[unsafe_target_feature(\"sse2\")]\nfn function_with_const_arg<const N: u32>(b: u32) -> u32 {\n    N - b\n}\n\n#[unsafe_target_feature(\"sse2\")]\nfn function_with_where_clause<T>(a: T, b: T) -> T::Output\nwhere\n    T: Copy + core::ops::Sub,\n{\n    a - b\n}\n\n#[unsafe_target_feature(\"sse2\")]\n#[rustfmt::skip]\nfn function_with_rustfmt_skip() {}\n\nstruct Struct {\n    a: u32,\n}\n\n#[unsafe_target_feature(\"sse2\")]\nimpl Struct {\n    #[allow(unused_mut)]\n    fn member_function(&self, mut b: u32) -> u32 {\n        self.a - b\n    }\n\n    fn member_function_with_const_arg<const N: u32>(self) -> u32 {\n        self.a - N\n    }\n}\n\nstruct StructWithGenerics<T>\nwhere\n    T: Copy + core::ops::Sub,\n{\n    a: T,\n}\n\n#[unsafe_target_feature(\"sse2\")]\nimpl<T> StructWithGenerics<T>\nwhere\n    T: Copy + core::ops::Sub,\n{\n    #[inline]\n    fn member_function(&self, b: T) -> T::Output {\n        self.a - b\n    }\n}\n\nstruct StructWithGenericsNoWhere<T: Copy + core::ops::Sub> {\n    a: T,\n}\n\n#[unsafe_target_feature(\"sse2\")]\nimpl<T: Copy + core::ops::Sub> StructWithGenericsNoWhere<T> {\n    #[inline(always)]\n    fn member_function(&self, b: T) -> T::Output {\n        self.a - b\n    }\n}\n\n#[unsafe_target_feature(\"sse2\")]\n#[allow(dead_code)]\nimpl<'a> From<&'a Struct> for () {\n    fn from(_: &'a Struct) -> Self {}\n}\n\n#[unsafe_target_feature(\"sse2\")]\nmod inner {\n    fn inner_function(a: u32, b: u32) -> u32 {\n        a - b\n    }\n}\n\n#[unsafe_target_feature_specialize(\"sse2\", \"avx2\")]\nmod inner_spec {\n    #[for_target_feature(\"sse2\")]\n    const CONST: u32 = 1;\n\n    #[for_target_feature(\"avx2\")]\n    const CONST: u32 = 2;\n\n    pub fn spec_function(a: u32, b: u32) -> u32 {\n        a - b - CONST\n    }\n\n    #[for_target_feature(\"sse2\")]\n    const IS_AVX2: bool = false;\n\n    #[for_target_feature(\"avx2\")]\n    const IS_AVX2: bool = true;\n\n    #[test]\n    fn test_specialized() {\n        assert!(!IS_AVX2);\n    }\n\n    #[cfg(test)]\n    mod tests {\n        #[test]\n        fn test_specialized_inner() {\n            assert!(!super::IS_AVX2);\n        }\n    }\n}\n\n#[unsafe_target_feature(\"sse2\")]\n#[test]\nfn test_sse2_only() {}\n\n// it turns out that for compilation to succeed, the feature needs be supported by rustc. For this\n// test actually verify what happens when the target_feature is not enabled, this needs to be a\n// pretty esoteric feature. Looking at the table of supported avx512 features at\n// https://en.wikipedia.org/wiki/AVX-512#CPUs_with_AVX-512 it seems avx512vp2intersect is one of the\n// most unusual ones that has rustc knows about\n#[unsafe_target_feature(\"avx512vp2intersect\")]\n#[test]\nfn test_unset_target_feature() {\n    compile_error!(\"When an unknown target_feature is set on a test, unsafe_target_feature is expected remove the function\");\n}\n\n#[test]\nfn test_function() {\n    assert_eq!(function(10, 3), 7);\n    assert_eq!(function_with_where_clause(10, 3), 7);\n    assert_eq!(function_with_const_arg::<10>(3), 7);\n    assert_eq!(Struct { a: 10 }.member_function(3), 7);\n    assert_eq!(StructWithGenerics { a: 10 }.member_function(3), 7);\n    assert_eq!(StructWithGenericsNoWhere { a: 10 }.member_function(3), 7);\n    assert_eq!(inner_spec_sse2::spec_function(10, 3), 6);\n    assert_eq!(inner_spec_avx2::spec_function(10, 3), 5);\n}\n",
    "filename": "curve25519-dalek-derive/tests/tests.rs",
    "filepath": null,
    "folder_id": 15811,
    "user_id": 460154
  },
  "63568": {
    "text": "#![doc = include_str!(\"../README.md\")]\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::spanned::Spanned;\n\nmacro_rules! unsupported_if_some {\n    ($value:expr) => {\n        if let Some(value) = $value {\n            return syn::Error::new(value.span(), \"unsupported by #[unsafe_target_feature(...)]\")\n                .into_compile_error()\n                .into();\n        }\n    };\n}\n\nmacro_rules! unsupported {\n    ($value: expr) => {\n        return syn::Error::new(\n            $value.span(),\n            \"unsupported by #[unsafe_target_feature(...)]\",\n        )\n        .into_compile_error()\n        .into()\n    };\n}\n\nmod kw {\n    syn::custom_keyword!(conditional);\n}\n\nenum SpecializeArg {\n    LitStr(syn::LitStr),\n    Conditional(Conditional),\n}\n\nimpl SpecializeArg {\n    fn lit(&self) -> &syn::LitStr {\n        match self {\n            SpecializeArg::LitStr(lit) => lit,\n            SpecializeArg::Conditional(conditional) => &conditional.lit,\n        }\n    }\n\n    fn condition(&self) -> Option<&TokenStream2> {\n        match self {\n            SpecializeArg::LitStr(..) => None,\n            SpecializeArg::Conditional(conditional) => Some(&conditional.attr),\n        }\n    }\n}\n\nstruct Conditional {\n    lit: syn::LitStr,\n    attr: TokenStream2,\n}\n\nimpl syn::parse::Parse for Conditional {\n    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        let lit = input.parse()?;\n        input.parse::<syn::Token![,]>()?;\n        let attr = input.parse()?;\n\n        Ok(Conditional { lit, attr })\n    }\n}\n\nimpl syn::parse::Parse for SpecializeArg {\n    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        let lookahead = input.lookahead1();\n        if lookahead.peek(kw::conditional) {\n            input.parse::<kw::conditional>()?;\n\n            let content;\n            syn::parenthesized!(content in input);\n\n            let conditional = content.parse()?;\n            Ok(SpecializeArg::Conditional(conditional))\n        } else {\n            Ok(SpecializeArg::LitStr(input.parse()?))\n        }\n    }\n}\n\nstruct SpecializeArgs(syn::punctuated::Punctuated<SpecializeArg, syn::Token![,]>);\n\nimpl syn::parse::Parse for SpecializeArgs {\n    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {\n        Ok(Self(syn::punctuated::Punctuated::parse_terminated(input)?))\n    }\n}\n\n#[proc_macro_attribute]\npub fn unsafe_target_feature(attributes: TokenStream, input: TokenStream) -> TokenStream {\n    let attributes = syn::parse_macro_input!(attributes as syn::LitStr);\n    let item = syn::parse_macro_input!(input as syn::Item);\n    process_item(&attributes, item, true)\n}\n\n#[proc_macro_attribute]\npub fn unsafe_target_feature_specialize(\n    attributes: TokenStream,\n    input: TokenStream,\n) -> TokenStream {\n    let attributes = syn::parse_macro_input!(attributes as SpecializeArgs);\n    let item_mod = syn::parse_macro_input!(input as syn::ItemMod);\n\n    let mut out = Vec::new();\n    for attributes in attributes.0 {\n        let features: Vec<_> = attributes\n            .lit()\n            .value()\n            .split(',')\n            .map(|feature| feature.replace(' ', \"\"))\n            .collect();\n        let name = format!(\"{}_{}\", item_mod.ident, features.join(\"_\"));\n        let ident = syn::Ident::new(&name, item_mod.ident.span());\n        let mut attrs = item_mod.attrs.clone();\n        if let Some(condition) = attributes.condition() {\n            attrs.push(syn::Attribute {\n                pound_token: Default::default(),\n                style: syn::AttrStyle::Outer,\n                bracket_token: Default::default(),\n                meta: syn::Meta::List(syn::MetaList {\n                    path: syn::Ident::new(\"cfg\", attributes.lit().span()).into(),\n                    delimiter: syn::MacroDelimiter::Paren(Default::default()),\n                    tokens: condition.clone(),\n                }),\n            });\n        }\n\n        let item_mod = process_mod(\n            attributes.lit(),\n            syn::ItemMod {\n                attrs,\n                ident,\n                ..item_mod.clone()\n            },\n            Some(features),\n        );\n\n        out.push(item_mod);\n    }\n\n    quote::quote! {\n        #(#out)*\n    }\n    .into()\n}\n\nfn process_item(attributes: &syn::LitStr, item: syn::Item, strict: bool) -> TokenStream {\n    match item {\n        syn::Item::Fn(function) => process_function(attributes, function, None),\n        syn::Item::Impl(item_impl) => process_impl(attributes, item_impl),\n        syn::Item::Mod(item_mod) => process_mod(attributes, item_mod, None).into(),\n        item => {\n            if strict {\n                unsupported!(item)\n            } else {\n                quote::quote! { #item }.into()\n            }\n        }\n    }\n}\n\nfn process_mod(\n    attributes: &syn::LitStr,\n    mut item_mod: syn::ItemMod,\n    spec_features: Option<Vec<String>>,\n) -> TokenStream2 {\n    if let Some((_, ref mut content)) = item_mod.content {\n        'next_item: for item in content {\n            if let Some(ref spec_features) = spec_features {\n                match item {\n                    syn::Item::Const(syn::ItemConst { ref mut attrs, .. })\n                    | syn::Item::Enum(syn::ItemEnum { ref mut attrs, .. })\n                    | syn::Item::ExternCrate(syn::ItemExternCrate { ref mut attrs, .. })\n                    | syn::Item::Fn(syn::ItemFn { ref mut attrs, .. })\n                    | syn::Item::ForeignMod(syn::ItemForeignMod { ref mut attrs, .. })\n                    | syn::Item::Impl(syn::ItemImpl { ref mut attrs, .. })\n                    | syn::Item::Macro(syn::ItemMacro { ref mut attrs, .. })\n                    | syn::Item::Mod(syn::ItemMod { ref mut attrs, .. })\n                    | syn::Item::Static(syn::ItemStatic { ref mut attrs, .. })\n                    | syn::Item::Struct(syn::ItemStruct { ref mut attrs, .. })\n                    | syn::Item::Trait(syn::ItemTrait { ref mut attrs, .. })\n                    | syn::Item::TraitAlias(syn::ItemTraitAlias { ref mut attrs, .. })\n                    | syn::Item::Type(syn::ItemType { ref mut attrs, .. })\n                    | syn::Item::Union(syn::ItemUnion { ref mut attrs, .. })\n                    | syn::Item::Use(syn::ItemUse { ref mut attrs, .. }) => {\n                        let mut index = 0;\n                        while index < attrs.len() {\n                            let attr = &attrs[index];\n                            if matches!(attr.style, syn::AttrStyle::Outer) {\n                                match attr.meta {\n                                    syn::Meta::List(ref list)\n                                        if is_path_eq(&list.path, \"for_target_feature\") =>\n                                    {\n                                        let feature: syn::LitStr = match list.parse_args() {\n                                            Ok(feature) => feature,\n                                            Err(error) => {\n                                                return error.into_compile_error();\n                                            }\n                                        };\n\n                                        let feature = feature.value();\n                                        if !spec_features.contains(&feature) {\n                                            *item = syn::Item::Verbatim(Default::default());\n                                            continue 'next_item;\n                                        }\n\n                                        attrs.remove(index);\n                                        continue;\n                                    }\n                                    _ => {}\n                                }\n                            }\n\n                            index += 1;\n                            continue;\n                        }\n                    }\n                    _ => {\n                        unsupported!(item_mod);\n                    }\n                }\n            }\n\n            *item = syn::Item::Verbatim(\n                process_item(\n                    attributes,\n                    std::mem::replace(item, syn::Item::Verbatim(Default::default())),\n                    false,\n                )\n                .into(),\n            );\n        }\n    }\n\n    quote::quote! {\n        #item_mod\n    }\n}\n\nfn process_impl(attributes: &syn::LitStr, mut item_impl: syn::ItemImpl) -> TokenStream {\n    unsupported_if_some!(item_impl.defaultness);\n    unsupported_if_some!(item_impl.unsafety);\n\n    let mut items = Vec::new();\n    for item in item_impl.items.drain(..) {\n        match item {\n            syn::ImplItem::Fn(function) => {\n                unsupported_if_some!(function.defaultness);\n                let function = syn::ItemFn {\n                    attrs: function.attrs,\n                    vis: function.vis,\n                    sig: function.sig,\n                    block: Box::new(function.block),\n                };\n                let output_item = process_function(\n                    attributes,\n                    function,\n                    Some((item_impl.generics.clone(), item_impl.self_ty.clone())),\n                );\n                items.push(syn::ImplItem::Verbatim(output_item.into()));\n            }\n            item => items.push(item),\n        }\n    }\n\n    item_impl.items = items;\n    quote::quote! {\n        #item_impl\n    }\n    .into()\n}\n\nfn is_path_eq(path: &syn::Path, ident: &str) -> bool {\n    let segments: Vec<_> = ident.split(\"::\").collect();\n    path.segments.len() == segments.len()\n        && path\n            .segments\n            .iter()\n            .zip(segments.iter())\n            .all(|(segment, expected)| segment.ident == expected && segment.arguments.is_none())\n}\n\nfn process_function(\n    attributes: &syn::LitStr,\n    function: syn::ItemFn,\n    outer: Option<(syn::Generics, Box<syn::Type>)>,\n) -> TokenStream {\n    if function.sig.unsafety.is_some() {\n        return quote::quote! {\n            #[target_feature(enable = #attributes)]\n            #function\n        }\n        .into();\n    }\n\n    unsupported_if_some!(function.sig.constness);\n    unsupported_if_some!(function.sig.asyncness);\n    unsupported_if_some!(function.sig.abi);\n    unsupported_if_some!(function.sig.variadic);\n\n    let function_visibility = function.vis;\n    let function_name = function.sig.ident;\n    let function_return = function.sig.output;\n    let function_inner_name =\n        syn::Ident::new(&format!(\"_impl_{}\", function_name), function_name.span());\n    let function_args = function.sig.inputs;\n    let function_body = function.block;\n    let mut function_call_args = Vec::new();\n    let mut function_args_outer = Vec::new();\n    let mut function_args_inner = Vec::new();\n    for (index, arg) in function_args.iter().enumerate() {\n        match arg {\n            syn::FnArg::Receiver(receiver) => {\n                unsupported_if_some!(receiver.attrs.first());\n                unsupported_if_some!(receiver.colon_token);\n\n                if outer.is_none() {\n                    return syn::Error::new(receiver.span(), \"unsupported by #[unsafe_target_feature(...)]; put the attribute on the outer `impl`\").into_compile_error().into();\n                }\n\n                function_args_inner.push(syn::FnArg::Receiver(receiver.clone()));\n                function_args_outer.push(syn::FnArg::Receiver(receiver.clone()));\n                function_call_args.push(syn::Ident::new(\"self\", receiver.self_token.span()));\n            }\n            syn::FnArg::Typed(ty) => {\n                unsupported_if_some!(ty.attrs.first());\n\n                match &*ty.pat {\n                    syn::Pat::Ident(pat_ident) => {\n                        unsupported_if_some!(pat_ident.attrs.first());\n\n                        function_args_inner.push(arg.clone());\n                        function_args_outer.push(syn::FnArg::Typed(syn::PatType {\n                            attrs: Vec::new(),\n                            pat: Box::new(syn::Pat::Ident(syn::PatIdent {\n                                attrs: Vec::new(),\n                                by_ref: None,\n                                mutability: None,\n                                ident: pat_ident.ident.clone(),\n                                subpat: None,\n                            })),\n                            colon_token: ty.colon_token,\n                            ty: ty.ty.clone(),\n                        }));\n                        function_call_args.push(pat_ident.ident.clone());\n                    }\n                    syn::Pat::Wild(pat_wild) => {\n                        unsupported_if_some!(pat_wild.attrs.first());\n\n                        let ident = syn::Ident::new(\n                            &format!(\"__arg_{}__\", index),\n                            pat_wild.underscore_token.span(),\n                        );\n                        function_args_inner.push(arg.clone());\n                        function_args_outer.push(syn::FnArg::Typed(syn::PatType {\n                            attrs: Vec::new(),\n                            pat: Box::new(syn::Pat::Ident(syn::PatIdent {\n                                attrs: Vec::new(),\n                                by_ref: None,\n                                mutability: None,\n                                ident: ident.clone(),\n                                subpat: None,\n                            })),\n                            colon_token: ty.colon_token,\n                            ty: ty.ty.clone(),\n                        }));\n                        function_call_args.push(ident);\n                    }\n                    _ => unsupported!(arg),\n                }\n            }\n        }\n    }\n\n    let mut maybe_inline = quote::quote! {};\n    let mut maybe_outer_attributes = Vec::new();\n    let mut maybe_cfg = quote::quote! {};\n    for attribute in function.attrs {\n        match &attribute.meta {\n            syn::Meta::Path(path) if is_path_eq(path, \"inline\") => {\n                maybe_inline = quote::quote! { #[inline] };\n            }\n            syn::Meta::Path(path) if is_path_eq(path, \"test\") => {\n                maybe_outer_attributes.push(attribute);\n                maybe_cfg = quote::quote! { #[cfg(target_feature = #attributes)] };\n            }\n            syn::Meta::List(syn::MetaList { path, tokens, .. })\n                if is_path_eq(path, \"inline\") && tokens.to_string() == \"always\" =>\n            {\n                maybe_inline = quote::quote! { #[inline] };\n            }\n            syn::Meta::NameValue(syn::MetaNameValue { path, .. }) if is_path_eq(path, \"doc\") => {\n                maybe_outer_attributes.push(attribute);\n            }\n            syn::Meta::List(syn::MetaList { path, .. })\n                if is_path_eq(path, \"cfg\")\n                    || is_path_eq(path, \"allow\")\n                    || is_path_eq(path, \"deny\") =>\n            {\n                maybe_outer_attributes.push(attribute);\n            }\n            syn::Meta::Path(path) if is_path_eq(path, \"rustfmt::skip\") => {\n                maybe_outer_attributes.push(attribute);\n            }\n            _ => unsupported!(attribute),\n        }\n    }\n\n    let (fn_impl_generics, fn_ty_generics, fn_where_clause) =\n        function.sig.generics.split_for_impl();\n    let fn_call_generics = fn_ty_generics.as_turbofish();\n\n    if let Some((generics, self_ty)) = outer {\n        let (outer_impl_generics, outer_ty_generics, outer_where_clause) =\n            generics.split_for_impl();\n        let trait_ident =\n            syn::Ident::new(&format!(\"__Impl_{}__\", function_name), function_name.span());\n        let item_trait = quote::quote! {\n            #[allow(non_camel_case_types)]\n            trait #trait_ident #outer_impl_generics #outer_where_clause {\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause;\n            }\n        };\n\n        let item_trait_impl = quote::quote! {\n            impl #outer_impl_generics #trait_ident #outer_ty_generics for #self_ty #outer_where_clause {\n                #[target_feature(enable = #attributes)]\n                #maybe_inline\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_inner),*) #function_return #fn_where_clause #function_body\n            }\n        };\n\n        quote::quote! {\n            #[inline(always)]\n            #(#maybe_outer_attributes)*\n            #function_visibility fn #function_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause {\n                #item_trait\n                #item_trait_impl\n                unsafe {\n                    <Self as #trait_ident #outer_ty_generics> ::#function_inner_name #fn_call_generics (#(#function_call_args),*)\n                }\n            }\n        }.into()\n    } else {\n        quote::quote! {\n            #[inline(always)]\n            #maybe_cfg\n            #(#maybe_outer_attributes)*\n            #function_visibility fn #function_name #fn_impl_generics (#(#function_args_outer),*) #function_return #fn_where_clause {\n                #[target_feature(enable = #attributes)]\n                #maybe_inline\n                unsafe fn #function_inner_name #fn_impl_generics (#(#function_args_inner),*) #function_return #fn_where_clause #function_body\n                unsafe {\n                    #function_inner_name #fn_call_generics (#(#function_call_args),*)\n                }\n            }\n        }.into()\n    }\n}\n",
    "filename": "curve25519-dalek-derive/src/lib.rs",
    "filepath": null,
    "folder_id": 15812,
    "user_id": 460154
  },
  "63576": {
    "text": "use curve25519_dalek::edwards::EdwardsPoint;\n\nuse x25519_dalek::*;\n\n#[test]\nfn byte_basepoint_matches_edwards_scalar_mul() {\n    let mut scalar_bytes = [0x37; 32];\n\n    for i in 0..32 {\n        scalar_bytes[i] += 2;\n\n        let result = x25519(scalar_bytes, X25519_BASEPOINT_BYTES);\n        let expected = EdwardsPoint::mul_base_clamped(scalar_bytes)\n            .to_montgomery()\n            .to_bytes();\n\n        assert_eq!(result, expected);\n    }\n}\n\n#[test]\n#[cfg(feature = \"serde\")]\nfn serde_bincode_public_key_roundtrip() {\n    use bincode;\n\n    let public_key = PublicKey::from(X25519_BASEPOINT_BYTES);\n\n    let encoded = bincode::serialize(&public_key).unwrap();\n    let decoded: PublicKey = bincode::deserialize(&encoded).unwrap();\n\n    assert_eq!(encoded.len(), 32);\n    assert_eq!(decoded.as_bytes(), public_key.as_bytes());\n}\n\n#[test]\n#[cfg(feature = \"serde\")]\nfn serde_bincode_public_key_matches_from_bytes() {\n    use bincode;\n\n    let expected = PublicKey::from(X25519_BASEPOINT_BYTES);\n    let decoded: PublicKey = bincode::deserialize(&X25519_BASEPOINT_BYTES).unwrap();\n\n    assert_eq!(decoded.as_bytes(), expected.as_bytes());\n}\n\n#[test]\n#[cfg(feature = \"serde\")]\nfn serde_bincode_static_secret_roundtrip() {\n    use bincode;\n\n    let static_secret = StaticSecret::from([0x24; 32]);\n    let encoded = bincode::serialize(&static_secret).unwrap();\n    let decoded: StaticSecret = bincode::deserialize(&encoded).unwrap();\n\n    assert_eq!(encoded.len(), 32);\n    assert_eq!(decoded.to_bytes(), static_secret.to_bytes());\n}\n\n#[test]\n#[cfg(feature = \"serde\")]\nfn serde_bincode_static_secret_matches_from_bytes() {\n    use bincode;\n\n    let expected = StaticSecret::from([0x24; 32]);\n    let decoded: StaticSecret = bincode::deserialize(&[0x24; 32]).unwrap();\n\n    assert_eq!(decoded.to_bytes(), expected.to_bytes());\n}\n\nfn do_rfc7748_ladder_test1(input_scalar: [u8; 32], input_point: [u8; 32], expected: [u8; 32]) {\n    let result = x25519(input_scalar, input_point);\n\n    assert_eq!(result, expected);\n}\n\n#[test]\nfn rfc7748_ladder_test1_vectorset1() {\n    let input_scalar: [u8; 32] = [\n        0xa5, 0x46, 0xe3, 0x6b, 0xf0, 0x52, 0x7c, 0x9d, 0x3b, 0x16, 0x15, 0x4b, 0x82, 0x46, 0x5e,\n        0xdd, 0x62, 0x14, 0x4c, 0x0a, 0xc1, 0xfc, 0x5a, 0x18, 0x50, 0x6a, 0x22, 0x44, 0xba, 0x44,\n        0x9a, 0xc4,\n    ];\n    let input_point: [u8; 32] = [\n        0xe6, 0xdb, 0x68, 0x67, 0x58, 0x30, 0x30, 0xdb, 0x35, 0x94, 0xc1, 0xa4, 0x24, 0xb1, 0x5f,\n        0x7c, 0x72, 0x66, 0x24, 0xec, 0x26, 0xb3, 0x35, 0x3b, 0x10, 0xa9, 0x03, 0xa6, 0xd0, 0xab,\n        0x1c, 0x4c,\n    ];\n    let expected: [u8; 32] = [\n        0xc3, 0xda, 0x55, 0x37, 0x9d, 0xe9, 0xc6, 0x90, 0x8e, 0x94, 0xea, 0x4d, 0xf2, 0x8d, 0x08,\n        0x4f, 0x32, 0xec, 0xcf, 0x03, 0x49, 0x1c, 0x71, 0xf7, 0x54, 0xb4, 0x07, 0x55, 0x77, 0xa2,\n        0x85, 0x52,\n    ];\n\n    do_rfc7748_ladder_test1(input_scalar, input_point, expected);\n}\n\n#[test]\nfn rfc7748_ladder_test1_vectorset2() {\n    let input_scalar: [u8; 32] = [\n        0x4b, 0x66, 0xe9, 0xd4, 0xd1, 0xb4, 0x67, 0x3c, 0x5a, 0xd2, 0x26, 0x91, 0x95, 0x7d, 0x6a,\n        0xf5, 0xc1, 0x1b, 0x64, 0x21, 0xe0, 0xea, 0x01, 0xd4, 0x2c, 0xa4, 0x16, 0x9e, 0x79, 0x18,\n        0xba, 0x0d,\n    ];\n    let input_point: [u8; 32] = [\n        0xe5, 0x21, 0x0f, 0x12, 0x78, 0x68, 0x11, 0xd3, 0xf4, 0xb7, 0x95, 0x9d, 0x05, 0x38, 0xae,\n        0x2c, 0x31, 0xdb, 0xe7, 0x10, 0x6f, 0xc0, 0x3c, 0x3e, 0xfc, 0x4c, 0xd5, 0x49, 0xc7, 0x15,\n        0xa4, 0x93,\n    ];\n    let expected: [u8; 32] = [\n        0x95, 0xcb, 0xde, 0x94, 0x76, 0xe8, 0x90, 0x7d, 0x7a, 0xad, 0xe4, 0x5c, 0xb4, 0xb8, 0x73,\n        0xf8, 0x8b, 0x59, 0x5a, 0x68, 0x79, 0x9f, 0xa1, 0x52, 0xe6, 0xf8, 0xf7, 0x64, 0x7a, 0xac,\n        0x79, 0x57,\n    ];\n\n    do_rfc7748_ladder_test1(input_scalar, input_point, expected);\n}\n\n#[test]\n#[ignore] // Run only if you want to burn a lot of CPU doing 1,000,000 DH operations\nfn rfc7748_ladder_test2() {\n    use curve25519_dalek::constants::X25519_BASEPOINT;\n\n    let mut k: [u8; 32] = X25519_BASEPOINT.0;\n    let mut u: [u8; 32] = X25519_BASEPOINT.0;\n    let mut result: [u8; 32];\n\n    macro_rules! do_iterations {\n        ($n:expr) => {\n            for _ in 0..$n {\n                result = x25519(k, u);\n                // OBVIOUS THING THAT I'M GOING TO NOTE ANYWAY BECAUSE I'VE\n                // SEEN PEOPLE DO THIS WITH GOLANG'S STDLIB AND YOU SURE AS\n                // HELL SHOULDN'T DO HORRIBLY STUPID THINGS LIKE THIS WITH\n                // MY LIBRARY:\n                //\n                // NEVER EVER TREAT SCALARS AS POINTS AND/OR VICE VERSA.\n                //\n                //                ↓↓ DON'T DO THIS ↓↓\n                u = k.clone();\n                k = result;\n            }\n        };\n    }\n\n    // After one iteration:\n    //     422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079\n    // After 1,000 iterations:\n    //     684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51\n    // After 1,000,000 iterations:\n    //     7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424\n\n    do_iterations!(1);\n    assert_eq!(\n        k,\n        [\n            0x42, 0x2c, 0x8e, 0x7a, 0x62, 0x27, 0xd7, 0xbc, 0xa1, 0x35, 0x0b, 0x3e, 0x2b, 0xb7,\n            0x27, 0x9f, 0x78, 0x97, 0xb8, 0x7b, 0xb6, 0x85, 0x4b, 0x78, 0x3c, 0x60, 0xe8, 0x03,\n            0x11, 0xae, 0x30, 0x79,\n        ]\n    );\n    do_iterations!(999);\n    assert_eq!(\n        k,\n        [\n            0x68, 0x4c, 0xf5, 0x9b, 0xa8, 0x33, 0x09, 0x55, 0x28, 0x00, 0xef, 0x56, 0x6f, 0x2f,\n            0x4d, 0x3c, 0x1c, 0x38, 0x87, 0xc4, 0x93, 0x60, 0xe3, 0x87, 0x5f, 0x2e, 0xb9, 0x4d,\n            0x99, 0x53, 0x2c, 0x51,\n        ]\n    );\n    do_iterations!(999_000);\n    assert_eq!(\n        k,\n        [\n            0x7c, 0x39, 0x11, 0xe0, 0xab, 0x25, 0x86, 0xfd, 0x86, 0x44, 0x97, 0x29, 0x7e, 0x57,\n            0x5e, 0x6f, 0x3b, 0xc6, 0x01, 0xc0, 0x88, 0x3c, 0x30, 0xdf, 0x5f, 0x4d, 0xd2, 0xd2,\n            0x4f, 0x66, 0x54, 0x24,\n        ]\n    );\n}\n\nmod rand_core {\n\n    use super::*;\n    use ::rand_core::{OsRng, TryRngCore};\n\n    #[test]\n    fn ephemeral_from_rng() {\n        EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err());\n    }\n\n    #[test]\n    #[cfg(feature = \"reusable_secrets\")]\n    fn reusable_from_rng() {\n        ReusableSecret::random_from_rng(&mut OsRng.unwrap_err());\n    }\n\n    #[test]\n    #[cfg(feature = \"static_secrets\")]\n    fn static_from_rng() {\n        StaticSecret::random_from_rng(&mut OsRng.unwrap_err());\n    }\n}\n\n#[cfg(feature = \"os_rng\")]\nmod os_rng {\n\n    use super::*;\n\n    #[test]\n    fn ephemeral_random() {\n        EphemeralSecret::random();\n    }\n\n    #[test]\n    #[cfg(feature = \"reusable_secrets\")]\n    fn reusable_random() {\n        ReusableSecret::random();\n    }\n\n    #[test]\n    #[cfg(feature = \"static_secrets\")]\n    fn static_random() {\n        StaticSecret::random();\n    }\n}\n",
    "filename": "x25519-dalek/tests/x25519_tests.rs",
    "filepath": null,
    "folder_id": 15818,
    "user_id": 460154
  },
  "63577": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of x25519-dalek.\n// Copyright (c) 2017-2019 isis agora lovecruft\n// Copyright (c) 2019 DebugSteven\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - DebugSteven <debugsteven@gmail.com>\n\n//! Benchmark the Diffie-Hellman operation.\n\nuse criterion::{Criterion, criterion_group, criterion_main};\n\nuse rand_core::{OsRng, TryRngCore};\n\nuse x25519_dalek::EphemeralSecret;\nuse x25519_dalek::PublicKey;\n\nfn bench_diffie_hellman(c: &mut Criterion) {\n    let bob_secret = EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err());\n    let bob_public = PublicKey::from(&bob_secret);\n\n    c.bench_function(\"diffie_hellman\", move |b| {\n        b.iter_with_setup(\n            || EphemeralSecret::random_from_rng(&mut OsRng.unwrap_err()),\n            |alice_secret| alice_secret.diffie_hellman(&bob_public),\n        )\n    });\n}\n\ncriterion_group! {\n    name = x25519_benches;\n    config = Criterion::default();\n    targets =\n        bench_diffie_hellman,\n}\ncriterion_main! {\n    x25519_benches,\n}\n",
    "filename": "x25519-dalek/benches/x25519.rs",
    "filepath": null,
    "folder_id": 15819,
    "user_id": 460154
  },
  "63580": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of x25519-dalek.\n// Copyright (c) 2017-2021 isis lovecruft\n// Copyright (c) 2019-2021 DebugSteven\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - DebugSteven <debugsteven@gmail.com>\n\n// Refuse to compile if documentation is missing, but only on nightly.\n//\n// This means that missing docs will still fail CI, but means we can use\n// README.md as the crate documentation.\n\n#![no_std]\n#![cfg_attr(docsrs, feature(doc_auto_cfg, doc_cfg, doc_cfg_hide))]\n#![cfg_attr(docsrs, doc(cfg_hide(docsrs)))]\n#![deny(missing_docs)]\n#![doc(\n    html_logo_url = \"https://cdn.jsdelivr.net/gh/dalek-cryptography/curve25519-dalek/docs/assets/dalek-logo-clear.png\"\n)]\n#![doc = include_str!(\"../README.md\")]\n\n//------------------------------------------------------------------------\n// x25519-dalek public API\n//------------------------------------------------------------------------\n\nmod x25519;\n\npub use crate::x25519::*;\n",
    "filename": "x25519-dalek/src/lib.rs",
    "filepath": null,
    "folder_id": 15821,
    "user_id": 460154
  },
  "63581": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of x25519-dalek.\n// Copyright (c) 2017-2021 isis lovecruft\n// Copyright (c) 2019-2021 DebugSteven\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - DebugSteven <debugsteven@gmail.com>\n\n//! x25519 Diffie-Hellman key exchange\n//!\n//! This implements x25519 key exchange as specified by Mike Hamburg\n//! and Adam Langley in [RFC7748](https://tools.ietf.org/html/rfc7748).\n\nuse curve25519_dalek::{edwards::EdwardsPoint, montgomery::MontgomeryPoint, traits::IsIdentity};\n\nuse rand_core::CryptoRng;\n#[cfg(feature = \"os_rng\")]\nuse rand_core::TryRngCore;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n\n/// A Diffie-Hellman public key\n///\n/// We implement `Zeroize` so that downstream consumers may derive it for `Drop`\n/// should they wish to erase public keys from memory.  Note that this erasure\n/// (in this crate) does *not* automatically happen, but either must be derived\n/// for Drop or explicitly called.\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\npub struct PublicKey(pub(crate) MontgomeryPoint);\n\nimpl From<[u8; 32]> for PublicKey {\n    /// Given a byte array, construct a x25519 `PublicKey`.\n    fn from(bytes: [u8; 32]) -> PublicKey {\n        PublicKey(MontgomeryPoint(bytes))\n    }\n}\n\nimpl PublicKey {\n    /// Convert this public key to a byte array.\n    #[inline]\n    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0.to_bytes()\n    }\n\n    /// View this public key as a byte array.\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8; 32] {\n        self.0.as_bytes()\n    }\n}\n\nimpl AsRef<[u8]> for PublicKey {\n    /// View this public key as a byte array.\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for PublicKey {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}\n\n/// A short-lived Diffie-Hellman secret key that can only be used to compute a single\n/// [`SharedSecret`].\n///\n/// This type is identical to the `StaticSecret` type, except that the\n/// [`EphemeralSecret::diffie_hellman`] method consumes and then wipes the secret key, and there\n/// are no serialization methods defined.  This means that [`EphemeralSecret`]s can only be\n/// generated from fresh randomness where the compiler statically checks that the resulting\n/// secret is used at most once.\npub struct EphemeralSecret(pub(crate) [u8; 32]);\n\nimpl EphemeralSecret {\n    /// Perform a Diffie-Hellman key agreement between `self` and\n    /// `their_public` key to produce a [`SharedSecret`].\n    pub fn diffie_hellman(self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }\n\n    /// Generate a new [`EphemeralSecret`] with the supplied RNG.\n    pub fn random_from_rng<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {\n        // The secret key is random bytes. Clamping is done later.\n        let mut bytes = [0u8; 32];\n        csprng.fill_bytes(&mut bytes);\n        EphemeralSecret(bytes)\n    }\n\n    /// Generate a new [`EphemeralSecret`].\n    #[cfg(feature = \"os_rng\")]\n    pub fn random() -> Self {\n        Self::random_from_rng(&mut rand_core::OsRng.unwrap_err())\n    }\n}\n\nimpl<'a> From<&'a EphemeralSecret> for PublicKey {\n    /// Given an x25519 [`EphemeralSecret`] key, compute its corresponding [`PublicKey`].\n    fn from(secret: &'a EphemeralSecret) -> PublicKey {\n        PublicKey(EdwardsPoint::mul_base_clamped(secret.0).to_montgomery())\n    }\n}\n\nimpl Drop for EphemeralSecret {\n    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl ZeroizeOnDrop for EphemeralSecret {}\n\n/// A Diffie-Hellman secret key which may be used more than once, but is\n/// purposefully not serialiseable in order to discourage key-reuse.  This is\n/// implemented to facilitate protocols such as Noise (e.g. Noise IK key usage,\n/// etc.) and X3DH which require an \"ephemeral\" key to conduct the\n/// Diffie-Hellman operation multiple times throughout the protocol, while the\n/// protocol run at a higher level is only conducted once per key.\n///\n/// Similarly to [`EphemeralSecret`], this type does _not_ have serialisation\n/// methods, in order to discourage long-term usage of secret key material. (For\n/// long-term secret keys, see `StaticSecret`.)\n///\n/// # Warning\n///\n/// If you're uncertain about whether you should use this, then you likely\n/// should not be using this.  Our strongly recommended advice is to use\n/// [`EphemeralSecret`] at all times, as that type enforces at compile-time that\n/// secret keys are never reused, which can have very serious security\n/// implications for many protocols.\n#[cfg(feature = \"reusable_secrets\")]\n#[derive(Clone)]\npub struct ReusableSecret(pub(crate) [u8; 32]);\n\n#[cfg(feature = \"reusable_secrets\")]\nimpl ReusableSecret {\n    /// Perform a Diffie-Hellman key agreement between `self` and\n    /// `their_public` key to produce a [`SharedSecret`].\n    pub fn diffie_hellman(&self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }\n\n    /// Generate a new [`ReusableSecret`] with the supplied RNG.\n    pub fn random_from_rng<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {\n        // The secret key is random bytes. Clamping is done later.\n        let mut bytes = [0u8; 32];\n        csprng.fill_bytes(&mut bytes);\n        ReusableSecret(bytes)\n    }\n\n    /// Generate a new [`ReusableSecret`].\n    #[cfg(feature = \"os_rng\")]\n    pub fn random() -> Self {\n        Self::random_from_rng(&mut rand_core::OsRng.unwrap_mut())\n    }\n}\n\n#[cfg(feature = \"reusable_secrets\")]\nimpl<'a> From<&'a ReusableSecret> for PublicKey {\n    /// Given an x25519 [`ReusableSecret`] key, compute its corresponding [`PublicKey`].\n    fn from(secret: &'a ReusableSecret) -> PublicKey {\n        PublicKey(EdwardsPoint::mul_base_clamped(secret.0).to_montgomery())\n    }\n}\n\n#[cfg(feature = \"reusable_secrets\")]\nimpl Drop for ReusableSecret {\n    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }\n}\n\n#[cfg(all(feature = \"reusable_secrets\", feature = \"zeroize\"))]\nimpl ZeroizeOnDrop for ReusableSecret {}\n\n/// A Diffie-Hellman secret key that can be used to compute multiple [`SharedSecret`]s.\n///\n/// This type is identical to the [`EphemeralSecret`] type, except that the\n/// [`StaticSecret::diffie_hellman`] method does not consume the secret key, and the type provides\n/// serialization methods to save and load key material.  This means that the secret may be used\n/// multiple times (but does not *have to be*).\n///\n/// # Warning\n///\n/// If you're uncertain about whether you should use this, then you likely\n/// should not be using this.  Our strongly recommended advice is to use\n/// [`EphemeralSecret`] at all times, as that type enforces at compile-time that\n/// secret keys are never reused, which can have very serious security\n/// implications for many protocols.\n#[cfg(feature = \"static_secrets\")]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n#[derive(Clone)]\npub struct StaticSecret([u8; 32]);\n\n#[cfg(feature = \"static_secrets\")]\nimpl StaticSecret {\n    /// Perform a Diffie-Hellman key agreement between `self` and\n    /// `their_public` key to produce a `SharedSecret`.\n    pub fn diffie_hellman(&self, their_public: &PublicKey) -> SharedSecret {\n        SharedSecret(their_public.0.mul_clamped(self.0))\n    }\n\n    /// Generate a new [`StaticSecret`] with the supplied RNG.\n    pub fn random_from_rng<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {\n        // The secret key is random bytes. Clamping is done later.\n        let mut bytes = [0u8; 32];\n        csprng.fill_bytes(&mut bytes);\n        StaticSecret(bytes)\n    }\n\n    /// Generate a new [`StaticSecret`].\n    #[cfg(feature = \"os_rng\")]\n    pub fn random() -> Self {\n        Self::random_from_rng(&mut rand_core::OsRng.unwrap_mut())\n    }\n\n    /// Extract this key's bytes for serialization.\n    #[inline]\n    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// View this key as a byte array.\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n}\n\n#[cfg(feature = \"static_secrets\")]\nimpl From<[u8; 32]> for StaticSecret {\n    /// Load a secret key from a byte array.\n    fn from(bytes: [u8; 32]) -> StaticSecret {\n        StaticSecret(bytes)\n    }\n}\n\n#[cfg(feature = \"static_secrets\")]\nimpl<'a> From<&'a StaticSecret> for PublicKey {\n    /// Given an x25519 [`StaticSecret`] key, compute its corresponding [`PublicKey`].\n    fn from(secret: &'a StaticSecret) -> PublicKey {\n        PublicKey(EdwardsPoint::mul_base_clamped(secret.0).to_montgomery())\n    }\n}\n\n#[cfg(feature = \"static_secrets\")]\nimpl AsRef<[u8]> for StaticSecret {\n    /// View this key as a byte array.\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}\n\n#[cfg(feature = \"static_secrets\")]\nimpl Drop for StaticSecret {\n    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }\n}\n\n#[cfg(all(feature = \"static_secrets\", feature = \"zeroize\"))]\nimpl ZeroizeOnDrop for StaticSecret {}\n\n/// The result of a Diffie-Hellman key exchange.\n///\n/// Each party computes this using their [`EphemeralSecret`] or [`StaticSecret`] and their\n/// counterparty's [`PublicKey`].\npub struct SharedSecret(pub(crate) MontgomeryPoint);\n\nimpl SharedSecret {\n    /// Convert this shared secret to a byte array.\n    #[inline]\n    pub fn to_bytes(&self) -> [u8; 32] {\n        self.0.to_bytes()\n    }\n\n    /// View this shared secret key as a byte array.\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8; 32] {\n        self.0.as_bytes()\n    }\n\n    /// Ensure in constant-time that this shared secret did not result from a\n    /// key exchange with non-contributory behaviour.\n    ///\n    /// In some more exotic protocols which need to guarantee \"contributory\"\n    /// behaviour for both parties, that is, that each party contributed a public\n    /// value which increased the security of the resulting shared secret.\n    /// To take an example protocol attack where this could lead to undesirable\n    /// results [from Thái \"thaidn\" Dương](https://vnhacker.blogspot.com/2015/09/why-not-validating-curve25519-public.html):\n    ///\n    /// > If Mallory replaces Alice's and Bob's public keys with zero, which is\n    /// > a valid Curve25519 public key, he would be able to force the ECDH\n    /// > shared value to be zero, which is the encoding of the point at infinity,\n    /// > and thus get to dictate some publicly known values as the shared\n    /// > keys. It still requires an active man-in-the-middle attack to pull the\n    /// > trick, after which, however, not only Mallory can decode Alice's data,\n    /// > but everyone too! It is also impossible for Alice and Bob to detect the\n    /// > intrusion, as they still share the same keys, and can communicate with\n    /// > each other as normal.\n    ///\n    /// The original Curve25519 specification argues that checks for\n    /// non-contributory behaviour are \"unnecessary for Diffie-Hellman\".\n    /// Whether this check is necessary for any particular given protocol is\n    /// often a matter of debate, which we will not re-hash here, but simply\n    /// cite some of the [relevant] [public] [discussions].\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the key exchange was contributory (good), and `false`\n    /// otherwise (can be bad for some protocols).\n    ///\n    /// [relevant]: https://tools.ietf.org/html/rfc7748#page-15\n    /// [public]: https://vnhacker.blogspot.com/2015/09/why-not-validating-curve25519-public.html\n    /// [discussions]: https://vnhacker.blogspot.com/2016/08/the-internet-of-broken-protocols.html\n    #[must_use]\n    pub fn was_contributory(&self) -> bool {\n        !self.0.is_identity()\n    }\n}\n\nimpl AsRef<[u8]> for SharedSecret {\n    /// View this shared secret key as a byte array.\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}\n\nimpl Drop for SharedSecret {\n    fn drop(&mut self) {\n        #[cfg(feature = \"zeroize\")]\n        self.0.zeroize();\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl ZeroizeOnDrop for SharedSecret {}\n\n/// The bare, byte-oriented x25519 function, exactly as specified in RFC7748.\n///\n/// This can be used with [`X25519_BASEPOINT_BYTES`] for people who\n/// cannot use the better, safer, and faster ephemeral DH API.\n///\n/// # Example\n#[cfg_attr(feature = \"static_secrets\", doc = \"```\")]\n#[cfg_attr(not(feature = \"static_secrets\"), doc = \"```ignore\")]\n/// use rand_core::OsRng;\n/// use rand_core::RngCore;\n/// use rand_core::TryRngCore;\n///\n/// use x25519_dalek::x25519;\n/// use x25519_dalek::StaticSecret;\n/// use x25519_dalek::PublicKey;\n///\n/// let mut rng = OsRng.unwrap_err();\n///\n/// // Generate Alice's key pair.\n/// let alice_secret = StaticSecret::random_from_rng(&mut rng);\n/// let alice_public = PublicKey::from(&alice_secret);\n///\n/// // Generate Bob's key pair.\n/// let bob_secret = StaticSecret::random_from_rng(&mut rng);\n/// let bob_public = PublicKey::from(&bob_secret);\n///\n/// // Alice and Bob should now exchange their public keys.\n///\n/// // Once they've done so, they may generate a shared secret.\n/// let alice_shared = x25519(alice_secret.to_bytes(), bob_public.to_bytes());\n/// let bob_shared = x25519(bob_secret.to_bytes(), alice_public.to_bytes());\n///\n/// assert_eq!(alice_shared, bob_shared);\n/// ```\npub fn x25519(k: [u8; 32], u: [u8; 32]) -> [u8; 32] {\n    MontgomeryPoint(u).mul_clamped(k).to_bytes()\n}\n\n/// The X25519 basepoint, for use with the bare, byte-oriented x25519\n/// function.  This is provided for people who cannot use the typed\n/// DH API for some reason.\npub const X25519_BASEPOINT_BYTES: [u8; 32] = [\n    9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n",
    "filename": "x25519-dalek/src/x25519.rs",
    "filepath": null,
    "folder_id": 15821,
    "user_id": 460154
  },
  "63592": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2020 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Group operations for Curve25519, in Edwards form.\n//!\n//! ## Encoding and Decoding\n//!\n//! Encoding is done by converting to and from a `CompressedEdwardsY`\n//! struct, which is a typed wrapper around `[u8; 32]`.\n//!\n//! ## Equality Testing\n//!\n//! The `EdwardsPoint` struct implements the [`subtle::ConstantTimeEq`]\n//! trait for constant-time equality checking, and also uses this to\n//! ensure `Eq` equality checking runs in constant time.\n//!\n//! ## Cofactor-related functions\n//!\n//! The order of the group of points on the curve \\\\(\\mathcal E\\\\)\n//! is \\\\(|\\mathcal E| = 8\\ell \\\\), so its structure is \\\\( \\mathcal\n//! E = \\mathcal E\\[8\\] \\times \\mathcal E[\\ell]\\\\).  The torsion\n//! subgroup \\\\( \\mathcal E\\[8\\] \\\\) consists of eight points of small\n//! order.  Technically, all of \\\\(\\mathcal E\\\\) is torsion, but we\n//! use the word only to refer to the small \\\\(\\mathcal E\\[8\\]\\\\) part, not\n//! the large prime-order \\\\(\\mathcal E[\\ell]\\\\) part.\n//!\n//! To test if a point is in \\\\( \\mathcal E\\[8\\] \\\\), use\n//! [`EdwardsPoint::is_small_order`].\n//!\n//! To test if a point is in \\\\( \\mathcal E[\\ell] \\\\), use\n//! [`EdwardsPoint::is_torsion_free`].\n//!\n//! To multiply by the cofactor, use [`EdwardsPoint::mul_by_cofactor`].\n//!\n//! To avoid dealing with cofactors entirely, consider using Ristretto.\n//!\n//! ## Scalars\n//!\n//! Scalars are represented by the [`Scalar`] struct. To construct a scalar, see\n//! [`Scalar::from_canonical_bytes`] or [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! ## Scalar Multiplication\n//!\n//! Scalar multiplication on Edwards points is provided by:\n//!\n//! * the `*` operator between a `Scalar` and a `EdwardsPoint`, which\n//!   performs constant-time variable-base scalar multiplication;\n//!\n//! * the `*` operator between a `Scalar` and a\n//!   `EdwardsBasepointTable`, which performs constant-time fixed-base\n//!   scalar multiplication;\n//!\n//! * an implementation of the\n//!   [`MultiscalarMul`](../traits/trait.MultiscalarMul.html) trait for\n//!   constant-time variable-base multiscalar multiplication;\n//!\n//! * an implementation of the\n//!   [`VartimeMultiscalarMul`](../traits/trait.VartimeMultiscalarMul.html)\n//!   trait for variable-time variable-base multiscalar multiplication;\n//!\n//! ## Implementation\n//!\n//! The Edwards arithmetic is implemented using the “extended twisted\n//! coordinates” of Hisil, Wong, Carter, and Dawson, and the\n//! corresponding complete formulas.  For more details,\n//! see the [`curve_models` submodule][curve_models]\n//! of the internal documentation.\n//!\n//! ## Validity Checking\n//!\n//! There is no function for checking whether a point is valid.\n//! Instead, the `EdwardsPoint` struct is guaranteed to hold a valid\n//! point on the curve.\n//!\n//! We use the Rust type system to make invalid points\n//! unrepresentable: `EdwardsPoint` objects can only be created via\n//! successful decompression of a compressed point, or else by\n//! operations on other (valid) `EdwardsPoint`s.\n//!\n//! [curve_models]: https://docs.rs/curve25519-dalek/latest/curve25519-dalek/backend/serial/curve_models/index.html\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nmod affine;\n\nuse cfg_if::cfg_if;\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};\nuse core::ops::{Mul, MulAssign};\n\n#[cfg(feature = \"digest\")]\nuse digest::{\n    FixedOutput, HashMarker, array::typenum::U64, consts::True, crypto_common::BlockSizeUser,\n    typenum::IsGreater,\n};\n\n#[cfg(feature = \"group\")]\nuse {\n    group::{GroupEncoding, cofactor::CofactorGroup, prime::PrimeGroup},\n    rand_core::TryRngCore,\n    subtle::CtOption,\n};\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::RngCore;\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse crate::constants;\n\nuse crate::field::FieldElement;\nuse crate::scalar::{Scalar, clamp_integer};\n\nuse crate::montgomery::MontgomeryPoint;\n\nuse crate::backend::serial::curve_models::AffineNielsPoint;\nuse crate::backend::serial::curve_models::CompletedPoint;\nuse crate::backend::serial::curve_models::ProjectiveNielsPoint;\nuse crate::backend::serial::curve_models::ProjectivePoint;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::window::{\n    LookupTableRadix16, LookupTableRadix32, LookupTableRadix64, LookupTableRadix128,\n    LookupTableRadix256,\n};\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::traits::BasepointTable;\n\nuse crate::traits::ValidityCheck;\nuse crate::traits::{Identity, IsIdentity};\n\nuse affine::AffinePoint;\n\n#[cfg(feature = \"alloc\")]\nuse crate::traits::MultiscalarMul;\n#[cfg(feature = \"alloc\")]\nuse crate::traits::{VartimeMultiscalarMul, VartimePrecomputedMultiscalarMul};\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\nuse vstd::prelude::*;\n\nverus! {\n// ------------------------------------------------------------------------\n// Compressed points\n// ------------------------------------------------------------------------\n\n/// In \"Edwards y\" / \"Ed25519\" format, the curve point \\\\((x,y)\\\\) is\n/// determined by the \\\\(y\\\\)-coordinate and the sign of \\\\(x\\\\).\n///\n/// The first 255 bits of a `CompressedEdwardsY` represent the\n/// \\\\(y\\\\)-coordinate.  The high bit of the 32nd byte gives the sign of \\\\(x\\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct CompressedEdwardsY(pub [u8; 32]);\n\nimpl ConstantTimeEq for CompressedEdwardsY {\n    //#[verifier::external_body]\n    fn ct_eq(&self, other: &CompressedEdwardsY) -> (result:Choice) \n    //ensures\n    //    true,\n    {\n        assume(false); // This is a placeholder for the external body, which is not implemented in this example.\n        self.as_bytes().ct_eq(other.as_bytes())\n    }\n}\n\n}\n\nimpl Eq for CompressedEdwardsY {}\nimpl PartialEq for CompressedEdwardsY {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Debug for CompressedEdwardsY {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }\n}\n\nimpl CompressedEdwardsY {\n    /// View this `CompressedEdwardsY` as an array of bytes.\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n\n    /// Copy this `CompressedEdwardsY` to an array of bytes.\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// Attempt to decompress to an `EdwardsPoint`.\n    ///\n    /// Returns `None` if the input is not the \\\\(y\\\\)-coordinate of a\n    /// curve point.\n    pub fn decompress(&self) -> Option<EdwardsPoint> {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        if is_valid_y_coord.into() {\n            Some(decompress::step_2(self, X, Y, Z))\n        } else {\n            None\n        }\n    }\n}\n\nmod decompress {\n    use super::*;\n\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y²-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy²+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }\n\n    #[rustfmt::skip]\n    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> EdwardsPoint {\n         // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n         // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n        X.conditional_negate(compressed_sign_bit);\n\n        EdwardsPoint {\n            X,\n            Y,\n            Z,\n            T: &X * &Y,\n        }\n    }\n}\n\nimpl TryFrom<&[u8]> for CompressedEdwardsY {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Serde support\n// ------------------------------------------------------------------------\n// Serializes to and from `EdwardsPoint` directly, doing compression\n// and decompression internally.  This means that users can create\n// structs containing `EdwardsPoint`s and use Serde's derived\n// serializers to serialize those structures.\n\n#[cfg(feature = \"digest\")]\nuse constants::ED25519_SQRTAM2;\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for EdwardsPoint {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.compress().as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for CompressedEdwardsY {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for EdwardsPoint {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct EdwardsPointVisitor;\n\n        impl<'de> Visitor<'de> for EdwardsPointVisitor {\n            type Value = EdwardsPoint;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"a valid point in Edwards y + sign format\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<EdwardsPoint, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                CompressedEdwardsY(bytes)\n                    .decompress()\n                    .ok_or_else(|| serde::de::Error::custom(\"decompression failed\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, EdwardsPointVisitor)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for CompressedEdwardsY {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct CompressedEdwardsYVisitor;\n\n        impl<'de> Visitor<'de> for CompressedEdwardsYVisitor {\n            type Value = CompressedEdwardsY;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"32 bytes of data\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<CompressedEdwardsY, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Ok(CompressedEdwardsY(bytes))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, CompressedEdwardsYVisitor)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Internal point representations\n// ------------------------------------------------------------------------\n\n/// An `EdwardsPoint` represents a point on the Edwards form of Curve25519.\n#[derive(Copy, Clone)]\n#[allow(missing_docs)]\npub struct EdwardsPoint {\n    pub(crate) X: FieldElement,\n    pub(crate) Y: FieldElement,\n    pub(crate) Z: FieldElement,\n    pub(crate) T: FieldElement,\n}\n\n// ------------------------------------------------------------------------\n// Constructors\n// ------------------------------------------------------------------------\n\nimpl Identity for CompressedEdwardsY {\n    fn identity() -> CompressedEdwardsY {\n        CompressedEdwardsY([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ])\n    }\n}\n\nimpl Default for CompressedEdwardsY {\n    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }\n}\n\nimpl CompressedEdwardsY {\n    /// Construct a `CompressedEdwardsY` from a slice of bytes.\n    ///\n    /// # Errors\n    ///\n    /// Returns [`TryFromSliceError`] if the input `bytes` slice does not have\n    /// a length of 32.\n    pub fn from_slice(bytes: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        bytes.try_into().map(CompressedEdwardsY)\n    }\n}\n\nimpl Identity for EdwardsPoint {\n    fn identity() -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for EdwardsPoint {\n    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Zeroize implementations for wiping points from memory\n// ------------------------------------------------------------------------\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for CompressedEdwardsY {\n    /// Reset this `CompressedEdwardsY` to the compressed form of the identity element.\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n        self.0[0] = 1;\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for EdwardsPoint {\n    /// Reset this `EdwardsPoint` to the identity element.\n    fn zeroize(&mut self) {\n        self.X.zeroize();\n        self.Y = FieldElement::ONE;\n        self.Z = FieldElement::ONE;\n        self.T.zeroize();\n    }\n}\n\n// ------------------------------------------------------------------------\n// Validity checks (for debugging, not CT)\n// ------------------------------------------------------------------------\n\nimpl ValidityCheck for EdwardsPoint {\n    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }\n}\n\n// ------------------------------------------------------------------------\n// Constant-time assignment\n// ------------------------------------------------------------------------\n\nimpl ConditionallySelectable for EdwardsPoint {\n    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Equality\n// ------------------------------------------------------------------------\n\nimpl ConstantTimeEq for EdwardsPoint {\n    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }\n}\n\nimpl PartialEq for EdwardsPoint {\n    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for EdwardsPoint {}\n\n// ------------------------------------------------------------------------\n// Point conversions\n// ------------------------------------------------------------------------\n\nimpl EdwardsPoint {\n    /// Convert to a ProjectiveNielsPoint\n    pub(crate) fn as_projective_niels(&self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: &self.Y + &self.X,\n            Y_minus_X: &self.Y - &self.X,\n            Z: self.Z,\n            T2d: &self.T * &constants::EDWARDS_D2,\n        }\n    }\n\n    /// Convert the representation of this point from extended\n    /// coordinates to projective coordinates.\n    ///\n    /// Free.\n    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n        }\n    }\n\n    /// Dehomogenize to a `AffineNielsPoint`.\n    /// Mainly for testing.\n    pub(crate) fn as_affine_niels(&self) -> AffineNielsPoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let xy2d = &(&x * &y) * &constants::EDWARDS_D2;\n        AffineNielsPoint {\n            y_plus_x: &y + &x,\n            y_minus_x: &y - &x,\n            xy2d,\n        }\n    }\n\n    /// Dehomogenize to `AffinePoint`.\n    pub(crate) fn to_affine(self) -> AffinePoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        AffinePoint { x, y }\n    }\n\n    /// Convert this `EdwardsPoint` on the Edwards model to the\n    /// corresponding `MontgomeryPoint` on the Montgomery model.\n    ///\n    /// This function has one exceptional case; the identity point of\n    /// the Edwards curve is sent to the 2-torsion point \\\\((0,0)\\\\)\n    /// on the Montgomery curve.\n    ///\n    /// Note that this is a one-way conversion, since the Montgomery\n    /// model does not retain sign information.\n    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        let u = &U * &W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }\n\n    /// Converts a large batch of points to Edwards at once. This has the same\n    /// behavior on identity elements as [`Self::to_montgomery`].\n    #[cfg(feature = \"alloc\")]\n    pub fn to_montgomery_batch(eds: &[Self]) -> Vec<MontgomeryPoint> {\n        // Do the same thing as the above function. u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        // We will do this in a batch, ie compute (Z-Y) for all the input\n        // points, then invert them all at once\n\n        // Compute the denominators in a batch\n        let mut denominators = eds.iter().map(|p| &p.Z - &p.Y).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut denominators);\n\n        // Now compute the Montgomery u coordinate for every point\n        let mut ret = Vec::with_capacity(eds.len());\n        for (ed, d) in eds.iter().zip(denominators.iter()) {\n            let u = &(&ed.Z + &ed.Y) * d;\n            ret.push(MontgomeryPoint(u.to_bytes()));\n        }\n\n        ret\n    }\n\n    /// Compress this point to `CompressedEdwardsY` format.\n    pub fn compress(&self) -> CompressedEdwardsY {\n        self.to_affine().compress()\n    }\n\n    /// Compress several `EdwardsPoint`s into `CompressedEdwardsY` format, using a batch inversion\n    /// for a significant speedup.\n    #[cfg(feature = \"alloc\")]\n    pub fn compress_batch(inputs: &[EdwardsPoint]) -> Vec<CompressedEdwardsY> {\n        let mut zs = inputs.iter().map(|input| input.Z).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut zs);\n\n        inputs\n            .iter()\n            .zip(&zs)\n            .map(|(input, recip)| {\n                let x = &input.X * recip;\n                let y = &input.Y * recip;\n                AffinePoint { x, y }.compress()\n            })\n            .collect()\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Perform hashing to curve, with explicit hash function and domain separator, `domain_sep`,\n    /// using the suite `edwards25519_XMD:SHA-512_ELL2_NU_`. The input is the concatenation of the\n    /// elements of `bytes`. Likewise for the domain separator with `domain_sep`. At least one\n    /// element of `domain_sep`, MUST be nonempty, and the concatenation MUST NOT exceed\n    /// 255 bytes.\n    ///\n    /// # Panics\n    /// Panics if `domain_sep.collect().len() == 0` or `> 255`\n    pub fn hash_to_curve<D>(bytes: &[&[u8]], domain_sep: &[&[u8]]) -> EdwardsPoint\n    where\n        D: BlockSizeUser + Default + FixedOutput<OutputSize = U64> + HashMarker,\n        D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    {\n        // For reference see\n        // https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method-2\n\n        let fe = FieldElement::hash_to_field::<D>(bytes, domain_sep);\n        let (M1, is_sq) = crate::montgomery::elligator_encode(&fe);\n\n        // The `to_edwards` conversion we're performing takes as input the sign of the Edwards\n        // `y` coordinate. However, the specification uses `is_sq` to determine the sign of the\n        // Montgomery `v` coordinate. Our approach reconciles this mismatch as follows:\n        //\n        // * We arbitrarily fix the sign of the Edwards `y` coordinate (we choose 0).\n        // * Using the Montgomery `u` coordinate and the Edwards `X` coordinate, we recover `v`.\n        // * We verify that the sign of `v` matches the expected one, i.e., `is_sq == mont_v.is_negative()`.\n        // * If it does not match, we conditionally negate to correct the sign.\n        //\n        // Note: This logic aligns with the RFC draft specification:\n        //     https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method-2\n        // followed by the mapping\n        //     https://www.rfc-editor.org/rfc/rfc9380.html#name-mappings-for-twisted-edward\n        // The only difference is that our `elligator_encode` returns only the Montgomery `u` coordinate,\n        // so we apply this workaround to reconstruct and validate the sign.\n\n        let mut E1_opt = M1\n            .to_edwards(0)\n            .expect(\"Montgomery conversion to Edwards point in Elligator failed\");\n\n        // Now we recover v, to ensure that we got the sign right.\n        let mont_v =\n            &(&ED25519_SQRTAM2 * &FieldElement::from_bytes(&M1.to_bytes())) * &E1_opt.X.invert();\n        E1_opt.X.conditional_negate(is_sq ^ mont_v.is_negative());\n        E1_opt.mul_by_cofactor()\n    }\n\n    /// Return an `EdwardsPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `RngCore`\n    ///\n    /// # Returns\n    ///\n    /// A random `EdwardsPoint`.\n    ///\n    /// # Implementation\n    ///\n    /// Uses rejection sampling, generating a random `CompressedEdwardsY` and then attempting point\n    /// decompression, rejecting invalid points.\n    #[cfg(any(test, feature = \"rand_core\"))]\n    pub fn random<R: RngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.fill_bytes(&mut repr.0);\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break p;\n                }\n            }\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Doubling\n// ------------------------------------------------------------------------\n\nimpl EdwardsPoint {\n    /// Add this point to itself.\n    pub(crate) fn double(&self) -> EdwardsPoint {\n        self.as_projective().double().as_extended()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Addition and Subtraction\n// ------------------------------------------------------------------------\n\nimpl<'a> Add<&'a EdwardsPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }\n}\n\ndefine_add_variants!(\n    LHS = EdwardsPoint,\n    RHS = EdwardsPoint,\n    Output = EdwardsPoint\n);\n\nimpl<'a> AddAssign<&'a EdwardsPoint> for EdwardsPoint {\n    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = EdwardsPoint, RHS = EdwardsPoint);\n\nimpl<'a> Sub<&'a EdwardsPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }\n}\n\ndefine_sub_variants!(\n    LHS = EdwardsPoint,\n    RHS = EdwardsPoint,\n    Output = EdwardsPoint\n);\n\nimpl<'a> SubAssign<&'a EdwardsPoint> for EdwardsPoint {\n    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = EdwardsPoint, RHS = EdwardsPoint);\n\nimpl<T> Sum<T> for EdwardsPoint\nwhere\n    T: Borrow<EdwardsPoint>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }\n}\n\n// ------------------------------------------------------------------------\n// Negation\n// ------------------------------------------------------------------------\n\nimpl Neg for &EdwardsPoint {\n    type Output = EdwardsPoint;\n\n    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }\n}\n\nimpl Neg for EdwardsPoint {\n    type Output = EdwardsPoint;\n\n    fn neg(self) -> EdwardsPoint {\n        -&self\n    }\n}\n\n// ------------------------------------------------------------------------\n// Scalar multiplication\n// ------------------------------------------------------------------------\n\nimpl<'a> MulAssign<&'a Scalar> for EdwardsPoint {\n    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }\n}\n\ndefine_mul_assign_variants!(LHS = EdwardsPoint, RHS = Scalar);\n\ndefine_mul_variants!(LHS = EdwardsPoint, RHS = Scalar, Output = EdwardsPoint);\ndefine_mul_variants!(LHS = Scalar, RHS = EdwardsPoint, Output = EdwardsPoint);\n\nimpl<'a> Mul<&'a Scalar> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, scalar: &'a Scalar) -> EdwardsPoint {\n        crate::backend::variable_base_mul(self, scalar)\n    }\n}\n\nimpl<'a> Mul<&'a EdwardsPoint> for &Scalar {\n    type Output = EdwardsPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, point: &'a EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }\n}\n\nimpl EdwardsPoint {\n    /// Fixed-base scalar multiplication by the Ed25519 base point.\n    ///\n    /// Uses precomputed basepoint tables when the `precomputed-tables` feature\n    /// is enabled, trading off increased code size for ~4x better performance.\n    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::ED25519_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::ED25519_BASEPOINT_TABLE\n        }\n    }\n\n    /// Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }\n\n    /// Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Multiscalar Multiplication impls\n// ------------------------------------------------------------------------\n\n// These use the iterator's size hint and the target settings to\n// forward to a specific backend implementation.\n\n#[cfg(feature = \"alloc\")]\nimpl MultiscalarMul for EdwardsPoint {\n    type Point = EdwardsPoint;\n\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.  When we do\n        // size-dependent algorithm dispatch, use this as the hint.\n        let _size = s_lo;\n\n        crate::backend::straus_multiscalar_mul(scalars, points)\n    }\n}\n\n#[cfg(feature = \"alloc\")]\nimpl VartimeMultiscalarMul for EdwardsPoint {\n    type Point = EdwardsPoint;\n\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.\n        // Use this as the hint to decide which algorithm to use.\n        let size = s_lo;\n\n        if size < 190 {\n            crate::backend::straus_optional_multiscalar_mul(scalars, points)\n        } else {\n            crate::backend::pippenger_optional_multiscalar_mul(scalars, points)\n        }\n    }\n}\n\n/// Precomputation for variable-time multiscalar multiplication with `EdwardsPoint`s.\n// This wraps the inner implementation in a facade type so that we can\n// decouple stability of the inner type from the stability of the\n// outer type.\n#[cfg(feature = \"alloc\")]\npub struct VartimeEdwardsPrecomputation(crate::backend::VartimePrecomputedStraus);\n\n#[cfg(feature = \"alloc\")]\nimpl VartimePrecomputedMultiscalarMul for VartimeEdwardsPrecomputation {\n    type Point = EdwardsPoint;\n\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(static_points))\n    }\n\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }\n\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }\n}\n\nimpl EdwardsPoint {\n    /// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.\n    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &EdwardsPoint,\n        b: &Scalar,\n    ) -> EdwardsPoint {\n        crate::backend::vartime_double_base_mul(a, A, b)\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nmacro_rules! impl_basepoint_table {\n    (Name = $name:ident, LookupTable = $table:ident, Point = $point:ty, Radix = $radix:expr, Additions = $adds:expr) => {\n        /// A precomputed table of multiples of a basepoint, for accelerating\n        /// fixed-base scalar multiplication.  One table, for the Ed25519\n        /// basepoint, is provided in the [`constants`] module.\n        ///\n        /// The basepoint tables are reasonably large, so they should probably be boxed.\n        ///\n        /// The sizes for the tables and the number of additions required for one scalar\n        /// multiplication are as follows:\n        ///\n        /// * [`EdwardsBasepointTableRadix16`]: 30KB, 64A\n        ///   (this is the default size, and is used for\n        ///   [`constants::ED25519_BASEPOINT_TABLE`])\n        /// * [`EdwardsBasepointTableRadix64`]: 120KB, 43A\n        /// * [`EdwardsBasepointTableRadix128`]: 240KB, 37A\n        /// * [`EdwardsBasepointTableRadix256`]: 480KB, 33A\n        ///\n        /// # Why 33 additions for radix-256?\n        ///\n        /// Normally, the radix-256 tables would allow for only 32 additions per scalar\n        /// multiplication.  However, due to the fact that standardised definitions of\n        /// legacy protocols—such as x25519—require allowing unreduced 255-bit scalars\n        /// invariants, when converting such an unreduced scalar's representation to\n        /// radix-\\\\(2^{8}\\\\), we cannot guarantee the carry bit will fit in the last\n        /// coefficient (the coefficients are `i8`s).  When, \\\\(w\\\\), the power-of-2 of\n        /// the radix, is \\\\(w < 8\\\\), we can fold the final carry onto the last\n        /// coefficient, \\\\(d\\\\), because \\\\(d < 2^{w/2}\\\\), so\n        /// $$\n        ///     d + carry \\cdot 2^{w} = d + 1 \\cdot 2^{w} < 2^{w+1} < 2^{8}\n        /// $$\n        /// When \\\\(w = 8\\\\), we can't fit \\\\(carry \\cdot 2^{w}\\\\) into an `i8`, so we\n        /// add the carry bit onto an additional coefficient.\n        #[derive(Clone)]\n        #[repr(transparent)]\n        pub struct $name(pub(crate) [$table<AffineNielsPoint>; 32]);\n\n        impl BasepointTable for $name {\n            type Point = $point;\n\n            /// Create a table of precomputed multiples of `basepoint`.\n            fn create(basepoint: &$point) -> $name {\n                // XXX use init_with\n                let mut table = $name([$table::default(); 32]);\n                let mut P = *basepoint;\n                for i in 0..32 {\n                    // P = (2w)^i * B\n                    table.0[i] = $table::from(&P);\n                    P = P.mul_by_pow_2($radix + $radix);\n                }\n                table\n            }\n\n            /// Get the basepoint for this table as an `EdwardsPoint`.\n            fn basepoint(&self) -> $point {\n                // self.0[0].select(1) = 1*(16^2)^0*B\n                // but as an `AffineNielsPoint`, so add identity to convert to extended.\n                (&<$point>::identity() + &self.0[0].select(1)).as_extended()\n            }\n\n            /// The computation uses Pippeneger's algorithm, as described for the\n            /// specific case of radix-16 on page 13 of the Ed25519 paper.\n            ///\n            /// # Piggenger's Algorithm Generalised\n            ///\n            /// Write the scalar \\\\(a\\\\) in radix-\\\\(w\\\\), where \\\\(w\\\\) is a power of\n            /// 2, with coefficients in \\\\([\\frac{-w}{2},\\frac{w}{2})\\\\), i.e.,\n            /// $$\n            ///     a = a\\_0 + a\\_1 w\\^1 + \\cdots + a\\_{x} w\\^{x},\n            /// $$\n            /// with\n            /// $$\n            /// \\begin{aligned}\n            ///     \\frac{-w}{2} \\leq a_i < \\frac{w}{2}\n            ///     &&\\cdots&&\n            ///     \\frac{-w}{2} \\leq a\\_{x} \\leq \\frac{w}{2}\n            /// \\end{aligned}\n            /// $$\n            /// and the number of additions, \\\\(x\\\\), is given by\n            /// \\\\(x = \\lceil \\frac{256}{w} \\rceil\\\\). Then\n            /// $$\n            ///     a B = a\\_0 B + a\\_1 w\\^1 B + \\cdots + a\\_{x-1} w\\^{x-1} B.\n            /// $$\n            /// Grouping even and odd coefficients gives\n            /// $$\n            /// \\begin{aligned}\n            ///     a B = \\quad a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B    \\\\\\\\\n            ///               + a\\_1 w\\^1 B +& a\\_3 w\\^3 B + \\cdots + a\\_{x-1} w\\^{x-1} B    \\\\\\\\\n            ///         = \\quad(a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B)   \\\\\\\\\n            ///             + w(a\\_1 w\\^0 B +& a\\_3 w\\^2 B + \\cdots + a\\_{x-1} w\\^{x-2} B).  \\\\\\\\\n            /// \\end{aligned}\n            /// $$\n            /// For each \\\\(i = 0 \\ldots 31\\\\), we create a lookup table of\n            /// $$\n            /// [w\\^{2i} B, \\ldots, \\frac{w}{2}\\cdot w\\^{2i} B],\n            /// $$\n            /// and use it to select \\\\( y \\cdot w\\^{2i} \\cdot B \\\\) in constant time.\n            ///\n            /// The radix-\\\\(w\\\\) representation requires that the scalar is bounded\n            /// by \\\\(2\\^{255}\\\\), which is always the case.\n            ///\n            /// The above algorithm is trivially generalised to other powers-of-2 radices.\n            fn mul_base(&self, scalar: &Scalar) -> $point {\n                let a = scalar.as_radix_2w($radix);\n\n                let tables = &self.0;\n                let mut P = <$point>::identity();\n\n                for i in (0..$adds).filter(|x| x % 2 == 1) {\n                    P = (&P + &tables[i / 2].select(a[i])).as_extended();\n                }\n\n                P = P.mul_by_pow_2($radix);\n\n                for i in (0..$adds).filter(|x| x % 2 == 0) {\n                    P = (&P + &tables[i / 2].select(a[i])).as_extended();\n                }\n\n                P\n            }\n        }\n\n        impl<'a, 'b> Mul<&'b Scalar> for &'a $name {\n            type Output = $point;\n\n            /// Construct an `EdwardsPoint` from a `Scalar` \\\\(a\\\\) by\n            /// computing the multiple \\\\(aB\\\\) of this basepoint \\\\(B\\\\).\n            fn mul(self, scalar: &'b Scalar) -> $point {\n                // delegate to a private function so that its documentation appears in internal docs\n                self.mul_base(scalar)\n            }\n        }\n\n        impl<'a, 'b> Mul<&'a $name> for &'b Scalar {\n            type Output = $point;\n\n            /// Construct an `EdwardsPoint` from a `Scalar` \\\\(a\\\\) by\n            /// computing the multiple \\\\(aB\\\\) of this basepoint \\\\(B\\\\).\n            fn mul(self, basepoint_table: &'a $name) -> $point {\n                basepoint_table * self\n            }\n        }\n\n        impl Debug for $name {\n            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(f, \"{:?}([\\n\", stringify!($name))?;\n                for i in 0..32 {\n                    write!(f, \"\\t{:?},\\n\", &self.0[i])?;\n                }\n                write!(f, \"])\")\n            }\n        }\n    };\n} // End macro_rules! impl_basepoint_table\n\n// The number of additions required is ceil(256/w) where w is the radix representation.\ncfg_if! {\n    if #[cfg(feature = \"precomputed-tables\")] {\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTable,\n            LookupTable = LookupTableRadix16,\n            Point = EdwardsPoint,\n            Radix = 4,\n            Additions = 64\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix32,\n            LookupTable = LookupTableRadix32,\n            Point = EdwardsPoint,\n            Radix = 5,\n            Additions = 52\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix64,\n            LookupTable = LookupTableRadix64,\n            Point = EdwardsPoint,\n            Radix = 6,\n            Additions = 43\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix128,\n            LookupTable = LookupTableRadix128,\n            Point = EdwardsPoint,\n            Radix = 7,\n            Additions = 37\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix256,\n            LookupTable = LookupTableRadix256,\n            Point = EdwardsPoint,\n            Radix = 8,\n            Additions = 33\n        }\n\n        /// A type-alias for [`EdwardsBasepointTable`] because the latter is\n        /// used as a constructor in the [`constants`] module.\n        //\n        // Same as for `LookupTableRadix16`, we have to define `EdwardsBasepointTable`\n        // first, because it's used as a constructor, and then provide a type alias for\n        // it.\n        pub type EdwardsBasepointTableRadix16 = EdwardsBasepointTable;\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nmacro_rules! impl_basepoint_table_conversions {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl<'a> From<&'a $lhs> for $rhs {\n            fn from(table: &'a $lhs) -> $rhs {\n                <$rhs>::create(&table.basepoint())\n            }\n        }\n\n        impl<'a> From<&'a $rhs> for $lhs {\n            fn from(table: &'a $rhs) -> $lhs {\n                <$lhs>::create(&table.basepoint())\n            }\n        }\n    };\n}\n\ncfg_if! {\n    if #[cfg(feature = \"precomputed-tables\")] {\n        // Conversions from radix 16\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix32\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix64\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 32\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix64\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 64\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix64,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix64,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 128\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix128,\n            RHS = EdwardsBasepointTableRadix256\n        }\n    }\n}\n\nimpl EdwardsPoint {\n    /// Multiply by the cofactor: return \\\\(\\[8\\]P\\\\).\n    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }\n\n    /// Compute \\\\([2\\^k] P \\\\) by successive doublings. Requires \\\\( k > 0 \\\\).\n    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        for _ in 0..(k - 1) {\n            r = s.double();\n            s = r.as_projective();\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        s.double().as_extended()\n    }\n\n    /// Determine if this point is of small order.\n    ///\n    /// # Return\n    ///\n    /// * `true` if `self` is in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\);\n    /// * `false` if `self` is not in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::constants;\n    ///\n    /// // Generator of the prime-order subgroup\n    /// let P = constants::ED25519_BASEPOINT_POINT;\n    /// // Generator of the torsion subgroup\n    /// let Q = constants::EIGHT_TORSION[1];\n    ///\n    /// // P has large order\n    /// assert_eq!(P.is_small_order(), false);\n    ///\n    /// // Q has small order\n    /// assert_eq!(Q.is_small_order(), true);\n    /// ```\n    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }\n\n    /// Determine if this point is “torsion-free”, i.e., is contained in\n    /// the prime-order subgroup.\n    ///\n    /// # Return\n    ///\n    /// * `true` if `self` has zero torsion component and is in the\n    ///   prime-order subgroup;\n    /// * `false` if `self` has a nonzero torsion component and is not\n    ///   in the prime-order subgroup.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::constants;\n    ///\n    /// // Generator of the prime-order subgroup\n    /// let P = constants::ED25519_BASEPOINT_POINT;\n    /// // Generator of the torsion subgroup\n    /// let Q = constants::EIGHT_TORSION[1];\n    ///\n    /// // P is torsion-free\n    /// assert_eq!(P.is_torsion_free(), true);\n    ///\n    /// // P + Q is not torsion-free\n    /// assert_eq!((P+Q).is_torsion_free(), false);\n    /// ```\n    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER).is_identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Debug traits\n// ------------------------------------------------------------------------\n\nimpl Debug for EdwardsPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }\n}\n\n// ------------------------------------------------------------------------\n// group traits\n// ------------------------------------------------------------------------\n\n// Use the full trait path to avoid Group::identity overlapping Identity::identity in the\n// rest of the module (e.g. tests).\n#[cfg(feature = \"group\")]\nimpl group::Group for EdwardsPoint {\n    type Scalar = Scalar;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.try_fill_bytes(&mut repr.0)?;\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break Ok(p);\n                }\n            }\n        }\n    }\n\n    fn identity() -> Self {\n        Identity::identity()\n    }\n\n    fn generator() -> Self {\n        constants::ED25519_BASEPOINT_POINT\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        self.double()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl GroupEncoding for EdwardsPoint {\n    type Repr = [u8; 32];\n\n    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        let repr = CompressedEdwardsY(*bytes);\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(&repr);\n        CtOption::new(decompress::step_2(&repr, X, Y, Z), is_valid_y_coord)\n    }\n\n    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // Just use the checked API; there are no checks we can skip.\n        Self::from_bytes(bytes)\n    }\n\n    fn to_bytes(&self) -> Self::Repr {\n        self.compress().to_bytes()\n    }\n}\n\n/// A `SubgroupPoint` represents a point on the Edwards form of Curve25519, that is\n/// guaranteed to be in the prime-order subgroup.\n#[cfg(feature = \"group\")]\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct SubgroupPoint(EdwardsPoint);\n\n#[cfg(feature = \"group\")]\nimpl From<SubgroupPoint> for EdwardsPoint {\n    fn from(p: SubgroupPoint) -> Self {\n        p.0\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Neg for SubgroupPoint {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        SubgroupPoint(-self.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Add<&SubgroupPoint> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n    fn add(self, other: &SubgroupPoint) -> SubgroupPoint {\n        SubgroupPoint(self.0 + other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_variants!(\n    LHS = SubgroupPoint,\n    RHS = SubgroupPoint,\n    Output = SubgroupPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl Add<&SubgroupPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn add(self, other: &SubgroupPoint) -> EdwardsPoint {\n        self + other.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_variants!(\n    LHS = EdwardsPoint,\n    RHS = SubgroupPoint,\n    Output = EdwardsPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl AddAssign<&SubgroupPoint> for SubgroupPoint {\n    fn add_assign(&mut self, rhs: &SubgroupPoint) {\n        self.0 += rhs.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_assign_variants!(LHS = SubgroupPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl AddAssign<&SubgroupPoint> for EdwardsPoint {\n    fn add_assign(&mut self, rhs: &SubgroupPoint) {\n        *self += rhs.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_assign_variants!(LHS = EdwardsPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl Sub<&SubgroupPoint> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n    fn sub(self, other: &SubgroupPoint) -> SubgroupPoint {\n        SubgroupPoint(self.0 - other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_variants!(\n    LHS = SubgroupPoint,\n    RHS = SubgroupPoint,\n    Output = SubgroupPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl Sub<&SubgroupPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn sub(self, other: &SubgroupPoint) -> EdwardsPoint {\n        self - other.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_variants!(\n    LHS = EdwardsPoint,\n    RHS = SubgroupPoint,\n    Output = EdwardsPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl SubAssign<&SubgroupPoint> for SubgroupPoint {\n    fn sub_assign(&mut self, rhs: &SubgroupPoint) {\n        self.0 -= rhs.0;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_assign_variants!(LHS = SubgroupPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl SubAssign<&SubgroupPoint> for EdwardsPoint {\n    fn sub_assign(&mut self, rhs: &SubgroupPoint) {\n        *self -= rhs.0;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_assign_variants!(LHS = EdwardsPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl<T> Sum<T> for SubgroupPoint\nwhere\n    T: Borrow<SubgroupPoint>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        use group::Group;\n        iter.fold(SubgroupPoint::identity(), |acc, item| acc + item.borrow())\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Mul<&Scalar> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, scalar: &Scalar) -> SubgroupPoint {\n        SubgroupPoint(self.0 * scalar)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_variants!(LHS = Scalar, RHS = SubgroupPoint, Output = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl Mul<&SubgroupPoint> for &Scalar {\n    type Output = SubgroupPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, point: &SubgroupPoint) -> SubgroupPoint {\n        point * self\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_variants!(LHS = SubgroupPoint, RHS = Scalar, Output = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl MulAssign<&Scalar> for SubgroupPoint {\n    fn mul_assign(&mut self, scalar: &Scalar) {\n        self.0 *= scalar;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_assign_variants!(LHS = SubgroupPoint, RHS = Scalar);\n\n#[cfg(feature = \"group\")]\nimpl ConstantTimeEq for SubgroupPoint {\n    fn ct_eq(&self, other: &SubgroupPoint) -> Choice {\n        self.0.ct_eq(&other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl ConditionallySelectable for SubgroupPoint {\n    fn conditional_select(a: &SubgroupPoint, b: &SubgroupPoint, choice: Choice) -> SubgroupPoint {\n        SubgroupPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }\n}\n\n#[cfg(all(feature = \"group\", feature = \"zeroize\"))]\nimpl Zeroize for SubgroupPoint {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl group::Group for SubgroupPoint {\n    type Scalar = Scalar;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        use group::ff::Field;\n\n        // This will almost never loop, but `Group::random` is documented as returning a\n        // non-identity element.\n        let s = loop {\n            let s: Scalar = Field::try_from_rng(rng)?;\n            if !s.is_zero_vartime() {\n                break s;\n            }\n        };\n\n        // This gives an element of the prime-order subgroup.\n        Ok(Self::generator() * s)\n    }\n\n    fn identity() -> Self {\n        SubgroupPoint(Identity::identity())\n    }\n\n    fn generator() -> Self {\n        SubgroupPoint(EdwardsPoint::generator())\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.0.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        SubgroupPoint(self.0.double())\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl GroupEncoding for SubgroupPoint {\n    type Repr = <EdwardsPoint as GroupEncoding>::Repr;\n\n    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        EdwardsPoint::from_bytes(bytes).and_then(|p| p.into_subgroup())\n    }\n\n    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        EdwardsPoint::from_bytes_unchecked(bytes).and_then(|p| p.into_subgroup())\n    }\n\n    fn to_bytes(&self) -> Self::Repr {\n        self.0.compress().to_bytes()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl PrimeGroup for SubgroupPoint {}\n\n#[cfg(feature = \"group\")]\nimpl CofactorGroup for EdwardsPoint {\n    type Subgroup = SubgroupPoint;\n\n    fn clear_cofactor(&self) -> Self::Subgroup {\n        SubgroupPoint(self.mul_by_cofactor())\n    }\n\n    fn into_subgroup(self) -> CtOption<Self::Subgroup> {\n        CtOption::new(SubgroupPoint(self), CofactorGroup::is_torsion_free(&self))\n    }\n\n    fn is_torsion_free(&self) -> Choice {\n        (self * constants::BASEPOINT_ORDER).ct_eq(&Self::identity())\n    }\n}\n\n// ------------------------------------------------------------------------\n// Tests\n// ------------------------------------------------------------------------\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    use rand_core::TryRngCore;\n\n    #[cfg(feature = \"alloc\")]\n    use alloc::vec::Vec;\n\n    #[cfg(feature = \"precomputed-tables\")]\n    use crate::constants::ED25519_BASEPOINT_TABLE;\n\n    /// X coordinate of the basepoint.\n    /// = 15112221349535400772501151409588531511454012693041857206046113283949847762202\n    static BASE_X_COORD_BYTES: [u8; 32] = [\n        0x1a, 0xd5, 0x25, 0x8f, 0x60, 0x2d, 0x56, 0xc9, 0xb2, 0xa7, 0x25, 0x95, 0x60, 0xc7, 0x2c,\n        0x69, 0x5c, 0xdc, 0xd6, 0xfd, 0x31, 0xe2, 0xa4, 0xc0, 0xfe, 0x53, 0x6e, 0xcd, 0xd3, 0x36,\n        0x69, 0x21,\n    ];\n\n    /// Compressed Edwards Y form of 2*basepoint.\n    static BASE2_CMPRSSD: CompressedEdwardsY = CompressedEdwardsY([\n        0xc9, 0xa3, 0xf8, 0x6a, 0xae, 0x46, 0x5f, 0xe, 0x56, 0x51, 0x38, 0x64, 0x51, 0x0f, 0x39,\n        0x97, 0x56, 0x1f, 0xa2, 0xc9, 0xe8, 0x5e, 0xa2, 0x1d, 0xc2, 0x29, 0x23, 0x09, 0xf3, 0xcd,\n        0x60, 0x22,\n    ]);\n\n    /// Compressed Edwards Y form of 16*basepoint.\n    static BASE16_CMPRSSD: CompressedEdwardsY = CompressedEdwardsY([\n        0xeb, 0x27, 0x67, 0xc1, 0x37, 0xab, 0x7a, 0xd8, 0x27, 0x9c, 0x07, 0x8e, 0xff, 0x11, 0x6a,\n        0xb0, 0x78, 0x6e, 0xad, 0x3a, 0x2e, 0x0f, 0x98, 0x9f, 0x72, 0xc3, 0x7f, 0x82, 0xf2, 0x96,\n        0x96, 0x70,\n    ]);\n\n    /// 4493907448824000747700850167940867464579944529806937181821189941592931634714\n    pub static A_SCALAR: Scalar = Scalar {\n        bytes: [\n            0x1a, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n            0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n            0x23, 0x76, 0xef, 0x09,\n        ],\n    };\n\n    /// 2506056684125797857694181776241676200180934651973138769173342316833279714961\n    pub static B_SCALAR: Scalar = Scalar {\n        bytes: [\n            0x91, 0x26, 0x7a, 0xcf, 0x25, 0xc2, 0x09, 0x1b, 0xa2, 0x17, 0x74, 0x7b, 0x66, 0xf0,\n            0xb3, 0x2e, 0x9d, 0xf2, 0xa5, 0x67, 0x41, 0xcf, 0xda, 0xc4, 0x56, 0xa7, 0xd4, 0xaa,\n            0xb8, 0x60, 0x8a, 0x05,\n        ],\n    };\n\n    /// A_SCALAR * basepoint, computed with ed25519.py\n    pub static A_TIMES_BASEPOINT: CompressedEdwardsY = CompressedEdwardsY([\n        0xea, 0x27, 0xe2, 0x60, 0x53, 0xdf, 0x1b, 0x59, 0x56, 0xf1, 0x4d, 0x5d, 0xec, 0x3c, 0x34,\n        0xc3, 0x84, 0xa2, 0x69, 0xb7, 0x4c, 0xc3, 0x80, 0x3e, 0xa8, 0xe2, 0xe7, 0xc9, 0x42, 0x5e,\n        0x40, 0xa5,\n    ]);\n\n    /// A_SCALAR * (A_TIMES_BASEPOINT) + B_SCALAR * BASEPOINT\n    /// computed with ed25519.py\n    static DOUBLE_SCALAR_MULT_RESULT: CompressedEdwardsY = CompressedEdwardsY([\n        0x7d, 0xfd, 0x6c, 0x45, 0xaf, 0x6d, 0x6e, 0x0e, 0xba, 0x20, 0x37, 0x1a, 0x23, 0x64, 0x59,\n        0xc4, 0xc0, 0x46, 0x83, 0x43, 0xde, 0x70, 0x4b, 0x85, 0x09, 0x6f, 0xfe, 0x35, 0x4f, 0x13,\n        0x2b, 0x42,\n    ]);\n\n    /// Test round-trip decompression for the basepoint.\n    #[test]\n    fn basepoint_decompression_compression() {\n        let base_X = FieldElement::from_bytes(&BASE_X_COORD_BYTES);\n        let bp = constants::ED25519_BASEPOINT_COMPRESSED\n            .decompress()\n            .unwrap();\n        assert!(bp.is_valid());\n        // Check that decompression actually gives the correct X coordinate\n        assert_eq!(base_X, bp.X);\n        assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n    }\n\n    /// Test sign handling in decompression\n    #[test]\n    fn decompression_sign_handling() {\n        // Manually set the high bit of the last byte to flip the sign\n        let mut minus_basepoint_bytes = *constants::ED25519_BASEPOINT_COMPRESSED.as_bytes();\n        minus_basepoint_bytes[31] |= 1 << 7;\n        let minus_basepoint = CompressedEdwardsY(minus_basepoint_bytes)\n            .decompress()\n            .unwrap();\n        // Test projective coordinates exactly since we know they should\n        // only differ by a flipped sign.\n        assert_eq!(minus_basepoint.X, -(&constants::ED25519_BASEPOINT_POINT.X));\n        assert_eq!(minus_basepoint.Y, constants::ED25519_BASEPOINT_POINT.Y);\n        assert_eq!(minus_basepoint.Z, constants::ED25519_BASEPOINT_POINT.Z);\n        assert_eq!(minus_basepoint.T, -(&constants::ED25519_BASEPOINT_POINT.T));\n    }\n\n    /// Test that computing 1*basepoint gives the correct basepoint.\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn basepoint_mult_one_vs_basepoint() {\n        let bp = ED25519_BASEPOINT_TABLE * &Scalar::ONE;\n        let compressed = bp.compress();\n        assert_eq!(compressed, constants::ED25519_BASEPOINT_COMPRESSED);\n    }\n\n    /// Test that `EdwardsBasepointTable::basepoint()` gives the correct basepoint.\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn basepoint_table_basepoint_function_correct() {\n        let bp = ED25519_BASEPOINT_TABLE.basepoint();\n        assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n    }\n\n    /// Test `impl Add<EdwardsPoint> for EdwardsPoint`\n    /// using basepoint + basepoint versus the 2*basepoint constant.\n    #[test]\n    fn basepoint_plus_basepoint_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_added = bp + bp;\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }\n\n    /// Test `impl Add<ProjectiveNielsPoint> for EdwardsPoint`\n    /// using the basepoint, basepoint2 constants\n    #[test]\n    fn basepoint_plus_basepoint_projective_niels_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_added = (&bp + &bp.as_projective_niels()).as_extended();\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }\n\n    /// Test `impl Add<AffineNielsPoint> for EdwardsPoint`\n    /// using the basepoint, basepoint2 constants\n    #[test]\n    fn basepoint_plus_basepoint_affine_niels_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_affine_niels = bp.as_affine_niels();\n        let bp_added = (&bp + &bp_affine_niels).as_extended();\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }\n\n    /// Check that equality of `EdwardsPoints` handles projective\n    /// coordinates correctly.\n    #[test]\n    fn extended_point_equality_handles_scaling() {\n        let mut two_bytes = [0u8; 32];\n        two_bytes[0] = 2;\n        let id1 = EdwardsPoint::identity();\n        let id2 = EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::from_bytes(&two_bytes),\n            Z: FieldElement::from_bytes(&two_bytes),\n            T: FieldElement::ZERO,\n        };\n        assert!(bool::from(id1.ct_eq(&id2)));\n    }\n\n    /// Sanity check for conversion to precomputed points\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn to_affine_niels_clears_denominators() {\n        // construct a point as aB so it has denominators (ie. Z != 1)\n        let aB = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n        let aB_affine_niels = aB.as_affine_niels();\n        let also_aB = (&EdwardsPoint::identity() + &aB_affine_niels).as_extended();\n        assert_eq!(aB.compress(), also_aB.compress());\n    }\n\n    /// Test mul_base versus a known scalar multiple from ed25519.py\n    #[test]\n    fn basepoint_mult_vs_ed25519py() {\n        let aB = EdwardsPoint::mul_base(&A_SCALAR);\n        assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n    }\n\n    /// Test that multiplication by the basepoint order kills the basepoint\n    #[test]\n    fn basepoint_mult_by_basepoint_order() {\n        let should_be_id = EdwardsPoint::mul_base(&constants::BASEPOINT_ORDER);\n        assert!(should_be_id.is_identity());\n    }\n\n    /// Test precomputed basepoint mult\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn test_precomputed_basepoint_mult() {\n        let aB_1 = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n        let aB_2 = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n        assert_eq!(aB_1.compress(), aB_2.compress());\n    }\n\n    /// Test scalar_mul versus a known scalar multiple from ed25519.py\n    #[test]\n    fn scalar_mul_vs_ed25519py() {\n        let aB = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n        assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n    }\n\n    /// Test basepoint.double() versus the 2*basepoint constant.\n    #[test]\n    fn basepoint_double_vs_basepoint2() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT.double().compress(),\n            BASE2_CMPRSSD\n        );\n    }\n\n    /// Test that computing 2*basepoint is the same as basepoint.double()\n    #[test]\n    fn basepoint_mult_two_vs_basepoint2() {\n        let two = Scalar::from(2u64);\n        let bp2 = EdwardsPoint::mul_base(&two);\n        assert_eq!(bp2.compress(), BASE2_CMPRSSD);\n    }\n\n    /// Test that all the basepoint table types compute the same results.\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn basepoint_tables() {\n        let P = &constants::ED25519_BASEPOINT_POINT;\n        let a = A_SCALAR;\n\n        let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n        let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n        let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n        let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n        let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n        let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n        let aP16 = (&table_radix16 * &a).compress();\n        let aP32 = (&table_radix32 * &a).compress();\n        let aP64 = (&table_radix64 * &a).compress();\n        let aP128 = (&table_radix128 * &a).compress();\n        let aP256 = (&table_radix256 * &a).compress();\n\n        assert_eq!(aP, aP16);\n        assert_eq!(aP16, aP32);\n        assert_eq!(aP32, aP64);\n        assert_eq!(aP64, aP128);\n        assert_eq!(aP128, aP256);\n    }\n\n    /// Check unreduced scalar multiplication by the basepoint tables is the same no matter what\n    /// radix the table is.\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn basepoint_tables_unreduced_scalar() {\n        let P = &constants::ED25519_BASEPOINT_POINT;\n        let a = crate::scalar::test::LARGEST_UNREDUCED_SCALAR;\n\n        let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n        let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n        let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n        let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n        let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n        let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n        let aP16 = (&table_radix16 * &a).compress();\n        let aP32 = (&table_radix32 * &a).compress();\n        let aP64 = (&table_radix64 * &a).compress();\n        let aP128 = (&table_radix128 * &a).compress();\n        let aP256 = (&table_radix256 * &a).compress();\n\n        assert_eq!(aP, aP16);\n        assert_eq!(aP16, aP32);\n        assert_eq!(aP32, aP64);\n        assert_eq!(aP64, aP128);\n        assert_eq!(aP128, aP256);\n    }\n\n    /// Check that converting to projective and then back to extended round-trips.\n    #[test]\n    fn basepoint_projective_extended_round_trip() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT\n                .as_projective()\n                .as_extended()\n                .compress(),\n            constants::ED25519_BASEPOINT_COMPRESSED\n        );\n    }\n\n    /// Test computing 16*basepoint vs mul_by_pow_2(4)\n    #[test]\n    fn basepoint16_vs_mul_by_pow_2_4() {\n        let bp16 = constants::ED25519_BASEPOINT_POINT.mul_by_pow_2(4);\n        assert_eq!(bp16.compress(), BASE16_CMPRSSD);\n    }\n\n    /// Check that mul_base_clamped and mul_clamped agree\n    #[test]\n    fn mul_base_clamped() {\n        let mut csprng = rand_core::OsRng;\n\n        // Make a random curve point in the curve. Give it torsion to make things interesting.\n        #[cfg(feature = \"precomputed-tables\")]\n        let random_point = {\n            let mut b = [0u8; 32];\n            csprng.try_fill_bytes(&mut b).unwrap();\n            EdwardsPoint::mul_base_clamped(b) + constants::EIGHT_TORSION[1]\n        };\n        // Make a basepoint table from the random point. We'll use this with mul_base_clamped\n        #[cfg(feature = \"precomputed-tables\")]\n        let random_table = EdwardsBasepointTableRadix256::create(&random_point);\n\n        // Now test scalar mult. agreement on the default basepoint as well as random_point\n\n        // Test that mul_base_clamped and mul_clamped agree on a large integer. Even after\n        // clamping, this integer is not reduced mod l.\n        let a_bytes = [0xff; 32];\n        assert_eq!(\n            EdwardsPoint::mul_base_clamped(a_bytes),\n            constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n        );\n        #[cfg(feature = \"precomputed-tables\")]\n        assert_eq!(\n            random_table.mul_base_clamped(a_bytes),\n            random_point.mul_clamped(a_bytes)\n        );\n\n        // Test agreement on random integers\n        for _ in 0..100 {\n            // This will be reduced mod l with probability l / 2^256 ≈ 6.25%\n            let mut a_bytes = [0u8; 32];\n            csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n            assert_eq!(\n                EdwardsPoint::mul_base_clamped(a_bytes),\n                constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n            );\n            #[cfg(feature = \"precomputed-tables\")]\n            assert_eq!(\n                random_table.mul_base_clamped(a_bytes),\n                random_point.mul_clamped(a_bytes)\n            );\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let BASE = constants::ED25519_BASEPOINT_POINT;\n\n        let s1 = Scalar::from(999u64);\n        let P1 = BASE * s1;\n\n        let s2 = Scalar::from(333u64);\n        let P2 = BASE * s2;\n\n        let vec = vec![P1, P2];\n        let sum: EdwardsPoint = vec.iter().sum();\n\n        assert_eq!(sum, P1 + P2);\n\n        // Test that sum works for the empty iterator\n        let empty_vector: Vec<EdwardsPoint> = vec![];\n        let sum: EdwardsPoint = empty_vector.iter().sum();\n\n        assert_eq!(sum, EdwardsPoint::identity());\n\n        // Test that sum works on owning iterators\n        let s = Scalar::from(2u64);\n        let mapped = vec.iter().map(|x| x * s);\n        let sum: EdwardsPoint = mapped.sum();\n\n        assert_eq!(sum, P1 * s + P2 * s);\n    }\n\n    /// Test that the conditional assignment trait works for AffineNielsPoints.\n    #[test]\n    fn conditional_assign_for_affine_niels_point() {\n        let id = AffineNielsPoint::identity();\n        let mut p1 = AffineNielsPoint::identity();\n        let bp = constants::ED25519_BASEPOINT_POINT.as_affine_niels();\n\n        p1.conditional_assign(&bp, Choice::from(0));\n        assert_eq!(p1, id);\n        p1.conditional_assign(&bp, Choice::from(1));\n        assert_eq!(p1, bp);\n    }\n\n    #[test]\n    fn is_small_order() {\n        // The basepoint has large prime order\n        assert!(!constants::ED25519_BASEPOINT_POINT.is_small_order());\n        // constants::EIGHT_TORSION has all points of small order.\n        for torsion_point in &constants::EIGHT_TORSION {\n            assert!(torsion_point.is_small_order());\n        }\n    }\n\n    #[test]\n    fn compressed_identity() {\n        assert_eq!(\n            EdwardsPoint::identity().compress(),\n            CompressedEdwardsY::identity()\n        );\n\n        #[cfg(feature = \"alloc\")]\n        {\n            let compressed = EdwardsPoint::compress_batch(&[EdwardsPoint::identity()]);\n            assert_eq!(&compressed, &[CompressedEdwardsY::identity()]);\n        }\n    }\n\n    #[cfg(feature = \"alloc\")]\n    #[test]\n    fn compress_batch() {\n        let mut rng = rand::rng();\n\n        // TODO(tarcieri): proptests?\n        // Make some points deterministically then randomly\n        let mut points = (1u64..16)\n            .map(|n| constants::ED25519_BASEPOINT_POINT * Scalar::from(n))\n            .collect::<Vec<_>>();\n        points.extend(core::iter::repeat_with(|| EdwardsPoint::random(&mut rng)).take(100));\n        let compressed = EdwardsPoint::compress_batch(&points);\n\n        // Check that the batch-compressed points match the individually compressed ones\n        for (point, compressed) in points.iter().zip(&compressed) {\n            assert_eq!(&point.compress(), compressed);\n        }\n    }\n\n    #[test]\n    fn is_identity() {\n        assert!(EdwardsPoint::identity().is_identity());\n        assert!(!constants::ED25519_BASEPOINT_POINT.is_identity());\n    }\n\n    /// Rust's debug builds have overflow and underflow trapping,\n    /// and enable `debug_assert!()`.  This performs many scalar\n    /// multiplications to attempt to trigger possible overflows etc.\n    ///\n    /// For instance, the `u64` `Mul` implementation for\n    /// `FieldElements` requires the input `Limb`s to be bounded by\n    /// 2^54, but we cannot enforce this dynamically at runtime, or\n    /// statically at compile time (until Rust gets type-level\n    /// integers, at which point we can encode \"bits of headroom\" into\n    /// the type system and prove correctness).\n    #[test]\n    fn monte_carlo_overflow_underflow_debug_assert_test() {\n        let mut P = constants::ED25519_BASEPOINT_POINT;\n        // N.B. each scalar_mul does 1407 field mults, 1024 field squarings,\n        // so this does ~ 1M of each operation.\n        for _ in 0..1_000 {\n            P *= &A_SCALAR;\n        }\n    }\n\n    #[test]\n    fn scalarmult_extended_point_works_both_ways() {\n        let G: EdwardsPoint = constants::ED25519_BASEPOINT_POINT;\n        let s: Scalar = A_SCALAR;\n\n        let P1 = G * s;\n        let P2 = s * G;\n\n        assert!(P1.compress().to_bytes() == P2.compress().to_bytes());\n    }\n\n    // A single iteration of a consistency check for MSM.\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_iter(n: usize) {\n        let mut rng = rand::rng();\n\n        // Construct random coefficients x0, ..., x_{n-1},\n        // followed by some extra hardcoded ones.\n        let xs = (0..n).map(|_| Scalar::random(&mut rng)).collect::<Vec<_>>();\n        let check = xs.iter().map(|xi| xi * xi).sum::<Scalar>();\n\n        // Construct points G_i = x_i * B\n        let Gs = xs.iter().map(EdwardsPoint::mul_base).collect::<Vec<_>>();\n\n        // Compute H1 = <xs, Gs> (consttime)\n        let H1 = EdwardsPoint::multiscalar_mul(&xs, &Gs);\n        // Compute H2 = <xs, Gs> (vartime)\n        let H2 = EdwardsPoint::vartime_multiscalar_mul(&xs, &Gs);\n        // Compute H3 = <xs, Gs> = sum(xi^2) * B\n        let H3 = EdwardsPoint::mul_base(&check);\n\n        assert_eq!(H1, H3);\n        assert_eq!(H2, H3);\n    }\n\n    // Use different multiscalar sizes to hit different internal\n    // parameters.\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_n_100() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(100);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_n_250() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(250);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_n_500() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(500);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_n_1000() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(1000);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn batch_to_montgomery() {\n        let mut rng = rand::rng();\n\n        let scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let points = scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let single_monts = points\n            .iter()\n            .map(EdwardsPoint::to_montgomery)\n            .collect::<Vec<_>>();\n\n        for i in [0, 1, 2, 3, 10, 50, 128] {\n            let invs = EdwardsPoint::to_montgomery_batch(&points[..i]);\n            assert_eq!(&invs, &single_monts[..i]);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let static_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let check_scalar: Scalar = static_scalars\n            .iter()\n            .chain(dynamic_scalars.iter())\n            .map(|s| s * s)\n            .sum();\n\n        let static_points = static_scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n        let dynamic_points = dynamic_scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let precomputation = VartimeEdwardsPrecomputation::new(static_points.iter());\n\n        assert_eq!(precomputation.len(), 128);\n        assert!(!precomputation.is_empty());\n\n        let P = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        use crate::traits::VartimeMultiscalarMul;\n        let Q = EdwardsPoint::vartime_multiscalar_mul(\n            static_scalars.iter().chain(dynamic_scalars.iter()),\n            static_points.iter().chain(dynamic_points.iter()),\n        );\n\n        let R = EdwardsPoint::mul_base(&check_scalar);\n\n        assert_eq!(P.compress(), R.compress());\n        assert_eq!(Q.compress(), R.compress());\n    }\n\n    mod vartime {\n        use super::super::*;\n        use super::{A_SCALAR, A_TIMES_BASEPOINT, B_SCALAR, DOUBLE_SCALAR_MULT_RESULT};\n\n        /// Test double_scalar_mul_vartime vs ed25519.py\n        #[test]\n        fn double_scalar_mul_basepoint_vs_ed25519py() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result =\n                EdwardsPoint::vartime_double_scalar_mul_basepoint(&A_SCALAR, &A, &B_SCALAR);\n            assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n        }\n\n        #[test]\n        #[cfg(feature = \"alloc\")]\n        fn multiscalar_mul_vs_ed25519py() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result = EdwardsPoint::vartime_multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n            assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n        }\n\n        #[test]\n        #[cfg(feature = \"alloc\")]\n        fn multiscalar_mul_vartime_vs_consttime() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result_vartime = EdwardsPoint::vartime_multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n            let result_consttime = EdwardsPoint::multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n\n            assert_eq!(result_vartime.compress(), result_consttime.compress());\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"serde\")]\n    fn serde_bincode_basepoint_roundtrip() {\n        use bincode;\n\n        let encoded = bincode::serialize(&constants::ED25519_BASEPOINT_POINT).unwrap();\n        let enc_compressed = bincode::serialize(&constants::ED25519_BASEPOINT_COMPRESSED).unwrap();\n        assert_eq!(encoded, enc_compressed);\n\n        // Check that the encoding is 32 bytes exactly\n        assert_eq!(encoded.len(), 32);\n\n        let dec_uncompressed: EdwardsPoint = bincode::deserialize(&encoded).unwrap();\n        let dec_compressed: CompressedEdwardsY = bincode::deserialize(&encoded).unwrap();\n\n        assert_eq!(dec_uncompressed, constants::ED25519_BASEPOINT_POINT);\n        assert_eq!(dec_compressed, constants::ED25519_BASEPOINT_COMPRESSED);\n\n        // Check that the encoding itself matches the usual one\n        let raw_bytes = constants::ED25519_BASEPOINT_COMPRESSED.as_bytes();\n        let bp: EdwardsPoint = bincode::deserialize(raw_bytes).unwrap();\n        assert_eq!(bp, constants::ED25519_BASEPOINT_POINT);\n    }\n\n    // Hash-to-curve test vectors from\n    // https://www.rfc-editor.org/rfc/rfc9380.html#name-edwards25519_xmdsha-512_ell2\n    // These are of the form (input_msg, output_x, output_y)\n    #[cfg(all(feature = \"alloc\", feature = \"digest\"))]\n    const RFC_HASH_TO_CURVE_KAT: &[(&[u8], &str, &str)] = &[\n        (\n            b\"\",\n            \"1ff2b70ecf862799e11b7ae744e3489aa058ce805dd323a936375a84695e76da\",\n            \"222e314d04a4d5725e9f2aff9fb2a6b69ef375a1214eb19021ceab2d687f0f9b\",\n        ),\n        (\n            b\"abc\",\n            \"5f13cc69c891d86927eb37bd4afc6672360007c63f68a33ab423a3aa040fd2a8\",\n            \"67732d50f9a26f73111dd1ed5dba225614e538599db58ba30aaea1f5c827fa42\",\n        ),\n        (\n            b\"abcdef0123456789\",\n            \"1dd2fefce934ecfd7aae6ec998de088d7dd03316aa1847198aecf699ba6613f1\",\n            \"2f8a6c24dd1adde73909cada6a4a137577b0f179d336685c4a955a0a8e1a86fb\",\n        ),\n        (\n            b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\\\n            qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\",\n            \"35fbdc5143e8a97afd3096f2b843e07df72e15bfca2eaf6879bf97c5d3362f73\",\n            \"2af6ff6ef5ebba128b0774f4296cb4c2279a074658b083b8dcca91f57a603450\",\n        ),\n        (\n            b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"6e5e1f37e99345887fc12111575fc1c3e36df4b289b8759d23af14d774b66bff\",\n            \"2c90c3d39eb18ff291d33441b35f3262cdd307162cc97c31bfcc7a4245891a37\"\n        )\n    ];\n\n    #[test]\n    #[cfg(all(feature = \"alloc\", feature = \"digest\"))]\n    fn elligator_hash_to_curve_test_vectors() {\n        let dst = b\"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n        for (index, vector) in RFC_HASH_TO_CURVE_KAT.iter().enumerate() {\n            let input = vector.0;\n\n            let expected_output = {\n                let mut x_bytes = hex::decode(vector.1).unwrap();\n                x_bytes.reverse();\n                let x = FieldElement::from_bytes(&x_bytes.try_into().unwrap());\n\n                let mut y_bytes = hex::decode(vector.2).unwrap();\n                y_bytes.reverse();\n                let y = FieldElement::from_bytes(&y_bytes.try_into().unwrap());\n\n                EdwardsPoint {\n                    X: x,\n                    Y: y,\n                    Z: FieldElement::ONE,\n                    T: &x * &y,\n                }\n            };\n\n            let computed = EdwardsPoint::hash_to_curve::<sha2::Sha512>(&[&input], &[dst]);\n            assert_eq!(computed, expected_output, \"Failed in test {}\", index);\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/edwards.rs",
    "filepath": null,
    "folder_id": 15822,
    "user_id": 460154
  },
  "63593": {
    "text": "#![allow(non_snake_case)]\n\nuse rand::{RngCore, TryRngCore, rng, rngs::OsRng};\n\nuse criterion::{\n    BatchSize, BenchmarkGroup, BenchmarkId, Criterion, criterion_main, measurement::Measurement,\n};\n#[cfg(feature = \"digest\")]\nuse sha2::Sha512;\n\nuse curve25519_dalek::constants;\nuse curve25519_dalek::scalar::Scalar;\n\nstatic BATCH_SIZES: [usize; 5] = [1, 2, 4, 8, 16];\nstatic MULTISCALAR_SIZES: [usize; 13] = [1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 512, 768, 1024];\n\nmod edwards_benches {\n    use super::*;\n\n    use curve25519_dalek::edwards::EdwardsPoint;\n\n    fn compress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B = &constants::ED25519_BASEPOINT_POINT;\n        c.bench_function(\"EdwardsPoint compression\", move |b| b.iter(|| B.compress()));\n    }\n\n    #[cfg(feature = \"alloc\")]\n    fn compress_batch<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch EdwardsPoint compression\", batch_size),\n                &batch_size,\n                |b, &size| {\n                    let mut rng = OsRng.unwrap_err();\n                    let points: Vec<EdwardsPoint> =\n                        (0..size).map(|_| EdwardsPoint::random(&mut rng)).collect();\n                    b.iter(|| EdwardsPoint::compress_batch(&points));\n                },\n            );\n        }\n    }\n\n    fn decompress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B_comp = &constants::ED25519_BASEPOINT_COMPRESSED;\n        c.bench_function(\"EdwardsPoint decompression\", move |b| {\n            b.iter(|| B_comp.decompress().unwrap())\n        });\n    }\n\n    fn consttime_fixed_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time fixed-base scalar mul\", move |b| {\n            b.iter(|| EdwardsPoint::mul_base(&s))\n        });\n    }\n\n    fn consttime_variable_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let B = &constants::ED25519_BASEPOINT_POINT;\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time variable-base scalar mul\", move |b| {\n            b.iter(|| B * s)\n        });\n    }\n\n    fn vartime_double_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"Variable-time aA+bB, A variable, B fixed\", |bench| {\n            let mut rng = rng();\n            let A = EdwardsPoint::mul_base(&Scalar::random(&mut rng));\n            bench.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| EdwardsPoint::vartime_double_scalar_mul_basepoint(&a, &A, &b),\n                BatchSize::SmallInput,\n            );\n        });\n    }\n\n    #[cfg(feature = \"digest\")]\n    fn hash_to_curve<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let mut rng = rng();\n\n        let mut msg = [0u8; 32];\n        let mut domain_sep = [0u8; 32];\n        rng.fill_bytes(&mut msg);\n        rng.fill_bytes(&mut domain_sep);\n\n        c.bench_function(\n            \"Elligator2 hash to curve (SHA-512, input size 32 bytes)\",\n            |b| b.iter(|| EdwardsPoint::hash_to_curve::<Sha512>(&[&msg], &[&domain_sep])),\n        );\n    }\n\n    pub(crate) fn edwards_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"edwards benches\");\n\n        compress(&mut g);\n        decompress(&mut g);\n        #[cfg(feature = \"alloc\")]\n        compress_batch(&mut g);\n        consttime_fixed_base_scalar_mul(&mut g);\n        consttime_variable_base_scalar_mul(&mut g);\n        vartime_double_base_scalar_mul(&mut g);\n        hash_to_curve(&mut g);\n    }\n}\n\nmod multiscalar_benches {\n    use super::*;\n\n    use curve25519_dalek::edwards::EdwardsPoint;\n    use curve25519_dalek::edwards::VartimeEdwardsPrecomputation;\n    use curve25519_dalek::traits::MultiscalarMul;\n    use curve25519_dalek::traits::VartimeMultiscalarMul;\n    use curve25519_dalek::traits::VartimePrecomputedMultiscalarMul;\n\n    fn construct_scalars(n: usize) -> Vec<Scalar> {\n        let mut rng = rng();\n        (0..n).map(|_| Scalar::random(&mut rng)).collect()\n    }\n\n    fn construct_points(n: usize) -> Vec<EdwardsPoint> {\n        let mut rng = rng();\n        (0..n)\n            .map(|_| EdwardsPoint::mul_base(&Scalar::random(&mut rng)))\n            .collect()\n    }\n\n    fn consttime_multiscalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Constant-time variable-base multiscalar multiplication\",\n                    *multiscalar_size,\n                ),\n                &multiscalar_size,\n                |b, &&size| {\n                    let points = construct_points(size);\n                    // This is supposed to be constant-time, but we might as well\n                    // rerandomize the scalars for every call just in case.\n                    b.iter_batched(\n                        || construct_scalars(size),\n                        |scalars| EdwardsPoint::multiscalar_mul(&scalars, &points),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }\n\n    fn vartime_multiscalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Variable-time variable-base multiscalar multiplication\",\n                    *multiscalar_size,\n                ),\n                &multiscalar_size,\n                |b, &&size| {\n                    let points = construct_points(size);\n                    // Rerandomize the scalars for every call to prevent\n                    // false timings from better caching (e.g., the CPU\n                    // cache lifts exactly the right table entries for the\n                    // benchmark into the highest cache levels).\n                    b.iter_batched(\n                        || construct_scalars(size),\n                        |scalars| EdwardsPoint::vartime_multiscalar_mul(&scalars, &points),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }\n\n    fn vartime_precomputed_pure_static<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\n                    \"Variable-time fixed-base multiscalar multiplication\",\n                    multiscalar_size,\n                ),\n                &multiscalar_size,\n                move |b, &&total_size| {\n                    let static_size = total_size;\n\n                    let static_points = construct_points(static_size);\n                    let precomp = VartimeEdwardsPrecomputation::new(static_points);\n                    // Rerandomize the scalars for every call to prevent\n                    // false timings from better caching (e.g., the CPU\n                    // cache lifts exactly the right table entries for the\n                    // benchmark into the highest cache levels).\n                    b.iter_batched(\n                        || construct_scalars(static_size),\n                        |scalars| precomp.vartime_multiscalar_mul(scalars),\n                        BatchSize::SmallInput,\n                    );\n                },\n            );\n        }\n    }\n\n    fn vartime_precomputed_helper<M: Measurement>(\n        c: &mut BenchmarkGroup<M>,\n        dynamic_fraction: f64,\n    ) {\n        for multiscalar_size in &MULTISCALAR_SIZES {\n            let bench_id = BenchmarkId::new(\n                \"Variable-time mixed-base\",\n                format!(\n                    \"(size: {:?}), ({:.0}pct dyn)\",\n                    multiscalar_size,\n                    100.0 * dynamic_fraction\n                ),\n            );\n\n            c.bench_with_input(bench_id, &multiscalar_size, move |b, &&total_size| {\n                let dynamic_size = ((total_size as f64) * dynamic_fraction) as usize;\n                let static_size = total_size - dynamic_size;\n\n                let static_points = construct_points(static_size);\n                let dynamic_points = construct_points(dynamic_size);\n                let precomp = VartimeEdwardsPrecomputation::new(static_points);\n                // Rerandomize the scalars for every call to prevent\n                // false timings from better caching (e.g., the CPU\n                // cache lifts exactly the right table entries for the\n                // benchmark into the highest cache levels).  Timings\n                // should be independent of points so we don't\n                // randomize them.\n                b.iter_batched(\n                    || {\n                        (\n                            construct_scalars(static_size),\n                            construct_scalars(dynamic_size),\n                        )\n                    },\n                    |(static_scalars, dynamic_scalars)| {\n                        precomp.vartime_mixed_multiscalar_mul(\n                            &static_scalars,\n                            &dynamic_scalars,\n                            &dynamic_points,\n                        )\n                    },\n                    BatchSize::SmallInput,\n                );\n            });\n        }\n    }\n\n    pub(crate) fn multiscalar_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"multiscalar benches\");\n\n        consttime_multiscalar_mul(&mut g);\n        vartime_multiscalar_mul(&mut g);\n        vartime_precomputed_pure_static(&mut g);\n\n        let dynamic_fracs = [0.0, 0.2, 0.5];\n\n        for frac in dynamic_fracs.iter() {\n            vartime_precomputed_helper(&mut g, *frac);\n        }\n    }\n}\n\nmod ristretto_benches {\n    use super::*;\n    use curve25519_dalek::ristretto::RistrettoPoint;\n\n    fn compress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"RistrettoPoint compression\", |b| {\n            let B = &constants::RISTRETTO_BASEPOINT_POINT;\n            b.iter(|| B.compress())\n        });\n    }\n\n    fn decompress<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"RistrettoPoint decompression\", |b| {\n            let B_comp = &constants::RISTRETTO_BASEPOINT_COMPRESSED;\n            b.iter(|| B_comp.decompress().unwrap())\n        });\n    }\n\n    fn double_and_compress_batch<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in &BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch Ristretto double-and-encode\", *batch_size),\n                &batch_size,\n                |b, &&size| {\n                    let mut rng = OsRng;\n                    let points: Vec<RistrettoPoint> = (0..size)\n                        .map(|_| RistrettoPoint::try_from_rng(&mut rng).unwrap())\n                        .collect();\n                    b.iter(|| RistrettoPoint::double_and_compress_batch(&points));\n                },\n            );\n        }\n    }\n\n    pub(crate) fn ristretto_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"ristretto benches\");\n\n        compress(&mut g);\n        decompress(&mut g);\n        double_and_compress_batch(&mut g);\n    }\n}\n\nmod montgomery_benches {\n    use super::*;\n    use curve25519_dalek::montgomery::MontgomeryPoint;\n\n    fn montgomery_ladder<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        c.bench_function(\"Montgomery pseudomultiplication\", |b| {\n            let B = constants::X25519_BASEPOINT;\n            let s = Scalar::from(897987897u64).invert();\n            b.iter(|| B * s);\n        });\n    }\n\n    fn consttime_fixed_base_scalar_mul<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let s = Scalar::from(897987897u64).invert();\n        c.bench_function(\"Constant-time fixed-base scalar mul\", move |b| {\n            b.iter(|| MontgomeryPoint::mul_base(&s))\n        });\n    }\n\n    pub(crate) fn montgomery_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"montgomery benches\");\n\n        montgomery_ladder(&mut g);\n        consttime_fixed_base_scalar_mul(&mut g);\n    }\n}\n\nmod scalar_benches {\n    use super::*;\n\n    fn scalar_arith<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        let mut rng = rng();\n\n        c.bench_function(\"Scalar inversion\", |b| {\n            let s = Scalar::from(897987897u64).invert();\n            b.iter(|| s.invert());\n        });\n        c.bench_function(\"Scalar addition\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a + b,\n                BatchSize::SmallInput,\n            );\n        });\n        c.bench_function(\"Scalar subtraction\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a - b,\n                BatchSize::SmallInput,\n            );\n        });\n        c.bench_function(\"Scalar multiplication\", |b| {\n            b.iter_batched(\n                || (Scalar::random(&mut rng), Scalar::random(&mut rng)),\n                |(a, b)| a * b,\n                BatchSize::SmallInput,\n            );\n        });\n    }\n\n    fn batch_scalar_inversion<M: Measurement>(c: &mut BenchmarkGroup<M>) {\n        for batch_size in &BATCH_SIZES {\n            c.bench_with_input(\n                BenchmarkId::new(\"Batch scalar inversion\", *batch_size),\n                &batch_size,\n                |b, &&size| {\n                    let mut rng = OsRng.unwrap_err();\n                    let scalars: Vec<Scalar> =\n                        (0..size).map(|_| Scalar::random(&mut rng)).collect();\n                    b.iter(|| {\n                        let mut s = scalars.clone();\n                        Scalar::batch_invert(&mut s);\n                    });\n                },\n            );\n        }\n    }\n\n    pub(crate) fn scalar_benches() {\n        let mut c = Criterion::default();\n        let mut g = c.benchmark_group(\"scalar benches\");\n\n        scalar_arith(&mut g);\n        batch_scalar_inversion(&mut g);\n    }\n}\n\ncriterion_main!(\n    scalar_benches::scalar_benches,\n    montgomery_benches::montgomery_benches,\n    ristretto_benches::ristretto_benches,\n    edwards_benches::edwards_benches,\n    multiscalar_benches::multiscalar_benches,\n);\n",
    "filename": "curve25519-dalek/benches/dalek_benchmarks.rs",
    "filepath": null,
    "folder_id": 15826,
    "user_id": 460154
  },
  "63597": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Parallel Edwards Arithmetic for Curve25519.\n//!\n//! This module currently has two point types:\n//!\n//! * `ExtendedPoint`: a point stored in vector-friendly format, with\n//!   vectorized doubling and addition;\n//!\n//! * `CachedPoint`: used for readdition.\n//!\n//! Details on the formulas can be found in the documentation for the\n//! parent `avx2` module.\n//!\n//! This API is designed to be safe: vectorized points can only be\n//! created from serial points (which do validation on decompression),\n//! and operations on valid points return valid points, so invalid\n//! point states should be unrepresentable.\n//!\n//! This design goal is met, with one exception: the `Neg`\n//! implementation for the `CachedPoint` performs a lazy negation, so\n//! that subtraction can be efficiently implemented as a negation and\n//! an addition.  Repeatedly negating a `CachedPoint` will cause its\n//! coefficients to grow and eventually overflow.  Repeatedly negating\n//! a point should not be necessary anyways.\n\n#![allow(non_snake_case)]\n\nuse core::ops::{Add, Neg, Sub};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\nuse curve25519_dalek_derive::unsafe_target_feature;\n\nuse crate::edwards;\nuse crate::window::{LookupTable, NafLookupTable5};\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nuse crate::window::NafLookupTable8;\n\nuse crate::traits::Identity;\n\nuse super::constants;\nuse super::field::{FieldElement2625x4, Lanes, Shuffle};\n\n/// A point on Curve25519, using parallel Edwards formulas for curve\n/// operations.\n///\n/// # Invariant\n///\n/// The coefficients of an `ExtendedPoint` are bounded with\n/// \\\\( b < 0.007 \\\\).\n#[derive(Copy, Clone, Debug)]\npub struct ExtendedPoint(pub(super) FieldElement2625x4);\n\n#[unsafe_target_feature(\"avx2\")]\nimpl From<edwards::EdwardsPoint> for ExtendedPoint {\n    fn from(P: edwards::EdwardsPoint) -> ExtendedPoint {\n        ExtendedPoint(FieldElement2625x4::new(&P.X, &P.Y, &P.Z, &P.T))\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl From<ExtendedPoint> for edwards::EdwardsPoint {\n    fn from(P: ExtendedPoint) -> edwards::EdwardsPoint {\n        let tmp = P.0.split();\n        edwards::EdwardsPoint {\n            X: tmp[0],\n            Y: tmp[1],\n            Z: tmp[2],\n            T: tmp[3],\n        }\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl ConditionallySelectable for ExtendedPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ExtendedPoint(FieldElement2625x4::conditional_select(&a.0, &b.0, choice))\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.0.conditional_assign(&other.0, choice);\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Default for ExtendedPoint {\n    fn default() -> ExtendedPoint {\n        ExtendedPoint::identity()\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Identity for ExtendedPoint {\n    fn identity() -> ExtendedPoint {\n        constants::EXTENDEDPOINT_IDENTITY\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl ExtendedPoint {\n    /// Compute the double of this point.\n    pub fn double(&self) -> ExtendedPoint {\n        // Want to compute (X1 Y1 Z1 X1+Y1).\n        // Not sure how to do this less expensively than computing\n        // (X1 Y1 Z1 T1) --(256bit shuffle)--> (X1 Y1 X1 Y1)\n        // (X1 Y1 X1 Y1) --(2x128b shuffle)--> (Y1 X1 Y1 X1)\n        // and then adding.\n\n        // Set tmp0 = (X1 Y1 X1 Y1)\n        let mut tmp0 = self.0.shuffle(Shuffle::ABAB);\n\n        // Set tmp1 = (Y1 X1 Y1 X1)\n        let mut tmp1 = tmp0.shuffle(Shuffle::BADC);\n\n        // Set tmp0 = (X1 Y1 Z1 X1+Y1)\n        tmp0 = self.0.blend(tmp0 + tmp1, Lanes::D);\n\n        // Set tmp1 = tmp0^2, negating the D values\n        tmp1 = tmp0.square_and_negate_D();\n        // Now tmp1 = (S1 S2 S3 -S4) with b < 0.007\n\n        // See discussion of bounds in the module-level documentation.\n        // We want to compute\n        //\n        //    + | S1 | S1 | S1 | S1 |\n        //    + | S2 |    |    | S2 |\n        //    + |    |    | S3 |    |\n        //    + |    |    | S3 |    |\n        //    + |    |    |    |-S4 |\n        //    + |    | 2p | 2p |    |\n        //    - |    | S2 | S2 |    |\n        //    =======================\n        //        S5   S6   S8   S9\n\n        let zero = FieldElement2625x4::ZERO;\n        let S_1 = tmp1.shuffle(Shuffle::AAAA);\n        let S_2 = tmp1.shuffle(Shuffle::BBBB);\n\n        tmp0 = zero.blend(tmp1 + tmp1, Lanes::C);\n        // tmp0 = (0, 0,  2S_3, 0)\n        tmp0 = tmp0.blend(tmp1, Lanes::D);\n        // tmp0 = (0, 0,  2S_3, -S_4)\n        tmp0 = tmp0 + S_1;\n        // tmp0 = (  S_1,   S_1, S_1 + 2S_3, S_1 - S_4)\n        tmp0 = tmp0 + zero.blend(S_2, Lanes::AD);\n        // tmp0 = (S_1 + S_2,   S_1, S_1 + 2S_3, S_1 + S_2 - S_4)\n        tmp0 = tmp0 + zero.blend(S_2.negate_lazy(), Lanes::BC);\n        // tmp0 = (S_1 + S_2, S_1 - S_2, S_1 - S_2 + 2S_3, S_1 + S_2 - S_4)\n        //    b < (     1.01,       1.6,             2.33,             1.6)\n        // Now tmp0 = (S_5, S_6, S_8, S_9)\n\n        // Set tmp1 = ( S_9,  S_6,  S_6,  S_9)\n        //        b < ( 1.6,  1.6,  1.6,  1.6)\n        tmp1 = tmp0.shuffle(Shuffle::DBBD);\n        // Set tmp0 = ( S_8,  S_5,  S_8,  S_5)\n        //        b < (2.33, 1.01, 2.33, 1.01)\n        tmp0 = tmp0.shuffle(Shuffle::CACA);\n\n        // Bounds on (tmp0, tmp1) are (2.33, 1.6) < (2.5, 1.75).\n        ExtendedPoint(&tmp0 * &tmp1)\n    }\n\n    pub fn mul_by_pow_2(&self, k: u32) -> ExtendedPoint {\n        let mut tmp: ExtendedPoint = *self;\n        for _ in 0..k {\n            tmp = tmp.double();\n        }\n        tmp\n    }\n}\n\n/// A cached point with some precomputed variables used for readdition.\n///\n/// # Warning\n///\n/// It is not safe to negate this point more than once.\n///\n/// # Invariant\n///\n/// As long as the `CachedPoint` is not repeatedly negated, its\n/// coefficients will be bounded with \\\\( b < 1.0 \\\\).\n#[derive(Copy, Clone, Debug)]\npub struct CachedPoint(pub(super) FieldElement2625x4);\n\n#[unsafe_target_feature(\"avx2\")]\nimpl From<ExtendedPoint> for CachedPoint {\n    fn from(P: ExtendedPoint) -> CachedPoint {\n        let mut x = P.0;\n\n        x = x.blend(x.diff_sum(), Lanes::AB);\n        // x = (Y2 - X2, Y2 + X2, Z2, T2) = (S2 S3 Z2 T2)\n\n        x = x * (121666, 121666, 2 * 121666, 2 * 121665);\n        // x = (121666*S2 121666*S3 2*121666*Z2 2*121665*T2)\n\n        x = x.blend(-x, Lanes::D);\n        // x = (121666*S2 121666*S3 2*121666*Z2 -2*121665*T2)\n\n        // The coefficients of the output are bounded with b < 0.007.\n        CachedPoint(x)\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Default for CachedPoint {\n    fn default() -> CachedPoint {\n        CachedPoint::identity()\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Identity for CachedPoint {\n    fn identity() -> CachedPoint {\n        constants::CACHEDPOINT_IDENTITY\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl ConditionallySelectable for CachedPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        CachedPoint(FieldElement2625x4::conditional_select(&a.0, &b.0, choice))\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.0.conditional_assign(&other.0, choice);\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Neg for &CachedPoint {\n    type Output = CachedPoint;\n    /// Lazily negate the point.\n    ///\n    /// # Warning\n    ///\n    /// Because this method does not perform a reduction, it is not\n    /// safe to repeatedly negate a point.\n    fn neg(self) -> CachedPoint {\n        let swapped = self.0.shuffle(Shuffle::BACD);\n        CachedPoint(swapped.blend(swapped.negate_lazy(), Lanes::D))\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Add<&CachedPoint> for &ExtendedPoint {\n    type Output = ExtendedPoint;\n\n    /// Add an `ExtendedPoint` and a `CachedPoint`.\n    fn add(self, other: &CachedPoint) -> ExtendedPoint {\n        // The coefficients of an `ExtendedPoint` are reduced after\n        // every operation.  If the `CachedPoint` was negated, its\n        // coefficients grow by one bit.  So on input, `self` is\n        // bounded with `b < 0.007` and `other` is bounded with\n        // `b < 1.0`.\n\n        let mut tmp = self.0;\n\n        tmp = tmp.blend(tmp.diff_sum(), Lanes::AB);\n        // tmp = (Y1-X1 Y1+X1 Z1 T1) = (S0 S1 Z1 T1) with b < 1.6\n\n        // (tmp, other) bounded with b < (1.6, 1.0) < (2.5, 1.75).\n        tmp = &tmp * &other.0;\n        // tmp = (S0*S2' S1*S3' Z1*Z2' T1*T2') = (S8 S9 S10 S11)\n\n        tmp = tmp.shuffle(Shuffle::ABDC);\n        // tmp = (S8 S9 S11 S10)\n\n        tmp = tmp.diff_sum();\n        // tmp = (S9-S8 S9+S8 S10-S11 S10+S11) = (S12 S13 S14 S15)\n\n        let t0 = tmp.shuffle(Shuffle::ADDA);\n        // t0 = (S12 S15 S15 S12)\n        let t1 = tmp.shuffle(Shuffle::CBCB);\n        // t1 = (S14 S13 S14 S13)\n\n        // All coefficients of t0, t1 are bounded with b < 1.6.\n        // Return (S12*S14 S15*S13 S15*S14 S12*S13) = (X3 Y3 Z3 T3)\n        ExtendedPoint(&t0 * &t1)\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Sub<&CachedPoint> for &ExtendedPoint {\n    type Output = ExtendedPoint;\n\n    /// Implement subtraction by negating the point and adding.\n    ///\n    /// Empirically, this seems about the same cost as a custom\n    /// subtraction impl (maybe because the benefit is cancelled by\n    /// increased code size?)\n    fn sub(self, other: &CachedPoint) -> ExtendedPoint {\n        self + &(-other)\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl From<&edwards::EdwardsPoint> for LookupTable<CachedPoint> {\n    fn from(point: &edwards::EdwardsPoint) -> Self {\n        let P = ExtendedPoint::from(*point);\n        let mut points = [CachedPoint::from(P); 8];\n        for i in 0..7 {\n            points[i + 1] = (&P + &points[i]).into();\n        }\n        LookupTable(points)\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl From<&edwards::EdwardsPoint> for NafLookupTable5<CachedPoint> {\n    fn from(point: &edwards::EdwardsPoint) -> Self {\n        let A = ExtendedPoint::from(*point);\n        let mut Ai = [CachedPoint::from(A); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).into();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n#[unsafe_target_feature(\"avx2\")]\nimpl From<&edwards::EdwardsPoint> for NafLookupTable8<CachedPoint> {\n    fn from(point: &edwards::EdwardsPoint) -> Self {\n        let A = ExtendedPoint::from(*point);\n        let mut Ai = [CachedPoint::from(A); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).into();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }\n}\n\n#[cfg(target_feature = \"avx2\")]\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[rustfmt::skip] // keep alignment of some S* calculations\n    fn serial_add(P: edwards::EdwardsPoint, Q: edwards::EdwardsPoint) -> edwards::EdwardsPoint {\n        use crate::backend::serial::u64::field::FieldElement51;\n\n        let (X1, Y1, Z1, T1) = (P.X, P.Y, P.Z, P.T);\n        let (X2, Y2, Z2, T2) = (Q.X, Q.Y, Q.Z, Q.T);\n\n        macro_rules! print_var {\n            ($x:ident) => {\n                println!(\"{} = {:?}\", stringify!($x), $x.to_bytes());\n            };\n        }\n\n        let S0 = &Y1 - &X1; // R1\n        let S1 = &Y1 + &X1; // R3\n        let S2 = &Y2 - &X2; // R2\n        let S3 = &Y2 + &X2; // R4\n        print_var!(S0);\n        print_var!(S1);\n        print_var!(S2);\n        print_var!(S3);\n        println!(\"\");\n\n        let S4 = &S0 * &S2; // R5 = R1 * R2\n        let S5 = &S1 * &S3; // R6 = R3 * R4\n        let S6 = &Z1 * &Z2; // R8\n        let S7 = &T1 * &T2; // R7\n        print_var!(S4);\n        print_var!(S5);\n        print_var!(S6);\n        print_var!(S7);\n        println!(\"\");\n\n        let S8  =  &S4 *    &FieldElement51([  121666,0,0,0,0]);  // R5\n        let S9  =  &S5 *    &FieldElement51([  121666,0,0,0,0]);  // R6\n        let S10 =  &S6 *    &FieldElement51([2*121666,0,0,0,0]);  // R8\n        let S11 =  &S7 * &(-&FieldElement51([2*121665,0,0,0,0])); // R7\n        print_var!(S8);\n        print_var!(S9);\n        print_var!(S10);\n        print_var!(S11);\n        println!(\"\");\n\n        let S12 =  &S9 - &S8;  // R1\n        let S13 =  &S9 + &S8;  // R4\n        let S14 = &S10 - &S11; // R2\n        let S15 = &S10 + &S11; // R3\n        print_var!(S12);\n        print_var!(S13);\n        print_var!(S14);\n        print_var!(S15);\n        println!(\"\");\n\n        let X3 = &S12 * &S14; // R1 * R2\n        let Y3 = &S15 * &S13; // R3 * R4\n        let Z3 = &S15 * &S14; // R2 * R3\n        let T3 = &S12 * &S13; // R1 * R4\n\n        edwards::EdwardsPoint {\n            X: X3,\n            Y: Y3,\n            Z: Z3,\n            T: T3,\n        }\n    }\n\n    fn addition_test_helper(P: edwards::EdwardsPoint, Q: edwards::EdwardsPoint) {\n        // Test the serial implementation of the parallel addition formulas\n        let R_serial: edwards::EdwardsPoint = serial_add(P.into(), Q.into()).into();\n\n        // Test the vector implementation of the parallel readdition formulas\n        let cached_Q = CachedPoint::from(ExtendedPoint::from(Q));\n        let R_vector: edwards::EdwardsPoint = (&ExtendedPoint::from(P) + &cached_Q).into();\n        let S_vector: edwards::EdwardsPoint = (&ExtendedPoint::from(P) - &cached_Q).into();\n\n        println!(\"Testing point addition:\");\n        println!(\"P = {:?}\", P);\n        println!(\"Q = {:?}\", Q);\n        println!(\"cached Q = {:?}\", cached_Q);\n        println!(\"R = P + Q = {:?}\", &P + &Q);\n        println!(\"R_serial = {:?}\", R_serial);\n        println!(\"R_vector = {:?}\", R_vector);\n        println!(\"S = P - Q = {:?}\", &P - &Q);\n        println!(\"S_vector = {:?}\", S_vector);\n        assert_eq!(R_serial.compress(), (&P + &Q).compress());\n        assert_eq!(R_vector.compress(), (&P + &Q).compress());\n        assert_eq!(S_vector.compress(), (&P - &Q).compress());\n        println!(\"OK!\\n\");\n    }\n\n    #[test]\n    fn vector_addition_vs_serial_addition_vs_edwards_extendedpoint() {\n        use crate::constants;\n        use crate::scalar::Scalar;\n\n        println!(\"Testing id +- id\");\n        let P = edwards::EdwardsPoint::identity();\n        let Q = edwards::EdwardsPoint::identity();\n        addition_test_helper(P, Q);\n\n        println!(\"Testing id +- B\");\n        let P = edwards::EdwardsPoint::identity();\n        let Q = constants::ED25519_BASEPOINT_POINT;\n        addition_test_helper(P, Q);\n\n        println!(\"Testing B +- B\");\n        let P = constants::ED25519_BASEPOINT_POINT;\n        let Q = constants::ED25519_BASEPOINT_POINT;\n        addition_test_helper(P, Q);\n\n        println!(\"Testing B +- kB\");\n        let P = constants::ED25519_BASEPOINT_POINT;\n        let Q = constants::ED25519_BASEPOINT_TABLE * &Scalar::from(8475983829u64);\n        addition_test_helper(P, Q);\n    }\n\n    fn serial_double(P: edwards::EdwardsPoint) -> edwards::EdwardsPoint {\n        let (X1, Y1, Z1, _T1) = (P.X, P.Y, P.Z, P.T);\n\n        macro_rules! print_var {\n            ($x:ident) => {\n                println!(\"{} = {:?}\", stringify!($x), $x.to_bytes());\n            };\n        }\n\n        let S0 = &X1 + &Y1; // R1\n        print_var!(S0);\n        println!(\"\");\n\n        let S1 = X1.square();\n        let S2 = Y1.square();\n        let S3 = Z1.square();\n        let S4 = S0.square();\n        print_var!(S1);\n        print_var!(S2);\n        print_var!(S3);\n        print_var!(S4);\n        println!(\"\");\n\n        let S5 = &S1 + &S2;\n        let S6 = &S1 - &S2;\n        let S7 = &S3 + &S3;\n        let S8 = &S7 + &S6;\n        let S9 = &S5 - &S4;\n        print_var!(S5);\n        print_var!(S6);\n        print_var!(S7);\n        print_var!(S8);\n        print_var!(S9);\n        println!(\"\");\n\n        let X3 = &S8 * &S9;\n        let Y3 = &S5 * &S6;\n        let Z3 = &S8 * &S6;\n        let T3 = &S5 * &S9;\n\n        edwards::EdwardsPoint {\n            X: X3,\n            Y: Y3,\n            Z: Z3,\n            T: T3,\n        }\n    }\n\n    fn doubling_test_helper(P: edwards::EdwardsPoint) {\n        let R1: edwards::EdwardsPoint = serial_double(P.into()).into();\n        let R2: edwards::EdwardsPoint = ExtendedPoint::from(P).double().into();\n        println!(\"Testing point doubling:\");\n        println!(\"P = {:?}\", P);\n        println!(\"(serial) R1 = {:?}\", R1);\n        println!(\"(vector) R2 = {:?}\", R2);\n        println!(\"P + P = {:?}\", &P + &P);\n        assert_eq!(R1.compress(), (&P + &P).compress());\n        assert_eq!(R2.compress(), (&P + &P).compress());\n        println!(\"OK!\\n\");\n    }\n\n    #[test]\n    fn vector_doubling_vs_serial_doubling_vs_edwards_extendedpoint() {\n        use crate::constants;\n        use crate::scalar::Scalar;\n\n        println!(\"Testing [2]id\");\n        let P = edwards::EdwardsPoint::identity();\n        doubling_test_helper(P);\n\n        println!(\"Testing [2]B\");\n        let P = constants::ED25519_BASEPOINT_POINT;\n        doubling_test_helper(P);\n\n        println!(\"Testing [2]([k]B)\");\n        let P = constants::ED25519_BASEPOINT_TABLE * &Scalar::from(8475983829u64);\n        doubling_test_helper(P);\n    }\n\n    #[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n    #[test]\n    fn basepoint_odd_lookup_table_verify() {\n        use crate::backend::vector::avx2::constants::BASEPOINT_ODD_LOOKUP_TABLE;\n        use crate::constants;\n\n        let basepoint_odd_table =\n            NafLookupTable8::<CachedPoint>::from(&constants::ED25519_BASEPOINT_POINT);\n        println!(\"basepoint_odd_lookup_table = {:?}\", basepoint_odd_table);\n\n        let table_B = &BASEPOINT_ODD_LOOKUP_TABLE;\n        for (b_vec, base_vec) in table_B.0.iter().zip(basepoint_odd_table.0.iter()) {\n            let b_splits = b_vec.0.split();\n            let base_splits = base_vec.0.split();\n\n            assert_eq!(base_splits[0], b_splits[0]);\n            assert_eq!(base_splits[1], b_splits[1]);\n            assert_eq!(base_splits[2], b_splits[2]);\n            assert_eq!(base_splits[3], b_splits[3]);\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/avx2/edwards.rs",
    "filepath": null,
    "folder_id": 15831,
    "user_id": 460154
  },
  "63598": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n// Nightly and stable currently disagree on the requirement of unsafe blocks when `unsafe_target_feature`\n// gets used.\n// See: https://github.com/rust-lang/rust/issues/132856\n#![allow(unused_unsafe)]\n\n//! An implementation of 4-way vectorized 32bit field arithmetic using\n//! AVX2.\n//!\n//! The `FieldElement2625x4` struct provides a vector of four field\n//! elements, implemented using AVX2 operations.  Its API is designed\n//! to abstract away the platform-dependent details, so that point\n//! arithmetic can be implemented only in terms of a vector of field\n//! elements.\n//!\n//! At this level, the API is optimized for speed and not safety.  The\n//! `FieldElement2625x4` does not always perform reductions.  The pre-\n//! and post-conditions on the bounds of the coefficients are\n//! documented for each method, but it is the caller's responsibility\n//! to ensure that there are no overflows.\n\n#![allow(non_snake_case)]\n\nconst A_LANES: u8 = 0b0000_0101;\nconst B_LANES: u8 = 0b0000_1010;\nconst C_LANES: u8 = 0b0101_0000;\nconst D_LANES: u8 = 0b1010_0000;\n\n#[allow(unused)]\nconst A_LANES64: u8 = 0b00_00_00_11;\n#[allow(unused)]\nconst B_LANES64: u8 = 0b00_00_11_00;\n#[allow(unused)]\nconst C_LANES64: u8 = 0b00_11_00_00;\n#[allow(unused)]\nconst D_LANES64: u8 = 0b11_00_00_00;\n\nuse crate::backend::vector::packed_simd::{u32x8, u64x4};\nuse core::ops::{Add, Mul, Neg};\n\nuse crate::backend::serial::u64::field::FieldElement51;\nuse crate::backend::vector::avx2::constants::{\n    P_TIMES_2_HI, P_TIMES_2_LO, P_TIMES_16_HI, P_TIMES_16_LO,\n};\n\nuse curve25519_dalek_derive::unsafe_target_feature;\n\n/// Unpack 32-bit lanes into 64-bit lanes:\n/// ```ascii,no_run\n/// (a0, b0, a1, b1, c0, d0, c1, d1)\n/// ```\n/// into\n/// ```ascii,no_run\n/// (a0, 0, b0, 0, c0, 0, d0, 0)\n/// (a1, 0, b1, 0, c1, 0, d1, 0)\n/// ```\n#[unsafe_target_feature(\"avx2\")]\n#[inline(always)]\nfn unpack_pair(src: u32x8) -> (u32x8, u32x8) {\n    let a: u32x8;\n    let b: u32x8;\n    let zero = u32x8::splat(0);\n    unsafe {\n        use core::arch::x86_64::_mm256_unpackhi_epi32;\n        use core::arch::x86_64::_mm256_unpacklo_epi32;\n        a = _mm256_unpacklo_epi32(src.into(), zero.into()).into();\n        b = _mm256_unpackhi_epi32(src.into(), zero.into()).into();\n    }\n    (a, b)\n}\n\n/// Repack 64-bit lanes into 32-bit lanes:\n/// ```ascii,no_run\n/// (a0, 0, b0, 0, c0, 0, d0, 0)\n/// (a1, 0, b1, 0, c1, 0, d1, 0)\n/// ```\n/// into\n/// ```ascii,no_run\n/// (a0, b0, a1, b1, c0, d0, c1, d1)\n/// ```\n#[unsafe_target_feature(\"avx2\")]\n#[inline(always)]\nfn repack_pair(x: u32x8, y: u32x8) -> u32x8 {\n    unsafe {\n        use core::arch::x86_64::_mm256_blend_epi32;\n        use core::arch::x86_64::_mm256_shuffle_epi32;\n\n        // Input: x = (a0, 0, b0, 0, c0, 0, d0, 0)\n        // Input: y = (a1, 0, b1, 0, c1, 0, d1, 0)\n\n        let x_shuffled = _mm256_shuffle_epi32(x.into(), 0b11_01_10_00);\n        let y_shuffled = _mm256_shuffle_epi32(y.into(), 0b10_00_11_01);\n\n        // x' = (a0, b0,  0,  0, c0, d0,  0,  0)\n        // y' = ( 0,  0, a1, b1,  0,  0, c1, d1)\n\n        _mm256_blend_epi32(x_shuffled, y_shuffled, 0b11001100).into()\n    }\n}\n\n/// The `Lanes` enum represents a subset of the lanes `A,B,C,D` of a\n/// `FieldElement2625x4`.\n///\n/// It's used to specify blend operations without\n/// having to know details about the data layout of the\n/// `FieldElement2625x4`.\n#[allow(clippy::upper_case_acronyms)]\n#[derive(Copy, Clone, Debug)]\npub enum Lanes {\n    C,\n    D,\n    AB,\n    AC,\n    CD,\n    AD,\n    BC,\n    ABCD,\n}\n\n/// The `Shuffle` enum represents a shuffle of a `FieldElement2625x4`.\n///\n/// The enum variants are named by what they do to a vector \\\\(\n/// (A,B,C,D) \\\\); for instance, `Shuffle::BADC` turns \\\\( (A, B, C,\n/// D) \\\\) into \\\\( (B, A, D, C) \\\\).\n#[allow(clippy::upper_case_acronyms)]\n#[derive(Copy, Clone, Debug)]\npub enum Shuffle {\n    AAAA,\n    BBBB,\n    CACA,\n    DBBD,\n    ADDA,\n    CBCB,\n    ABAB,\n    BADC,\n    BACD,\n    ABDC,\n}\n\n/// A vector of four field elements.\n///\n/// Each operation on a `FieldElement2625x4` has documented effects on\n/// the bounds of the coefficients.  This API is designed for speed\n/// and not safety; it is the caller's responsibility to ensure that\n/// the post-conditions of one operation are compatible with the\n/// pre-conditions of the next.\n#[derive(Clone, Copy, Debug)]\npub struct FieldElement2625x4(pub(crate) [u32x8; 5]);\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n#[unsafe_target_feature(\"avx2\")]\nimpl ConditionallySelectable for FieldElement2625x4 {\n    fn conditional_select(\n        a: &FieldElement2625x4,\n        b: &FieldElement2625x4,\n        choice: Choice,\n    ) -> FieldElement2625x4 {\n        let mask = (-(choice.unwrap_u8() as i32)) as u32;\n        let mask_vec = u32x8::splat(mask);\n        FieldElement2625x4([\n            a.0[0] ^ (mask_vec & (a.0[0] ^ b.0[0])),\n            a.0[1] ^ (mask_vec & (a.0[1] ^ b.0[1])),\n            a.0[2] ^ (mask_vec & (a.0[2] ^ b.0[2])),\n            a.0[3] ^ (mask_vec & (a.0[3] ^ b.0[3])),\n            a.0[4] ^ (mask_vec & (a.0[4] ^ b.0[4])),\n        ])\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement2625x4, choice: Choice) {\n        let mask = (-(choice.unwrap_u8() as i32)) as u32;\n        let mask_vec = u32x8::splat(mask);\n        self.0[0] ^= mask_vec & (self.0[0] ^ other.0[0]);\n        self.0[1] ^= mask_vec & (self.0[1] ^ other.0[1]);\n        self.0[2] ^= mask_vec & (self.0[2] ^ other.0[2]);\n        self.0[3] ^= mask_vec & (self.0[3] ^ other.0[3]);\n        self.0[4] ^= mask_vec & (self.0[4] ^ other.0[4]);\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl FieldElement2625x4 {\n    pub const ZERO: FieldElement2625x4 = FieldElement2625x4([u32x8::splat_const::<0>(); 5]);\n\n    /// Split this vector into an array of four (serial) field\n    /// elements.\n    #[rustfmt::skip] // keep alignment of extracted lanes\n    pub fn split(&self) -> [FieldElement51; 4] {\n        let mut out = [FieldElement51::ZERO; 4];\n        for i in 0..5 {\n            let a_2i   = self.0[i].extract::<0>() as u64; //\n            let b_2i   = self.0[i].extract::<1>() as u64; //\n            let a_2i_1 = self.0[i].extract::<2>() as u64; // `.\n            let b_2i_1 = self.0[i].extract::<3>() as u64; //  | pre-swapped to avoid\n            let c_2i   = self.0[i].extract::<4>() as u64; //  | a cross lane shuffle\n            let d_2i   = self.0[i].extract::<5>() as u64; // .'\n            let c_2i_1 = self.0[i].extract::<6>() as u64; //\n            let d_2i_1 = self.0[i].extract::<7>() as u64; //\n\n            out[0].0[i] = a_2i + (a_2i_1 << 26);\n            out[1].0[i] = b_2i + (b_2i_1 << 26);\n            out[2].0[i] = c_2i + (c_2i_1 << 26);\n            out[3].0[i] = d_2i + (d_2i_1 << 26);\n        }\n\n        out\n    }\n\n    /// Rearrange the elements of this vector according to `control`.\n    ///\n    /// The `control` parameter should be a compile-time constant, so\n    /// that when this function is inlined, LLVM is able to lower the\n    /// shuffle using an immediate.\n    #[inline]\n    pub fn shuffle(&self, control: Shuffle) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn shuffle_lanes(x: u32x8, control: Shuffle) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_permutevar8x32_epi32;\n\n                let c: u32x8 = match control {\n                    Shuffle::AAAA => u32x8::new(0, 0, 2, 2, 0, 0, 2, 2),\n                    Shuffle::BBBB => u32x8::new(1, 1, 3, 3, 1, 1, 3, 3),\n                    Shuffle::CACA => u32x8::new(4, 0, 6, 2, 4, 0, 6, 2),\n                    Shuffle::DBBD => u32x8::new(5, 1, 7, 3, 1, 5, 3, 7),\n                    Shuffle::ADDA => u32x8::new(0, 5, 2, 7, 5, 0, 7, 2),\n                    Shuffle::CBCB => u32x8::new(4, 1, 6, 3, 4, 1, 6, 3),\n                    Shuffle::ABAB => u32x8::new(0, 1, 2, 3, 0, 1, 2, 3),\n                    Shuffle::BADC => u32x8::new(1, 0, 3, 2, 5, 4, 7, 6),\n                    Shuffle::BACD => u32x8::new(1, 0, 3, 2, 4, 5, 6, 7),\n                    Shuffle::ABDC => u32x8::new(0, 1, 2, 3, 5, 4, 7, 6),\n                };\n                // Note that this gets turned into a generic LLVM\n                // shuffle-by-constants, which can be lowered to a simpler\n                // instruction than a generic permute.\n                _mm256_permutevar8x32_epi32(x.into(), c.into()).into()\n            }\n        }\n\n        FieldElement2625x4([\n            shuffle_lanes(self.0[0], control),\n            shuffle_lanes(self.0[1], control),\n            shuffle_lanes(self.0[2], control),\n            shuffle_lanes(self.0[3], control),\n            shuffle_lanes(self.0[4], control),\n        ])\n    }\n\n    /// Blend `self` with `other`, taking lanes specified in `control` from `other`.\n    ///\n    /// The `control` parameter should be a compile-time constant, so\n    /// that this function can be inlined and LLVM can lower it to a\n    /// blend instruction using an immediate.\n    #[inline]\n    pub fn blend(&self, other: FieldElement2625x4, control: Lanes) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn blend_lanes(x: u32x8, y: u32x8, control: Lanes) -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n\n                // This would be much cleaner if we could factor out the match\n                // statement on the control. Unfortunately, rustc forgets\n                // constant-info very quickly, so we can't even write\n                // ```\n                // match control {\n                //     Lanes::C => {\n                //         let imm = C_LANES as i32;\n                //         _mm256_blend_epi32(..., imm)\n                // ```\n                // let alone\n                // ```\n                // let imm = match control {\n                //     Lanes::C => C_LANES as i32,\n                // }\n                // _mm256_blend_epi32(..., imm)\n                // ```\n                // even though both of these would be constant-folded by LLVM\n                // at a lower level (as happens in the shuffle implementation,\n                // which does not require a shuffle immediate but *is* lowered\n                // to immediate shuffles anyways).\n                match control {\n                    Lanes::C => _mm256_blend_epi32(x.into(), y.into(), C_LANES as i32).into(),\n                    Lanes::D => _mm256_blend_epi32(x.into(), y.into(), D_LANES as i32).into(),\n                    Lanes::AD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::AB => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | B_LANES) as i32).into()\n                    }\n                    Lanes::AC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (A_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::CD => {\n                        _mm256_blend_epi32(x.into(), y.into(), (C_LANES | D_LANES) as i32).into()\n                    }\n                    Lanes::BC => {\n                        _mm256_blend_epi32(x.into(), y.into(), (B_LANES | C_LANES) as i32).into()\n                    }\n                    Lanes::ABCD => _mm256_blend_epi32(\n                        x.into(),\n                        y.into(),\n                        (A_LANES | B_LANES | C_LANES | D_LANES) as i32,\n                    )\n                    .into(),\n                }\n            }\n        }\n\n        FieldElement2625x4([\n            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n\n    /// Convenience wrapper around `new(x,x,x,x)`.\n    pub fn splat(x: &FieldElement51) -> FieldElement2625x4 {\n        FieldElement2625x4::new(x, x, x, x)\n    }\n\n    /// Create a `FieldElement2625x4` from four `FieldElement51`s.\n    ///\n    /// # Postconditions\n    ///\n    /// The resulting `FieldElement2625x4` is bounded with \\\\( b < 0.0002 \\\\).\n    #[rustfmt::skip] // keep alignment of computed lanes\n    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> FieldElement2625x4 {\n        let mut buf = [u32x8::splat(0); 5];\n        let low_26_bits = (1 << 26) - 1;\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5 {\n            let a_2i   = (x0.0[i] & low_26_bits) as u32;\n            let a_2i_1 = (x0.0[i] >> 26) as u32;\n            let b_2i   = (x1.0[i] & low_26_bits) as u32;\n            let b_2i_1 = (x1.0[i] >> 26) as u32;\n            let c_2i   = (x2.0[i] & low_26_bits) as u32;\n            let c_2i_1 = (x2.0[i] >> 26) as u32;\n            let d_2i   = (x3.0[i] & low_26_bits) as u32;\n            let d_2i_1 = (x3.0[i] >> 26) as u32;\n\n            buf[i] = u32x8::new(a_2i, b_2i, a_2i_1, b_2i_1, c_2i, d_2i, c_2i_1, d_2i_1);\n        }\n\n        // We don't know that the original `FieldElement51`s were\n        // fully reduced, so the odd limbs may exceed 2^25.\n        // Reduce them to be sure.\n        FieldElement2625x4(buf).reduce()\n    }\n\n    /// Given \\\\((A,B,C,D)\\\\), compute \\\\((-A,-B,-C,-D)\\\\), without\n    /// performing a reduction.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.999 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1 \\\\).\n    #[inline]\n    pub fn negate_lazy(&self) -> FieldElement2625x4 {\n        // The limbs of self are bounded with b < 0.999, while the\n        // smallest limb of 2*p is 67108845 > 2^{26+0.9999}, so\n        // underflows are not possible.\n        FieldElement2625x4([\n            P_TIMES_2_LO - self.0[0],\n            P_TIMES_2_HI - self.0[1],\n            P_TIMES_2_HI - self.0[2],\n            P_TIMES_2_HI - self.0[3],\n            P_TIMES_2_HI - self.0[4],\n        ])\n    }\n\n    /// Given `self = (A,B,C,D)`, compute `(B - A, B + A, D - C, D + C)`.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 0.01 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 1.6 \\\\).\n    #[inline]\n    pub fn diff_sum(&self) -> FieldElement2625x4 {\n        // tmp1 = (B, A, D, C)\n        let tmp1 = self.shuffle(Shuffle::BADC);\n        // tmp2 = (-A, B, -C, D)\n        let tmp2 = self.blend(self.negate_lazy(), Lanes::AC);\n        // (B - A, B + A, D - C, D + C) bounded with b < 1.6\n        tmp1 + tmp2\n    }\n\n    /// Reduce this vector of field elements \\\\(\\mathrm{mod} p\\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.0002 \\\\).\n    #[inline]\n    pub fn reduce(&self) -> FieldElement2625x4 {\n        let shifts = u32x8::new(26, 26, 25, 25, 26, 26, 25, 25);\n        let masks = u32x8::new(\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n            (1 << 26) - 1,\n            (1 << 26) - 1,\n            (1 << 25) - 1,\n            (1 << 25) - 1,\n        );\n\n        // Let c(x) denote the carryout of the coefficient x.\n        //\n        // Given    (   x0,    y0,    x1,    y1,    z0,    w0,    z1,    w1),\n        // compute  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0)).\n        //\n        // The carryouts are bounded by 2^(32 - 25) = 2^7.\n        let rotated_carryout = |v: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_shuffle_epi32;\n                use core::arch::x86_64::_mm256_srlv_epi32;\n\n                let c = _mm256_srlv_epi32(v.into(), shifts.into());\n                _mm256_shuffle_epi32(c, 0b01_00_11_10).into()\n            }\n        };\n\n        // Combine (lo, lo, lo, lo, lo, lo, lo, lo)\n        //    with (hi, hi, hi, hi, hi, hi, hi, hi)\n        //      to (lo, lo, hi, hi, lo, lo, hi, hi)\n        //\n        // This allows combining carryouts, e.g.,\n        //\n        // lo  (c(x1), c(y1), c(x0), c(y0), c(z1), c(w1), c(z0), c(w0))\n        // hi  (c(x3), c(y3), c(x2), c(y2), c(z3), c(w3), c(z2), c(w2))\n        // ->  (c(x1), c(y1), c(x2), c(y2), c(z1), c(w1), c(z2), c(w2))\n        //\n        // which is exactly the vector of carryins for\n        //\n        //     (   x2,    y2,    x3,    y3,    z2,    w2,    z3,    w3).\n        //\n        let combine = |v_lo: u32x8, v_hi: u32x8| -> u32x8 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(v_lo.into(), v_hi.into(), 0b11_00_11_00).into()\n            }\n        };\n\n        let mut v = self.0;\n\n        let c10 = rotated_carryout(v[0]);\n        v[0] = (v[0] & masks) + combine(u32x8::splat(0), c10);\n\n        let c32 = rotated_carryout(v[1]);\n        v[1] = (v[1] & masks) + combine(c10, c32);\n\n        let c54 = rotated_carryout(v[2]);\n        v[2] = (v[2] & masks) + combine(c32, c54);\n\n        let c76 = rotated_carryout(v[3]);\n        v[3] = (v[3] & masks) + combine(c54, c76);\n\n        let c98 = rotated_carryout(v[4]);\n        v[4] = (v[4] & masks) + combine(c76, c98);\n\n        let c9_19: u32x8 = unsafe {\n            use core::arch::x86_64::_mm256_mul_epu32;\n            use core::arch::x86_64::_mm256_shuffle_epi32;\n\n            // Need to rearrange c98, since vpmuludq uses the low\n            // 32-bits of each 64-bit lane to compute the product:\n            //\n            // c98       = (c(x9), c(y9), c(x8), c(y8), c(z9), c(w9), c(z8), c(w8));\n            // c9_spread = (c(x9), c(x8), c(y9), c(y8), c(z9), c(z8), c(w9), c(w8)).\n            let c9_spread = _mm256_shuffle_epi32(c98.into(), 0b11_01_10_00);\n\n            // Since the carryouts are bounded by 2^7, their products with 19\n            // are bounded by 2^11.25.  This means that\n            //\n            // c9_19_spread = (19*c(x9), 0, 19*c(y9), 0, 19*c(z9), 0, 19*c(w9), 0).\n            let c9_19_spread = _mm256_mul_epu32(c9_spread, u64x4::splat(19).into());\n\n            // Unshuffle:\n            // c9_19 = (19*c(x9), 19*c(y9), 0, 0, 19*c(z9), 19*c(w9), 0, 0).\n            _mm256_shuffle_epi32(c9_19_spread, 0b11_01_10_00).into()\n        };\n\n        // Add the final carryin.\n        v[0] += c9_19;\n\n        // Each output coefficient has exactly one carryin, which is\n        // bounded by 2^11.25, so they are bounded as\n        //\n        // c_even < 2^26 + 2^11.25 < 26.00006 < 2^{26+b}\n        // c_odd  < 2^25 + 2^11.25 < 25.0001  < 2^{25+b}\n        //\n        // where b = 0.0002.\n        FieldElement2625x4(v)\n    }\n\n    /// Given an array of wide coefficients, reduce them to a `FieldElement2625x4`.\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[inline]\n    #[rustfmt::skip] // keep alignment of carry chain\n    fn reduce64(mut z: [u64x4; 10]) -> FieldElement2625x4 {\n        // These aren't const because splat isn't a const fn\n        let LOW_25_BITS: u64x4 = u64x4::splat((1 << 25) - 1);\n        let LOW_26_BITS: u64x4 = u64x4::splat((1 << 26) - 1);\n\n        // Carry the value from limb i = 0..8 to limb i+1\n        let carry = |z: &mut [u64x4; 10], i: usize| {\n            debug_assert!(i < 9);\n            if i % 2 == 0 {\n                // Even limbs have 26 bits\n                z[i + 1] += z[i].shr::<26>();\n                z[i] &= LOW_26_BITS;\n            } else {\n                // Odd limbs have 25 bits\n                z[i + 1] += z[i].shr::<25>();\n                z[i] &= LOW_25_BITS;\n            }\n        };\n\n        // Perform two halves of the carry chain in parallel.\n        carry(&mut z, 0); carry(&mut z, 4);\n        carry(&mut z, 1); carry(&mut z, 5);\n        carry(&mut z, 2); carry(&mut z, 6);\n        carry(&mut z, 3); carry(&mut z, 7);\n        // Since z[3] < 2^64, c < 2^(64-25) = 2^39,\n        // so    z[4] < 2^26 + 2^39 < 2^39.0002\n        carry(&mut z, 4); carry(&mut z, 8);\n        // Now z[4] < 2^26\n        // and z[5] < 2^25 + 2^13.0002 < 2^25.0004 (good enough)\n\n        // Last carry has a multiplication by 19.  In the serial case we\n        // do a 64-bit multiplication by 19, but here we want to do a\n        // 32-bit multiplication.  However, if we only know z[9] < 2^64,\n        // the carry is bounded as c < 2^(64-25) = 2^39, which is too\n        // big.  To ensure c < 2^32, we would need z[9] < 2^57.\n        // Instead, we split the carry in two, with c = c_0 + c_1*2^26.\n\n        let c = z[9].shr::<25>();\n        z[9] &= LOW_25_BITS;\n        let mut c0: u64x4 = c & LOW_26_BITS; // c0 < 2^26;\n        let mut c1: u64x4 = c.shr::<26>();         // c1 < 2^(39-26) = 2^13;\n\n        let x19 = u64x4::splat(19);\n        c0 = u32x8::from(c0).mul32(u32x8::from(x19));\n        c1 = u32x8::from(c1).mul32(u32x8::from(x19));\n\n        z[0] += c0; // z0 < 2^26 + 2^30.25 < 2^30.33\n        z[1] += c1; // z1 < 2^25 + 2^17.25 < 2^25.0067\n        carry(&mut z, 0); // z0 < 2^26, z1 < 2^25.0067 + 2^4.33 = 2^25.007\n\n        // The output coefficients are bounded with\n        //\n        // b = 0.007  for z[1]\n        // b = 0.0004 for z[5]\n        // b = 0      for other z[i].\n        //\n        // So the packed result is bounded with b = 0.007.\n        FieldElement2625x4([\n            repack_pair(z[0].into(), z[1].into()),\n            repack_pair(z[2].into(), z[3].into()),\n            repack_pair(z[4].into(), z[5].into()),\n            repack_pair(z[6].into(), z[7].into()),\n            repack_pair(z[8].into(), z[9].into()),\n        ])\n    }\n\n    /// Square this field element, and negate the result's \\\\(D\\\\) value.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 1.5 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[rustfmt::skip] // keep alignment of z* calculations\n    pub fn square_and_negate_D(&self) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let x0_2 = x0.shl::<1>();\n        let x1_2 = x1.shl::<1>();\n        let x2_2 = x2.shl::<1>();\n        let x3_2 = x3.shl::<1>();\n        let x4_2 = x4.shl::<1>();\n        let x5_2 = x5.shl::<1>();\n        let x6_2 = x6.shl::<1>();\n        let x7_2 = x7.shl::<1>();\n\n        let x5_19 = m_lo(v19, x5);\n        let x6_19 = m_lo(v19, x6);\n        let x7_19 = m_lo(v19, x7);\n        let x8_19 = m_lo(v19, x8);\n        let x9_19 = m_lo(v19, x9);\n\n        let mut z0 = m(x0,   x0) + m(x2_2, x8_19) + m(x4_2, x6_19) + ((m(x1_2, x9_19) +   m(x3_2, x7_19) +    m(x5,   x5_19)).shl::<1>());\n        let mut z1 = m(x0_2, x1) + m(x3_2, x8_19) + m(x5_2, x6_19) +                    ((m(x2,   x9_19) +    m(x4,   x7_19)).shl::<1>());\n        let mut z2 = m(x0_2, x2) + m(x1_2,    x1) + m(x4_2, x8_19) +   m(x6,   x6_19) + ((m(x3_2, x9_19) +    m(x5_2, x7_19)).shl::<1>());\n        let mut z3 = m(x0_2, x3) + m(x1_2,    x2) + m(x5_2, x8_19) +                    ((m(x4,   x9_19) +    m(x6,   x7_19)).shl::<1>());\n        let mut z4 = m(x0_2, x4) + m(x1_2,  x3_2) + m(x2,      x2) +   m(x6_2, x8_19) + ((m(x5_2, x9_19) +    m(x7,   x7_19)).shl::<1>());\n        let mut z5 = m(x0_2, x5) + m(x1_2,    x4) + m(x2_2,    x3) +   m(x7_2, x8_19)                    +  ((m(x6,   x9_19)).shl::<1>());\n        let mut z6 = m(x0_2, x6) + m(x1_2,  x5_2) + m(x2_2,    x4) +   m(x3_2,    x3) +   m(x8,   x8_19) +  ((m(x7_2, x9_19)).shl::<1>());\n        let mut z7 = m(x0_2, x7) + m(x1_2,    x6) + m(x2_2,    x5) +   m(x3_2,    x4)                    +  ((m(x8,   x9_19)).shl::<1>());\n        let mut z8 = m(x0_2, x8) + m(x1_2,  x7_2) + m(x2_2,    x6) +   m(x3_2,  x5_2) +   m(x4,      x4) +  ((m(x9,   x9_19)).shl::<1>());\n        let mut z9 = m(x0_2, x9) + m(x1_2,    x8) + m(x2_2,    x7) +   m(x3_2,    x6) +   m(x4_2,    x5)                                 ;\n\n        // The biggest z_i is bounded as z_i < 249*2^(51 + 2*b);\n        // if b < 1.5 we get z_i < 4485585228861014016.\n        //\n        // The limbs of the multiples of p are bounded above by\n        //\n        // 0x3fffffff << 37 = 9223371899415822336 < 2^63\n        //\n        // and below by\n        //\n        // 0x1fffffff << 37 = 4611685880988434432\n        //                  > 4485585228861014016\n        //\n        // So these multiples of p are big enough to avoid underflow\n        // in subtraction, and small enough to fit within u64\n        // with room for a carry.\n\n        let low__p37 = u64x4::splat(0x3ffffed << 37);\n        let even_p37 = u64x4::splat(0x3ffffff << 37);\n        let odd__p37 = u64x4::splat(0x1ffffff << 37);\n\n        let negate_D = |x: u64x4, p: u64x4| -> u64x4 {\n            unsafe {\n                use core::arch::x86_64::_mm256_blend_epi32;\n                _mm256_blend_epi32(x.into(), (p - x).into(), D_LANES64 as i32).into()\n            }\n        };\n\n        z0 = negate_D(z0, low__p37);\n        z1 = negate_D(z1, odd__p37);\n        z2 = negate_D(z2, even_p37);\n        z3 = negate_D(z3, odd__p37);\n        z4 = negate_D(z4, even_p37);\n        z5 = negate_D(z5, odd__p37);\n        z6 = negate_D(z6, even_p37);\n        z7 = negate_D(z7, odd__p37);\n        z8 = negate_D(z8, even_p37);\n        z9 = negate_D(z9, odd__p37);\n\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Neg for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n\n    /// Negate this field element, performing a reduction.\n    ///\n    /// If the coefficients are known to be small, use `negate_lazy`\n    /// to avoid performing a reduction.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 4.0 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.0002 \\\\).\n    #[inline]\n    fn neg(self) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            P_TIMES_16_LO - self.0[0],\n            P_TIMES_16_HI - self.0[1],\n            P_TIMES_16_HI - self.0[2],\n            P_TIMES_16_HI - self.0[3],\n            P_TIMES_16_HI - self.0[4],\n        ])\n        .reduce()\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Add<FieldElement2625x4> for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Add two `FieldElement2625x4`s, without performing a reduction.\n    #[inline]\n    fn add(self, rhs: FieldElement2625x4) -> FieldElement2625x4 {\n        FieldElement2625x4([\n            self.0[0] + rhs.0[0],\n            self.0[1] + rhs.0[1],\n            self.0[2] + rhs.0[2],\n            self.0[3] + rhs.0[3],\n            self.0[4] + rhs.0[4],\n        ])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Mul<(u32, u32, u32, u32)> for FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Perform a multiplication by a vector of small constants.\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    #[inline]\n    fn mul(self, scalars: (u32, u32, u32, u32)) -> FieldElement2625x4 {\n        let consts = u32x8::new(scalars.0, 0, scalars.1, 0, scalars.2, 0, scalars.3, 0);\n\n        let (b0, b1) = unpack_pair(self.0[0]);\n        let (b2, b3) = unpack_pair(self.0[1]);\n        let (b4, b5) = unpack_pair(self.0[2]);\n        let (b6, b7) = unpack_pair(self.0[3]);\n        let (b8, b9) = unpack_pair(self.0[4]);\n\n        FieldElement2625x4::reduce64([\n            b0.mul32(consts),\n            b1.mul32(consts),\n            b2.mul32(consts),\n            b3.mul32(consts),\n            b4.mul32(consts),\n            b5.mul32(consts),\n            b6.mul32(consts),\n            b7.mul32(consts),\n            b8.mul32(consts),\n            b9.mul32(consts),\n        ])\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl Mul<&FieldElement2625x4> for &FieldElement2625x4 {\n    type Output = FieldElement2625x4;\n    /// Multiply `self` by `rhs`.\n    ///\n    /// # Preconditions\n    ///\n    /// The coefficients of `self` must be bounded with \\\\( b < 2.5 \\\\).\n    ///\n    /// The coefficients of `rhs` must be bounded with \\\\( b < 1.75 \\\\).\n    ///\n    /// # Postconditions\n    ///\n    /// The coefficients of the result are bounded with \\\\( b < 0.007 \\\\).\n    ///\n    #[rustfmt::skip] // keep alignment of z* calculations\n    #[inline]\n    fn mul(self, rhs: &FieldElement2625x4) -> FieldElement2625x4 {\n        #[inline(always)]\n        fn m(x: u32x8, y: u32x8) -> u64x4 {\n            x.mul32(y)\n        }\n\n        #[inline(always)]\n        fn m_lo(x: u32x8, y: u32x8) -> u32x8 {\n            x.mul32(y).into()\n        }\n\n        let (x0, x1) = unpack_pair(self.0[0]);\n        let (x2, x3) = unpack_pair(self.0[1]);\n        let (x4, x5) = unpack_pair(self.0[2]);\n        let (x6, x7) = unpack_pair(self.0[3]);\n        let (x8, x9) = unpack_pair(self.0[4]);\n\n        let (y0, y1) = unpack_pair(rhs.0[0]);\n        let (y2, y3) = unpack_pair(rhs.0[1]);\n        let (y4, y5) = unpack_pair(rhs.0[2]);\n        let (y6, y7) = unpack_pair(rhs.0[3]);\n        let (y8, y9) = unpack_pair(rhs.0[4]);\n\n        let v19 = u32x8::new(19, 0, 19, 0, 19, 0, 19, 0);\n\n        let y1_19 = m_lo(v19, y1); // This fits in a u32\n        let y2_19 = m_lo(v19, y2); // iff 26 + b + lg(19) < 32\n        let y3_19 = m_lo(v19, y3); // if  b < 32 - 26 - 4.248 = 1.752\n        let y4_19 = m_lo(v19, y4);\n        let y5_19 = m_lo(v19, y5);\n        let y6_19 = m_lo(v19, y6);\n        let y7_19 = m_lo(v19, y7);\n        let y8_19 = m_lo(v19, y8);\n        let y9_19 = m_lo(v19, y9);\n\n        let x1_2 = x1 + x1; // This fits in a u32 iff 25 + b + 1 < 32\n        let x3_2 = x3 + x3; //                    iff b < 6\n        let x5_2 = x5 + x5;\n        let x7_2 = x7 + x7;\n        let x9_2 = x9 + x9;\n\n        let z0 = m(x0, y0) + m(x1_2, y9_19) + m(x2, y8_19) + m(x3_2, y7_19) + m(x4, y6_19) + m(x5_2, y5_19) + m(x6, y4_19) + m(x7_2, y3_19) + m(x8, y2_19) + m(x9_2, y1_19);\n        let z1 = m(x0, y1) + m(x1,      y0) + m(x2, y9_19) + m(x3,   y8_19) + m(x4, y7_19) + m(x5,   y6_19) + m(x6, y5_19) + m(x7,   y4_19) + m(x8, y3_19) + m(x9,   y2_19);\n        let z2 = m(x0, y2) + m(x1_2,    y1) + m(x2,    y0) + m(x3_2, y9_19) + m(x4, y8_19) + m(x5_2, y7_19) + m(x6, y6_19) + m(x7_2, y5_19) + m(x8, y4_19) + m(x9_2, y3_19);\n        let z3 = m(x0, y3) + m(x1,      y2) + m(x2,    y1) + m(x3,      y0) + m(x4, y9_19) + m(x5,   y8_19) + m(x6, y7_19) + m(x7,   y6_19) + m(x8, y5_19) + m(x9,   y4_19);\n        let z4 = m(x0, y4) + m(x1_2,    y3) + m(x2,    y2) + m(x3_2,    y1) + m(x4,    y0) + m(x5_2, y9_19) + m(x6, y8_19) + m(x7_2, y7_19) + m(x8, y6_19) + m(x9_2, y5_19);\n        let z5 = m(x0, y5) + m(x1,      y4) + m(x2,    y3) + m(x3,      y2) + m(x4,    y1) + m(x5,      y0) + m(x6, y9_19) + m(x7,   y8_19) + m(x8, y7_19) + m(x9,   y6_19);\n        let z6 = m(x0, y6) + m(x1_2,    y5) + m(x2,    y4) + m(x3_2,    y3) + m(x4,    y2) + m(x5_2,    y1) + m(x6,    y0) + m(x7_2, y9_19) + m(x8, y8_19) + m(x9_2, y7_19);\n        let z7 = m(x0, y7) + m(x1,      y6) + m(x2,    y5) + m(x3,      y4) + m(x4,    y3) + m(x5,      y2) + m(x6,    y1) + m(x7,      y0) + m(x8, y9_19) + m(x9,   y8_19);\n        let z8 = m(x0, y8) + m(x1_2,    y7) + m(x2,    y6) + m(x3_2,    y5) + m(x4,    y4) + m(x5_2,    y3) + m(x6,    y2) + m(x7_2,    y1) + m(x8,    y0) + m(x9_2, y9_19);\n        let z9 = m(x0, y9) + m(x1,      y8) + m(x2,    y7) + m(x3,      y6) + m(x4,    y5) + m(x5,      y4) + m(x6,    y3) + m(x7,      y2) + m(x8,    y1) + m(x9,      y0);\n\n        // The bounds on z[i] are the same as in the serial 32-bit code\n        // and the comment below is copied from there:\n\n        // How big is the contribution to z[i+j] from x[i], y[j]?\n        //\n        // Using the bounds above, we get:\n        //\n        // i even, j even:   x[i]*y[j] <   2^(26+b)*2^(26+b) = 2*2^(51+2*b)\n        // i  odd, j even:   x[i]*y[j] <   2^(25+b)*2^(26+b) = 1*2^(51+2*b)\n        // i even, j  odd:   x[i]*y[j] <   2^(26+b)*2^(25+b) = 1*2^(51+2*b)\n        // i  odd, j  odd: 2*x[i]*y[j] < 2*2^(25+b)*2^(25+b) = 1*2^(51+2*b)\n        //\n        // We perform inline reduction mod p by replacing 2^255 by 19\n        // (since 2^255 - 19 = 0 mod p).  This adds a factor of 19, so\n        // we get the bounds (z0 is the biggest one, but calculated for\n        // posterity here in case finer estimation is needed later):\n        //\n        //  z0 < ( 2 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 249*2^(51 + 2*b)\n        //  z1 < ( 1 +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 154*2^(51 + 2*b)\n        //  z2 < ( 2 +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 195*2^(51 + 2*b)\n        //  z3 < ( 1 +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 118*2^(51 + 2*b)\n        //  z4 < ( 2 +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 141*2^(51 + 2*b)\n        //  z5 < ( 1 +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) =  82*2^(51 + 2*b)\n        //  z6 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) =  87*2^(51 + 2*b)\n        //  z7 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 )*2^(51 + 2b) =  46*2^(51 + 2*b)\n        //  z8 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 )*2^(51 + 2b) =  33*2^(51 + 2*b)\n        //  z9 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   )*2^(51 + 2b) =  10*2^(51 + 2*b)\n        //\n        // So z[0] fits into a u64 if 51 + 2*b + lg(249) < 64\n        //                         if b < 2.5.\n\n        // In fact this bound is slightly sloppy, since it treats both\n        // inputs x and y as being bounded by the same parameter b,\n        // while they are in fact bounded by b_x and b_y, and we\n        // already require that b_y < 1.75 in order to fit the\n        // multiplications by 19 into a u32.  The tighter bound on b_y\n        // means we could get a tighter bound on the outputs, or a\n        // looser bound on b_x.\n        FieldElement2625x4::reduce64([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}\n\n#[cfg(target_feature = \"avx2\")]\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn scale_by_curve_constants() {\n        let mut x = FieldElement2625x4::splat(&FieldElement51::ONE);\n\n        x = x * (121666, 121666, 2 * 121666, 2 * 121665);\n\n        let xs = x.split();\n        assert_eq!(xs[0], FieldElement51([121666, 0, 0, 0, 0]));\n        assert_eq!(xs[1], FieldElement51([121666, 0, 0, 0, 0]));\n        assert_eq!(xs[2], FieldElement51([2 * 121666, 0, 0, 0, 0]));\n        assert_eq!(xs[3], FieldElement51([2 * 121665, 0, 0, 0, 0]));\n    }\n\n    #[test]\n    fn diff_sum_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3).diff_sum();\n\n        let result = vec.split();\n\n        assert_eq!(result[0], &x1 - &x0);\n        assert_eq!(result[1], &x1 + &x0);\n        assert_eq!(result[2], &x3 - &x2);\n        assert_eq!(result[3], &x3 + &x2);\n    }\n\n    #[test]\n    fn square_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let result = vec.square_and_negate_D().split();\n\n        assert_eq!(result[0], &x0 * &x0);\n        assert_eq!(result[1], &x1 * &x1);\n        assert_eq!(result[2], &x2 * &x2);\n        assert_eq!(result[3], -&(&x3 * &x3));\n    }\n\n    #[test]\n    fn multiply_vs_serial() {\n        let x0 = FieldElement51([10000, 10001, 10002, 10003, 10004]);\n        let x1 = FieldElement51([10100, 10101, 10102, 10103, 10104]);\n        let x2 = FieldElement51([10200, 10201, 10202, 10203, 10204]);\n        let x3 = FieldElement51([10300, 10301, 10302, 10303, 10304]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n        let vecprime = vec.clone();\n\n        let result = (&vec * &vecprime).split();\n\n        assert_eq!(result[0], &x0 * &x0);\n        assert_eq!(result[1], &x1 * &x1);\n        assert_eq!(result[2], &x2 * &x2);\n        assert_eq!(result[3], &x3 * &x3);\n    }\n\n    #[test]\n    fn test_unpack_repack_pair() {\n        let x0 = FieldElement51([10000 + (10001 << 26), 0, 0, 0, 0]);\n        let x1 = FieldElement51([10100 + (10101 << 26), 0, 0, 0, 0]);\n        let x2 = FieldElement51([10200 + (10201 << 26), 0, 0, 0, 0]);\n        let x3 = FieldElement51([10300 + (10301 << 26), 0, 0, 0, 0]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let src = vec.0[0];\n\n        let (a, b) = unpack_pair(src);\n\n        let expected_a = u32x8::new(10000, 0, 10100, 0, 10200, 0, 10300, 0);\n        let expected_b = u32x8::new(10001, 0, 10101, 0, 10201, 0, 10301, 0);\n\n        assert_eq!(a, expected_a);\n        assert_eq!(b, expected_b);\n\n        let expected_src = repack_pair(a, b);\n\n        assert_eq!(src, expected_src);\n    }\n\n    #[test]\n    fn new_split_roundtrips() {\n        let x0 = FieldElement51::from_bytes(&[0x10; 32]);\n        let x1 = FieldElement51::from_bytes(&[0x11; 32]);\n        let x2 = FieldElement51::from_bytes(&[0x12; 32]);\n        let x3 = FieldElement51::from_bytes(&[0x13; 32]);\n\n        let vec = FieldElement2625x4::new(&x0, &x1, &x2, &x3);\n\n        let splits = vec.split();\n\n        assert_eq!(x0, splits[0]);\n        assert_eq!(x1, splits[1]);\n        assert_eq!(x2, splits[2]);\n        assert_eq!(x3, splits[3]);\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/avx2/field.rs",
    "filepath": null,
    "folder_id": 15831,
    "user_id": 460154
  },
  "63599": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! This module contains constants used by the AVX2 backend.\n\nuse crate::backend::vector::packed_simd::u32x8;\n\nuse crate::backend::vector::avx2::edwards::{CachedPoint, ExtendedPoint};\nuse crate::backend::vector::avx2::field::FieldElement2625x4;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::window::NafLookupTable8;\n\n/// The identity element as an `ExtendedPoint`.\npub(crate) static EXTENDEDPOINT_IDENTITY: ExtendedPoint = ExtendedPoint(FieldElement2625x4([\n    u32x8::new_const(0, 1, 0, 0, 1, 0, 0, 0),\n    u32x8::splat_const::<0>(),\n    u32x8::splat_const::<0>(),\n    u32x8::splat_const::<0>(),\n    u32x8::splat_const::<0>(),\n]));\n\n/// The identity element as a `CachedPoint`.\npub(crate) static CACHEDPOINT_IDENTITY: CachedPoint = CachedPoint(FieldElement2625x4([\n    u32x8::new_const(121647, 121666, 0, 0, 243332, 67108845, 0, 33554431),\n    u32x8::new_const(67108864, 0, 33554431, 0, 0, 67108863, 0, 33554431),\n    u32x8::new_const(67108863, 0, 33554431, 0, 0, 67108863, 0, 33554431),\n    u32x8::new_const(67108863, 0, 33554431, 0, 0, 67108863, 0, 33554431),\n    u32x8::new_const(67108863, 0, 33554431, 0, 0, 67108863, 0, 33554431),\n]));\n\n/// The low limbs of (2p, 2p, 2p, 2p), so that\n/// ```ascii,no_run\n/// (2p, 2p, 2p, 2p) = [P_TIMES_2_LO, P_TIMES_2_HI, P_TIMES_2_HI, P_TIMES_2_HI, P_TIMES_2_HI]\n/// ```\npub(crate) static P_TIMES_2_LO: u32x8 = u32x8::new_const(\n    67108845 << 1,\n    67108845 << 1,\n    33554431 << 1,\n    33554431 << 1,\n    67108845 << 1,\n    67108845 << 1,\n    33554431 << 1,\n    33554431 << 1,\n);\n\n/// The high limbs of (2p, 2p, 2p, 2p), so that\n/// ```ascii,no_run\n/// (2p, 2p, 2p, 2p) = [P_TIMES_2_LO, P_TIMES_2_HI, P_TIMES_2_HI, P_TIMES_2_HI, P_TIMES_2_HI]\n/// ```\npub(crate) static P_TIMES_2_HI: u32x8 = u32x8::new_const(\n    67108863 << 1,\n    67108863 << 1,\n    33554431 << 1,\n    33554431 << 1,\n    67108863 << 1,\n    67108863 << 1,\n    33554431 << 1,\n    33554431 << 1,\n);\n\n/// The low limbs of (16p, 16p, 16p, 16p), so that\n/// ```ascii,no_run\n/// (16p, 16p, 16p, 16p) = [P_TIMES_16_LO, P_TIMES_16_HI, P_TIMES_16_HI, P_TIMES_16_HI, P_TIMES_16_HI]\n/// ```\npub(crate) static P_TIMES_16_LO: u32x8 = u32x8::new_const(\n    67108845 << 4,\n    67108845 << 4,\n    33554431 << 4,\n    33554431 << 4,\n    67108845 << 4,\n    67108845 << 4,\n    33554431 << 4,\n    33554431 << 4,\n);\n\n/// The high limbs of (16p, 16p, 16p, 16p), so that\n/// ```ascii,no_run\n/// (16p, 16p, 16p, 16p) = [P_TIMES_16_LO, P_TIMES_16_HI, P_TIMES_16_HI, P_TIMES_16_HI, P_TIMES_16_HI]\n/// ```\npub(crate) static P_TIMES_16_HI: u32x8 = u32x8::new_const(\n    67108863 << 4,\n    67108863 << 4,\n    33554431 << 4,\n    33554431 << 4,\n    67108863 << 4,\n    67108863 << 4,\n    33554431 << 4,\n    33554431 << 4,\n);\n\n/// Odd multiples of the Ed25519 basepoint:\n#[cfg(feature = \"precomputed-tables\")]\npub(crate) static BASEPOINT_ODD_LOOKUP_TABLE: NafLookupTable8<CachedPoint> = NafLookupTable8([\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            3571425, 10045002, 19036563, 1096096, 243332, 65897020, 0, 28963681,\n        ),\n        u32x8::new_const(\n            30896895, 63055514, 1614915, 5095970, 0, 53791688, 0, 31258312,\n        ),\n        u32x8::new_const(\n            13347627, 40339464, 2236269, 11185503, 0, 22520087, 0, 8659512,\n        ),\n        u32x8::new_const(\n            11125413, 29139905, 32037254, 28360723, 0, 64556417, 0, 9635759,\n        ),\n        u32x8::new_const(\n            33268144, 47262491, 4336918, 15795740, 0, 22027545, 0, 4846528,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            47099681, 31447946, 29365447, 24740513, 42991046, 18317844, 16051644, 21404226,\n        ),\n        u32x8::new_const(\n            31708133, 28909527, 2366091, 13703791, 469246, 54159622, 2601402, 32988002,\n        ),\n        u32x8::new_const(\n            63432457, 30251794, 15163516, 18491340, 28144087, 35605455, 13682295, 18474872,\n        ),\n        u32x8::new_const(\n            12221607, 4967598, 26061980, 26008006, 20226147, 9726961, 17410, 18051083,\n        ),\n        u32x8::new_const(\n            60569645, 62487085, 11911242, 21920922, 4092105, 38186967, 22431483, 31366585,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            18147205, 62587998, 2554617, 536692, 11924528, 26674131, 17645433, 24341419,\n        ),\n        u32x8::new_const(\n            11573357, 27579485, 31491870, 29000885, 10800976, 51902791, 28076395, 20464029,\n        ),\n        u32x8::new_const(\n            56031649, 10856669, 11791193, 26769430, 25306956, 5922200, 6630685, 9385098,\n        ),\n        u32x8::new_const(\n            31319348, 23906711, 16290213, 32142166, 61106354, 17181823, 3548308, 12022566,\n        ),\n        u32x8::new_const(\n            5904298, 50218605, 11826440, 5492249, 10379071, 3472255, 172742, 31948344,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            10625852, 15193821, 22918394, 23676410, 53695416, 54987793, 10067515, 11747680,\n        ),\n        u32x8::new_const(\n            65013325, 1309652, 29616320, 28922974, 60360891, 19621771, 9938982, 30406429,\n        ),\n        u32x8::new_const(\n            54967954, 65931918, 5595602, 25719523, 64909864, 30566415, 15945272, 8495317,\n        ),\n        u32x8::new_const(\n            1167157, 55265018, 11507029, 31641054, 43497904, 2367338, 12937761, 27517066,\n        ),\n        u32x8::new_const(\n            656704, 2544994, 13006713, 480979, 38471594, 62541240, 25353597, 11531760,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            22176662, 3984313, 27495285, 4110608, 2909584, 30594106, 15677919, 2549183,\n        ),\n        u32x8::new_const(\n            33979105, 62269905, 2071511, 6894756, 53189950, 47232857, 6408191, 6123225,\n        ),\n        u32x8::new_const(\n            32553873, 63948030, 12612401, 3633166, 24054373, 37626618, 14481327, 8520484,\n        ),\n        u32x8::new_const(\n            56552486, 10749438, 12034813, 28811946, 1445640, 36755601, 12104575, 10257833,\n        ),\n        u32x8::new_const(\n            22795808, 48761311, 1136056, 9380768, 1411523, 5341811, 27318329, 9686767,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            21157200, 39156966, 20473176, 4934657, 61478183, 45121537, 5429856, 13035023,\n        ),\n        u32x8::new_const(\n            7954529, 58789246, 31440083, 7054221, 38438565, 36856107, 1364112, 14548122,\n        ),\n        u32x8::new_const(\n            26120083, 36321360, 4919997, 31687496, 33757765, 36237559, 15243054, 32163861,\n        ),\n        u32x8::new_const(\n            25878307, 46544824, 19455951, 2414935, 16844726, 56521560, 32680554, 26660660,\n        ),\n        u32x8::new_const(\n            48360220, 43407178, 12187042, 24925816, 7423722, 25746484, 12814654, 17395963,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            63153652, 32195955, 4087908, 8431689, 30392384, 47203165, 8986649, 9053039,\n        ),\n        u32x8::new_const(\n            63659241, 47988767, 2931872, 19953600, 11747107, 51610101, 20952181, 13364887,\n        ),\n        u32x8::new_const(\n            3659197, 58790649, 5930099, 2605312, 28477896, 580728, 20579735, 2610622,\n        ),\n        u32x8::new_const(\n            41781607, 17161358, 10690531, 24368015, 47027031, 36742339, 5414694, 13156365,\n        ),\n        u32x8::new_const(\n            13237853, 51182423, 8954802, 29006542, 22643989, 56896541, 22830593, 10289708,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            1401265, 58846825, 30911620, 32239180, 15391552, 15200821, 6339309, 16403588,\n        ),\n        u32x8::new_const(\n            55913797, 29541724, 1664461, 21709410, 38470488, 47097092, 17674945, 32666066,\n        ),\n        u32x8::new_const(\n            22844482, 10797709, 27548106, 31638735, 34500968, 26611503, 19727211, 13160873,\n        ),\n        u32x8::new_const(\n            31485204, 14496164, 13981208, 10276888, 5748808, 35024436, 2740987, 7479021,\n        ),\n        u32x8::new_const(\n            58541207, 14866135, 32344041, 545930, 62661488, 6941250, 27940205, 11976112,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            39849808, 44781685, 15697329, 24387845, 12501486, 50260092, 23199481, 31929024,\n        ),\n        u32x8::new_const(\n            24823070, 27956017, 27034296, 10316465, 47664045, 11152446, 15719183, 30181617,\n        ),\n        u32x8::new_const(\n            20771189, 19969144, 31433937, 19185213, 27565920, 10384445, 2893359, 9255362,\n        ),\n        u32x8::new_const(\n            42894974, 11925545, 32134441, 32738810, 55916336, 32479272, 19563550, 5511385,\n        ),\n        u32x8::new_const(\n            17857161, 47809169, 14564114, 27997751, 33024640, 38669671, 31956536, 27313245,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            58237774, 15917425, 18872208, 19394230, 17374297, 6101419, 4839741, 6596900,\n        ),\n        u32x8::new_const(\n            66947393, 15744215, 18368993, 17750160, 41006525, 9205497, 2629667, 32170865,\n        ),\n        u32x8::new_const(\n            66481381, 1919414, 28338762, 7372967, 33819153, 4156199, 27126309, 12739816,\n        ),\n        u32x8::new_const(\n            44117158, 58545296, 22521371, 11809712, 28998792, 50731010, 30215699, 25748377,\n        ),\n        u32x8::new_const(\n            23561284, 4160244, 9035405, 24895184, 39761639, 59253416, 8684759, 22487864,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            12671134, 56419053, 16092401, 30038207, 4002647, 47822606, 7151311, 28430768,\n        ),\n        u32x8::new_const(\n            61041684, 35765374, 30598048, 19666539, 44150175, 40140037, 290469, 28442674,\n        ),\n        u32x8::new_const(\n            18847796, 1371617, 33316881, 13199936, 43646578, 17068881, 12074900, 1537415,\n        ),\n        u32x8::new_const(\n            10052225, 38316070, 27469797, 5297537, 50725570, 20435349, 10339121, 2779737,\n        ),\n        u32x8::new_const(\n            18372189, 15466385, 24762130, 22217964, 23503887, 47844464, 10415034, 2606889,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            55082775, 45300503, 16032654, 5964396, 17743504, 24634761, 19493066, 5184611,\n        ),\n        u32x8::new_const(\n            50172633, 35093294, 10040575, 23616256, 4543900, 61852191, 4049821, 7423669,\n        ),\n        u32x8::new_const(\n            20295398, 40009376, 10487190, 15670429, 51972856, 58649552, 20436392, 3432497,\n        ),\n        u32x8::new_const(\n            35189420, 54117751, 12825868, 6283038, 27540739, 30648758, 22658912, 9466689,\n        ),\n        u32x8::new_const(\n            51737549, 40725785, 17409814, 25201086, 21156239, 34176168, 26814520, 5956424,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            8211442, 8014184, 6260823, 22108096, 32182620, 51844847, 2466270, 28582231,\n        ),\n        u32x8::new_const(\n            27199739, 3848333, 31738017, 10892045, 4963982, 65391770, 32551997, 28906469,\n        ),\n        u32x8::new_const(\n            16606846, 32207068, 26404535, 7614129, 45416902, 65584718, 13821785, 2646060,\n        ),\n        u32x8::new_const(\n            36090634, 57981287, 32247670, 22837502, 31003861, 55448117, 6062915, 20369975,\n        ),\n        u32x8::new_const(\n            27381403, 50578107, 522631, 29521058, 31137497, 40220737, 27628049, 1824195,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            59402443, 17056879, 29262689, 6131785, 52551472, 43367471, 29423199, 18899208,\n        ),\n        u32x8::new_const(\n            5749414, 43514612, 11365899, 21514624, 65591890, 60945892, 19841732, 5628567,\n        ),\n        u32x8::new_const(\n            19334369, 52500268, 12307673, 5267367, 3212103, 9035822, 29142161, 30520954,\n        ),\n        u32x8::new_const(\n            57261330, 6819646, 22089161, 9800373, 55155453, 62250856, 13766735, 25244545,\n        ),\n        u32x8::new_const(\n            54370226, 61888301, 24496089, 2540581, 65637506, 60274355, 18154273, 11687259,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            12521903, 26014045, 13995625, 33360175, 23605474, 7376434, 27229267, 17195036,\n        ),\n        u32x8::new_const(\n            59482891, 10074423, 574357, 3857753, 61377787, 50306685, 5241065, 20234396,\n        ),\n        u32x8::new_const(\n            23674717, 6997172, 20771841, 16858511, 40565304, 29973136, 7049812, 14585010,\n        ),\n        u32x8::new_const(\n            1427477, 13295732, 31762066, 31499740, 60419925, 54666164, 22009424, 8089609,\n        ),\n        u32x8::new_const(\n            58154031, 41593020, 15342328, 957047, 38937260, 37037498, 24871992, 32973409,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            30654745, 51286025, 21206982, 2433562, 12780105, 31732574, 33087964, 33081189,\n        ),\n        u32x8::new_const(\n            66640017, 42720009, 16567620, 15300745, 1530367, 33001123, 20930247, 21042661,\n        ),\n        u32x8::new_const(\n            15003356, 5294119, 22985605, 18928772, 32628461, 18230172, 14773298, 27193722,\n        ),\n        u32x8::new_const(\n            27555, 65346287, 17017174, 7837720, 21499787, 42855613, 22474984, 13675085,\n        ),\n        u32x8::new_const(\n            24164369, 50130116, 5973149, 24152073, 1577334, 25400030, 18648484, 32228854,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            49518649, 59119280, 31670678, 20396561, 61728330, 651402, 176032, 9529498,\n        ),\n        u32x8::new_const(\n            61765532, 9082232, 32794568, 15526956, 48543100, 32614212, 19001206, 25680229,\n        ),\n        u32x8::new_const(\n            32086091, 10373081, 8996131, 31822823, 35788988, 49973190, 30542040, 17858455,\n        ),\n        u32x8::new_const(\n            48130197, 58121889, 27753291, 29923268, 54448075, 43300790, 9336565, 15770022,\n        ),\n        u32x8::new_const(\n            57725546, 20557498, 9366233, 16023566, 16189031, 2837363, 24315301, 27003505,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            28286608, 10767548, 18220739, 5413236, 48253387, 58255702, 11864864, 28527159,\n        ),\n        u32x8::new_const(\n            45038176, 58655197, 25648758, 10951484, 42564382, 34542843, 23146954, 22234334,\n        ),\n        u32x8::new_const(\n            14858710, 24978793, 15040559, 4379220, 47621477, 40271440, 15650420, 1998736,\n        ),\n        u32x8::new_const(\n            24106391, 9626149, 344505, 25253814, 34579800, 59687089, 25718289, 25904133,\n        ),\n        u32x8::new_const(\n            1981195, 37751302, 26132048, 1764722, 13288231, 28808622, 12531301, 18292949,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            13869851, 31448904, 14963539, 7581293, 20536485, 35021083, 21257574, 33356609,\n        ),\n        u32x8::new_const(\n            36903364, 18429241, 11097857, 5943856, 60583077, 40015815, 30509523, 31915271,\n        ),\n        u32x8::new_const(\n            49161801, 40681915, 67892, 25454357, 22779677, 25798439, 15964829, 5863227,\n        ),\n        u32x8::new_const(\n            60810637, 4496471, 5217137, 14095116, 50942411, 50712663, 2507380, 26844507,\n        ),\n        u32x8::new_const(\n            34579752, 53519385, 10859797, 18816024, 42552864, 39478521, 6783896, 17277037,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            43287109, 27900723, 33182187, 2766754, 17041989, 1018260, 33392790, 4830032,\n        ),\n        u32x8::new_const(\n            60194178, 30788903, 24728888, 14513195, 20897010, 28843233, 20111980, 17475240,\n        ),\n        u32x8::new_const(\n            46042274, 19257042, 4628173, 31649727, 27388316, 66631493, 11541886, 6408028,\n        ),\n        u32x8::new_const(\n            57024680, 49536568, 32050358, 31321917, 17437691, 49672356, 2884755, 20493991,\n        ),\n        u32x8::new_const(\n            59553007, 46782643, 29001173, 1814088, 21930692, 51319706, 14965872, 30748046,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            16441817, 36111849, 6900424, 602234, 46522199, 16441484, 8135070, 21726541,\n        ),\n        u32x8::new_const(\n            37711225, 32701959, 11679112, 13125533, 32154135, 9407918, 26554289, 620848,\n        ),\n        u32x8::new_const(\n            19233407, 30086864, 14679568, 2797374, 4892806, 7993077, 247658, 5632804,\n        ),\n        u32x8::new_const(\n            37427262, 26675495, 27125659, 13496131, 50718473, 40115609, 28505351, 27837393,\n        ),\n        u32x8::new_const(\n            196819, 18410429, 7070012, 21691388, 29763371, 24754123, 9727048, 10930179,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            28319289, 40734650, 16225680, 24739184, 64272368, 35356897, 7866648, 13635853,\n        ),\n        u32x8::new_const(\n            34165295, 48328447, 27041670, 23643655, 48949950, 52963288, 30411133, 6045174,\n        ),\n        u32x8::new_const(\n            18583559, 41649834, 9813585, 26098520, 25682734, 26733526, 19276490, 10654728,\n        ),\n        u32x8::new_const(\n            34867476, 52715968, 5694571, 13380978, 15134994, 1831255, 8608001, 17266401,\n        ),\n        u32x8::new_const(\n            59925903, 44282172, 27802465, 1855069, 14234749, 36635487, 11302294, 10938429,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            8373273, 49064494, 4932071, 32997499, 38472880, 29335908, 14504412, 22460029,\n        ),\n        u32x8::new_const(\n            31795930, 50785923, 25835990, 25790073, 65669841, 11360450, 9969157, 9008164,\n        ),\n        u32x8::new_const(\n            50262498, 45869261, 16124434, 15336007, 882762, 42522623, 11277198, 26296377,\n        ),\n        u32x8::new_const(\n            42332732, 59129236, 14452816, 567985, 208061, 34722729, 32008143, 14828749,\n        ),\n        u32x8::new_const(\n            17937794, 36846032, 32102665, 4442466, 19745435, 31633451, 7146411, 15812027,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            30741269, 38648744, 12562645, 30092623, 25073992, 28730659, 27911745, 30000958,\n        ),\n        u32x8::new_const(\n            2859794, 25991700, 17776078, 27091930, 2328322, 60061146, 18581824, 18039008,\n        ),\n        u32x8::new_const(\n            58206333, 17917354, 1972306, 11853766, 2655376, 60543390, 18416710, 13287440,\n        ),\n        u32x8::new_const(\n            62746330, 61423885, 21246577, 2266675, 60099139, 14804707, 14772234, 20679434,\n        ),\n        u32x8::new_const(\n            26987698, 15488817, 715616, 2339565, 51980752, 17333865, 21965103, 10839820,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            18672548, 57660959, 16042910, 19519287, 62865851, 17580961, 26628347, 23774759,\n        ),\n        u32x8::new_const(\n            368070, 3464471, 25888304, 30370559, 52396053, 45426828, 28745251, 9246829,\n        ),\n        u32x8::new_const(\n            29090099, 57950037, 23104657, 4903923, 10987778, 56163684, 23621539, 10332760,\n        ),\n        u32x8::new_const(\n            53338235, 44851161, 21606845, 31069622, 4243630, 34464392, 11286454, 5802022,\n        ),\n        u32x8::new_const(\n            46710757, 63389067, 11642865, 1980986, 12967337, 28162061, 3854192, 30432268,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            12179834, 41005450, 12809619, 33525228, 4624405, 46957889, 16968743, 11827816,\n        ),\n        u32x8::new_const(\n            51521162, 12466775, 31791271, 15303651, 49798465, 62714504, 6509600, 12918560,\n        ),\n        u32x8::new_const(\n            20445559, 1756449, 28848701, 7920171, 9835040, 5900071, 28757409, 12376688,\n        ),\n        u32x8::new_const(\n            18259496, 14281012, 21767026, 10232236, 20000226, 12400540, 4104902, 23570543,\n        ),\n        u32x8::new_const(\n            3687440, 26546648, 13328821, 26841081, 49822734, 22334054, 244496, 24862543,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            59523541, 62195428, 3853227, 13954801, 12387708, 47627615, 27221350, 17899572,\n        ),\n        u32x8::new_const(\n            63193587, 36343307, 14595132, 6880795, 1364792, 37648434, 3259017, 20536046,\n        ),\n        u32x8::new_const(\n            30362834, 10440372, 9574624, 11729232, 63861613, 21748389, 5530846, 2721586,\n        ),\n        u32x8::new_const(\n            18339760, 1550632, 17170271, 25732971, 28459263, 63142237, 21642345, 31557672,\n        ),\n        u32x8::new_const(\n            10611282, 5204623, 18049257, 214175, 19432723, 49809070, 26010406, 27449522,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            19770733, 26478685, 9464541, 29158041, 28604307, 45196604, 7586524, 6641859,\n        ),\n        u32x8::new_const(\n            65654484, 52230498, 30886612, 19112823, 47271809, 38942611, 16020035, 10773481,\n        ),\n        u32x8::new_const(\n            27464323, 54451016, 20646645, 17732915, 23008717, 53626684, 3253189, 15614410,\n        ),\n        u32x8::new_const(\n            52381752, 40693008, 7063024, 28469981, 51159478, 44543211, 19941777, 5985451,\n        ),\n        u32x8::new_const(\n            13553668, 35524849, 14788737, 1883845, 12385775, 47958835, 29135466, 1776722,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            36719806, 20827965, 23175373, 32996806, 42041892, 65708790, 5467143, 20884008,\n        ),\n        u32x8::new_const(\n            43256281, 40770646, 17244063, 31959819, 64366384, 43544617, 25057754, 12628720,\n        ),\n        u32x8::new_const(\n            17337782, 58472057, 27906934, 15305274, 30292418, 39284317, 16946773, 24806712,\n        ),\n        u32x8::new_const(\n            6485126, 32447403, 16261486, 13561940, 49439635, 10738368, 16419889, 8897231,\n        ),\n        u32x8::new_const(\n            44812203, 40122262, 25496058, 2759794, 25295304, 52178368, 24154195, 29334408,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            42307254, 57217102, 1088936, 3832827, 33905401, 23130334, 6958056, 12622851,\n        ),\n        u32x8::new_const(\n            3881189, 14870059, 19712830, 6071598, 38147944, 60776394, 3427938, 13765703,\n        ),\n        u32x8::new_const(\n            7666911, 24227591, 17077136, 22967588, 6874639, 30915523, 11451695, 24292224,\n        ),\n        u32x8::new_const(\n            13659529, 31984463, 28764736, 20506164, 64729627, 49321636, 28284636, 25472371,\n        ),\n        u32x8::new_const(\n            39360308, 42281399, 9446504, 868960, 49227724, 21351115, 30561851, 11292096,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            7071115, 46444090, 5387916, 15432877, 27226682, 41506862, 2398278, 3978240,\n        ),\n        u32x8::new_const(\n            51009614, 54216973, 24368938, 31392616, 38456150, 62313644, 6729154, 99724,\n        ),\n        u32x8::new_const(\n            17474332, 62857913, 2619930, 30659308, 18268181, 32809239, 22826292, 24561895,\n        ),\n        u32x8::new_const(\n            38187020, 67003092, 14118280, 16500577, 18808560, 64983716, 25712929, 32518261,\n        ),\n        u32x8::new_const(\n            25735813, 62284262, 10824872, 20558596, 48149681, 31162667, 22608274, 26285185,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            963440, 63742255, 10230323, 25515008, 32506414, 6105697, 25980317, 24645129,\n        ),\n        u32x8::new_const(\n            7162189, 8101249, 14679265, 33443386, 2002396, 8541405, 19442276, 4795881,\n        ),\n        u32x8::new_const(\n            8116694, 51463069, 4415528, 25599140, 55805721, 39582709, 6719436, 30033839,\n        ),\n        u32x8::new_const(\n            14468202, 42181869, 25188826, 9639755, 47546189, 62711146, 32762447, 18338064,\n        ),\n        u32x8::new_const(\n            33880058, 32810909, 8969931, 13095238, 38360605, 40138517, 9246134, 4928058,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            63655588, 17883670, 9410246, 26162761, 5000571, 7349225, 23785252, 32751089,\n        ),\n        u32x8::new_const(\n            28568737, 10733123, 9342397, 21570673, 54096560, 32467591, 20494687, 21511513,\n        ),\n        u32x8::new_const(\n            47675157, 47932807, 29250946, 15672208, 59760469, 9945465, 14939287, 18437405,\n        ),\n        u32x8::new_const(\n            37985267, 8609815, 31573002, 3373596, 47828883, 20834216, 13248616, 24154292,\n        ),\n        u32x8::new_const(\n            5543543, 29553242, 3386453, 30501150, 25058089, 15236571, 8814395, 32462955,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            39158670, 15322548, 20495103, 3312736, 14557171, 12985179, 8044741, 3176899,\n        ),\n        u32x8::new_const(\n            24673290, 29693310, 21412266, 18324699, 2154518, 40329021, 17500543, 3954277,\n        ),\n        u32x8::new_const(\n            36758685, 38738957, 165513, 14691866, 3070475, 10424235, 17096536, 16896898,\n        ),\n        u32x8::new_const(\n            59790459, 43094586, 8720681, 10423589, 1122030, 31545615, 4463786, 31811293,\n        ),\n        u32x8::new_const(\n            49778992, 60881044, 20509974, 5832494, 64155961, 31483358, 4511231, 20307815,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            2863373, 40876242, 26865913, 24067353, 15726407, 40919070, 12953902, 9931535,\n        ),\n        u32x8::new_const(\n            60934877, 42512204, 21649141, 21945190, 52211954, 60984193, 7046207, 5363493,\n        ),\n        u32x8::new_const(\n            4205971, 64068464, 18197273, 7327176, 51527794, 21166920, 20669933, 11828242,\n        ),\n        u32x8::new_const(\n            59782815, 49617225, 15379924, 457923, 9320508, 21498914, 3242540, 31563182,\n        ),\n        u32x8::new_const(\n            27714753, 8664670, 3366162, 26338598, 56775518, 25796006, 13129151, 21388876,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            59276548, 49972346, 16795002, 33455915, 48430097, 53857205, 18627071, 32474471,\n        ),\n        u32x8::new_const(\n            42160315, 50705892, 13530540, 28012698, 19833221, 55886870, 20191784, 9644313,\n        ),\n        u32x8::new_const(\n            20372416, 28414713, 24084234, 31804096, 33815377, 36131001, 17251241, 18291088,\n        ),\n        u32x8::new_const(\n            56234667, 14920441, 2033267, 29572003, 1724043, 45519699, 17873735, 501988,\n        ),\n        u32x8::new_const(\n            50031659, 31517850, 15697583, 1016845, 43104661, 54769582, 8008601, 27257051,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            52951491, 66542164, 14853573, 30444631, 12045973, 24321813, 16545674, 18160646,\n        ),\n        u32x8::new_const(\n            60107911, 1126003, 5947677, 19486116, 41119984, 30860440, 7935395, 13354438,\n        ),\n        u32x8::new_const(\n            17841328, 11063269, 1664538, 26687568, 6268968, 22280371, 17275484, 4523163,\n        ),\n        u32x8::new_const(\n            15886041, 56799482, 15446552, 21712778, 1005290, 17827215, 4978741, 6854882,\n        ),\n        u32x8::new_const(\n            34319277, 47731002, 20321804, 28544575, 29591814, 63376351, 24754545, 26001714,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            66783087, 5234346, 46102, 8566476, 19947339, 20180418, 25398238, 3726678,\n        ),\n        u32x8::new_const(\n            63890180, 46380965, 20674069, 5366544, 59661487, 48406612, 31533614, 7071217,\n        ),\n        u32x8::new_const(\n            13104676, 1406631, 24326736, 19854367, 61039528, 11019904, 31967425, 19219275,\n        ),\n        u32x8::new_const(\n            39003597, 30143957, 15351834, 8639435, 57309582, 61436794, 15830475, 10090318,\n        ),\n        u32x8::new_const(\n            45923044, 6700175, 99413, 21263025, 23762647, 53905481, 6063914, 10065424,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            42822326, 57678669, 4052879, 25452667, 54049411, 2373092, 22337016, 7701046,\n        ),\n        u32x8::new_const(\n            44382355, 43307377, 16761537, 30373573, 49790216, 23230748, 25655306, 10519391,\n        ),\n        u32x8::new_const(\n            919475, 59371245, 1273450, 25558666, 9724711, 8556709, 25755845, 10887647,\n        ),\n        u32x8::new_const(\n            25465699, 44651158, 17658392, 11257418, 29735193, 22885150, 7094716, 26828565,\n        ),\n        u32x8::new_const(\n            48237389, 47661599, 27054393, 7328070, 27280193, 65616691, 23062005, 4170709,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            26535281, 60238317, 30343788, 25790743, 37993933, 24614372, 9523840, 10401918,\n        ),\n        u32x8::new_const(\n            2783987, 29468958, 4697011, 19804475, 37246678, 46797720, 10261254, 18942252,\n        ),\n        u32x8::new_const(\n            58135580, 60247753, 25301938, 6844561, 20949454, 39844754, 4552026, 919057,\n        ),\n        u32x8::new_const(\n            6694071, 44126261, 32285330, 31370180, 24603698, 53328179, 13971149, 5325636,\n        ),\n        u32x8::new_const(\n            64879487, 582094, 17982081, 19190425, 24951286, 26923842, 29077174, 33286062,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            54863941, 67016431, 1224043, 23371240, 62940074, 52101083, 13523637, 30366406,\n        ),\n        u32x8::new_const(\n            36324581, 25407485, 18258623, 4698602, 50300544, 2658516, 26300935, 2611030,\n        ),\n        u32x8::new_const(\n            27183975, 21791014, 18105064, 9875199, 58118912, 54198635, 6400311, 14767984,\n        ),\n        u32x8::new_const(\n            33918318, 42937962, 14809334, 22136592, 10636588, 29082337, 29829692, 28549776,\n        ),\n        u32x8::new_const(\n            61080905, 854212, 12202487, 20004503, 9256495, 6903981, 20567109, 347423,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            41391822, 34336880, 22362564, 14247996, 12115604, 41583344, 7639288, 28910945,\n        ),\n        u32x8::new_const(\n            62066617, 59758859, 26665947, 11614812, 65737664, 45704543, 30324810, 12868376,\n        ),\n        u32x8::new_const(\n            17491771, 43589814, 9454919, 26047850, 52629282, 39304244, 3868968, 19296062,\n        ),\n        u32x8::new_const(\n            17826638, 30413590, 32534225, 32741469, 15012391, 14365713, 33039233, 14791399,\n        ),\n        u32x8::new_const(\n            64115596, 59197067, 32739005, 23275744, 32954320, 22241406, 20788442, 4942942,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            31956192, 59570132, 2784352, 4237732, 47222312, 4860927, 18658867, 15279314,\n        ),\n        u32x8::new_const(\n            63240583, 28160478, 23524941, 13390861, 66437406, 57718120, 33345312, 28896298,\n        ),\n        u32x8::new_const(\n            39026193, 46239965, 21440243, 25070488, 64012383, 60999016, 16517060, 29565907,\n        ),\n        u32x8::new_const(\n            18118181, 60161496, 4212092, 23976240, 36277753, 62363144, 5816868, 16964362,\n        ),\n        u32x8::new_const(\n            18196138, 62490693, 281468, 7934713, 56027312, 62015725, 4837237, 32932252,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            29885826, 51028067, 30418143, 33438769, 62542283, 39442528, 31535876, 143299,\n        ),\n        u32x8::new_const(\n            17143063, 56709783, 14451852, 15782104, 32762665, 14047066, 26295037, 5432487,\n        ),\n        u32x8::new_const(\n            75151, 533606, 7539077, 30926189, 38410914, 23771680, 4872443, 29199566,\n        ),\n        u32x8::new_const(\n            61522396, 48934708, 16223126, 207380, 11171993, 47975147, 14164574, 352966,\n        ),\n        u32x8::new_const(\n            15449006, 56530757, 26796528, 12045834, 63738697, 40667227, 33001582, 9101885,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            43331297, 18431341, 25801195, 17267698, 19365485, 57295202, 22218985, 21284590,\n        ),\n        u32x8::new_const(\n            2429849, 19152559, 10762172, 22564684, 21880390, 66866426, 20357935, 22641906,\n        ),\n        u32x8::new_const(\n            19771185, 31652693, 3666117, 28136958, 23624283, 55101502, 6313920, 6783662,\n        ),\n        u32x8::new_const(\n            3487137, 7092443, 11001876, 26196524, 47319246, 44542068, 17594073, 15027760,\n        ),\n        u32x8::new_const(\n            49563607, 32191113, 4991283, 25400512, 46539152, 4155103, 32368171, 201203,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            20548943, 14334571, 4073874, 6368588, 53208883, 56484515, 15970071, 25561889,\n        ),\n        u32x8::new_const(\n            49915097, 44030795, 11202344, 29284344, 60258023, 66225712, 8075764, 12383512,\n        ),\n        u32x8::new_const(\n            45248912, 4933668, 9592153, 5819559, 31030983, 38174071, 32435814, 7442522,\n        ),\n        u32x8::new_const(\n            62688129, 48218381, 22089545, 12897361, 21050881, 34278889, 7569163, 3225449,\n        ),\n        u32x8::new_const(\n            19050183, 51089071, 32935757, 22640195, 66122318, 47144608, 18743677, 25177079,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            41186817, 46681702, 31819867, 32997133, 38559207, 27147015, 30293819, 16762988,\n        ),\n        u32x8::new_const(\n            24154689, 51762873, 23883879, 13510519, 55338250, 61224161, 11663149, 30803960,\n        ),\n        u32x8::new_const(\n            18104238, 14117824, 11724021, 21362053, 65704761, 35530242, 13498058, 33522849,\n        ),\n        u32x8::new_const(\n            63812888, 23995539, 28920539, 24005193, 26412223, 36582218, 4251418, 26160309,\n        ),\n        u32x8::new_const(\n            16822053, 66064082, 3482145, 31979593, 45937188, 54475379, 612917, 7976478,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            46509314, 55327128, 8944536, 274914, 26432930, 53829300, 21192572, 3569894,\n        ),\n        u32x8::new_const(\n            20919764, 64356651, 30642344, 17215170, 20335124, 11203745, 18663316, 19024174,\n        ),\n        u32x8::new_const(\n            59297055, 53842463, 3680204, 9806710, 54004169, 51484914, 29807998, 20134199,\n        ),\n        u32x8::new_const(\n            14781592, 22628010, 26877930, 25880359, 30434803, 190607, 30184292, 8991040,\n        ),\n        u32x8::new_const(\n            64400983, 64591751, 854562, 28216111, 20010398, 50414793, 9803872, 22687008,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            15091184, 32550863, 8818643, 4244752, 43123513, 64565526, 408838, 13206998,\n        ),\n        u32x8::new_const(\n            16405061, 60379639, 31489017, 20949281, 27568751, 38734986, 8364264, 12451020,\n        ),\n        u32x8::new_const(\n            16005217, 58008076, 1406778, 26546927, 39571784, 56365493, 31274296, 8918790,\n        ),\n        u32x8::new_const(\n            23271122, 19453469, 27718201, 32742670, 234332, 36785342, 22601675, 14331046,\n        ),\n        u32x8::new_const(\n            40636025, 22442705, 22115403, 23745859, 41164945, 61012, 12499614, 542137,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            62776018, 32835413, 17373246, 17187309, 54469193, 21770290, 15923753, 28996575,\n        ),\n        u32x8::new_const(\n            59385210, 63082298, 12568449, 8509004, 9483342, 16105238, 5756054, 26890758,\n        ),\n        u32x8::new_const(\n            53987996, 38201748, 5521661, 19060159, 18663191, 9093637, 27786835, 31189196,\n        ),\n        u32x8::new_const(\n            65872678, 43635130, 27903055, 25020300, 65772737, 38110437, 5213502, 21909342,\n        ),\n        u32x8::new_const(\n            4438979, 9680838, 10212446, 4764184, 13235684, 58245995, 20264570, 21024049,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            60835961, 48209103, 31049052, 4688268, 12426713, 59829045, 22302488, 29008521,\n        ),\n        u32x8::new_const(\n            50401667, 29716596, 23531224, 7581281, 49071895, 6952617, 14934683, 8218256,\n        ),\n        u32x8::new_const(\n            1601446, 36631413, 31774811, 29625330, 56786114, 8331539, 23129509, 19783344,\n        ),\n        u32x8::new_const(\n            59514327, 64513110, 1772300, 5701338, 5737511, 16147555, 9461515, 5703271,\n        ),\n        u32x8::new_const(\n            33072974, 54300426, 11940114, 1308663, 15627555, 4931627, 28443714, 20924342,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            18135013, 20358426, 4922557, 10015355, 65729669, 34786528, 26248549, 29194359,\n        ),\n        u32x8::new_const(\n            797666, 34997544, 24316856, 25107230, 24612576, 4761401, 15307321, 32404252,\n        ),\n        u32x8::new_const(\n            16501152, 60565831, 9487105, 9316022, 24986054, 31917592, 3962024, 2501883,\n        ),\n        u32x8::new_const(\n            63356796, 50432342, 18044926, 30566881, 42032028, 31415202, 13524600, 16119907,\n        ),\n        u32x8::new_const(\n            3927286, 57022374, 9265437, 21620772, 19481940, 3806938, 24836192, 14572399,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            10785787, 46564798, 368445, 33181384, 5319843, 52687136, 30347110, 29837357,\n        ),\n        u32x8::new_const(\n            56436732, 47859251, 24141084, 22250712, 59046084, 4963427, 33463413, 17168859,\n        ),\n        u32x8::new_const(\n            15512044, 6366740, 4737504, 27644548, 30307977, 25037929, 14593903, 12836490,\n        ),\n        u32x8::new_const(\n            63878897, 34013023, 5860752, 7244096, 3689461, 57012135, 18389096, 11589351,\n        ),\n        u32x8::new_const(\n            4682110, 36302830, 653422, 22316819, 14081831, 5657024, 11088376, 24110612,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            39907267, 45940262, 24887471, 18342609, 878445, 40456159, 12019082, 345107,\n        ),\n        u32x8::new_const(\n            12794982, 28893944, 9447505, 11387200, 16961963, 13916996, 10893728, 25898006,\n        ),\n        u32x8::new_const(\n            44934162, 53465865, 3583620, 1102334, 53917811, 63478576, 2426066, 10389549,\n        ),\n        u32x8::new_const(\n            45096036, 37595344, 19367718, 20257175, 10280866, 41653449, 27665642, 375926,\n        ),\n        u32x8::new_const(\n            45847901, 24064074, 32494820, 32204556, 10720704, 51079060, 1297436, 29853825,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            66303987, 36060363, 16494578, 24962147, 11971403, 49538586, 25060560, 1964341,\n        ),\n        u32x8::new_const(\n            25988481, 27641502, 24909517, 27237087, 66646363, 52777626, 16360849, 10459972,\n        ),\n        u32x8::new_const(\n            43930529, 34374176, 31225968, 8807030, 10394758, 35904854, 25325589, 19335583,\n        ),\n        u32x8::new_const(\n            25094697, 34380951, 20051185, 32287161, 11739332, 53887441, 30517319, 26601892,\n        ),\n        u32x8::new_const(\n            8868546, 35635502, 32513071, 28248087, 51946989, 14222744, 19198839, 23261841,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            51218008, 5070126, 11046681, 5320810, 61212079, 34104447, 23895089, 6460727,\n        ),\n        u32x8::new_const(\n            39843528, 46278671, 10426120, 25624792, 66658766, 37140083, 28933107, 12969597,\n        ),\n        u32x8::new_const(\n            59635793, 40220191, 5751421, 173680, 58321825, 740337, 1412847, 7682623,\n        ),\n        u32x8::new_const(\n            975962, 56440763, 20812276, 22631115, 49095824, 19883130, 2419746, 31043648,\n        ),\n        u32x8::new_const(\n            66208703, 39669328, 22525915, 3748897, 65994776, 34533552, 8126286, 18326047,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            64176557, 3912400, 19351673, 30068471, 31190055, 24221683, 33142424, 28698542,\n        ),\n        u32x8::new_const(\n            34784792, 4109933, 3867193, 19557314, 2112512, 32715890, 24550117, 16595976,\n        ),\n        u32x8::new_const(\n            35542761, 48024875, 10925431, 31526577, 66577735, 23189821, 13375709, 1735095,\n        ),\n        u32x8::new_const(\n            59699254, 43854093, 29783239, 24777271, 19600372, 39924461, 2896720, 1472185,\n        ),\n        u32x8::new_const(\n            56389656, 35980854, 33172342, 1370336, 23707480, 57654949, 7850973, 12655016,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            38372660, 57101970, 7044964, 12732710, 57535705, 6043201, 30858914, 10946592,\n        ),\n        u32x8::new_const(\n            21023468, 6946992, 26403324, 23901823, 35695559, 23440687, 4763891, 6514074,\n        ),\n        u32x8::new_const(\n            28662273, 30933699, 9352242, 26354829, 37402243, 3145176, 8770289, 525937,\n        ),\n        u32x8::new_const(\n            54933102, 36695832, 3281859, 4755022, 23043294, 32794379, 15618886, 23602412,\n        ),\n        u32x8::new_const(\n            9931565, 29897140, 2480737, 24193701, 7833615, 2284939, 893926, 13421882,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            22917795, 22088359, 28978099, 19794863, 60542318, 29878494, 31053731, 9080720,\n        ),\n        u32x8::new_const(\n            23679072, 52547035, 28424916, 20647332, 4008761, 28267029, 12961289, 1589095,\n        ),\n        u32x8::new_const(\n            55616194, 26678929, 14998265, 23274397, 54625466, 46244264, 28627706, 33030665,\n        ),\n        u32x8::new_const(\n            11527330, 6449415, 26531607, 3472938, 41541592, 62607682, 19862690, 20564723,\n        ),\n        u32x8::new_const(\n            32843805, 49066843, 28425824, 19521495, 48792073, 48242878, 27392443, 13175986,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            16185025, 61537525, 2961305, 1492442, 25123147, 3095034, 31896958, 33089615,\n        ),\n        u32x8::new_const(\n            64748157, 18336595, 16522231, 25426312, 65718949, 35485695, 30554083, 10205918,\n        ),\n        u32x8::new_const(\n            39626934, 39271045, 16420458, 9826240, 56483981, 27128085, 3783403, 13360006,\n        ),\n        u32x8::new_const(\n            30793778, 66771960, 17241420, 6564573, 61102581, 29974476, 32385512, 9011754,\n        ),\n        u32x8::new_const(\n            28068166, 11862220, 14323567, 12380617, 52090465, 16029056, 24495309, 21409233,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            59411973, 57437124, 11695483, 17586857, 16108987, 43449109, 31098002, 6248476,\n        ),\n        u32x8::new_const(\n            42258047, 61595931, 29308533, 11742653, 43042345, 27373650, 30165249, 21929989,\n        ),\n        u32x8::new_const(\n            49907221, 9620337, 21888081, 20981082, 56288861, 61562203, 33223566, 3582446,\n        ),\n        u32x8::new_const(\n            57535017, 41003416, 22080416, 14463796, 65518565, 18127889, 24370863, 33332664,\n        ),\n        u32x8::new_const(\n            66655380, 6430175, 471782, 11947673, 30596400, 18898659, 15930721, 4211851,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            6757410, 65455566, 13584784, 11362173, 10797127, 24451471, 19541370, 29309435,\n        ),\n        u32x8::new_const(\n            40360156, 17685025, 18326181, 3846903, 13693365, 63049479, 31900359, 23385063,\n        ),\n        u32x8::new_const(\n            52455038, 57513503, 22163311, 27095042, 48610726, 66454160, 12085341, 26357004,\n        ),\n        u32x8::new_const(\n            22097042, 14063840, 6705778, 14342902, 66139825, 20702105, 31279090, 7495745,\n        ),\n        u32x8::new_const(\n            27360710, 49314837, 18774847, 7146436, 37066216, 42004961, 22409916, 10524446,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            1497507, 33054449, 11839906, 2960428, 40538463, 18884538, 25018820, 4073970,\n        ),\n        u32x8::new_const(\n            54484385, 43640735, 2808257, 20710708, 39840730, 27222424, 21783544, 11848522,\n        ),\n        u32x8::new_const(\n            45765237, 48200555, 9299019, 9393151, 34818188, 56098995, 13575233, 21012731,\n        ),\n        u32x8::new_const(\n            4265428, 49627650, 24960282, 9425650, 47883651, 2797524, 11853190, 22877329,\n        ),\n        u32x8::new_const(\n            25008173, 64199503, 380047, 12107343, 12329448, 11914399, 764281, 29687002,\n        ),\n    ])),\n    CachedPoint(FieldElement2625x4([\n        u32x8::new_const(\n            35889734, 23047226, 4022841, 7017445, 7274086, 53316179, 25100176, 15310676,\n        ),\n        u32x8::new_const(\n            42409427, 30270106, 6823853, 31551384, 40645017, 66489807, 18021817, 32669351,\n        ),\n        u32x8::new_const(\n            39827134, 43680850, 28297996, 20258133, 26058742, 52643238, 22238331, 21690533,\n        ),\n        u32x8::new_const(\n            60808002, 17499995, 30042246, 29310584, 48219954, 29389518, 8680514, 17844709,\n        ),\n        u32x8::new_const(\n            6452896, 50116553, 9532047, 26821214, 44524351, 50428429, 21904953, 12608048,\n        ),\n    ])),\n]);\n",
    "filename": "curve25519-dalek/src/backend/vector/avx2/constants.rs",
    "filepath": null,
    "folder_id": 15831,
    "user_id": 460154
  },
  "63600": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n#![doc = include_str!(\"../../../../docs/avx2-notes.md\")]\n\npub(crate) mod field;\n\npub(crate) mod edwards;\n\npub(crate) mod constants;\n\npub(crate) use self::edwards::{CachedPoint, ExtendedPoint};\n",
    "filename": "curve25519-dalek/src/backend/vector/avx2/mod.rs",
    "filepath": null,
    "folder_id": 15831,
    "user_id": 460154
  },
  "63601": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2018-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n#![allow(non_snake_case)]\n\nuse crate::traits::Identity;\n\nuse core::ops::{Add, Neg, Sub};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\nuse curve25519_dalek_derive::unsafe_target_feature;\n\nuse crate::edwards;\nuse crate::window::{LookupTable, NafLookupTable5};\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nuse crate::window::NafLookupTable8;\n\nuse super::constants;\nuse super::field::{F51x4Reduced, F51x4Unreduced, Lanes, Shuffle};\n\n#[derive(Copy, Clone, Debug)]\npub struct ExtendedPoint(pub(super) F51x4Unreduced);\n\n#[derive(Copy, Clone, Debug)]\npub struct CachedPoint(pub(super) F51x4Reduced);\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl From<edwards::EdwardsPoint> for ExtendedPoint {\n    fn from(P: edwards::EdwardsPoint) -> ExtendedPoint {\n        ExtendedPoint(F51x4Unreduced::new(&P.X, &P.Y, &P.Z, &P.T))\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl From<ExtendedPoint> for edwards::EdwardsPoint {\n    fn from(P: ExtendedPoint) -> edwards::EdwardsPoint {\n        let reduced = F51x4Reduced::from(P.0);\n        let tmp = F51x4Unreduced::from(reduced).split();\n        edwards::EdwardsPoint {\n            X: tmp[0],\n            Y: tmp[1],\n            Z: tmp[2],\n            T: tmp[3],\n        }\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl From<ExtendedPoint> for CachedPoint {\n    fn from(P: ExtendedPoint) -> CachedPoint {\n        let mut x = P.0;\n\n        x = x.blend(&x.diff_sum(), Lanes::AB);\n        x = &F51x4Reduced::from(x) * (121666, 121666, 2 * 121666, 2 * 121665);\n        x = x.blend(&x.negate_lazy(), Lanes::D);\n\n        CachedPoint(F51x4Reduced::from(x))\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl Default for ExtendedPoint {\n    fn default() -> ExtendedPoint {\n        ExtendedPoint::identity()\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl Identity for ExtendedPoint {\n    fn identity() -> ExtendedPoint {\n        constants::EXTENDEDPOINT_IDENTITY\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl ExtendedPoint {\n    pub fn double(&self) -> ExtendedPoint {\n        // (Y1 X1 T1 Z1) -- uses vpshufd (1c latency @ 1/c)\n        let mut tmp0 = self.0.shuffle(Shuffle::BADC);\n\n        // (X1+Y1 X1+Y1 X1+Y1 X1+Y1) -- can use vpinserti128\n        let mut tmp1 = (self.0 + tmp0).shuffle(Shuffle::ABAB);\n\n        // (X1 Y1 Z1 X1+Y1)\n        tmp0 = self.0.blend(&tmp1, Lanes::D);\n\n        tmp1 = F51x4Reduced::from(tmp0).square();\n        // Now tmp1 = (S1 S2 S3 S4)\n\n        // We want to compute\n        //\n        //    + | S1 | S1 | S1 | S1 |\n        //    + | S2 |    |    | S2 |\n        //    + |    |    | S3 |    |\n        //    + |    |    | S3 |    |\n        //    + |    |16p |16p |16p |\n        //    - |    | S2 | S2 |    |\n        //    - |    |    |    | S4 |\n        //    =======================\n        //        S5   S6   S8   S9\n\n        let zero = F51x4Unreduced::ZERO;\n\n        let S1_S1_S1_S1 = tmp1.shuffle(Shuffle::AAAA);\n        let S2_S2_S2_S2 = tmp1.shuffle(Shuffle::BBBB);\n\n        let S2_S2_S2_S4 = S2_S2_S2_S2.blend(&tmp1, Lanes::D).negate_lazy();\n\n        tmp0 = S1_S1_S1_S1 + zero.blend(&(tmp1 + tmp1), Lanes::C);\n        tmp0 = tmp0 + zero.blend(&S2_S2_S2_S2, Lanes::AD);\n        tmp0 = tmp0 + zero.blend(&S2_S2_S2_S4, Lanes::BCD);\n\n        let tmp2 = F51x4Reduced::from(tmp0);\n\n        ExtendedPoint(&tmp2.shuffle(Shuffle::DBBD) * &tmp2.shuffle(Shuffle::CACA))\n    }\n\n    pub fn mul_by_pow_2(&self, k: u32) -> ExtendedPoint {\n        let mut tmp: ExtendedPoint = *self;\n        for _ in 0..k {\n            tmp = tmp.double();\n        }\n        tmp\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl<'a, 'b> Add<&'b CachedPoint> for &'a ExtendedPoint {\n    type Output = ExtendedPoint;\n\n    /// Add an `ExtendedPoint` and a `CachedPoint`.\n    fn add(self, other: &'b CachedPoint) -> ExtendedPoint {\n        let mut tmp = self.0;\n\n        tmp = tmp.blend(&tmp.diff_sum(), Lanes::AB);\n        // tmp = (Y1-X1 Y1+X1 Z1 T1) = (S0 S1 Z1 T1)\n\n        tmp = &F51x4Reduced::from(tmp) * &other.0;\n        // tmp = (S0*S2' S1*S3' Z1*Z2' T1*T2') = (S8 S9 S10 S11)\n\n        tmp = tmp.shuffle(Shuffle::ABDC);\n        // tmp = (S8 S9 S11 S10)\n\n        let tmp = F51x4Reduced::from(tmp.diff_sum());\n        // tmp = (S9-S8 S9+S8 S10-S11 S10+S11) = (S12 S13 S14 S15)\n\n        let t0 = tmp.shuffle(Shuffle::ADDA);\n        // t0 = (S12 S15 S15 S12)\n        let t1 = tmp.shuffle(Shuffle::CBCB);\n        // t1 = (S14 S13 S14 S13)\n\n        // Return (S12*S14 S15*S13 S15*S14 S12*S13) = (X3 Y3 Z3 T3)\n        ExtendedPoint(&t0 * &t1)\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl Default for CachedPoint {\n    fn default() -> CachedPoint {\n        CachedPoint::identity()\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl Identity for CachedPoint {\n    fn identity() -> CachedPoint {\n        constants::CACHEDPOINT_IDENTITY\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl ConditionallySelectable for CachedPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        CachedPoint(F51x4Reduced::conditional_select(&a.0, &b.0, choice))\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.0.conditional_assign(&other.0, choice);\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl<'a> Neg for &'a CachedPoint {\n    type Output = CachedPoint;\n\n    fn neg(self) -> CachedPoint {\n        let swapped = self.0.shuffle(Shuffle::BACD);\n        CachedPoint(swapped.blend(&(-self.0), Lanes::D))\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl<'a, 'b> Sub<&'b CachedPoint> for &'a ExtendedPoint {\n    type Output = ExtendedPoint;\n\n    /// Implement subtraction by negating the point and adding.\n    fn sub(self, other: &'b CachedPoint) -> ExtendedPoint {\n        self + &(-other)\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl<'a> From<&'a edwards::EdwardsPoint> for LookupTable<CachedPoint> {\n    fn from(point: &'a edwards::EdwardsPoint) -> Self {\n        let P = ExtendedPoint::from(*point);\n        let mut points = [CachedPoint::from(P); 8];\n        for i in 0..7 {\n            points[i + 1] = (&P + &points[i]).into();\n        }\n        LookupTable(points)\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl<'a> From<&'a edwards::EdwardsPoint> for NafLookupTable5<CachedPoint> {\n    fn from(point: &'a edwards::EdwardsPoint) -> Self {\n        let A = ExtendedPoint::from(*point);\n        let mut Ai = [CachedPoint::from(A); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).into();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl<'a> From<&'a edwards::EdwardsPoint> for NafLookupTable8<CachedPoint> {\n    fn from(point: &'a edwards::EdwardsPoint) -> Self {\n        let A = ExtendedPoint::from(*point);\n        let mut Ai = [CachedPoint::from(A); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).into();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }\n}\n\n#[cfg(all(target_feature = \"avx512ifma\", target_feature = \"avx512vl\"))]\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    fn addition_test_helper(P: edwards::EdwardsPoint, Q: edwards::EdwardsPoint) {\n        // Test the serial implementation of the parallel addition formulas\n        //let R_serial: edwards::EdwardsPoint = serial_add(P.into(), Q.into()).into();\n\n        // Test the vector implementation of the parallel readdition formulas\n        let cached_Q = CachedPoint::from(ExtendedPoint::from(Q));\n        let R_vector: edwards::EdwardsPoint = (&ExtendedPoint::from(P) + &cached_Q).into();\n        let S_vector: edwards::EdwardsPoint = (&ExtendedPoint::from(P) - &cached_Q).into();\n\n        println!(\"Testing point addition:\");\n        println!(\"P = {:?}\", P);\n        println!(\"Q = {:?}\", Q);\n        println!(\"cached Q = {:?}\", cached_Q);\n        println!(\"R = P + Q = {:?}\", &P + &Q);\n        //println!(\"R_serial = {:?}\", R_serial);\n        println!(\"R_vector = {:?}\", R_vector);\n        println!(\"S = P - Q = {:?}\", &P - &Q);\n        println!(\"S_vector = {:?}\", S_vector);\n        //assert_eq!(R_serial.compress(), (&P + &Q).compress());\n        assert_eq!(R_vector.compress(), (&P + &Q).compress());\n        assert_eq!(S_vector.compress(), (&P - &Q).compress());\n        println!(\"OK!\\n\");\n    }\n\n    #[test]\n    fn vector_addition_vs_serial_addition_vs_edwards_extendedpoint() {\n        use crate::constants;\n        use crate::scalar::Scalar;\n\n        println!(\"Testing id +- id\");\n        let P = edwards::EdwardsPoint::identity();\n        let Q = edwards::EdwardsPoint::identity();\n        addition_test_helper(P, Q);\n\n        println!(\"Testing id +- B\");\n        let P = edwards::EdwardsPoint::identity();\n        let Q = constants::ED25519_BASEPOINT_POINT;\n        addition_test_helper(P, Q);\n\n        println!(\"Testing B +- B\");\n        let P = constants::ED25519_BASEPOINT_POINT;\n        let Q = constants::ED25519_BASEPOINT_POINT;\n        addition_test_helper(P, Q);\n\n        println!(\"Testing B +- kB\");\n        let P = constants::ED25519_BASEPOINT_POINT;\n        let Q = constants::ED25519_BASEPOINT_TABLE * &Scalar::from(8475983829u64);\n        addition_test_helper(P, Q);\n    }\n\n    fn doubling_test_helper(P: edwards::EdwardsPoint) {\n        //let R1: edwards::EdwardsPoint = serial_double(P.into()).into();\n        let R2: edwards::EdwardsPoint = ExtendedPoint::from(P).double().into();\n        println!(\"Testing point doubling:\");\n        println!(\"P = {:?}\", P);\n        //println!(\"(serial) R1 = {:?}\", R1);\n        println!(\"(vector) R2 = {:?}\", R2);\n        println!(\"P + P = {:?}\", &P + &P);\n        //assert_eq!(R1.compress(), (&P + &P).compress());\n        assert_eq!(R2.compress(), (&P + &P).compress());\n        println!(\"OK!\\n\");\n    }\n\n    #[test]\n    fn vector_doubling_vs_serial_doubling_vs_edwards_extendedpoint() {\n        use crate::constants;\n        use crate::scalar::Scalar;\n\n        println!(\"Testing [2]id\");\n        let P = edwards::EdwardsPoint::identity();\n        doubling_test_helper(P);\n\n        println!(\"Testing [2]B\");\n        let P = constants::ED25519_BASEPOINT_POINT;\n        doubling_test_helper(P);\n\n        println!(\"Testing [2]([k]B)\");\n        let P = constants::ED25519_BASEPOINT_TABLE * &Scalar::from(8475983829u64);\n        doubling_test_helper(P);\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/ifma/edwards.rs",
    "filepath": null,
    "folder_id": 15832,
    "user_id": 460154
  },
  "63602": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n// Nightly and stable currently disagree on the requirement of unsafe blocks when `unsafe_target_feature`\n// gets used.\n// See: https://github.com/rust-lang/rust/issues/132856\n#![allow(unused_unsafe)]\n#![allow(non_snake_case)]\n\nuse crate::backend::vector::packed_simd::u64x4;\nuse core::ops::{Add, Mul, Neg};\n\nuse crate::backend::serial::u64::field::FieldElement51;\n\nuse curve25519_dalek_derive::unsafe_target_feature;\n\n/// A wrapper around `vpmadd52luq` that works on `u64x4`.\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\n#[inline]\nunsafe fn madd52lo(z: u64x4, x: u64x4, y: u64x4) -> u64x4 {\n    use core::arch::x86_64::_mm256_madd52lo_epu64;\n    _mm256_madd52lo_epu64(z.into(), x.into(), y.into()).into()\n}\n\n/// A wrapper around `vpmadd52huq` that works on `u64x4`.\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\n#[inline]\nunsafe fn madd52hi(z: u64x4, x: u64x4, y: u64x4) -> u64x4 {\n    use core::arch::x86_64::_mm256_madd52hi_epu64;\n    _mm256_madd52hi_epu64(z.into(), x.into(), y.into()).into()\n}\n\n/// A vector of four field elements in radix 2^51, with unreduced coefficients.\n#[derive(Copy, Clone, Debug)]\npub struct F51x4Unreduced(pub(crate) [u64x4; 5]);\n\n/// A vector of four field elements in radix 2^51, with reduced coefficients.\n#[derive(Copy, Clone, Debug)]\npub struct F51x4Reduced(pub(crate) [u64x4; 5]);\n\n#[allow(clippy::upper_case_acronyms)]\n#[derive(Copy, Clone)]\npub enum Shuffle {\n    AAAA,\n    BBBB,\n    BADC,\n    BACD,\n    ADDA,\n    CBCB,\n    ABDC,\n    ABAB,\n    DBBD,\n    CACA,\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\n#[inline(always)]\nfn shuffle_lanes(x: u64x4, control: Shuffle) -> u64x4 {\n    unsafe {\n        use core::arch::x86_64::_mm256_permute4x64_epi64 as perm;\n\n        match control {\n            Shuffle::AAAA => perm(x.into(), 0b00_00_00_00).into(),\n            Shuffle::BBBB => perm(x.into(), 0b01_01_01_01).into(),\n            Shuffle::BADC => perm(x.into(), 0b10_11_00_01).into(),\n            Shuffle::BACD => perm(x.into(), 0b11_10_00_01).into(),\n            Shuffle::ADDA => perm(x.into(), 0b00_11_11_00).into(),\n            Shuffle::CBCB => perm(x.into(), 0b01_10_01_10).into(),\n            Shuffle::ABDC => perm(x.into(), 0b10_11_01_00).into(),\n            Shuffle::ABAB => perm(x.into(), 0b01_00_01_00).into(),\n            Shuffle::DBBD => perm(x.into(), 0b11_01_01_11).into(),\n            Shuffle::CACA => perm(x.into(), 0b00_10_00_10).into(),\n        }\n    }\n}\n\n#[allow(clippy::upper_case_acronyms)]\n#[derive(Copy, Clone)]\npub enum Lanes {\n    D,\n    C,\n    AB,\n    AC,\n    AD,\n    BCD,\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\n#[inline]\nfn blend_lanes(x: u64x4, y: u64x4, control: Lanes) -> u64x4 {\n    unsafe {\n        use core::arch::x86_64::_mm256_blend_epi32 as blend;\n\n        match control {\n            Lanes::D => blend(x.into(), y.into(), 0b11_00_00_00).into(),\n            Lanes::C => blend(x.into(), y.into(), 0b00_11_00_00).into(),\n            Lanes::AB => blend(x.into(), y.into(), 0b00_00_11_11).into(),\n            Lanes::AC => blend(x.into(), y.into(), 0b00_11_00_11).into(),\n            Lanes::AD => blend(x.into(), y.into(), 0b11_00_00_11).into(),\n            Lanes::BCD => blend(x.into(), y.into(), 0b11_11_11_00).into(),\n        }\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl F51x4Unreduced {\n    pub const ZERO: F51x4Unreduced = F51x4Unreduced([u64x4::splat_const::<0>(); 5]);\n\n    pub fn new(\n        x0: &FieldElement51,\n        x1: &FieldElement51,\n        x2: &FieldElement51,\n        x3: &FieldElement51,\n    ) -> F51x4Unreduced {\n        F51x4Unreduced([\n            u64x4::new(x0.0[0], x1.0[0], x2.0[0], x3.0[0]),\n            u64x4::new(x0.0[1], x1.0[1], x2.0[1], x3.0[1]),\n            u64x4::new(x0.0[2], x1.0[2], x2.0[2], x3.0[2]),\n            u64x4::new(x0.0[3], x1.0[3], x2.0[3], x3.0[3]),\n            u64x4::new(x0.0[4], x1.0[4], x2.0[4], x3.0[4]),\n        ])\n    }\n\n    pub fn split(&self) -> [FieldElement51; 4] {\n        let x = &self.0;\n        [\n            FieldElement51([\n                x[0].extract::<0>(),\n                x[1].extract::<0>(),\n                x[2].extract::<0>(),\n                x[3].extract::<0>(),\n                x[4].extract::<0>(),\n            ]),\n            FieldElement51([\n                x[0].extract::<1>(),\n                x[1].extract::<1>(),\n                x[2].extract::<1>(),\n                x[3].extract::<1>(),\n                x[4].extract::<1>(),\n            ]),\n            FieldElement51([\n                x[0].extract::<2>(),\n                x[1].extract::<2>(),\n                x[2].extract::<2>(),\n                x[3].extract::<2>(),\n                x[4].extract::<2>(),\n            ]),\n            FieldElement51([\n                x[0].extract::<3>(),\n                x[1].extract::<3>(),\n                x[2].extract::<3>(),\n                x[3].extract::<3>(),\n                x[4].extract::<3>(),\n            ]),\n        ]\n    }\n\n    #[inline]\n    pub fn diff_sum(&self) -> F51x4Unreduced {\n        // tmp1 = (B, A, D, C)\n        let tmp1 = self.shuffle(Shuffle::BADC);\n        // tmp2 = (-A, B, -C, D)\n        let tmp2 = self.blend(&self.negate_lazy(), Lanes::AC);\n        // (B - A, B + A, D - C, D + C)\n        tmp1 + tmp2\n    }\n\n    #[inline]\n    pub fn negate_lazy(&self) -> F51x4Unreduced {\n        let lo = u64x4::splat(36028797018963664u64);\n        let hi = u64x4::splat(36028797018963952u64);\n        F51x4Unreduced([\n            lo - self.0[0],\n            hi - self.0[1],\n            hi - self.0[2],\n            hi - self.0[3],\n            hi - self.0[4],\n        ])\n    }\n\n    #[inline]\n    pub fn shuffle(&self, control: Shuffle) -> F51x4Unreduced {\n        F51x4Unreduced([\n            shuffle_lanes(self.0[0], control),\n            shuffle_lanes(self.0[1], control),\n            shuffle_lanes(self.0[2], control),\n            shuffle_lanes(self.0[3], control),\n            shuffle_lanes(self.0[4], control),\n        ])\n    }\n\n    #[inline]\n    pub fn blend(&self, other: &F51x4Unreduced, control: Lanes) -> F51x4Unreduced {\n        F51x4Unreduced([\n            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl Neg for F51x4Reduced {\n    type Output = F51x4Reduced;\n\n    fn neg(self) -> F51x4Reduced {\n        F51x4Unreduced::from(self).negate_lazy().into()\n    }\n}\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl ConditionallySelectable for F51x4Reduced {\n    #[inline]\n    fn conditional_select(a: &F51x4Reduced, b: &F51x4Reduced, choice: Choice) -> F51x4Reduced {\n        let mask = (-(choice.unwrap_u8() as i64)) as u64;\n        let mask_vec = u64x4::splat(mask);\n        F51x4Reduced([\n            a.0[0] ^ (mask_vec & (a.0[0] ^ b.0[0])),\n            a.0[1] ^ (mask_vec & (a.0[1] ^ b.0[1])),\n            a.0[2] ^ (mask_vec & (a.0[2] ^ b.0[2])),\n            a.0[3] ^ (mask_vec & (a.0[3] ^ b.0[3])),\n            a.0[4] ^ (mask_vec & (a.0[4] ^ b.0[4])),\n        ])\n    }\n\n    #[inline]\n    fn conditional_assign(&mut self, other: &F51x4Reduced, choice: Choice) {\n        let mask = (-(choice.unwrap_u8() as i64)) as u64;\n        let mask_vec = u64x4::splat(mask);\n        self.0[0] ^= mask_vec & (self.0[0] ^ other.0[0]);\n        self.0[1] ^= mask_vec & (self.0[1] ^ other.0[1]);\n        self.0[2] ^= mask_vec & (self.0[2] ^ other.0[2]);\n        self.0[3] ^= mask_vec & (self.0[3] ^ other.0[3]);\n        self.0[4] ^= mask_vec & (self.0[4] ^ other.0[4]);\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl F51x4Reduced {\n    #[inline]\n    pub fn shuffle(&self, control: Shuffle) -> F51x4Reduced {\n        F51x4Reduced([\n            shuffle_lanes(self.0[0], control),\n            shuffle_lanes(self.0[1], control),\n            shuffle_lanes(self.0[2], control),\n            shuffle_lanes(self.0[3], control),\n            shuffle_lanes(self.0[4], control),\n        ])\n    }\n\n    #[inline]\n    pub fn blend(&self, other: &F51x4Reduced, control: Lanes) -> F51x4Reduced {\n        F51x4Reduced([\n            blend_lanes(self.0[0], other.0[0], control),\n            blend_lanes(self.0[1], other.0[1], control),\n            blend_lanes(self.0[2], other.0[2], control),\n            blend_lanes(self.0[3], other.0[3], control),\n            blend_lanes(self.0[4], other.0[4], control),\n        ])\n    }\n\n    #[inline]\n    pub fn square(&self) -> F51x4Unreduced {\n        unsafe {\n            let x = &self.0;\n\n            // Represent values with coeff. 2\n            let mut z0_2 = u64x4::splat(0);\n            let mut z1_2 = u64x4::splat(0);\n            let mut z2_2 = u64x4::splat(0);\n            let mut z3_2 = u64x4::splat(0);\n            let mut z4_2 = u64x4::splat(0);\n            let mut z5_2 = u64x4::splat(0);\n            let mut z6_2 = u64x4::splat(0);\n            let mut z7_2 = u64x4::splat(0);\n            let mut z9_2 = u64x4::splat(0);\n\n            // Represent values with coeff. 4\n            let mut z2_4 = u64x4::splat(0);\n            let mut z3_4 = u64x4::splat(0);\n            let mut z4_4 = u64x4::splat(0);\n            let mut z5_4 = u64x4::splat(0);\n            let mut z6_4 = u64x4::splat(0);\n            let mut z7_4 = u64x4::splat(0);\n            let mut z8_4 = u64x4::splat(0);\n\n            let mut z0_1 = u64x4::splat(0);\n            z0_1 = madd52lo(z0_1, x[0], x[0]);\n\n            let mut z1_1 = u64x4::splat(0);\n            z1_2 = madd52lo(z1_2, x[0], x[1]);\n            z1_2 = madd52hi(z1_2, x[0], x[0]);\n\n            z2_4 = madd52hi(z2_4, x[0], x[1]);\n            let mut z2_1 = z2_4.shl::<2>();\n            z2_2 = madd52lo(z2_2, x[0], x[2]);\n            z2_1 = madd52lo(z2_1, x[1], x[1]);\n\n            z3_4 = madd52hi(z3_4, x[0], x[2]);\n            let mut z3_1 = z3_4.shl::<2>();\n            z3_2 = madd52lo(z3_2, x[1], x[2]);\n            z3_2 = madd52lo(z3_2, x[0], x[3]);\n            z3_2 = madd52hi(z3_2, x[1], x[1]);\n\n            z4_4 = madd52hi(z4_4, x[1], x[2]);\n            z4_4 = madd52hi(z4_4, x[0], x[3]);\n            let mut z4_1 = z4_4.shl::<2>();\n            z4_2 = madd52lo(z4_2, x[1], x[3]);\n            z4_2 = madd52lo(z4_2, x[0], x[4]);\n            z4_1 = madd52lo(z4_1, x[2], x[2]);\n\n            z5_4 = madd52hi(z5_4, x[1], x[3]);\n            z5_4 = madd52hi(z5_4, x[0], x[4]);\n            let mut z5_1 = z5_4.shl::<2>();\n            z5_2 = madd52lo(z5_2, x[2], x[3]);\n            z5_2 = madd52lo(z5_2, x[1], x[4]);\n            z5_2 = madd52hi(z5_2, x[2], x[2]);\n\n            z6_4 = madd52hi(z6_4, x[2], x[3]);\n            z6_4 = madd52hi(z6_4, x[1], x[4]);\n            let mut z6_1 = z6_4.shl::<2>();\n            z6_2 = madd52lo(z6_2, x[2], x[4]);\n            z6_1 = madd52lo(z6_1, x[3], x[3]);\n\n            z7_4 = madd52hi(z7_4, x[2], x[4]);\n            let mut z7_1 = z7_4.shl::<2>();\n            z7_2 = madd52lo(z7_2, x[3], x[4]);\n            z7_2 = madd52hi(z7_2, x[3], x[3]);\n\n            z8_4 = madd52hi(z8_4, x[3], x[4]);\n            let mut z8_1 = z8_4.shl::<2>();\n            z8_1 = madd52lo(z8_1, x[4], x[4]);\n\n            let mut z9_1 = u64x4::splat(0);\n            z9_2 = madd52hi(z9_2, x[4], x[4]);\n\n            z5_1 += z5_2.shl::<1>();\n            z6_1 += z6_2.shl::<1>();\n            z7_1 += z7_2.shl::<1>();\n            z9_1 += z9_2.shl::<1>();\n\n            let mut t0 = u64x4::splat(0);\n            let mut t1 = u64x4::splat(0);\n            let r19 = u64x4::splat(19);\n\n            t0 = madd52hi(t0, r19, z9_1);\n            t1 = madd52lo(t1, r19, z9_1.shr::<52>());\n\n            z4_2 = madd52lo(z4_2, r19, z8_1.shr::<52>());\n            z3_2 = madd52lo(z3_2, r19, z7_1.shr::<52>());\n            z2_2 = madd52lo(z2_2, r19, z6_1.shr::<52>());\n            z1_2 = madd52lo(z1_2, r19, z5_1.shr::<52>());\n\n            z0_2 = madd52lo(z0_2, r19, t0 + t1);\n            z1_2 = madd52hi(z1_2, r19, z5_1);\n            z2_2 = madd52hi(z2_2, r19, z6_1);\n            z3_2 = madd52hi(z3_2, r19, z7_1);\n            z4_2 = madd52hi(z4_2, r19, z8_1);\n\n            z0_1 = madd52lo(z0_1, r19, z5_1);\n            z1_1 = madd52lo(z1_1, r19, z6_1);\n            z2_1 = madd52lo(z2_1, r19, z7_1);\n            z3_1 = madd52lo(z3_1, r19, z8_1);\n            z4_1 = madd52lo(z4_1, r19, z9_1);\n\n            F51x4Unreduced([\n                z0_1 + z0_2 + z0_2,\n                z1_1 + z1_2 + z1_2,\n                z2_1 + z2_2 + z2_2,\n                z3_1 + z3_2 + z3_2,\n                z4_1 + z4_2 + z4_2,\n            ])\n        }\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl From<F51x4Reduced> for F51x4Unreduced {\n    #[inline]\n    fn from(x: F51x4Reduced) -> F51x4Unreduced {\n        F51x4Unreduced(x.0)\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl From<F51x4Unreduced> for F51x4Reduced {\n    #[inline]\n    fn from(x: F51x4Unreduced) -> F51x4Reduced {\n        let mask = u64x4::splat((1 << 51) - 1);\n        let r19 = u64x4::splat(19);\n\n        // Compute carryouts in parallel\n        let c0 = x.0[0].shr::<51>();\n        let c1 = x.0[1].shr::<51>();\n        let c2 = x.0[2].shr::<51>();\n        let c3 = x.0[3].shr::<51>();\n        let c4 = x.0[4].shr::<51>();\n\n        unsafe {\n            F51x4Reduced([\n                madd52lo(x.0[0] & mask, c4, r19),\n                (x.0[1] & mask) + c0,\n                (x.0[2] & mask) + c1,\n                (x.0[3] & mask) + c2,\n                (x.0[4] & mask) + c3,\n            ])\n        }\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl Add<F51x4Unreduced> for F51x4Unreduced {\n    type Output = F51x4Unreduced;\n    #[inline]\n    fn add(self, rhs: F51x4Unreduced) -> F51x4Unreduced {\n        F51x4Unreduced([\n            self.0[0] + rhs.0[0],\n            self.0[1] + rhs.0[1],\n            self.0[2] + rhs.0[2],\n            self.0[3] + rhs.0[3],\n            self.0[4] + rhs.0[4],\n        ])\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl<'a> Mul<(u32, u32, u32, u32)> for &'a F51x4Reduced {\n    type Output = F51x4Unreduced;\n    #[inline]\n    fn mul(self, scalars: (u32, u32, u32, u32)) -> F51x4Unreduced {\n        unsafe {\n            let x = &self.0;\n            let y = u64x4::new(\n                scalars.0 as u64,\n                scalars.1 as u64,\n                scalars.2 as u64,\n                scalars.3 as u64,\n            );\n            let r19 = u64x4::splat(19);\n\n            let mut z0_1 = u64x4::splat(0);\n            let mut z1_1 = u64x4::splat(0);\n            let mut z2_1 = u64x4::splat(0);\n            let mut z3_1 = u64x4::splat(0);\n            let mut z4_1 = u64x4::splat(0);\n            let mut z1_2 = u64x4::splat(0);\n            let mut z2_2 = u64x4::splat(0);\n            let mut z3_2 = u64x4::splat(0);\n            let mut z4_2 = u64x4::splat(0);\n            let mut z5_2 = u64x4::splat(0);\n\n            // Wave 0\n            z4_2 = madd52hi(z4_2, y, x[3]);\n            z5_2 = madd52hi(z5_2, y, x[4]);\n            z4_1 = madd52lo(z4_1, y, x[4]);\n            z0_1 = madd52lo(z0_1, y, x[0]);\n            z3_1 = madd52lo(z3_1, y, x[3]);\n            z2_1 = madd52lo(z2_1, y, x[2]);\n            z1_1 = madd52lo(z1_1, y, x[1]);\n            z3_2 = madd52hi(z3_2, y, x[2]);\n\n            // Wave 2\n            z2_2 = madd52hi(z2_2, y, x[1]);\n            z1_2 = madd52hi(z1_2, y, x[0]);\n            z0_1 = madd52lo(z0_1, z5_2 + z5_2, r19);\n\n            F51x4Unreduced([\n                z0_1,\n                z1_1 + z1_2 + z1_2,\n                z2_1 + z2_2 + z2_2,\n                z3_1 + z3_2 + z3_2,\n                z4_1 + z4_2 + z4_2,\n            ])\n        }\n    }\n}\n\n#[unsafe_target_feature(\"avx512ifma,avx512vl\")]\nimpl<'a, 'b> Mul<&'b F51x4Reduced> for &'a F51x4Reduced {\n    type Output = F51x4Unreduced;\n    #[inline]\n    fn mul(self, rhs: &'b F51x4Reduced) -> F51x4Unreduced {\n        unsafe {\n            // Inputs\n            let x = &self.0;\n            let y = &rhs.0;\n\n            // Accumulators for terms with coeff 1\n            let mut z0_1 = u64x4::splat(0);\n            let mut z1_1 = u64x4::splat(0);\n            let mut z2_1 = u64x4::splat(0);\n            let mut z3_1 = u64x4::splat(0);\n            let mut z4_1 = u64x4::splat(0);\n            let mut z5_1 = u64x4::splat(0);\n            let mut z6_1 = u64x4::splat(0);\n            let mut z7_1 = u64x4::splat(0);\n            let mut z8_1 = u64x4::splat(0);\n\n            // Accumulators for terms with coeff 2\n            let mut z0_2 = u64x4::splat(0);\n            let mut z1_2 = u64x4::splat(0);\n            let mut z2_2 = u64x4::splat(0);\n            let mut z3_2 = u64x4::splat(0);\n            let mut z4_2 = u64x4::splat(0);\n            let mut z5_2 = u64x4::splat(0);\n            let mut z6_2 = u64x4::splat(0);\n            let mut z7_2 = u64x4::splat(0);\n            let mut z8_2 = u64x4::splat(0);\n            let mut z9_2 = u64x4::splat(0);\n\n            // LLVM doesn't seem to do much work reordering IFMA\n            // instructions, so try to organize them into \"waves\" of 8\n            // independent operations (4c latency, 0.5 c throughput\n            // means 8 in flight)\n\n            // Wave 0\n            z4_1 = madd52lo(z4_1, x[2], y[2]);\n            z5_2 = madd52hi(z5_2, x[2], y[2]);\n            z5_1 = madd52lo(z5_1, x[4], y[1]);\n            z6_2 = madd52hi(z6_2, x[4], y[1]);\n            z6_1 = madd52lo(z6_1, x[4], y[2]);\n            z7_2 = madd52hi(z7_2, x[4], y[2]);\n            z7_1 = madd52lo(z7_1, x[4], y[3]);\n            z8_2 = madd52hi(z8_2, x[4], y[3]);\n\n            // Wave 1\n            z4_1 = madd52lo(z4_1, x[3], y[1]);\n            z5_2 = madd52hi(z5_2, x[3], y[1]);\n            z5_1 = madd52lo(z5_1, x[3], y[2]);\n            z6_2 = madd52hi(z6_2, x[3], y[2]);\n            z6_1 = madd52lo(z6_1, x[3], y[3]);\n            z7_2 = madd52hi(z7_2, x[3], y[3]);\n            z7_1 = madd52lo(z7_1, x[3], y[4]);\n            z8_2 = madd52hi(z8_2, x[3], y[4]);\n\n            // Wave 2\n            z8_1 = madd52lo(z8_1, x[4], y[4]);\n            z9_2 = madd52hi(z9_2, x[4], y[4]);\n            z4_1 = madd52lo(z4_1, x[4], y[0]);\n            z5_2 = madd52hi(z5_2, x[4], y[0]);\n            z5_1 = madd52lo(z5_1, x[2], y[3]);\n            z6_2 = madd52hi(z6_2, x[2], y[3]);\n            z6_1 = madd52lo(z6_1, x[2], y[4]);\n            z7_2 = madd52hi(z7_2, x[2], y[4]);\n\n            let z8 = z8_1 + z8_2 + z8_2;\n            let z9 = z9_2 + z9_2;\n\n            // Wave 3\n            z3_1 = madd52lo(z3_1, x[3], y[0]);\n            z4_2 = madd52hi(z4_2, x[3], y[0]);\n            z4_1 = madd52lo(z4_1, x[1], y[3]);\n            z5_2 = madd52hi(z5_2, x[1], y[3]);\n            z5_1 = madd52lo(z5_1, x[1], y[4]);\n            z6_2 = madd52hi(z6_2, x[1], y[4]);\n            z2_1 = madd52lo(z2_1, x[2], y[0]);\n            z3_2 = madd52hi(z3_2, x[2], y[0]);\n\n            let z6 = z6_1 + z6_2 + z6_2;\n            let z7 = z7_1 + z7_2 + z7_2;\n\n            // Wave 4\n            z3_1 = madd52lo(z3_1, x[2], y[1]);\n            z4_2 = madd52hi(z4_2, x[2], y[1]);\n            z4_1 = madd52lo(z4_1, x[0], y[4]);\n            z5_2 = madd52hi(z5_2, x[0], y[4]);\n            z1_1 = madd52lo(z1_1, x[1], y[0]);\n            z2_2 = madd52hi(z2_2, x[1], y[0]);\n            z2_1 = madd52lo(z2_1, x[1], y[1]);\n            z3_2 = madd52hi(z3_2, x[1], y[1]);\n\n            let z5 = z5_1 + z5_2 + z5_2;\n\n            // Wave 5\n            z3_1 = madd52lo(z3_1, x[1], y[2]);\n            z4_2 = madd52hi(z4_2, x[1], y[2]);\n            z0_1 = madd52lo(z0_1, x[0], y[0]);\n            z1_2 = madd52hi(z1_2, x[0], y[0]);\n            z1_1 = madd52lo(z1_1, x[0], y[1]);\n            z2_1 = madd52lo(z2_1, x[0], y[2]);\n            z2_2 = madd52hi(z2_2, x[0], y[1]);\n            z3_2 = madd52hi(z3_2, x[0], y[2]);\n\n            let mut t0 = u64x4::splat(0);\n            let mut t1 = u64x4::splat(0);\n            let r19 = u64x4::splat(19);\n\n            // Wave 6\n            t0 = madd52hi(t0, r19, z9);\n            t1 = madd52lo(t1, r19, z9.shr::<52>());\n            z3_1 = madd52lo(z3_1, x[0], y[3]);\n            z4_2 = madd52hi(z4_2, x[0], y[3]);\n            z1_2 = madd52lo(z1_2, r19, z5.shr::<52>());\n            z2_2 = madd52lo(z2_2, r19, z6.shr::<52>());\n            z3_2 = madd52lo(z3_2, r19, z7.shr::<52>());\n            z0_1 = madd52lo(z0_1, r19, z5);\n\n            // Wave 7\n            z4_1 = madd52lo(z4_1, r19, z9);\n            z1_1 = madd52lo(z1_1, r19, z6);\n            z0_2 = madd52lo(z0_2, r19, t0 + t1);\n            z4_2 = madd52hi(z4_2, r19, z8);\n            z2_1 = madd52lo(z2_1, r19, z7);\n            z1_2 = madd52hi(z1_2, r19, z5);\n            z2_2 = madd52hi(z2_2, r19, z6);\n            z3_2 = madd52hi(z3_2, r19, z7);\n\n            // Wave 8\n            z3_1 = madd52lo(z3_1, r19, z8);\n            z4_2 = madd52lo(z4_2, r19, z8.shr::<52>());\n\n            F51x4Unreduced([\n                z0_1 + z0_2 + z0_2,\n                z1_1 + z1_2 + z1_2,\n                z2_1 + z2_2 + z2_2,\n                z3_1 + z3_2 + z3_2,\n                z4_1 + z4_2 + z4_2,\n            ])\n        }\n    }\n}\n\n#[cfg(all(target_feature = \"avx512ifma\", target_feature = \"avx512vl\"))]\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn vpmadd52luq() {\n        let x = u64x4::splat(2);\n        let y = u64x4::splat(3);\n        let mut z = u64x4::splat(5);\n\n        z = unsafe { madd52lo(z, x, y) };\n\n        assert_eq!(z, u64x4::splat(5 + 2 * 3));\n    }\n\n    #[test]\n    fn new_split_round_trip_on_reduced_input() {\n        // Invert a small field element to get a big one\n        let a = FieldElement51([2438, 24, 243, 0, 0]).invert();\n\n        let ax4 = F51x4Unreduced::new(&a, &a, &a, &a);\n        let splits = ax4.split();\n\n        for i in 0..4 {\n            assert_eq!(a, splits[i]);\n        }\n    }\n\n    #[test]\n    fn new_split_round_trip_on_unreduced_input() {\n        // Invert a small field element to get a big one\n        let a = FieldElement51([2438, 24, 243, 0, 0]).invert();\n        // ... but now multiply it by 16 without reducing coeffs\n        let a16 = FieldElement51([\n            a.0[0] << 4,\n            a.0[1] << 4,\n            a.0[2] << 4,\n            a.0[3] << 4,\n            a.0[4] << 4,\n        ]);\n\n        let a16x4 = F51x4Unreduced::new(&a16, &a16, &a16, &a16);\n        let splits = a16x4.split();\n\n        for i in 0..4 {\n            assert_eq!(a16, splits[i]);\n        }\n    }\n\n    #[test]\n    fn test_reduction() {\n        // Invert a small field element to get a big one\n        let a = FieldElement51([2438, 24, 243, 0, 0]).invert();\n        // ... but now multiply it by 128 without reducing coeffs\n        let abig = FieldElement51([\n            a.0[0] << 4,\n            a.0[1] << 4,\n            a.0[2] << 4,\n            a.0[3] << 4,\n            a.0[4] << 4,\n        ]);\n\n        let abigx4: F51x4Reduced = F51x4Unreduced::new(&abig, &abig, &abig, &abig).into();\n\n        let splits = F51x4Unreduced::from(abigx4).split();\n        let c = &a * &FieldElement51([(1 << 4), 0, 0, 0, 0]);\n\n        for i in 0..4 {\n            assert_eq!(c, splits[i]);\n        }\n    }\n\n    #[test]\n    fn mul_matches_serial() {\n        // Invert a small field element to get a big one\n        let a = FieldElement51([2438, 24, 243, 0, 0]).invert();\n        let b = FieldElement51([98098, 87987897, 0, 1, 0]).invert();\n        let c = &a * &b;\n\n        let ax4: F51x4Reduced = F51x4Unreduced::new(&a, &a, &a, &a).into();\n        let bx4: F51x4Reduced = F51x4Unreduced::new(&b, &b, &b, &b).into();\n        let cx4 = &ax4 * &bx4;\n\n        let splits = cx4.split();\n\n        for i in 0..4 {\n            assert_eq!(c, splits[i]);\n        }\n    }\n\n    #[test]\n    fn iterated_mul_matches_serial() {\n        // Invert a small field element to get a big one\n        let a = FieldElement51([2438, 24, 243, 0, 0]).invert();\n        let b = FieldElement51([98098, 87987897, 0, 1, 0]).invert();\n        let mut c = &a * &b;\n        for _i in 0..1024 {\n            c = &a * &c;\n            c = &b * &c;\n        }\n\n        let ax4: F51x4Reduced = F51x4Unreduced::new(&a, &a, &a, &a).into();\n        let bx4: F51x4Reduced = F51x4Unreduced::new(&b, &b, &b, &b).into();\n        let mut cx4 = &ax4 * &bx4;\n        for _i in 0..1024 {\n            cx4 = &ax4 * &F51x4Reduced::from(cx4);\n            cx4 = &bx4 * &F51x4Reduced::from(cx4);\n        }\n\n        let splits = cx4.split();\n\n        for i in 0..4 {\n            assert_eq!(c, splits[i]);\n        }\n    }\n\n    #[test]\n    fn square_matches_mul() {\n        // Invert a small field element to get a big one\n        let a = FieldElement51([2438, 24, 243, 0, 0]).invert();\n\n        let ax4: F51x4Reduced = F51x4Unreduced::new(&a, &a, &a, &a).into();\n        let cx4 = &ax4 * &ax4;\n        let cx4_sq = ax4.square();\n\n        let splits = cx4.split();\n        let splits_sq = cx4_sq.split();\n\n        for i in 0..4 {\n            assert_eq!(splits_sq[i], splits[i]);\n        }\n    }\n\n    #[test]\n    fn iterated_square_matches_serial() {\n        // Invert a small field element to get a big one\n        let mut a = FieldElement51([2438, 24, 243, 0, 0]).invert();\n        let mut ax4 = F51x4Unreduced::new(&a, &a, &a, &a);\n        for _j in 0..1024 {\n            a = a.square();\n            ax4 = F51x4Reduced::from(ax4).square();\n\n            let splits = ax4.split();\n            for i in 0..4 {\n                assert_eq!(a, splits[i]);\n            }\n        }\n    }\n\n    #[test]\n    fn iterated_u32_mul_matches_serial() {\n        // Invert a small field element to get a big one\n        let a = FieldElement51([2438, 24, 243, 0, 0]).invert();\n        let b = FieldElement51([121665, 0, 0, 0, 0]);\n        let mut c = &a * &b;\n        for _i in 0..1024 {\n            c = &b * &c;\n        }\n\n        let ax4 = F51x4Unreduced::new(&a, &a, &a, &a);\n        let bx4 = (121665u32, 121665u32, 121665u32, 121665u32);\n        let mut cx4 = &F51x4Reduced::from(ax4) * bx4;\n        for _i in 0..1024 {\n            cx4 = &F51x4Reduced::from(cx4) * bx4;\n        }\n\n        let splits = cx4.split();\n\n        for i in 0..4 {\n            assert_eq!(c, splits[i]);\n        }\n    }\n\n    #[test]\n    fn shuffle_AAAA() {\n        let x0 = FieldElement51::from_bytes(&[0x10; 32]);\n        let x1 = FieldElement51::from_bytes(&[0x11; 32]);\n        let x2 = FieldElement51::from_bytes(&[0x12; 32]);\n        let x3 = FieldElement51::from_bytes(&[0x13; 32]);\n\n        let x = F51x4Unreduced::new(&x0, &x1, &x2, &x3);\n\n        let y = x.shuffle(Shuffle::AAAA);\n        let splits = y.split();\n\n        assert_eq!(splits[0], x0);\n        assert_eq!(splits[1], x0);\n        assert_eq!(splits[2], x0);\n        assert_eq!(splits[3], x0);\n    }\n\n    #[test]\n    fn blend_AB() {\n        let x0 = FieldElement51::from_bytes(&[0x10; 32]);\n        let x1 = FieldElement51::from_bytes(&[0x11; 32]);\n        let x2 = FieldElement51::from_bytes(&[0x12; 32]);\n        let x3 = FieldElement51::from_bytes(&[0x13; 32]);\n\n        let x = F51x4Unreduced::new(&x0, &x1, &x2, &x3);\n        let z = F51x4Unreduced::new(&x3, &x2, &x1, &x0);\n\n        let y = x.blend(&z, Lanes::AB);\n        let splits = y.split();\n\n        assert_eq!(splits[0], x3);\n        assert_eq!(splits[1], x2);\n        assert_eq!(splits[2], x2);\n        assert_eq!(splits[3], x3);\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/ifma/field.rs",
    "filepath": null,
    "folder_id": 15832,
    "user_id": 460154
  },
  "63603": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2018-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! This module contains constants used by the IFMA backend.\n\nuse crate::backend::vector::packed_simd::u64x4;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::window::NafLookupTable8;\n\nuse super::edwards::{CachedPoint, ExtendedPoint};\nuse super::field::{F51x4Reduced, F51x4Unreduced};\n\n/// The identity element as an `ExtendedPoint`.\npub(crate) static EXTENDEDPOINT_IDENTITY: ExtendedPoint = ExtendedPoint(F51x4Unreduced([\n    u64x4::new_const(0, 1, 1, 0),\n    u64x4::new_const(0, 0, 0, 0),\n    u64x4::new_const(0, 0, 0, 0),\n    u64x4::new_const(0, 0, 0, 0),\n    u64x4::new_const(0, 0, 0, 0),\n]));\n\n/// The identity element as a `CachedPoint`.\npub(crate) static CACHEDPOINT_IDENTITY: CachedPoint = CachedPoint(F51x4Reduced([\n    u64x4::new_const(121647, 121666, 243332, 2251799813685229),\n    u64x4::new_const(2251799813685248, 0, 0, 2251799813685247),\n    u64x4::new_const(2251799813685247, 0, 0, 2251799813685247),\n    u64x4::new_const(2251799813685247, 0, 0, 2251799813685247),\n    u64x4::new_const(2251799813685247, 0, 0, 2251799813685247),\n]));\n\n/// Odd multiples of the Ed25519 basepoint:\n#[cfg(feature = \"precomputed-tables\")]\npub(crate) static BASEPOINT_ODD_LOOKUP_TABLE: NafLookupTable8<CachedPoint> = NafLookupTable8([\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(1277522120965857, 73557767439946, 243332, 1943719795065404),\n        u64x4::new_const(108375142003455, 341984820733594, 0, 2097709862669256),\n        u64x4::new_const(150073485536043, 750646439938056, 0, 581130035634455),\n        u64x4::new_const(2149983732744869, 1903255931888577, 0, 646644904824193),\n        u64x4::new_const(291045673509296, 1060034214701851, 0, 325245010451737),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1970681836121889,\n            1660307753655178,\n            1077207637163462,\n            1436413309977108,\n        ),\n        u64x4::new_const(\n            158785710838757,\n            919645875412951,\n            174577133496574,\n            2213787394009350,\n        ),\n        u64x4::new_const(\n            1017606396438281,\n            1240932851489554,\n            918203302506967,\n            1239827708070863,\n        ),\n        u64x4::new_const(\n            1748989883612327,\n            1745367742532782,\n            1168385548387,\n            1211387683826673,\n        ),\n        u64x4::new_const(\n            799349980018733,\n            1471088235739693,\n            1505351346057417,\n            2104975925096407,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            171437462972293,\n            36016853025886,\n            1184164975342640,\n            1633525003912147,\n        ),\n        u64x4::new_const(\n            2113383632509037,\n            1946216474924125,\n            1884174984466256,\n            1373317790955847,\n        ),\n        u64x4::new_const(\n            791293623466401,\n            1796466048084189,\n            444977763198796,\n            629823271230872,\n        ),\n        u64x4::new_const(\n            1093217720067380,\n            2157024270666135,\n            238122980108466,\n            806820763806847,\n        ),\n        u64x4::new_const(\n            793658959468458,\n            368578641413741,\n            11592529764159,\n            2144017075993471,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1538027396670268,\n            1588896993892061,\n            675619548648376,\n            788373514423313,\n        ),\n        u64x4::new_const(\n            1987517656073805,\n            1940987929951188,\n            666993851697339,\n            2040540928108427,\n        ),\n        u64x4::new_const(\n            375514548584082,\n            1726008037083790,\n            1070069155000872,\n            570111103756303,\n        ),\n        u64x4::new_const(\n            772223645372213,\n            2123395244967674,\n            868238486911408,\n            1846639042240362,\n        ),\n        u64x4::new_const(\n            872865734460736,\n            32277956842850,\n            1701451131455402,\n            773883376061880,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1845177363882902,\n            275858237213625,\n            1052127336883600,\n            171072805852218,\n        ),\n        u64x4::new_const(\n            139016783952609,\n            462699304987089,\n            430046471494974,\n            410922720999257,\n        ),\n        u64x4::new_const(\n            846403935976337,\n            243817706931454,\n            971825428236901,\n            571800039596794,\n        ),\n        u64x4::new_const(\n            807642685434918,\n            1933536976438782,\n            812324278898440,\n            688391556487313,\n        ),\n        u64x4::new_const(\n            76239450396192,\n            629532732688863,\n            1833302026979779,\n            650067934544499,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1373931604989264,\n            331159264656614,\n            364391529321767,\n            874765630865409,\n        ),\n        u64x4::new_const(\n            2109908262150241,\n            473400816504190,\n            91544045127333,\n            976307977609515,\n        ),\n        u64x4::new_const(\n            330175435673491,\n            2126511895885904,\n            1022944071588421,\n            2158480209801463,\n        ),\n        u64x4::new_const(\n            1305666795527971,\n            162063591028664,\n            2193154870675382,\n            1789166662611800,\n        ),\n        u64x4::new_const(\n            817858592500508,\n            1672743239440202,\n            859976879916778,\n            1167423340862516,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            274334925170164,\n            565841102587251,\n            603083835949120,\n            607539210240861,\n        ),\n        u64x4::new_const(\n            196754662972649,\n            1339063476699167,\n            1406077076979491,\n            896902435668469,\n        ),\n        u64x4::new_const(\n            397962210956733,\n            174839587476217,\n            1381082665748936,\n            175195877334136,\n        ),\n        u64x4::new_const(\n            717429432748391,\n            1635309821746318,\n            363374010274647,\n            882908746261699,\n        ),\n        u64x4::new_const(\n            600946602802781,\n            1946596133370711,\n            1532135183320341,\n            690530671668253,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            2074443704000945,\n            2163534804938345,\n            425423840926528,\n            1100826171404853,\n        ),\n        u64x4::new_const(\n            111700142796101,\n            1456893872751964,\n            1186145518682968,\n            2192182627706116,\n        ),\n        u64x4::new_const(\n            1848722121856066,\n            2123239575044749,\n            1323870754599272,\n            883211262889775,\n        ),\n        u64x4::new_const(\n            938263017712916,\n            689670293631396,\n            183944529557576,\n            501908638166580,\n        ),\n        u64x4::new_const(\n            2170571907220631,\n            36636756989655,\n            1875035480138608,\n            803703278398018,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1053429956874064,\n            1636640618139765,\n            1556890827801070,\n            2142720579528828,\n        ),\n        u64x4::new_const(\n            1814240918422814,\n            692326274601777,\n            1054896561802157,\n            2025454041705534,\n        ),\n        u64x4::new_const(\n            2109495823888757,\n            1287497869997176,\n            194170063200096,\n            621116840113213,\n        ),\n        u64x4::new_const(\n            2156505873679998,\n            2197064359737385,\n            1312887672223536,\n            369862818895912,\n        ),\n        u64x4::new_const(\n            977381163563657,\n            1878897311974033,\n            2144566861359744,\n            1832960882773351,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1266492498289486,\n            1301524759372145,\n            324789537938521,\n            442710471023019,\n        ),\n        u64x4::new_const(\n            1232722320001345,\n            1191193089162455,\n            176474006074813,\n            2158950213252857,\n        ),\n        u64x4::new_const(\n            1901782191467749,\n            494791441598902,\n            1820415815322129,\n            854954583485223,\n        ),\n        u64x4::new_const(\n            1511383667649702,\n            792536415032464,\n            2027741263854728,\n            1727944381044738,\n        ),\n        u64x4::new_const(\n            606355788891204,\n            1670687521471220,\n            582824350365415,\n            1509135066079912,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1079942762813598,\n            2015830004785901,\n            479916361323351,\n            1907956590950158,\n        ),\n        u64x4::new_const(\n            2053400302939156,\n            1319799126867070,\n            19493088767391,\n            1908755581402373,\n        ),\n        u64x4::new_const(\n            2235858054780980,\n            885832711204321,\n            810332865560178,\n            103174191215441,\n        ),\n        u64x4::new_const(\n            1843466881032833,\n            355511728384038,\n            693846715794114,\n            186545012724117,\n        ),\n        u64x4::new_const(\n            1661758432892509,\n            1491022339899281,\n            698941123765263,\n            174945407208560,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1075933251927831,\n            400263885306647,\n            1308157532880528,\n            347933379126665,\n        ),\n        u64x4::new_const(\n            673811632329433,\n            1584860147186478,\n            271778891257244,\n            498194055154207,\n        ),\n        u64x4::new_const(\n            703783427747558,\n            1051624728592032,\n            1371463103351544,\n            230351033002960,\n        ),\n        u64x4::new_const(\n            860729466483372,\n            421647596766583,\n            1520613871336707,\n            635298775280054,\n        ),\n        u64x4::new_const(\n            1168352891728845,\n            1691216293752089,\n            1799491997061519,\n            399728882318504,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            420156727446514,\n            1483649215777128,\n            165508610199900,\n            1918121104840431,\n        ),\n        u64x4::new_const(\n            2129902293682427,\n            730952770435213,\n            2184527544565390,\n            1939880362232986,\n        ),\n        u64x4::new_const(\n            1771978364905086,\n            510975579746524,\n            927564335219142,\n            177574146260558,\n        ),\n        u64x4::new_const(\n            2164104536437514,\n            1532598873799015,\n            406875369182421,\n            1367005937406517,\n        ),\n        u64x4::new_const(\n            35073200082587,\n            1981124717036219,\n            1854087014063833,\n            122419694385217,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1963785875777739,\n            411497142699119,\n            1974557512687408,\n            1268304422747183,\n        ),\n        u64x4::new_const(\n            762752575978150,\n            1443822019541748,\n            1331556159904338,\n            377726798263780,\n        ),\n        u64x4::new_const(\n            825953972847841,\n            353487068141356,\n            1955697322427207,\n            2048226560172078,\n        ),\n        u64x4::new_const(\n            1482378558684434,\n            657691905625918,\n            923870001994493,\n            1694132799397736,\n        ),\n        u64x4::new_const(\n            1643904759603122,\n            170495566698285,\n            1218312703413378,\n            784318735038131,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            939230507241903,\n            2238763473105245,\n            1827325199528162,\n            1153939339775538,\n        ),\n        u64x4::new_const(\n            38544505283339,\n            258889431497015,\n            351721979677947,\n            1357907379592829,\n        ),\n        u64x4::new_const(\n            1393974676373341,\n            1131355528938676,\n            473104915298872,\n            978783482501776,\n        ),\n        u64x4::new_const(\n            2131516168980501,\n            2113911780991092,\n            1477027502354261,\n            542884524860340,\n        ),\n        u64x4::new_const(\n            1029606261349423,\n            64226378557628,\n            1669131167474348,\n            2212808057234874,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1423176501543193,\n            163313632579593,\n            2220495688893001,\n            2220041045291870,\n        ),\n        u64x4::new_const(\n            1111834224023697,\n            1026815658023689,\n            1404605100939775,\n            1412149108248227,\n        ),\n        u64x4::new_const(\n            1542537854906076,\n            1270288391129127,\n            991419278941933,\n            1824939809581980,\n        ),\n        u64x4::new_const(\n            1142003215657891,\n            525980550896367,\n            1508270666157963,\n            917719462309053,\n        ),\n        u64x4::new_const(\n            400851268057105,\n            1620818232405188,\n            1251478578139510,\n            2162841805361886,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            2125383272208441,\n            1368790097335984,\n            11813369275978,\n            639513785921674,\n        ),\n        u64x4::new_const(\n            2200806265616284,\n            1041996387620216,\n            1275149397833084,\n            1723371028064068,\n        ),\n        u64x4::new_const(\n            603720163891275,\n            2135593511176153,\n            2049641644431548,\n            1198460677818310,\n        ),\n        u64x4::new_const(\n            1862491879401621,\n            2008116580769441,\n            626566325260235,\n            1058308304975798,\n        ),\n        u64x4::new_const(\n            628557314314858,\n            1075323332046522,\n            1631772244117095,\n            1812174547405683,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1222773123817104,\n            363276129291452,\n            796237592807883,\n            1914425291893078,\n        ),\n        u64x4::new_const(\n            1721259057429088,\n            734941709009373,\n            1553365830564638,\n            1492120931079419,\n        ),\n        u64x4::new_const(\n            1009354843273686,\n            293884504384873,\n            1050281954944357,\n            134132942667344,\n        ),\n        u64x4::new_const(\n            23119363298711,\n            1694754778833445,\n            1725925193393496,\n            1738396998222001,\n        ),\n        u64x4::new_const(\n            1753692057254667,\n            118428526447110,\n            840961387840295,\n            1227619055408558,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1004186117579547,\n            508771992330056,\n            1426571663072421,\n            2238524171903259,\n        ),\n        u64x4::new_const(\n            744764613007812,\n            398885442368825,\n            2047459490294949,\n            2141797621077959,\n        ),\n        u64x4::new_const(\n            4556204156489,\n            1708213022802363,\n            1071381560923933,\n            393474529142567,\n        ),\n        u64x4::new_const(\n            350116198213005,\n            945907227204695,\n            168267474358731,\n            1801504420122711,\n        ),\n        u64x4::new_const(\n            728788674520360,\n            1262722049156121,\n            455259596607008,\n            1159442365834489,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            2226818917892677,\n            185673745808179,\n            2240952219732549,\n            324137961621908,\n        ),\n        u64x4::new_const(\n            1659527641857410,\n            973964060249383,\n            1349692151487730,\n            1172743533370593,\n        ),\n        u64x4::new_const(\n            310591478467746,\n            2123977244137170,\n            774562885265820,\n            430035546191685,\n        ),\n        u64x4::new_const(\n            2150863173197992,\n            2101978317708856,\n            193592648406011,\n            1375328504508580,\n        ),\n        u64x4::new_const(\n            1946235834250479,\n            121741431658675,\n            1004342690620100,\n            2063466488599450,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            463079632200153,\n            40415275714025,\n            545935352782679,\n            1458043501600908,\n        ),\n        u64x4::new_const(\n            783771976559993,\n            880839641726471,\n            1782028201271831,\n            41664413404590,\n        ),\n        u64x4::new_const(\n            985129151724159,\n            187728621410000,\n            16620051933318,\n            378011085567733,\n        ),\n        u64x4::new_const(\n            1820372198168638,\n            905710046480679,\n            1912961774249737,\n            1868135861067161,\n        ),\n        u64x4::new_const(\n            474460473983187,\n            1455684425673661,\n            652771171116843,\n            733511920760779,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1088886980746809,\n            1660218575261626,\n            527921875040240,\n            915086639857889,\n        ),\n        u64x4::new_const(\n            1814735788528175,\n            1586698876186367,\n            2040856637532862,\n            405684812785624,\n        ),\n        u64x4::new_const(\n            658578559700999,\n            1751442070931114,\n            1293623371490094,\n            715026719042518,\n        ),\n        u64x4::new_const(\n            382156225644820,\n            897982285504960,\n            577673183555858,\n            1158728558309719,\n        ),\n        u64x4::new_const(\n            1865791902475663,\n            124491617513788,\n            758484125168765,\n            734065580770143,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            330985690350617,\n            2214424721795630,\n            973374650780848,\n            1507267060932964,\n        ),\n        u64x4::new_const(\n            1733823971011290,\n            1730742552292995,\n            669018866977489,\n            604527664126146,\n        ),\n        u64x4::new_const(\n            1082092498645474,\n            1029182053935309,\n            756799947765834,\n            1764720030308351,\n        ),\n        u64x4::new_const(\n            969912105693756,\n            38116887248276,\n            2148030115687613,\n            995140534653865,\n        ),\n        u64x4::new_const(\n            2154373397460354,\n            298128883464656,\n            479587543632539,\n            1061127201140779,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            843064865526549,\n            2019481782959016,\n            1873125524281672,\n            2013330239022371,\n        ),\n        u64x4::new_const(\n            1192932403815186,\n            1818108671859220,\n            1247005102016258,\n            1210577394628058,\n        ),\n        u64x4::new_const(\n            132359273326717,\n            795492788299178,\n            1235924489372816,\n            891705064411550,\n        ),\n        u64x4::new_const(\n            1425833709104858,\n            152114045731085,\n            991347902581315,\n            1387773338707683,\n        ),\n        u64x4::new_const(\n            48024203807922,\n            157005564892977,\n            1474053161953744,\n            727448023498345,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1076621484026788,\n            1309917234320927,\n            1786998180233659,\n            1595497085944737,\n        ),\n        u64x4::new_const(\n            1737334672694726,\n            2038133716999447,\n            1929061192400917,\n            620544235219084,\n        ),\n        u64x4::new_const(\n            1550527313469747,\n            329096759623509,\n            1585214659209474,\n            693419841748324,\n        ),\n        u64x4::new_const(\n            1450010875912315,\n            2085047082180569,\n            757421110771886,\n            389367139787400,\n        ),\n        u64x4::new_const(\n            781339490566117,\n            132941783448971,\n            258650459725225,\n            2042274962585613,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            859638991542650,\n            2249840007426442,\n            1138753070862357,\n            793751342318913,\n        ),\n        u64x4::new_const(\n            2133476133447306,\n            1027010646129239,\n            436851910892865,\n            866949948830344,\n        ),\n        u64x4::new_const(\n            1936003572431223,\n            531513680252193,\n            1929877059408416,\n            830585477662503,\n        ),\n        u64x4::new_const(\n            1460760405777960,\n            686673748420916,\n            275475330051554,\n            1581792376993692,\n        ),\n        u64x4::new_const(\n            894482039456784,\n            1801274480988632,\n            16407898635278,\n            1668497039215206,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            258585746227669,\n            936490904651492,\n            1826793887434108,\n            1201219990633823,\n        ),\n        u64x4::new_const(\n            979462791643635,\n            461762372210187,\n            218708929991480,\n            1378150755760178,\n        ),\n        u64x4::new_const(\n            642542170229970,\n            787135445552820,\n            371168855880557,\n            182642566486693,\n        ),\n        u64x4::new_const(\n            1152277399721904,\n            1726910452705576,\n            1452393215705343,\n            2117799581546845,\n        ),\n        u64x4::new_const(\n            1211265143925330,\n            14373046151823,\n            1745528818271507,\n            1842106288572078,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            635154614562157,\n            1956763034454109,\n            509123035953043,\n            445727657534780,\n        ),\n        u64x4::new_const(\n            2072765509783252,\n            1282639891593570,\n            1075086397362049,\n            722996110178195,\n        ),\n        u64x4::new_const(\n            1385572918825603,\n            1190035835509576,\n            218317841176013,\n            1047865370756924,\n        ),\n        u64x4::new_const(\n            473991569426488,\n            1910588123704592,\n            1338270051770806,\n            401676861680875,\n        ),\n        u64x4::new_const(\n            992455353618436,\n            126422733426929,\n            1955248037756399,\n            119233843022643,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1555272991526078,\n            2214378187116349,\n            366893798097444,\n            1401502118355702,\n        ),\n        u64x4::new_const(\n            1157229521930713,\n            2144787187506262,\n            1681597469697840,\n            847499096518697,\n        ),\n        u64x4::new_const(\n            1872802655800758,\n            1027119609820793,\n            1137278714788290,\n            1664750301179485,\n        ),\n        u64x4::new_const(\n            1091289858897030,\n            910126419483563,\n            1101920147235731,\n            597083075893952,\n        ),\n        u64x4::new_const(\n            1711011533670315,\n            185206680336278,\n            1620960612579784,\n            1968598849170880,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            73077300235958,\n            257216723095630,\n            466947267713785,\n            847105214181598,\n        ),\n        u64x4::new_const(\n            1322905631406309,\n            407458059314731,\n            230045063190376,\n            923800751267786,\n        ),\n        u64x4::new_const(\n            1146027205000415,\n            1541328763727623,\n            768510249199119,\n            1630223587589059,\n        ),\n        u64x4::new_const(\n            1930368769879433,\n            1376145403022159,\n            1898149855343131,\n            1709421930518180,\n        ),\n        u64x4::new_const(\n            633944191571764,\n            58314960742839,\n            2050971151574988,\n            757799756090059,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            361576929158539,\n            1035682890165818,\n            160945739362874,\n            266975208626222,\n        ),\n        u64x4::new_const(\n            1635371797076046,\n            2106722851965197,\n            451585919077206,\n            6692426667180,\n        ),\n        u64x4::new_const(\n            175820543533852,\n            2057511393764025,\n            1531846543720469,\n            1648320903946519,\n        ),\n        u64x4::new_const(\n            947461770620940,\n            1107335044817620,\n            1725565474111216,\n            2182263619949220,\n        ),\n        u64x4::new_const(\n            726444888601221,\n            1379664085279206,\n            1517215633290417,\n            1763968936542507,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            686545355846512,\n            1712283265573167,\n            1743509592736302,\n            1653906616429153,\n        ),\n        u64x4::new_const(\n            985108805667149,\n            2244347650874753,\n            1304749057936860,\n            321846134330589,\n        ),\n        u64x4::new_const(\n            296321076156886,\n            1717929256240029,\n            450933772486425,\n            2015536856431605,\n        ),\n        u64x4::new_const(\n            1690393512821866,\n            646913049470189,\n            2198650647576397,\n            1230646705710442,\n        ),\n        u64x4::new_const(\n            601961913448442,\n            878806578800541,\n            620497587492381,\n            330716414244629,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            631510982676132,\n            1755753187697174,\n            1596201246674299,\n            2197888384902121,\n        ),\n        u64x4::new_const(\n            626957678275745,\n            1447583371478595,\n            1375375216702128,\n            1443613232818823,\n        ),\n        u64x4::new_const(\n            1962997804660501,\n            1051744123184519,\n            1002558639300437,\n            1237313314603385,\n        ),\n        u64x4::new_const(\n            2118828335274995,\n            226398203764759,\n            889099617161107,\n            1620967117678504,\n        ),\n        u64x4::new_const(\n            227261019362935,\n            2046897556746842,\n            591524060355369,\n            2178552047369691,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1375403119051662,\n            222313965014452,\n            539873444241395,\n            213198095917915,\n        ),\n        u64x4::new_const(\n            1436952871599114,\n            1229749762725246,\n            1174441562267670,\n            265367077740349,\n        ),\n        u64x4::new_const(\n            11107426165917,\n            985954476039181,\n            1147329112365579,\n            1133931640328107,\n        ),\n        u64x4::new_const(\n            585235055006843,\n            699515259687482,\n            299559608721134,\n            2134819767146767,\n        ),\n        u64x4::new_const(\n            1376401105588528,\n            391412107507860,\n            302743651807545,\n            1362834426455518,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1802940904616205,\n            1615132760193234,\n            869321663313735,\n            666494072545310,\n        ),\n        u64x4::new_const(\n            1452849320020701,\n            1472716813676364,\n            472862999490802,\n            359937983286145,\n        ),\n        u64x4::new_const(\n            1221198323133843,\n            491718521756528,\n            1387135774113906,\n            793779904904008,\n        ),\n        u64x4::new_const(\n            1032129287829151,\n            30730741946697,\n            217603185195068,\n            2118169309744162,\n        ),\n        u64x4::new_const(\n            225899335574721,\n            1767553399797342,\n            881082465669982,\n            1435383196392870,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1127093564374276,\n            2245188499702906,\n            1250041622887441,\n            2179324911668149,\n        ),\n        u64x4::new_const(\n            908019210866875,\n            1879900391060964,\n            1355047706206597,\n            647218945377302,\n        ),\n        u64x4::new_const(\n            1616265604422592,\n            2134336781521657,\n            1157711219915601,\n            1227494173135033,\n        ),\n        u64x4::new_const(\n            136450294813355,\n            1984543542455033,\n            1199486053011083,\n            33687889941331,\n        ),\n        u64x4::new_const(\n            1053447012707371,\n            68239344331930,\n            537448158443925,\n            1829189783369646,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            996806463322563,\n            2043104667851348,\n            1110361398300309,\n            1218740346887957,\n        ),\n        u64x4::new_const(\n            399141907016839,\n            1307691109658227,\n            532535384961264,\n            896201194398872,\n        ),\n        u64x4::new_const(\n            111705272106160,\n            1790972382466021,\n            1159338112559144,\n            303544352897203,\n        ),\n        u64x4::new_const(\n            1036600573322969,\n            1457119922663674,\n            334117653665514,\n            460023361701263,\n        ),\n        u64x4::new_const(\n            1363773215189933,\n            1915594049343802,\n            1661249423378694,\n            1744945551969247,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            3093919631215,\n            574886478077610,\n            1704446919728971,\n            250093147254210,\n        ),\n        u64x4::new_const(\n            1387413348737796,\n            360142717826981,\n            2116185073015983,\n            474541388374100,\n        ),\n        u64x4::new_const(\n            1632539630892580,\n            1332404016215719,\n            2145297637794728,\n            1289783723173504,\n        ),\n        u64x4::new_const(\n            1030244179060173,\n            579782698595797,\n            1062365251139982,\n            677149839815546,\n        ),\n        u64x4::new_const(\n            6671539419876,\n            1426937459653775,\n            406942403696343,\n            675479224223817,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            271984148441782,\n            1708099625818957,\n            1499011822959235,\n            516808451044836,\n        ),\n        u64x4::new_const(\n            1124847751346323,\n            2038336022958449,\n            1721698491022600,\n            705944403212572,\n        ),\n        u64x4::new_const(\n            85459783780275,\n            1715213099986669,\n            1728445509034791,\n            730657630359717,\n        ),\n        u64x4::new_const(\n            1185034652652387,\n            755472578204310,\n            476118360897817,\n            1800434542785310,\n        ),\n        u64x4::new_const(\n            1815589628676941,\n            491778500674079,\n            1547664984392513,\n            279891608681267,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            2036337168672113,\n            1730787524684269,\n            639134121311693,\n            698060925015524,\n        ),\n        u64x4::new_const(\n            315211075189491,\n            1329055848835358,\n            688621136402134,\n            1271193060119448,\n        ),\n        u64x4::new_const(\n            1697984374314012,\n            459330773536457,\n            305481314707918,\n            61676911066002,\n        ),\n        u64x4::new_const(\n            2166631826859191,\n            2105217187401781,\n            937587962768434,\n            357397435365683,\n        ),\n        u64x4::new_const(\n            1206757093145471,\n            1287847622009294,\n            1951336140421622,\n            2233789834777410,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            82144190081093,\n            1568417433687791,\n            907555979158442,\n            2037855062523867,\n        ),\n        u64x4::new_const(\n            1225315484058853,\n            315317868015613,\n            1765025920288384,\n            175223259828436,\n        ),\n        u64x4::new_const(\n            1215010304871271,\n            662713408454950,\n            429517658575616,\n            991062684008811,\n        ),\n        u64x4::new_const(\n            993837615254894,\n            1485561584889450,\n            2001836754226476,\n            1915943063896801,\n        ),\n        u64x4::new_const(\n            818895101625673,\n            1342479472068804,\n            1380235330010671,\n            23315169761453,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1500726307559118,\n            956166860173424,\n            512663951564436,\n            1940180717699824,\n        ),\n        u64x4::new_const(\n            1789521472720825,\n            779456898652427,\n            2035063615853504,\n            863582140589407,\n        ),\n        u64x4::new_const(\n            634508890793787,\n            1748041666732214,\n            259642099961634,\n            1294936839797812,\n        ),\n        u64x4::new_const(\n            2183334898697038,\n            2197242820694806,\n            2217225409073703,\n            992633998226449,\n        ),\n        u64x4::new_const(\n            2197077498155916,\n            1562008797791883,\n            1395088759904208,\n            331715244679294,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            186854731652320,\n            284389440026580,\n            1252175415119400,\n            1025377410100223,\n        ),\n        u64x4::new_const(\n            1578732129417607,\n            898645497852382,\n            2237766074482974,\n            1939197790303592,\n        ),\n        u64x4::new_const(\n            1438830390640145,\n            1682452015845597,\n            1108441197232223,\n            1984134492898664,\n        ),\n        u64x4::new_const(\n            282668727301669,\n            1609018289552856,\n            390363439795705,\n            1138459124667912,\n        ),\n        u64x4::new_const(\n            18889015928490,\n            532489638086725,\n            324621535996080,\n            2210046082697453,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            2041327051605378,\n            2244037852176483,\n            2116336876147147,\n            9616672544864,\n        ),\n        u64x4::new_const(\n            969847387559191,\n            1059119127679639,\n            1764630094670633,\n            364568045311834,\n        ),\n        u64x4::new_const(\n            505938893153679,\n            2075421412172902,\n            326984153045666,\n            1959549727324704,\n        ),\n        u64x4::new_const(\n            1088715617911260,\n            13917085151028,\n            950568481355929,\n            23687195265771,\n        ),\n        u64x4::new_const(\n            1798284568673198,\n            808382292203333,\n            2214698741961545,\n            610817203275867,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1731488929623777,\n            1158815615106413,\n            1491090861948525,\n            1428384712900962,\n        ),\n        u64x4::new_const(\n            722237139522457,\n            1514290328911535,\n            1366197913116230,\n            1519472657321210,\n        ),\n        u64x4::new_const(\n            246028966932273,\n            1888239319448405,\n            423720022211163,\n            455243905681470,\n        ),\n        u64x4::new_const(\n            738323403716001,\n            1758018973481179,\n            1180718299482318,\n            1008495946606708,\n        ),\n        u64x4::new_const(\n            334959381596119,\n            1704599537529481,\n            2172191232106896,\n            13502508918495,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            273393076768079,\n            427388720298603,\n            1071733376018227,\n            1715429388968611,\n        ),\n        u64x4::new_const(\n            751776629892313,\n            1965239102856011,\n            541955408230119,\n            831043488876080,\n        ),\n        u64x4::new_const(\n            643718536393104,\n            390543998404644,\n            2176730661486279,\n            499459234889079,\n        ),\n        u64x4::new_const(\n            1482404333915009,\n            865527293526285,\n            507957951411713,\n            216456252558825,\n        ),\n        u64x4::new_const(\n            2210281256300231,\n            1519357818277551,\n            1257866936775246,\n            1689605217672864,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            2135395168187905,\n            2214400157568614,\n            2032983817870823,\n            1124945109072647,\n        ),\n        u64x4::new_const(\n            1602820011758145,\n            906675633903289,\n            782700735390986,\n            2067218823525601,\n        ),\n        u64x4::new_const(\n            786785748926382,\n            1433583123655616,\n            905839404290873,\n            2249680349963778,\n        ),\n        u64x4::new_const(\n            1940824582370584,\n            1610961256326291,\n            285307858781375,\n            1755588655461194,\n        ),\n        u64x4::new_const(\n            233682812055333,\n            2146114223476434,\n            41132209533476,\n            535292431776371,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            600257696476418,\n            18449221564824,\n            1422209458591138,\n            239571584769716,\n        ),\n        u64x4::new_const(\n            2056372917056980,\n            1155290566623531,\n            1252473955568148,\n            1276690716882081,\n        ),\n        u64x4::new_const(\n            246974369025311,\n            658117221519903,\n            2000380937898441,\n            1351183273924850,\n        ),\n        u64x4::new_const(\n            1803747363753112,\n            1736801515030186,\n            2025633577199091,\n            603378480769167,\n        ),\n        u64x4::new_const(\n            57348749438551,\n            1893551220299655,\n            657926732731806,\n            1522499384853705,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            591809128842736,\n            284860517232591,\n            27436696863545,\n            886306697195798,\n        ),\n        u64x4::new_const(\n            2113192175751749,\n            1405882509906423,\n            561316282804847,\n            835573846576266,\n        ),\n        u64x4::new_const(\n            94407289485409,\n            1781534171669004,\n            2098782516531528,\n            598529921520053,\n        ),\n        u64x4::new_const(\n            1860137004504786,\n            2197323407480349,\n            1516772733981532,\n            961740253777086,\n        ),\n        u64x4::new_const(\n            1484139612868217,\n            1593557644636881,\n            838834937143441,\n            36382198263380,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1165898865828562,\n            1153420815042389,\n            1068625028915785,\n            1945927229911090,\n        ),\n        u64x4::new_const(\n            843454394017146,\n            571029655293754,\n            386282254545998,\n            1804608237584150,\n        ),\n        u64x4::new_const(\n            370552451091100,\n            1279105656351124,\n            1864742949668631,\n            2093071521726981,\n        ),\n        u64x4::new_const(\n            1872542389052198,\n            1679083953574330,\n            349872262454465,\n            1470311090717925,\n        ),\n        u64x4::new_const(\n            685345654160323,\n            319718985807814,\n            1359932285384164,\n            1410900103316331,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            2083666668832889,\n            314624387816655,\n            1496694646480345,\n            1946728950459189,\n        ),\n        u64x4::new_const(\n            1579153761571203,\n            508771185291380,\n            1002249659402007,\n            551517831173801,\n        ),\n        u64x4::new_const(\n            2132371471626150,\n            1988122278556533,\n            1552195130653890,\n            1327637750292755,\n        ),\n        u64x4::new_const(\n            118937099181527,\n            382610380973142,\n            634951529106471,\n            382740054041699,\n        ),\n        u64x4::new_const(\n            801287519643470,\n            87822941589258,\n            1908825350108451,\n            1404208826499115,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            330347226380261,\n            672119116965146,\n            1761510370768005,\n            1959200302484704,\n        ),\n        u64x4::new_const(\n            1631876583009250,\n            1684917718484264,\n            1027256947805920,\n            2174612545251129,\n        ),\n        u64x4::new_const(\n            636668855699872,\n            625187713984839,\n            265886954766790,\n            167898557908504,\n        ),\n        u64x4::new_const(\n            1210974548180860,\n            2051308710365526,\n            907620584086428,\n            1081788677970850,\n        ),\n        u64x4::new_const(\n            621792955460854,\n            1450945504745382,\n            1666728650687828,\n            977937146451674,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            24725936182267,\n            2226765032752574,\n            2036560083102883,\n            2002351185719584,\n        ),\n        u64x4::new_const(\n            1620080779405308,\n            1493220053370419,\n            2245691691038916,\n            1152182628629603,\n        ),\n        u64x4::new_const(\n            317928527147500,\n            1855194218440212,\n            979380281964169,\n            861442286685289,\n        ),\n        u64x4::new_const(\n            393308472784625,\n            486143087279967,\n            1234071346236405,\n            777748237119399,\n        ),\n        u64x4::new_const(\n            43850412814718,\n            1497656407486446,\n            744128331046695,\n            1618035787321792,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1670169946550211,\n            1230951698726438,\n            806586940221293,\n            23159779184607,\n        ),\n        u64x4::new_const(\n            634011340979302,\n            764182085034744,\n            731065727766955,\n            1737985776442180,\n        ),\n        u64x4::new_const(\n            240492712141842,\n            73976435954441,\n            162810587166835,\n            697230894340912,\n        ),\n        u64x4::new_const(\n            1299745598348388,\n            1359436039694544,\n            1856609816731554,\n            25228008461513,\n        ),\n        u64x4::new_const(\n            2180690501932381,\n            2161211192848458,\n            87069466793408,\n            2003456332883860,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1106932458043379,\n            1675181364231371,\n            1681785724775243,\n            131824742557210,\n        ),\n        u64x4::new_const(\n            1671649414647169,\n            1827849994880670,\n            1097958057111899,\n            701956891169434,\n        ),\n        u64x4::new_const(\n            2095539283710881,\n            591029812888096,\n            1699571518315654,\n            1297589045812566,\n        ),\n        u64x4::new_const(\n            1345612272298537,\n            2166754730876055,\n            2047982622154948,\n            1785222806258129,\n        ),\n        u64x4::new_const(\n            2181915268829890,\n            1895697064378670,\n            1288412327355885,\n            1561075738281368,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            741330264098392,\n            357073519729966,\n            1603572339180975,\n            433572083688575,\n        ),\n        u64x4::new_const(\n            699685108971208,\n            1719650727634959,\n            1941668009419214,\n            870374958347891,\n        ),\n        u64x4::new_const(\n            385971389331537,\n            11655507719711,\n            94814615497633,\n            515572102810609,\n        ),\n        u64x4::new_const(\n            1396688200590426,\n            1518748475144123,\n            162386454324368,\n            2083303971579002,\n        ),\n        u64x4::new_const(\n            1511688632419263,\n            251584258592336,\n            545345887993880,\n            1229840230314160,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1298668855706029,\n            2017860934939344,\n            2224150456036391,\n            1925926576297971,\n        ),\n        u64x4::new_const(\n            259522963883544,\n            1312469129541229,\n            1647530465049600,\n            1113737129047154,\n        ),\n        u64x4::new_const(\n            733193298663145,\n            2115712816303403,\n            897628702762311,\n            116440277571901,\n        ),\n        u64x4::new_const(\n            1998719395229750,\n            1662774553684237,\n            194395608126452,\n            98796702872301,\n        ),\n        u64x4::new_const(\n            2226158244229144,\n            91961728239158,\n            526869903032152,\n            849263805316773,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            472779569333556,\n            854477760843410,\n            2070906720349401,\n            734613359834689,\n        ),\n        u64x4::new_const(\n            1771897100487404,\n            1604024196006064,\n            319699348925383,\n            437152129592623,\n        ),\n        u64x4::new_const(\n            627618365135361,\n            1768642666037955,\n            588564169143939,\n            35295037750744,\n        ),\n        u64x4::new_const(\n            220241884231278,\n            319104161410840,\n            1048165719448798,\n            1583931089774347,\n        ),\n        u64x4::new_const(\n            166479451884333,\n            1623611819962804,\n            59990366193679,\n            900727256046987,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            1944687327687331,\n            1328410791053991,\n            2083980670913902,\n            609396833380574,\n        ),\n        u64x4::new_const(\n            1907563845734496,\n            1385619047697883,\n            869817384774457,\n            106642388505109,\n        ),\n        u64x4::new_const(\n            1006516581737154,\n            1561918369633937,\n            1921172883211450,\n            2216650451558824,\n        ),\n        u64x4::new_const(\n            1780506017391778,\n            233064930371847,\n            1332962603425752,\n            1380075261612354,\n        ),\n        u64x4::new_const(\n            1907624789747741,\n            1310065402098523,\n            1838275780706825,\n            884225500782782,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            198729830692545,\n            100156148743413,\n            2140568641558859,\n            2220606475942394,\n        ),\n        u64x4::new_const(\n            1108788217903741,\n            1706330932366163,\n            2050449866410661,\n            684907598542847,\n        ),\n        u64x4::new_const(\n            1101958322366646,\n            659427843062405,\n            253899933868173,\n            896574852821269,\n        ),\n        u64x4::new_const(\n            1157052140740658,\n            440541103447032,\n            2173354981480949,\n            604768603561932,\n        ),\n        u64x4::new_const(\n            961238337866054,\n            830849154351308,\n            1643852412409441,\n            1436749321770368,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            784870637473285,\n            1180234052037572,\n            2086951602998715,\n            419328169540373,\n        ),\n        u64x4::new_const(\n            1966862397394559,\n            788036164772123,\n            2024355635709481,\n            1471696676696146,\n        ),\n        u64x4::new_const(\n            1468884300957205,\n            1408016588131185,\n            2229595828577885,\n            240413942963547,\n        ),\n        u64x4::new_const(\n            1481791691942441,\n            970648959691160,\n            1635500996148197,\n            2236917233261585,\n        ),\n        u64x4::new_const(\n            31660820731028,\n            801794768903647,\n            1069092619607344,\n            282652554845923,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            911659428682786,\n            762502588057038,\n            1311399152500807,\n            1966922911783311,\n        ),\n        u64x4::new_const(\n            1229849228728540,\n            258161307933217,\n            2140796867375541,\n            1569345075547911,\n        ),\n        u64x4::new_const(\n            1487354676143742,\n            1818317546165791,\n            811033554173350,\n            1768788663337616,\n        ),\n        u64x4::new_const(\n            450017165913234,\n            962535873747168,\n            2099104262993585,\n            503030952485785,\n        ),\n        u64x4::new_const(\n            1259958681304518,\n            479589250923541,\n            1503904042161640,\n            706283657294305,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            794562643024291,\n            198670993088241,\n            1678984629358943,\n            273399517554618,\n        ),\n        u64x4::new_const(\n            188458991574433,\n            1389872130156447,\n            1461868931574746,\n            795140878721432,\n        ),\n        u64x4::new_const(\n            624046647169653,\n            630363741191019,\n            911018499983500,\n            1410140563046579,\n        ),\n        u64x4::new_const(\n            1675056174405076,\n            632544713589250,\n            795454163559811,\n            1535271563341780,\n        ),\n        u64x4::new_const(\n            25504547444781,\n            812510098987855,\n            51290042016232,\n            1992260991700127,\n        ),\n    ])),\n    CachedPoint(F51x4Reduced([\n        u64x4::new_const(\n            269968325452358,\n            470932785179706,\n            1684444304834150,\n            1027482126748243,\n        ),\n        u64x4::new_const(\n            457941065342419,\n            2117377568137882,\n            1209423706730905,\n            2192403099717071,\n        ),\n        u64x4::new_const(\n            1899046404863678,\n            1359500336071762,\n            1492389156724726,\n            1455627081827750,\n        ),\n        u64x4::new_const(\n            2016101061876546,\n            1967000012916571,\n            582539481696050,\n            1197538178790094,\n        ),\n        u64x4::new_const(\n            639684852217504,\n            1799941252757449,\n            1470016556327743,\n            846111828965901,\n        ),\n    ])),\n]);\n",
    "filename": "curve25519-dalek/src/backend/vector/ifma/constants.rs",
    "filepath": null,
    "folder_id": 15832,
    "user_id": 460154
  },
  "63604": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2018-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n#![doc = include_str!(\"../../../../docs/ifma-notes.md\")]\n\n#[allow(missing_docs)]\npub mod field;\n\n#[allow(missing_docs)]\npub mod edwards;\n\npub mod constants;\n\npub(crate) use self::edwards::{CachedPoint, ExtendedPoint};\n",
    "filename": "curve25519-dalek/src/backend/vector/ifma/mod.rs",
    "filepath": null,
    "folder_id": 15832,
    "user_id": 460154
  },
  "63605": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2019 Henry de Valence.\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Precomputation for Straus's method.\n\n#![allow(non_snake_case)]\n\n#[curve25519_dalek_derive::unsafe_target_feature_specialize(\n    \"avx2\",\n    conditional(\n        \"avx512ifma,avx512vl\",\n        all(curve25519_dalek_backend = \"unstable_avx512\", nightly)\n    )\n)]\npub mod spec {\n\n    use alloc::vec::Vec;\n\n    use core::borrow::Borrow;\n    use core::cmp::Ordering;\n\n    #[for_target_feature(\"avx2\")]\n    use crate::backend::vector::avx2::{CachedPoint, ExtendedPoint};\n\n    #[for_target_feature(\"avx512ifma\")]\n    use crate::backend::vector::ifma::{CachedPoint, ExtendedPoint};\n\n    use crate::edwards::EdwardsPoint;\n    use crate::scalar::Scalar;\n    use crate::traits::Identity;\n    use crate::traits::VartimePrecomputedMultiscalarMul;\n    use crate::window::{NafLookupTable5, NafLookupTable8};\n\n    pub struct VartimePrecomputedStraus {\n        static_lookup_tables: Vec<NafLookupTable8<CachedPoint>>,\n    }\n\n    impl VartimePrecomputedMultiscalarMul for VartimePrecomputedStraus {\n        type Point = EdwardsPoint;\n\n        fn new<I>(static_points: I) -> Self\n        where\n            I: IntoIterator,\n            I::Item: Borrow<EdwardsPoint>,\n        {\n            Self {\n                static_lookup_tables: static_points\n                    .into_iter()\n                    .map(|P| NafLookupTable8::<CachedPoint>::from(P.borrow()))\n                    .collect(),\n            }\n        }\n\n        fn len(&self) -> usize {\n            self.static_lookup_tables.len()\n        }\n\n        fn is_empty(&self) -> bool {\n            self.static_lookup_tables.is_empty()\n        }\n\n        fn optional_mixed_multiscalar_mul<I, J, K>(\n            &self,\n            static_scalars: I,\n            dynamic_scalars: J,\n            dynamic_points: K,\n        ) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator,\n            J::Item: Borrow<Scalar>,\n            K: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let static_nafs = static_scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect::<Vec<_>>();\n            let dynamic_nafs: Vec<_> = dynamic_scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect::<Vec<_>>();\n\n            let dynamic_lookup_tables = dynamic_points\n                .into_iter()\n                .map(|P_opt| P_opt.map(|P| NafLookupTable5::<CachedPoint>::from(&P)))\n                .collect::<Option<Vec<_>>>()?;\n\n            let sp = self.static_lookup_tables.len();\n            let dp = dynamic_lookup_tables.len();\n            assert!(sp >= static_nafs.len());\n            assert_eq!(dp, dynamic_nafs.len());\n\n            // We could save some doublings by looking for the highest\n            // nonzero NAF coefficient, but since we might have a lot of\n            // them to search, it's not clear it's worthwhile to check.\n            let mut R = ExtendedPoint::identity();\n            for j in (0..256).rev() {\n                R = R.double();\n\n                for i in 0..dp {\n                    let t_ij = dynamic_nafs[i][j];\n                    match t_ij.cmp(&0) {\n                        Ordering::Greater => {\n                            R = &R + &dynamic_lookup_tables[i].select(t_ij as usize);\n                        }\n                        Ordering::Less => {\n                            R = &R - &dynamic_lookup_tables[i].select(-t_ij as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..static_nafs.len() {\n                    let t_ij = static_nafs[i][j];\n                    match t_ij.cmp(&0) {\n                        Ordering::Greater => {\n                            R = &R + &self.static_lookup_tables[i].select(t_ij as usize);\n                        }\n                        Ordering::Less => {\n                            R = &R - &self.static_lookup_tables[i].select(-t_ij as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n            }\n\n            Some(R.into())\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/scalar_mul/precomputed_straus.rs",
    "filepath": null,
    "folder_id": 15833,
    "user_id": 460154
  },
  "63606": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2019 Oleg Andreev\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Oleg Andreev <oleganza@gmail.com>\n\n#![allow(non_snake_case)]\n\n#[curve25519_dalek_derive::unsafe_target_feature_specialize(\n    \"avx2\",\n    conditional(\n        \"avx512ifma,avx512vl\",\n        all(curve25519_dalek_backend = \"unstable_avx512\", nightly)\n    )\n)]\npub mod spec {\n\n    use alloc::vec::Vec;\n\n    use core::borrow::Borrow;\n    use core::cmp::Ordering;\n\n    #[for_target_feature(\"avx2\")]\n    use crate::backend::vector::avx2::{CachedPoint, ExtendedPoint};\n\n    #[for_target_feature(\"avx512ifma\")]\n    use crate::backend::vector::ifma::{CachedPoint, ExtendedPoint};\n\n    use crate::edwards::EdwardsPoint;\n    use crate::scalar::Scalar;\n    use crate::traits::{Identity, VartimeMultiscalarMul};\n\n    /// Implements a version of Pippenger's algorithm.\n    ///\n    /// See the documentation in the serial `scalar_mul::pippenger` module for details.\n    pub struct Pippenger;\n\n    impl VartimeMultiscalarMul for Pippenger {\n        type Point = EdwardsPoint;\n\n        fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let mut scalars = scalars.into_iter();\n            let size = scalars.by_ref().size_hint().0;\n            let w = if size < 500 {\n                6\n            } else if size < 800 {\n                7\n            } else {\n                8\n            };\n\n            let max_digit: usize = 1 << w;\n            let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n            let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n            // Collect optimized scalars and points in a buffer for repeated access\n            // (scanning the whole collection per each digit position).\n            let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n            let points = points\n                .into_iter()\n                .map(|p| p.map(|P| CachedPoint::from(ExtendedPoint::from(P))));\n\n            let scalars_points = scalars\n                .zip(points)\n                .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n                .collect::<Option<Vec<_>>>()?;\n\n            // Prepare 2^w/2 buckets.\n            // buckets[i] corresponds to a multiplication factor (i+1).\n            let mut buckets: Vec<ExtendedPoint> = (0..buckets_count)\n                .map(|_| ExtendedPoint::identity())\n                .collect();\n\n            let mut columns = (0..digits_count).rev().map(|digit_index| {\n                // Clear the buckets when processing another digit.\n                for bucket in &mut buckets {\n                    *bucket = ExtendedPoint::identity();\n                }\n\n                // Iterate over pairs of (point, scalar)\n                // and add/sub the point to the corresponding bucket.\n                // Note: if we add support for precomputed lookup tables,\n                // we'll be adding/subtractiong point premultiplied by `digits[i]` to buckets[0].\n                for (digits, pt) in scalars_points.iter() {\n                    // Widen digit so that we don't run into edge cases when w=8.\n                    let digit = digits[digit_index] as i16;\n                    match digit.cmp(&0) {\n                        Ordering::Greater => {\n                            let b = (digit - 1) as usize;\n                            buckets[b] = &buckets[b] + pt;\n                        }\n                        Ordering::Less => {\n                            let b = (-digit - 1) as usize;\n                            buckets[b] = &buckets[b] - pt;\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n\n                // Add the buckets applying the multiplication factor to each bucket.\n                // The most efficient way to do that is to have a single sum with two running sums:\n                // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n                //\n                // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n                //   C\n                //   C B\n                //   C B A   Sum = C + (C+B) + (C+B+A)\n                let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n                let mut buckets_sum = buckets[buckets_count - 1];\n                for i in (0..(buckets_count - 1)).rev() {\n                    buckets_intermediate_sum =\n                        &buckets_intermediate_sum + &CachedPoint::from(buckets[i]);\n                    buckets_sum = &buckets_sum + &CachedPoint::from(buckets_intermediate_sum);\n                }\n\n                buckets_sum\n            });\n\n            // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n            let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n            Some(\n                columns\n                    .fold(hi_column, |total, p| {\n                        &total.mul_by_pow_2(w as u32) + &CachedPoint::from(p)\n                    })\n                    .into(),\n            )\n        }\n    }\n\n    #[cfg(test)]\n    mod test {\n        #[test]\n        fn test_vartime_pippenger() {\n            use super::*;\n            use crate::constants;\n            use crate::scalar::Scalar;\n\n            // Reuse points across different tests\n            let mut n = 512;\n            let x = Scalar::from(2128506u64).invert();\n            let y = Scalar::from(4443282u64).invert();\n            let points: Vec<_> = (0..n)\n                .map(|i| constants::ED25519_BASEPOINT_POINT * Scalar::from(1 + i as u64))\n                .collect();\n            let scalars: Vec<_> = (0..n)\n                .map(|i| x + (Scalar::from(i as u64) * y)) // fast way to make ~random but deterministic scalars\n                .collect();\n\n            let premultiplied: Vec<EdwardsPoint> = scalars\n                .iter()\n                .zip(points.iter())\n                .map(|(sc, pt)| sc * pt)\n                .collect();\n\n            while n > 0 {\n                let scalars = &scalars[0..n].to_vec();\n                let points = &points[0..n].to_vec();\n                let control: EdwardsPoint = premultiplied[0..n].iter().sum();\n\n                let subject = Pippenger::vartime_multiscalar_mul(scalars.clone(), points.clone());\n\n                assert_eq!(subject.compress(), control.compress());\n\n                n = n / 2;\n            }\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/scalar_mul/pippenger.rs",
    "filepath": null,
    "folder_id": 15833,
    "user_id": 460154
  },
  "63607": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n#![allow(non_snake_case)]\n\n#[curve25519_dalek_derive::unsafe_target_feature_specialize(\n    \"avx2\",\n    conditional(\n        \"avx512ifma,avx512vl\",\n        all(curve25519_dalek_backend = \"unstable_avx512\", nightly)\n    )\n)]\npub mod spec {\n\n    use alloc::vec::Vec;\n\n    use core::borrow::Borrow;\n    use core::cmp::Ordering;\n\n    #[cfg(feature = \"zeroize\")]\n    use zeroize::Zeroizing;\n\n    #[for_target_feature(\"avx2\")]\n    use crate::backend::vector::avx2::{CachedPoint, ExtendedPoint};\n\n    #[for_target_feature(\"avx512ifma\")]\n    use crate::backend::vector::ifma::{CachedPoint, ExtendedPoint};\n\n    use crate::edwards::EdwardsPoint;\n    use crate::scalar::Scalar;\n    use crate::traits::{Identity, MultiscalarMul, VartimeMultiscalarMul};\n    use crate::window::{LookupTable, NafLookupTable5};\n\n    /// Multiscalar multiplication using interleaved window / Straus'\n    /// method.  See the `Straus` struct in the serial backend for more\n    /// details.\n    ///\n    /// This exists as a separate implementation from that one because the\n    /// AVX2 code uses different curve models (it does not pass between\n    /// multiple models during scalar mul), and it has to convert the\n    /// point representation on the fly.\n    pub struct Straus {}\n\n    impl MultiscalarMul for Straus {\n        type Point = EdwardsPoint;\n\n        fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator,\n            J::Item: Borrow<EdwardsPoint>,\n        {\n            // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n            // for each input point P\n            let lookup_tables: Vec<_> = points\n                .into_iter()\n                .map(|point| LookupTable::<CachedPoint>::from(point.borrow()))\n                .collect();\n\n            let scalar_digits_vec: Vec<_> = scalars\n                .into_iter()\n                .map(|s| s.borrow().as_radix_16())\n                .collect();\n            // Pass ownership to a `Zeroizing` wrapper\n            #[cfg(feature = \"zeroize\")]\n            let scalar_digits_vec = Zeroizing::new(scalar_digits_vec);\n\n            let mut Q = ExtendedPoint::identity();\n            for j in (0..64).rev() {\n                Q = Q.mul_by_pow_2(4);\n                let it = scalar_digits_vec.iter().zip(lookup_tables.iter());\n                for (s_i, lookup_table_i) in it {\n                    // Q = Q + s_{i,j} * P_i\n                    Q = &Q + &lookup_table_i.select(s_i[j]);\n                }\n            }\n            Q.into()\n        }\n    }\n\n    impl VartimeMultiscalarMul for Straus {\n        type Point = EdwardsPoint;\n\n        fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n        where\n            I: IntoIterator,\n            I::Item: Borrow<Scalar>,\n            J: IntoIterator<Item = Option<EdwardsPoint>>,\n        {\n            let nafs: Vec<_> = scalars\n                .into_iter()\n                .map(|c| c.borrow().non_adjacent_form(5))\n                .collect();\n            let lookup_tables: Vec<_> = points\n                .into_iter()\n                .map(|P_opt| P_opt.map(|P| NafLookupTable5::<CachedPoint>::from(&P)))\n                .collect::<Option<Vec<_>>>()?;\n\n            let mut Q = ExtendedPoint::identity();\n\n            for i in (0..256).rev() {\n                Q = Q.double();\n\n                for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                    match naf[i].cmp(&0) {\n                        Ordering::Greater => {\n                            Q = &Q + &lookup_table.select(naf[i] as usize);\n                        }\n                        Ordering::Less => {\n                            Q = &Q - &lookup_table.select(-naf[i] as usize);\n                        }\n                        Ordering::Equal => {}\n                    }\n                }\n            }\n\n            Some(Q.into())\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/scalar_mul/straus.rs",
    "filepath": null,
    "folder_id": 15833,
    "user_id": 460154
  },
  "63608": {
    "text": "#![allow(non_snake_case)]\n\n#[curve25519_dalek_derive::unsafe_target_feature_specialize(\n    \"avx2\",\n    conditional(\n        \"avx512ifma,avx512vl\",\n        all(curve25519_dalek_backend = \"unstable_avx512\", nightly)\n    )\n)]\npub mod spec {\n\n    #[for_target_feature(\"avx2\")]\n    use crate::backend::vector::avx2::{CachedPoint, ExtendedPoint};\n\n    #[for_target_feature(\"avx512ifma\")]\n    use crate::backend::vector::ifma::{CachedPoint, ExtendedPoint};\n\n    use crate::edwards::EdwardsPoint;\n    use crate::scalar::Scalar;\n    use crate::traits::Identity;\n    use crate::window::LookupTable;\n\n    /// Perform constant-time, variable-base scalar multiplication.\n    pub fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n        // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n        let lookup_table = LookupTable::<CachedPoint>::from(point);\n        // Setting s = scalar, compute\n        //\n        //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n        //\n        // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n        let scalar_digits = scalar.as_radix_16();\n        // Compute s*P as\n        //\n        //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n        //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n        //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n        //\n        // We sum right-to-left.\n        let mut Q = ExtendedPoint::identity();\n        for i in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            Q = &Q + &lookup_table.select(scalar_digits[i]);\n        }\n        Q.into()\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/scalar_mul/variable_base.rs",
    "filepath": null,
    "folder_id": 15833,
    "user_id": 460154
  },
  "63609": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Implementations of various multiplication algorithms for the SIMD backends.\n\n#[allow(missing_docs)]\npub mod variable_base;\n\n#[allow(missing_docs)]\npub mod vartime_double_base;\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub mod straus;\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub mod precomputed_straus;\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub mod pippenger;\n",
    "filename": "curve25519-dalek/src/backend/vector/scalar_mul/mod.rs",
    "filepath": null,
    "folder_id": 15833,
    "user_id": 460154
  },
  "63610": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n#![allow(non_snake_case)]\n\n#[curve25519_dalek_derive::unsafe_target_feature_specialize(\n    \"avx2\",\n    conditional(\n        \"avx512ifma,avx512vl\",\n        all(curve25519_dalek_backend = \"unstable_avx512\", nightly)\n    )\n)]\npub mod spec {\n\n    use core::cmp::Ordering;\n\n    #[for_target_feature(\"avx2\")]\n    use crate::backend::vector::avx2::{CachedPoint, ExtendedPoint};\n\n    #[for_target_feature(\"avx512ifma\")]\n    use crate::backend::vector::ifma::{CachedPoint, ExtendedPoint};\n\n    #[cfg(feature = \"precomputed-tables\")]\n    #[for_target_feature(\"avx2\")]\n    use crate::backend::vector::avx2::constants::BASEPOINT_ODD_LOOKUP_TABLE;\n\n    #[cfg(feature = \"precomputed-tables\")]\n    #[for_target_feature(\"avx512ifma\")]\n    use crate::backend::vector::ifma::constants::BASEPOINT_ODD_LOOKUP_TABLE;\n\n    use crate::edwards::EdwardsPoint;\n    use crate::scalar::Scalar;\n    use crate::traits::Identity;\n    use crate::window::NafLookupTable5;\n\n    /// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.\n    pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n        let a_naf = a.non_adjacent_form(5);\n\n        #[cfg(feature = \"precomputed-tables\")]\n        let b_naf = b.non_adjacent_form(8);\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        let b_naf = b.non_adjacent_form(5);\n\n        // Find starting index\n        let mut i: usize = 255;\n        for j in (0..256).rev() {\n            i = j;\n            if a_naf[i] != 0 || b_naf[i] != 0 {\n                break;\n            }\n        }\n\n        let table_A = NafLookupTable5::<CachedPoint>::from(A);\n\n        #[cfg(feature = \"precomputed-tables\")]\n        let table_B = &BASEPOINT_ODD_LOOKUP_TABLE;\n\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        let table_B =\n            &NafLookupTable5::<CachedPoint>::from(&crate::constants::ED25519_BASEPOINT_POINT);\n\n        let mut Q = ExtendedPoint::identity();\n\n        loop {\n            Q = Q.double();\n\n            match a_naf[i].cmp(&0) {\n                Ordering::Greater => {\n                    Q = &Q + &table_A.select(a_naf[i] as usize);\n                }\n                Ordering::Less => {\n                    Q = &Q - &table_A.select(-a_naf[i] as usize);\n                }\n                Ordering::Equal => {}\n            }\n\n            match b_naf[i].cmp(&0) {\n                Ordering::Greater => {\n                    Q = &Q + &table_B.select(b_naf[i] as usize);\n                }\n                Ordering::Less => {\n                    Q = &Q - &table_B.select(-b_naf[i] as usize);\n                }\n                Ordering::Equal => {}\n            }\n\n            if i == 0 {\n                break;\n            }\n            i -= 1;\n        }\n\n        Q.into()\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/scalar_mul/vartime_double_base.rs",
    "filepath": null,
    "folder_id": 15833,
    "user_id": 460154
  },
  "63611": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// See LICENSE for licensing information.\n\n// Nightly and stable currently disagree on the requirement of unsafe blocks when `unsafe_target_feature`\n// gets used.\n// See: https://github.com/rust-lang/rust/issues/132856\n#![allow(unused_unsafe)]\n\n//! This module defines wrappers over platform-specific SIMD types to make them\n//! more convenient to use.\n//!\n//! UNSAFETY: Everything in this module assumes that we're running on hardware\n//!           which supports at least AVX2. This invariant *must* be enforced\n//!           by the callers of this code.\nuse core::ops::{Add, AddAssign, BitAnd, BitAndAssign, BitXor, BitXorAssign, Sub};\n\nuse curve25519_dalek_derive::unsafe_target_feature;\n\nmacro_rules! impl_shared {\n    (\n        $ty:ident,\n        $lane_ty:ident,\n        $add_intrinsic:ident,\n        $sub_intrinsic:ident,\n        $shl_intrinsic:ident,\n        $shr_intrinsic:ident,\n        $extract_intrinsic:ident\n    ) => {\n        #[allow(non_camel_case_types)]\n        #[derive(Copy, Clone, Debug)]\n        #[repr(transparent)]\n        pub struct $ty(core::arch::x86_64::__m256i);\n\n        #[unsafe_target_feature(\"avx2\")]\n        impl From<$ty> for core::arch::x86_64::__m256i {\n            #[inline]\n            fn from(value: $ty) -> core::arch::x86_64::__m256i {\n                value.0\n            }\n        }\n\n        #[unsafe_target_feature(\"avx2\")]\n        impl From<core::arch::x86_64::__m256i> for $ty {\n            #[inline]\n            fn from(value: core::arch::x86_64::__m256i) -> $ty {\n                $ty(value)\n            }\n        }\n\n        #[unsafe_target_feature(\"avx2\")]\n        impl PartialEq for $ty {\n            #[inline]\n            fn eq(&self, rhs: &$ty) -> bool {\n                unsafe {\n                    // This compares each pair of 8-bit packed integers and returns either 0xFF or\n                    // 0x00 depending on whether they're equal.\n                    //\n                    // So the values are equal if (and only if) this returns a value that's filled\n                    // with only 0xFF.\n                    //\n                    // Pseudocode of what this does:\n                    //     self.0\n                    //         .bytes()\n                    //         .zip(rhs.0.bytes())\n                    //         .map(|a, b| if a == b { 0xFF } else { 0x00 })\n                    //         .join();\n                    let m = core::arch::x86_64::_mm256_cmpeq_epi8(self.0, rhs.0);\n\n                    // Now we need to reduce the 256-bit value to something on which we can branch.\n                    //\n                    // This will just take the most significant bit of every 8-bit packed integer\n                    // and build an `i32` out of it. If the values we previously compared were\n                    // equal then all off the most significant bits will be equal to 1, which means\n                    // that this will return 0xFFFFFFFF, which is equal to -1 when represented as\n                    // an `i32`.\n                    core::arch::x86_64::_mm256_movemask_epi8(m) == -1\n                }\n            }\n        }\n\n        impl Eq for $ty {}\n\n        #[unsafe_target_feature(\"avx2\")]\n        impl Add for $ty {\n            type Output = Self;\n\n            #[inline]\n            fn add(self, rhs: $ty) -> Self {\n                unsafe { core::arch::x86_64::$add_intrinsic(self.0, rhs.0).into() }\n            }\n        }\n\n        #[allow(clippy::assign_op_pattern)]\n        #[unsafe_target_feature(\"avx2\")]\n        impl AddAssign for $ty {\n            #[inline]\n            fn add_assign(&mut self, rhs: $ty) {\n                *self = *self + rhs\n            }\n        }\n\n        #[unsafe_target_feature(\"avx2\")]\n        impl Sub for $ty {\n            type Output = Self;\n\n            #[inline]\n            fn sub(self, rhs: $ty) -> Self {\n                unsafe { core::arch::x86_64::$sub_intrinsic(self.0, rhs.0).into() }\n            }\n        }\n\n        #[unsafe_target_feature(\"avx2\")]\n        impl BitAnd for $ty {\n            type Output = Self;\n\n            #[inline]\n            fn bitand(self, rhs: $ty) -> Self {\n                unsafe { core::arch::x86_64::_mm256_and_si256(self.0, rhs.0).into() }\n            }\n        }\n\n        #[unsafe_target_feature(\"avx2\")]\n        impl BitXor for $ty {\n            type Output = Self;\n\n            #[inline]\n            fn bitxor(self, rhs: $ty) -> Self {\n                unsafe { core::arch::x86_64::_mm256_xor_si256(self.0, rhs.0).into() }\n            }\n        }\n\n        #[allow(clippy::assign_op_pattern)]\n        #[unsafe_target_feature(\"avx2\")]\n        impl BitAndAssign for $ty {\n            #[inline]\n            fn bitand_assign(&mut self, rhs: $ty) {\n                *self = *self & rhs;\n            }\n        }\n\n        #[allow(clippy::assign_op_pattern)]\n        #[unsafe_target_feature(\"avx2\")]\n        impl BitXorAssign for $ty {\n            #[inline]\n            fn bitxor_assign(&mut self, rhs: $ty) {\n                *self = *self ^ rhs;\n            }\n        }\n\n        #[unsafe_target_feature(\"avx2\")]\n        #[allow(dead_code)]\n        impl $ty {\n            #[inline]\n            pub fn shl<const N: i32>(self) -> Self {\n                unsafe { core::arch::x86_64::$shl_intrinsic(self.0, N).into() }\n            }\n\n            #[inline]\n            pub fn shr<const N: i32>(self) -> Self {\n                unsafe { core::arch::x86_64::$shr_intrinsic(self.0, N).into() }\n            }\n\n            #[inline]\n            pub fn extract<const N: i32>(self) -> $lane_ty {\n                unsafe { core::arch::x86_64::$extract_intrinsic(self.0, N) as $lane_ty }\n            }\n        }\n    };\n}\n\nmacro_rules! impl_conv {\n    ($src:ident => $($dst:ident),+) => {\n        $(\n            #[unsafe_target_feature(\"avx2\")]\n            impl From<$src> for $dst {\n                #[inline]\n                fn from(value: $src) -> $dst {\n                    $dst(value.0)\n                }\n            }\n        )+\n    }\n}\n\n// We define SIMD functionality over packed unsigned integer types. However, all the integer\n// intrinsics deal with signed integers. So we cast unsigned to signed, pack it into SIMD, do\n// add/sub/shl/shr arithmetic, and finally cast back to unsigned at the end. Why is this equivalent\n// to doing the same thing on unsigned integers? Shl/shr is clear, because casting does not change\n// the bits of the integer. But what about add/sub? This is due to the following:\n//\n//     1) Rust uses two's complement to represent signed integers. So we're assured that the values\n//        we cast into SIMD and extract out at the end are two's complement.\n//\n//        https://doc.rust-lang.org/reference/types/numeric.html\n//\n//     2) Wrapping add/sub is compatible between two's complement signed and unsigned integers.\n//        That is, for all x,y: u64 (or any unsigned integer type),\n//\n//            x.wrapping_add(y) == (x as i64).wrapping_add(y as i64) as u64, and\n//            x.wrapping_sub(y) == (x as i64).wrapping_sub(y as i64) as u64\n//\n//        https://julesjacobs.com/2019/03/20/why-twos-complement-works.html\n//\n//     3) The add/sub functions we use for SIMD are indeed wrapping. The docs indicate that\n//        __mm256_add/sub compile to vpaddX/vpsubX instructions where X = w, d, or q depending on\n//        the bitwidth. From x86 docs:\n//\n//            When an individual result is too large to be represented in X bits (overflow), the\n//            result is wrapped around and the low X bits are written to the destination operand\n//            (that is, the carry is ignored).\n//\n//        https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq\n//        https://www.felixcloutier.com/x86/psubb:psubw:psubd\n//        https://www.felixcloutier.com/x86/psubq\n\nimpl_shared!(\n    u64x4,\n    u64,\n    _mm256_add_epi64,\n    _mm256_sub_epi64,\n    _mm256_slli_epi64,\n    _mm256_srli_epi64,\n    _mm256_extract_epi64\n);\nimpl_shared!(\n    u32x8,\n    u32,\n    _mm256_add_epi32,\n    _mm256_sub_epi32,\n    _mm256_slli_epi32,\n    _mm256_srli_epi32,\n    _mm256_extract_epi32\n);\n\nimpl_conv!(u64x4 => u32x8);\n\n#[allow(dead_code)]\nimpl u64x4 {\n    /// A constified variant of `new`.\n    ///\n    /// Should only be called from `const` contexts. At runtime `new` is going to be faster.\n    #[inline]\n    pub const fn new_const(x0: u64, x1: u64, x2: u64, x3: u64) -> Self {\n        // SAFETY: Transmuting between an array and a SIMD type is safe\n        // https://rust-lang.github.io/unsafe-code-guidelines/layout/packed-simd-vectors.html\n        unsafe {\n            Self(core::mem::transmute::<[u64; 4], core::arch::x86_64::__m256i>([x0, x1, x2, x3]))\n        }\n    }\n\n    /// A constified variant of `splat`.\n    ///\n    /// Should only be called from `const` contexts. At runtime `splat` is going to be faster.\n    #[inline]\n    pub const fn splat_const<const N: u64>() -> Self {\n        Self::new_const(N, N, N, N)\n    }\n\n    /// Constructs a new instance.\n    #[unsafe_target_feature(\"avx2\")]\n    #[inline]\n    pub fn new(x0: u64, x1: u64, x2: u64, x3: u64) -> u64x4 {\n        unsafe {\n            // _mm256_set_epi64 sets the underlying vector in reverse order of the args\n            u64x4(core::arch::x86_64::_mm256_set_epi64x(\n                x3 as i64, x2 as i64, x1 as i64, x0 as i64,\n            ))\n        }\n    }\n\n    /// Constructs a new instance with all of the elements initialized to the given value.\n    #[unsafe_target_feature(\"avx2\")]\n    #[inline]\n    pub fn splat(x: u64) -> u64x4 {\n        unsafe { u64x4(core::arch::x86_64::_mm256_set1_epi64x(x as i64)) }\n    }\n}\n\n#[allow(dead_code)]\nimpl u32x8 {\n    /// A constified variant of `new`.\n    ///\n    /// Should only be called from `const` contexts. At runtime `new` is going to be faster.\n    #[allow(clippy::too_many_arguments)]\n    #[inline]\n    pub const fn new_const(\n        x0: u32,\n        x1: u32,\n        x2: u32,\n        x3: u32,\n        x4: u32,\n        x5: u32,\n        x6: u32,\n        x7: u32,\n    ) -> Self {\n        // SAFETY: Transmuting between an array and a SIMD type is safe\n        // https://rust-lang.github.io/unsafe-code-guidelines/layout/packed-simd-vectors.html\n        unsafe {\n            Self(\n                core::mem::transmute::<[u32; 8], core::arch::x86_64::__m256i>([\n                    x0, x1, x2, x3, x4, x5, x6, x7,\n                ]),\n            )\n        }\n    }\n\n    /// A constified variant of `splat`.\n    ///\n    /// Should only be called from `const` contexts. At runtime `splat` is going to be faster.\n    #[inline]\n    pub const fn splat_const<const N: u32>() -> Self {\n        Self::new_const(N, N, N, N, N, N, N, N)\n    }\n\n    /// Constructs a new instance.\n    #[allow(clippy::too_many_arguments)]\n    #[unsafe_target_feature(\"avx2\")]\n    #[inline]\n    pub fn new(x0: u32, x1: u32, x2: u32, x3: u32, x4: u32, x5: u32, x6: u32, x7: u32) -> u32x8 {\n        unsafe {\n            // _mm256_set_epi32 sets the underlying vector in reverse order of the args\n            u32x8(core::arch::x86_64::_mm256_set_epi32(\n                x7 as i32, x6 as i32, x5 as i32, x4 as i32, x3 as i32, x2 as i32, x1 as i32,\n                x0 as i32,\n            ))\n        }\n    }\n\n    /// Constructs a new instance with all of the elements initialized to the given value.\n    #[unsafe_target_feature(\"avx2\")]\n    #[inline]\n    pub fn splat(x: u32) -> u32x8 {\n        unsafe { u32x8(core::arch::x86_64::_mm256_set1_epi32(x as i32)) }\n    }\n}\n\n#[unsafe_target_feature(\"avx2\")]\nimpl u32x8 {\n    /// Multiplies the low unsigned 32-bits from each packed 64-bit element\n    /// and returns the unsigned 64-bit results.\n    ///\n    /// (This ignores the upper 32-bits from each packed 64-bits!)\n    #[inline]\n    pub fn mul32(self, rhs: u32x8) -> u64x4 {\n        // NOTE: This ignores the upper 32-bits from each packed 64-bits.\n        unsafe { core::arch::x86_64::_mm256_mul_epu32(self.0, rhs.0).into() }\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/vector/packed_simd.rs",
    "filepath": null,
    "folder_id": 15830,
    "user_id": 460154
  },
  "63612": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n#![doc = include_str!(\"../../../docs/parallel-formulas.md\")]\n\n#[allow(missing_docs)]\npub mod packed_simd;\n\npub mod avx2;\n\n#[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\npub mod ifma;\n\npub mod scalar_mul;\n",
    "filename": "curve25519-dalek/src/backend/vector/mod.rs",
    "filepath": null,
    "folder_id": 15830,
    "user_id": 460154
  },
  "63613": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! **INTERNALS:** Pluggable implementations for different architectures.\n//!\n//! The backend code is split into two parts: a serial backend,\n//! and a vector backend.\n//!\n//! The [`serial`] backend contains 32- and 64-bit implementations of\n//! field arithmetic and scalar arithmetic, as well as implementations\n//! of point operations using the mixed-model strategy (passing\n//! between different curve models depending on the operation).\n//!\n//! The [`vector`] backend contains implementations of vectorized\n//! field arithmetic, used to implement point operations using a novel\n//! implementation strategy derived from parallel formulas of Hisil,\n//! Wong, Carter, and Dawson.\n//!\n//! Because the two strategies give rise to different curve models,\n//! it's not possible to reuse exactly the same scalar multiplication\n//! code (or to write it generically), so both serial and vector\n//! backends contain matching implementations of scalar multiplication\n//! algorithms.  These are intended to be selected by a `#[cfg]`-based\n//! type alias.\n//!\n//! The [`vector`] backend is selected by the `simd_backend` cargo\n//! feature; it uses the [`serial`] backend for non-vectorized operations.\n\nuse crate::EdwardsPoint;\nuse crate::Scalar;\n\npub mod serial;\n\n#[cfg(curve25519_dalek_backend = \"simd\")]\npub mod vector;\n\n#[derive(Copy, Clone)]\nenum BackendKind {\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    Avx2,\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    Avx512,\n    Serial,\n}\n\n#[inline]\nfn get_selected_backend() -> BackendKind {\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    {\n        cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n        let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n        if token_avx512.get() {\n            return BackendKind::Avx512;\n        }\n    }\n\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    {\n        cpufeatures::new!(cpuid_avx2, \"avx2\");\n        let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n        if token_avx2.get() {\n            return BackendKind::Avx2;\n        }\n    }\n\n    BackendKind::Serial\n}\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub fn pippenger_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 =>\n            vector::scalar_mul::pippenger::spec_avx2::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 =>\n            vector::scalar_mul::pippenger::spec_avx512ifma_avx512vl::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        BackendKind::Serial =>\n            serial::scalar_mul::pippenger::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n    }\n}\n\n#[cfg(feature = \"alloc\")]\npub(crate) enum VartimePrecomputedStraus {\n    #[cfg(curve25519_dalek_backend = \"simd\")]\n    Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus),\n    #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    Avx512ifma(\n        vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus,\n    ),\n    Scalar(serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus),\n}\n\n#[cfg(feature = \"alloc\")]\nimpl VartimePrecomputedStraus {\n    pub fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<EdwardsPoint>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match get_selected_backend() {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            BackendKind::Avx2 =>\n                VartimePrecomputedStraus::Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus::new(static_points)),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            BackendKind::Avx512 =>\n                VartimePrecomputedStraus::Avx512ifma(vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus::new(static_points)),\n            BackendKind::Serial =>\n                VartimePrecomputedStraus::Scalar(serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus::new(static_points))\n        }\n    }\n\n    /// Return the number of static points in the precomputation.\n    pub fn len(&self) -> usize {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.len(),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.len(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.len(),\n        }\n    }\n\n    /// Determine if the precomputation is empty.\n    pub fn is_empty(&self) -> bool {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.is_empty(),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.is_empty(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.is_empty(),\n        }\n    }\n\n    pub fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: core::borrow::Borrow<Scalar>,\n        K: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            #[cfg(curve25519_dalek_backend = \"simd\")]\n            VartimePrecomputedStraus::Avx2(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n            #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }\n}\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub fn straus_multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator,\n    J::Item: core::borrow::Borrow<EdwardsPoint>,\n{\n    use crate::traits::MultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => {\n            vector::scalar_mul::straus::spec_avx2::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}\n\n#[allow(missing_docs)]\n#[cfg(feature = \"alloc\")]\npub fn straus_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => {\n            vector::scalar_mul::straus::spec_avx2::Straus::optional_multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::optional_multiscalar_mul::<\n                I,\n                J,\n            >(scalars, points)\n        }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::optional_multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}\n\n/// Perform constant-time, variable-base scalar multiplication.\npub fn variable_base_mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => vector::scalar_mul::variable_base::spec_avx2::mul(point, scalar),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::variable_base::spec_avx512ifma_avx512vl::mul(point, scalar)\n        }\n        BackendKind::Serial => serial::scalar_mul::variable_base::mul(point, scalar),\n    }\n}\n\n/// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.\n#[allow(non_snake_case)]\npub fn vartime_double_base_mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        #[cfg(curve25519_dalek_backend = \"simd\")]\n        BackendKind::Avx2 => vector::scalar_mul::vartime_double_base::spec_avx2::mul(a, A, b),\n        #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        BackendKind::Avx512 => {\n            vector::scalar_mul::vartime_double_base::spec_avx512ifma_avx512vl::mul(a, A, b)\n        }\n        BackendKind::Serial => serial::scalar_mul::vartime_double_base::mul(a, A, b),\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/mod.rs",
    "filepath": null,
    "folder_id": 15829,
    "user_id": 460154
  },
  "63614": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Internal curve representations which are not part of the public API.\n//!\n//! # Curve representations\n//!\n//! Internally, we use several different models for the curve.  Here\n//! is a sketch of the relationship between the models, following [a\n//! post][smith-moderncrypto]\n//! by Ben Smith on the `moderncrypto` mailing list.  This is also briefly\n//! discussed in section 2.5 of [_Montgomery curves and their\n//! arithmetic_][costello-smith-2017] by Costello and Smith.\n//!\n//! Begin with the affine equation for the curve,\n//! $$\n//!     -x\\^2 + y\\^2 = 1 + dx\\^2y\\^2.\n//! $$\n//! Next, pass to the projective closure \\\\(\\mathbb P\\^1 \\times \\mathbb\n//! P\\^1 \\\\) by setting \\\\(x=X/Z\\\\), \\\\(y=Y/T.\\\\)  Clearing denominators\n//! gives the model\n//! $$\n//!     -X\\^2T\\^2 + Y\\^2Z\\^2 = Z\\^2T\\^2 + dX\\^2Y\\^2.\n//! $$\n//! In `curve25519-dalek`, this is represented as the `CompletedPoint`\n//! struct.\n//! To map from \\\\(\\mathbb P\\^1 \\times \\mathbb P\\^1 \\\\), a product of\n//! two lines, to \\\\(\\mathbb P\\^3\\\\), we use the [Segre\n//! embedding](https://en.wikipedia.org/wiki/Segre_embedding)\n//! $$\n//!     \\sigma : ((X:Z),(Y:T)) \\mapsto (XY:XT:ZY:ZT).\n//! $$\n//! Using coordinates \\\\( (W_0:W_1:W_2:W_3) \\\\) for \\\\(\\mathbb P\\^3\\\\),\n//! the image \\\\(\\sigma (\\mathbb P\\^1 \\times \\mathbb P\\^1) \\\\) is the\n//! surface defined by \\\\( W_0 W_3 = W_1 W_2 \\\\), and under \\\\(\n//! \\sigma\\\\), the equation above becomes\n//! $$\n//!     -W\\_1\\^2 + W\\_2\\^2 = W\\_3\\^2 + dW\\_0\\^2,\n//! $$\n//! so that the curve is given by the pair of equations\n//! $$\n//! \\begin{aligned}\n//!     -W\\_1\\^2 + W\\_2\\^2 &= W\\_3\\^2 + dW\\_0\\^2, \\\\\\\\  W_0 W_3 &= W_1 W_2.\n//! \\end{aligned}\n//! $$\n//! Up to variable naming, this is exactly the \"extended\" curve model\n//! introduced in [_Twisted Edwards Curves\n//! Revisited_][hisil-wong-carter-dawson-2008] by Hisil, Wong, Carter,\n//! and Dawson.  In `curve25519-dalek`, it is represented as the\n//! `EdwardsPoint` struct.  We can map from \\\\(\\mathbb P\\^3 \\\\) to\n//! \\\\(\\mathbb P\\^2 \\\\) by sending \\\\( (W\\_0:W\\_1:W\\_2:W\\_3) \\\\) to \\\\(\n//! (W\\_1:W\\_2:W\\_3) \\\\).  Notice that\n//! $$\n//!     \\frac {W\\_1} {W\\_3} = \\frac {XT} {ZT} = \\frac X Z = x,\n//! $$\n//! and\n//! $$\n//!     \\frac {W\\_2} {W\\_3} = \\frac {YZ} {ZT} = \\frac Y T = y,\n//! $$\n//! so this is the same as if we had started with the affine model\n//! and passed to \\\\( \\mathbb P\\^2 \\\\) by setting \\\\( x = W\\_1 / W\\_3\n//! \\\\), \\\\(y = W\\_2 / W\\_3 \\\\).\n//! Up to variable naming, this is the projective representation\n//! introduced in [_Twisted Edwards\n//! Curves_][bernstein-birkner-joye-lange-peters-2008] by Bernstein,\n//! Birkner, Joye, Lange, and Peters.  In `curve25519-dalek`, it is\n//! represented by the `ProjectivePoint` struct.\n//!\n//! # Passing between curve models\n//!\n//! Although the \\\\( \\mathbb P\\^3 \\\\) model provides faster addition\n//! formulas, the \\\\( \\mathbb P\\^2 \\\\) model provides faster doubling\n//! formulas.  Hisil, Wong, Carter, and Dawson therefore suggest mixing\n//! coordinate systems for scalar multiplication, attributing the idea\n//! to [a 1998 paper][cohen-miyaji-ono-1998] of Cohen, Miyagi, and Ono.\n//!\n//! Their suggestion is to vary the formulas used by context, using a\n//! \\\\( \\mathbb P\\^2 \\rightarrow \\mathbb P\\^2 \\\\) doubling formula when\n//! a doubling is followed\n//! by another doubling, a \\\\( \\mathbb P\\^2 \\rightarrow \\mathbb P\\^3 \\\\)\n//! doubling formula when a doubling is followed by an addition, and\n//! computing point additions using a \\\\( \\mathbb P\\^3 \\times \\mathbb P\\^3\n//! \\rightarrow \\mathbb P\\^2 \\\\) formula.\n//!\n//! The `ref10` reference implementation of [Ed25519][ed25519], by\n//! Bernstein, Duif, Lange, Schwabe, and Yang, tweaks\n//! this strategy, factoring the addition formulas through the\n//! completion \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1 \\\\), so that the\n//! output of an addition or doubling always lies in \\\\( \\mathbb P\\^1 \\times\n//! \\mathbb P\\^1\\\\), and the choice of which formula to use is replaced\n//! by a choice of whether to convert the result to \\\\( \\mathbb P\\^2 \\\\)\n//! or \\\\(\\mathbb P\\^3 \\\\).  However, this tweak is not described in\n//! their paper, only in their software.\n//!\n//! Our naming for the `CompletedPoint` (\\\\(\\mathbb P\\^1 \\times \\mathbb\n//! P\\^1 \\\\)), `ProjectivePoint` (\\\\(\\mathbb P\\^2 \\\\)), and\n//! `EdwardsPoint` (\\\\(\\mathbb P\\^3 \\\\)) structs follows the naming in\n//! Adam Langley's [Golang ed25519][agl-ed25519] implementation, which\n//! `curve25519-dalek` was originally derived from.\n//!\n//! Finally, to accelerate readditions, we use two cached point formats\n//! in \"Niels coordinates\", named for Niels Duif,\n//! one for the affine model and one for the \\\\( \\mathbb P\\^3 \\\\) model:\n//!\n//! * `AffineNielsPoint`: \\\\( (y+x, y-x, 2dxy) \\\\)\n//! * `ProjectiveNielsPoint`: \\\\( (Y+X, Y-X, Z, 2dXY) \\\\)\n//!\n//! [smith-moderncrypto]: https://moderncrypto.org/mail-archive/curves/2016/000807.html\n//! [costello-smith-2017]: https://eprint.iacr.org/2017/212\n//! [hisil-wong-carter-dawson-2008]: https://www.iacr.org/archive/asiacrypt2008/53500329/53500329.pdf\n//! [bernstein-birkner-joye-lange-peters-2008]: https://eprint.iacr.org/2008/013\n//! [cohen-miyaji-ono-1998]: https://link.springer.com/content/pdf/10.1007%2F3-540-49649-1_6.pdf\n//! [ed25519]: https://eprint.iacr.org/2011/368\n//! [agl-ed25519]: https://github.com/agl/ed25519\n\n#![allow(non_snake_case)]\n\nuse core::fmt::Debug;\nuse core::ops::{Add, Neg, Sub};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse crate::constants;\n\nuse crate::edwards::EdwardsPoint;\nuse crate::field::FieldElement;\nuse crate::traits::ValidityCheck;\n\n// ------------------------------------------------------------------------\n// Internal point representations\n// ------------------------------------------------------------------------\n\n/// A `ProjectivePoint` is a point \\\\((X:Y:Z)\\\\) on the \\\\(\\mathbb\n/// P\\^2\\\\) model of the curve.\n/// A point \\\\((x,y)\\\\) in the affine model corresponds to\n/// \\\\((x:y:1)\\\\).\n///\n/// More details on the relationships between the different curve models\n/// can be found in the module-level documentation.\n#[allow(missing_docs)]\n#[derive(Copy, Clone)]\npub struct ProjectivePoint {\n    pub X: FieldElement,\n    pub Y: FieldElement,\n    pub Z: FieldElement,\n}\n\n/// A `CompletedPoint` is a point \\\\(((X:Z), (Y:T))\\\\) on the \\\\(\\mathbb\n/// P\\^1 \\times \\mathbb P\\^1 \\\\) model of the curve.\n/// A point (x,y) in the affine model corresponds to \\\\( ((x:1),(y:1))\n/// \\\\).\n///\n/// More details on the relationships between the different curve models\n/// can be found in the module-level documentation.\n#[derive(Copy, Clone)]\n#[allow(missing_docs)]\npub struct CompletedPoint {\n    pub X: FieldElement,\n    pub Y: FieldElement,\n    pub Z: FieldElement,\n    pub T: FieldElement,\n}\n\n/// A pre-computed point in the affine model for the curve, represented as\n/// \\\\((y+x, y-x, 2dxy)\\\\) in \"Niels coordinates\".\n///\n/// More details on the relationships between the different curve models\n/// can be found in the module-level documentation.\n// Safe to derive Eq because affine coordinates.\n#[derive(Copy, Clone, Eq, PartialEq)]\n#[allow(missing_docs)]\npub struct AffineNielsPoint {\n    pub y_plus_x: FieldElement,\n    pub y_minus_x: FieldElement,\n    pub xy2d: FieldElement,\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for AffineNielsPoint {\n    fn zeroize(&mut self) {\n        self.y_plus_x.zeroize();\n        self.y_minus_x.zeroize();\n        self.xy2d.zeroize();\n    }\n}\n\n/// A pre-computed point on the \\\\( \\mathbb P\\^3 \\\\) model for the\n/// curve, represented as \\\\((Y+X, Y-X, Z, 2dXY)\\\\) in \"Niels coordinates\".\n///\n/// More details on the relationships between the different curve models\n/// can be found in the module-level documentation.\n#[derive(Copy, Clone)]\n#[allow(missing_docs)]\npub struct ProjectiveNielsPoint {\n    pub Y_plus_X: FieldElement,\n    pub Y_minus_X: FieldElement,\n    pub Z: FieldElement,\n    pub T2d: FieldElement,\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for ProjectiveNielsPoint {\n    fn zeroize(&mut self) {\n        self.Y_plus_X.zeroize();\n        self.Y_minus_X.zeroize();\n        self.Z.zeroize();\n        self.T2d.zeroize();\n    }\n}\n\n// ------------------------------------------------------------------------\n// Constructors\n// ------------------------------------------------------------------------\n\nuse crate::traits::Identity;\n\nimpl Identity for ProjectivePoint {\n    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n        }\n    }\n}\n\nimpl Identity for ProjectiveNielsPoint {\n    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for ProjectiveNielsPoint {\n    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }\n}\n\nimpl Identity for AffineNielsPoint {\n    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for AffineNielsPoint {\n    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Validity checks (for debugging, not CT)\n// ------------------------------------------------------------------------\n\nimpl ValidityCheck for ProjectivePoint {\n    fn is_valid(&self) -> bool {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        let ZZZZ = ZZ.square();\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n\n        lhs == rhs\n    }\n}\n\n// ------------------------------------------------------------------------\n// Constant-time assignment\n// ------------------------------------------------------------------------\n\nimpl ConditionallySelectable for ProjectiveNielsPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }\n}\n\nimpl ConditionallySelectable for AffineNielsPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }\n\n    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }\n}\n\n// ------------------------------------------------------------------------\n// Point conversions\n// ------------------------------------------------------------------------\n\nimpl ProjectivePoint {\n    /// Convert this point from the \\\\( \\mathbb P\\^2 \\\\) model to the\n    /// \\\\( \\mathbb P\\^3 \\\\) model.\n    ///\n    /// This costs \\\\(3 \\mathrm M + 1 \\mathrm S\\\\).\n    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.Z,\n            Y: &self.Y * &self.Z,\n            Z: self.Z.square(),\n            T: &self.X * &self.Y,\n        }\n    }\n}\n\nimpl CompletedPoint {\n    /// Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1\n    /// \\\\) model to the \\\\( \\mathbb P\\^2 \\\\) model.\n    ///\n    /// This costs \\\\(3 \\mathrm M \\\\).\n    pub fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n        }\n    }\n\n    /// Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1\n    /// \\\\) model to the \\\\( \\mathbb P\\^3 \\\\) model.\n    ///\n    /// This costs \\\\(4 \\mathrm M \\\\).\n    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n            T: &self.X * &self.Y,\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Doubling\n// ------------------------------------------------------------------------\n\nimpl ProjectivePoint {\n    /// Double this point: return self + self\n    pub fn double(&self) -> CompletedPoint {\n        // Double()\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ2 = self.Z.square2();\n        let X_plus_Y = &self.X + &self.Y;\n        let X_plus_Y_sq = X_plus_Y.square();\n        let YY_plus_XX = &YY + &XX;\n        let YY_minus_XX = &YY - &XX;\n\n        CompletedPoint {\n            X: &X_plus_Y_sq - &YY_plus_XX,\n            Y: YY_plus_XX,\n            Z: YY_minus_XX,\n            T: &ZZ2 - &YY_minus_XX,\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Addition and Subtraction\n// ------------------------------------------------------------------------\n\n// XXX(hdevalence) These were doc(hidden) so they don't appear in the\n// public API docs.\n// However, that prevents them being used with --document-private-items,\n// so comment out the doc(hidden) for now until this is resolved\n//\n// upstream rust issue: https://github.com/rust-lang/rust/issues/46380\n//#[doc(hidden)]\nimpl<'a> Add<&'a ProjectiveNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn add(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.Y_plus_X;\n        let MM = &Y_minus_X * &other.Y_minus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &ZZ2 + &TT2d,\n            T: &ZZ2 - &TT2d,\n        }\n    }\n}\n\n//#[doc(hidden)]\nimpl<'a> Sub<&'a ProjectiveNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn sub(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.Y_minus_X;\n        let MP = &Y_minus_X * &other.Y_plus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &ZZ2 - &TT2d,\n            T: &ZZ2 + &TT2d,\n        }\n    }\n}\n\n//#[doc(hidden)]\nimpl<'a> Add<&'a AffineNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn add(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.y_plus_x;\n        let MM = &Y_minus_X * &other.y_minus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &Z2 + &Txy2d,\n            T: &Z2 - &Txy2d,\n        }\n    }\n}\n\n//#[doc(hidden)]\nimpl<'a> Sub<&'a AffineNielsPoint> for &EdwardsPoint {\n    type Output = CompletedPoint;\n\n    fn sub(self, other: &'a AffineNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.y_minus_x;\n        let MP = &Y_minus_X * &other.y_plus_x;\n        let Txy2d = &self.T * &other.xy2d;\n        let Z2 = &self.Z + &self.Z;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &Z2 - &Txy2d,\n            T: &Z2 + &Txy2d,\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Negation\n// ------------------------------------------------------------------------\n\nimpl Neg for &ProjectiveNielsPoint {\n    type Output = ProjectiveNielsPoint;\n\n    fn neg(self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: self.Y_minus_X,\n            Y_minus_X: self.Y_plus_X,\n            Z: self.Z,\n            T2d: -(&self.T2d),\n        }\n    }\n}\n\nimpl Neg for &AffineNielsPoint {\n    type Output = AffineNielsPoint;\n\n    fn neg(self) -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: self.y_minus_x,\n            y_minus_x: self.y_plus_x,\n            xy2d: -(&self.xy2d),\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Debug traits\n// ------------------------------------------------------------------------\n\nimpl Debug for ProjectivePoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectivePoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z\n        )\n    }\n}\n\nimpl Debug for CompletedPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"CompletedPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }\n}\n\nimpl Debug for AffineNielsPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"AffineNielsPoint{{\\n\\ty_plus_x: {:?},\\n\\ty_minus_x: {:?},\\n\\txy2d: {:?}\\n}}\",\n            &self.y_plus_x, &self.y_minus_x, &self.xy2d\n        )\n    }\n}\n\nimpl Debug for ProjectiveNielsPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectiveNielsPoint{{\\n\\tY_plus_X: {:?},\\n\\tY_minus_X: {:?},\\n\\tZ: {:?},\\n\\tT2d: {:?}\\n}}\",\n            &self.Y_plus_X, &self.Y_minus_X, &self.Z, &self.T2d\n        )\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
    "filepath": null,
    "folder_id": 15835,
    "user_id": 460154
  },
  "63615": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2019 Henry de Valence.\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Precomputation for Straus's method.\n\n#![allow(non_snake_case)]\n\nuse alloc::vec::Vec;\n\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\n\nuse crate::backend::serial::curve_models::{\n    AffineNielsPoint, CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n};\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::Identity;\nuse crate::traits::VartimePrecomputedMultiscalarMul;\nuse crate::window::{NafLookupTable5, NafLookupTable8};\n\n#[allow(missing_docs)]\npub struct VartimePrecomputedStraus {\n    static_lookup_tables: Vec<NafLookupTable8<AffineNielsPoint>>,\n}\n\nimpl VartimePrecomputedMultiscalarMul for VartimePrecomputedStraus {\n    type Point = EdwardsPoint;\n\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self {\n            static_lookup_tables: static_points\n                .into_iter()\n                .map(|P| NafLookupTable8::<AffineNielsPoint>::from(P.borrow()))\n                .collect(),\n        }\n    }\n\n    fn len(&self) -> usize {\n        self.static_lookup_tables.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.static_lookup_tables.is_empty()\n    }\n\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        let static_nafs = static_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n        let dynamic_nafs: Vec<_> = dynamic_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n\n        let dynamic_lookup_tables = dynamic_points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let sp = self.static_lookup_tables.len();\n        let dp = dynamic_lookup_tables.len();\n        assert!(sp >= static_nafs.len());\n        assert_eq!(dp, dynamic_nafs.len());\n\n        // We could save some doublings by looking for the highest\n        // nonzero NAF coefficient, but since we might have a lot of\n        // them to search, it's not clear it's worthwhile to check.\n        let mut S = ProjectivePoint::identity();\n        for j in (0..256).rev() {\n            let mut R: CompletedPoint = S.double();\n\n            for i in 0..dp {\n                let t_ij = dynamic_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &dynamic_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &dynamic_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            #[allow(clippy::needless_range_loop)]\n            for i in 0..static_nafs.len() {\n                let t_ij = static_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &self.static_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &self.static_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            S = R.as_projective();\n        }\n\n        Some(S.as_extended())\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
    "filepath": null,
    "folder_id": 15836,
    "user_id": 460154
  },
  "63616": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2019 Oleg Andreev\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Oleg Andreev <oleganza@gmail.com>\n\n//! Implementation of a variant of Pippenger's algorithm.\n\n#![allow(non_snake_case)]\n\nuse alloc::vec::Vec;\n\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\n\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::VartimeMultiscalarMul;\n\n/// Implements a version of Pippenger's algorithm.\n///\n/// The algorithm works as follows:\n///\n/// Let `n` be a number of point-scalar pairs.\n/// Let `w` be a window of bits (6..8, chosen based on `n`, see cost factor).\n///\n/// 1. Prepare `2^(w-1) - 1` buckets with indices `[1..2^(w-1))` initialized with identity points.\n///    Bucket 0 is not needed as it would contain points multiplied by 0.\n/// 2. Convert scalars to a radix-`2^w` representation with signed digits in `[-2^w/2, 2^w/2]`.\n///    Note: only the last digit may equal `2^w/2`.\n/// 3. Starting with the last window, for each point `i=[0..n)` add it to a bucket indexed by\n///    the point's scalar's value in the window.\n/// 4. Once all points in a window are sorted into buckets, add buckets by multiplying each\n///    by their index. Efficient way of doing it is to start with the last bucket and compute two sums:\n///    intermediate sum from the last to the first, and the full sum made of all intermediate sums.\n/// 5. Shift the resulting sum of buckets by `w` bits by using `w` doublings.\n/// 6. Add to the return value.\n/// 7. Repeat the loop.\n///\n/// Approximate cost w/o wNAF optimizations (A = addition, D = doubling):\n///\n/// ```ascii\n/// cost = (n*A + 2*(2^w/2)*A + w*D + A)*256/w\n///          |          |       |     |   |\n///          |          |       |     |   looping over 256/w windows\n///          |          |       |     adding to the result\n///    sorting points   |       shifting the sum by w bits (to the next window, starting from last window)\n///    one by one       |\n///    into buckets     adding/subtracting all buckets\n///                     multiplied by their indexes\n///                     using a sum of intermediate sums\n/// ```\n///\n/// For large `n`, dominant factor is (n*256/w) additions.\n/// However, if `w` is too big and `n` is not too big, then `(2^w/2)*A` could dominate.\n/// Therefore, the optimal choice of `w` grows slowly as `n` grows.\n///\n/// This algorithm is adapted from section 4 of <https://eprint.iacr.org/2012/549.pdf>.\npub struct Pippenger;\n\nimpl VartimeMultiscalarMul for Pippenger {\n    type Point = EdwardsPoint;\n\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::Identity;\n\n        let mut scalars = scalars.into_iter();\n        let size = scalars.by_ref().size_hint().0;\n\n        // Digit width in bits. As digit width grows,\n        // number of point additions goes down, but amount of\n        // buckets and bucket additions grows exponentially.\n        let w = if size < 500 {\n            6\n        } else if size < 800 {\n            7\n        } else {\n            8\n        };\n\n        let max_digit: usize = 1 << w;\n        let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n        let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n        // Collect optimized scalars and points in buffers for repeated access\n        // (scanning the whole set per digit position).\n        let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n        let points = points\n            .into_iter()\n            .map(|p| p.map(|P| P.as_projective_niels()));\n\n        let scalars_points = scalars\n            .zip(points)\n            .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n            .collect::<Option<Vec<_>>>()?;\n\n        // Prepare 2^w/2 buckets.\n        // buckets[i] corresponds to a multiplication factor (i+1).\n        let mut buckets: Vec<_> = (0..buckets_count)\n            .map(|_| EdwardsPoint::identity())\n            .collect();\n\n        let mut columns = (0..digits_count).rev().map(|digit_index| {\n            // Clear the buckets when processing another digit.\n            for bucket in &mut buckets {\n                *bucket = EdwardsPoint::identity();\n            }\n\n            // Iterate over pairs of (point, scalar)\n            // and add/sub the point to the corresponding bucket.\n            // Note: if we add support for precomputed lookup tables,\n            // we'll be adding/subtracting point premultiplied by `digits[i]` to buckets[0].\n            for (digits, pt) in scalars_points.iter() {\n                // Widen digit so that we don't run into edge cases when w=8.\n                let digit = digits[digit_index] as i16;\n                match digit.cmp(&0) {\n                    Ordering::Greater => {\n                        let b = (digit - 1) as usize;\n                        buckets[b] = (&buckets[b] + pt).as_extended();\n                    }\n                    Ordering::Less => {\n                        let b = (-digit - 1) as usize;\n                        buckets[b] = (&buckets[b] - pt).as_extended();\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            // Add the buckets applying the multiplication factor to each bucket.\n            // The most efficient way to do that is to have a single sum with two running sums:\n            // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n            //\n            // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n            //   C\n            //   C B\n            //   C B A   Sum = C + (C+B) + (C+B+A)\n            let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n            let mut buckets_sum = buckets[buckets_count - 1];\n            for i in (0..(buckets_count - 1)).rev() {\n                buckets_intermediate_sum += buckets[i];\n                buckets_sum += buckets_intermediate_sum;\n            }\n\n            buckets_sum\n        });\n\n        // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n        let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n        Some(columns.fold(hi_column, |total, p| total.mul_by_pow_2(w as u32) + p))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::constants;\n\n    #[test]\n    fn test_vartime_pippenger() {\n        // Reuse points across different tests\n        let mut n = 512;\n        let x = Scalar::from(2128506u64).invert();\n        let y = Scalar::from(4443282u64).invert();\n        let points: Vec<_> = (0..n)\n            .map(|i| constants::ED25519_BASEPOINT_POINT * Scalar::from(1 + i as u64))\n            .collect();\n        let scalars: Vec<_> = (0..n)\n            .map(|i| x + (Scalar::from(i as u64) * y)) // fast way to make ~random but deterministic scalars\n            .collect();\n\n        let premultiplied: Vec<EdwardsPoint> = scalars\n            .iter()\n            .zip(points.iter())\n            .map(|(sc, pt)| sc * pt)\n            .collect();\n\n        while n > 0 {\n            let scalars = &scalars[0..n].to_vec();\n            let points = &points[0..n].to_vec();\n            let control: EdwardsPoint = premultiplied[0..n].iter().sum();\n\n            let subject = Pippenger::vartime_multiscalar_mul(scalars.clone(), points.clone());\n\n            assert_eq!(subject.compress(), control.compress());\n\n            n /= 2;\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
    "filepath": null,
    "folder_id": 15836,
    "user_id": 460154
  },
  "63617": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Implementation of the interleaved window method, also known as Straus' method.\n\n#![allow(non_snake_case)]\n\nuse alloc::vec::Vec;\n\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\n\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::MultiscalarMul;\nuse crate::traits::VartimeMultiscalarMul;\n\n/// Perform multiscalar multiplication by the interleaved window\n/// method, also known as Straus' method (since it was apparently\n/// [first published][solution] by Straus in 1964, as a solution to [a\n/// problem][problem] posted in the American Mathematical Monthly in\n/// 1963).\n///\n/// It is easy enough to reinvent, and has been repeatedly.  The basic\n/// idea is that when computing\n/// \\\\[\n/// Q = s_1 P_1 + \\cdots + s_n P_n\n/// \\\\]\n/// by means of additions and doublings, the doublings can be shared\n/// across the \\\\( P_i \\\\\\).\n///\n/// We implement two versions, a constant-time algorithm using fixed\n/// windows and a variable-time algorithm using sliding windows.  They\n/// are slight variations on the same idea, and are described in more\n/// detail in the respective implementations.\n///\n/// [solution]: https://www.jstor.org/stable/2310929\n/// [problem]: https://www.jstor.org/stable/2312273\npub struct Straus {}\n\nimpl MultiscalarMul for Straus {\n    type Point = EdwardsPoint;\n\n    /// Constant-time Straus using a fixed window of size \\\\(4\\\\).\n    ///\n    /// Our goal is to compute\n    /// \\\\[\n    /// Q = s_1 P_1 + \\cdots + s_n P_n.\n    /// \\\\]\n    ///\n    /// For each point \\\\( P_i \\\\), precompute a lookup table of\n    /// \\\\[\n    /// P_i, 2P_i, 3P_i, 4P_i, 5P_i, 6P_i, 7P_i, 8P_i.\n    /// \\\\]\n    ///\n    /// For each scalar \\\\( s_i \\\\), compute its radix-\\\\(2^4\\\\)\n    /// signed digits \\\\( s_{i,j} \\\\), i.e.,\n    /// \\\\[\n    ///    s_i = s_{i,0} + s_{i,1} 16^1 + ... + s_{i,63} 16^{63},\n    /// \\\\]\n    /// with \\\\( -8 \\leq s_{i,j} < 8 \\\\).  Since \\\\( 0 \\leq |s_{i,j}|\n    /// \\leq 8 \\\\), we can retrieve \\\\( s_{i,j} P_i \\\\) from the\n    /// lookup table with a conditional negation: using signed\n    /// digits halves the required table size.\n    ///\n    /// Then as in the single-base fixed window case, we have\n    /// \\\\[\n    /// \\begin{aligned}\n    /// s_i P_i &= P_i (s_{i,0} +     s_{i,1} 16^1 + \\cdots +     s_{i,63} 16^{63})   \\\\\\\\\n    /// s_i P_i &= P_i s_{i,0} + P_i s_{i,1} 16^1 + \\cdots + P_i s_{i,63} 16^{63}     \\\\\\\\\n    /// s_i P_i &= P_i s_{i,0} + 16(P_i s_{i,1} + 16( \\cdots +16P_i s_{i,63})\\cdots )\n    /// \\end{aligned}\n    /// \\\\]\n    /// so each \\\\( s_i P_i \\\\) can be computed by alternately adding\n    /// a precomputed multiple \\\\( P_i s_{i,j} \\\\) of \\\\( P_i \\\\) and\n    /// repeatedly doubling.\n    ///\n    /// Now consider the two-dimensional sum\n    /// \\\\[\n    /// \\begin{aligned}\n    /// s\\_1 P\\_1 &=& P\\_1 s\\_{1,0} &+& 16 (P\\_1 s\\_{1,1} &+& 16 ( \\cdots &+& 16 P\\_1 s\\_{1,63}&) \\cdots ) \\\\\\\\\n    ///     +     & &      +        & &      +            & &             & &     +            &           \\\\\\\\\n    /// s\\_2 P\\_2 &=& P\\_2 s\\_{2,0} &+& 16 (P\\_2 s\\_{2,1} &+& 16 ( \\cdots &+& 16 P\\_2 s\\_{2,63}&) \\cdots ) \\\\\\\\\n    ///     +     & &      +        & &      +            & &             & &     +            &           \\\\\\\\\n    /// \\vdots    & &  \\vdots       & &   \\vdots          & &             & &  \\vdots          &           \\\\\\\\\n    ///     +     & &      +        & &      +            & &             & &     +            &           \\\\\\\\\n    /// s\\_n P\\_n &=& P\\_n s\\_{n,0} &+& 16 (P\\_n s\\_{n,1} &+& 16 ( \\cdots &+& 16 P\\_n s\\_{n,63}&) \\cdots )\n    /// \\end{aligned}\n    /// \\\\]\n    /// The sum of the left-hand column is the result \\\\( Q \\\\); by\n    /// computing the two-dimensional sum on the right column-wise,\n    /// top-to-bottom, then right-to-left, we need to multiply by \\\\(\n    /// 16\\\\) only once per column, sharing the doublings across all\n    /// of the input points.\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        use crate::backend::serial::curve_models::ProjectiveNielsPoint;\n        use crate::traits::Identity;\n        use crate::window::LookupTable;\n\n        let lookup_tables: Vec<_> = points\n            .into_iter()\n            .map(|point| LookupTable::<ProjectiveNielsPoint>::from(point.borrow()))\n            .collect();\n\n        // This puts the scalar digits into a heap-allocated Vec.\n        // To ensure that these are erased, pass ownership of the Vec into a\n        // Zeroizing wrapper.\n        #[cfg_attr(not(feature = \"zeroize\"), allow(unused_mut))]\n        let mut scalar_digits: Vec<_> = scalars\n            .into_iter()\n            .map(|s| s.borrow().as_radix_16())\n            .collect();\n\n        let mut Q = EdwardsPoint::identity();\n        for j in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            let it = scalar_digits.iter().zip(lookup_tables.iter());\n            for (s_i, lookup_table_i) in it {\n                // R_i = s_{i,j} * P_i\n                let R_i = lookup_table_i.select(s_i[j]);\n                // Q = Q + R_i\n                Q = (&Q + &R_i).as_extended();\n            }\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        zeroize::Zeroize::zeroize(&mut scalar_digits);\n\n        Q\n    }\n}\n\nimpl VartimeMultiscalarMul for Straus {\n    type Point = EdwardsPoint;\n\n    /// Variable-time Straus using a non-adjacent form of width \\\\(5\\\\).\n    ///\n    /// This is completely similar to the constant-time code, but we\n    /// use a non-adjacent form for the scalar, and do not do table\n    /// lookups in constant time.\n    ///\n    /// The non-adjacent form has signed, odd digits.  Using only odd\n    /// digits halves the table size (since we only need odd\n    /// multiples), or gives fewer additions for the same table size.\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::backend::serial::curve_models::{\n            CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n        };\n        use crate::traits::Identity;\n        use crate::window::NafLookupTable5;\n\n        let nafs: Vec<_> = scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect();\n\n        let lookup_tables = points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let mut r = ProjectivePoint::identity();\n\n        for i in (0..256).rev() {\n            let mut t: CompletedPoint = r.double();\n\n            for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                match naf[i].cmp(&0) {\n                    Ordering::Greater => {\n                        t = &t.as_extended() + &lookup_table.select(naf[i] as usize)\n                    }\n                    Ordering::Less => t = &t.as_extended() - &lookup_table.select(-naf[i] as usize),\n                    Ordering::Equal => {}\n                }\n            }\n\n            r = t.as_projective();\n        }\n\n        Some(r.as_extended())\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
    "filepath": null,
    "folder_id": 15836,
    "user_id": 460154
  },
  "63618": {
    "text": "#![allow(non_snake_case)]\n\nuse crate::backend::serial::curve_models::ProjectiveNielsPoint;\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::Identity;\nuse crate::window::LookupTable;\n\n/// Perform constant-time, variable-base scalar multiplication.\n#[rustfmt::skip] // keep alignment of explanatory comments\npub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n    let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);\n    // Setting s = scalar, compute\n    //\n    //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n    //\n    // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n    // This decomposition requires s < 2^255, which is guaranteed by Scalar invariant #1.\n    let scalar_digits = scalar.as_radix_16();\n    // Compute s*P as\n    //\n    //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n    //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n    //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n    //\n    // We sum right-to-left.\n\n    // Unwrap first loop iteration to save computing 16*identity\n    let mut tmp2;\n    let mut tmp3 = EdwardsPoint::identity();\n    let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);\n    // Now tmp1 = s_63*P in P1xP1 coords\n    for i in (0..63).rev() {\n        tmp2 = tmp1.as_projective(); // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();   // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }\n    tmp1.as_extended()\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
    "filepath": null,
    "folder_id": 15836,
    "user_id": 460154
  },
  "63619": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Implementations of various scalar multiplication algorithms.\n//!\n//! Note that all of these implementations use serial code for field\n//! arithmetic with the multi-model strategy described in the\n//! `curve_models` module.  The vectorized AVX2 backend has its own\n//! scalar multiplication implementations, since it only uses one\n//! curve model.\n\n#[allow(missing_docs)]\npub mod variable_base;\n\n#[allow(missing_docs)]\npub mod vartime_double_base;\n\n#[cfg(feature = \"alloc\")]\npub mod straus;\n\n#[cfg(feature = \"alloc\")]\npub mod precomputed_straus;\n\n#[cfg(feature = \"alloc\")]\npub mod pippenger;\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/mod.rs",
    "filepath": null,
    "folder_id": 15836,
    "user_id": 460154
  },
  "63620": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n#![allow(non_snake_case)]\n\nuse core::cmp::Ordering;\n\nuse crate::backend::serial::curve_models::{ProjectiveNielsPoint, ProjectivePoint};\nuse crate::constants;\nuse crate::edwards::EdwardsPoint;\nuse crate::scalar::Scalar;\nuse crate::traits::Identity;\nuse crate::window::NafLookupTable5;\n\n/// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.\npub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    let a_naf = a.non_adjacent_form(5);\n\n    #[cfg(feature = \"precomputed-tables\")]\n    let b_naf = b.non_adjacent_form(8);\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let b_naf = b.non_adjacent_form(5);\n\n    // Find starting index\n    let mut i: usize = 255;\n    for j in (0..256).rev() {\n        i = j;\n        if a_naf[i] != 0 || b_naf[i] != 0 {\n            break;\n        }\n    }\n\n    let table_A = NafLookupTable5::<ProjectiveNielsPoint>::from(A);\n    #[cfg(feature = \"precomputed-tables\")]\n    let table_B = &constants::AFFINE_ODD_MULTIPLES_OF_BASEPOINT;\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let table_B =\n        &NafLookupTable5::<ProjectiveNielsPoint>::from(&constants::ED25519_BASEPOINT_POINT);\n\n    let mut r = ProjectivePoint::identity();\n    loop {\n        let mut t = r.double();\n\n        match a_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_A.select(a_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_A.select(-a_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        match b_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_B.select(b_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_B.select(-b_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        r = t.as_projective();\n\n        if i == 0 {\n            break;\n        }\n        i -= 1;\n    }\n\n    r.as_extended()\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
    "filepath": null,
    "folder_id": 15836,
    "user_id": 460154
  },
  "63621": {
    "text": "// -*- mode: rust; coding: utf-8; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2018 Isis Lovecruft, Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Isis Agora Lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Field arithmetic modulo \\\\(p = 2\\^{255} - 19\\\\), using \\\\(32\\\\)-bit\n//! limbs with \\\\(64\\\\)-bit products.\n//!\n//! This code was originally derived from Adam Langley's Golang ed25519\n//! implementation, and was then rewritten to use unsigned limbs instead\n//! of signed limbs.\n//!\n//! This uses the formally-verified field arithmetic generated by the\n//! [fiat-crypto project](https://github.com/mit-plv/fiat-crypto)\n\nuse core::fmt::Debug;\nuse core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};\nuse core::ops::{Sub, SubAssign};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse fiat_crypto::curve25519_32::*;\n\n/// A `FieldElement2625` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 32-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{25.5}\\\\) as ten `u32`s.  This means that a field\n/// element \\\\(x\\\\) is represented as\n/// $$\n/// x = \\sum\\_{i=0}\\^9 x\\_i 2\\^{\\lceil i \\frac {51} 2 \\rceil}\n///   = x\\_0 + x\\_1 2\\^{26} + x\\_2 2\\^{51} + x\\_3 2\\^{77} + \\cdots + x\\_9 2\\^{230};\n/// $$\n/// the coefficients are alternately bounded by \\\\(2\\^{25}\\\\) and\n/// \\\\(2\\^{26}\\\\).  The limbs are allowed to grow between reductions up\n/// to \\\\(2\\^{25+b}\\\\) or \\\\(2\\^{26+b}\\\\), where \\\\(b = 1.75\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement2625` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement2625(pub(crate) fiat_25519_tight_field_element);\n\nimpl Debug for FieldElement2625 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement2625({:?})\", &(self.0).0[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement2625 {\n    fn zeroize(&mut self) {\n        (self.0).0.zeroize();\n    }\n}\n\nimpl<'b> AddAssign<&'b FieldElement2625> for FieldElement2625 {\n    fn add_assign(&mut self, rhs: &'b FieldElement2625) {\n        let mut result_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_add(&mut result_loose, &self.0, &rhs.0);\n        fiat_25519_carry(&mut self.0, &result_loose);\n    }\n}\n\nimpl<'a, 'b> Add<&'b FieldElement2625> for &'a FieldElement2625 {\n    type Output = FieldElement2625;\n    fn add(self, rhs: &'b FieldElement2625) -> FieldElement2625 {\n        let mut result_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_add(&mut result_loose, &self.0, &rhs.0);\n        let mut output = FieldElement2625::ZERO;\n        fiat_25519_carry(&mut output.0, &result_loose);\n        output\n    }\n}\n\nimpl<'b> SubAssign<&'b FieldElement2625> for FieldElement2625 {\n    fn sub_assign(&mut self, rhs: &'b FieldElement2625) {\n        let mut result_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_sub(&mut result_loose, &self.0, &rhs.0);\n        fiat_25519_carry(&mut self.0, &result_loose);\n    }\n}\n\nimpl<'a, 'b> Sub<&'b FieldElement2625> for &'a FieldElement2625 {\n    type Output = FieldElement2625;\n    fn sub(self, rhs: &'b FieldElement2625) -> FieldElement2625 {\n        let mut result_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_sub(&mut result_loose, &self.0, &rhs.0);\n        let mut output = FieldElement2625::ZERO;\n        fiat_25519_carry(&mut output.0, &result_loose);\n        output\n    }\n}\n\nimpl<'b> MulAssign<&'b FieldElement2625> for FieldElement2625 {\n    fn mul_assign(&mut self, rhs: &'b FieldElement2625) {\n        let mut self_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_relax(&mut self_loose, &self.0);\n        let mut rhs_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_relax(&mut rhs_loose, &rhs.0);\n        fiat_25519_carry_mul(&mut self.0, &self_loose, &rhs_loose);\n    }\n}\n\nimpl<'a, 'b> Mul<&'b FieldElement2625> for &'a FieldElement2625 {\n    type Output = FieldElement2625;\n    fn mul(self, rhs: &'b FieldElement2625) -> FieldElement2625 {\n        let mut self_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_relax(&mut self_loose, &self.0);\n        let mut rhs_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_relax(&mut rhs_loose, &rhs.0);\n        let mut output = FieldElement2625::ZERO;\n        fiat_25519_carry_mul(&mut output.0, &self_loose, &rhs_loose);\n        output\n    }\n}\n\nimpl<'a> Neg for &'a FieldElement2625 {\n    type Output = FieldElement2625;\n    fn neg(self) -> FieldElement2625 {\n        let mut output_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_opp(&mut output_loose, &self.0);\n        let mut output = FieldElement2625::ZERO;\n        fiat_25519_carry(&mut output.0, &output_loose);\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement2625 {\n    fn conditional_select(\n        a: &FieldElement2625,\n        b: &FieldElement2625,\n        choice: Choice,\n    ) -> FieldElement2625 {\n        let mut output = fiat_25519_tight_field_element([0u32; 10]);\n        fiat_25519_selectznz(\n            &mut output.0,\n            choice.unwrap_u8() as fiat_25519_u1,\n            &(a.0).0,\n            &(b.0).0,\n        );\n        FieldElement2625(output)\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement2625, choice: Choice) {\n        let mut output = [0u32; 10];\n        let choicebit = choice.unwrap_u8() as fiat_25519_u1;\n        fiat_25519_cmovznz_u32(&mut output[0], choicebit, self.0[0], other.0[0]);\n        fiat_25519_cmovznz_u32(&mut output[1], choicebit, self.0[1], other.0[1]);\n        fiat_25519_cmovznz_u32(&mut output[2], choicebit, self.0[2], other.0[2]);\n        fiat_25519_cmovznz_u32(&mut output[3], choicebit, self.0[3], other.0[3]);\n        fiat_25519_cmovznz_u32(&mut output[4], choicebit, self.0[4], other.0[4]);\n        fiat_25519_cmovznz_u32(&mut output[5], choicebit, self.0[5], other.0[5]);\n        fiat_25519_cmovznz_u32(&mut output[6], choicebit, self.0[6], other.0[6]);\n        fiat_25519_cmovznz_u32(&mut output[7], choicebit, self.0[7], other.0[7]);\n        fiat_25519_cmovznz_u32(&mut output[8], choicebit, self.0[8], other.0[8]);\n        fiat_25519_cmovznz_u32(&mut output[9], choicebit, self.0[9], other.0[9]);\n        *self = FieldElement2625::from_limbs(output);\n    }\n\n    fn conditional_swap(a: &mut FieldElement2625, b: &mut FieldElement2625, choice: Choice) {\n        u32::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u32::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u32::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u32::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u32::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n        u32::conditional_swap(&mut a.0[5], &mut b.0[5], choice);\n        u32::conditional_swap(&mut a.0[6], &mut b.0[6], choice);\n        u32::conditional_swap(&mut a.0[7], &mut b.0[7], choice);\n        u32::conditional_swap(&mut a.0[8], &mut b.0[8], choice);\n        u32::conditional_swap(&mut a.0[9], &mut b.0[9], choice);\n    }\n}\n\nimpl FieldElement2625 {\n    pub(crate) const fn from_limbs(limbs: [u32; 10]) -> FieldElement2625 {\n        FieldElement2625(fiat_25519_tight_field_element(limbs))\n    }\n\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: FieldElement2625 = FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: FieldElement2625 = FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    /// The scalar \\\\( -1 \\\\).\n    pub const MINUS_ONE: FieldElement2625 = FieldElement2625::from_limbs([\n        0x3ffffec, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff,\n        0x3ffffff, 0x1ffffff,\n    ]);\n\n    /// Invert the sign of this field element\n    pub fn negate(&mut self) {\n        let neg = self.neg();\n        self.0 = neg.0;\n    }\n\n    /// Given `k > 0`, return `self^(2^k)`.\n    pub fn pow2k(&self, k: u32) -> FieldElement2625 {\n        debug_assert!(k > 0);\n        let mut z = self.square();\n        for _ in 1..k {\n            z = z.square();\n        }\n        z\n    }\n\n    /// Load a `FieldElement2625` from the low 255 bits of a 256-bit\n    /// input.\n    ///\n    /// # Warning\n    ///\n    /// This function does not check that the input used the canonical\n    /// representative.  It masks the high bit, but it will happily\n    /// decode 2^255 - 18 to 1.  Applications that require a canonical\n    /// encoding of every field element should decode, re-encode to\n    /// the canonical encoding, and check that the input was\n    /// canonical.\n    pub const fn from_bytes(data: &[u8; 32]) -> FieldElement2625 {\n        let mut temp = [0u8; 32];\n        temp.copy_from_slice(data);\n        temp[31] &= 127u8;\n        let mut output = fiat_25519_tight_field_element([0u32; 10]);\n        fiat_25519_from_bytes(&mut output, &temp);\n        FieldElement2625(output)\n    }\n\n    /// Serialize this `FieldElement51` to a 32-byte array.  The\n    /// encoding is canonical.\n    pub fn to_bytes(self) -> [u8; 32] {\n        let mut bytes = [0u8; 32];\n        fiat_25519_to_bytes(&mut bytes, &self.0);\n        bytes\n    }\n\n    /// Compute `self^2`.\n    pub fn square(&self) -> FieldElement2625 {\n        let mut self_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_relax(&mut self_loose, &self.0);\n        let mut output = FieldElement2625::ZERO;\n        fiat_25519_carry_square(&mut output.0, &self_loose);\n        output\n    }\n\n    /// Compute `2*self^2`.\n    pub fn square2(&self) -> FieldElement2625 {\n        let mut self_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_relax(&mut self_loose, &self.0);\n        let mut square = fiat_25519_tight_field_element([0; 10]);\n        fiat_25519_carry_square(&mut square, &self_loose);\n        let mut output_loose = fiat_25519_loose_field_element([0; 10]);\n        fiat_25519_add(&mut output_loose, &square, &square);\n        let mut output = FieldElement2625::ZERO;\n        fiat_25519_carry(&mut output.0, &output_loose);\n        output\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/fiat_u32/field.rs",
    "filepath": null,
    "folder_id": 15837,
    "user_id": 460154
  },
  "63622": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2018 Isis Lovecruft, Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Isis Agora Lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! The `u32` backend uses `u32`s and a `(u32, u32) -> u64` multiplier.\n//!\n//! This code is intended to be portable, but it requires that\n//! multiplication of two \\\\(32\\\\)-bit values to a \\\\(64\\\\)-bit result\n//! is constant-time on the target platform.\n//!\n//! This uses the formally-verified field arithmetic generated by the\n//! [fiat-crypto project](https://github.com/mit-plv/fiat-crypto)\n\n#[path = \"../u32/scalar.rs\"]\npub mod scalar;\n\npub mod field;\n\n#[path = \"../u32/constants.rs\"]\npub mod constants;\n",
    "filename": "curve25519-dalek/src/backend/serial/fiat_u32/mod.rs",
    "filepath": null,
    "folder_id": 15837,
    "user_id": 460154
  },
  "63623": {
    "text": "//! Arithmetic mod 2^252 + 27742317777372353535851937790883648493\n//! with 9 29-bit unsigned limbs\n//!\n//! To see that this is safe for intermediate results, note that\n//! the largest limb in a 9 by 9 product of 29-bit limbs will be\n//! (0x1fffffff^2) * 9 = 0x23fffffdc0000009 (62 bits).\n//!\n//! For a one level Karatsuba decomposition, the specific ranges\n//! depend on how the limbs are combined, but will stay within\n//! -0x1ffffffe00000008 (62 bits with sign bit) to\n//! 0x43fffffbc0000011 (63 bits), which is still safe.\n\nuse core::fmt::Debug;\nuse core::ops::{Index, IndexMut};\nuse subtle::{Choice, ConditionallySelectable};\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse crate::constants;\n\n/// The `Scalar29` struct represents an element in \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\) as 9 29-bit\n/// limbs\n#[derive(Copy, Clone)]\npub struct Scalar29 {\n    pub limbs: [u32; 9],\n}\n\nimpl Debug for Scalar29 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar29: {:?}\", &self.limbs[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar29 {\n    fn zeroize(&mut self) {\n        self.limbs.zeroize();\n    }\n}\n\nimpl Index<usize> for Scalar29 {\n    type Output = u32;\n    fn index(&self, _index: usize) -> &u32 {\n        &(self.limbs[_index])\n    }\n}\n\nimpl IndexMut<usize> for Scalar29 {\n    fn index_mut(&mut self, _index: usize) -> &mut u32 {\n        &mut (self.limbs[_index])\n    }\n}\n\n/// u32 * u32 = u64 multiply helper\n#[inline(always)]\nfn m(x: u32, y: u32) -> u64 {\n    (x as u64) * (y as u64)\n}\n\nimpl Scalar29 {\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: Scalar29 = Scalar29 {\n        limbs: [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    };\n\n    /// Unpack a 32 byte / 256 bit scalar into 9 29-bit limbs.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    pub fn from_bytes(bytes: &[u8; 32]) -> Scalar29 {\n        let mut words = [0u32; 8];\n        for i in 0..8 {\n            for j in 0..4 {\n                words[i] |= (bytes[(i * 4) + j] as u32) << (j * 8);\n            }\n        }\n\n        let mask = (1u32 << 29) - 1;\n        let top_mask = (1u32 << 24) - 1;\n        let mut s = Scalar29::ZERO;\n\n        s[0] =   words[0]                            & mask;\n        s[1] = ((words[0] >> 29) | (words[1] <<  3)) & mask;\n        s[2] = ((words[1] >> 26) | (words[2] <<  6)) & mask;\n        s[3] = ((words[2] >> 23) | (words[3] <<  9)) & mask;\n        s[4] = ((words[3] >> 20) | (words[4] << 12)) & mask;\n        s[5] = ((words[4] >> 17) | (words[5] << 15)) & mask;\n        s[6] = ((words[5] >> 14) | (words[6] << 18)) & mask;\n        s[7] = ((words[6] >> 11) | (words[7] << 21)) & mask;\n        s[8] =  (words[7] >>  8)                     & top_mask;\n\n        s\n    }\n\n    /// Reduce a 64 byte / 512 bit scalar mod l.\n    #[rustfmt::skip] // keep alignment of lo[*] calculations\n    pub fn from_bytes_wide(bytes: &[u8; 64]) -> Scalar29 {\n        let mut words = [0u32; 16];\n        for i in 0..16 {\n            for j in 0..4 {\n                words[i] |= (bytes[(i * 4) + j] as u32) << (j * 8);\n            }\n        }\n\n        let mask = (1u32 << 29) - 1;\n        let mut lo = Scalar29::ZERO;\n        let mut hi = Scalar29::ZERO;\n\n        lo[0] =   words[ 0]                             & mask;\n        lo[1] = ((words[ 0] >> 29) | (words[ 1] <<  3)) & mask;\n        lo[2] = ((words[ 1] >> 26) | (words[ 2] <<  6)) & mask;\n        lo[3] = ((words[ 2] >> 23) | (words[ 3] <<  9)) & mask;\n        lo[4] = ((words[ 3] >> 20) | (words[ 4] << 12)) & mask;\n        lo[5] = ((words[ 4] >> 17) | (words[ 5] << 15)) & mask;\n        lo[6] = ((words[ 5] >> 14) | (words[ 6] << 18)) & mask;\n        lo[7] = ((words[ 6] >> 11) | (words[ 7] << 21)) & mask;\n        lo[8] = ((words[ 7] >>  8) | (words[ 8] << 24)) & mask;\n        hi[0] = ((words[ 8] >>  5) | (words[ 9] << 27)) & mask;\n        hi[1] =  (words[ 9] >>  2)                      & mask;\n        hi[2] = ((words[ 9] >> 31) | (words[10] <<  1)) & mask;\n        hi[3] = ((words[10] >> 28) | (words[11] <<  4)) & mask;\n        hi[4] = ((words[11] >> 25) | (words[12] <<  7)) & mask;\n        hi[5] = ((words[12] >> 22) | (words[13] << 10)) & mask;\n        hi[6] = ((words[13] >> 19) | (words[14] << 13)) & mask;\n        hi[7] = ((words[14] >> 16) | (words[15] << 16)) & mask;\n        hi[8] =   words[15] >> 13                             ;\n\n        lo = Scalar29::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar29::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar29::add(&hi, &lo) // (hi * R) + lo\n    }\n\n    /// Pack the limbs of this `Scalar29` into 32 bytes.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    #[allow(clippy::identity_op)]\n    pub fn to_bytes(self) -> [u8; 32] {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.limbs[0] >>  0)                      as u8;\n        s[ 1] =  (self.limbs[0] >>  8)                      as u8;\n        s[ 2] =  (self.limbs[0] >> 16)                      as u8;\n        s[ 3] = ((self.limbs[0] >> 24) | (self.limbs[1] << 5))  as u8;\n        s[ 4] =  (self.limbs[1] >>  3)                      as u8;\n        s[ 5] =  (self.limbs[1] >> 11)                      as u8;\n        s[ 6] =  (self.limbs[1] >> 19)                      as u8;\n        s[ 7] = ((self.limbs[1] >> 27) | (self.limbs[2] << 2))  as u8;\n        s[ 8] =  (self.limbs[2] >>  6)                      as u8;\n        s[ 9] =  (self.limbs[2] >> 14)                      as u8;\n        s[10] = ((self.limbs[2] >> 22) | (self.limbs[3] << 7))  as u8;\n        s[11] =  (self.limbs[3] >>  1)                      as u8;\n        s[12] =  (self.limbs[3] >>  9)                      as u8;\n        s[13] =  (self.limbs[3] >> 17)                      as u8;\n        s[14] = ((self.limbs[3] >> 25) | (self.limbs[4] << 4))  as u8;\n        s[15] =  (self.limbs[4] >>  4)                      as u8;\n        s[16] =  (self.limbs[4] >> 12)                      as u8;\n        s[17] =  (self.limbs[4] >> 20)                      as u8;\n        s[18] = ((self.limbs[4] >> 28) | (self.limbs[5] << 1))  as u8;\n        s[19] =  (self.limbs[5] >>  7)                      as u8;\n        s[20] =  (self.limbs[5] >> 15)                      as u8;\n        s[21] = ((self.limbs[5] >> 23) | (self.limbs[6] << 6))  as u8;\n        s[22] =  (self.limbs[6] >>  2)                      as u8;\n        s[23] =  (self.limbs[6] >> 10)                      as u8;\n        s[24] =  (self.limbs[6] >> 18)                      as u8;\n        s[25] = ((self.limbs[6] >> 26) | (self.limbs[7] << 3))  as u8;\n        s[26] =  (self.limbs[7] >>  5)                      as u8;\n        s[27] =  (self.limbs[7] >> 13)                      as u8;\n        s[28] =  (self.limbs[7] >> 21)                      as u8;\n        s[29] =  (self.limbs[8] >>  0)                      as u8;\n        s[30] =  (self.limbs[8] >>  8)                      as u8;\n        s[31] =  (self.limbs[8] >> 16)                      as u8;\n\n        s\n    }\n\n    /// Compute `a + b` (mod l).\n    pub fn add(a: &Scalar29, b: &Scalar29) -> Scalar29 {\n        let mut sum = Scalar29::ZERO;\n        let mask = (1u32 << 29) - 1;\n\n        // a + b\n        let mut carry: u32 = 0;\n        for i in 0..9 {\n            carry = a[i] + b[i] + (carry >> 29);\n            sum[i] = carry & mask;\n        }\n\n        // subtract l if the sum is >= l\n        Scalar29::sub(&sum, &constants::L)\n    }\n\n    /// Compute `a - b` (mod l).\n    pub fn sub(a: &Scalar29, b: &Scalar29) -> Scalar29 {\n        let mut difference = Scalar29::ZERO;\n        let mask = (1u32 << 29) - 1;\n\n        // a - b\n        let mut borrow: u32 = 0;\n        for i in 0..9 {\n            borrow = a[i].wrapping_sub(b[i] + (borrow >> 31));\n            difference[i] = borrow & mask;\n        }\n\n        // conditionally add l if the difference is negative\n        let mut carry: u32 = 0;\n        for i in 0..9 {\n            let underflow = Choice::from((borrow >> 31) as u8);\n            let addend = u32::conditional_select(&0, &constants::L[i], underflow);\n            carry = (carry >> 29) + difference[i] + addend;\n            difference[i] = carry & mask;\n        }\n\n        difference\n    }\n\n    /// Compute `a * b`.\n    ///\n    /// This is implemented with a one-level refined Karatsuba decomposition\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of z[*] calculations\n    pub (crate) fn mul_internal(a: &Scalar29, b: &Scalar29) -> [u64; 17] {\n        let mut z = [0u64; 17];\n\n        z[0] = m(a[0], b[0]);                                                                 // c00\n        z[1] = m(a[0], b[1]) + m(a[1], b[0]);                                                 // c01\n        z[2] = m(a[0], b[2]) + m(a[1], b[1]) + m(a[2], b[0]);                                 // c02\n        z[3] = m(a[0], b[3]) + m(a[1], b[2]) + m(a[2], b[1]) + m(a[3], b[0]);                 // c03\n        z[4] = m(a[0], b[4]) + m(a[1], b[3]) + m(a[2], b[2]) + m(a[3], b[1]) + m(a[4], b[0]); // c04\n        z[5] =                 m(a[1], b[4]) + m(a[2], b[3]) + m(a[3], b[2]) + m(a[4], b[1]); // c05\n        z[6] =                                 m(a[2], b[4]) + m(a[3], b[3]) + m(a[4], b[2]); // c06\n        z[7] =                                                 m(a[3], b[4]) + m(a[4], b[3]); // c07\n        z[8] =                                                                (m(a[4], b[4])).wrapping_sub(z[3]); // c08 - c03\n\n        z[10] = z[5].wrapping_sub(m(a[5], b[5]));                                                // c05mc10\n        z[11] = z[6].wrapping_sub(m(a[5], b[6]) + m(a[6], b[5]));                                // c06mc11\n        z[12] = z[7].wrapping_sub(m(a[5], b[7]) + m(a[6], b[6]) + m(a[7], b[5]));                // c07mc12\n        z[13] =                   m(a[5], b[8]) + m(a[6], b[7]) + m(a[7], b[6]) + m(a[8], b[5]); // c13\n        z[14] =                                   m(a[6], b[8]) + m(a[7], b[7]) + m(a[8], b[6]); // c14\n        z[15] =                                                   m(a[7], b[8]) + m(a[8], b[7]); // c15\n        z[16] =                                                                   m(a[8], b[8]); // c16\n\n        z[ 5] = z[10].wrapping_sub(z[ 0]); // c05mc10 - c00\n        z[ 6] = z[11].wrapping_sub(z[ 1]); // c06mc11 - c01\n        z[ 7] = z[12].wrapping_sub(z[ 2]); // c07mc12 - c02\n        z[ 8] = z[ 8].wrapping_sub(z[13]); // c08mc13 - c03\n        z[ 9] = z[14].wrapping_add(z[ 4]); // c14 + c04\n        z[10] = z[15].wrapping_add(z[10]); // c15 + c05mc10\n        z[11] = z[16].wrapping_add(z[11]); // c16 + c06mc11\n\n        let aa = [\n            a[0] + a[5],\n            a[1] + a[6],\n            a[2] + a[7],\n            a[3] + a[8]\n        ];\n\n        let bb = [\n            b[0] + b[5],\n            b[1] + b[6],\n            b[2] + b[7],\n            b[3] + b[8]\n        ];\n\n        z[ 5] = (m(aa[0], bb[0]))                                                                       .wrapping_add(z[ 5]); // c20 + c05mc10 - c00\n        z[ 6] = (m(aa[0], bb[1]) + m(aa[1], bb[0]))                                                     .wrapping_add(z[ 6]); // c21 + c06mc11 - c01\n        z[ 7] = (m(aa[0], bb[2]) + m(aa[1], bb[1]) + m(aa[2], bb[0]))                                   .wrapping_add(z[ 7]); // c22 + c07mc12 - c02\n        z[ 8] = (m(aa[0], bb[3]) + m(aa[1], bb[2]) + m(aa[2], bb[1]) + m(aa[3], bb[0]))                 .wrapping_add(z[ 8]); // c23 + c08mc13 - c03\n        z[ 9] = (m(aa[0],  b[4]) + m(aa[1], bb[3]) + m(aa[2], bb[2]) + m(aa[3], bb[1]) + m(a[4], bb[0])).wrapping_sub(z[ 9]); // c24 - c14 - c04\n        z[10] = (                  m(aa[1],  b[4]) + m(aa[2], bb[3]) + m(aa[3], bb[2]) + m(a[4], bb[1])).wrapping_sub(z[10]); // c25 - c15 - c05mc10\n        z[11] = (                                    m(aa[2],  b[4]) + m(aa[3], bb[3]) + m(a[4], bb[2])).wrapping_sub(z[11]); // c26 - c16 - c06mc11\n        z[12] = (                                                      m(aa[3],  b[4]) + m(a[4], bb[3])).wrapping_sub(z[12]); // c27 - c07mc12\n\n        z\n    }\n\n    /// Compute `a^2`.\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of calculations\n    fn square_internal(a: &Scalar29) -> [u64; 17] {\n        let aa = [\n            a[0] * 2,\n            a[1] * 2,\n            a[2] * 2,\n            a[3] * 2,\n            a[4] * 2,\n            a[5] * 2,\n            a[6] * 2,\n            a[7] * 2\n        ];\n\n        [\n            m( a[0], a[0]),\n            m(aa[0], a[1]),\n            m(aa[0], a[2]) + m( a[1], a[1]),\n            m(aa[0], a[3]) + m(aa[1], a[2]),\n            m(aa[0], a[4]) + m(aa[1], a[3]) + m( a[2], a[2]),\n            m(aa[0], a[5]) + m(aa[1], a[4]) + m(aa[2], a[3]),\n            m(aa[0], a[6]) + m(aa[1], a[5]) + m(aa[2], a[4]) + m( a[3], a[3]),\n            m(aa[0], a[7]) + m(aa[1], a[6]) + m(aa[2], a[5]) + m(aa[3], a[4]),\n            m(aa[0], a[8]) + m(aa[1], a[7]) + m(aa[2], a[6]) + m(aa[3], a[5]) + m( a[4], a[4]),\n                             m(aa[1], a[8]) + m(aa[2], a[7]) + m(aa[3], a[6]) + m(aa[4], a[5]),\n                                              m(aa[2], a[8]) + m(aa[3], a[7]) + m(aa[4], a[6]) + m( a[5], a[5]),\n                                                               m(aa[3], a[8]) + m(aa[4], a[7]) + m(aa[5], a[6]),\n                                                                                m(aa[4], a[8]) + m(aa[5], a[7]) + m( a[6], a[6]),\n                                                                                                 m(aa[5], a[8]) + m(aa[6], a[7]),\n                                                                                                                  m(aa[6], a[8]) + m( a[7], a[7]),\n                                                                                                                                   m(aa[7], a[8]),\n                                                                                                                                                    m( a[8], a[8]),\n        ]\n    }\n\n    /// Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^261\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of part1() and part2() computations\n    pub (crate) fn montgomery_reduce(limbs: &[u64; 17]) -> Scalar29 {\n\n        #[inline(always)]\n        fn part1(sum: u64) -> (u64, u32) {\n            let p = (sum as u32).wrapping_mul(constants::LFACTOR) & ((1u32 << 29) - 1);\n            ((sum + m(p,constants::L[0])) >> 29, p)\n        }\n\n        #[inline(always)]\n        fn part2(sum: u64) -> (u64, u32) {\n            let w = (sum as u32) & ((1u32 << 29) - 1);\n            (sum >> 29, w)\n        }\n\n        // note: l5,l6,l7 are zero, so their multiplies can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = part1(        limbs[ 0]);\n        let (carry, n1) = part1(carry + limbs[ 1] + m(n0,l[1]));\n        let (carry, n2) = part1(carry + limbs[ 2] + m(n0,l[2]) + m(n1,l[1]));\n        let (carry, n3) = part1(carry + limbs[ 3] + m(n0,l[3]) + m(n1,l[2]) + m(n2,l[1]));\n        let (carry, n4) = part1(carry + limbs[ 4] + m(n0,l[4]) + m(n1,l[3]) + m(n2,l[2]) + m(n3,l[1]));\n        let (carry, n5) = part1(carry + limbs[ 5]              + m(n1,l[4]) + m(n2,l[3]) + m(n3,l[2]) + m(n4,l[1]));\n        let (carry, n6) = part1(carry + limbs[ 6]                           + m(n2,l[4]) + m(n3,l[3]) + m(n4,l[2]) + m(n5,l[1]));\n        let (carry, n7) = part1(carry + limbs[ 7]                                        + m(n3,l[4]) + m(n4,l[3]) + m(n5,l[2]) + m(n6,l[1]));\n        let (carry, n8) = part1(carry + limbs[ 8] + m(n0,l[8])                                        + m(n4,l[4]) + m(n5,l[3]) + m(n6,l[2]) + m(n7,l[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = part2(carry + limbs[ 9]              + m(n1,l[8])                                        + m(n5,l[4]) + m(n6,l[3]) + m(n7,l[2]) + m(n8,l[1]));\n        let (carry, r1) = part2(carry + limbs[10]                           + m(n2,l[8])                                        + m(n6,l[4]) + m(n7,l[3]) + m(n8,l[2]));\n        let (carry, r2) = part2(carry + limbs[11]                                        + m(n3,l[8])                                        + m(n7,l[4]) + m(n8,l[3]));\n        let (carry, r3) = part2(carry + limbs[12]                                                     + m(n4,l[8])                                        + m(n8,l[4]));\n        let (carry, r4) = part2(carry + limbs[13]                                                                  + m(n5,l[8])                                       );\n        let (carry, r5) = part2(carry + limbs[14]                                                                               + m(n6,l[8])                          );\n        let (carry, r6) = part2(carry + limbs[15]                                                                                            + m(n7,l[8])             );\n        let (carry, r7) = part2(carry + limbs[16]                                                                                                         + m(n8,l[8]));\n        let         r8 = carry as u32;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar29::sub(&Scalar29 { limbs: [r0,r1,r2,r3,r4,r5,r6,r7,r8] }, l)\n    }\n\n    /// Compute `a * b` (mod l).\n    #[inline(never)]\n    pub fn mul(a: &Scalar29, b: &Scalar29) -> Scalar29 {\n        let ab = Scalar29::montgomery_reduce(&Scalar29::mul_internal(a, b));\n        Scalar29::montgomery_reduce(&Scalar29::mul_internal(&ab, &constants::RR))\n    }\n\n    /// Compute `a^2` (mod l).\n    #[inline(never)]\n    #[allow(dead_code)] // XXX we don't expose square() via the Scalar API\n    pub fn square(&self) -> Scalar29 {\n        let aa = Scalar29::montgomery_reduce(&Scalar29::square_internal(self));\n        Scalar29::montgomery_reduce(&Scalar29::mul_internal(&aa, &constants::RR))\n    }\n\n    /// Compute `(a * b) / R` (mod l), where R is the Montgomery modulus 2^261\n    #[inline(never)]\n    pub fn montgomery_mul(a: &Scalar29, b: &Scalar29) -> Scalar29 {\n        Scalar29::montgomery_reduce(&Scalar29::mul_internal(a, b))\n    }\n\n    /// Compute `(a^2) / R` (mod l) in Montgomery form, where R is the Montgomery modulus 2^261\n    #[inline(never)]\n    pub fn montgomery_square(&self) -> Scalar29 {\n        Scalar29::montgomery_reduce(&Scalar29::square_internal(self))\n    }\n\n    /// Puts a Scalar29 in to Montgomery form, i.e. computes `a*R (mod l)`\n    #[inline(never)]\n    pub fn as_montgomery(&self) -> Scalar29 {\n        Scalar29::montgomery_mul(self, &constants::RR)\n    }\n\n    /// Takes a Scalar29 out of Montgomery form, i.e. computes `a/R (mod l)`\n    #[allow(clippy::wrong_self_convention)]\n    pub fn from_montgomery(&self) -> Scalar29 {\n        let mut limbs = [0u64; 17];\n        for i in 0..9 {\n            limbs[i] = self[i] as u64;\n        }\n        Scalar29::montgomery_reduce(&limbs)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    /// Note: x is 2^253-1 which is slightly larger than the largest scalar produced by\n    /// this implementation (l-1), and should verify there are no overflows for valid scalars\n    ///\n    /// x = 2^253-1 = 14474011154664524427946373126085988481658748083205070504932198000989141204991\n    /// x = 7237005577332262213973186563042994240801631723825162898930247062703686954002 mod l\n    /// x = 5147078182513738803124273553712992179887200054963030844803268920753008712037*R mod l in Montgomery form\n    pub static X: Scalar29 = Scalar29 {\n        limbs: [\n            0x1fffffff, 0x1fffffff, 0x1fffffff, 0x1fffffff, 0x1fffffff, 0x1fffffff, 0x1fffffff,\n            0x1fffffff, 0x001fffff,\n        ],\n    };\n\n    /// x^2 = 3078544782642840487852506753550082162405942681916160040940637093560259278169 mod l\n    pub static XX: Scalar29 = Scalar29 {\n        limbs: [\n            0x00217559, 0x000b3401, 0x103ff43b, 0x1462a62c, 0x1d6f9f38, 0x18e7a42f, 0x09a3dcee,\n            0x008dbe18, 0x0006ce65,\n        ],\n    };\n\n    /// x^2 = 2912514428060642753613814151688322857484807845836623976981729207238463947987*R mod l in Montgomery form\n    pub static XX_MONT: Scalar29 = Scalar29 {\n        limbs: [\n            0x152b4d2e, 0x0571d53b, 0x1da6d964, 0x188663b6, 0x1d1b5f92, 0x19d50e3f, 0x12306c29,\n            0x0c6f26fe, 0x00030edb,\n        ],\n    };\n\n    /// y = 6145104759870991071742105800796537629880401874866217824609283457819451087098\n    pub static Y: Scalar29 = Scalar29 {\n        limbs: [\n            0x1e1458fa, 0x165ba838, 0x1d787b36, 0x0e577f3a, 0x1d2baf06, 0x1d689a19, 0x1fff3047,\n            0x117704ab, 0x000d9601,\n        ],\n    };\n\n    /// x*y = 36752150652102274958925982391442301741\n    pub static XY: Scalar29 = Scalar29 {\n        limbs: [\n            0x0ba7632d, 0x017736bb, 0x15c76138, 0x0c69daa1, 0x000001ba, 0x00000000, 0x00000000,\n            0x00000000, 0x00000000,\n        ],\n    };\n\n    /// x*y = 3783114862749659543382438697751927473898937741870308063443170013240655651591*R mod l in Montgomery form\n    pub static XY_MONT: Scalar29 = Scalar29 {\n        limbs: [\n            0x077b51e1, 0x1c64e119, 0x02a19ef5, 0x18d2129e, 0x00de0430, 0x045a7bc8, 0x04cfc7c9,\n            0x1c002681, 0x000bdc1c,\n        ],\n    };\n\n    /// a = 2351415481556538453565687241199399922945659411799870114962672658845158063753\n    pub static A: Scalar29 = Scalar29 {\n        limbs: [\n            0x07b3be89, 0x02291b60, 0x14a99f03, 0x07dc3787, 0x0a782aae, 0x16262525, 0x0cfdb93f,\n            0x13f5718d, 0x000532da,\n        ],\n    };\n\n    /// b = 4885590095775723760407499321843594317911456947580037491039278279440296187236\n    pub static B: Scalar29 = Scalar29 {\n        limbs: [\n            0x15421564, 0x1e69fd72, 0x093d9692, 0x161785be, 0x1587d69f, 0x09d9dada, 0x130246c0,\n            0x0c0a8e72, 0x000acd25,\n        ],\n    };\n\n    /// a+b = 0\n    /// a-b = 4702830963113076907131374482398799845891318823599740229925345317690316127506\n    pub static AB: Scalar29 = Scalar29 {\n        limbs: [\n            0x0f677d12, 0x045236c0, 0x09533e06, 0x0fb86f0f, 0x14f0555c, 0x0c4c4a4a, 0x19fb727f,\n            0x07eae31a, 0x000a65b5,\n        ],\n    };\n\n    // c = (2^512 - 1) % l = 1627715501170711445284395025044413883736156588369414752970002579683115011840\n    pub static C: Scalar29 = Scalar29 {\n        limbs: [\n            0x049c0f00, 0x00308f1a, 0x0164d1e9, 0x1c374ed1, 0x1be65d00, 0x19e90bfa, 0x08f73bb1,\n            0x036f8613, 0x00039941,\n        ],\n    };\n\n    #[test]\n    fn mul_max() {\n        let res = Scalar29::mul(&X, &X);\n        for i in 0..9 {\n            assert!(res[i] == XX[i]);\n        }\n    }\n\n    #[test]\n    fn square_max() {\n        let res = X.square();\n        for i in 0..9 {\n            assert!(res[i] == XX[i]);\n        }\n    }\n\n    #[test]\n    fn montgomery_mul_max() {\n        let res = Scalar29::montgomery_mul(&X, &X);\n        for i in 0..9 {\n            assert!(res[i] == XX_MONT[i]);\n        }\n    }\n\n    #[test]\n    fn montgomery_square_max() {\n        let res = X.montgomery_square();\n        for i in 0..9 {\n            assert!(res[i] == XX_MONT[i]);\n        }\n    }\n\n    #[test]\n    fn mul() {\n        let res = Scalar29::mul(&X, &Y);\n        for i in 0..9 {\n            assert!(res[i] == XY[i]);\n        }\n    }\n\n    #[test]\n    fn montgomery_mul() {\n        let res = Scalar29::montgomery_mul(&X, &Y);\n        for i in 0..9 {\n            assert!(res[i] == XY_MONT[i]);\n        }\n    }\n\n    #[test]\n    fn add() {\n        let res = Scalar29::add(&A, &B);\n        let zero = Scalar29::ZERO;\n        for i in 0..9 {\n            assert!(res[i] == zero[i]);\n        }\n    }\n\n    #[test]\n    fn sub() {\n        let res = Scalar29::sub(&A, &B);\n        for i in 0..9 {\n            assert!(res[i] == AB[i]);\n        }\n    }\n\n    #[test]\n    fn from_bytes_wide() {\n        let bignum = [255u8; 64]; // 2^512 - 1\n        let reduced = Scalar29::from_bytes_wide(&bignum);\n        for i in 0..9 {\n            assert!(reduced[i] == C[i]);\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u32/scalar.rs",
    "filepath": null,
    "folder_id": 15838,
    "user_id": 460154
  },
  "63624": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Field arithmetic modulo \\\\(p = 2\\^{255} - 19\\\\), using \\\\(32\\\\)-bit\n//! limbs with \\\\(64\\\\)-bit products.\n//!\n//! This code was originally derived from Adam Langley's Golang ed25519\n//! implementation, and was then rewritten to use unsigned limbs instead\n//! of signed limbs.\n\nuse core::fmt::Debug;\nuse core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};\nuse core::ops::{Sub, SubAssign};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\n/// A `FieldElement2625` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 32-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{25.5}\\\\) as ten `u32`s.  This means that a field\n/// element \\\\(x\\\\) is represented as\n/// $$\n/// x = \\sum\\_{i=0}\\^9 x\\_i 2\\^{\\lceil i \\frac {51} 2 \\rceil}\n///   = x\\_0 + x\\_1 2\\^{26} + x\\_2 2\\^{51} + x\\_3 2\\^{77} + \\cdots + x\\_9 2\\^{230};\n/// $$\n/// the coefficients are alternately bounded by \\\\(2\\^{25}\\\\) and\n/// \\\\(2\\^{26}\\\\).  The limbs are allowed to grow between reductions up\n/// to \\\\(2\\^{25+b}\\\\) or \\\\(2\\^{26+b}\\\\), where \\\\(b = 1.75\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement2625` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement2625(pub(crate) [u32; 10]);\n\nimpl Debug for FieldElement2625 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement2625({:?})\", &self.0[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement2625 {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}\n\nimpl<'b> AddAssign<&'b FieldElement2625> for FieldElement2625 {\n    fn add_assign(&mut self, _rhs: &'b FieldElement2625) {\n        for i in 0..10 {\n            self.0[i] += _rhs.0[i];\n        }\n    }\n}\n\nimpl<'a, 'b> Add<&'b FieldElement2625> for &'a FieldElement2625 {\n    type Output = FieldElement2625;\n    fn add(self, _rhs: &'b FieldElement2625) -> FieldElement2625 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }\n}\n\nimpl<'b> SubAssign<&'b FieldElement2625> for FieldElement2625 {\n    fn sub_assign(&mut self, _rhs: &'b FieldElement2625) {\n        // See comment in FieldElement51::Sub\n        //\n        // Compute a - b as ((a + 2^4 * p) - b) to avoid underflow.\n        let b = &_rhs.0;\n        self.0 = FieldElement2625::reduce([\n            ((self.0[0] + (0x3ffffed << 4)) - b[0]) as u64,\n            ((self.0[1] + (0x1ffffff << 4)) - b[1]) as u64,\n            ((self.0[2] + (0x3ffffff << 4)) - b[2]) as u64,\n            ((self.0[3] + (0x1ffffff << 4)) - b[3]) as u64,\n            ((self.0[4] + (0x3ffffff << 4)) - b[4]) as u64,\n            ((self.0[5] + (0x1ffffff << 4)) - b[5]) as u64,\n            ((self.0[6] + (0x3ffffff << 4)) - b[6]) as u64,\n            ((self.0[7] + (0x1ffffff << 4)) - b[7]) as u64,\n            ((self.0[8] + (0x3ffffff << 4)) - b[8]) as u64,\n            ((self.0[9] + (0x1ffffff << 4)) - b[9]) as u64,\n        ])\n        .0;\n    }\n}\n\nimpl<'a, 'b> Sub<&'b FieldElement2625> for &'a FieldElement2625 {\n    type Output = FieldElement2625;\n    fn sub(self, _rhs: &'b FieldElement2625) -> FieldElement2625 {\n        let mut output = *self;\n        output -= _rhs;\n        output\n    }\n}\n\nimpl<'b> MulAssign<&'b FieldElement2625> for FieldElement2625 {\n    fn mul_assign(&mut self, _rhs: &'b FieldElement2625) {\n        let result = (self as &FieldElement2625) * _rhs;\n        self.0 = result.0;\n    }\n}\n\nimpl<'a, 'b> Mul<&'b FieldElement2625> for &'a FieldElement2625 {\n    type Output = FieldElement2625;\n\n    #[rustfmt::skip] // keep alignment of z* calculations\n    fn mul(self, _rhs: &'b FieldElement2625) -> FieldElement2625 {\n        /// Helper function to multiply two 32-bit integers with 64 bits\n        /// of output.\n        #[inline(always)]\n        fn m(x: u32, y: u32) -> u64 {\n            (x as u64) * (y as u64)\n        }\n\n        // Alias self, _rhs for more readable formulas\n        let x: &[u32; 10] = &self.0;\n        let y: &[u32; 10] = &_rhs.0;\n\n        // We assume that the input limbs x[i], y[i] are bounded by:\n        //\n        // x[i], y[i] < 2^(26 + b) if i even\n        // x[i], y[i] < 2^(25 + b) if i odd\n        //\n        // where b is a (real) parameter representing the excess bits of\n        // the limbs.  We track the bitsizes of all variables through\n        // the computation and solve at the end for the allowable\n        // headroom bitsize b (which determines how many additions we\n        // can perform between reductions or multiplications).\n\n        let y1_19 = 19 * y[1]; // This fits in a u32\n        let y2_19 = 19 * y[2]; // iff 26 + b + lg(19) < 32\n        let y3_19 = 19 * y[3]; // if  b < 32 - 26 - 4.248 = 1.752\n        let y4_19 = 19 * y[4];\n        let y5_19 = 19 * y[5]; // below, b<2.5: this is a bottleneck,\n        let y6_19 = 19 * y[6]; // could be avoided by promoting to\n        let y7_19 = 19 * y[7]; // u64 here instead of in m()\n        let y8_19 = 19 * y[8];\n        let y9_19 = 19 * y[9];\n\n        // What happens when we multiply x[i] with y[j] and place the\n        // result into the (i+j)-th limb?\n        //\n        // x[i]      represents the value x[i]*2^ceil(i*51/2)\n        // y[j]      represents the value y[j]*2^ceil(j*51/2)\n        // z[i+j]    represents the value z[i+j]*2^ceil((i+j)*51/2)\n        // x[i]*y[j] represents the value x[i]*y[i]*2^(ceil(i*51/2)+ceil(j*51/2))\n        //\n        // Since the radix is already accounted for, the result placed\n        // into the (i+j)-th limb should be\n        //\n        // x[i]*y[i]*2^(ceil(i*51/2)+ceil(j*51/2) - ceil((i+j)*51/2)).\n        //\n        // The value of ceil(i*51/2)+ceil(j*51/2) - ceil((i+j)*51/2) is\n        // 1 when both i and j are odd, and 0 otherwise.  So we add\n        //\n        //   x[i]*y[j] if either i or j is even\n        // 2*x[i]*y[j] if i and j are both odd\n        //\n        // by using precomputed multiples of x[i] for odd i:\n\n        let x1_2 = 2 * x[1]; // This fits in a u32 iff 25 + b + 1 < 32\n        let x3_2 = 2 * x[3]; //                    iff b < 6\n        let x5_2 = 2 * x[5];\n        let x7_2 = 2 * x[7];\n        let x9_2 = 2 * x[9];\n\n        let z0 = m(x[0], y[0]) + m(x1_2, y9_19) + m(x[2], y8_19) + m(x3_2, y7_19) + m(x[4], y6_19) + m(x5_2, y5_19) + m(x[6], y4_19) + m(x7_2, y3_19) + m(x[8], y2_19) + m(x9_2, y1_19);\n        let z1 = m(x[0], y[1]) + m(x[1],  y[0]) + m(x[2], y9_19) + m(x[3], y8_19) + m(x[4], y7_19) + m(x[5], y6_19) + m(x[6], y5_19) + m(x[7], y4_19) + m(x[8], y3_19) + m(x[9], y2_19);\n        let z2 = m(x[0], y[2]) + m(x1_2,  y[1]) + m(x[2], y[0])  + m(x3_2, y9_19) + m(x[4], y8_19) + m(x5_2, y7_19) + m(x[6], y6_19) + m(x7_2, y5_19) + m(x[8], y4_19) + m(x9_2, y3_19);\n        let z3 = m(x[0], y[3]) + m(x[1],  y[2]) + m(x[2], y[1])  + m(x[3],  y[0]) + m(x[4], y9_19) + m(x[5], y8_19) + m(x[6], y7_19) + m(x[7], y6_19) + m(x[8], y5_19) + m(x[9], y4_19);\n        let z4 = m(x[0], y[4]) + m(x1_2,  y[3]) + m(x[2], y[2])  + m(x3_2,  y[1]) + m(x[4],  y[0]) + m(x5_2, y9_19) + m(x[6], y8_19) + m(x7_2, y7_19) + m(x[8], y6_19) + m(x9_2, y5_19);\n        let z5 = m(x[0], y[5]) + m(x[1],  y[4]) + m(x[2], y[3])  + m(x[3],  y[2]) + m(x[4],  y[1]) + m(x[5],  y[0]) + m(x[6], y9_19) + m(x[7], y8_19) + m(x[8], y7_19) + m(x[9], y6_19);\n        let z6 = m(x[0], y[6]) + m(x1_2,  y[5]) + m(x[2], y[4])  + m(x3_2,  y[3]) + m(x[4],  y[2]) + m(x5_2,  y[1]) + m(x[6],  y[0]) + m(x7_2, y9_19) + m(x[8], y8_19) + m(x9_2, y7_19);\n        let z7 = m(x[0], y[7]) + m(x[1],  y[6]) + m(x[2], y[5])  + m(x[3],  y[4]) + m(x[4],  y[3]) + m(x[5],  y[2]) + m(x[6],  y[1]) + m(x[7],  y[0]) + m(x[8], y9_19) + m(x[9], y8_19);\n        let z8 = m(x[0], y[8]) + m(x1_2,  y[7]) + m(x[2], y[6])  + m(x3_2,  y[5]) + m(x[4],  y[4]) + m(x5_2,  y[3]) + m(x[6],  y[2]) + m(x7_2,  y[1]) + m(x[8],  y[0]) + m(x9_2, y9_19);\n        let z9 = m(x[0], y[9]) + m(x[1],  y[8]) + m(x[2], y[7])  + m(x[3],  y[6]) + m(x[4],  y[5]) + m(x[5],  y[4]) + m(x[6],  y[3]) + m(x[7],  y[2]) + m(x[8],  y[1]) + m(x[9],  y[0]);\n\n        // How big is the contribution to z[i+j] from x[i], y[j]?\n        //\n        // Using the bounds above, we get:\n        //\n        // i even, j even:   x[i]*y[j] <   2^(26+b)*2^(26+b) = 2*2^(51+2*b)\n        // i  odd, j even:   x[i]*y[j] <   2^(25+b)*2^(26+b) = 1*2^(51+2*b)\n        // i even, j  odd:   x[i]*y[j] <   2^(26+b)*2^(25+b) = 1*2^(51+2*b)\n        // i  odd, j  odd: 2*x[i]*y[j] < 2*2^(25+b)*2^(25+b) = 1*2^(51+2*b)\n        //\n        // We perform inline reduction mod p by replacing 2^255 by 19\n        // (since 2^255 - 19 = 0 mod p).  This adds a factor of 19, so\n        // we get the bounds (z0 is the biggest one, but calculated for\n        // posterity here in case finer estimation is needed later):\n        //\n        //  z0 < ( 2 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 249*2^(51 + 2*b)\n        //  z1 < ( 1 +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 154*2^(51 + 2*b)\n        //  z2 < ( 2 +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 195*2^(51 + 2*b)\n        //  z3 < ( 1 +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) = 118*2^(51 + 2*b)\n        //  z4 < ( 2 +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) = 141*2^(51 + 2*b)\n        //  z5 < ( 1 +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 + 1*19 + 1*19 )*2^(51 + 2b) =  82*2^(51 + 2*b)\n        //  z6 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 + 2*19 + 1*19 )*2^(51 + 2b) =  87*2^(51 + 2*b)\n        //  z7 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   + 1*19 + 1*19 )*2^(51 + 2b) =  46*2^(51 + 2*b)\n        //  z6 < ( 2 +  1   +  2   +  1   +  2   +  1   +  2   +  1   +  2   + 1*19 )*2^(51 + 2b) =  33*2^(51 + 2*b)\n        //  z7 < ( 1 +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   +  1   )*2^(51 + 2b) =  10*2^(51 + 2*b)\n        //\n        // So z[0] fits into a u64 if 51 + 2*b + lg(249) < 64\n        //                         if b < 2.5.\n        FieldElement2625::reduce([z0, z1, z2, z3, z4, z5, z6, z7, z8, z9])\n    }\n}\n\nimpl<'a> Neg for &'a FieldElement2625 {\n    type Output = FieldElement2625;\n    fn neg(self) -> FieldElement2625 {\n        let mut output = *self;\n        output.negate();\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement2625 {\n    fn conditional_select(\n        a: &FieldElement2625,\n        b: &FieldElement2625,\n        choice: Choice,\n    ) -> FieldElement2625 {\n        FieldElement2625([\n            u32::conditional_select(&a.0[0], &b.0[0], choice),\n            u32::conditional_select(&a.0[1], &b.0[1], choice),\n            u32::conditional_select(&a.0[2], &b.0[2], choice),\n            u32::conditional_select(&a.0[3], &b.0[3], choice),\n            u32::conditional_select(&a.0[4], &b.0[4], choice),\n            u32::conditional_select(&a.0[5], &b.0[5], choice),\n            u32::conditional_select(&a.0[6], &b.0[6], choice),\n            u32::conditional_select(&a.0[7], &b.0[7], choice),\n            u32::conditional_select(&a.0[8], &b.0[8], choice),\n            u32::conditional_select(&a.0[9], &b.0[9], choice),\n        ])\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement2625, choice: Choice) {\n        self.0[0].conditional_assign(&other.0[0], choice);\n        self.0[1].conditional_assign(&other.0[1], choice);\n        self.0[2].conditional_assign(&other.0[2], choice);\n        self.0[3].conditional_assign(&other.0[3], choice);\n        self.0[4].conditional_assign(&other.0[4], choice);\n        self.0[5].conditional_assign(&other.0[5], choice);\n        self.0[6].conditional_assign(&other.0[6], choice);\n        self.0[7].conditional_assign(&other.0[7], choice);\n        self.0[8].conditional_assign(&other.0[8], choice);\n        self.0[9].conditional_assign(&other.0[9], choice);\n    }\n\n    fn conditional_swap(a: &mut FieldElement2625, b: &mut FieldElement2625, choice: Choice) {\n        u32::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u32::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u32::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u32::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u32::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n        u32::conditional_swap(&mut a.0[5], &mut b.0[5], choice);\n        u32::conditional_swap(&mut a.0[6], &mut b.0[6], choice);\n        u32::conditional_swap(&mut a.0[7], &mut b.0[7], choice);\n        u32::conditional_swap(&mut a.0[8], &mut b.0[8], choice);\n        u32::conditional_swap(&mut a.0[9], &mut b.0[9], choice);\n    }\n}\n\nimpl FieldElement2625 {\n    pub(crate) const fn from_limbs(limbs: [u32; 10]) -> FieldElement2625 {\n        FieldElement2625(limbs)\n    }\n\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: FieldElement2625 = FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: FieldElement2625 = FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    /// The scalar \\\\( -1 \\\\).\n    pub const MINUS_ONE: FieldElement2625 = FieldElement2625::from_limbs([\n        0x3ffffec, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff,\n        0x3ffffff, 0x1ffffff,\n    ]);\n\n    /// Invert the sign of this field element\n    pub fn negate(&mut self) {\n        // Compute -b as ((2^4 * p) - b) to avoid underflow.\n        let neg = FieldElement2625::reduce([\n            ((0x3ffffed << 4) - self.0[0]) as u64,\n            ((0x1ffffff << 4) - self.0[1]) as u64,\n            ((0x3ffffff << 4) - self.0[2]) as u64,\n            ((0x1ffffff << 4) - self.0[3]) as u64,\n            ((0x3ffffff << 4) - self.0[4]) as u64,\n            ((0x1ffffff << 4) - self.0[5]) as u64,\n            ((0x3ffffff << 4) - self.0[6]) as u64,\n            ((0x1ffffff << 4) - self.0[7]) as u64,\n            ((0x3ffffff << 4) - self.0[8]) as u64,\n            ((0x1ffffff << 4) - self.0[9]) as u64,\n        ]);\n        self.0 = neg.0;\n    }\n\n    /// Given `k > 0`, return `self^(2^k)`.\n    pub fn pow2k(&self, k: u32) -> FieldElement2625 {\n        debug_assert!(k > 0);\n        let mut z = self.square();\n        for _ in 1..k {\n            z = z.square();\n        }\n        z\n    }\n\n    /// Given unreduced coefficients `z[0], ..., z[9]` of any size,\n    /// carry and reduce them mod p to obtain a `FieldElement2625`\n    /// whose coefficients have excess `b < 0.007`.\n    ///\n    /// In other words, each coefficient of the result is bounded by\n    /// either `2^(25 + 0.007)` or `2^(26 + 0.007)`, as appropriate.\n    #[rustfmt::skip] // keep alignment of carry chain\n    const fn reduce(mut z: [u64; 10]) -> FieldElement2625 {\n\n        const LOW_25_BITS: u64 = (1 << 25) - 1;\n        const LOW_26_BITS: u64 = (1 << 26) - 1;\n\n        /// Carry the value from limb i = 0..8 to limb i+1\n        #[inline(always)]\n        const fn carry(z: &mut [u64; 10], i: usize) {\n            debug_assert!(i < 9);\n            if i % 2 == 0 {\n                // Even limbs have 26 bits\n                z[i + 1] += z[i] >> 26;\n                z[i] &= LOW_26_BITS;\n            } else {\n                // Odd limbs have 25 bits\n                z[i + 1] += z[i] >> 25;\n                z[i] &= LOW_25_BITS;\n            }\n        }\n\n        // Perform two halves of the carry chain in parallel.\n        carry(&mut z, 0); carry(&mut z, 4);\n        carry(&mut z, 1); carry(&mut z, 5);\n        carry(&mut z, 2); carry(&mut z, 6);\n        carry(&mut z, 3); carry(&mut z, 7);\n        // Since z[3] < 2^64, c < 2^(64-25) = 2^39,\n        // so    z[4] < 2^26 + 2^39 < 2^39.0002\n        carry(&mut z, 4); carry(&mut z, 8);\n        // Now z[4] < 2^26\n        // and z[5] < 2^25 + 2^13.0002 < 2^25.0004 (good enough)\n\n        // Last carry has a multiplication by 19:\n        z[0] += 19 * (z[9] >> 25);\n        z[9] &= LOW_25_BITS;\n\n        // Since z[9] < 2^64, c < 2^(64-25) = 2^39,\n        //    so z[0] + 19*c < 2^26 + 2^43.248 < 2^43.249.\n        carry(&mut z, 0);\n        // Now z[1] < 2^25 - 2^(43.249 - 26)\n        //          < 2^25.007 (good enough)\n        // and we're done.\n\n        FieldElement2625([\n            z[0] as u32,\n            z[1] as u32,\n            z[2] as u32,\n            z[3] as u32,\n            z[4] as u32,\n            z[5] as u32,\n            z[6] as u32,\n            z[7] as u32,\n            z[8] as u32,\n            z[9] as u32,\n        ])\n    }\n\n    /// Load a `FieldElement51` from the low 255 bits of a 256-bit\n    /// input.\n    ///\n    /// # Warning\n    ///\n    /// This function does not check that the input used the canonical\n    /// representative.  It masks the high bit, but it will happily\n    /// decode 2^255 - 18 to 1.  Applications that require a canonical\n    /// encoding of every field element should decode, re-encode to\n    /// the canonical encoding, and check that the input was\n    /// canonical.\n    #[rustfmt::skip] // keep alignment of h[*] values\n    pub const fn from_bytes(data: &[u8; 32]) -> FieldElement2625 {\n        #[inline]\n        const fn load3_at(b: &[u8], i: usize) -> u64 {\n           (b[i] as u64) | ((b[i + 1] as u64) << 8) | ((b[i + 2] as u64) << 16)\n        }\n\n        #[inline]\n        const fn load4_at(b: &[u8], i: usize) -> u64 {\n           (b[i] as u64)\n           | ((b[i + 1] as u64) << 8)\n           | ((b[i + 2] as u64) << 16)\n           | ((b[i + 3] as u64) << 24)\n        }\n\n        let mut h = [0u64;10];\n        const LOW_23_BITS: u64 = (1 << 23) - 1;\n        h[0] =  load4_at(data,  0);\n        h[1] =  load3_at(data,  4) << 6;\n        h[2] =  load3_at(data,  7) << 5;\n        h[3] =  load3_at(data, 10) << 3;\n        h[4] =  load3_at(data, 13) << 2;\n        h[5] =  load4_at(data, 16);\n        h[6] =  load3_at(data, 20) << 7;\n        h[7] =  load3_at(data, 23) << 5;\n        h[8] =  load3_at(data, 26) << 4;\n        h[9] = (load3_at(data, 29) & LOW_23_BITS) << 2;\n\n        FieldElement2625::reduce(h)\n    }\n\n    /// Serialize this `FieldElement51` to a 32-byte array.  The\n    /// encoding is canonical.\n    #[allow(clippy::identity_op)]\n    pub fn to_bytes(self) -> [u8; 32] {\n        let inp = &self.0;\n        // Reduce the value represented by `in` to the range [0,2*p)\n        let mut h: [u32; 10] = FieldElement2625::reduce([\n            // XXX this cast is annoying\n            inp[0] as u64,\n            inp[1] as u64,\n            inp[2] as u64,\n            inp[3] as u64,\n            inp[4] as u64,\n            inp[5] as u64,\n            inp[6] as u64,\n            inp[7] as u64,\n            inp[8] as u64,\n            inp[9] as u64,\n        ])\n        .0;\n\n        // Let h be the value to encode.\n        //\n        // Write h = pq + r with 0 <= r < p.  We want to compute r = h mod p.\n        //\n        // Since h < 2*p, q = 0 or 1, with q = 0 when h < p and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        let mut q: u32 = (h[0] + 19) >> 26;\n        q = (h[1] + q) >> 25;\n        q = (h[2] + q) >> 26;\n        q = (h[3] + q) >> 25;\n        q = (h[4] + q) >> 26;\n        q = (h[5] + q) >> 25;\n        q = (h[6] + q) >> 26;\n        q = (h[7] + q) >> 25;\n        q = (h[8] + q) >> 26;\n        q = (h[9] + q) >> 25;\n\n        debug_assert!(q == 0 || q == 1);\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        const LOW_25_BITS: u32 = (1 << 25) - 1;\n        const LOW_26_BITS: u32 = (1 << 26) - 1;\n\n        h[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q...\n        h[1] += h[0] >> 26;\n        h[0] &= LOW_26_BITS;\n        h[2] += h[1] >> 25;\n        h[1] &= LOW_25_BITS;\n        h[3] += h[2] >> 26;\n        h[2] &= LOW_26_BITS;\n        h[4] += h[3] >> 25;\n        h[3] &= LOW_25_BITS;\n        h[5] += h[4] >> 26;\n        h[4] &= LOW_26_BITS;\n        h[6] += h[5] >> 25;\n        h[5] &= LOW_25_BITS;\n        h[7] += h[6] >> 26;\n        h[6] &= LOW_26_BITS;\n        h[8] += h[7] >> 25;\n        h[7] &= LOW_25_BITS;\n        h[9] += h[8] >> 26;\n        h[8] &= LOW_26_BITS;\n\n        // ... but instead of carrying the value\n        // (h[9] >> 25) = q*2^255 into another limb,\n        // discard it, subtracting the value from h.\n        debug_assert!((h[9] >> 25) == 0 || (h[9] >> 25) == 1);\n        h[9] &= LOW_25_BITS;\n\n        let mut s = [0u8; 32];\n        s[0] = (h[0] >> 0) as u8;\n        s[1] = (h[0] >> 8) as u8;\n        s[2] = (h[0] >> 16) as u8;\n        s[3] = ((h[0] >> 24) | (h[1] << 2)) as u8;\n        s[4] = (h[1] >> 6) as u8;\n        s[5] = (h[1] >> 14) as u8;\n        s[6] = ((h[1] >> 22) | (h[2] << 3)) as u8;\n        s[7] = (h[2] >> 5) as u8;\n        s[8] = (h[2] >> 13) as u8;\n        s[9] = ((h[2] >> 21) | (h[3] << 5)) as u8;\n        s[10] = (h[3] >> 3) as u8;\n        s[11] = (h[3] >> 11) as u8;\n        s[12] = ((h[3] >> 19) | (h[4] << 6)) as u8;\n        s[13] = (h[4] >> 2) as u8;\n        s[14] = (h[4] >> 10) as u8;\n        s[15] = (h[4] >> 18) as u8;\n        s[16] = (h[5] >> 0) as u8;\n        s[17] = (h[5] >> 8) as u8;\n        s[18] = (h[5] >> 16) as u8;\n        s[19] = ((h[5] >> 24) | (h[6] << 1)) as u8;\n        s[20] = (h[6] >> 7) as u8;\n        s[21] = (h[6] >> 15) as u8;\n        s[22] = ((h[6] >> 23) | (h[7] << 3)) as u8;\n        s[23] = (h[7] >> 5) as u8;\n        s[24] = (h[7] >> 13) as u8;\n        s[25] = ((h[7] >> 21) | (h[8] << 4)) as u8;\n        s[26] = (h[8] >> 4) as u8;\n        s[27] = (h[8] >> 12) as u8;\n        s[28] = ((h[8] >> 20) | (h[9] << 6)) as u8;\n        s[29] = (h[9] >> 2) as u8;\n        s[30] = (h[9] >> 10) as u8;\n        s[31] = (h[9] >> 18) as u8;\n\n        // Check that high bit is cleared\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }\n\n    #[rustfmt::skip] // keep alignment of z* calculations\n    fn square_inner(&self) -> [u64; 10] {\n        // Optimized version of multiplication for the case of squaring.\n        // Pre- and post- conditions identical to multiplication function.\n        let x = &self.0;\n        let x0_2  =  2 * x[0];\n        let x1_2  =  2 * x[1];\n        let x2_2  =  2 * x[2];\n        let x3_2  =  2 * x[3];\n        let x4_2  =  2 * x[4];\n        let x5_2  =  2 * x[5];\n        let x6_2  =  2 * x[6];\n        let x7_2  =  2 * x[7];\n        let x5_19 = 19 * x[5];\n        let x6_19 = 19 * x[6];\n        let x7_19 = 19 * x[7];\n        let x8_19 = 19 * x[8];\n        let x9_19 = 19 * x[9];\n\n        /// Helper function to multiply two 32-bit integers with 64 bits\n        /// of output.\n        #[inline(always)]\n        fn m(x: u32, y: u32) -> u64 {\n            (x as u64) * (y as u64)\n        }\n\n        // This block is rearranged so that instead of doing a 32-bit multiplication by 38, we do a\n        // 64-bit multiplication by 2 on the results.  This is because lg(38) is too big: we would\n        // have less than 1 bit of headroom left, which is too little.\n        let mut z = [0u64; 10];\n        z[0] = m(x[0], x[0]) + m(x2_2, x8_19) + m(x4_2, x6_19) + (m(x1_2, x9_19) +  m(x3_2, x7_19) + m(x[5], x5_19)) * 2;\n        z[1] = m(x0_2, x[1]) + m(x3_2, x8_19) + m(x5_2, x6_19) + (m(x[2], x9_19) +  m(x[4], x7_19)                 ) * 2;\n        z[2] = m(x0_2, x[2]) + m(x1_2,  x[1]) + m(x4_2, x8_19) +  m(x[6], x6_19) + (m(x3_2, x9_19) + m(x5_2, x7_19)) * 2;\n        z[3] = m(x0_2, x[3]) + m(x1_2,  x[2]) + m(x5_2, x8_19) + (m(x[4], x9_19) +  m(x[6], x7_19)                 ) * 2;\n        z[4] = m(x0_2, x[4]) + m(x1_2,  x3_2) + m(x[2],  x[2]) +  m(x6_2, x8_19) + (m(x5_2, x9_19) + m(x[7], x7_19)) * 2;\n        z[5] = m(x0_2, x[5]) + m(x1_2,  x[4]) + m(x2_2,  x[3]) +  m(x7_2, x8_19) +  m(x[6], x9_19)                   * 2;\n        z[6] = m(x0_2, x[6]) + m(x1_2,  x5_2) + m(x2_2,  x[4]) +  m(x3_2,  x[3]) +  m(x[8], x8_19) + m(x7_2, x9_19)  * 2;\n        z[7] = m(x0_2, x[7]) + m(x1_2,  x[6]) + m(x2_2,  x[5]) +  m(x3_2,  x[4]) +  m(x[8], x9_19)                   * 2;\n        z[8] = m(x0_2, x[8]) + m(x1_2,  x7_2) + m(x2_2,  x[6]) +  m(x3_2,  x5_2) +  m(x[4],  x[4]) + m(x[9], x9_19)  * 2;\n        z[9] = m(x0_2, x[9]) + m(x1_2,  x[8]) + m(x2_2,  x[7]) +  m(x3_2,  x[6]) +  m(x4_2,  x[5])                      ;\n\n        z\n    }\n\n    /// Compute `self^2`.\n    pub fn square(&self) -> FieldElement2625 {\n        FieldElement2625::reduce(self.square_inner())\n    }\n\n    /// Compute `2*self^2`.\n    pub fn square2(&self) -> FieldElement2625 {\n        let mut coeffs = self.square_inner();\n        for coeff in &mut coeffs {\n            *coeff += *coeff;\n        }\n        FieldElement2625::reduce(coeffs)\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u32/field.rs",
    "filepath": null,
    "folder_id": 15838,
    "user_id": 460154
  },
  "63625": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! This module contains various constants (such as curve parameters\n//! and useful field elements like `sqrt(-1)`), as well as\n//! lookup tables of pre-computed points.\n\nuse super::field::FieldElement2625;\nuse super::scalar::Scalar29;\nuse crate::edwards::EdwardsPoint;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::{\n    backend::serial::curve_models::AffineNielsPoint,\n    edwards::EdwardsBasepointTable,\n    window::{LookupTable, NafLookupTable8},\n};\n\n/// The value of minus one, equal to `-&FieldElement::ONE`\npub(crate) const MINUS_ONE: FieldElement2625 = FieldElement2625::from_limbs([\n    67108844, 33554431, 67108863, 33554431, 67108863, 33554431, 67108863, 33554431, 67108863,\n    33554431,\n]);\n\n/// sqrt(-486664)\n#[cfg(feature = \"digest\")]\npub(crate) const ED25519_SQRTAM2: FieldElement2625 = FieldElement2625::from_limbs([\n    54885894, 25242303, 55597453, 9067496, 51808079, 33312638, 25456129, 14121551, 54921728,\n    3972023,\n]);\n\n/// Edwards `d` value, equal to `-121665/121666 mod p`.\npub(crate) const EDWARDS_D: FieldElement2625 = FieldElement2625::from_limbs([\n    56195235, 13857412, 51736253, 6949390, 114729, 24766616, 60832955, 30306712, 48412415, 21499315,\n]);\n\n/// Edwards `2*d` value, equal to `2*(-121665/121666) mod p`.\npub(crate) const EDWARDS_D2: FieldElement2625 = FieldElement2625::from_limbs([\n    45281625, 27714825, 36363642, 13898781, 229458, 15978800, 54557047, 27058993, 29715967, 9444199,\n]);\n\n/// One minus edwards `d` value squared, equal to `(1 - (-121665/121666) mod p) pow 2`\npub(crate) const ONE_MINUS_EDWARDS_D_SQUARED: FieldElement2625 = FieldElement2625::from_limbs([\n    6275446, 16937061, 44170319, 29780721, 11667076, 7397348, 39186143, 1766194, 42675006, 672202,\n]);\n\n/// Edwards `d` value minus one squared, equal to `(((-121665/121666) mod p) - 1) pow 2`\npub(crate) const EDWARDS_D_MINUS_ONE_SQUARED: FieldElement2625 = FieldElement2625::from_limbs([\n    15551776, 22456977, 53683765, 23429360, 55212328, 10178283, 40474537, 4729243, 61826754,\n    23438029,\n]);\n\n/// `= sqrt(a*d - 1)`, where `a = -1 (mod p)`, `d` are the Edwards curve parameters.\npub(crate) const SQRT_AD_MINUS_ONE: FieldElement2625 = FieldElement2625::from_limbs([\n    24849947, 33400850, 43495378, 6347714, 46036536, 32887293, 41837720, 18186727, 66238516,\n    14525638,\n]);\n\n/// `= 1/sqrt(a-d)`, where `a = -1 (mod p)`, `d` are the Edwards curve parameters.\npub(crate) const INVSQRT_A_MINUS_D: FieldElement2625 = FieldElement2625::from_limbs([\n    6111466, 4156064, 39310137, 12243467, 41204824, 120896, 20826367, 26493656, 6093567, 31568420,\n]);\n\n/// Precomputed value of one of the square roots of -1 (mod p)\npub(crate) const SQRT_M1: FieldElement2625 = FieldElement2625::from_limbs([\n    34513072, 25610706, 9377949, 3500415, 12389472, 33281959, 41962654, 31548777, 326685, 11406482,\n]);\n\n/// `APLUS2_OVER_FOUR` is (A+2)/4. (This is used internally within the Montgomery ladder.)\npub(crate) const APLUS2_OVER_FOUR: FieldElement2625 =\n    FieldElement2625::from_limbs([121666, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\n/// `MONTGOMERY_A` is equal to 486662, which is a constant of the curve equation\n/// for Curve25519 in its Montgomery form. (This is used internally within the\n/// Elligator map.)\npub(crate) const MONTGOMERY_A: FieldElement2625 =\n    FieldElement2625::from_limbs([486662, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\n/// `MONTGOMERY_A_NEG` is equal to -486662. (This is used internally within the\n/// Elligator map.)\npub(crate) const MONTGOMERY_A_NEG: FieldElement2625 = FieldElement2625::from_limbs([\n    66622183, 33554431, 67108863, 33554431, 67108863, 33554431, 67108863, 33554431, 67108863,\n    33554431,\n]);\n\n/// `L` is the order of base point, i.e. 2^252 +\n/// 27742317777372353535851937790883648493\npub(crate) const L: Scalar29 = Scalar29 {\n    limbs: [\n        0x1cf5d3ed, 0x009318d2, 0x1de73596, 0x1df3bd45, 0x0000014d, 0x00000000, 0x00000000,\n        0x00000000, 0x00100000,\n    ],\n};\n\n/// `L` * `LFACTOR` = -1 (mod 2^29)\npub(crate) const LFACTOR: u32 = 0x12547e1b;\n\n/// `R` = R % L where R = 2^261\npub(crate) const R: Scalar29 = Scalar29 {\n    limbs: [\n        0x114df9ed, 0x1a617303, 0x0f7c098c, 0x16793167, 0x1ffd656e, 0x1fffffff, 0x1fffffff,\n        0x1fffffff, 0x000fffff,\n    ],\n};\n\n/// `RR` = (R^2) % L where R = 2^261\npub(crate) const RR: Scalar29 = Scalar29 {\n    limbs: [\n        0x0b5f9d12, 0x1e141b17, 0x158d7f3d, 0x143f3757, 0x1972d781, 0x042feb7c, 0x1ceec73d,\n        0x1e184d1e, 0x0005046d,\n    ],\n};\n\n/// The Ed25519 basepoint, as an `EdwardsPoint`.\n///\n/// This is called `_POINT` to distinguish it from\n/// `ED25519_BASEPOINT_TABLE`, which should be used for scalar\n/// multiplication (it's much faster).\npub const ED25519_BASEPOINT_POINT: EdwardsPoint = EdwardsPoint {\n    X: FieldElement2625::from_limbs([\n        52811034, 25909283, 16144682, 17082669, 27570973, 30858332, 40966398, 8378388, 20764389,\n        8758491,\n    ]),\n    Y: FieldElement2625::from_limbs([\n        40265304, 26843545, 13421772, 20132659, 26843545, 6710886, 53687091, 13421772, 40265318,\n        26843545,\n    ]),\n    Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n    T: FieldElement2625::from_limbs([\n        28827043, 27438313, 39759291, 244362, 8635006, 11264893, 19351346, 13413597, 16611511,\n        27139452,\n    ]),\n};\n\n/// The 8-torsion subgroup \\\\(\\mathcal E \\[8\\]\\\\).\n///\n/// In the case of Curve25519, it is cyclic; the \\\\(i\\\\)-th element of\n/// the array is \\\\([i]P\\\\), where \\\\(P\\\\) is a point of order \\\\(8\\\\)\n/// generating \\\\(\\mathcal E\\[8\\]\\\\).\n///\n/// Thus \\\\(\\mathcal E\\[4\\]\\\\) is the points indexed by `0,2,4,6`, and\n/// \\\\(\\mathcal E\\[2\\]\\\\) is the points indexed by `0,4`.\n/// The Ed25519 basepoint has y = 4/5.  This is called `_POINT` to\n/// distinguish it from `_TABLE`, which should be used for scalar\n/// multiplication (it's much faster).\npub const EIGHT_TORSION: [EdwardsPoint; 8] = EIGHT_TORSION_INNER_DOC_HIDDEN;\n\n/// Inner item used to hide limb constants from cargo doc output.\n#[doc(hidden)]\npub const EIGHT_TORSION_INNER_DOC_HIDDEN: [EdwardsPoint; 8] = [\n    EdwardsPoint {\n        X: FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        Y: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        T: FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement2625::from_limbs([\n            21352778, 5345713, 4660180, 25206575, 24143089, 14568123, 30185756, 21306662, 33579924,\n            8345318,\n        ]),\n        Y: FieldElement2625::from_limbs([\n            6952903, 1265500, 60246523, 7057497, 4037696, 5447722, 35427965, 15325401, 19365852,\n            31985330,\n        ]),\n        Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        T: FieldElement2625::from_limbs([\n            41846657, 21581751, 11716001, 27684820, 48915701, 16297738, 20670665, 24995334,\n            3541542, 28543251,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement2625::from_limbs([\n            32595773, 7943725, 57730914, 30054016, 54719391, 272472, 25146209, 2005654, 66782178,\n            22147949,\n        ]),\n        Y: FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        T: FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement2625::from_limbs([\n            21352778, 5345713, 4660180, 25206575, 24143089, 14568123, 30185756, 21306662, 33579924,\n            8345318,\n        ]),\n        Y: FieldElement2625::from_limbs([\n            60155942, 32288931, 6862340, 26496934, 63071167, 28106709, 31680898, 18229030,\n            47743011, 1569101,\n        ]),\n        Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        T: FieldElement2625::from_limbs([\n            25262188, 11972680, 55392862, 5869611, 18193162, 17256693, 46438198, 8559097, 63567321,\n            5011180,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        Y: FieldElement2625::from_limbs([\n            67108844, 33554431, 67108863, 33554431, 67108863, 33554431, 67108863, 33554431,\n            67108863, 33554431,\n        ]),\n        Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        T: FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement2625::from_limbs([\n            45756067, 28208718, 62448683, 8347856, 42965774, 18986308, 36923107, 12247769,\n            33528939, 25209113,\n        ]),\n        Y: FieldElement2625::from_limbs([\n            60155942, 32288931, 6862340, 26496934, 63071167, 28106709, 31680898, 18229030,\n            47743011, 1569101,\n        ]),\n        Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        T: FieldElement2625::from_limbs([\n            41846657, 21581751, 11716001, 27684820, 48915701, 16297738, 20670665, 24995334,\n            3541542, 28543251,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement2625::from_limbs([\n            34513072, 25610706, 9377949, 3500415, 12389472, 33281959, 41962654, 31548777, 326685,\n            11406482,\n        ]),\n        Y: FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        T: FieldElement2625::from_limbs([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement2625::from_limbs([\n            45756067, 28208718, 62448683, 8347856, 42965774, 18986308, 36923107, 12247769,\n            33528939, 25209113,\n        ]),\n        Y: FieldElement2625::from_limbs([\n            6952903, 1265500, 60246523, 7057497, 4037696, 5447722, 35427965, 15325401, 19365852,\n            31985330,\n        ]),\n        Z: FieldElement2625::from_limbs([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n        T: FieldElement2625::from_limbs([\n            25262188, 11972680, 55392862, 5869611, 18193162, 17256693, 46438198, 8559097, 63567321,\n            5011180,\n        ]),\n    },\n];\n\n/// Table containing precomputed multiples of the Ed25519 basepoint \\\\(B = (x, 4/5)\\\\).\n#[cfg(feature = \"precomputed-tables\")]\npub static ED25519_BASEPOINT_TABLE: &'static EdwardsBasepointTable =\n    &ED25519_BASEPOINT_TABLE_INNER_DOC_HIDDEN;\n\n/// Inner constant, used to avoid filling the docs with precomputed points.\n#[doc(hidden)]\n#[cfg(feature = \"precomputed-tables\")]\nstatic ED25519_BASEPOINT_TABLE_INNER_DOC_HIDDEN: EdwardsBasepointTable = EdwardsBasepointTable([\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                93076338, 52752828, 29566454, 37215328, 54414518, 37569218, 94653489, 21800160,\n                61029707, 35602036,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                54563134, 934261, 64385954, 3049989, 66381436, 9406985, 12720692, 5043384,\n                19500929, 18085054,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                58370664, 4489569, 9688441, 18769238, 10184608, 21191052, 29287918, 11864899,\n                42594502, 29115885,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54292951, 54132516, 45527619, 11784319, 41753206, 30803714, 55390960, 29739860,\n                66750418, 23343128,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                45405608, 6903824, 27185491, 6451973, 37531140, 24000426, 51492312, 11189267,\n                40279186, 28235350,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                26966623, 11152617, 32442495, 15396054, 14353839, 20802097, 63980037, 24013313,\n                51636816, 29387734,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                82745136, 23865874, 24204772, 25642034, 67725840, 16869169, 94896463, 52336674,\n                28944398, 32004408,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                16568933, 4717097, 55552716, 32452109, 15682895, 21747389, 16354576, 21778470,\n                7689661, 11199574,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                30464137, 27578307, 55329429, 17883566, 23220364, 15915852, 7512774, 10017326,\n                49359771, 23634074,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                50071967, 13921891, 78054670, 27521000, 27105051, 17470053, 105291517, 15006021,\n                70393432, 27277891,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                23599295, 25248385, 55915199, 25867015, 13236773, 10506355, 7464579, 9656445,\n                13059162, 10374397,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                7798537, 16710257, 3033922, 2874086, 28997861, 2835604, 32406664, 29715387,\n                66467155, 33453106,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77970208, 11473153, 27284546, 35535607, 37044514, 46132292, 99976748, 48069538,\n                118779423, 44373810,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                4708026, 6336745, 20377586, 9066809, 55836755, 6594695, 41455196, 12483687,\n                54440373, 5581305,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                19563141, 16186464, 37722007, 4097518, 10237984, 29206317, 28542349, 13850243,\n                43430843, 17738489,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                51736881, 20691677, 32573249, 4720197, 107781206, 39429941, 115029100, 18329611,\n                124398787, 21468653,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                58559652, 109982, 15149363, 2178705, 22900618, 4543417, 3044240, 17864545, 1762327,\n                14866737,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                48909169, 17603008, 56635573, 1707277, 49922944, 3916100, 38872452, 3959420,\n                27914454, 4383652,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                72262591, 43463716, 68832610, 30776557, 97632468, 39071304, 86589715, 38784565,\n                43156424, 18378665,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                36839857, 30090922, 7665485, 10083793, 28475525, 1649722, 20654025, 16520125,\n                30598449, 7715701,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                28881826, 14381568, 9657904, 3680757, 46927229, 7843315, 35708204, 1370707,\n                29794553, 32145132,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                14499452, 64379265, 33917749, 62854211, 95603724, 14271266, 97399599, 10876453,\n                33954766, 35936157,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                59913433, 30899068, 52378708, 462250, 39384538, 3941371, 60872247, 3696004,\n                34808032, 15351954,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                27431194, 8222322, 16448760, 29646437, 48401861, 11938354, 34147463, 30583916,\n                29551812, 10109425,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                53451805, 20399000, 102933977, 45331528, 88556249, 40073815, 64730579, 31926875,\n                77201646, 28790260,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                27939166, 14210322, 4677035, 16277044, 44144402, 21156292, 34600109, 12005537,\n                49298737, 12803509,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                17228999, 17892808, 65875336, 300139, 65883994, 21839654, 30364212, 24516238,\n                18016356, 4397660,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                56150002, 25864224, 4776340, 18600194, 27850027, 17952220, 40489757, 14544524,\n                49631360, 34537070,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                29253598, 15796703, 64244882, 23645547, 10057022, 3163536, 7332899, 29434304,\n                46061167, 9934962,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                5793284, 16271923, 42977250, 23438027, 29188559, 1206517, 52360934, 4559894,\n                36984942, 22656481,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                39464893, 55615857, 83391519, 22517938, 28414020, 52096600, 24191032, 38096129,\n                53770554, 39054999,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                12650548, 32057319, 9052870, 11355358, 49428827, 25154267, 49678271, 12264342,\n                10874051, 13524335,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                25556948, 30508442, 714650, 2510400, 23394682, 23139102, 33119037, 5080568,\n                44580805, 5376627,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                108129445, 29543378, 50095164, 30016803, 60382070, 35475328, 44787558, 57661420,\n                71644630, 35123438,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                64853442, 14606629, 45416424, 25514613, 28430648, 8775819, 36614302, 3044289,\n                31848280, 12543772,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                45080285, 2943892, 35251351, 6777305, 13784462, 29262229, 39731668, 31491700,\n                7718481, 14474653,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                69494160, 36008644, 44477543, 33601034, 62670928, 51428448, 67765827, 26317766,\n                91425031, 28300864,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                13741529, 10911568, 33875447, 24950694, 46931033, 32521134, 33040650, 20129900,\n                46379407, 8321685,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                21060490, 31341688, 15712756, 29218333, 1639039, 10656336, 23845965, 21679594,\n                57124405, 608371,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                53436113, 18466845, 56219170, 25997372, 61071954, 11305546, 68232832, 60328286,\n                94338261, 33578318,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                43864724, 33260226, 55364135, 14712570, 37643165, 31524814, 12797023, 27114124,\n                65475458, 16678953,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                37608244, 4770661, 51054477, 14001337, 7830047, 9564805, 65600720, 28759386,\n                49939598, 4904952,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                91168402, 48171434, 86146020, 18514523, 86874956, 18648002, 72278074, 16191879,\n                69237100, 29227598,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                50127693, 4124965, 58568254, 22900634, 30336521, 19449185, 37302527, 916032,\n                60226322, 30567899,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                44477957, 12419371, 59974635, 26081060, 50629959, 16739174, 285431, 2763829,\n                15736322, 4143876,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                69488197, 11839344, 62998462, 27565766, 78383161, 34349388, 67321664, 18959768,\n                23527083, 17096164,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                33431108, 22423954, 49269897, 17927531, 8909498, 8376530, 34483524, 4087880,\n                51919953, 19138217,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                1767664, 7197987, 53903638, 31531796, 54017513, 448825, 5799055, 4357868, 62334673,\n                17231393,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                6721947, 47388255, 43585475, 32003117, 93463156, 21691110, 90474010, 29604699,\n                74499753, 36314231,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                4409022, 2052381, 23373853, 10530217, 7676779, 20668478, 21302352, 29290375,\n                1244379, 20634787,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                62687625, 7169618, 4982368, 30596842, 30256824, 30776892, 14086412, 9208236,\n                15886429, 16489664,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                69104920, 43930080, 81455230, 46865633, 60234728, 17116020, 120524529, 33952799,\n                36502408, 32841498,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                41801399, 9795879, 64331450, 14878808, 33577029, 14780362, 13348553, 12076947,\n                36272402, 5113181,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                49338080, 11797795, 31950843, 13929123, 41220562, 12288343, 36767763, 26218045,\n                13847710, 5387222,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                48526682, 30138214, 84933706, 64767897, 89853205, 56666252, 75871923, 37172217,\n                47508201, 43925422,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                20246567, 19185054, 22358228, 33010720, 18507282, 23140436, 14554436, 24808340,\n                32232923, 16763880,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                9648486, 10094563, 26416693, 14745928, 36734546, 27081810, 11094160, 15689506,\n                3140038, 17044340,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                50948773, 39027126, 31895587, 38299426, 75932378, 43920116, 39884063, 43003044,\n                38334409, 33920726,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                19153450, 11523972, 56012374, 27051289, 42461232, 5420646, 28344573, 8041113,\n                719605, 11671788,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                8678006, 2694440, 60300850, 2517371, 4964326, 11152271, 51675948, 18287915,\n                27000812, 23358879,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                119059805, 40688742, 75748150, 30739554, 59873175, 43976173, 67672928, 38890528,\n                73859840, 19033405,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                11836410, 29574944, 26297893, 16080799, 23455045, 15735944, 1695823, 24735310,\n                8169719, 16220347,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                48993007, 8653646, 17578566, 27461813, 59083086, 17541668, 55964556, 30926767,\n                61118155, 19388398,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                43800347, 22586119, 82322091, 23473217, 36255258, 22504427, 27884328, 36401716,\n                69764724, 35292826,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                39571412, 19301410, 41772562, 25551651, 57738101, 8129820, 21651608, 30315096,\n                48021414, 22549153,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                1533110, 3437855, 23735889, 459276, 29970501, 11335377, 26030092, 5821408,\n                10478196, 8544890,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                32173083, 50979553, 24896205, 37475929, 22579055, 63698010, 19270447, 45771905,\n                84897880, 63712868,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                36555903, 31326030, 51530034, 23407230, 13243888, 517024, 15479401, 29701199,\n                30460519, 1052596,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55493970, 13323617, 32618793, 8175907, 51878691, 12596686, 27491595, 28942073,\n                3179267, 24075541,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                99055914, 52742212, 62468279, 18214510, 51982886, 27514722, 52352086, 17142691,\n                19072639, 24043372,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                11685058, 11822410, 3158003, 19601838, 33402193, 29389366, 5977895, 28339415,\n                473098, 5040608,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                46817982, 8198641, 39698732, 11602122, 1290375, 30754672, 28326861, 1721092,\n                47550222, 30422825,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                74990396, 10687936, 74687587, 7738377, 48157852, 31000479, 88929649, 8076148,\n                39240368, 11538388,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                47173198, 3899860, 18283497, 26752864, 51380203, 22305220, 8754524, 7446702,\n                61432810, 5797015,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55813245, 29760862, 51326753, 25589858, 12708868, 25098233, 2014098, 24503858,\n                64739691, 27677090,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                111745333, 55540121, 106535706, 34700805, 86065554, 50194990, 68301593, 29840232,\n                82232482, 44365936,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                14352079, 30134717, 48166819, 10822654, 32750596, 4699007, 67038501, 15776355,\n                38222085, 21579878,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                38867681, 25481956, 62129901, 28239114, 29416930, 1847569, 46454691, 17069576,\n                4714546, 23953777,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                15200313, 41923004, 86787964, 15970073, 35236190, 35513882, 24611598, 29010600,\n                55362987, 45894651,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                12876937, 23074376, 33134380, 6590940, 60801088, 14872439, 9613953, 8241152,\n                15370987, 9608631,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                62965568, 21540023, 8446280, 33162829, 4407737, 13629032, 59383996, 15866073,\n                38898243, 24740332,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                26660609, 51431209, 75502596, 33912478, 59707572, 34547419, 43204630, 34413128,\n                87680086, 41974987,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                14620696, 13067227, 51661590, 8264466, 14106269, 15080814, 33531827, 12516406,\n                45534429, 21077682,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                236881, 10476226, 57258, 18877408, 6472997, 2466984, 17258519, 7256740, 8791136,\n                15069930,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                68385255, 24182513, 90058498, 17231624, 43615824, 61406677, 81820737, 38428660,\n                36445723, 31223040,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                5855666, 4990204, 53397016, 7294283, 59304582, 1924646, 65685689, 25642053,\n                34039526, 9234252,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                20590503, 24535444, 31529743, 26201766, 64402029, 10650547, 31559055, 21944845,\n                18979185, 13396066,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                24474268, 38522535, 22267081, 37961786, 91172745, 25229251, 48291976, 13594781,\n                33514650, 40576390,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                55541958, 26988926, 45743778, 15928891, 40950559, 4315420, 41160136, 29637754,\n                45628383, 12868081,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                38473832, 13504660, 19988037, 31421671, 21078224, 6443208, 45662757, 2244499,\n                54653067, 25465048,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                36513317, 13793478, 61256044, 33873567, 41385691, 60844964, 100195408, 8957936,\n                51875216, 39094952,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                55478669, 22050529, 58989363, 25911358, 2620055, 1022908, 43398120, 31985447,\n                50980335, 18591624,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                23152952, 775386, 27395463, 14006635, 57407746, 4649511, 1689819, 892185, 55595587,\n                18348483,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                76878974, 43141169, 93604957, 37878551, 68665374, 30004407, 94562682, 38317558,\n                47929249, 39421565,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                34343820, 1927589, 31726409, 28801137, 23962433, 17534932, 27846558, 5931263,\n                37359161, 17445976,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                27461885, 30576896, 22380809, 1815854, 44075111, 30522493, 7283489, 18406359,\n                47582163, 7734628,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                59098581, 57518046, 55988459, 39750469, 29344157, 20123547, 74694158, 30377805,\n                85658360, 48856500,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                34450527, 27383209, 59436070, 22502750, 6258877, 13504381, 10458790, 27135971,\n                58236621, 8424745,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                24687186, 8613276, 36441818, 30320886, 1863891, 31723888, 19206233, 7134917,\n                55824382, 32725512,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                11334880, 24336410, 75134156, 46261950, 84632755, 23078360, 77352601, 18868970,\n                62042829, 50053268,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                8911542, 6887158, 57524604, 26595841, 11145640, 24010752, 17303924, 19430194,\n                6536640, 10543906,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                38162480, 15479762, 49642029, 568875, 65611181, 11223453, 64439674, 16928857,\n                39873154, 8876770,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                41365946, 54541999, 118567760, 32707823, 101191041, 32758142, 33627041, 15824473,\n                66504438, 24514614,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10330056, 70051, 7957388, 24551765, 9764901, 15609756, 27698697, 28664395, 1657393,\n                3084098,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                10477963, 26084172, 12119565, 20303627, 29016246, 28188843, 31280318, 14396151,\n                36875289, 15272408,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54820536, 36723894, 28813182, 16658753, 92225296, 27923965, 109043770, 54472724,\n                42094105, 35504935,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                40928506, 9489186, 11053416, 18808271, 36055143, 5825629, 58724558, 24786899,\n                15341278, 8373727,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                28685821, 7759505, 52730348, 21551571, 35137043, 4079241, 298136, 23321830,\n                64230656, 15190419,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                34175950, 47360767, 52771378, 51314432, 110213106, 10940926, 75778582, 36296824,\n                108184414, 60233859,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                65528476, 21825014, 41129205, 22109408, 49696989, 22641577, 9291593, 17306653,\n                54954121, 6048604,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                36803549, 14843443, 1539301, 11864366, 20201677, 1900163, 13934231, 5128323,\n                11213262, 9168384,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                40828313, 44562278, 19408959, 32613674, 115624762, 29225850, 62020803, 22449281,\n                20470156, 50710163,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                43972811, 9282191, 14855179, 18164354, 59746048, 19145871, 44324911, 14461607,\n                14042978, 5230683,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                29969548, 30812838, 50396996, 25001989, 9175485, 31085458, 21556950, 3506042,\n                61174973, 21104723,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                63964099, 42299092, 19704002, 38135710, 46678177, 6830682, 45824694, 42525944,\n                38569674, 48880994,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                47644235, 10110287, 49846336, 30050539, 43608476, 1355668, 51585814, 15300987,\n                46594746, 9168259,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                61755510, 4488612, 43305616, 16314346, 7780487, 17915493, 38160505, 9601604,\n                33087103, 24543045,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                47665675, 18041531, 46311396, 21109108, 104393280, 43783891, 39664534, 52108332,\n                61111992, 49219103,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                23294591, 16921819, 44458082, 25083453, 27844203, 11461195, 13099750, 31094076,\n                18151675, 13417686,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                42385932, 29377914, 35958184, 5988918, 40250079, 6685064, 1661597, 21002991,\n                15271675, 18101767,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                78541887, 20325766, 75348494, 28274914, 65123427, 32828713, 48410099, 35721975,\n                60187562, 20114249,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                35672693, 15575145, 30436815, 12192228, 44645511, 9395378, 57191156, 24915434,\n                12215109, 12028277,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                14098381, 6555944, 23007258, 5757252, 51681032, 20603929, 30123439, 4617780,\n                50208775, 32898803,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                63082644, 51868028, 79002030, 47273095, 52299401, 35401816, 51288864, 43708440,\n                91082124, 20869957,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                40577025, 29858441, 65199965, 2534300, 35238307, 17004076, 18341389, 22134481,\n                32013173, 23450893,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                41629544, 10876442, 55337778, 18929291, 54739296, 1838103, 21911214, 6354752,\n                4425632, 32716610,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                56675456, 18941465, 89338721, 30463384, 53917697, 34331160, 116802352, 55088400,\n                71833867, 47599401,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                19268631, 26250011, 1555348, 8692754, 45634805, 23643767, 6347389, 32142648,\n                47586572, 17444675,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                42244775, 12986007, 56209986, 27995847, 55796492, 33405905, 19541417, 8180106,\n                9282262, 10282508,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                108012627, 37982977, 58447667, 20360168, 71207265, 52943606, 15522533, 8372215,\n                72651459, 22851748,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56546323, 14895632, 26814552, 16880582, 49628109, 31065071, 64326972, 6993760,\n                49014979, 10114654,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                47001790, 32625013, 31422703, 10427861, 59998115, 6150668, 38017109, 22025285,\n                25953724, 33448274,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                62874448, 59069571, 57989737, 36600431, 69210472, 54501569, 86498882, 39648727,\n                63793584, 46385556,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                51110167, 7578151, 5310217, 14408357, 33560244, 33329692, 31575953, 6326196,\n                7381791, 31132593,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                46206085, 3296810, 24736065, 17226043, 18374253, 7318640, 6295303, 8082724,\n                51746375, 12339663,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                27724736, 35845589, 73197064, 19369633, 68901590, 39412065, 80957277, 15768921,\n                92200031, 14856293,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                48242193, 8331042, 24373479, 8541013, 66406866, 24284974, 12927299, 20858939,\n                44926390, 24541532,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55685435, 28132841, 11632844, 3405020, 30536730, 21880393, 39848098, 13866389,\n                30146206, 9142070,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                71032974, 18246915, 120400605, 23499470, 79400683, 32886065, 39406089, 9326383,\n                58871006, 37725725,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                51186905, 16037936, 6713787, 16606682, 45496729, 2790943, 26396185, 3731949,\n                345228, 28091483,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                45781307, 13448258, 25284571, 1143661, 20614966, 24705045, 2031538, 21163201,\n                50855680, 19972348,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                98125037, 16832002, 93480255, 52657630, 62081513, 14854136, 17477601, 37397089,\n                28012649, 50703444,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                62033029, 9368965, 58546785, 28953529, 51858910, 6970559, 57918991, 16292056,\n                58241707, 3507939,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                29439664, 3537914, 23333589, 6997794, 49553303, 22536363, 51899661, 18503164,\n                57943934, 6580395,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54922984, 59429075, 83547131, 10826159, 58412047, 27318820, 84969307, 24280585,\n                65013061, 42858998,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                20714545, 29217521, 29088194, 7406487, 11426967, 28458727, 14792666, 18945815,\n                5289420, 33077305,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                50443312, 22903641, 60948518, 20248671, 9192019, 31751970, 17271489, 12349094,\n                26939669, 29802138,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54218947, 9373457, 98704712, 16374214, 21471720, 13221525, 39825369, 54760304,\n                63410056, 33672318,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                22263325, 26994382, 3984569, 22379786, 51994855, 32987646, 28311252, 5358056,\n                43789084, 541963,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                16259200, 3261970, 2309254, 18019958, 50223152, 28972515, 24134069, 16848603,\n                53771797, 20002236,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                76487005, 20414245, 111371745, 20809166, 95307144, 59864765, 64709178, 32837080,\n                67799289, 48430675,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                24977353, 33240048, 58884894, 20089345, 28432342, 32378079, 54040059, 21257083,\n                44727879, 6618998,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                65570671, 11685645, 12944378, 13682314, 42719353, 19141238, 8044828, 19737104,\n                32239828, 27901670,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                48505798, 38317421, 66182613, 42439735, 105805247, 30367115, 76890510, 23204372,\n                32779358, 5095274,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                34100715, 28339925, 34843976, 29869215, 9460460, 24227009, 42507207, 14506723,\n                21639561, 30924196,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                50707921, 20442216, 25239337, 15531969, 3987758, 29055114, 65819361, 26690896,\n                17874573, 558605,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                53508716, 10240080, 76280747, 16131052, 46239610, 43154131, 100608350, 38634582,\n                69194755, 38674192,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                44903700, 31034903, 50727262, 414690, 42089314, 2170429, 30634760, 25190818,\n                35108870, 27794547,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                60263160, 15791201, 8550074, 32241778, 29928808, 21462176, 27534429, 26362287,\n                44757485, 12961481,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                42616785, 57538092, 10368192, 11582341, 110820435, 31309143, 83642793, 8206995,\n                104023076, 28394792,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                55987368, 30172197, 2307365, 6362031, 66973409, 8868176, 50273234, 7031274,\n                7589640, 8945490,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                34956097, 8917966, 6661220, 21876816, 65916803, 17761038, 7251488, 22372252,\n                24099108, 19098262,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                72128384, 25646961, 71352990, 18840075, 107284455, 40007595, 47990681, 20265406,\n                127985831, 56828126,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10853575, 10721687, 26480089, 5861829, 44113045, 1972174, 65242217, 22996533,\n                63745412, 27113307,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                50106456, 5906789, 221599, 26991285, 7828207, 20305514, 24362660, 31546264,\n                53242455, 7421391,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                75248772, 27007934, 99366509, 27663885, 97484582, 1886180, 113042620, 48995682,\n                95935221, 29431402,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                6267067, 9695052, 7709135, 16950835, 34239795, 31668296, 14795159, 25714308,\n                13746020, 31812384,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                28584883, 7787108, 60375922, 18503702, 22846040, 25983196, 63926927, 33190907,\n                4771361, 25134474,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                92058101, 6376278, 39642383, 25379823, 48462709, 23623825, 100652432, 54967168,\n                70678489, 44897024,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                26514970, 4740088, 27912651, 3697550, 19331575, 22082093, 6809885, 4608608,\n                7325975, 18753361,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55490446, 19000001, 42787651, 7655127, 65739590, 5214311, 39708324, 10258389,\n                49462170, 25367739,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                11431185, 49377439, 93679108, 47883555, 85138853, 38350513, 35662684, 49135095,\n                76389221, 29580744,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                66948081, 23228174, 44253547, 29249434, 46247496, 19933429, 34297962, 22372809,\n                51563772, 4387440,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                46309467, 12194511, 3937617, 27748540, 39954043, 9340369, 42594872, 8548136,\n                20617071, 26072431,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                66170039, 29623845, 58394552, 49679149, 91711988, 27329038, 53333511, 55233041,\n                91454545, 10325459,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                47253587, 31985546, 44906155, 8714033, 14007766, 6928528, 16318175, 32543743,\n                4766742, 3552007,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                45357481, 16823515, 1351762, 32751011, 63099193, 3950934, 3217514, 14481909,\n                10988822, 29559670,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                15564288, 19242862, 70210106, 39238579, 97555643, 25503075, 79785990, 27049088,\n                58813011, 46850436,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                57666574, 6624295, 36809900, 21640754, 62437882, 31497052, 31521203, 9614054,\n                37108040, 12074673,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                4771172, 33419193, 14290748, 20464580, 27992297, 14998318, 65694928, 31997715,\n                29832612, 17163397,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                7064865, 59567690, 115055764, 62041325, 48217593, 30641695, 92934105, 38847728,\n                39986203, 46656021,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                64810282, 2439669, 59642254, 1719964, 39841323, 17225986, 32512468, 28236839,\n                36752793, 29363474,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                37102324, 10162315, 33928688, 3981722, 50626726, 20484387, 14413973, 9515896,\n                19568978, 9628812,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                33053784, 33753789, 83003454, 35137490, 94489106, 28973996, 49269969, 61002024,\n                60817076, 36992171,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                48129987, 3884492, 19469877, 12726490, 15913552, 13614290, 44147131, 70103,\n                7463304, 4176122,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                39984863, 10659916, 11482427, 17484051, 12771466, 26919315, 34389459, 28231680,\n                24216881, 5944158,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                76002989, 41005405, 64444714, 57343111, 106137209, 21165315, 19345745, 48235228,\n                78741856, 5847884,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                26942781, 31239115, 9129563, 28647825, 26024104, 11769399, 55590027, 6367193,\n                57381634, 4782139,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                19916442, 28726022, 44198159, 22140040, 25606323, 27581991, 33253852, 8220911,\n                6358847, 31680575,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                67910273, 31472729, 16569427, 44619599, 29875703, 33651059, 75017251, 29073951,\n                53570360, 34941586,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                19646058, 5720633, 55692158, 12814208, 11607948, 12749789, 14147075, 15156355,\n                45242033, 11835259,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                19299512, 1155910, 28703737, 14890794, 2925026, 7269399, 26121523, 15467869,\n                40548314, 5052482,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                64091413, 43612637, 69089700, 37518674, 22160965, 12322533, 60677741, 20936246,\n                12228556, 26550755,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                32944382, 14922211, 44263970, 5188527, 21913450, 24834489, 4001464, 13238564,\n                60994061, 8653814,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                22865569, 28901697, 27603667, 21009037, 14348957, 8234005, 24808405, 5719875,\n                28483275, 2841751,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                117796741, 32441125, 66781144, 21446575, 21886281, 51556090, 65220896, 33238773,\n                87040921, 20815228,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                55452759, 10087520, 58243976, 28018288, 47830290, 30498519, 3999227, 13239134,\n                62331395, 19644223,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                1382174, 21859713, 17266789, 9194690, 53784508, 9720080, 20403944, 11284705,\n                53095046, 3093229,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                83759766, 56070931, 66044684, 35125060, 58779117, 40907184, 66806439, 16271224,\n                43059443, 26862581,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                45197768, 27626490, 62497547, 27994275, 35364760, 22769138, 24123613, 15193618,\n                45456747, 16815042,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                57172930, 29264984, 41829040, 4372841, 2087473, 10399484, 31870908, 14690798,\n                17361620, 11864968,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                55801216, 39764803, 80315437, 39360751, 105200035, 19587230, 54777658, 26067830,\n                41530403, 50868174,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                14668443, 21284197, 26039038, 15305210, 25515617, 4542480, 10453892, 6577524,\n                9145645, 27110552,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                5974855, 3053895, 57675815, 23169240, 35243739, 3225008, 59136222, 3936127,\n                61456591, 30504127,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                97734231, 28825031, 41552902, 20761565, 46624288, 41249530, 17097187, 50805368,\n                106217947, 35358062,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                63555773, 9865098, 61880298, 4272700, 61435032, 16864731, 14911343, 12196514,\n                45703375, 7047411,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                20093258, 9920966, 55970670, 28210574, 13161586, 12044805, 34252013, 4124600,\n                34765036, 23296865,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                46320021, 14084653, 53577151, 41396578, 19119037, 19731827, 71861240, 24839791,\n                45429205, 35842469,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                40289628, 30270716, 29965058, 3039786, 52635099, 2540456, 29457502, 14625692,\n                42289247, 12570231,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                66045306, 22002608, 16920317, 12494842, 1278292, 27685323, 45948920, 30055751,\n                55134159, 4724942,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                85069815, 21778897, 62967895, 23851901, 58232301, 32143814, 54201480, 24894499,\n                104641427, 35458286,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                23134274, 19275300, 56426866, 31942495, 20684484, 15770816, 54119114, 3190295,\n                26955097, 14109738,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                15308788, 5320727, 36995055, 19235554, 22902007, 7767164, 29425325, 22276870,\n                31960941, 11934971,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                39713134, 41990227, 71218507, 12222638, 109589860, 14818667, 87747037, 38429459,\n                77600255, 34934149,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                53949449, 9197840, 3875503, 24618324, 65725151, 27674630, 33518458, 16176658,\n                21432314, 12180697,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55321537, 11500837, 13787581, 19721842, 44678184, 10140204, 1465425, 12689540,\n                56807545, 19681548,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                72522936, 18168390, 46101199, 43198001, 79943833, 34740580, 64485947, 32212200,\n                26128230, 39587344,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                40771450, 19788269, 32496024, 19900513, 17847800, 20885276, 3604024, 8316894,\n                41233830, 23117073,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                3296484, 6223048, 24680646, 21307972, 44056843, 5903204, 58246567, 28915267,\n                12376616, 3188849,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                29190450, 18895386, 27549112, 32370916, 70628929, 22857130, 32049514, 26245319,\n                50999629, 57256556,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                52364359, 24245275, 735817, 32955454, 46701176, 28496527, 25246077, 17758763,\n                18640740, 32593455,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                60180029, 17123636, 10361373, 5642961, 4910474, 12345252, 35470478, 33060001,\n                10530746, 1053335,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                104951742, 52922057, 120679510, 54991489, 47651803, 56453479, 102755357, 30605445,\n                24018830, 48581076,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                44516310, 30409154, 64819587, 5953842, 53668675, 9425630, 25310643, 13003497,\n                64794073, 18408815,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                39688860, 32951110, 59064879, 31885314, 41016598, 13987818, 39811242, 187898,\n                43942445, 31022696,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                45364447, 19743956, 68953703, 38575859, 123783328, 17642957, 76825530, 49821353,\n                62038646, 34280530,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                29370903, 27500434, 7334070, 18212173, 9385286, 2247707, 53446902, 28714970,\n                30007387, 17731091,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                66172485, 16086690, 23751945, 33011114, 65941325, 28365395, 9137108, 730663,\n                9835848, 4555336,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                43732410, 34964877, 44855110, 54209249, 97976497, 49381408, 17693929, 34099128,\n                55123565, 45977077,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                31117226, 21338698, 53606025, 6561946, 57231997, 20796761, 61990178, 29457725,\n                29120152, 13924425,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                49707966, 19321222, 19675798, 30819676, 56101901, 27695611, 57724924, 22236731,\n                7240930, 33317044,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                35747087, 22207651, 119210280, 27698212, 111764387, 54956091, 68331198, 37943914,\n                70402500, 51557120,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                50424044, 19110186, 11038543, 11054958, 53307689, 30215898, 42789283, 7733546,\n                12796905, 27218610,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                58349431, 22736595, 41689999, 10783768, 36493307, 23807620, 38855524, 3647835,\n                3222231, 22393970,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                85714958, 35247531, 108769341, 51938590, 71221215, 43599452, 23603892, 31506198,\n                59558087, 36039416,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                9255298, 30423235, 54952701, 32550175, 13098012, 24339566, 16377219, 31451620,\n                47306788, 30519729,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                44379556, 7496159, 61366665, 11329248, 19991973, 30206930, 35390715, 9936965,\n                37011176, 22935634,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                88987435, 28553134, 71447199, 47198328, 64071998, 13160959, 86817760, 5415496,\n                59748361, 29445138,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                27736842, 10103576, 12500508, 8502413, 63695848, 23920873, 10436917, 32004156,\n                43449720, 25422331,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                19492550, 21450067, 37426887, 32701801, 63900692, 12403436, 30066266, 8367329,\n                13243957, 8709688,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                79123950, 36355692, 95306994, 10151020, 91926984, 28811298, 55914672, 27908697,\n                72259831, 40828617,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                2831347, 21062286, 1478974, 6122054, 23825128, 20820846, 31097298, 6083058,\n                31021603, 23760822,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64578913, 31324785, 445612, 10720828, 53259337, 22048494, 43601132, 16354464,\n                15067285, 19406725,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                74949787, 47592304, 100852864, 49488446, 66380650, 29911725, 88512851, 34612017,\n                47729401, 21151211,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                915865, 17085158, 15608284, 24765302, 42751837, 6060029, 49737545, 8410996,\n                59888403, 16527024,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                32922597, 32997445, 20336073, 17369864, 10903704, 28169945, 16957573, 52992,\n                23834301, 6588044,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                32752011, 44787382, 70490858, 24839565, 22652987, 22810329, 17159698, 50243539,\n                46794283, 32248439,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                62419196, 9166775, 41398568, 22707125, 11576751, 12733943, 7924251, 30802151,\n                1976122, 26305405,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                21251203, 16309901, 64125849, 26771309, 30810596, 12967303, 156041, 30183180,\n                12331344, 25317235,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                75760459, 29077399, 118132091, 28557436, 80111370, 36505236, 96163290, 28447461,\n                77116999, 28886530,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                31486061, 15114593, 52847614, 12951353, 14369431, 26166587, 16347320, 19892343,\n                8684154, 23021480,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                19443825, 11385320, 24468943, 23895364, 43189605, 2187568, 40845657, 27467510,\n                31316347, 14219878,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                38514355, 1193784, 99354083, 11392484, 31092169, 49277233, 94254877, 40546840,\n                29126554, 42761822,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                32382916, 1110093, 18477781, 11028262, 39697101, 26006320, 62128346, 10843781,\n                59151264, 19118701,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                2814918, 7836403, 27519878, 25686276, 46214848, 22000742, 45614304, 8550129,\n                28346258, 1994730,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                47530546, 41639976, 53108344, 29605809, 69894701, 17323124, 47591912, 40729325,\n                22628101, 41669612,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                36703732, 955510, 55975026, 18476362, 34661776, 20276352, 41457285, 3317159,\n                57165847, 930271,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                51805164, 26720662, 28856489, 1357446, 23421993, 1057177, 24091212, 32165462,\n                44343487, 22903716,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                44357614, 28250434, 54201256, 54339997, 51297351, 25757378, 52269845, 50554643,\n                65241844, 41953401,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                35139535, 2106402, 62372504, 1362500, 12813763, 16200670, 22981545, 27263159,\n                18009407, 17781660,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                49887941, 24009210, 39324209, 14166834, 29815394, 7444469, 29551787, 29827013,\n                19288548, 1325865,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                82209002, 51273111, 110293748, 32549332, 107767535, 49063838, 79485593, 30075285,\n                100274970, 25511681,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                20909212, 13023121, 57899112, 16251777, 61330449, 25459517, 12412150, 10018715,\n                2213263, 19676059,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                32529814, 22479743, 30361438, 16864679, 57972923, 1513225, 22922121, 6382134,\n                61341936, 8371347,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77032307, 44825931, 79725657, 37099153, 104219359, 31832804, 12891686, 25361300,\n                40665920, 44040575,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                44511638, 26541766, 8587002, 25296571, 4084308, 20584370, 361725, 2610596,\n                43187334, 22099236,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                5408392, 32417741, 62139741, 10561667, 24145918, 14240566, 31319731, 29318891,\n                19985174, 30118346,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                53114388, 50171252, 81658109, 36895530, 99264821, 13648975, 49531796, 8849296,\n                67173894, 41925115,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                58787919, 21504805, 31204562, 5839400, 46481576, 32497154, 47665921, 6922163,\n                12743482, 23753914,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64747493, 12678784, 28815050, 4759974, 43215817, 4884716, 23783145, 11038569,\n                18800704, 255233,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                61839168, 31780545, 13957885, 41545147, 23132994, 34283205, 80502710, 42621388,\n                86367551, 52355070,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                64172210, 22726896, 56676774, 14516792, 63468078, 4372540, 35173943, 2209389,\n                65584811, 2055793,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                580882, 16705327, 5468415, 30871414, 36182444, 18858431, 59905517, 24560042,\n                37087844, 7394434,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                90947654, 35377159, 118479284, 48797157, 75426955, 29821327, 45436683, 30062226,\n                62287122, 48354352,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                13345610, 9759151, 3371034, 17416641, 16353038, 8577942, 31129804, 13496856,\n                58052846, 7402517,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                2286874, 29118501, 47066405, 31546095, 53412636, 5038121, 11006906, 17794080,\n                8205060, 1607563,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                81522931, 25552299, 70440693, 63900646, 89358013, 27960243, 85473524, 30647473,\n                30019586, 24525154,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                39420813, 1585952, 56333811, 931068, 37988643, 22552112, 52698034, 12029092,\n                9944378, 8024,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                4368715, 29844802, 29874199, 18531449, 46878477, 22143727, 50994269, 32555346,\n                58966475, 5640029,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77408455, 13746482, 11661824, 16234854, 74739102, 5998373, 76918751, 16859867,\n                82328661, 19226648,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                27425505, 27835351, 3055005, 10660664, 23458024, 595578, 51710259, 32381236,\n                48766680, 9742716,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                6744077, 2427284, 26042789, 2720740, 66260958, 1118973, 32324614, 7406442,\n                12420155, 1994844,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                81121366, 62084143, 115833273, 23975961, 107732385, 29617991, 121184249, 22644627,\n                91428792, 27108098,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                16412671, 29047065, 10772640, 15929391, 50040076, 28895810, 10555944, 23070383,\n                37006495, 28815383,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                22397363, 25786748, 57815702, 20761563, 17166286, 23799296, 39775798, 6199365,\n                21880021, 21303672,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                62825538, 5368522, 35991846, 41717820, 103894664, 36763558, 83666014, 42445160,\n                75949308, 38512191,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                51661137, 709326, 60189418, 22684253, 37330941, 6522331, 45388683, 12130071,\n                52312361, 5005756,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64994094, 19246303, 23019041, 15765735, 41839181, 6002751, 10183197, 20315106,\n                50713577, 31378319,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                115191953, 35186435, 80575154, 59113763, 110577275, 16573535, 35094956, 30497327,\n                22208661, 35554900,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                3065054, 32141671, 41510189, 33192999, 49425798, 27851016, 58944651, 11248526,\n                63417650, 26140247,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                10379208, 27508878, 8877318, 1473647, 37817580, 21046851, 16690914, 2553332,\n                63976176, 16400288,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                82825513, 34808697, 115745037, 41000704, 58659945, 6344163, 45011593, 26268851,\n                26894936, 42686498,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                24158868, 12938817, 11085297, 25376834, 39045385, 29097348, 36532400, 64451,\n                60291780, 30861549,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                13488534, 7794716, 22236231, 5989356, 25426474, 20976224, 2350709, 30135921,\n                62420857, 2364225,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                83443897, 9132433, 92749446, 40233319, 68834491, 42072368, 55301839, 21856974,\n                15445874, 25756331,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                29004188, 25687351, 28661401, 32914020, 54314860, 25611345, 31863254, 29418892,\n                66830813, 17795152,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                60986784, 18687766, 38493958, 14569918, 56250865, 29962602, 10343411, 26578142,\n                37280576, 22738620,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                94190495, 37018415, 14099041, 29036828, 68725166, 27348827, 96651499, 15372178,\n                84402661, 34515140,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                20263915, 11434237, 61343429, 11236809, 13505955, 22697330, 50997518, 6493121,\n                47724353, 7639713,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64278047, 18715199, 25403037, 25339236, 58791851, 17380732, 18006286, 17510682,\n                29994676, 17746311,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                76878673, 38757082, 110060329, 19923038, 106166724, 21992806, 42495722, 53248081,\n                35924287, 34263895,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                12286395, 13076066, 45333675, 32377809, 42105665, 4057651, 35090736, 24663557,\n                16102006, 13205847,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                13733362, 5599946, 10557076, 3195751, 61550873, 8536969, 41568694, 8525971,\n                10151379, 10394400,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                71133505, 17416880, 89545125, 12276533, 58009849, 64422764, 86807091, 11743038,\n                100915394, 42488844,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                51229064, 29029191, 58528116, 30620370, 14634844, 32856154, 57659786, 3137093,\n                55571978, 11721157,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                17555920, 28540494, 8268605, 2331751, 44370049, 9761012, 9319229, 8835153,\n                57903375, 32274386,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                66647436, 25724417, 87722981, 16688287, 59594098, 28747312, 89409167, 34059860,\n                73217325, 27371016,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                62038564, 12367916, 36445330, 3234472, 32617080, 25131790, 29880582, 20071101,\n                40210373, 25686972,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                35133562, 5726538, 26934134, 10237677, 63935147, 32949378, 24199303, 3795095,\n                7592688, 18562353,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                21594413, 18590204, 84575271, 63031641, 32537082, 36294330, 73516586, 12018832,\n                38852812, 37852843,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                46458361, 21592935, 39872588, 570497, 3767144, 31836892, 13891941, 31985238,\n                13717173, 10805743,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                52432215, 17910135, 15287173, 11927123, 24177847, 25378864, 66312432, 14860608,\n                40169934, 27690595,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                80071405, 38866230, 57048095, 45212711, 85964149, 25600230, 80395126, 54300159,\n                62727806, 9882021,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                18512060, 11319350, 46985740, 15090308, 18818594, 5271736, 44380960, 3666878,\n                43141434, 30255002,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                60319844, 30408388, 16192428, 13241070, 15898607, 19348318, 57023983, 26893321,\n                64705764, 5276064,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                97278672, 28236783, 93415069, 55358004, 94923826, 40623698, 74261714, 37239413,\n                68558087, 13082860,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10342807, 3098505, 2119311, 193222, 25702612, 12233820, 23697382, 15056736,\n                46092426, 25352431,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                33958735, 3261607, 22745853, 7948688, 19370557, 18376767, 40936887, 6482813,\n                56808784, 22494330,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                32869439, 61700319, 25609741, 49233102, 56421094, 51637792, 26112419, 36075440,\n                44444575, 40459246,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                29506904, 4457497, 3377935, 23757988, 36598817, 12935079, 1561737, 3841096,\n                38105225, 26896789,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                10340844, 26924055, 48452231, 31276001, 12621150, 20215377, 30878496, 21730062,\n                41524312, 5181965,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                25940096, 20896407, 17324187, 56801490, 58437394, 15029093, 91505116, 17103509,\n                64786011, 21165857,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                45343161, 9916822, 65808455, 4079497, 66080518, 11909558, 1782390, 12641087,\n                20603771, 26992690,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                48226577, 21881051, 24849421, 11501709, 13161720, 28785558, 1925522, 11914390,\n                4662781, 7820689,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                79349895, 33128449, 75241554, 42948365, 32846759, 31954812, 29749455, 45727356,\n                83245615, 48818451,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56758909, 18873868, 58896884, 2330219, 49446315, 19008651, 10658212, 6671822,\n                19012087, 3772772,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                3753511, 30133366, 10617073, 2028709, 14841030, 26832768, 28718731, 17791548,\n                20527770, 12988982,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                52286341, 27757162, 63400876, 12689772, 66209881, 22639565, 110034681, 56543919,\n                70408527, 54683910,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                50331161, 18301130, 57466446, 4978982, 3308785, 8755439, 6943197, 6461331,\n                41525717, 8991217,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                49882601, 1816361, 65435576, 27467992, 31783887, 25378441, 34160718, 7417949,\n                36866577, 1507264,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                29692644, 40384323, 56610063, 37889327, 88054838, 21647935, 38221255, 41763822,\n                14606361, 22907359,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                63627275, 8707080, 32188102, 5672294, 22096700, 1711240, 34088169, 9761486,\n                4170404, 31469107,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55521375, 14855944, 62981086, 32022574, 40459774, 15084045, 22186522, 16002000,\n                52832027, 25153633,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                62297389, 47315460, 35404986, 31070512, 63796392, 41423478, 59995291, 23934339,\n                80349708, 44520301,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                59366301, 25297669, 52340529, 19898171, 43876480, 12387165, 4498947, 14147411,\n                29514390, 4302863,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                53695440, 21146572, 20757301, 19752600, 14785142, 8976368, 62047588, 31410058,\n                17846987, 19582505,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                64864393, 32799703, 62511833, 32488122, 60861691, 35009730, 112569999, 24339641,\n                61886162, 46204698,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                57202067, 17484121, 21134159, 12198166, 40044289, 708125, 387813, 13770293,\n                47974538, 10958662,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                22470984, 12369526, 23446014, 28113323, 45588061, 23855708, 55336367, 21979976,\n                42025033, 4271861,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                109048144, 57055220, 47199530, 48916026, 61124505, 35713623, 67184238, 62830334,\n                101691505, 42024103,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                15854951, 4148314, 58214974, 7259001, 11666551, 13824734, 36577666, 2697371,\n                24154791, 24093489,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                15446137, 17747788, 29759746, 14019369, 30811221, 23944241, 35526855, 12840103,\n                24913809, 9815020,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                62399559, 27940162, 35267365, 21265538, 52665326, 44353845, 125114051, 46993199,\n                85843991, 43020669,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                11933045, 9281483, 5081055, 28370608, 64480701, 28648802, 59381042, 22658328,\n                44380208, 16199063,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                14576810, 379472, 40322331, 25237195, 37682355, 22741457, 67006097, 1876698,\n                30801119, 2164795,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                15995067, 36754305, 13672554, 13712240, 47730029, 62461217, 121136116, 51612593,\n                53616055, 34822483,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56818250, 29895392, 63822271, 10948817, 23037027, 3794475, 63638526, 20954210,\n                50053494, 3565903,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                29210069, 24135095, 61189071, 28601646, 10834810, 20226706, 50596761, 22733718,\n                39946641, 19523900,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                121055819, 49063018, 83772567, 25398281, 38758921, 42573554, 37925442, 29785008,\n                69352974, 19552452,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                61955989, 29753495, 57802388, 27482848, 16243068, 14684434, 41435776, 17373631,\n                13491505, 4641841,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                10813398, 643330, 47920349, 32825515, 30292061, 16954354, 27548446, 25833190,\n                14476988, 20787001,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77400943, 9984944, 73590300, 41834336, 59857349, 40587174, 27282936, 31910173,\n                106304917, 12651322,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                35923332, 32741048, 22271203, 11835308, 10201545, 15351028, 17099662, 3988035,\n                21721536, 30405492,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                10202177, 27008593, 35735631, 23979793, 34958221, 25434748, 54202543, 3852693,\n                13216206, 14842320,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                51293205, 22953365, 60569911, 26295436, 60124204, 26972653, 35608016, 47320255,\n                106783330, 43454614,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                14465486, 19721101, 34974879, 18815558, 39665676, 12990491, 33046193, 15796406,\n                60056998, 25514317,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                30924398, 25274812, 6359015, 20738097, 16508376, 9071735, 41620263, 15413634,\n                9524356, 26535554,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                12274182, 20378885, 99736504, 65323537, 73845487, 13267304, 72346523, 28444948,\n                82772379, 37590215,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                64157555, 8903984, 17349946, 601635, 50676049, 28941875, 53376124, 17665097,\n                44850385, 4659090,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                50192582, 28601458, 36715152, 18395610, 20774811, 15897498, 5736189, 15026997,\n                64930608, 20098846,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                58249865, 31335375, 28571665, 56953346, 66634395, 23448733, 63307367, 33832526,\n                23440561, 33264224,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10226222, 27625730, 15139955, 120818, 52241171, 5218602, 32937275, 11551483,\n                50536904, 26111567,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                17932739, 21117156, 43069306, 10749059, 11316803, 7535897, 22503767, 5561594,\n                63462240, 3898660,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                74858752, 32584864, 50769132, 33537967, 42090752, 15122142, 65535333, 40706961,\n                88940025, 34799664,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                26958440, 18896406, 4314585, 8346991, 61431100, 11960071, 34519569, 32934396,\n                36706772, 16838219,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                54942968, 9166946, 33491384, 13673479, 29787085, 13096535, 6280834, 14587357,\n                44770839, 13987524,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                109867800, 7778773, 88224864, 49127028, 62275597, 28196653, 62807965, 28429792,\n                59639082, 30696363,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                9681908, 26817309, 35157219, 13591837, 60225043, 386949, 31622781, 6439245,\n                52527852, 4091396,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                58682418, 1470726, 38999185, 31957441, 3978626, 28430809, 47486180, 12092162,\n                29077877, 18812444,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                72378032, 26694705, 120987516, 25533715, 25932562, 35317984, 61502753, 28048550,\n                47091016, 2357888,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                32264008, 18146780, 61721128, 32394338, 65017541, 29607531, 23104803, 20684524,\n                5727337, 189038,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                14609104, 24599962, 61108297, 16931650, 52531476, 25810533, 40363694, 10942114,\n                41219933, 18669734,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                87622345, 39112362, 51504250, 41383962, 93522806, 31535027, 45729895, 41026212,\n                13913676, 28416557,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                41534488, 11967825, 29233242, 12948236, 60354399, 4713226, 58167894, 14059179,\n                12878652, 8511905,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                41452044, 3393630, 64153449, 26478905, 64858154, 9366907, 36885446, 6812973,\n                5568676, 30426776,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                78738868, 12144453, 69225203, 47160468, 94487748, 49231348, 49700110, 20050058,\n                119822531, 8070816,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                27117677, 23547054, 35826092, 27984343, 1127281, 12772488, 37262958, 10483305,\n                55556115, 32525717,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                10637467, 27866368, 5674780, 1072708, 40765276, 26572129, 65424888, 9177852,\n                39615702, 15431202,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                87633990, 44446997, 121475255, 12779441, 104724694, 16150073, 105977209, 14943140,\n                52052074, 25618500,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                37084402, 5626925, 66557297, 23573344, 753597, 11981191, 25244767, 30314666,\n                63752313, 9594023,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                43356201, 2636869, 61944954, 23450613, 585133, 7877383, 11345683, 27062142,\n                13352334, 22577348,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                65177046, 28146973, 70413512, 54223994, 84124668, 62231772, 104433876, 25801948,\n                53893326, 33235227,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                20239939, 6607058, 6203985, 3483793, 48721888, 32775202, 46385121, 15077869,\n                44358105, 14523816,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                27406023, 27512775, 27423595, 29057038, 4996213, 10002360, 38266833, 29008937,\n                36936121, 28748764,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                78483087, 12660714, 17861383, 21013599, 78044431, 34653658, 53222787, 24462691,\n                106490683, 44912934,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                54378055, 10311866, 1510375, 10778093, 64989409, 24408729, 32676002, 11149336,\n                40985213, 4985767,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                48012542, 341146, 60911379, 33315398, 15756972, 24757770, 66125820, 13794113,\n                47694557, 17933176,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                73598907, 45494717, 25495922, 59382504, 75777235, 24803115, 70476466, 40524436,\n                65417798, 58104073,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                1656478, 13457317, 15370807, 6364910, 13605745, 8362338, 47934242, 28078708,\n                50312267, 28522993,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                44835530, 20030007, 67044178, 29220208, 48503227, 22632463, 46537798, 26546453,\n                67009010, 23317098,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                84856310, 43593691, 86477162, 29503840, 46478228, 51067577, 99101545, 17696455,\n                104957364, 28042459,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                31932008, 28568291, 47496481, 16366579, 22023614, 88450, 11371999, 29810185,\n                4882241, 22927527,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                29796488, 37186, 19818052, 10115756, 55279832, 3352735, 18551198, 3272828,\n                61917932, 29392022,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                12501267, 4044383, 58495907, 53716478, 101787674, 38691029, 47878485, 30024734,\n                330069, 29895023,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                6384877, 2899513, 17807477, 7663917, 64749976, 12363164, 25366522, 24980540,\n                66837568, 12071498,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                58743349, 29511910, 25133447, 29037077, 60897836, 2265926, 34339246, 1936674,\n                61949167, 3829362,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                28425947, 27718999, 66531773, 28857233, 120000172, 40425360, 75030413, 26986644,\n                26333139, 47822096,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56041645, 11871230, 27385719, 22994888, 62522949, 22365119, 10004785, 24844944,\n                45347639, 8930323,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                45911060, 17158396, 25654215, 31829035, 12282011, 11008919, 1541940, 4757911,\n                40617363, 17145491,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                80646107, 25794941, 113612887, 44516357, 61186043, 20336366, 53952279, 39771685,\n                118274028, 47369420,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                49686272, 15157789, 18705543, 29619, 24409717, 33293956, 27361680, 9257833,\n                65152338, 31777517,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                42063564, 23362465, 15366584, 15166509, 54003778, 8423555, 37937324, 12361134,\n                48422886, 4578289,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                91688613, 3711569, 68451186, 22374305, 107212592, 47679386, 44564334, 14074918,\n                21964432, 41789689,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                60580251, 31142934, 9442965, 27628844, 12025639, 32067012, 64127349, 31885225,\n                13006805, 2355433,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                50803946, 19949172, 60476436, 28412082, 16974358, 22643349, 27202043, 1719366,\n                1141648, 20758196,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54244901, 53888877, 58790596, 56090772, 60298717, 28710537, 13475065, 30420460,\n                32674894, 47269477,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                11423316, 28086373, 32344215, 8962751, 24989809, 9241752, 53843611, 16086211,\n                38367983, 17912338,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                65699196, 12530727, 60740138, 10847386, 19531186, 19422272, 55399715, 7791793,\n                39862921, 4383346,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                38137947, 38825878, 65842854, 23817442, 121762491, 50287029, 62246456, 62202414,\n                27193555, 39799623,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                51914908, 5362277, 65324971, 2695833, 4960227, 12840725, 23061898, 3260492,\n                22510453, 8577507,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                54476394, 11257345, 34415870, 13548176, 66387860, 10879010, 31168030, 13952092,\n                37537372, 29918525,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                70986166, 23981692, 99525555, 38959755, 56104456, 19897796, 70868632, 45489751,\n                72720723, 41718449,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                50833043, 14667796, 15906460, 12155291, 44997715, 24514713, 32003001, 24722143,\n                5773084, 25132323,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                43320746, 25300131, 1950874, 8937633, 18686727, 16459170, 66203139, 12376319,\n                31632953, 190926,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                109624102, 17415545, 58684872, 13378745, 81271271, 6901327, 58820115, 38062995,\n                41767308, 29926903,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                8884438, 27670423, 6023973, 10104341, 60227295, 28612898, 18722940, 18768427,\n                65436375, 827624,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                34388281, 17265135, 34605316, 7101209, 13354605, 2659080, 65308289, 19446395,\n                42230385, 1541285,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                70010192, 32436744, 70989239, 57049475, 116596786, 29941649, 45306746, 29986950,\n                87565708, 31669398,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                27019610, 12299467, 53450576, 31951197, 54247203, 28692960, 47568713, 28538373,\n                29439640, 15138866,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                21536104, 26928012, 34661045, 22864223, 44700786, 5175813, 61688824, 17193268,\n                7779327, 109896,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                97388589, 48203181, 59063992, 39979989, 80748484, 32810922, 28698389, 45734550,\n                23177718, 33000357,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                26572828, 3405927, 35407164, 12890904, 47843196, 5335865, 60615096, 2378491,\n                4439158, 20275085,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                44392139, 3489069, 57883598, 33221678, 18875721, 32414337, 14819433, 20822905,\n                49391106, 28092994,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                62052362, 50120982, 83062524, 37322183, 56672364, 49181491, 66287909, 35731656,\n                75658945, 18440266,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                48635543, 16596774, 66727204, 15663610, 22860960, 15585581, 39264755, 29971692,\n                43848403, 25125843,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                34628313, 15707274, 58902952, 27902350, 29464557, 2713815, 44383727, 15860481,\n                45206294, 1494192,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                47546754, 53021470, 41524990, 24254879, 80236705, 34314140, 21923481, 16529112,\n                75851568, 46521448,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                38643965, 1553204, 32536856, 23080703, 42417258, 33148257, 58194238, 30620535,\n                37205105, 15553882,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                21877890, 3230008, 9881174, 10539357, 62311749, 2841331, 11543572, 14513274,\n                19375923, 20906471,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                75941133, 52613378, 80362373, 38692006, 72146734, 37633208, 24880817, 60886148,\n                69971515, 9455042,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                29306751, 5123106, 20245049, 19404543, 9592565, 8447059, 65031740, 30564351,\n                15511448, 4789663,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                46429108, 7004546, 8824831, 24119455, 63063159, 29803695, 61354101, 108892,\n                23513200, 16652362,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                100961536, 37699212, 62632834, 26975308, 77878902, 26398889, 60458447, 54172563,\n                115898528, 43767290,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                2756062, 8598110, 7383731, 26694540, 22312758, 32449420, 21179800, 2600940,\n                57120566, 21047965,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                42463153, 13317461, 36659605, 17900503, 21365573, 22684775, 11344423, 864440,\n                64609187, 16844368,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                107784906, 6148327, 49924452, 19080277, 85891792, 33278434, 44547329, 33765731,\n                69828620, 38495428,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                65784982, 3911312, 60160120, 14759764, 37081714, 7851206, 21690126, 8518463,\n                26699843, 5276295,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                53958991, 27125364, 9396248, 365013, 24703301, 23065493, 1321585, 149635, 51656090,\n                7159368,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77096625, 30149672, 84616825, 43059961, 76840398, 31388917, 89464872, 41866607,\n                89586081, 25151046,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                18155857, 17049442, 19744715, 9006923, 15154154, 23015456, 24256459, 28689437,\n                44560690, 9334108,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                2986088, 28642539, 10776627, 30080588, 10620589, 26471229, 45695018, 14253544,\n                44521715, 536905,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                71486582, 41670267, 91675941, 15495313, 78733938, 46619030, 74499414, 44144056,\n                77946923, 51688439,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                47766460, 867879, 9277171, 30335973, 52677291, 31567988, 19295825, 17757482,\n                6378259, 699185,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                7895007, 4057113, 60027092, 20476675, 49222032, 33231305, 66392824, 15693154,\n                62063800, 20180469,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                59371282, 27685029, 119651408, 26147511, 78494517, 46756047, 31730677, 22591592,\n                63190227, 23885106,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10188286, 17783598, 59772502, 13427542, 22223443, 14896287, 30743455, 7116568,\n                45322357, 5427592,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                696102, 13206899, 27047647, 22922350, 15285304, 23701253, 10798489, 28975712,\n                19236242, 12477404,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                55879406, 44798227, 50054593, 25513566, 66320635, 58940896, 63211193, 44734935,\n                43939347, 41288075,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                17800790, 19518253, 40108434, 21787760, 23887826, 3149671, 23466177, 23016261,\n                10322026, 15313801,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                26246234, 11968874, 32263343, 28085704, 6830754, 20231401, 51314159, 33452449,\n                42659621, 10890803,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                35743198, 43825794, 54448238, 27287163, 83799070, 54046319, 119235514, 50039361,\n                92289660, 28219547,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                66522290, 10376443, 34522450, 22268075, 19801892, 10997610, 2276632, 9482883,\n                316878, 13820577,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                57226037, 29044064, 64993357, 16457135, 56008783, 11674995, 30756178, 26039378,\n                30696929, 29841583,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                100097781, 23951019, 12499365, 41465219, 56491606, 21622917, 59766047, 57123466,\n                34759345, 7392472,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                58253184, 15927860, 9866406, 29905021, 64711949, 16898650, 36699387, 24419436,\n                25112946, 30627788,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64604801, 33117465, 25621773, 27875660, 15085041, 28074555, 42223985, 20028237,\n                5537437, 19640113,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                55883261, 2320284, 57524584, 10149186, 100773065, 5808646, 119341477, 31824763,\n                98343453, 39645030,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                57475529, 116425, 26083934, 2897444, 60744427, 30866345, 609720, 15878753,\n                60138459, 24519663,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                39351007, 247743, 51914090, 24551880, 23288160, 23542496, 43239268, 6503645,\n                20650474, 1804084,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                106627923, 49010854, 76081380, 42024039, 82749485, 37994278, 70230858, 56779150,\n                94951478, 33352103,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                51801891, 2839643, 22530074, 10026331, 4602058, 5048462, 28248656, 5031932,\n                55733782, 12714368,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                20807691, 26283607, 29286140, 11421711, 39232341, 19686201, 45881388, 1035545,\n                47375635, 12796919,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                79185725, 52807577, 58323861, 21705509, 42096072, 49955115, 49517368, 20654993,\n                70589528, 51926048,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                34747315, 5457596, 28548107, 7833186, 7303070, 21600887, 42745799, 17632556,\n                33734809, 2771024,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                45719598, 421931, 26597266, 6860826, 22486084, 26817260, 49971378, 29344205,\n                42556581, 15673396,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                46924223, 35892647, 19788684, 57487908, 63107597, 24813538, 46837679, 38287685,\n                70836007, 20619983,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                6120100, 814863, 55314462, 32931715, 6812204, 17806661, 2019593, 7975683, 31123697,\n                22595451,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                30069250, 22119100, 30434653, 2958439, 18399564, 32578143, 12296868, 9204260,\n                50676426, 9648164,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                32705413, 32003455, 97814521, 41005496, 55303257, 43186244, 70414129, 38803035,\n                108209395, 22176929,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                17219846, 2375039, 35537917, 27978816, 47649184, 9219902, 294711, 15298639,\n                2662509, 17257359,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                65935918, 25995736, 62742093, 29266687, 45762450, 25120105, 32087528, 32331655,\n                32247247, 19164571,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                14312609, 34775988, 17395389, 58408721, 62163121, 58424228, 106019982, 23916613,\n                51081240, 20175586,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                65680039, 23875441, 57873182, 6549686, 59725795, 33085767, 23046501, 9803137,\n                17597934, 2346211,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                18510781, 15337574, 26171504, 981392, 44867312, 7827555, 43617730, 22231079,\n                3059832, 21771562,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77250443, 39637338, 84938156, 31606788, 76938955, 13613135, 41552228, 28009845,\n                33606651, 37146527,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                33114149, 17665080, 40583177, 20211034, 33076704, 8716171, 1151462, 1521897,\n                66126199, 26716628,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                34169699, 29298616, 23947180, 33230254, 34035889, 21248794, 50471177, 3891703,\n                26353178, 693168,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                97483084, 35150011, 117333688, 46741361, 71709207, 33961335, 76694157, 33153763,\n                31375463, 47924397,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                52738210, 25781902, 1510300, 6434173, 48324075, 27291703, 32732229, 20445593,\n                17901440, 16011505,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                18171223, 21619806, 54608461, 15197121, 56070717, 18324396, 47936623, 17508055,\n                8764034, 12309598,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                73084753, 28311243, 47649501, 23872684, 55567586, 14015781, 110551971, 34782749,\n                17544095, 22960650,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                5811932, 31839139, 3442886, 31285122, 48741515, 25194890, 49064820, 18144304,\n                61543482, 12348899,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                35709185, 11407554, 25755363, 6891399, 63851926, 14872273, 42259511, 8141294,\n                56476330, 32968952,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                121542424, 34248456, 62032718, 46854775, 81124121, 19103037, 124519055, 22225380,\n                30944592, 1130208,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                8247747, 26843490, 40546482, 25845122, 52706924, 18905521, 4652151, 2488540,\n                23550156, 33283200,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                17294297, 29765994, 7026747, 15626851, 22990044, 113481, 2267737, 27646286,\n                66700045, 33416712,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                83199930, 17300505, 85708115, 40895109, 69246500, 32332774, 63744702, 48105367,\n                70369388, 26388160,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                62198760, 20221544, 18550886, 10864893, 50649539, 26262835, 44079994, 20349526,\n                54360141, 2701325,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                58534169, 16099414, 4629974, 17213908, 46322650, 27548999, 57090500, 9276970,\n                11329923, 1862132,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                14763057, 17650824, 103299457, 3689865, 70620756, 43867957, 45157775, 45773662,\n                58070900, 32614131,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                8894987, 30108338, 6150752, 3013931, 301220, 15693451, 35127648, 30644714,\n                51670695, 11595569,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                15214943, 3537601, 40870142, 19495559, 4418656, 18323671, 13947275, 10730794,\n                53619402, 29190761,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                64570539, 41237224, 99867876, 33817540, 104232996, 25598978, 111885603, 23365795,\n                68085971, 34254425,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                54642373, 4195083, 57897332, 550903, 51543527, 12917919, 19118110, 33114591,\n                36574330, 19216518,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                31788442, 19046775, 4799988, 7372237, 8808585, 18806489, 9408236, 23502657,\n                12493931, 28145115,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                41428258, 5260743, 47873055, 27269961, 63412921, 16566086, 94327144, 36161552,\n                29375954, 6024730,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                842132, 30759739, 62345482, 24831616, 26332017, 21148791, 11831879, 6985184,\n                57168503, 2854095,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                62261602, 25585100, 2516241, 27706719, 9695690, 26333246, 16512644, 960770,\n                12121869, 16648078,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                51890193, 48221527, 53772634, 35568148, 97707150, 33090294, 35603941, 25672367,\n                20237805, 36392843,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                47820798, 4453151, 15298546, 17376044, 22115042, 17581828, 12544293, 20083975,\n                1068880, 21054527,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                57549981, 17035596, 33238497, 13506958, 30505848, 32439836, 58621956, 30924378,\n                12521377, 4845654,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                106019188, 44298538, 64150483, 43754095, 74868174, 54020263, 70518210, 32681031,\n                127735421, 20668560,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                43547042, 6230155, 46726851, 10655313, 43068279, 21933259, 10477733, 32314216,\n                63995636, 13974497,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                12966261, 15550616, 35069916, 31939085, 21025979, 32924988, 5642324, 7188737,\n                18895762, 12629579,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                14741860, 18607545, 89286071, 21833194, 68388604, 41613031, 11758139, 34343875,\n                32195180, 37450109,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10758205, 15755439, 62598914, 9243697, 62229442, 6879878, 64904289, 29988312,\n                58126794, 4429646,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64654951, 15725972, 46672522, 23143759, 61304955, 22514211, 59972993, 21911536,\n                18047435, 18272689,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                41935825, 55801698, 29759954, 45331216, 111955344, 51288407, 78101976, 54258026,\n                49488161, 57700395,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                21987233, 700364, 42603816, 14972007, 59334599, 27836036, 32155025, 2581431,\n                37149879, 8773374,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                41540495, 454462, 53896929, 16126714, 25240068, 8594567, 20656846, 12017935,\n                59234475, 19634276,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                73137027, 39817509, 103205921, 55807152, 66289943, 36016203, 102376553, 61640820,\n                65387074, 30777706,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                54829870, 16624276, 987579, 27631834, 32908202, 1248608, 7719845, 29387734,\n                28408819, 6816612,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                56750770, 25316602, 19549650, 21385210, 22082622, 16147817, 20613181, 13982702,\n                56769294, 5067942,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                36602859, 29732664, 79183544, 13582411, 47230892, 35998382, 47389577, 12746131,\n                72440074, 57002919,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                30528792, 3601899, 65151774, 4619784, 39747042, 18118043, 24180792, 20984038,\n                27679907, 31905504,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                9402385, 19597367, 32834042, 10838634, 40528714, 20317236, 26653273, 24868867,\n                22611443, 20839026,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                89299435, 34672460, 22736440, 48684895, 103757035, 27563109, 86298488, 62459921,\n                71963721, 40176570,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                58798126, 30600981, 58846284, 30166382, 56707132, 33282502, 13424425, 29987205,\n                26404408, 13001963,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                35867026, 18138731, 64114613, 8939345, 11562230, 20713762, 41044498, 21932711,\n                51703708, 11020692,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                68974887, 59159374, 59210213, 23253421, 12483314, 47031979, 70284499, 21130268,\n                28761761, 34961166,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                66660290, 31776765, 13018550, 3194501, 57528444, 22392694, 24760584, 29207344,\n                25577410, 20175752,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                42818486, 4759344, 66418211, 31701615, 2066746, 10693769, 37513074, 9884935,\n                57739938, 4745409,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                57967561, 39604145, 47577802, 29213020, 102956929, 43498706, 51646855, 55797011,\n                78040786, 21622500,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                50547351, 14112679, 59096219, 4817317, 59068400, 22139825, 44255434, 10856640,\n                46638094, 13434653,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                22759470, 23480998, 50342599, 31683009, 13637441, 23386341, 1765143, 20900106,\n                28445306, 28189722,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                29875044, 46048045, 69904399, 63322533, 68819482, 48735613, 56913146, 24765756,\n                9074233, 34721612,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                40903181, 11014232, 57266213, 30918946, 40200743, 7532293, 48391976, 24018933,\n                3843902, 9367684,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                56139269, 27150720, 9591133, 9582310, 11349256, 108879, 16235123, 8601684,\n                66969667, 4242894,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                89201818, 53917740, 65066069, 21585919, 99295616, 55591475, 60534521, 36025091,\n                106800361, 16625499,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56051142, 3042015, 13770083, 24296510, 584235, 33009577, 59338006, 2602724,\n                39757248, 14247412,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                6314156, 23289540, 34336361, 15957556, 56951134, 168749, 58490057, 14290060,\n                27108877, 32373552,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                58522248, 26383465, 80350645, 44514587, 34117848, 19759835, 100656839, 22495542,\n                107069276, 34536304,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                22833421, 9293594, 34459416, 19935764, 57971897, 14756818, 44180005, 19583651,\n                56629059, 17356469,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                59340277, 3326785, 38997067, 10783823, 19178761, 14905060, 22680049, 13906969,\n                51175174, 3797898,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                88830182, 29341685, 54902740, 42864613, 63226624, 19901321, 90849087, 30845199,\n                87600846, 59066711,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                9209251, 18419377, 53852306, 27386633, 66377847, 15289672, 25947805, 15286587,\n                30997318, 26851369,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                7392013, 16618386, 23946583, 25514540, 53843699, 32020573, 52911418, 31232855,\n                17649997, 33304352,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                57807757, 52915036, 97718388, 30504888, 41933794, 32270679, 51867297, 24028707,\n                64875610, 41216577,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                49550191, 1763593, 33994528, 15908609, 37067994, 21380136, 7335079, 25082233,\n                63934189, 3440182,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                47219164, 27577423, 42997570, 23865561, 10799742, 16982475, 40449, 29122597,\n                4862399, 1133,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                34252636, 25680474, 61686474, 48415381, 50789832, 41510573, 74366924, 33866292,\n                36513872, 26175010,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                63335436, 31988495, 28985339, 7499440, 24445838, 9325937, 29727763, 16527196,\n                18278453, 15405622,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                62726958, 8508651, 47210498, 29880007, 61124410, 15149969, 53795266, 843522,\n                45233802, 13626196,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                69390312, 20067376, 56193445, 30944521, 68988221, 49718638, 56324981, 37508223,\n                80449702, 15928662,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                31727126, 26374577, 48671360, 25270779, 2875792, 17164102, 41838969, 26539605,\n                43656557, 5964752,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                4100401, 27594980, 49929526, 6017713, 48403027, 12227140, 40424029, 11344143,\n                2538215, 25983677,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                57675240, 6123112, 78268667, 31397823, 97125143, 48520672, 46633880, 35039852,\n                66479607, 17595569,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                40304287, 4260918, 11851389, 9658551, 35091757, 16367491, 46903439, 20363143,\n                11659921, 22439314,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                26180377, 10015009, 36264640, 24973138, 5418196, 9480663, 2231568, 23384352,\n                33100371, 32248261,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                82229958, 28352560, 56718958, 48982252, 39598926, 17561924, 88779810, 38041106,\n                61177053, 19088051,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                16166467, 24070699, 56004733, 6023907, 35182066, 32189508, 2340059, 17299464,\n                56373093, 23514607,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                28042865, 29997343, 54982337, 12259705, 63391366, 26608532, 6766452, 24864833,\n                18036435, 5803270,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                66291264, 40318343, 78912424, 35140016, 78067310, 30883266, 23855390, 4598332,\n                60949433, 19436993,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                36077558, 19298237, 17332028, 31170912, 31312681, 27587249, 696308, 50292,\n                47013125, 11763583,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                66514282, 31040148, 34874710, 12643979, 12650761, 14811489, 665117, 20940800,\n                47335652, 22840869,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                97573435, 55845991, 62981386, 20819953, 86944190, 60003250, 109821551, 35630203,\n                50088706, 34546902,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                18357166, 26559999, 7766381, 16342475, 37783946, 411173, 14578841, 8080033,\n                55534529, 22952821,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                19598397, 10334610, 12555054, 2555664, 18821899, 23214652, 21873262, 16014234,\n                26224780, 16452269,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                36884920, 5145195, 73053412, 49940397, 71085598, 35564328, 122839923, 25936244,\n                46575034, 37253081,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                14187449, 3448569, 56472628, 22743496, 44444983, 30120835, 7268409, 22663988,\n                27394300, 12015369,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                19695742, 16087646, 28032085, 12999827, 6817792, 11427614, 20244189, 32241655,\n                53849736, 30151970,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                97968948, 12735207, 65220619, 28854697, 50133957, 35811371, 126051714, 45852742,\n                58558339, 23160969,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                61389038, 22309106, 65198214, 15569034, 26642876, 25966672, 61319509, 18435777,\n                62132699, 12651792,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64260450, 9953420, 11531313, 28271553, 26895122, 20857343, 53990043, 17036529,\n                9768697, 31021214,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                109498250, 35449081, 66821165, 28850346, 82457582, 25397901, 32767512, 46319882,\n                72048958, 44232657,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                18860224, 15980149, 48121624, 31991861, 40875851, 22482575, 59264981, 13944023,\n                42736516, 16582018,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                51604604, 4970267, 37215820, 4175592, 46115652, 31354675, 55404809, 15444559,\n                56105103, 7989036,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                98599278, 39122492, 64696060, 35736814, 34772016, 38086117, 35030594, 39754637,\n                47422750, 52308692,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                49800177, 17674491, 35586086, 33551600, 34221481, 16375548, 8680158, 17182719,\n                28550067, 26697300,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                38981977, 27866340, 16837844, 31733974, 60258182, 12700015, 37068883, 4364037,\n                1155602, 5988841,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                88999280, 20281524, 121593716, 12154347, 59276991, 48854927, 90257846, 29083950,\n                91727270, 41837612,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                33972757, 23041680, 9975415, 6841041, 35549071, 16356535, 3070187, 26528504,\n                1466168, 10740210,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                65599446, 18066246, 53605478, 22898515, 32799043, 909394, 53169961, 27774712,\n                34944214, 18227391,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                71069668, 19286628, 39082773, 51190812, 47704004, 46701299, 82676190, 34505938,\n                63848542, 32980496,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                24740822, 5052253, 37014733, 8961360, 25877428, 6165135, 42740684, 14397371,\n                59728495, 27410326,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                38220480, 3510802, 39005586, 32395953, 55870735, 22922977, 51667400, 19101303,\n                65483377, 27059617,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                67902144, 24323953, 75945165, 27318724, 39747955, 31184838, 100261706, 62223612,\n                57202662, 32932579,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                5666214, 525582, 20782575, 25516013, 42570364, 14657739, 16099374, 1468826,\n                60937436, 18367850,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                62249590, 29775088, 64191105, 26806412, 7778749, 11688288, 36704511, 23683193,\n                65549940, 23690785,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                10896313, 25834728, 67933138, 34027032, 114757419, 36564017, 25248957, 48337770,\n                36527387, 17796587,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10566929, 12612572, 35164652, 11118702, 54475488, 12362878, 21752402, 8822496,\n                24003793, 14264025,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                27713843, 26198459, 56100623, 9227529, 27050101, 2504721, 23886875, 20436907,\n                13958494, 27821979,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                110736080, 38421656, 39861735, 37454952, 29838368, 25342141, 102328328, 23512649,\n                74449384, 51698795,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                4646495, 25543308, 44342840, 22021777, 23184552, 8566613, 31366726, 32173371,\n                52042079, 23179239,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                49838347, 12723031, 50115803, 14878793, 21619651, 27356856, 27584816, 3093888,\n                58265170, 3849920,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                58043933, 35657603, 92670503, 51983125, 61869038, 43137389, 99585908, 24536476,\n                72111157, 18004172,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                55051311, 22376525, 21115584, 20189277, 8808711, 21523724, 16489529, 13378448,\n                41263148, 12741425,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                61162478, 10645102, 36197278, 15390283, 63821882, 26435754, 24306471, 15852464,\n                28834118, 25908360,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                49773097, 24447374, 109686448, 42989383, 58636779, 32971069, 54018092, 34010272,\n                87570721, 39045736,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                13669229, 17458950, 54626889, 23351392, 52539093, 21661233, 42112877, 11293806,\n                38520660, 24132599,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                28497909, 6272777, 34085870, 14470569, 8906179, 32328802, 18504673, 19389266,\n                29867744, 24758489,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                50901822, 47071627, 39309233, 19856633, 24009063, 60734973, 60741262, 53933471,\n                22853427, 29542421,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                24191359, 16712145, 53177067, 15217830, 14542237, 1646131, 18603514, 22516545,\n                12876622, 31441985,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                17902668, 4518229, 66697162, 30725184, 26878216, 5258055, 54248111, 608396,\n                16031844, 3723494,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                105584936, 12763726, 46662418, 41131935, 33001347, 54091119, 17558840, 59235974,\n                23896952, 29240187,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                47103464, 21542479, 31520463, 605201, 2543521, 5991821, 64163800, 7229063,\n                57189218, 24727572,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                28816026, 298879, 38943848, 17633493, 19000927, 31888542, 54428030, 30605106,\n                49057085, 31471516,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                16000882, 33209536, 70601955, 55661665, 37604267, 20394642, 79686603, 49595699,\n                47393623, 7847706,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10151868, 10572098, 27312476, 7922682, 14825339, 4723128, 34252933, 27035413,\n                57088296, 3852847,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55678375, 15697595, 45987307, 29133784, 5386313, 15063598, 16514493, 17622322,\n                29330898, 18478208,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                41609110, 29175637, 51885955, 26653220, 83724594, 35606215, 70412565, 33569921,\n                106668931, 45868821,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                15683501, 27551389, 18109119, 23573784, 15337967, 27556609, 50391428, 15921865,\n                16103996, 29823217,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                43939021, 22773182, 13588191, 31925625, 63310306, 32479502, 47835256, 5402698,\n                37293151, 23713330,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                90299521, 35939014, 34394523, 37016585, 104314072, 32025298, 55842007, 8911516,\n                109011869, 36294143,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                21374101, 30000182, 33584214, 9874410, 15377179, 11831242, 33578960, 6134906,\n                4931255, 11987849,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                67101132, 30575573, 50885377, 7277596, 105524, 33232381, 35628324, 13861387,\n                37032554, 10117929,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                37607694, 22809559, 40945095, 13051538, 41483300, 38644074, 127892224, 40258509,\n                79998882, 15728939,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                45136504, 21783052, 66157804, 29135591, 14704839, 2695116, 903376, 23126293,\n                12885166, 8311031,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                49592363, 5352193, 10384213, 19742774, 7506450, 13453191, 26423267, 4384730,\n                1888765, 28119028,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                108400371, 64001550, 120723127, 30371924, 98005322, 19632702, 101966083, 20846561,\n                47644429, 30214188,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                43500868, 30888657, 66582772, 4651135, 5765089, 4618330, 6092245, 14845197,\n                17151279, 23700316,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                42278406, 20820711, 51942885, 10367249, 37577956, 33289075, 22825804, 26467153,\n                50242379, 16176524,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                43525570, 40119392, 87172552, 37352659, 129477549, 40913655, 69115045, 23191005,\n                38362610, 56911354,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56482264, 29068029, 53788301, 28429114, 3432135, 27161203, 23632036, 31613822,\n                32808309, 1099883,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                15030958, 5768825, 39657628, 30667132, 60681485, 18193060, 51830967, 26745081,\n                2051440, 18328567,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                63746522, 26315059, 74626753, 43379423, 90664713, 33849800, 72257261, 52954675,\n                44422508, 50188091,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                4577067, 16802144, 13249840, 18250104, 19958762, 19017158, 18559669, 22794883,\n                8402477, 23690159,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                38702534, 32502850, 40318708, 32646733, 49896449, 22523642, 9453450, 18574360,\n                17983009, 9967138,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                41346351, 40079153, 93694351, 43523701, 24709297, 34774792, 65430873, 7806336,\n                84616260, 37205991,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56688388, 29436320, 14584638, 15971087, 51340543, 8861009, 26556809, 27979875,\n                48555541, 22197296,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                2839082, 14284142, 4029895, 3472686, 14402957, 12689363, 40466743, 8459446,\n                61503401, 25932490,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                62269556, 30018987, 76853824, 2871047, 92222842, 36741449, 109106914, 32705364,\n                84366947, 25576692,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                18164541, 22959256, 49953981, 32012014, 19237077, 23809137, 23357532, 18337424,\n                26908269, 12150756,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                36843994, 25906566, 5112248, 26517760, 65609056, 26580174, 43167, 28016731,\n                34806789, 16215818,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                60209940, 43378825, 54804084, 29153342, 102820586, 27277595, 99683352, 46087336,\n                59605791, 24879084,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                39765323, 17038963, 39957339, 22831480, 946345, 16291093, 254968, 7168080,\n                21676107, 31611404,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                21260942, 25129680, 50276977, 21633609, 43430902, 3968120, 63456915, 27338965,\n                63552672, 25641356,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                16544735, 46804798, 50304435, 49100673, 62525860, 46311689, 64646555, 24874095,\n                48201831, 23891632,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                64693606, 17976703, 18312302, 4964443, 51836334, 20900867, 26820650, 16690659,\n                25459437, 28989823,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                41964155, 11425019, 28423002, 22533875, 60963942, 17728207, 9142794, 31162830,\n                60676445, 31909614,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                44004193, 39807907, 16964146, 29785560, 109103755, 54812425, 39651637, 50764205,\n                73444554, 40804420,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                36775618, 13979674, 7503222, 21186118, 55152142, 28932738, 36836594, 2682241,\n                25993170, 21075909,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                4364628, 5930691, 32304656, 23509878, 59054082, 15091130, 22857016, 22955477,\n                31820367, 15075278,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                98987979, 24635738, 84367624, 33645057, 126175891, 28636721, 91271651, 23903545,\n                116247489, 46387475,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                19073683, 14851414, 42705695, 21694263, 7625277, 11091125, 47489674, 2074448,\n                57694925, 14905376,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                24483648, 21618865, 64589997, 22007013, 65555733, 15355505, 41826784, 9253128,\n                27628530, 25998952,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                84706452, 41895034, 86464480, 34106618, 26198469, 30377849, 71702187, 24396849,\n                120106852, 48851446,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                510886, 14337390, 35323607, 16638631, 6328095, 2713355, 46891447, 21690211,\n                8683220, 2921426,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                18606791, 11874196, 27155355, 28272950, 43077121, 6265445, 41930624, 32275507,\n                4674689, 13890525,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                13609605, 13069022, 106845367, 20498522, 91469449, 43147405, 82086020, 43389536,\n                71498550, 33842827,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                9922506, 33035038, 13613106, 5883594, 48350519, 33120168, 54804801, 8317627,\n                23388070, 16052080,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                12719997, 11937594, 35138804, 28525742, 26900119, 8561328, 46953177, 21921452,\n                52354592, 22741539,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                83070703, 47704840, 93825794, 32888599, 111423399, 47157999, 78938436, 41022275,\n                38286735, 34483706,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                11038231, 21972036, 39798381, 26237869, 56610336, 17246600, 43629330, 24182562,\n                45715720, 2465073,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                20017144, 29231206, 27915241, 1529148, 12396362, 15675764, 13817261, 23896366,\n                2463390, 28932292,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                50749967, 20890520, 122152544, 38550884, 65852441, 34628003, 76692421, 12851106,\n                71112760, 46228148,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                65377275, 18398561, 63845933, 16143081, 19294135, 13385325, 14741514, 24450706,\n                7903885, 2348101,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                24536016, 17039225, 12715591, 29692277, 1511292, 10047386, 63266518, 26425272,\n                38731325, 10048126,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54486638, 27349611, 97827688, 2591311, 56491836, 12192839, 85982162, 59811773,\n                34811106, 15221631,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                40630742, 22450567, 11546243, 31701949, 9180879, 7656409, 45764914, 2095754,\n                29769758, 6593415,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                35114656, 30646970, 4176911, 3264766, 12538965, 32686321, 26312344, 27435754,\n                30958053, 8292160,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                98538667, 53149747, 96282394, 15632447, 12174511, 64348770, 99917693, 37531617,\n                93251999, 30405555,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                22648882, 1402143, 44308880, 13746058, 7936347, 365344, 58440231, 31879998,\n                63350620, 31249806,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                51616947, 8012312, 64594134, 20851969, 43143017, 23300402, 65496150, 32018862,\n                50444388, 8194477,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                27338047, 26047012, 59694639, 10140404, 48082437, 26964542, 94386054, 42409807,\n                95681149, 36559595,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                26287105, 4821776, 25476601, 29408529, 63344350, 17765447, 49100281, 1182478,\n                41014043, 20474836,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                59937691, 3178079, 23970071, 6201893, 49913287, 29065239, 45232588, 19571804,\n                32208682, 32356184,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                50451143, 36372074, 56822501, 14811297, 73133531, 46903936, 39793359, 56611021,\n                39436277, 22014573,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                15941010, 24148500, 45741813, 8062054, 31876073, 33315803, 51830470, 32110002,\n                15397330, 29424239,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                8934485, 20068965, 43822466, 20131190, 34662773, 14047985, 31170398, 32113411,\n                39603297, 15087183,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                115860466, 31397939, 24524912, 16876564, 82629290, 27193655, 118715321, 11461894,\n                83897392, 27685489,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                65161459, 16013772, 21750665, 3714552, 49707082, 17498998, 63338576, 23231111,\n                31322513, 21938797,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                21426636, 27904214, 53460576, 28206894, 38296674, 28633461, 48833472, 18933017,\n                13040861, 21441484,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                78402740, 46032517, 107081326, 48638180, 104910306, 14748870, 14555558, 20137329,\n                68722574, 38451366,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                41213962, 15323293, 58619073, 25496531, 25967125, 20128972, 2825959, 28657387,\n                43137087, 22287016,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                51184079, 28324551, 49665331, 6410663, 3622847, 10243618, 20615400, 12405433,\n                43355834, 25118015,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                127126414, 46110638, 114026375, 9025185, 50036385, 4333800, 71487300, 35986461,\n                23097948, 32988414,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                4565804, 17528778, 20084411, 25711615, 1724998, 189254, 24767264, 10103221,\n                48596551, 2424777,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                366633, 21577626, 8173089, 26664313, 30788633, 5745705, 59940186, 1344108,\n                63466311, 12412658,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                110215918, 41244716, 82038279, 33386174, 102006892, 53695876, 91271559, 51782359,\n                63967361, 44733816,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                18289503, 18829478, 8056944, 16430056, 45379140, 7842513, 61107423, 32067534,\n                48424218, 22110928,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                476239, 6601091, 60956074, 23831056, 17503544, 28690532, 27672958, 13403813,\n                11052904, 5219329,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                87787372, 25178693, 34436965, 42403554, 129207969, 48129182, 98295834, 29580701,\n                9014761, 58529808,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                53464795, 23204192, 51146355, 5075807, 65594203, 22019831, 34006363, 9160279,\n                8473550, 30297594,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                24900749, 14435722, 17209120, 18261891, 44516588, 9878982, 59419555, 17218610,\n                42540382, 11788947,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                63990690, 22159237, 53306774, 48351872, 76761311, 26708527, 47071426, 43965164,\n                42540393, 32095740,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                51449703, 16736705, 44641714, 10215877, 58011687, 7563910, 11871841, 21049238,\n                48595538, 8464117,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                43708233, 8348506, 52522913, 32692717, 63158658, 27181012, 14325288, 8628612,\n                33313881, 25183915,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                46921853, 28586496, 89476219, 38825978, 66011746, 28765593, 109412060, 23317576,\n                58168128, 61290594,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                60160060, 31759219, 34483180, 17533252, 32635413, 26180187, 15989196, 20716244,\n                28358191, 29300528,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                43547083, 30755372, 34757181, 31892468, 57961144, 10429266, 50471180, 4072015,\n                61757200, 5596588,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                105981130, 30164382, 79421759, 39767609, 3117141, 49632997, 29266238, 36111653,\n                68877164, 15373192,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                59865506, 30307471, 62515396, 26001078, 66980936, 32642186, 66017961, 29049440,\n                42448372, 3442909,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                36898293, 5124042, 14181784, 8197961, 18964734, 21615339, 22597930, 7176455,\n                48523386, 13365929,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                59231455, 32054473, 75433536, 38244510, 73370723, 34444877, 24538106, 24984246,\n                57419264, 30522764,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                25008885, 22782833, 62803832, 23916421, 16265035, 15721635, 683793, 21730648,\n                15723478, 18390951,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                57448220, 12374378, 40101865, 26528283, 59384749, 21239917, 11879681, 5400171,\n                519526, 32318556,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                22258378, 50776631, 59239045, 14613015, 44588609, 30603508, 46754982, 40870398,\n                16648396, 41160072,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                59027556, 25089834, 58885552, 9719709, 19259459, 18206220, 23994941, 28272877,\n                57640015, 4763277,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                45409620, 9220968, 51378240, 1084136, 41632757, 30702041, 31088446, 25789909,\n                55752334, 728111,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                26047201, 55357393, 127317403, 50587064, 91200930, 9158118, 62835319, 20998873,\n                104852291, 28056158,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                17510331, 33231575, 5854288, 8403524, 17133918, 30441820, 38997856, 12327944,\n                10750447, 10014012,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                56796096, 3936951, 9156313, 24656749, 16498691, 32559785, 39627812, 32887699,\n                3424690, 7540221,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                97431206, 26590321, 78469868, 29411114, 74542167, 4989747, 127146306, 50791643,\n                57864597, 48812477,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                13054543, 30774935, 19155473, 469045, 54626067, 4566041, 5631406, 2711395, 1062915,\n                28418087,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                47868616, 22299832, 37599834, 26054466, 61273100, 13005410, 61042375, 12194496,\n                32960380, 1459310,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                86960860, 40582355, 90778216, 43574797, 75695366, 26896524, 67503060, 27452546,\n                85746866, 55933926,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                31395515, 15098109, 26581030, 8030562, 50580950, 28547297, 9012485, 25970078,\n                60465776, 28111795,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                57916680, 31207054, 65111764, 4529533, 25766844, 607986, 67095642, 9677542,\n                34813975, 27098423,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                64664330, 33404494, 96457765, 8186664, 68982624, 12489862, 103283149, 25714738,\n                59256019, 58970434,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                51872508, 18120922, 7766469, 746860, 26346930, 23332670, 39775412, 10754587,\n                57677388, 5203575,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                31834314, 14135496, 66338857, 5159117, 20917671, 16786336, 59640890, 26216907,\n                31809242, 7347066,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                57502122, 21680191, 87523322, 46588417, 80825387, 21862550, 86906833, 21343176,\n                82301739, 31466941,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                54445282, 31372712, 1168161, 29749623, 26747876, 19416341, 10609329, 12694420,\n                33473243, 20172328,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                33184999, 11180355, 15832085, 22169002, 65475192, 225883, 15089336, 22530529,\n                60973201, 14480052,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                98417562, 27934433, 98139703, 31657332, 82783410, 26971548, 72605071, 13685226,\n                27595050, 42291707,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                46790012, 18404192, 10933842, 17376410, 8335351, 26008410, 36100512, 20943827,\n                26498113, 66511,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                22644435, 24792703, 50437087, 4884561, 64003250, 19995065, 30540765, 29267685,\n                53781076, 26039336,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                106199862, 9834843, 85726071, 30873119, 63706907, 53801357, 75314402, 13585436,\n                117090263, 48669869,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                23711543, 32881517, 31206560, 25191721, 6164646, 23844445, 33572981, 32128335,\n                8236920, 16492939,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                43198286, 20038905, 40809380, 29050590, 25005589, 25867162, 19574901, 10071562,\n                6708380, 27332008,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                69210217, 28624377, 86811594, 35922006, 118790560, 34602105, 72409880, 42883131,\n                29955600, 55430554,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                3096359, 9271816, 45488000, 18032587, 52260867, 25961494, 41216721, 20918836,\n                57191288, 6216607,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                34493015, 338662, 41913253, 2510421, 37895298, 19734218, 24822829, 27407865,\n                40341383, 7525078,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                44042196, 53123240, 83242349, 25658253, 130828162, 34333218, 66198527, 30771936,\n                47722230, 45548532,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                21691500, 19929806, 66467532, 19187410, 3285880, 30070836, 42044197, 9718257,\n                59631427, 13381417,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                18445390, 29352196, 14979845, 11622458, 65381754, 29971451, 23111647, 27179185,\n                28535281, 15779576,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                30098034, 36644094, 124983340, 16662133, 45801924, 44862842, 53040409, 12021729,\n                77064149, 17251075,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                9734894, 18977602, 59635230, 24415696, 2060391, 11313496, 48682835, 9924398,\n                20194861, 13380996,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                40730762, 25589224, 44941042, 15789296, 49053522, 27385639, 65123949, 15707770,\n                26342023, 10146099,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                41091971, 33334488, 88448054, 33513043, 86854119, 30675731, 37471583, 35781471,\n                21612325, 33008704,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                54031477, 1184227, 23562814, 27583990, 46757619, 27205717, 25764460, 12243797,\n                46252298, 11649657,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                57077370, 11262625, 27384172, 2271902, 26947504, 17556661, 39943, 6114064,\n                33514190, 2333242,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                112784121, 54687041, 75228644, 40774344, 45278341, 58092729, 60429112, 54438225,\n                91459440, 20104430,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                62992557, 22282898, 43222677, 4843614, 37020525, 690622, 35572776, 23147595,\n                8317859, 12352766,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                18200138, 19078521, 34021104, 30857812, 43406342, 24451920, 43556767, 31266881,\n                20712162, 6719373,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                26656189, 39629685, 59250307, 35440503, 105873684, 37816756, 78226393, 29791221,\n                26224234, 30256974,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                49939907, 18700334, 63713187, 17184554, 47154818, 14050419, 21728352, 9493610,\n                18620611, 17125804,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                53785524, 13325348, 11432106, 5964811, 18609221, 6062965, 61839393, 23828875,\n                36407290, 17074774,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                43248307, 55875704, 94070219, 35195292, 34695751, 16816491, 79357372, 28313792,\n                80844205, 35488493,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                25089769, 6742589, 17081145, 20148166, 21909292, 17486451, 51972569, 29789085,\n                45830866, 5473615,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                31883658, 25593331, 1083431, 21982029, 22828470, 13290673, 59983779, 12469655,\n                29111212, 28103418,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                91353792, 52058456, 107954750, 36345970, 52111264, 50221109, 91476329, 39943270,\n                56813276, 34006814,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                41468082, 30136590, 5217915, 16224624, 19987036, 29472163, 42872612, 27639183,\n                15766061, 8407814,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                46701865, 13990230, 15495425, 16395525, 5377168, 15166495, 58191841, 29165478,\n                59040954, 2276717,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                30157899, 46478498, 116505677, 42800183, 87003891, 36922573, 43281276, 38650650,\n                89849239, 26251014,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                2041139, 19298082, 7783686, 13876377, 41161879, 20201972, 24051123, 13742383,\n                51471265, 13295221,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                33338218, 25048699, 12532112, 7977527, 9106186, 31839181, 49388668, 28941459,\n                62657506, 18884987,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                47063564, 39008528, 52762315, 40001577, 28862070, 35438083, 64639597, 29412551,\n                74879432, 43175028,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                23208049, 7979712, 33071466, 8149229, 1758231, 22719437, 30945527, 31860109,\n                33606523, 18786461,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                1439939, 17283952, 66028874, 32760649, 4625401, 10647766, 62065063, 1220117,\n                30494170, 22113633,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                62071265, 20526136, 64138304, 30492664, 82749837, 26852765, 40369837, 34480481,\n                65424524, 20220784,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                13908495, 30005160, 30919927, 27280607, 45587000, 7989038, 9021034, 9078865,\n                3353509, 4033511,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                37445433, 18440821, 32259990, 33209950, 24295848, 20642309, 23161162, 8839127,\n                27485041, 7356032,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                76769853, 34259874, 79088928, 28184277, 65480320, 14661172, 60762722, 36179446,\n                95539899, 50337029,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                43269631, 25243016, 41163352, 7480957, 49427195, 25200248, 44562891, 14150564,\n                15970762, 4099461,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                29262576, 16756590, 26350592, 24760869, 8529670, 22346382, 13617292, 23617289,\n                11465738, 8317062,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                41615764, 26591503, 99609063, 24135380, 44070139, 31252209, 82007500, 37402886,\n                88078197, 28396915,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                46724414, 19206718, 48772458, 13884721, 34069410, 2842113, 45498038, 29904543,\n                11177094, 14989547,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                42612143, 21838415, 16959895, 2278463, 12066309, 10137771, 13515641, 2581286,\n                38621356, 9930239,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                49357223, 31456605, 83653163, 54099563, 118302919, 18605349, 18345766, 53705111,\n                83400343, 28240393,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                33879670, 2553287, 32678213, 9875984, 8534129, 6889387, 57432090, 6957616, 4368891,\n                9788741,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                16660737, 7281060, 56278106, 12911819, 20108584, 25452756, 45386327, 24941283,\n                16250551, 22443329,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                47343357, 35944957, 117666696, 14161978, 69014150, 39969338, 71798447, 10604806,\n                104027325, 4782745,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                65754325, 14736940, 59741422, 20261545, 7710541, 19398842, 57127292, 4383044,\n                22546403, 437323,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                31665558, 21373968, 50922033, 1491338, 48740239, 3294681, 27343084, 2786261,\n                36475274, 19457415,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                52641566, 32870716, 33734756, 41002983, 19294359, 14334329, 47418233, 35909750,\n                47824192, 27440058,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                15121312, 17758270, 6377019, 27523071, 56310752, 20596586, 18952176, 15496498,\n                37728731, 11754227,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64471568, 20071356, 8488726, 19250536, 12728760, 31931939, 7141595, 11724556,\n                22761615, 23420291,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                16918416, 11729663, 49025285, 36577418, 103201995, 53769203, 38367677, 21327038,\n                32851221, 11717399,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                11166615, 7338049, 60386341, 4531519, 37640192, 26252376, 31474878, 3483633,\n                65915689, 29523600,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                66923210, 9921304, 31456609, 20017994, 55095045, 13348922, 33142652, 6546660,\n                47123585, 29606055,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                101757113, 44821142, 55911756, 25655328, 31703693, 37410335, 58571732, 20721383,\n                36336829, 18068118,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                49102387, 12709067, 3991746, 27075244, 45617340, 23004006, 35973516, 17504552,\n                10928916, 3011958,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                60151107, 17960094, 31696058, 334240, 29576716, 14796075, 36277808, 20749251,\n                18008030, 10258577,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                44660220, 49210000, 74127342, 29144428, 36794597, 32352840, 65255398, 34921551,\n                92236737, 6671742,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                29701166, 19180498, 56230743, 9279287, 67091296, 13127209, 21382910, 11042292,\n                25838796, 4642684,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                46678630, 14955536, 42982517, 8124618, 61739576, 27563961, 30468146, 19653792,\n                18423288, 4177476,\n            ]),\n        },\n    ]),\n]);\n\n/// Odd multiples of the basepoint `[B, 3B, 5B, 7B, 9B, 11B, 13B, 15B, ..., 127B]`.\n#[cfg(feature = \"precomputed-tables\")]\n#[allow(dead_code)]\npub(crate) const AFFINE_ODD_MULTIPLES_OF_BASEPOINT: NafLookupTable8<AffineNielsPoint> =\n    NafLookupTable8([\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                93076338, 52752828, 29566454, 37215328, 54414518, 37569218, 94653489, 21800160,\n                61029707, 35602036,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                54563134, 934261, 64385954, 3049989, 66381436, 9406985, 12720692, 5043384,\n                19500929, 18085054,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                58370664, 4489569, 9688441, 18769238, 10184608, 21191052, 29287918, 11864899,\n                42594502, 29115885,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                82745136, 23865874, 24204772, 25642034, 67725840, 16869169, 94896463, 52336674,\n                28944398, 32004408,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                16568933, 4717097, 55552716, 32452109, 15682895, 21747389, 16354576, 21778470,\n                7689661, 11199574,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                30464137, 27578307, 55329429, 17883566, 23220364, 15915852, 7512774, 10017326,\n                49359771, 23634074,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77970208, 11473153, 27284546, 35535607, 37044514, 46132292, 99976748, 48069538,\n                118779423, 44373810,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                4708026, 6336745, 20377586, 9066809, 55836755, 6594695, 41455196, 12483687,\n                54440373, 5581305,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                19563141, 16186464, 37722007, 4097518, 10237984, 29206317, 28542349, 13850243,\n                43430843, 17738489,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                72262591, 43463716, 68832610, 30776557, 97632468, 39071304, 86589715, 38784565,\n                43156424, 18378665,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                36839857, 30090922, 7665485, 10083793, 28475525, 1649722, 20654025, 16520125,\n                30598449, 7715701,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                28881826, 14381568, 9657904, 3680757, 46927229, 7843315, 35708204, 1370707,\n                29794553, 32145132,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                44589852, 26862249, 14201701, 24808930, 43598457, 42399157, 85583074, 32192981,\n                54046167, 47376308,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                60653668, 25714560, 3374701, 28813570, 40010246, 22982724, 31655027, 26342105,\n                18853321, 19333481,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                4566811, 20590564, 38133974, 21313742, 59506191, 30723862, 58594505, 23123294,\n                2207752, 30344648,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                41954014, 62923042, 96790006, 41423232, 60254202, 24130566, 121780363, 32891430,\n                103106264, 17421994,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                25576264, 30851218, 7349803, 21739588, 16472781, 9300885, 3844789, 15725684,\n                171356, 6466918,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                23103977, 13316479, 9739013, 17404951, 817874, 18515490, 8965338, 19466374,\n                36393951, 16193876,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                100695917, 36735143, 64714733, 47558118, 50205389, 17283591, 84347261, 38283886,\n                49034350, 9256799,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                41926547, 29380300, 32336397, 5036987, 45872047, 11360616, 22616405, 9761698,\n                47281666, 630304,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                53388152, 2639452, 42871404, 26147950, 9494426, 27780403, 60554312, 17593437,\n                64659607, 19263131,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                63957664, 28508356, 76391577, 40420576, 102310665, 32691407, 48168288, 15033783,\n                92213982, 25659555,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                42782475, 15950225, 35307649, 18961608, 55446126, 28463506, 1573891, 30928545,\n                2198789, 17749813,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64009494, 10324966, 64867251, 7453182, 61661885, 30818928, 53296841, 17317989,\n                34647629, 21263748,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                17735022, 27114469, 76149336, 40765111, 43325570, 26153544, 26948151, 45905235,\n                38656900, 62179684,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                2154119, 14782993, 28737794, 11906199, 36205504, 26488101, 19338132, 16910143,\n                50209922, 29794297,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                29935700, 6336041, 20999566, 30405369, 13628497, 24612108, 61639745, 22359641,\n                56973806, 18684690,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                29792811, 31379227, 113441390, 20675662, 58452680, 54138549, 42892249, 32958636,\n                31674345, 24275271,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                7606599, 22131225, 17376912, 15235046, 32822971, 7512882, 30227203, 14344178,\n                9952094, 8804749,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                32575079, 3961822, 36404898, 17773250, 67073898, 1319543, 30641032, 7823672,\n                63309858, 18878784,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77823924, 52933642, 26572931, 18690221, 109143683, 23989794, 79129572, 53326100,\n                38888709, 55889506,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                37146997, 554126, 63326061, 20925660, 49205290, 8620615, 53375504, 25938867,\n                8752612, 31225894,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                4529887, 12416158, 60388162, 30157900, 15427957, 27628808, 61150927, 12724463,\n                23658330, 23690055,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                102043267, 54823614, 45810225, 19657305, 54297192, 7413280, 66851983, 39718512,\n                25005048, 18002658,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                5403481, 24654166, 61855580, 13522652, 14989680, 1879017, 43913069, 25724172,\n                20315901, 421248,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                34818947, 1705239, 25347020, 7938434, 51632025, 1720023, 54809726, 32655885,\n                64907986, 5517607,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                88543525, 16557377, 80359887, 30047148, 91602876, 27723948, 62710290, 52707861,\n                7715736, 61648232,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                14461032, 6393639, 22681353, 14533514, 52493587, 3544717, 57780998, 24657863,\n                59891807, 31628125,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                60864886, 31199953, 18524951, 11247802, 43517645, 21165456, 26204394, 27268421,\n                63221077, 29979135,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                97491378, 10077555, 94805128, 42472719, 30231379, 17961119, 76201413, 41182329,\n                41405214, 31798052,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                13670592, 720327, 7131696, 19360499, 66651570, 16947532, 3061924, 22871019,\n                39814495, 20141336,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                44847187, 28379568, 38472030, 23697331, 49441718, 3215393, 1669253, 30451034,\n                62323912, 29368533,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                74923758, 35244493, 27222384, 30715870, 48444195, 28125622, 116052444, 32330148,\n                92609232, 35372537,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                39340596, 15199968, 52787715, 18781603, 18787729, 5464578, 11652644, 8722118,\n                57056621, 5153960,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                5733861, 14534448, 59480402, 15892910, 30737296, 188529, 491756, 17646733,\n                33071791, 15771063,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                85239571, 21331573, 119690709, 30172286, 44350959, 55826224, 68258766, 16209406,\n                20222151, 32139086,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                52372801, 13847470, 52690845, 3802477, 48387139, 10595589, 13745896, 3112846,\n                50361463, 2761905,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                45982696, 12273933, 15897066, 704320, 31367969, 3120352, 11710867, 16405685,\n                19410991, 10591627,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                82008850, 34439758, 89319886, 49124188, 34309215, 29866047, 80308709, 27738519,\n                71739865, 46909287,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                36631997, 23300851, 59535242, 27474493, 59924914, 29067704, 17551261, 13583017,\n                37580567, 31071178,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                22641770, 21277083, 10843473, 1582748, 37504588, 634914, 15612385, 18139122,\n                59415250, 22563863,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                76721854, 52814714, 41722368, 35285867, 53022548, 38255176, 93163883, 27627617,\n                87963092, 33729456,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                61915349, 11733561, 59403492, 31381562, 29521830, 16845409, 54973419, 26057054,\n                49464700, 796779,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                3855018, 8248512, 12652406, 88331, 2948262, 971326, 15614761, 9441028, 29507685,\n                8583792,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                76968870, 14808584, 76708906, 57649718, 23400175, 24077237, 63783137, 37471119,\n                56750251, 30681804,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                33709664, 3740344, 52888604, 25059045, 46197996, 22678812, 45207164, 6431243,\n                21300862, 27646257,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                49811511, 9216232, 25043921, 18738174, 29145960, 3024227, 65580502, 530149,\n                66809973, 22275500,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                23499366, 24936714, 38355445, 35908587, 82540167, 39280880, 46809413, 41143783,\n                72530804, 49676198,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                45162189, 23851397, 9380591, 15192763, 36034862, 15525765, 5277811, 25040629,\n                33286237, 31693326,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                62424427, 13336013, 49368582, 1581264, 30884213, 15048226, 66823504, 4736577,\n                53805192, 29608355,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                25190215, 26304748, 58928336, 42665707, 64280342, 38580230, 61299598, 20659504,\n                30387592, 32519377,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                14480213, 17057820, 2286692, 32980967, 14693157, 22197912, 49247898, 9909859,\n                236428, 16857435,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                7877514, 29872867, 45886243, 25902853, 41998762, 6241604, 35694938, 15657879,\n                56797932, 8609105,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54245189, 32562161, 57887697, 19509733, 45323534, 37472546, 27606727, 59528498,\n                74398957, 44973176,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                28964163, 20950093, 44929966, 26145892, 34786807, 18058153, 18187179, 27016486,\n                42438836, 14869174,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55703901, 1222455, 64329400, 24533246, 11330890, 9135834, 3589529, 19555234,\n                53275553, 1207212,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                33323313, 35603165, 79328585, 6017848, 71286345, 23804207, 86644124, 44008367,\n                55775078, 31816581,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                64814718, 27217688, 29891310, 4504619, 8548709, 21986323, 62140656, 12555980,\n                34377058, 21436823,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                49069441, 9880212, 33350825, 24576421, 24446077, 15616561, 19302117, 9370836,\n                55172180, 28526191,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                95404934, 26757208, 123864063, 4572839, 69249194, 43584425, 53559055, 41742046,\n                41167331, 24643278,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                35101859, 30958612, 66105296, 3168612, 22836264, 10055966, 22893634, 13045780,\n                28576558, 30704591,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                59987873, 21166324, 43296694, 15387892, 39447987, 19996270, 5059183, 19972934,\n                30207804, 29631666,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                67444156, 16132892, 88330413, 37924284, 68147855, 57949418, 91481571, 24889160,\n                62329722, 50712214,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56922508, 1347520, 23300731, 27393371, 42651667, 8512932, 27610931, 24436993,\n                3998295, 3835244,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                16327050, 22776956, 14746360, 22599650, 23700920, 11727222, 25900154, 21823218,\n                34907363, 25105813,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                59807886, 12089757, 115624210, 41476837, 67589715, 26361580, 71355762, 44268661,\n                67753061, 13128476,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                7174885, 26592113, 59892333, 6465478, 4145835, 17673606, 38764952, 22293290,\n                1360980, 25805937,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                40179568, 6331649, 42386021, 20205884, 15635073, 6103612, 56391180, 6789942,\n                7597240, 24095312,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54776568, 36935932, 18757261, 41429535, 67215081, 34700142, 86560976, 61204154,\n                26496794, 19612129,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                46701540, 24101444, 49515651, 25946994, 45338156, 9941093, 55509371, 31298943,\n                1347425, 15381335,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                53576449, 26135856, 17092785, 3684747, 57829121, 27109516, 2987881, 10987137,\n                52269096, 15465522,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                80033010, 26264316, 72380996, 10039544, 94605936, 30615493, 60406855, 30400829,\n                120765849, 45301372,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                35668062, 24246990, 47788280, 25128298, 37456967, 19518969, 43459670, 10724644,\n                7294162, 4471290,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                33813988, 3549109, 101112, 21464449, 4858392, 3029943, 59999440, 21424738,\n                34313875, 1512799,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                29494960, 28240930, 51093230, 28823678, 92791151, 54796794, 77571888, 37795542,\n                75765856, 10649531,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                63536751, 7572551, 62249759, 25202639, 32046232, 32318941, 29315141, 15424555,\n                24706712, 28857648,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                47618751, 5819839, 19528172, 20715950, 40655763, 20611047, 4960954, 6496879,\n                2790858, 28045273,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                85174457, 55843901, 111946683, 31021158, 32797785, 48944265, 78338887, 31144772,\n                82688001, 38470222,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                49664705, 3638040, 57888693, 19234931, 40104182, 28143840, 28667142, 18386877,\n                18584835, 3592929,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                12065039, 18867394, 6430594, 17107159, 1727094, 13096957, 61520237, 27056604,\n                27026997, 13543966,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                68512926, 37577278, 94695528, 14209106, 95849194, 30038709, 51818051, 20241476,\n                68980056, 42251074,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                17325298, 33376175, 65271265, 4931225, 31708266, 6292284, 23064744, 22072792,\n                43945505, 9236924,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                51955585, 20268063, 61151838, 26383348, 4766519, 20788033, 21173534, 27030753,\n                9509140, 7790046,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                24124086, 38918775, 28620390, 10538620, 59433851, 19581010, 60862718, 43500219,\n                77600721, 32213801,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                7062127, 13930079, 2259902, 6463144, 32137099, 24748848, 41557343, 29331342,\n                47345194, 13022814,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                18921826, 392002, 55817981, 6420686, 8000611, 22415972, 14722962, 26246290,\n                20604450, 8079345,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                67710253, 26257798, 51499391, 46550521, 30228769, 53940987, 76234206, 43362242,\n                77953697, 21034392,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                25817710, 8020883, 50134679, 21244805, 47057788, 8766556, 29308546, 22307963,\n                49449920, 23874253,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                11081015, 13522660, 12474691, 29260223, 48687631, 9341946, 16850694, 18637605,\n                6199839, 14303642,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                64518173, 19894035, 117213833, 43031641, 79641718, 39533880, 66531934, 41205092,\n                117735515, 13989682,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                6921800, 4421166, 59739491, 30510778, 43106355, 30941531, 9363541, 3394240,\n                50874187, 23872585,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                54293979, 23466866, 47184247, 20627378, 8313211, 5865878, 5948507, 32290343,\n                52583140, 23139870,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                111574723, 24134616, 49842442, 23485580, 34844037, 45228427, 67103167, 25858409,\n                38508586, 35097070,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                19879846, 15259900, 25020018, 14261729, 22075205, 25189303, 787540, 31325033,\n                62422289, 16131171,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                39487053, 27893575, 34654176, 25620816, 60209846, 23603919, 8931189, 12275052,\n                38626469, 33438928,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                105416367, 9568747, 62672739, 49685015, 106242995, 4547918, 18403901, 38581738,\n                60829966, 33150322,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                7950033, 25841033, 47276506, 3884935, 62418883, 2342083, 50269031, 14194015,\n                27013685, 3320257,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                35270691, 18076829, 46994271, 4273335, 43595882, 31742297, 58328702, 4594760,\n                49180851, 18144010,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                30194115, 50068680, 49746331, 27470090, 40428285, 23271051, 70252167, 16153483,\n                123511881, 27809602,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                27113466, 6865046, 4512771, 29327742, 29021084, 7405965, 33302911, 9322435,\n                4307527, 32438240,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                29337813, 24673346, 10359233, 30347534, 57709483, 9930840, 60607771, 24076133,\n                20985293, 22480923,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                14579237, 33467236, 85745988, 15769997, 101228358, 21649866, 82685456, 59023858,\n                86175344, 24337101,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                4472119, 14702190, 10432042, 22460027, 708461, 18783996, 34234374, 30870323,\n                63796457, 10370850,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                36957127, 19555637, 16244231, 24367549, 58999881, 13440043, 35147632, 8718974,\n                43101064, 18487380,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                21818223, 34477173, 23913863, 22441963, 129271975, 14842154, 43035020, 9485973,\n                53819529, 22318987,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                10874834, 4351765, 66252340, 17269436, 64427034, 30735311, 5883785, 28998531,\n                44403022, 26064601,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                64017630, 9755550, 37507935, 22752543, 4031638, 29903925, 47267417, 32706846,\n                39147952, 21635901,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                81365001, 44927611, 97395185, 43985591, 66242539, 38517499, 52937891, 37374973,\n                73352483, 38476849,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                43460763, 24260930, 21493330, 30888969, 23329454, 24545577, 58286855, 12750266,\n                22391140, 26198125,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                20477567, 24078713, 1674568, 4102219, 25208396, 13972305, 30389482, 19572626,\n                1485666, 17679765,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                100511110, 23887606, 116505658, 30877106, 45483774, 25222431, 67931340, 37154158,\n                32618865, 18610785,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                48647066, 166413, 55454758, 8889513, 21027475, 32728181, 43100067, 4690060,\n                7520989, 16421303,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                14868391, 20996450, 64836606, 1042490, 27060176, 10253541, 53431276, 19516737,\n                41808946, 2239538,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                50228416, 29594943, 62030348, 10307368, 70970997, 20292574, 126292474, 51543890,\n                67827181, 15848795,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                5548701, 17911007, 33137864, 32764443, 31146554, 17931096, 64023370, 7290289,\n                6361313, 32861205,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                63374742, 30320053, 4091667, 30955480, 44819449, 2212055, 52638826, 22391938,\n                38484599, 7051029,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                50485560, 7033600, 57711425, 10740562, 72347547, 42328739, 7593987, 46950560,\n                85560721, 41970063,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                40930651, 3776911, 39108529, 2508077, 19371703, 7626128, 4092943, 15778278,\n                42044145, 24540103,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                44128555, 8867576, 8645499, 22222278, 11497130, 4344907, 10788462, 23382703,\n                3547104, 15368835,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                81786515, 51902785, 74560130, 22753403, 52379722, 41395524, 57994925, 6818020,\n                57707296, 16352835,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                21622574, 18581624, 36511951, 1212467, 36930308, 7910192, 20622927, 2438677,\n                52628762, 29068327,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                6797431, 2854059, 4269865, 8037366, 32016522, 15223213, 34765784, 15297582,\n                3559197, 26425254,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                107761639, 61759660, 79235166, 8794359, 48418924, 60111631, 87862210, 33613219,\n                68436482, 40229362,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                52388944, 32880897, 37676257, 8253690, 32826330, 2707379, 25088512, 17182878,\n                15053907, 11601568,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                43894091, 25425955, 50962615, 28097648, 30129084, 13258436, 39364589, 8197601,\n                58181660, 15003422,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                13470722, 47835674, 31012390, 30525035, 89789519, 50713267, 39648035, 13815677,\n                94028755, 62582101,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                54478677, 14782829, 56712503, 7094748, 41775828, 29409658, 9084386, 30179063,\n                64014926, 32519086,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                6314429, 20018828, 12535891, 19610611, 10074031, 28087963, 50489447, 26314252,\n                24553876, 32746308,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                105768482, 46629424, 103418946, 65789027, 85765355, 28316167, 56299027, 22780838,\n                122676432, 32376204,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                5654403, 26425050, 39347935, 963424, 5032477, 19850195, 30011537, 11153401,\n                63182039, 13343989,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                1130444, 29814849, 40569426, 8144467, 24179188, 6267924, 63847147, 2912740,\n                63870704, 29186744,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                49722534, 11073633, 52865263, 50829611, 33921405, 38614719, 32360242, 35465390,\n                50107050, 45035301,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                2003571, 2472803, 46902183, 1716406, 58609069, 15922982, 43766122, 27456369,\n                33468339, 29346282,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                18834217, 8245144, 29896065, 3490830, 62967493, 7220277, 146130, 18459164,\n                57533060, 30070422,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                77805507, 38474121, 73459597, 18553340, 107508318, 52705654, 33655873, 27331956,\n                44498407, 13768350,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                23652128, 27647291, 43351590, 13262712, 65238054, 26296349, 11902126, 2949002,\n                34445239, 25602117,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                55906958, 19046111, 28501158, 28224561, 14495533, 14714956, 32929972, 2643566,\n                17034893, 11645825,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                38181639, 29751709, 73650473, 17760526, 80753587, 17992258, 72670209, 41214427,\n                87524152, 37630124,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                6498441, 12053607, 10375600, 14764370, 24795955, 16159258, 57849421, 16071837,\n                31008329, 3792564,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                47930485, 9176956, 54248931, 8732776, 58000258, 10333519, 96092, 29273884,\n                13051277, 20121493,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                54190492, 49837594, 61282066, 10734597, 67926686, 36967416, 115462142, 30339271,\n                37200685, 30036936,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                21193614, 19929501, 18841215, 29565554, 64002173, 11123558, 14111648, 6069945,\n                30307604, 25935103,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                58539773, 2098685, 38301131, 15844175, 41633654, 16934366, 15145895, 5543861,\n                64050790, 6595361,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                34107945, 34731353, 51956038, 5614778, 79079051, 30288154, 47460410, 22186730,\n                30689695, 19628976,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                25043248, 19224237, 46048097, 32289319, 29339134, 12397721, 37385860, 12978240,\n                57951631, 31419653,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                46038439, 28501736, 62566522, 12609283, 35236982, 30457796, 64113609, 14800343,\n                6412849, 6276813,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                124528774, 39505727, 83050803, 41361190, 116071796, 37845759, 61633481, 38385016,\n                71255100, 31629488,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                249426, 17196749, 35434953, 13884216, 11701636, 24553269, 51821986, 12900910,\n                34844073, 16150118,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                2520516, 14697628, 15319213, 22684490, 62866663, 29666431, 13872507, 7473319,\n                12419515, 2958466,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                101517167, 22298305, 98222207, 59471046, 61547444, 50370568, 97111094, 42539051,\n                14298448, 49873561,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                19427905, 12004555, 9971383, 28189868, 32306269, 23648270, 34176633, 10760437,\n                53354280, 5634974,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                30044319, 23677863, 60273406, 14563839, 9734978, 19808149, 30899064, 30835691,\n                22828539, 23633348,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                25513026, 37111929, 37113703, 29589233, 77394412, 34745965, 95889446, 61766763,\n                92876242, 37566563,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                42139852, 9176396, 16274786, 33467453, 52558621, 7190768, 1490604, 31312359,\n                44767199, 18491072,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                4272877, 21431483, 45594743, 13027605, 59232641, 24151956, 38390319, 12906718,\n                45915869, 15503563,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                29874396, 35808736, 25494239, 37976524, 43036007, 37144111, 18198811, 35141252,\n                53490316, 47742788,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                59518553, 28520621, 59946871, 29462027, 3630300, 29398589, 60425462, 24588735,\n                53129947, 28399367,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                18192774, 12787801, 32021061, 9158184, 48389348, 16385092, 11799402, 9492011,\n                43154220, 15950102,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                68768204, 54638026, 33464925, 53430209, 66037964, 35360373, 22565155, 39168685,\n                46605438, 51897954,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                57660336, 29715319, 64414626, 32753338, 16894121, 935644, 53848937, 22684138,\n                10541713, 14174330,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                22888141, 12700209, 40301697, 6435658, 56329485, 5524686, 56715961, 6520808,\n                15754965, 9355803,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                79549820, 26746924, 54931884, 38547877, 49672847, 19708985, 52599424, 12757151,\n                93328625, 39524327,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                33888606, 13911610, 18921581, 1162763, 46616901, 13799218, 29525142, 21929286,\n                59295464, 503508,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                57865531, 22043577, 17998312, 3038439, 52838371, 9832208, 43311531, 660991,\n                25265267, 18977724,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                64010269, 23727746, 42277281, 48089313, 102316973, 34946803, 127880577, 38411468,\n                114816699, 43712746,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56859315, 32558245, 41017090, 22610758, 13704990, 23215119, 2475037, 32344984,\n                12799418, 11135856,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                1867214, 27167702, 19772099, 16925005, 15366693, 25797692, 10829276, 15372827,\n                26582557, 31642714,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                57265197, 20059797, 107314987, 30587501, 60553812, 25602102, 29690666, 37127097,\n                103070929, 51772159,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56432653, 6329655, 42770975, 4187982, 30677076, 9335071, 60103332, 14755050,\n                9451294, 574767,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                52859018, 2867107, 56258365, 15719081, 5959372, 8703738, 29137781, 21575537,\n                20249840, 31808689,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                74749335, 47235127, 9995910, 52200224, 92069015, 8964515, 33248715, 21201554,\n                57573145, 31605506,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                56307055, 23891752, 3613811, 30787942, 49031222, 26667524, 26985478, 31973510,\n                26785294, 29587427,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                30891460, 5254655, 47414930, 12769216, 42912782, 11830405, 7411958, 1394027,\n                18778535, 18209370,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                61227949, 26179350, 57501473, 13585864, 102855675, 40344975, 54134826, 59707765,\n                74122694, 12256219,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                5975515, 16302413, 24341148, 28270615, 18786096, 22405501, 28243950, 28328004,\n                53412289, 4381960,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                9394648, 8758552, 26189703, 16642536, 35993528, 5117040, 5977877, 13955594,\n                19244020, 24493735,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                111388362, 51822507, 30193028, 3993472, 110736308, 44014764, 107346699, 48464072,\n                92830877, 56442511,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                7236795, 30433657, 63588571, 620817, 11118384, 24979014, 66780154, 19877679,\n                16217590, 26311105,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                42540794, 21657271, 16455973, 23630199, 3992015, 21894417, 44876052, 19291718,\n                55429803, 30442389,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement2625::from_limbs([\n                69421833, 26972132, 58859271, 20240912, 119664007, 29643940, 93968457, 34515112,\n                110902491, 44996669,\n            ]),\n            y_minus_x: FieldElement2625::from_limbs([\n                3428668, 27807272, 41139948, 24786894, 4167808, 21423270, 52199622, 8021269,\n                53172251, 18070808,\n            ]),\n            xy2d: FieldElement2625::from_limbs([\n                30631113, 26363656, 21279866, 23275794, 18311406, 466071, 42527968, 7989982,\n                29641567, 29446694,\n            ]),\n        },\n    ]);\n",
    "filename": "curve25519-dalek/src/backend/serial/u32/constants.rs",
    "filepath": null,
    "folder_id": 15838,
    "user_id": 460154
  },
  "63626": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! The `u32` backend uses `u32`s and a `(u32, u32) -> u64` multiplier.\n//!\n//! This code is intended to be portable, but it requires that\n//! multiplication of two \\\\(32\\\\)-bit values to a \\\\(64\\\\)-bit result\n//! is constant-time on the target platform.\n\npub mod field;\n\npub mod scalar;\n\npub mod constants;\n",
    "filename": "curve25519-dalek/src/backend/serial/u32/mod.rs",
    "filepath": null,
    "folder_id": 15838,
    "user_id": 460154
  },
  "63627": {
    "text": "// -*- mode: rust; coding: utf-8; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2018 Isis Lovecruft, Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Isis Agora Lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Field arithmetic modulo \\\\(p = 2\\^{255} - 19\\\\), using \\\\(64\\\\)-bit\n//! limbs with \\\\(128\\\\)-bit products.\n//!\n//! This uses the formally-verified field arithmetic generated by the\n//! [fiat-crypto project](https://github.com/mit-plv/fiat-crypto)\n\nuse core::fmt::Debug;\nuse core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};\nuse core::ops::{Sub, SubAssign};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse fiat_crypto::curve25519_64::*;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51(pub(crate) fiat_25519_tight_field_element);\n\nimpl Debug for FieldElement51 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &(self.0).0[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    fn zeroize(&mut self) {\n        (self.0).0.zeroize();\n    }\n}\n\nimpl<'b> AddAssign<&'b FieldElement51> for FieldElement51 {\n    fn add_assign(&mut self, rhs: &'b FieldElement51) {\n        let mut result_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_add(&mut result_loose, &self.0, &rhs.0);\n        fiat_25519_carry(&mut self.0, &result_loose);\n    }\n}\n\nimpl<'a, 'b> Add<&'b FieldElement51> for &'a FieldElement51 {\n    type Output = FieldElement51;\n    fn add(self, rhs: &'b FieldElement51) -> FieldElement51 {\n        let mut result_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_add(&mut result_loose, &self.0, &rhs.0);\n        let mut output = FieldElement51::ZERO;\n        fiat_25519_carry(&mut output.0, &result_loose);\n        output\n    }\n}\n\nimpl<'b> SubAssign<&'b FieldElement51> for FieldElement51 {\n    fn sub_assign(&mut self, rhs: &'b FieldElement51) {\n        let mut result_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_sub(&mut result_loose, &self.0, &rhs.0);\n        fiat_25519_carry(&mut self.0, &result_loose);\n    }\n}\n\nimpl<'a, 'b> Sub<&'b FieldElement51> for &'a FieldElement51 {\n    type Output = FieldElement51;\n    fn sub(self, rhs: &'b FieldElement51) -> FieldElement51 {\n        let mut result_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_sub(&mut result_loose, &self.0, &rhs.0);\n        let mut output = FieldElement51::ZERO;\n        fiat_25519_carry(&mut output.0, &result_loose);\n        output\n    }\n}\n\nimpl<'b> MulAssign<&'b FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, rhs: &'b FieldElement51) {\n        let mut self_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_relax(&mut self_loose, &self.0);\n        let mut rhs_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_relax(&mut rhs_loose, &rhs.0);\n        fiat_25519_carry_mul(&mut self.0, &self_loose, &rhs_loose);\n    }\n}\n\nimpl<'a, 'b> Mul<&'b FieldElement51> for &'a FieldElement51 {\n    type Output = FieldElement51;\n    fn mul(self, rhs: &'b FieldElement51) -> FieldElement51 {\n        let mut self_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_relax(&mut self_loose, &self.0);\n        let mut rhs_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_relax(&mut rhs_loose, &rhs.0);\n        let mut output = FieldElement51::ZERO;\n        fiat_25519_carry_mul(&mut output.0, &self_loose, &rhs_loose);\n        output\n    }\n}\n\nimpl<'a> Neg for &'a FieldElement51 {\n    type Output = FieldElement51;\n    fn neg(self) -> FieldElement51 {\n        let mut output_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_opp(&mut output_loose, &self.0);\n        let mut output = FieldElement51::ZERO;\n        fiat_25519_carry(&mut output.0, &output_loose);\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        let mut output = fiat_25519_tight_field_element([0u64; 5]);\n        fiat_25519_selectznz(\n            &mut output.0,\n            choice.unwrap_u8() as fiat_25519_u1,\n            &(a.0).0,\n            &(b.0).0,\n        );\n        FieldElement51(output)\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }\n\n    fn conditional_assign(&mut self, rhs: &FieldElement51, choice: Choice) {\n        let mut output = [0u64; 5];\n        let choicebit = choice.unwrap_u8() as fiat_25519_u1;\n        fiat_25519_cmovznz_u64(&mut output[0], choicebit, self.0[0], rhs.0[0]);\n        fiat_25519_cmovznz_u64(&mut output[1], choicebit, self.0[1], rhs.0[1]);\n        fiat_25519_cmovznz_u64(&mut output[2], choicebit, self.0[2], rhs.0[2]);\n        fiat_25519_cmovznz_u64(&mut output[3], choicebit, self.0[3], rhs.0[3]);\n        fiat_25519_cmovznz_u64(&mut output[4], choicebit, self.0[4], rhs.0[4]);\n        *self = FieldElement51::from_limbs(output);\n    }\n}\n\nimpl FieldElement51 {\n    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51(fiat_25519_tight_field_element(limbs))\n    }\n\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: FieldElement51 = FieldElement51::from_limbs([0, 0, 0, 0, 0]);\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: FieldElement51 = FieldElement51::from_limbs([1, 0, 0, 0, 0]);\n    /// The scalar \\\\( -1 \\\\).\n    pub const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n        2251799813685228,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n    ]);\n\n    /// Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).\n    #[inline(always)]\n    #[allow(dead_code)] // Need this to not complain about reduce not being used\n    fn reduce(limbs: [u64; 5]) -> FieldElement51 {\n        let input = fiat_25519_loose_field_element(limbs);\n        let mut output = fiat_25519_tight_field_element([0; 5]);\n        fiat_25519_carry(&mut output, &input);\n        FieldElement51(output)\n    }\n\n    /// Load a `FieldElement51` from the low 255 bits of a 256-bit\n    /// input.\n    ///\n    /// # Warning\n    ///\n    /// This function does not check that the input used the canonical\n    /// representative.  It masks the high bit, but it will happily\n    /// decode 2^255 - 18 to 1.  Applications that require a canonical\n    /// encoding of every field element should decode, re-encode to\n    /// the canonical encoding, and check that the input was\n    /// canonical.\n    ///\n    pub const fn from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n        let mut temp = [0u8; 32];\n        temp.copy_from_slice(bytes);\n        temp[31] &= 127u8;\n        let mut output = fiat_25519_tight_field_element([0u64; 5]);\n        fiat_25519_from_bytes(&mut output, &temp);\n        FieldElement51(output)\n    }\n\n    /// Serialize this `FieldElement51` to a 32-byte array.  The\n    /// encoding is canonical.\n    pub fn to_bytes(self) -> [u8; 32] {\n        let mut bytes = [0u8; 32];\n        fiat_25519_to_bytes(&mut bytes, &self.0);\n        bytes\n    }\n\n    /// Given `k > 0`, return `self^(2^k)`.\n    pub fn pow2k(&self, mut k: u32) -> FieldElement51 {\n        let mut output = *self;\n        loop {\n            let mut input = fiat_25519_loose_field_element([0; 5]);\n            fiat_25519_relax(&mut input, &output.0);\n            fiat_25519_carry_square(&mut output.0, &input);\n            k -= 1;\n            if k == 0 {\n                return output;\n            }\n        }\n    }\n\n    /// Returns the square of this field element.\n    pub fn square(&self) -> FieldElement51 {\n        let mut self_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_relax(&mut self_loose, &self.0);\n        let mut output = FieldElement51::ZERO;\n        fiat_25519_carry_square(&mut output.0, &self_loose);\n        output\n    }\n\n    /// Returns 2 times the square of this field element.\n    pub fn square2(&self) -> FieldElement51 {\n        let mut self_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_relax(&mut self_loose, &self.0);\n        let mut square = fiat_25519_tight_field_element([0; 5]);\n        fiat_25519_carry_square(&mut square, &self_loose);\n        let mut output_loose = fiat_25519_loose_field_element([0; 5]);\n        fiat_25519_add(&mut output_loose, &square, &square);\n        let mut output = FieldElement51::ZERO;\n        fiat_25519_carry(&mut output.0, &output_loose);\n        output\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/fiat_u64/field.rs",
    "filepath": null,
    "folder_id": 15839,
    "user_id": 460154
  },
  "63628": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2018 Isis Lovecruft, Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Isis Agora Lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! The `u64` backend uses `u64`s and a `(u64, u64) -> u128` multiplier.\n//!\n//! On x86_64, the idiom `(x as u128) * (y as u128)` lowers to `MUL`\n//! instructions taking 64-bit inputs and producing 128-bit outputs.  On\n//! other platforms, this implementation is not recommended.\n//!\n//! On Haswell and newer, the BMI2 extension provides `MULX`, and on\n//! Broadwell and newer, the ADX extension provides `ADCX` and `ADOX`\n//! (allowing the CPU to compute two carry chains in parallel).  These\n//! will be used if available.\n\n#[path = \"../u64/scalar.rs\"]\npub mod scalar;\n\npub mod field;\n\n#[path = \"../u64/constants.rs\"]\npub mod constants;\n\n#[path = \"../u64/subtle_assumes.rs\"]\npub mod subtle_assumes;\n\n#[path = \"../u64/scalar_lemmas.rs\"]\npub mod scalar_lemmas;\n\n#[path = \"../u64/scalar_specs.rs\"]\npub mod scalar_specs;\n\n#[path = \"../u64/common_verus.rs\"]\npub mod common_verus;\n",
    "filename": "curve25519-dalek/src/backend/serial/fiat_u64/mod.rs",
    "filepath": null,
    "folder_id": 15839,
    "user_id": 460154
  },
  "63629": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Serial implementations of field, scalar, point arithmetic.\n//!\n//! When the vector backend is disabled, the crate uses the mixed-model strategy\n//! for implementing point operations and scalar multiplication; see the\n//! [`curve_models`] and [`scalar_mul`] documentation for more information.\n//!\n//! When the vector backend is enabled, the field and scalar\n//! implementations are still used for non-vectorized operations.\n\nuse cfg_if::cfg_if;\n\ncfg_if! {\n    if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        #[doc(hidden)]\n        pub mod fiat_u32;\n\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        #[doc(hidden)]\n        pub mod fiat_u64;\n\n    } else {\n\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        #[doc(hidden)]\n        pub mod u32;\n\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        #[doc(hidden)]\n        pub mod u64;\n\n    }\n}\n\npub mod curve_models;\n\npub mod scalar_mul;\n",
    "filename": "curve25519-dalek/src/backend/serial/mod.rs",
    "filepath": null,
    "folder_id": 15834,
    "user_id": 460154
  },
  "63630": {
    "text": "#![allow(unused)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::prelude::*;\n\nuse vstd::calc_macro::*;\n\n// Placeholder until u128 lemma gets into vstd;\nverus! {\n\nmacro_rules! lemma_pow2_no_overflow {\n    ($name:ident, $uN:ty) => {\n        verus! {\n        pub broadcast proof fn $name(n: nat)\n            requires\n                0 <= n < <$uN>::BITS,\n            ensures\n                0 < #[trigger] pow2(n) < <$uN>::MAX,\n        {\n            lemma_pow2_pos(n);\n            lemma2_to64();\n            lemma2_to64_rest();\n            if (64 < n <= 127) {\n                assert(pow2(127) == pow2(64) * pow2(63)) by {\n                    lemma_pow2_adds(64, 63);\n                }\n                assert(0x8000000000000000 * 0x10000000000000000 < u128::MAX) by (compute);\n                if (n < 127){\n                    lemma_pow2_strictly_increases(n, 127)\n                }\n            }\n        }\n        }\n    };\n}\n\nlemma_pow2_no_overflow!(lemma_u128_pow2_no_overflow, u128);\n\nmacro_rules! lemma_low_bits_mask_is_mod {\n    ($name:ident, $and_split_low_bit:ident, $no_overflow:ident, $uN:ty) => {\n        verus! {\n        pub broadcast proof fn $name(x: $uN, n: nat)\n            requires\n                n < <$uN>::BITS,\n            ensures\n                #[trigger] (x & (low_bits_mask(n) as $uN)) == x % (pow2(n) as $uN),\n            decreases n,\n        {\n            // Bounds.\n            $no_overflow(n);\n            lemma_pow2_pos(n);\n            assert(pow2(0) == 1) by {\n                lemma2_to64();\n            }\n\n            // Inductive proof.\n            if n == 0 {\n                assert(low_bits_mask(0) == 0);\n                assert(x & 0 == 0) by (bit_vector);\n                assert(pow2(0) == 1);\n                assert(x % 1 == 0);\n            } else {\n                lemma_pow2_unfold(n);\n                assert((x % 2) == ((x % 2) & 1)) by (bit_vector);\n                calc!{ (==)\n                    x % (pow2(n) as $uN);\n                        {}\n                    x % ((2 * pow2((n-1) as nat)) as $uN);\n                        {\n                            lemma_pow2_pos((n-1) as nat);\n                            lemma_mod_breakdown(x as int, 2, pow2((n-1) as nat) as int);\n                        }\n                    add(mul(2, (x / 2) % (pow2((n-1) as nat) as $uN)), x % 2);\n                        {\n                            $name(x/2, (n-1) as nat);\n                        }\n                    add(mul(2, (x / 2) & (low_bits_mask((n-1) as nat) as $uN)), x % 2);\n                        {\n                            lemma_low_bits_mask_div2(n);\n                        }\n                    add(mul(2, (x / 2) & (low_bits_mask(n) as $uN / 2)), x % 2);\n                        {\n                            lemma_low_bits_mask_is_odd(n);\n                        }\n                    add(mul(2, (x / 2) & (low_bits_mask(n) as $uN / 2)), (x % 2) & ((low_bits_mask(n) as $uN) % 2));\n                        {\n                            $and_split_low_bit(x as $uN, low_bits_mask(n) as $uN);\n                        }\n                    x & (low_bits_mask(n) as $uN);\n                }\n            }\n        }\n\n        // Helper lemma breaking a bitwise-and operation into the low bit and the rest.\n        proof fn $and_split_low_bit(x: $uN, m: $uN)\n            by (bit_vector)\n            ensures\n                x & m == add(mul(((x / 2) & (m / 2)), 2), (x % 2) & (m % 2)),\n        {\n        }\n        }\n    };\n}\n\nlemma_low_bits_mask_is_mod!(\n    lemma_u128_low_bits_mask_is_mod,\n    lemma_u128_and_split_low_bit,\n    lemma_u128_pow2_no_overflow,\n    u128\n);\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/vstd_u128.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63631": {
    "text": "// field.rs\n#![allow(unused)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::arithmetic::power::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::prelude::*;\n\nuse super::common_verus::*;\nuse super::field_lemmas::*;\nuse super::vstd_u128::*;\n\n// ADAPTED CODE LINES: X.0 globally replaced with X.limbs\n\nverus! {\n\n/* MANUALLY moved outside and made explicit */\n// LOW_51_BIT_MASK: u64 = (1u64 << 51) -1; originally\npub const LOW_51_BIT_MASK: u64 = 2251799813685247u64; // 2^51  -1\n\n// Basic properties of LOW_51_BIT_MASK:\n// - It's the value of low_bits_mask (spec function defined in vstd and used in its lemmas)\n// - it's less than 2^51\npub proof fn l51_bit_mask_lt()\n    ensures\n        LOW_51_BIT_MASK == low_bits_mask(51),\n        LOW_51_BIT_MASK < (1u64 << 51) as nat,\n{\n    lemma2_to64_rest();\n    assert(LOW_51_BIT_MASK < (1u64 << 51) as nat) by (compute);\n}\n\n// Masking with low_bits_mask(51) gives a value bounded by 2^51\npub proof fn masked_lt_51(v: u64)\n    ensures\n        v & LOW_51_BIT_MASK < (1u64 << 51),\n{\n    l51_bit_mask_lt(); // LOW_51_BIT_MASK == low_bits_mask(51)\n    masked_lt(v, 51);\n}\n\n// lemma_div_and_mod specialization for k = 51, using LOW_51_BIT_MASK == low_bits_mask(51)\npub proof fn lemma_div_and_mod_51(ai:u64, bi: u64, v: u64)\n    requires\n        ai == v >> 51,\n        bi == v & LOW_51_BIT_MASK\n    ensures\n        ai == v / (pow2(51) as u64),\n        bi == v % (pow2(51) as u64),\n        v == ai * pow2(51) + bi\n{\n    l51_bit_mask_lt(); // LOW_51_BIT_MASK == low_bits_mask(51)\n    lemma_div_and_mod(ai, bi, v, 51);\n}\n\npub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & LOW_51_BIT_MASK]\n        (x as u64) & LOW_51_BIT_MASK == x & (LOW_51_BIT_MASK as u128)\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}\n\npub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5]) {\n    let r = [\n        ((limbs[0] & LOW_51_BIT_MASK) + (limbs[4] >> 51) * 19) as u64,\n        ((limbs[1] & LOW_51_BIT_MASK) + (limbs[0] >> 51)) as u64,\n        ((limbs[2] & LOW_51_BIT_MASK) + (limbs[1] >> 51)) as u64,\n        ((limbs[3] & LOW_51_BIT_MASK) + (limbs[2] >> 51)) as u64,\n        ((limbs[4] & LOW_51_BIT_MASK) + (limbs[3] >> 51)) as u64,\n    ];\n    r\n}\n\n// Each component of spec_reduce is bounded.\n// The reason we _don't_ write\n// ensures forall |i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52)\n// is that the solver treats `spec_reduce`` above as symbolic and does _not_ instantiate e.g.\n// ((limbs[4] & LOW_51_BIT_MASK) + (limbs[3] >> 51)) as u64 < (1u64 << 52)\npub proof fn lemma_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & LOW_51_BIT_MASK) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & LOW_51_BIT_MASK) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & LOW_51_BIT_MASK) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & LOW_51_BIT_MASK) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & LOW_51_BIT_MASK) + (limbs[3] >> 51)) < (1u64 << 52)\n\n{\n    // \\A i. limbs[i] < 2^13\n    shifted_lt(limbs[0], 51);\n    shifted_lt(limbs[1], 51);\n    shifted_lt(limbs[2], 51);\n    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & LOW_51_BIT_MASK < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}\n\npub proof fn lemma_reduce(limbs: [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52),\n        // Suppose l = (l0, l1, l2, l3, l4) are the input limbs.\n        // They represent a number\n        // e(l) =  l0 + l1 * 2^51 + l2 * 2^102 + l3 * 2^153 + l4 * 2^204\n        // in Z_p, for p = 2^255 - 19\n        // reduce(l) returns v = (v0, v1, v2, v3, v4), such that\n        // v0 = 19 * a4 + b0\n        // v1 =      a0 + b1\n        // v2 =      a1 + b2\n        // v3 =      a2 + b3\n        // v4 =      a3 + b4\n        // where ai = li >> 51 and bi = li & LOW_51_BIT_MASK\n        // we can reformulate this as ai = li / 2^51 (flooring division) and bi = li % 2^51\n        // Using the following identity connecting integer division and remainder:\n        // x = y * (x / y) + x % y\n        // we can see that li = ai * 2^51 + bi\n        // Plugging the above identities into the equations for v, we can observe that\n        // e(v) = e(l) - p * (l4 >> 51)\n        // IOW, e(reduce(l)) = e(l) (mod p)\n        // additionally, if all limbs are below 2^51, reduce(l) = l\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (spec_reduce(limbs) =~= limbs),\n        as_nat(spec_reduce(limbs)) == as_nat(limbs) - p() * (limbs[4] >> 51)\n{\n\n    // -----\n    // reduce identity for small limbs\n\n    // Can't seem to reference r within this proof block, we reconstruct it here\n    let rr: [u64; 5] = spec_reduce(limbs);\n\n    assert((forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) ==> (rr =~= limbs)) by {\n        if (forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) {\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] & LOW_51_BIT_MASK == limbs[i] by {\n                l51_bit_mask_lt(); // LOW_51_BIT_MASK = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_low_bits_mask_is_mod(limbs[i], 51);\n                lemma_small_mod(limbs[i] as nat, pow2(51));\n            }\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] >> 51 == 0 by {\n                l51_bit_mask_lt(); // LOW_51_BIT_MASK = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_shr_is_div(limbs[i], 51);\n                lemma_basic_div(limbs[i] as int, pow2(51) as int);\n            }\n        }\n    }\n\n    // -- as_nat identity\n\n    // ai = limbs[i] / 2^52\n    let a0 = (limbs[0] >> 51);\n    let a1 = (limbs[1] >> 51);\n    let a2 = (limbs[2] >> 51);\n    let a3 = (limbs[3] >> 51);\n    let a4 = (limbs[4] >> 51);\n\n    // bi = limbs[i] % 2^52\n    let b0 = (limbs[0] & LOW_51_BIT_MASK);\n    let b1 = (limbs[1] & LOW_51_BIT_MASK);\n    let b2 = (limbs[2] & LOW_51_BIT_MASK);\n    let b3 = (limbs[3] & LOW_51_BIT_MASK);\n    let b4 = (limbs[4] & LOW_51_BIT_MASK);\n\n    lemma_boundaries(limbs);\n\n    // distribute\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(102) * a1 + pow2(102) * b2 +\n        pow2(153) * a2 + pow2(153) * b3 +\n        pow2(204) * a3 + pow2(204) * b4\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n    }\n\n    // factor out\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(51) * (pow2(51) * a1) + pow2(102) * b2 +\n        pow2(102) * (pow2(51) * a2) + pow2(153) * b3 +\n        pow2(153) * (pow2(51) * a3) + pow2(204) * b4\n    ) by {\n        lemma_two_factoring_51(51, a1);\n        lemma_two_factoring_51(102, a2);\n        lemma_two_factoring_51(153, a3);\n    }\n\n    // change groupings\n    assert(as_nat(rr) ==\n        (b0 + pow2(51) * a0) +\n        pow2(51) * (b1 + pow2(51) * a1) +\n        pow2(102) * (b2 + pow2(51) * a2) +\n        pow2(153) * (b3 + pow2(51) * a3) +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n    }\n\n    // invoke div/mod identity\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a0, b0, limbs[0]);\n        lemma_div_and_mod_51(a1, b1, limbs[1]);\n        lemma_div_and_mod_51(a2, b2, limbs[2]);\n        lemma_div_and_mod_51(a3, b3, limbs[3]);\n    }\n\n    // Add missing limbs[4] parts\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * limbs[4] - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a4, b4, limbs[4]);\n        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204)* (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }\n    }\n\n    // The solver can collect components of as_nat(limbs) automatically:\n    // as_nat(rr) == as_nat(limbs) - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    // ... as well as pull in minus\n    // as_nat(rr) == as_nat(limbs) - (pow2(204) * (pow2(51) * a4 ) - 19 * a4)\n\n    // collect components of p() * a4\n    assert(pow2(204) * (pow2(51) * a4) - 19 * a4 == p() * a4) by {\n        lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, a4 as int);\n        lemma_pow2_adds(204, 51);\n        lemma_mul_is_distributive_sub_other_way(a4 as int, pow2(255) as int, 19 );\n        pow255_gt_19(); // we need to prove 2^255 - 19 doesn't underflow\n    }\n}\n\n/* MANUALLY moved outside, named return value */\nconst fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        0 <= r <= (u64::MAX as nat),\n{\n        (input[i] as u64)\n    | ((input[i + 1] as u64) << 8)\n    | ((input[i + 2] as u64) << 16)\n    | ((input[i + 3] as u64) << 24)\n    | ((input[i + 4] as u64) << 32)\n    | ((input[i + 5] as u64) << 40)\n    | ((input[i + 6] as u64) << 48)\n    | ((input[i + 7] as u64) << 56)\n}\n\n/* MANUALLY moved outside */\n#[inline(always)]\nfn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX\n\n{\n    proof {\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}\n\npub struct FieldElement51 {\n    // ADAPTED CODE LINE: we give a name to the field: \"limbs\"\n    pub limbs: [u64; 5],\n}\n\nimpl FieldElement51 {\n    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }\n\n    // Modified to use direct struct\n    pub const ZERO: FieldElement51 = FieldElement51{limbs: [0, 0, 0, 0, 0]};\n    pub const ONE: FieldElement51 = FieldElement51{limbs: [1, 0, 0, 0, 0]};\n    pub const MINUS_ONE: FieldElement51 = FieldElement51{limbs: [\n        2251799813685228,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n    ]};\n\n    /// Invert the sign of this field element\n    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, as_nat((c0, c, c, c, c)) = p, so\n            // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n            // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            as_nat(self.limbs) == 16 * p() - as_nat(old(self).limbs) - p() * ((36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n            (as_nat(self.limbs) + as_nat(old(self).limbs)) % p() == 0\n    {\n        proof {\n            let c0 = (pow2(51) - 19);\n            let c  = (pow2(51) - 1);\n            lemma2_to64_rest(); // get pow2(51)\n            // solver knows 36028797018963664u64 == 16 * c0\n            // solver knows 36028797018963952u64 == 16 * c;\n\n            assert forall |i: int| 0 <= i < 5 implies old(self).limbs[i] < 16 * c0 by {\n                shift_is_pow2(51);\n            }\n\n            // Introduce 16p as a vector\n            let v = [(16 * c0) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64];\n\n            assert(as_nat(v) == 16 * p()) by {\n                // by definition of as_nat\n                assert( as_nat(v) ==\n                    16 * c0 +\n                    pow2(51) * (16 * c) +\n                    pow2(102) * (16 * c) +\n                    pow2(153) * (16 * c) +\n                    pow2(204) * (16 * c)\n                );\n\n                // solver can reorder factors and pull out 16 on its own\n                // ...\n\n                // Write out `c`s and sum up powers\n                assert( p() ==\n                    c0 +\n                    pow2(51) * c +\n                    pow2(102) * c +\n                    pow2(153) * c +\n                    pow2(204) * c\n                ) by {\n                    lemma_pow2_adds(51, 51);\n                    lemma_pow2_adds(51, 102);\n                    lemma_pow2_adds(51, 153);\n                    lemma_pow2_adds(51, 204);\n                }\n            }\n\n            let l0 = old(self).limbs[0];\n            let l1 = old(self).limbs[1];\n            let l2 = old(self).limbs[2];\n            let l3 = old(self).limbs[3];\n            let l4 = old(self).limbs[4];\n\n            assert(as_nat([\n                (16 * c0 - l0) as u64,\n                (16 * c - l1) as u64,\n                (16 * c - l2) as u64,\n                (16 * c - l3) as u64,\n                (16 * c - l4) as u64,\n                ]) == as_nat(v) - as_nat(old(self).limbs)\n            ) by {\n                lemma_as_nat_sub(v, old(self).limbs);\n            }\n        }\n        // See commentary in the Sub impl: (copied below)\n            // To avoid underflow, first add a multiple of p.\n            // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n            //\n            // If we could statically track the bitlengths of the limbs\n            // of every FieldElement51, we could choose a multiple of p\n            // just bigger than _rhs and avoid having to do a reduction.\n            //\n            // Since we don't yet have type-level integers to do this, we\n            // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.limbs[0],\n            36028797018963952u64 - self.limbs[1],\n            36028797018963952u64 - self.limbs[2],\n            36028797018963952u64 - self.limbs[3],\n            36028797018963952u64 - self.limbs[4],\n        ]);\n        proof {\n            let k = ((36028797018963952u64 - old(self).limbs[4]) as u64 >> 51) as nat;\n            broadcast use lemma_mul_is_distributive_sub;\n            lemma_mod_multiples_vanish((16 - k) as int, 0 as int, p() as int);\n        }\n        self.limbs = neg.limbs;\n    }\n\n    /// Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).\n    #[inline(always)]\n    fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n        ensures\n            r.limbs == spec_reduce(limbs),\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n            (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n            as_nat(r.limbs) == as_nat(limbs) - p() * (limbs[4] >> 51),\n            as_nat(r.limbs) % p() == as_nat(limbs) % p()\n    {\n        proof {\n            lemma_boundaries(limbs);\n            lemma_reduce(limbs);\n            pow255_gt_19();\n            lemma_mod_multiples_vanish((limbs[4] >> 51) as int, as_nat(spec_reduce(limbs)) as int, p() as int);\n        }\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }\n\n    /// Load a `FieldElement51` from the low 255 bits of a 256-bit\n    /// input.\n    ///\n    /// # Warning\n    ///\n    /// This function does not check that the input used the canonical\n    /// representative.  It masks the high bit, but it will happily\n    /// decode 2^255 - 18 to 1.  Applications that require a canonical\n    /// encoding of every field element should decode, re-encode to\n    /// the canonical encoding, and check that the input was\n    /// canonical.\n    ///\n    #[rustfmt::skip] // keep alignment of bit shifts\n    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)\n        ensures\n            true\n            // TODO:\n            // as_nat(r.limbs) =?= as_nat_32_u8(bytes)\n    {\n        proof {\n            l51_bit_mask_lt() // No over/underflow in the below let-def\n        }\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{ limbs:\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ]}\n    }\n\n    /// Serialize this `FieldElement51` to a 32-byte array.  The\n    /// encoding is canonical.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_bytes(self) -> (r: [u8; 32])\n        ensures\n            true // No overflow\n            // TODO:\n            // as_nat(self.limbs) =?= as_nat_32_u8(r),\n            // canonical encoding\n            // forall|i: int| 0 <= i < 5 ==> r[i] < (1u64 << 51)\n    {\n        proof {\n            let l = spec_reduce(self.limbs);\n            lemma_reduce(self.limbs);\n\n            let q0 = (l[0] + 19) as u64 >> 51;\n            let q1 = (l[1] + q0) as u64 >> 51;\n            let q2 = (l[2] + q1) as u64 >> 51;\n            let q3 = (l[3] + q2) as u64 >> 51;\n            let q4 = (l[4] + q3) as u64 >> 51;\n\n            assert(19 < (1u64 << 52)) by (bit_vector);\n            lemma_add_then_shift(l[0], 19);\n            lemma_add_then_shift(l[1], q0);\n            lemma_add_then_shift(l[2], q1);\n            lemma_add_then_shift(l[3], q2);\n            lemma_add_then_shift(l[4], q3);\n\n            let l0 = (l[0] + 19 * q4) as u64;\n            let l1 = (l[1] + (l0 >> 51)) as u64;\n            let l2 = (l[2] + (l1 >> 51)) as u64;\n            let l3 = (l[3] + (l2 >> 51)) as u64;\n            let l4 = (l[3] + (l3 >> 51)) as u64;\n\n            assert( 19 * q4 < 1u64 << 7) by {\n                // Explicit values for pow2(k) for k < 64\n                lemma2_to64();\n                shift_is_pow2(5); // now we know 19 < 1u64 << 5 for free\n                shift_is_pow2(2);\n                shift_is_pow2(7);\n                lemma_pow2_adds(5, 2);\n            }\n            assert(((1u64 << 7)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            assert(((1u64 << 13)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            shifted_lt(l0, 51);\n            shifted_lt(l1, 51);\n            shifted_lt(l2, 51);\n            shifted_lt(l3, 51);\n\n            l51_bit_mask_lt();\n\n            // TODO\n            // let rr = [\n            //     l0 & LOW_51_BIT_MASK,\n            //     l1 & LOW_51_BIT_MASK,\n            //     l2 & LOW_51_BIT_MASK,\n            //     l3 & LOW_51_BIT_MASK,\n            //     l4 & LOW_51_BIT_MASK\n            // ];\n\n            // let r = [\n            //     rr[0]                           as u8,\n            //     (rr[0] >>  8)                    as u8,\n            //     (rr[0] >> 16)                    as u8,\n            //     (rr[0] >> 24)                    as u8,\n            //     (rr[0] >> 32)                    as u8,\n            //     (rr[0] >> 40)                    as u8,\n            //     ((rr[0] >> 48) | (rr[1] << 3)) as u8,\n            //     (rr[1] >>  5)                    as u8,\n            //     (rr[1] >> 13)                    as u8,\n            //     (rr[1] >> 21)                    as u8,\n            //     (rr[1] >> 29)                    as u8,\n            //     (rr[1] >> 37)                    as u8,\n            //     ((rr[1] >> 45) | (rr[2] << 6)) as u8,\n            //     (rr[2] >>  2)                    as u8,\n            //     (rr[2] >> 10)                    as u8,\n            //     (rr[2] >> 18)                    as u8,\n            //     (rr[2] >> 26)                    as u8,\n            //     (rr[2] >> 34)                    as u8,\n            //     (rr[2] >> 42)                    as u8,\n            //     ((rr[2] >> 50) | (rr[3] << 1)) as u8,\n            //     (rr[3] >>  7)                    as u8,\n            //     (rr[3] >> 15)                    as u8,\n            //     (rr[3] >> 23)                    as u8,\n            //     (rr[3] >> 31)                    as u8,\n            //     (rr[3] >> 39)                    as u8,\n            //     ((rr[3] >> 47) | (rr[4] << 4)) as u8,\n            //     (rr[4] >>  4)                    as u8,\n            //     (rr[4] >> 12)                    as u8,\n            //     (rr[4] >> 20)                    as u8,\n            //     (rr[4] >> 28)                    as u8,\n            //     (rr[4] >> 36)                    as u8,\n            //     (rr[4] >> 44)                    as u8\n            // ];\n\n        }\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.limbs).limbs;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n        // debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }\n\n    /// Given `k > 0`, return `self^(2^k)`.\n    #[rustfmt::skip] // keep alignment of c* calculations\n    pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n        requires\n            k > 0, // debug_assert!( k > 0 );\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54 // 51 + b for b = 3\n        ensures\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(k as nat)) as nat % p(),\n    {\n        let mut a: [u64; 5] = self.limbs;\n\n        // pre-loop invariant, i = 0\n        proof {\n            assert(as_nat(a) == pow(as_nat(self.limbs) as int, pow2(0))) by {\n                lemma2_to64(); // pow2(0) = 1\n                lemma_pow1(as_nat(self.limbs) as int);\n            }\n        }\n\n        for i in 0..k\n            invariant\n                forall |i: int| 0 <= i < 5 ==> a[i] < 1u64 << 54,\n                as_nat(a) % p() == pow(as_nat(self.limbs) as int, pow2(i as nat)) as nat % p(),\n        {\n            proof {\n                pow255_gt_19(); // p > 0\n                lemma2_to64_rest(); // pow2(51 | 54)\n                shift_is_pow2(54);\n\n                let bound = 1u64 << 54;\n                let bound19 = (19 * bound) as u64;\n                let bound_sq = 1u128 << 108;\n                // u64 to u128 conversion forces extra assert\n                assert( (1u64 << 54) * ((19 * (1u64 << 54)) as u64) == 19 * (1u128 << 108)) by (bit_vector);\n\n                // bv arithmetic\n                assert(19 < (1u64 << 5)) by (bit_vector);\n                assert((1u64 << 51) < (1u64 << 52)) by (bit_vector);\n                assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 54) < (1u64 << 59)) by (bit_vector);\n                assert((1u64 << 54) * (1u64 << 5) == (1u64 << 59)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 54) as u128) == (1u128 << 108)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 59) as u128) == (1u128 << 113)) by (bit_vector);\n\n                let a3_19 = (19 * a[3]) as u64;\n                let a4_19 = (19 * a[4]) as u64;\n\n                // c0\n                let c0_0: u128 = (a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19)) as u128;\n                lemma_m(a[0], a[0], bound, bound);\n                lemma_m(a[1], a4_19, bound, bound19);\n                lemma_m(a[2], a3_19, bound, bound19);\n                // conclusion, (1 + 2 * (19 + 19)) = 77\n                assert(c0_0 < 77 * bound_sq);\n\n                // c1\n                let c1_0: u128 = (a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)) as u128;\n                lemma_m(a[3], a3_19, bound, bound19);\n                lemma_m(a[0],  a[1], bound, bound);\n                lemma_m(a[2], a4_19, bound, bound19);\n                // conclusion, (19 + 2 * (1 + 19)) = 59\n                assert(c1_0 < 59 * bound_sq);\n\n                // c2\n                let c2_0: u128 = (a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19)) as u128;\n                lemma_m(a[1],  a[1], bound, bound);\n                lemma_m(a[0],  a[2], bound, bound);\n                lemma_m(a[4], a3_19, bound, bound19);\n                // conclusion, (1 + 2 * (1 + 19)) = 41\n                assert(c2_0 < 41 * bound_sq);\n\n                // c3\n                let c3_0: u128 = (a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2])) as u128;\n                lemma_m(a[4], a4_19, bound, bound19);\n                lemma_m(a[0],  a[3], bound, bound);\n                lemma_m(a[1],  a[2], bound, bound);\n                // conclusion, (19 + 2 * (1 + 1)) = 23\n                assert(c3_0 < 23 * bound_sq);\n\n                // c4\n                let c4_0: u128 = (a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3])) as u128;\n                lemma_m(a[2],  a[2], bound, bound);\n                lemma_m(a[0],  a[4], bound, bound);\n                lemma_m(a[1],  a[3], bound, bound);\n                // conclusion, (1 + 2 * (1 + 1)) = 5\n                assert(c4_0 < 5 * bound_sq);\n\n                assert( 77 * bound_sq <= ((u64::MAX as u128) << 51)) by (compute); // all ci_0 are then < MAX << 51\n\n                lemma_shr_51_fits_u64(c0_0);\n\n                let c1 = (c1_0 + ((c0_0 >> 51) as u64) as u128) as u128;\n                let a0_0 = (c0_0 as u64) & LOW_51_BIT_MASK;\n\n                lemma_shr_51_fits_u64(c1);\n                // a0_0 < (1u64 << 51)\n                masked_lt_51(c0_0 as u64);\n\n                let c2 = (c2_0 + ((c1 >> 51) as u64) as u128) as u128;\n                let a1_0 = (c1 as u64) & LOW_51_BIT_MASK;\n\n                lemma_shr_51_fits_u64(c2);\n                // a1_0 < (1u64 << 51)\n                masked_lt_51(c1 as u64);\n\n                let c3 = (c3_0 + ((c2 >> 51) as u64) as u128) as u128;\n                let a2 = (c2 as u64) & LOW_51_BIT_MASK;\n\n                lemma_shr_51_fits_u64(c3);\n                // a2 < (1u64 << 51)\n                masked_lt_51(c2 as u64);\n\n                let c4 = (c4_0 + ((c3 >> 51) as u64) as u128) as u128;\n                let a3 = (c3 as u64) & LOW_51_BIT_MASK;\n\n                lemma_shr_51_fits_u64(c4);\n                // a3 < (1u64 << 51)\n                masked_lt_51(c3 as u64);\n\n                let carry: u64 = (c4 >> 51) as u64;\n                let a4 = (c4 as u64) & LOW_51_BIT_MASK;\n\n                // a4 < (1u64 << 51)\n                masked_lt_51(c4 as u64);\n\n                assert(c4 <= c4_0 + (u64::MAX as u128));\n                lemma_shr_51_le(c4, (5 * bound_sq + (u64::MAX as u128)) as u128 );\n\n                // From the comments below:\n                // c4 < 2^110.33  so that carry < 2^59.33\n                // and\n                // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n\n                // ceil(2^59.33)\n                let pow2_5933 = 724618875532318195u64;\n\n                assert((5 * (1u128 << 108) + (u64::MAX as u128)) as u128 >> 51 < (pow2_5933 as u128)) by (compute);\n                assert(carry < pow2_5933);\n\n                // a[0] += carry * 19 fits in u64\n                assert((1u64 << 51) + 19 * pow2_5933 <= u64::MAX) by (compute);\n                let a0_1 = (a0_0 + carry * 19) as u64;\n\n                lemma_shr_51_le(a0_1 as u128, u64::MAX as u128);\n                assert( ((u64::MAX as u128) >> 51) < (1u64 << 13) ) by (compute);\n\n                // a1_0 < (1u64 << 51)\n                assert((1u64 << 51) + (1u64 << 13) < (1u64 << 52)) by (compute);\n\n                // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n                assert(a1_0 + (a0_1 >> 51) < (1u64 << 52));\n                let a1_1 = (a1_0 + (a0_1 >> 51)) as u64;\n\n                let a0_2 = a0_1 & LOW_51_BIT_MASK;\n                // a0_2 < (1u64 << 51)\n                masked_lt_51(a0_1 as u64);\n\n                //---- end of no-overflow proof ----\n                // Loop invariant: after i loops we have as_nat(a) % p = as_nat(self.limbs) ^ (2 ^ i) % p\n                let a_hat = [a0_2, a1_1, a2, a3, a4];\n                assert(as_nat(a_hat) % p() == (as_nat(a) * as_nat(a)) % p() ) by {\n                    // it suffices to prove as_nat(a_hat) == (as_nat(a))^2 (mod p)\n                    // let s = pow2(51) for brevity\n\n                    // By definition, as_nat(a_hat) = a0_2 + s * a1_1 + s^2 * a2 + s^3 * a3 + s^4 * a4\n                    // a0_2 + s * a1_1 cancel out terms via the div/mod identity:\n                    assert(as_nat(a_hat) ==\n                        a0_1 +\n                        pow2(51) * a1_0 +\n                        pow2(102) * a2 +\n                        pow2(153) * a3 +\n                        pow2(204) * a4\n                    ) by {\n                        // a0_2 + s * a1_1 =\n                        // a0_1 % s  + s * (a1_0 + s * (a0_1 / s)) =\n                        // s * a1_0 + [s * (a0_1 / s) + a0_1 % s] = (by the div-mod identity)\n                        // s * a1_0 + a0_1\n                        assert(a0_2 + pow2(51) * a1_1 == a0_1 + pow2(51) * a1_0) by {\n                            lemma_div_and_mod_51((a0_1 >> 51), a0_2, a0_1);\n                        }\n                    }\n\n                    // Next, we replace all _ & LOW_BITS_MASK with (mod s)\n                    assert(as_nat(a_hat) ==\n                        ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry +\n                        pow2( 51) * ((c1 as u64) % (pow2(51) as u64)) +\n                        pow2(102) * ((c2 as u64) % (pow2(51) as u64)) +\n                        pow2(153) * ((c3 as u64) % (pow2(51) as u64)) +\n                        pow2(204) * ((c4 as u64) % (pow2(51) as u64))\n                    ) by {\n                        // TODO: we need lemma_u128_low_bits_mask_is_mod in vstd!\n                        broadcast use lemma_cast_then_mask_51;\n                        broadcast use lemma_u128_low_bits_mask_is_mod;\n                        l51_bit_mask_lt();\n                    }\n\n                    // We can see all mod operations in u128\n                    assert(as_nat(a_hat) ==\n                        (c0_0 % (pow2(51) as u128)) + 19 * carry +\n                        pow2( 51) * (c1 % (pow2(51) as u128)) +\n                        pow2(102) * (c2 % (pow2(51) as u128)) +\n                        pow2(153) * (c3 % (pow2(51) as u128)) +\n                        pow2(204) * (c4 % (pow2(51) as u128))\n                    ) by {\n                        // pow2(51) is the same in u64 and 128\n                        lemma_cast_then_mod_51(c0_0);\n                        lemma_cast_then_mod_51(c1);\n                        lemma_cast_then_mod_51(c2);\n                        lemma_cast_then_mod_51(c3);\n                        lemma_cast_then_mod_51(c4);\n                    }\n\n                    // Next, we categorically replace a % s with a - s * ( a / s )\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c0_0 / (pow2(51) as u128))) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c1/ (pow2(51) as u128))) +\n                        pow2(102) * (c2 - pow2(51) * (c2/ (pow2(51) as u128))) +\n                        pow2(153) * (c3 - pow2(51) * (c3/ (pow2(51) as u128))) +\n                        pow2(204) * (c4 - pow2(51) * (c4/ (pow2(51) as u128)))\n                    ) by {\n                        broadcast use lemma_fundamental_div_mod;\n                    }\n\n                    // Then, we know that\n                    // carry = c4/s\n                    // c4 = c4_0 + c3/s <=> c3/s = c4 - c4_0\n                    // c3 = c3_0 + c2/s <=> c2/s = c3 - c3_0\n                    // c2 = c2_0 + c1/s <=> c1/s = c2 - c2_0\n                    // c1 = c1_0 + c0_0/s <=> c0_0/s = c1 - c1_0\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c1 - c1_0)) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) +\n                        pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) +\n                        pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) +\n                        pow2(204) * (c4 - pow2(51) * carry)\n                    ) by {\n                        broadcast use lemma_u128_shr_is_div;\n                    }\n\n                    // Now we use distributivity and pow exponent sums, which cancels out any ci terms and leaves only ci_0 terms\n                    // Conveniently, we're left with a difference of c * p\n                    assert(as_nat(a_hat) ==\n                        c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0 -\n                        p() * carry\n                    ) by {\n                        broadcast use lemma_mul_is_associative;\n                        broadcast use lemma_mul_is_distributive_sub;\n\n                        lemma_pow2_adds(51, 51);\n                        lemma_pow2_adds(51, 102);\n                        lemma_pow2_adds(51, 153);\n                        lemma_pow2_adds(51, 204);\n\n                        // carry on the right, get p\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n                        pow255_gt_19();\n                    }\n\n                    let c_arr_as_nat = (c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0\n                        );\n\n\n                    assert(as_nat(a_hat) % p() == c_arr_as_nat as nat % p()) by {\n                        lemma_mod_diff_factor(carry as int, c_arr_as_nat as int, p() as int);\n                    }\n\n                    // We use the as_nat_squared lemma to see what (as_nat(a)^2) evaluates to (mod p)\n\n                    // The nat_squared lemma gives us the following:\n                    // as_nat(a) * as_nat(a) ==\n                    // pow2(8 * 51) * (a[4] * a[4]) +\n                    // pow2(7 * 51) * (2 * (a[3] * a[4])) +\n                    // pow2(6 * 51) * (a[3] * a[3] + 2 * (a[2] * a[4])) +\n                    // pow2(5 * 51) * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])) +\n                    // pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    // pow2(3 * 51) * (2 * (a[1] * a[2]) + 2 * (a[0] * a[3])) +\n                    // pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] * a[2])) +\n                    // pow2(1 * 51) * (2 * (a[0] * a[1])) +\n                    //                (a[0] * a[0])\n                    //\n                    // AND\n                    //\n                    // (as_nat(a) * as_nat(a)) % p() ==\n                    // (\n                    //     pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    //     pow2(3 * 51) * (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])) +\n                    //     pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))) +\n                    //     pow2(1 * 51) * (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))) +\n                    //                    (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))\n                    // ) as nat % p()\n                    as_nat_squared(a);\n\n                    // We're basically done, what remains is to prove that the coefficients next to pow2(i * 51)\n                    // are exactly ci_0s (via distributivity and associativity)\n\n                    // let c0_0: u128 = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                    assert(c0_0 == (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))) by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                        //     = a[0] *  a[0] + 2*( a[1] * a4_19 ) + 2 * (a[2] * a3_19);\n                        // RHS = a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))\n                        //     = a[0] *  a[0] + 19 * (2 * (a[2] * a[3])) + 19 * (2 * (a[1] * a[4]))\n\n                        // goals\n                        // 1) 2 * (a[1] * a4_19) = 19 * (2 * (a[1] * a[4]))\n                        // 2) 2 * (a[2] * a3_19) = 19 * (2 * (a[2] * a[3]))\n\n                        assert(2*(a[1] * a4_19) == 19 * (2 * (a[1] * a[4]))) by {\n                            lemma_reorder_mul(a[1] as int, a[4] as int);\n                        }\n\n                        assert(2*(a[2] * a3_19) == 19 * (2 * (a[2] * a[3]))) by {\n                            lemma_reorder_mul(a[2] as int, a[3] as int);\n                        }\n                    }\n\n                    // let c1_0: u128 = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19);\n                    assert(c1_0 == (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)\n                        //     = a[3] * a3_19 + 2*( a[0] *  a[1]) + 2 * (a[2] * a4_19)\n                        // RHS = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))\n                        //     = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3]) + 19 * (2 * (a[2] * a[4]))\n\n                        // goals: 1) a[3] * a3_19 = 19 * (a[3] * a[3])\n                        //        2) 2 * (a[2] * a4_19) = 19 * (2 * (a[2] * a[4]))\n\n                        assert(a[3] * a3_19 == 19 * (a[3] * a[3])) by {\n                            lemma_mul_is_associative(a[3] as int, a[3] as int, 19);\n                        }\n\n                        assert(2*(a[2] * a4_19) == 19 * (2 * (a[2] * a[4]))) by {\n                            lemma_reorder_mul(a[2] as int, a[4] as int);\n                        }\n                    }\n\n                    // let c2_0: u128 = a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19);\n                    assert(c2_0 == (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[1] * a[1] + 2 * (a[0] *  a[2] + a[4] * a3_19)\n                        //     = a[1] * a[1] + 2 * (a[0] *  a[2]) +  2 * (a[4] * a3_19)\n                        // RHS = a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))\n\n                        // goals: 2 * (a[4] * a3_19) = 19 * (2 * (a[3] * a[4]))\n\n                        assert(2 * (a[4] * a3_19) == 19 * (2 * (a[3] * a[4]))) by {\n                            lemma_mul_is_associative(a[4] as int, a[3] as int, 19);\n                        }\n                    }\n\n                    // let c3_0: u128 = a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]);\n                    assert(c3_0 == (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[4] * a4_19 + 2 * (a[0] *  a[3] + a[1] *  a[2])\n                        //     = a[4] * a4_19 + 2 * (a[0] *  a[3]) + 2 * (a[1] *  a[2])\n                        // RHS = 2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])\n\n                        // goals: a[4] * a4_19 = 19 * (a[4] * a[4])\n\n                        assert(a[4] * a4_19 == 19 * (a[4] * a[4])) by {\n                            lemma_mul_is_associative(a[4] as int, a[4] as int, 19);\n                        }\n                    }\n\n                    // let c4_0: u128 = a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]);\n                    assert(c4_0 == (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])\n                        //     = a[2] * a[2] + 2 * (a[0] * a[4]) + 2 * (a[1] * a[3])\n                        // RHS = a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])\n\n                        // goals: none\n                    }\n                }\n\n                let a_pow_2i_int = pow(as_nat(self.limbs) as int, pow2(i as nat));\n                assert(a_pow_2i_int >= 0) by {\n                    lemma_pow_nat_is_nat(as_nat(self.limbs), i as nat);\n                }\n                let a_pow_2i: nat = a_pow_2i_int as nat;\n\n                assert(as_nat(a_hat) % p() ==\n                    ((as_nat(a) % p()) * (as_nat(a) % p())) % p()\n                ) by {\n                    lemma_mul_mod_noop(as_nat(a) as int, as_nat(a) as int, p() as int);\n                }\n\n                // (a_pow_2i % p)^2 % p = (a_pow_2i^2) % p\n                lemma_mul_mod_noop(a_pow_2i as int, a_pow_2i as int, p() as int);\n\n                // We know, by the loop inv, that\n                // as_nat(a) % p == a_pow_2i % p\n                // and, by the above\n                // as_nat(a_hat) % p  = (as_nat(a) * as_nat(a)) % p = (a_pow_2i ^ 2)) % p\n                // It suffices to prove that\n                // (v^(2^i))^2 = v^(2^(i + 1))\n                lemma_pow2_square(as_nat(self.limbs) as int, i as nat);\n            }\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n            // debug_assert!(a[0] < (1 << 54));\n            // debug_assert!(a[1] < (1 << 54));\n            // debug_assert!(a[2] < (1 << 54));\n            // debug_assert!(a[3] < (1 << 54));\n            // debug_assert!(a[4] < (1 << 54));\n\n            // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n        }\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs: a}\n    }\n\n    /// Returns the square of this field element.\n    pub fn square(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            // TODO\n            // as_nat(square(x)) = as_nat(x) * as_nat(x)\n            true\n\n    {\n        self.pow2k(1)\n    }\n\n    /// Returns 2 times the square of this field element.\n    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            // TODO\n            // as_nat(square2(x)) = 2 * as_nat(x) * as_nat(x)\n            true\n    {\n        let mut square = self.pow2k(1);\n        for i in 0..5 {\n            proof {\n                assume(false);\n            }\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }\n}\n\nfn main()\n{}\n\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63632": {
    "text": "#![allow(unused)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::arithmetic::power::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// Auxiliary lemma for multiplication (of nat!)\npub proof fn mul_lt(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 < b1,\n        a2 < b2,\n    ensures\n        a1 * a2 < b1 * b2,\n{\n    if (a2 == 0) {\n        assert(b1 * b2 > 0) by {\n            // a * b != 0 <==> a != 0 /\\ b != 0\n            lemma_mul_nonzero(b1 as int, b2 as int);\n        }\n    }\n    else {\n        // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n        lemma_mul_strict_inequality(a1 as int, b1  as int, a2 as int);\n        // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n        lemma_mul_strict_inequality(a2 as int, b2 as int, b1 as int);\n    }\n}\n\npub proof fn mul_le(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 <= b1,\n        a2 <= b2,\n    ensures\n        a1 * a2 <= b1 * b2,\n{\n    // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n    lemma_mul_inequality(a1 as int, b1  as int, a2 as int);\n    // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n    lemma_mul_inequality(a2 as int, b2 as int, b1 as int);\n}\n\n// Auxiliary lemma for exponentiation\npub proof fn pow2_le_max64(k: nat)\n    requires\n        k < 64,\n    ensures\n        pow2(k) <= u64::MAX\n    {\n        lemma2_to64();\n        lemma2_to64_rest();\n    }\n\n// Rewriting lemma; 2^(a + b) * x = 2^a * (2^b * x)\n// Parenthesis placement matters here\npub proof fn lemma_two_factoring(a : nat, b: nat, v: u64)\n    ensures\n        pow2(a + b) * v == pow2(a) * (pow2(b) * v)\n{\n    lemma_pow2_adds(a, b);\n    lemma_mul_is_associative(pow2(a) as int, pow2(b) as int, v as int);\n}\n\n// Specialization of lemma_u64_shl_is_mul for x = 1\npub proof fn shift_is_pow2(k: nat)\n    requires\n        k < 64,\n    ensures\n        (1u64 << k) == pow2(k)\n{\n    pow2_le_max64(k);\n    lemma_u64_shl_is_mul(1u64, k as u64);\n}\n\n// v << 0 == v for all v\npub broadcast proof fn shl_zero_is_id(v: u64)\n    ensures\n        #![trigger v << 0]\n        v << 0 == v\n{\n    assert(v << 0 == v) by (bit_vector);\n}\n\n// v << (a + b) == (v << a) << b\npub proof fn shl_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n        v * pow2(a + b) <= u64::MAX\n    ensures\n        (v << (a + b)) == ((v << a) << b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shl_zero_is_id;\n    }\n    else {\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // 2^a < 2^(a + b) ...\n        lemma_pow2_strictly_increases(a, a + b);\n        // ..., which implies v * 2^a < v * 2^(a + b) <= u64::MAX\n        mul_le(v as nat, v as nat, pow2(a), pow2(a + b));\n        // v << a + b = v * 2^(a+b)\n        lemma_u64_shl_is_mul(v, (a + b) as u64);\n        // v << a = v * 2^a\n        lemma_u64_shl_is_mul(v, a as u64);\n        broadcast use lemma_mul_is_associative; // (v * 2^a) * 2^b = v * (2^a * 2^b)\n        // (v * 2^a) << b = (v * 2^a) * 2^b\n        lemma_u64_shl_is_mul((v * pow2(a)) as u64, b as u64);\n    }\n}\n\n// [<<] preserves [<=] (u64 version)\npub proof fn lemma_shl_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64,\n        (b * pow2(k)) <= u64::MAX,\n    ensures\n        (a << k) <= (b << k)\n{\n    mul_le(a as nat, b as nat, pow2(k), pow2(k));\n    lemma_u64_shl_is_mul(a, k as u64);\n    lemma_u64_shl_is_mul(b, k as u64);\n}\n\n// // If a <= b then v << a <= v << b (up to overflow)\npub proof fn shl_nondecreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b < 64,\n        v * pow2(b) <= u64::MAX\n    ensures\n        (v << a) <= (v << b)\n{\n    lemma2_to64(); // pow2(0)\n\n    if (a == b) {\n        // trivial\n    }\n    else if (a == 0) {\n        // a != b <=> b > 0\n        lemma_pow2_strictly_increases(0, b);\n        lemma_u64_shl_is_mul(v, 0);\n        lemma_u64_shl_is_mul(v, b as u64);\n        mul_le(v as nat, v as nat, pow2(0), pow2(b));\n    }\n    else {\n        // if a != 0 and a != b then 0 < d < b\n        let d = b - a;\n\n        // v << b = (v << (b - a)) << a\n        shl_decomposition(v, d as nat, a);\n\n        assert(v << d == v * pow2(d as nat)) by {\n            // we need the precond v * pow2(d) < M\n            lemma_pow2_strictly_increases(d as nat, b);\n            mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));\n            lemma_u64_shl_is_mul(v, d as u64);\n        }\n\n        assert(v <= v << d) by {\n            shl_zero_is_id(v);\n            lemma_u64_shl_is_mul(v, 0);\n            lemma_pow2_strictly_increases(0, d as nat);\n            mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));\n        }\n\n        lemma_pow2_adds(a, d as nat);\n\n        assert( (v << (d as u64)) * pow2(a) <= u64::MAX ) by {\n            broadcast use lemma_mul_is_associative;\n        }\n\n        // [v <= v << d] => [(v << a) <= (v << d) << a]\n        lemma_shl_le_u64(v, v << (d as u64), a);\n    }\n}\n\n// v >> 0 == v for all v\npub broadcast proof fn shr_zero_is_id(v: u64)\n    ensures\n        #![trigger v >> 0]\n        v >> 0 == v\n{\n    assert(v >> 0 == v) by (bit_vector);\n}\n\n// v >> (a + b) == (v >> a) >> b\npub proof fn shr_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64\n    ensures\n        (v >> (a + b)) == ((v >> a) >> b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shr_zero_is_id;\n    }\n    else {\n        lemma2_to64_rest(); // pow2(64)\n        lemma_pow2_strictly_increases(a, a + b);\n        lemma_pow2_strictly_increases(b, a + b);\n        lemma_pow2_strictly_increases(a + b, 64); // pow2(a + b) fits in u64\n\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // v >> a + b = v / 2^(a+b)\n        lemma_u64_shr_is_div(v, (a + b) as u64);\n        // v >> a = v / 2^a\n        lemma_u64_shr_is_div(v, a as u64);\n        // (v / 2^a) << b = (v / 2^a) / 2^b\n        lemma_u64_shr_is_div((v / (pow2(a) as u64)) as u64, b as u64);\n\n        // 2^k > 0\n        lemma_pow2_pos(a);\n        lemma_pow2_pos(b);\n\n        // v / 2^a / 2^b = v / 2^(a + b)\n        lemma_div_denominator(v as int, pow2(a) as int, pow2(b) as int);\n    }\n}\n\n// [>>] preserves [<=] (u64 version)\npub proof fn lemma_shr_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64\n    ensures\n        (a >> k) <= (b >> k)\n{\n    lemma_pow2_pos(k);\n    lemma_u64_shr_is_div(a, k as u64);\n    lemma_u64_shr_is_div(b, k as u64);\n    lemma_div_is_ordered(a as int, b as int, pow2(k) as int);\n}\n\n// If a <= b then v >> a >= v >> b\npub proof fn shr_nonincreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b <= 64\n    ensures\n        v >> b <= v >> a\n{\n    if (b == 64) {\n        assert(v >> 64 == 0) by (bit_vector);\n    }\n    else {\n        let d = (b - a) as u64;\n        // v >> b = (v >> (b - a)) >> a\n        shr_decomposition(v, d as nat, a);\n        assert(v >> d <= v) by (bit_vector);\n        // a <= b => a >> x <= b >> x\n        lemma_shr_le_u64(v >> d, v, a);\n    }\n}\n\n// u64::MAX = 2^64 - 1\n// u64::MAX >> k = 2^(64 - k) - 1\n// 1u64 << (64 - k) = 2^(64 - k)\npub proof fn lemma_u64_max_shifting(k:nat)\n    requires\n        1 <= k < 64\n    ensures\n        u64::MAX >> k < 1u64 << (64 - k)\n    decreases 64-k\n{\n    let M = u64::MAX;\n\n    // recursion base case\n    if (k == 63){\n        assert(u64::MAX >> 63 < 1u64 << 1) by (compute);\n    }\n    else {\n        // M >> (k + 1) < 1 << (63 - k)\n        lemma_u64_max_shifting(k + 1);\n\n        // M >> (k + 1) = (M >> k) >> 1\n        shr_decomposition(M, k, 1);\n\n        // precondition\n        lemma2_to64_rest(); // pow2(63)\n        lemma_pow2_strictly_increases((63 - k) as nat, (64 - k) as nat);\n\n        assert(1u64 * pow2((64 - k) as nat) <= 1u64 * pow2(63)) by {\n            if (k == 1) {\n                // 64 - k = 63\n                // tautology\n            }\n            else {\n                // 64 - k < 63\n                lemma_pow2_strictly_increases((64 - k) as nat, 63);\n            }\n            mul_le(1u64 as nat, 1u64 as nat, pow2((64 - k) as nat), pow2(63));\n        }\n        assert( 1u64 * pow2(63) <= u64::MAX) by (compute);\n\n        // 1 << 64 - k = (1 << 63 - k) << 1\n        shl_decomposition(1u64, (63 - k) as nat, 1);\n\n        // (M >> k) >> 1 = (M >> k) / pow2(1);\n        lemma_u64_shr_is_div( M >> k, 1);\n\n        // lemma_u64_shl_is_mul(x, n) precondition: x * pow2(n) <= u64::MAX\n        assert((1u64 << ((63 - k))) * pow2(1) <= u64::MAX) by {\n            shift_is_pow2((63 - k) as nat);\n            lemma_pow2_adds((63-k) as nat, 1);\n        }\n\n        // (1 << 63 - k) << 1 = (1 << 63 - k) * pow2(1);\n        lemma_u64_shl_is_mul( 1u64 << ((63 - k)), 1);\n\n        lemma2_to64(); // pow2(1) = 2\n\n        assert((1u64 << ((64 - k) as u64)) / 2 == (1u64 << ((63 - k) as u64))) by {\n            lemma_div_multiples_vanish((1u64 << (63 - k) as u64) as int, 2);\n        }\n    }\n}\n\n// Corollary of lemma_u64_max_shifting, since for any\n// v: u64 it holds that v <= u64::MAX and >> preserves [<=]\npub proof fn shifted_lt(v: u64, k: nat)\n    requires\n        1 <= k <= 64\n    ensures\n        v >> k < 1u64 << (64 - k)\n{\n    if (k == 64) {\n        assert( v >> 64 == 0) by (bit_vector);\n        shl_zero_is_id(1u64);\n    }\n    else {\n        // (v >> k) <= (u64::MAX >> k)\n        lemma_shr_le_u64(v, u64::MAX, k);\n        // u64::MAX >> k < 1u64 << (64 - k)\n        lemma_u64_max_shifting(k);\n    }\n}\n\n// Because &-ing low_bits_mask(k) is a mod operation, it follows that\n// v & (low_bits_mask(k) as u64) = v % pow2(k) < pow2(k)\npub proof fn masked_lt(v: u64, k: nat)\n    requires\n        0 <= k < 64\n    ensures\n        v & (low_bits_mask(k) as u64) < (1u64 << k)\n{\n    // v & (low_bits_mask(k) as u64) = v % pow2(k)\n    lemma_u64_low_bits_mask_is_mod(v, k);\n    // pow2(k) > 0\n    lemma_pow2_pos(k);\n    // v % pow2(k) < pow2(k)\n    lemma_mod_bound(v as int, pow2(k) as int);\n    // 1 << k = pow2(k)\n    shift_is_pow2(k);\n}\n\n// a < b => (2^a - 1) < (2^b - 1)\npub proof fn low_bits_mask_increases(a: nat, b: nat)\n    requires\n        a < b\n    ensures\n        low_bits_mask(a) < low_bits_mask(b)\n    decreases a + b\n{\n    if (a == 0){\n         // lbm(0) = 0\n        lemma_low_bits_mask_values();\n        // lbm(b) = 2 * lbm(b - 1) + 1, in particular, > 0\n        lemma_low_bits_mask_unfold(b);\n    }\n    else {\n        // lbm(b) / 2 = lbm(b - 1)\n        lemma_low_bits_mask_div2(b);\n        // lbm(a) / 2 = lbm(a - 1)\n        lemma_low_bits_mask_div2(a);\n        // lbm(a - 1) < lbm(b - 1)\n        low_bits_mask_increases((a - 1) as nat, (b - 1) as nat);\n    }\n\n}\n\n// k <= 64 => 2^k - 1 <= u64::MAX = 2^64 - 1\npub proof fn low_bits_masks_fit_u64(k: nat)\n    requires\n        k <= 64\n    ensures\n        low_bits_mask(k) <= u64::MAX\n{\n    lemma_low_bits_mask_values(); // lbm(0) = 0, lbm(64) = 2^64\n    assert(low_bits_mask(64) <= u64::MAX) by (compute);\n    if (k < 64){\n        low_bits_mask_increases(k, 64);\n    }\n}\n\npub proof fn lemma_div_and_mod(ai:u64, bi: u64, v: u64, k: nat)\n    requires\n        k < 64,\n        ai == v >> k,\n        bi == v & (low_bits_mask(k) as u64)\n    ensures\n        ai == v / (pow2(k) as u64),\n        bi == v % (pow2(k) as u64),\n        v == ai * pow2(k) + bi\n{\n    lemma2_to64();\n    lemma2_to64_rest(); // pow2(63) = 0x8000000000000000\n\n    // v >> k = v / pow2(k);\n    lemma_u64_shr_is_div(v, k as u64);\n\n    // v & low_bits_mask(k) = v % pow2(k);\n    lemma_u64_low_bits_mask_is_mod(v, k);\n\n    // 0 < pow2(k) <= u64::MAX\n    lemma_pow2_pos(k);\n    assert(pow2(k) <= u64::MAX) by {\n        assert(0x8000000000000000 <= u64::MAX) by (compute);\n        if (k < 63) {\n            lemma_pow2_strictly_increases(k, 63);\n        }\n    }\n\n    // v = (pow2(k) * (v / pow2(k)) + (v % pow2(k)))\n    lemma_fundamental_div_mod(v as int, pow2(k) as int);\n}\n\n// m(_,_) multiplication is bounded by the product of the individual bounds\npub proof fn lemma_m(x: u64, y: u64, bx: u64, by: u64)\n    requires\n        x < bx,\n        y < by\n    ensures\n        (x as u128) * (y as u128) < (bx as u128) * (by as u128)\n{\n    mul_lt(x as nat, bx as nat, y as nat, by as nat);\n}\n\n// (v^(2^k))^2 = v^(2^(k + 1))\npub proof fn lemma_pow2_square(v: int, i: nat)\n    ensures\n        pow(v, pow2(i)) * pow(v, pow2(i)) == pow(v, pow2(i + 1))\n{\n    // pow(v, pow2(i)) * pow(v, pow2(i)) = pow(v, pow2(i) + pow2(i));\n    lemma_pow_adds(v as int, pow2(i), pow2(i));\n    // 2 * pow2(i) = pow2(i + 1)\n    lemma_pow2_unfold(i + 1);\n}\n\n// Combination of mod lemmas, (b +- a * m) % m = b % m\npub proof fn lemma_mod_sum_factor(a: int, b: int, m: int)\n    requires\n        m > 0\n    ensures\n        (a * m + b) % m == b % m\n{\n    // (a * m + b) % m == ((a * m) % m + b % m) % m\n    lemma_add_mod_noop(a * m, b, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}\n\npub proof fn lemma_mod_diff_factor(a: int, b: int, m: int)\n    requires\n        m > 0,\n    ensures\n        (b - a * m) % m == b % m\n{\n    // (b - a * m) % m == (b % m - (a * m) % m) % m\n    lemma_sub_mod_noop(b, a * m, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}\n\n// v^(2^i) >= 0\npub proof fn lemma_pow_nat_is_nat(v: nat, i: nat)\n    ensures\n        pow(v as int, pow2(i)) >= 0\n{\n    lemma_pow2_pos(i); // pow2(i) > 0\n    if (v == 0) {\n        lemma0_pow(pow2(i));\n    }\n    else {\n        lemma_pow_positive(v as int, pow2(i));\n    }\n}\n\n// dummy, so we can call `verus common_verus.rs`\nfn main() {}\n\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/common_verus.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63633": {
    "text": "#[allow(unused_imports)]\nuse super::common_verus::*;\n#[allow(unused_imports)]\nuse super::scalar::Scalar52;\n#[allow(unused_imports)]\nuse super::scalar_specs::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::mul::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\n#[allow(unused_imports)]\nuse vstd::bits::*;\n#[allow(unused_imports)]\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\n/// Verification: scalar * scalar.invert() ≡ 1 mod L\nproof fn verify_invert_correct(x: Scalar52)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}\n\npub proof fn lemma_52_52(x: u64, y: u64)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures (x as u128) * (y as u128) < (1u128 << 104)\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert( x * y < x * (1u128 << 52)  );\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}\n\npub proof fn lemma_square_internal_no_overflow()\n    ensures\n         (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n         (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n         (1u128 << 104) * 2 == (1u128 << 105),\n         (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}\n\n\npub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]) ,\n        z[1] == (a[0] * a[1])  * 2,\n        z[2] == (a[0] * a[2])  * 2 + (a[1] * a[1]) ,\n        z[3] == (a[0] * a[3])  * 2 + (a[1] * a[2])  * 2,\n        z[4] == (a[0] * a[4])  * 2 + (a[1] * a[3])  * 2 + (a[2] * a[2]) ,\n        z[5] == (a[1] * a[4])  * 2 + (a[2] * a[3])  * 2,\n        z[6] == (a[2] * a[4])  * 2 + (a[3] * a[3]) ,\n        z[7] == (a[3] * a[4])  * 2,\n        z[8] == (a[4] * a[4]) ,\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n\n{\n        assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n            broadcast use group_mul_is_commutative_and_distributive;\n            broadcast use lemma_mul_is_associative;\n\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(52, 104);\n            lemma_pow2_adds(52, 156);\n            lemma_pow2_adds(52, 208);\n            lemma_pow2_adds(104, 104);\n            lemma_pow2_adds(104, 156);\n            lemma_pow2_adds(104, 208);\n            lemma_pow2_adds(156, 156);\n            lemma_pow2_adds(156, 208);\n            lemma_pow2_adds(208, 208);\n        };\n        lemma_nine_limbs_equals_slice128_to_nat(&z);\n        lemma_five_limbs_equals_to_nat(&a);\n}\n\npub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}\n\npub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}\n\n\npub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\nensures\n    nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs)\n{\n\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            ((limbs[4] as nat) +\n            ((limbs[5] as nat) +\n                ((limbs[6] as nat) +\n                ((limbs[7] as nat) +\n                (limbs[8] as nat) * pow2(52)\n                ) * pow2(52)\n                ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        lemma_pow2_adds(208, 52);\n        lemma_pow2_adds(260, 52);\n        lemma_pow2_adds(312, 52);\n        lemma_pow2_adds(364, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}\n\npub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\nensures\n    five_limbs_to_nat_aux(*limbs) == to_nat(limbs)\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            (limbs[4] as nat) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        (limbs[0] as nat) +\n        pow2(52) * (limbs[1] as nat) +\n        pow2(104) * (limbs[2] as nat) +\n        pow2(156) * (limbs[3] as nat) +\n        pow2(208) * (limbs[4] as nat); {\n        }\n        five_limbs_to_nat_aux(*limbs);\n    }\n}\n\n\npub proof fn lemma_scalar_subtract_no_overflow(carry: u64, difference_limb: u64, addend: u64, i: u32, l_value: &Scalar52)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}\n\npub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}\n\npub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}\n\npub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}\n\n\npub proof fn lemma_from_montgomery_limbs_conversion(\n    limbs: &[u128; 9],\n    self_limbs: &[u64; 5]\n)\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) +\n           (self_limbs[1] as nat) * pow2(52) +\n           (self_limbs[2] as nat) * pow2(104) +\n           (self_limbs[3] as nat) * pow2(156) +\n           (self_limbs[4] as nat) * pow2(208) +\n           0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(416));\n}\n\n\n\npub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}\n} // verus!\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63634": {
    "text": "#![allow(unused)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::prelude::*;\n\nuse super::common_verus::*;\n\n// Lemmas and spec functions only used in field_verus.rs\n// A lemma should be in this file instead of `common_verus` if:\n//  - It references some constant prominent in `field_verus` (e.g. 51 for bit operations, 2^255 -19)\n//  - It defines or reasons about a spec function relevant only to `field_verus`\nverus! {\n\n// p = 2^255 - 19\npub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n}\n\n// Proof that 2^255 > 19\npub proof fn pow255_gt_19()\n    ensures\n        pow2(255) > 19\n{\n    lemma2_to64(); // 2^5\n    lemma_pow2_strictly_increases(5, 255);\n}\n\n// Specialization for b = 51\npub proof fn lemma_two_factoring_51(k : nat, ai: u64)\n    ensures\n        pow2(k + 51) * ai == pow2(k) * (pow2(51) * ai)\n{\n    lemma_two_factoring(k, 51, ai);\n}\n\n// Evaluation function, given a field element as limbs, reconstruct the nat value it represents.\npub open spec fn as_nat(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n}\n\n// Evaluation function, given a field element as limbs, reconstruct the nat value it represents.\npub open spec fn as_nat_32_u8(limbs: [u8; 32]) -> nat {\n    // Verus error: `core::iter::range::impl&%15::fold` is not supported\n    // we write them out manually\n    (limbs[0] as nat) +\n    pow2( 1 * 8) * (limbs[ 1] as nat) +\n    pow2( 2 * 8) * (limbs[ 2] as nat) +\n    pow2( 3 * 8) * (limbs[ 3] as nat) +\n    pow2( 4 * 8) * (limbs[ 4] as nat) +\n    pow2( 5 * 8) * (limbs[ 5] as nat) +\n    pow2( 6 * 8) * (limbs[ 6] as nat) +\n    pow2( 7 * 8) * (limbs[ 7] as nat) +\n    pow2( 8 * 8) * (limbs[ 8] as nat) +\n    pow2( 9 * 8) * (limbs[ 9] as nat) +\n    pow2(10 * 8) * (limbs[10] as nat) +\n    pow2(11 * 8) * (limbs[11] as nat) +\n    pow2(12 * 8) * (limbs[12] as nat) +\n    pow2(13 * 8) * (limbs[13] as nat) +\n    pow2(14 * 8) * (limbs[14] as nat) +\n    pow2(15 * 8) * (limbs[15] as nat) +\n    pow2(16 * 8) * (limbs[16] as nat) +\n    pow2(17 * 8) * (limbs[17] as nat) +\n    pow2(18 * 8) * (limbs[18] as nat) +\n    pow2(19 * 8) * (limbs[19] as nat) +\n    pow2(20 * 8) * (limbs[20] as nat) +\n    pow2(21 * 8) * (limbs[21] as nat) +\n    pow2(22 * 8) * (limbs[22] as nat) +\n    pow2(23 * 8) * (limbs[23] as nat) +\n    pow2(24 * 8) * (limbs[24] as nat) +\n    pow2(25 * 8) * (limbs[25] as nat) +\n    pow2(26 * 8) * (limbs[26] as nat) +\n    pow2(27 * 8) * (limbs[27] as nat) +\n    pow2(28 * 8) * (limbs[28] as nat) +\n    pow2(29 * 8) * (limbs[29] as nat) +\n    pow2(30 * 8) * (limbs[30] as nat) +\n    pow2(31 * 8) * (limbs[31] as nat)\n}\n\n// Lemma: If a > b pointwise, then as_nat(a - b) = as_nat(a) - as_nat(b)\npub proof fn lemma_as_nat_sub(a: [u64;5], b: [u64;5])\n    requires\n        forall |i:int| 0 <= i < 5 ==> b[i] < a[i]\n    ensures\n        as_nat([\n            (a[0] - b[0]) as u64,\n            (a[1] - b[1]) as u64,\n            (a[2] - b[2]) as u64,\n            (a[3] - b[3]) as u64,\n            (a[4] - b[4]) as u64\n        ]) == as_nat(a) - as_nat(b)\n{\n    let c: [u64;5] = [\n        (a[0] - b[0]) as u64,\n        (a[1] - b[1]) as u64,\n        (a[2] - b[2]) as u64,\n        (a[3] - b[3]) as u64,\n        (a[4] - b[4]) as u64\n    ];\n    // distribute pow2\n    assert( as_nat(c) ==\n        (a[0] - b[0]) +\n        pow2(51) * a[1] - pow2(51) * b[1] +\n        pow2(102) * a[2] - pow2(102) * b[2] +\n        pow2(153) * a[3] - pow2(153) * b[3] +\n        pow2(204) * a[4] - pow2(204) * b[4]\n    ) by {\n        broadcast use lemma_mul_is_distributive_sub;\n    }\n}\n\npub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52)\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}\n\n// >> preserves [<=]. Unfortunately, these operations are u128 and\n// we need lemma_u128_shr_is_div.\npub proof fn lemma_shr_51_le(a: u128, b: u128)\n    requires\n        a <= b\n    ensures\n        (a >> 51) <= (b >> 51)\n{\n    lemma_pow2_pos(51);\n    lemma2_to64_rest(); // pow2(51) value\n    lemma_u128_shr_is_div(a, 51);\n    lemma_u128_shr_is_div(b, 51);\n    lemma_div_is_ordered(a as int, b as int, 51);\n}\n\n// Corollary of above, using the identity (a << x) >> x == a for u64::MAX\npub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51\n    ensures\n        (a >> 51) <= (u64::MAX as u128)\n\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}\n\n// Auxiliary datatype lemma\n// Should work for any k <= 64, but the proofs are convoluted and we can't use BV\n// (x as u64) = x % 2^64, so x = 2^64 * (x / 2^64) + (x as u64). Thus\n// (x as u64) % 2^k = (x as u64) % 2^k, because 2^k | 2^64 * (...) for k <= 64\npub proof fn lemma_cast_then_mod_51(x: u128)\n    ensures\n        (x as u64) % (pow2(51) as u64) == x % (pow2(51) as u128)\n{\n    lemma2_to64_rest(); // pow2(51 | 64)\n    assert( (x as u64) % 0x8000000000000 == x % 0x8000000000000) by (bit_vector);\n}\n\n// Explicit and mod-p identities for squaring as_nat conversion\npub proof fn as_nat_squared(v: [u64; 5])\n    ensures\n        as_nat(v) * as_nat(v) ==\n        pow2(8 * 51) * (v[4] * v[4]) +\n        pow2(7 * 51) * (2 * (v[3] * v[4])) +\n        pow2(6 * 51) * (v[3] * v[3] + 2 * (v[2] * v[4])) +\n        pow2(5 * 51) * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])) +\n        pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n        pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3])) +\n        pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2])) +\n        pow2(1 * 51) * (2 * (v[0] * v[1])) +\n                       (v[0] * v[0]),\n        // and the mod equality\n        (as_nat(v) * as_nat(v)) % p() ==\n        (\n            pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n            pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])) +\n            pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))) +\n            pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))) +\n                           (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])))\n        ) as nat % p()\n{\n    let v0 = v[0];\n    let v1 = v[1];\n    let v2 = v[2];\n    let v3 = v[3];\n    let v4 = v[4];\n\n    let s1 = pow2(1 * 51);\n    let s2 = pow2(2 * 51);\n    let s3 = pow2(3 * 51);\n    let s4 = pow2(4 * 51);\n    let s5 = pow2(5 * 51);\n    let s6 = pow2(6 * 51);\n    let s7 = pow2(7 * 51);\n    let s8 = pow2(8 * 51);\n\n    assert(s1 * s1 == s2) by {\n        lemma_pow2_adds(51, 51)\n    }\n    assert(s1 * s2 == s2 * s1 == s3) by {\n        lemma_pow2_adds(51, 102)\n    }\n    assert(s1 * s3 == s3 * s1 == s4) by {\n        lemma_pow2_adds(51, 153)\n    }\n    assert(s1 * s4 == s4 * s1 == s5) by {\n        lemma_pow2_adds(51, 204)\n    }\n    assert(s2 * s2 ==s4) by {\n        lemma_pow2_adds(102, 102)\n    }\n    assert(s2 * s3 == s3 * s2 == s5) by {\n        lemma_pow2_adds(102, 153)\n    }\n    assert(s2 * s4 == s4 * s2 == s6) by {\n        lemma_pow2_adds(102, 204)\n    }\n    assert(s3 * s3 == s6) by {\n        lemma_pow2_adds(153, 153)\n    }\n    assert(s3 * s4 == s4 * s3 == s7) by {\n        lemma_pow2_adds(153, 204)\n    }\n    assert(s4 * s4 == s8) by {\n        lemma_pow2_adds(204, 204)\n    }\n\n    assert(as_nat(v) * as_nat(v) ==\n        v0 * as_nat(v) +\n        (s1 * v1) * as_nat(v) +\n        (s2 * v2) * as_nat(v) +\n        (s3 * v3) * as_nat(v) +\n        (s4 * v4) * as_nat(v)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    // because of the sheer number of possible associativity/distributivity groupings we have\n    // to help the solver along by intermittently asserting chunks\n    assert(v0 * as_nat(v) ==\n        v0 * v0 +\n        v0 * (s1 * v1) +\n        v0 * (s2 * v2) +\n        v0 * (s3 * v3) +\n        v0 * (s4 * v4)\n        ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n        v0 * v0\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    assert((s1 * v1) * as_nat(v) ==\n        s5 * (v1 * v4) +\n        s4 * (v1 * v3) +\n        s3 * (v1 * v2) +\n        s2 * (v1 * v1) +\n        s1 * (v0 * v1)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    assert((s2 * v2) * as_nat(v) ==\n        s6 * (v2 * v4) +\n        s5 * (v2 * v3) +\n        s4 * (v2 * v2) +\n        s3 * (v1 * v2) +\n        s2 * (v0 * v2)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    assert((s3 * v3) * as_nat(v) ==\n        s7 * (v3 * v4) +\n        s6 * (v3 * v3) +\n        s5 * (v2 * v3) +\n        s4 * (v1 * v3) +\n        s3 * (v0 * v3)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    assert((s4 * v4) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (v3 * v4) +\n        s6 * (v2 * v4) +\n        s5 * (v1 * v4) +\n        s4 * (v0 * v4)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    // we now mash them all together\n    assert(as_nat(v) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (2 * (v3 * v4)) +\n        s6 * (v3 * v3 + 2 * (v2 * v4)) +\n        s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) +\n        s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4)) +\n        s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) +\n        s2 * (v1 * v1 + 2 * (v0 * v2)) +\n        s1 * (2 * (v0 * v1)) +\n             (v0 * v0)\n    ) by {\n        broadcast use lemma_mul_is_associative;\n        broadcast use lemma_mul_is_distributive_add;\n        assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n        assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n        assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n        assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n        assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n        assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n        assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n        assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n        assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n        assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n    }\n\n    // This is the explicit version, now we can take everything mod p\n\n    // p well defined\n    pow255_gt_19();\n\n    // By definition, p = s^5 - 19\n    // equivalently,\n    // s^5 = (p + 19)\n    // s^6 = s * (p + 19)\n    // s^7 = s^2 * (p + 19)\n    // s^8 = s^3 * (p + 19)\n    assert(s5 == (p() + 19));\n\n    // we pack together terms to slim down expressions;\n\n    let c0_base = v0 *  v0;\n    let c0_x19 = 2 * (v2 * v3) + 2 * (v1 * v4);\n    let c0 = c0_base + 19 * c0_x19;\n\n    let c1_base = 2 * (v0 *  v1);\n    let c1_x19 = v3 * v3 + 2 * (v2 * v4);\n    let c1 = c1_base + 19 * c1_x19;\n\n    let c2_base = v1 * v1 + 2 * (v0 *  v2);\n    let c2_x19 = 2 * (v3 * v4);\n    let c2 = c2_base + 19 * c2_x19;\n\n    let c3_base = 2 * (v1 *  v2) + 2 * (v0 *  v3);\n    let c3_x19 = v4 * v4;\n    let c3 = c3_base + 19 * c3_x19;\n\n    let c4 = v2 *  v2 + 2 * (v1 *  v3) + 2 * (v0 *  v4);\n\n    // group in preparation for the substitution\n    assert(as_nat(v) * as_nat(v) ==\n        s4 * c4 +\n        s3 * (s5 * c3_x19 + c3_base) +\n        s2 * (s5 * c2_x19 + c2_base) +\n        s1 * (s5 * c1_x19 + c1_base) +\n             (s5 * c0_x19 + c0_base)\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        broadcast use lemma_mul_is_associative;\n    }\n\n    // Next we use the identity s5 = p + 19\n    assert(s5 * c3_x19 + c3_base == p() * c3_x19 + c3) by {\n        lemma_mul_is_distributive_add(c3_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c2_x19 + c2_base == p() * c2_x19 + c2) by {\n        lemma_mul_is_distributive_add(c2_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c1_x19 + c1_base == p() * c1_x19 + c1) by {\n        lemma_mul_is_distributive_add(c1_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c0_x19 + c0_base == p() * c0_x19 + c0) by {\n        lemma_mul_is_distributive_add(c0_x19 as int, p() as int, 19);\n    }\n\n    // in summary, we can reorder and regroup terms to get X * p() + Y\n    assert(as_nat(v) * as_nat(v) ==\n        p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 ) +\n        (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        )\n    ) by {\n        broadcast use lemma_mul_is_distributive_add;\n        // we don't broadcast assoc, too many trigger matches\n        lemma_mul_is_associative(s3 as int, p() as int, c3_x19 as int);\n        lemma_mul_is_associative(s2 as int, p() as int, c2_x19 as int);\n        lemma_mul_is_associative(s1 as int, p() as int, c1_x19 as int);\n        lemma_mul_is_associative(p() as int, s3 as int, c3_x19 as int);\n        lemma_mul_is_associative(p() as int, s2 as int, c2_x19 as int);\n        lemma_mul_is_associative(p() as int, s1 as int, c1_x19 as int);\n    }\n\n\n    let k = ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 );\n    let sum = (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        );\n\n    assert(as_nat(v) * as_nat(v) == k * p() + sum);\n    assert(k * p() + sum == (k as nat) * p() + (sum as nat));\n\n    // Now, we simply move to mod p\n\n    assert((as_nat(v) * as_nat(v)) % p() == ((k as nat) * p() + (sum as nat)) % p() );\n    assert(\n        ((k as nat) * p() + (sum as nat)) % p() ==\n        (sum as nat) % p()\n    ) by {\n        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}\n\n// Auxiliary lemma for reordering terms in the pow2k proof\npub proof fn lemma_reorder_mul(a: int, b: int)\n    ensures\n        2 * (a * (19 * b)) == 19 * (2 * (a * b))\n{\n    // 2*( a * (19 * b)) = (2 * a) * (19 * b)\n    lemma_mul_is_associative(2, a, 19 * b);\n    // (2 * a) * (19 * b) = (19 * b) * (2 * a) = 19 * (b * (2 * a))\n    lemma_mul_is_associative(19, b, 2 * a);\n    // (b * (2 * a)) = (b * (a * 2)) = 2 * (a * b)\n    lemma_mul_is_associative(b, a, 2);\n}\n\n// dummy, so we can call `verus`\nfn main() {}\n\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/field_lemmas.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63635": {
    "text": "//! Arithmetic mod \\\\(2\\^{252} + 27742317777372353535851937790883648493\\\\)\n//! with five \\\\(52\\\\)-bit unsigned limbs.\n//!\n//! \\\\(51\\\\)-bit limbs would cover the desired bit range (\\\\(253\\\\)\n//! bits), but isn't large enough to reduce a \\\\(512\\\\)-bit number with\n//! Montgomery multiplication, so \\\\(52\\\\) bits is used instead.  To see\n//! that this is safe for intermediate results, note that the largest\n//! limb in a \\\\(5\\times 5\\\\) product of \\\\(52\\\\)-bit limbs will be\n//!\n//! ```text\n//! (0xfffffffffffff^2) * 5 = 0x4ffffffffffff60000000000005 (107 bits).\n//! ```\n\nuse core::fmt::Debug;\nuse core::ops::{Index, IndexMut};\nuse subtle::Choice;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse crate::constants;\n\n#[allow(unused_imports)]\nuse super::scalar_lemmas::*;\n#[allow(unused_imports)]\nuse super::scalar_specs::*;\nuse super::subtle_assumes::*;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\nuse vstd::prelude::*;\n\nverus! {\n/// The `Scalar52` struct represents an element in\n/// \\\\(\\mathbb Z / \\ell \\mathbb Z\\\\) as 5 \\\\(52\\\\)-bit limbs.\n#[derive(Copy, Clone)]\npub struct Scalar52 {\n    pub limbs: [u64; 5],\n}\n\n} // verus!\n\nimpl Debug for Scalar52 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", self.limbs)\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar52 {\n    fn zeroize(&mut self) {\n        self.limbs.zeroize();\n    }\n}\n\nverus! {\nimpl Index<usize> for Scalar52 {\n    type Output = u64;\n    // TODO Verify this\n    #[verifier::external_body]\n    fn index(&self, _index: usize) -> &u64 {\n        &(self.limbs[_index])\n    }\n}\n} // verus!\n\nimpl IndexMut<usize> for Scalar52 {\n    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.limbs[_index])\n    }\n}\n\nverus! {\n\n/// u64 * u64 = u128 multiply helper\n#[inline(always)]\nfn m(x: u64, y: u64) -> (z: u128)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures\n    z < (1u128 << 104),\n    z == x * y\n{\n    proof {lemma_52_52(x, y);}\n    (x as u128) * (y as u128)\n}\n\nimpl Scalar52 {\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: Scalar52 = Scalar52 { limbs: [0, 0, 0, 0, 0] };\n\n    /// Unpack a 32 byte / 256 bit scalar into 5 52-bit limbs.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n    ensures bytes_to_nat(bytes) == to_nat(&s.limbs)\n    {\n        let mut words = [0u64; 4];\n        for i in 0..4\n            invariant 0 <= i <= 4 // proof\n        {\n            for j in 0..8\n                invariant 0 <= j <= 8 && i < 4\n            {\n                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64)*8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)\n        assume(bytes_to_nat(bytes) == words_to_nat(&words));\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        //test workflow graphs\n        s.limbs[0] =   words[0]                            & mask;\n        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] =  (words[3] >> 16)                     & top_mask;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }\n\n    /// Reduce a 64 byte / 512 bit scalar mod l\n    #[rustfmt::skip] // keep alignment of lo[*] and hi[*] calculations\n    #[verifier::external_body] // TODO Verify this function\n    pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n    ensures\n        limbs_bounded(&s),\n        to_nat(&s.limbs) == bytes_wide_to_nat(bytes) % group_order(),\n    {\n        assume(false); // TODO: complete the proof\n        let mut words = [0u64; 8];\n        for i in 0..8 {\n            for j in 0..8 {\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        let mut hi = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n\n        lo[0] =   words[0]                             & mask;\n        lo[1] = ((words[0] >> 52) | (words[ 1] << 12)) & mask;\n        lo[2] = ((words[1] >> 40) | (words[ 2] << 24)) & mask;\n        lo[3] = ((words[2] >> 28) | (words[ 3] << 36)) & mask;\n        lo[4] = ((words[3] >> 16) | (words[ 4] << 48)) & mask;\n        hi[0] =  (words[4] >>  4)                      & mask;\n        hi[1] = ((words[4] >> 56) | (words[ 5] <<  8)) & mask;\n        hi[2] = ((words[5] >> 44) | (words[ 6] << 20)) & mask;\n        hi[3] = ((words[6] >> 32) | (words[ 7] << 32)) & mask;\n        hi[4] =   words[7] >> 20                             ;\n\n        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar52::add(&hi, &lo)\n    }\n\n    /// Pack the limbs of this `Scalar52` into 32 bytes\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    #[allow(clippy::identity_op)]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_bytes(self) -> (s: [u8; 32])\n    ensures bytes_to_nat(&s) == to_nat(&self.limbs)\n    {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.limbs[ 0] >>  0)                      as u8;\n        s[ 1] =  (self.limbs[ 0] >>  8)                      as u8;\n        s[ 2] =  (self.limbs[ 0] >> 16)                      as u8;\n        s[ 3] =  (self.limbs[ 0] >> 24)                      as u8;\n        s[ 4] =  (self.limbs[ 0] >> 32)                      as u8;\n        s[ 5] =  (self.limbs[ 0] >> 40)                      as u8;\n        s[ 6] = ((self.limbs[ 0] >> 48) | (self.limbs[ 1] << 4)) as u8;\n        s[ 7] =  (self.limbs[ 1] >>  4)                      as u8;\n        s[ 8] =  (self.limbs[ 1] >> 12)                      as u8;\n        s[ 9] =  (self.limbs[ 1] >> 20)                      as u8;\n        s[10] =  (self.limbs[ 1] >> 28)                      as u8;\n        s[11] =  (self.limbs[ 1] >> 36)                      as u8;\n        s[12] =  (self.limbs[ 1] >> 44)                      as u8;\n        s[13] =  (self.limbs[ 2] >>  0)                      as u8;\n        s[14] =  (self.limbs[ 2] >>  8)                      as u8;\n        s[15] =  (self.limbs[ 2] >> 16)                      as u8;\n        s[16] =  (self.limbs[ 2] >> 24)                      as u8;\n        s[17] =  (self.limbs[ 2] >> 32)                      as u8;\n        s[18] =  (self.limbs[ 2] >> 40)                      as u8;\n        s[19] = ((self.limbs[ 2] >> 48) | (self.limbs[ 3] << 4)) as u8;\n        s[20] =  (self.limbs[ 3] >>  4)                      as u8;\n        s[21] =  (self.limbs[ 3] >> 12)                      as u8;\n        s[22] =  (self.limbs[ 3] >> 20)                      as u8;\n        s[23] =  (self.limbs[ 3] >> 28)                      as u8;\n        s[24] =  (self.limbs[ 3] >> 36)                      as u8;\n        s[25] =  (self.limbs[ 3] >> 44)                      as u8;\n        s[26] =  (self.limbs[ 4] >>  0)                      as u8;\n        s[27] =  (self.limbs[ 4] >>  8)                      as u8;\n        s[28] =  (self.limbs[ 4] >> 16)                      as u8;\n        s[29] =  (self.limbs[ 4] >> 24)                      as u8;\n        s[30] =  (self.limbs[ 4] >> 32)                      as u8;\n        s[31] =  (self.limbs[ 4] >> 40)                      as u8;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }\n\n    /// Compute `a + b` (mod l)\n    pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order(),\n    {\n        let mut sum = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector); }\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        for i in 0..5\n           invariant\n                    forall|j: int| 0 <= j < i ==> sum.limbs[j] < 1u64 << 52,\n                    limbs_bounded(a),\n                    limbs_bounded(b),\n                    mask == (1u64 << 52) - 1,\n                    i == 0 ==> carry == 0,\n                    i >= 1 ==> (carry >> 52) < 2,\n        {\n            proof {lemma_add_loop_bounds(i as int, carry, a.limbs[i as int], b.limbs[i as int]);}\n            carry = a.limbs[i] + b.limbs[i] + (carry >> 52);\n            sum.limbs[i] = carry & mask;\n            proof {lemma_add_carry_and_sum_bounds(carry, mask);}\n        }\n\n        // subtract l if the sum is >= l\n        proof { lemma_l_value_properties(&constants::L, &sum); }\n        let result = Scalar52::sub(&sum, &constants::L);\n        assume(to_nat(&result.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order());\n        result\n\n    }\n\n    /// Compute `a - b` (mod l)\n    pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) + group_order() - to_nat(&b.limbs)) % (group_order() as int)\n    {\n        let mut difference = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector);}\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        for i in 0..5\n            invariant\n                      limbs_bounded(b),\n                      forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n                      mask == (1u64 << 52) - 1,\n        {\n            proof { assert ((borrow >> 63) < 2) by (bit_vector); }\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            difference.limbs[i] = borrow & mask;\n            proof { lemma_borrow_and_mask_bounded(borrow, mask); }\n        }\n\n        // conditionally add l if the difference is negative\n        let mut carry: u64 = 0;\n        for i in 0..5\n            invariant\n                      forall|j: int| 0 <= j < 5 ==> difference.limbs[j] < (1u64 << 52),  // from first loop\n                      mask == (1u64 << 52) - 1,\n                      i == 0 ==> carry == 0,\n                      i >= 1 ==> (carry >> 52) < 2,\n        {\n            let underflow = Choice::from((borrow >> 63) as u8);\n            let addend = select(&0, &constants::L.limbs[i], underflow);\n            proof {lemma_scalar_subtract_no_overflow(carry, difference.limbs[i as int], addend, i as u32, &constants::L);}\n            carry = (carry >> 52) + difference.limbs[i] + addend;\n            difference.limbs[i] = carry & mask;\n            proof { lemma_carry_bounded_after_mask(carry, mask); }\n        }\n        assume(to_nat(&difference.limbs) == (to_nat(&a.limbs) + group_order() - to_nat(&b.limbs)) % (group_order() as int));\n        difference\n    }\n\n    /// Compute `a * b`\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of z[*] calculations\n    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&b.limbs),\n    {\n        proof {lemma_mul_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n\n        z[0] = m(a.limbs[0], b.limbs[0]);\n        z[1] = m(a.limbs[0], b.limbs[1]) + m(a.limbs[1], b.limbs[0]);\n        z[2] = m(a.limbs[0], b.limbs[2]) + m(a.limbs[1], b.limbs[1]) + m(a.limbs[2], b.limbs[0]);\n        z[3] = m(a.limbs[0], b.limbs[3]) + m(a.limbs[1], b.limbs[2]) + m(a.limbs[2], b.limbs[1]) + m(a.limbs[3], b.limbs[0]);\n        z[4] = m(a.limbs[0], b.limbs[4]) + m(a.limbs[1], b.limbs[3]) + m(a.limbs[2], b.limbs[2]) + m(a.limbs[3], b.limbs[1]) + m(a.limbs[4], b.limbs[0]);\n        z[5] =                 m(a.limbs[1], b.limbs[4]) + m(a.limbs[2], b.limbs[3]) + m(a.limbs[3], b.limbs[2]) + m(a.limbs[4], b.limbs[1]);\n        z[6] =                                 m(a.limbs[2], b.limbs[4]) + m(a.limbs[3], b.limbs[3]) + m(a.limbs[4], b.limbs[2]);\n        z[7] =                                                 m(a.limbs[3], b.limbs[4]) + m(a.limbs[4], b.limbs[3]);\n        z[8] =                                                                 m(a.limbs[4], b.limbs[4]);\n\n        proof {lemma_mul_internal_correct(&a.limbs, &b.limbs, &z);}\n\n        z\n    }\n\n\n    // TODO Make this function more like the original?\n    /// Compute `a^2`\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of calculations\n    pub (crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n    {\n        proof {lemma_square_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(a.limbs[2], a.limbs[2]);\n        z[5] =                 m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] =                                 m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] =                                                 m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] =                                                                 m(a.limbs[4], a.limbs[4]);\n\n        proof {lemma_square_internal_correct(&a.limbs, &z);}\n\n        z\n    }\n\n    /// Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^260\n    #[inline(always)]\n    #[rustfmt::skip] // keep alignment of n* and r* calculations\n    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    ensures\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == slice128_to_nat(limbs) % group_order(),\n        limbs_bounded(&result),\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = Self::part1(limbs[0]);\n        let (carry, n1) = Self::part1(carry + limbs[1] + m(n0, l.limbs[1]));\n        let (carry, n2) = Self::part1(carry + limbs[2] + m(n0, l.limbs[2]) + m(n1, l.limbs[1]));\n        let (carry, n3) = Self::part1(carry + limbs[3] + m(n1, l.limbs[2]) + m(n2, l.limbs[1]));\n        let (carry, n4) = Self::part1(carry + limbs[4] + m(n0, l.limbs[4]) + m(n2, l.limbs[2]) + m(n3, l.limbs[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = Self::part2(carry + limbs[5] + m(n1, l.limbs[4]) + m(n3, l.limbs[2]) + m(n4, l.limbs[1]));\n        let (carry, r1) = Self::part2(carry + limbs[6] + m(n2, l.limbs[4]) + m(n4, l.limbs[2]));\n        let (carry, r2) = Self::part2(carry + limbs[7] + m(n3, l.limbs[4]));\n        let (carry, r3) = Self::part2(carry + limbs[8] + m(n4, l.limbs[4]));\n        let r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52 { limbs: [r0, r1, r2, r3, r4] }, l)\n    }\n\n\n    /// Helper function for Montgomery reduction\n    #[inline(always)]\n    fn part1(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n        let carry = (sum + m(p, constants::L.limbs[0])) >> 52;\n        (carry, p)\n    }\n\n    /// Helper function for Montgomery reduction\n    #[inline(always)]\n    fn part2(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let w = (sum as u64) & ((1u64 << 52) - 1);\n        let carry = sum >> 52;\n        (carry, w)\n    }\n\n    /// Compute `a * b` (mod l)\n    #[inline(never)]\n    pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR))\n    }\n\n    /// Compute `a^2` (mod l)\n    #[inline(never)]\n    #[allow(dead_code)] // XXX we don't expose square() via the Scalar API\n    pub fn square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR))\n    }\n\n    /// Compute `(a * b) / R` (mod l), where R is the Montgomery modulus 2^260\n    #[inline(never)]\n    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }\n\n    /// Compute `(a^2) / R` (mod l) in Montgomery form, where R is the Montgomery modulus 2^260\n    #[inline(never)]\n    pub fn montgomery_square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }\n\n    /// Puts a Scalar52 in to Montgomery form, i.e. computes `a*R (mod l)`\n    #[inline(never)]\n    pub fn as_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order(),\n    {\n        proof {\n            lemma_rr_limbs_bounded();\n        }\n        let result = Scalar52::montgomery_mul(self, &constants::RR);\n        assume(to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order());\n        result\n    }\n\n    /// Takes a Scalar52 out of Montgomery form, i.e. computes `a/R (mod l)`\n    #[allow(clippy::wrong_self_convention)]\n    #[inline(never)]\n    pub fn from_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == to_nat(&self.limbs) % group_order(),\n    {\n        let mut limbs = [0u128; 9];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5\n            invariant\n                forall|j: int| #![auto] 0 <= j < i ==> limbs[j] == self.limbs[j] as u128,\n                forall|j: int| #![auto] i <= j < 9 ==> limbs[j] == 0,\n        {\n            limbs[i] = self.limbs[i] as u128;\n        }\n        let result = Scalar52::montgomery_reduce(&limbs);\n        proof {\n            lemma_from_montgomery_limbs_conversion(&limbs, &self.limbs);\n        }\n        result\n    }\n}\n\n\n} // verus!\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    /// Note: x is 2^253-1 which is slightly larger than the largest scalar produced by\n    /// this implementation (l-1), and should show there are no overflows for valid scalars\n    ///\n    /// x = 14474011154664524427946373126085988481658748083205070504932198000989141204991\n    /// x = 7237005577332262213973186563042994240801631723825162898930247062703686954002 mod l\n    /// x = 3057150787695215392275360544382990118917283750546154083604586903220563173085*R mod l in Montgomery form\n    pub static X: Scalar52 = Scalar52 {\n        limbs: [\n            0x000fffffffffffff,\n            0x000fffffffffffff,\n            0x000fffffffffffff,\n            0x000fffffffffffff,\n            0x00001fffffffffff,\n        ],\n    };\n\n    /// x^2 = 3078544782642840487852506753550082162405942681916160040940637093560259278169 mod l\n    pub static XX: Scalar52 = Scalar52 {\n        limbs: [\n            0x0001668020217559,\n            0x000531640ffd0ec0,\n            0x00085fd6f9f38a31,\n            0x000c268f73bb1cf4,\n            0x000006ce65046df0,\n        ],\n    };\n\n    /// x^2 = 4413052134910308800482070043710297189082115023966588301924965890668401540959*R mod l in Montgomery form\n    pub static XX_MONT: Scalar52 = Scalar52 {\n        limbs: [\n            0x000c754eea569a5c,\n            0x00063b6ed36cb215,\n            0x0008ffa36bf25886,\n            0x000e9183614e7543,\n            0x0000061db6c6f26f,\n        ],\n    };\n\n    /// y = 6145104759870991071742105800796537629880401874866217824609283457819451087098\n    pub static Y: Scalar52 = Scalar52 {\n        limbs: [\n            0x000b75071e1458fa,\n            0x000bf9d75e1ecdac,\n            0x000433d2baf0672b,\n            0x0005fffcc11fad13,\n            0x00000d96018bb825,\n        ],\n    };\n\n    /// x*y = 36752150652102274958925982391442301741 mod l\n    pub static XY: Scalar52 = Scalar52 {\n        limbs: [\n            0x000ee6d76ba7632d,\n            0x000ed50d71d84e02,\n            0x00000000001ba634,\n            0x0000000000000000,\n            0x0000000000000000,\n        ],\n    };\n\n    /// x*y = 658448296334113745583381664921721413881518248721417041768778176391714104386*R mod l in Montgomery form\n    pub static XY_MONT: Scalar52 = Scalar52 {\n        limbs: [\n            0x0006d52bf200cfd5,\n            0x00033fb1d7021570,\n            0x000f201bc07139d8,\n            0x0001267e3e49169e,\n            0x000007b839c00268,\n        ],\n    };\n\n    /// a = 2351415481556538453565687241199399922945659411799870114962672658845158063753\n    pub static A: Scalar52 = Scalar52 {\n        limbs: [\n            0x0005236c07b3be89,\n            0x0001bc3d2a67c0c4,\n            0x000a4aa782aae3ee,\n            0x0006b3f6e4fec4c4,\n            0x00000532da9fab8c,\n        ],\n    };\n\n    /// b = 4885590095775723760407499321843594317911456947580037491039278279440296187236\n    pub static B: Scalar52 = Scalar52 {\n        limbs: [\n            0x000d3fae55421564,\n            0x000c2df24f65a4bc,\n            0x0005b5587d69fb0b,\n            0x00094c091b013b3b,\n            0x00000acd25605473,\n        ],\n    };\n\n    /// a+b = 0\n    /// a-b = 4702830963113076907131374482398799845891318823599740229925345317690316127506\n    pub static AB: Scalar52 = Scalar52 {\n        limbs: [\n            0x000a46d80f677d12,\n            0x0003787a54cf8188,\n            0x0004954f0555c7dc,\n            0x000d67edc9fd8989,\n            0x00000a65b53f5718,\n        ],\n    };\n\n    // c = (2^512 - 1) % l = 1627715501170711445284395025044413883736156588369414752970002579683115011840\n    pub static C: Scalar52 = Scalar52 {\n        limbs: [\n            0x000611e3449c0f00,\n            0x000a768859347a40,\n            0x0007f5be65d00e1b,\n            0x0009a3dceec73d21,\n            0x00000399411b7c30,\n        ],\n    };\n\n    #[test]\n    fn mul_max() {\n        let res = Scalar52::mul(&X, &X);\n        for i in 0..5 {\n            assert!(res[i] == XX[i]);\n        }\n    }\n\n    #[test]\n    fn square_max() {\n        let res = X.square();\n        for i in 0..5 {\n            assert!(res[i] == XX[i]);\n        }\n    }\n\n    #[test]\n    fn montgomery_mul_max() {\n        let res = Scalar52::montgomery_mul(&X, &X);\n        for i in 0..5 {\n            assert!(res[i] == XX_MONT[i]);\n        }\n    }\n\n    #[test]\n    fn montgomery_square_max() {\n        let res = X.montgomery_square();\n        for i in 0..5 {\n            assert!(res[i] == XX_MONT[i]);\n        }\n    }\n\n    #[test]\n    fn mul() {\n        let res = Scalar52::mul(&X, &Y);\n        for i in 0..5 {\n            assert!(res[i] == XY[i]);\n        }\n    }\n\n    #[test]\n    fn montgomery_mul() {\n        let res = Scalar52::montgomery_mul(&X, &Y);\n        for i in 0..5 {\n            assert!(res[i] == XY_MONT[i]);\n        }\n    }\n\n    #[test]\n    fn add() {\n        let res = Scalar52::add(&A, &B);\n        let zero = Scalar52::ZERO;\n        for i in 0..5 {\n            assert!(res[i] == zero[i]);\n        }\n    }\n\n    #[test]\n    fn sub() {\n        let res = Scalar52::sub(&A, &B);\n        for i in 0..5 {\n            assert!(res[i] == AB[i]);\n        }\n    }\n\n    #[test]\n    fn from_bytes_wide() {\n        let bignum = [255u8; 64]; // 2^512 - 1\n        let reduced = Scalar52::from_bytes_wide(&bignum);\n        for i in 0..5 {\n            assert!(reduced[i] == C[i]);\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63636": {
    "text": "//! Tell Verus what Choice does\nuse subtle::{Choice, ConditionallySelectable};\n\nuse vstd::prelude::*;\n\nverus! {\n\n\n#[verifier::external_type_specification]\n#[verifier::external_body]\n#[allow(dead_code)]\npub struct ExChoice(Choice);\n\npub uninterp spec fn boolify(c: Choice) -> bool;\n\npub assume_specification [Choice::from](u: u8) -> (c: Choice)\n    ensures u == 0 ==> boolify(c) == false,\n            u == 1 ==> boolify(c) == true;\n\n#[verifier::external_body]\npub fn select(x: &u64, y: &u64, c: Choice) -> (res: u64)\n    ensures boolify(c) ==> res == x,\n            ! boolify(c) ==> res == y\n{\n    u64::conditional_select(x, y, c)\n}\n\n} // verus!\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63637": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Field arithmetic modulo \\\\(p = 2\\^{255} - 19\\\\), using \\\\(64\\\\)-bit\n//! limbs with \\\\(128\\\\)-bit products.\n\nuse core::fmt::Debug;\nuse core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};\nuse core::ops::{Sub, SubAssign};\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\n/// A `FieldElement51` represents an element of the field\n/// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n///\n/// In the 64-bit implementation, a `FieldElement` is represented in\n/// radix \\\\(2\\^{51}\\\\) as five `u64`s; the coefficients are allowed to\n/// grow up to \\\\(2\\^{54}\\\\) between reductions modulo \\\\(p\\\\).\n///\n/// # Note\n///\n/// The `curve25519_dalek::field` module provides a type alias\n/// `curve25519_dalek::field::FieldElement` to either `FieldElement51`\n/// or `FieldElement2625`.\n///\n/// The backend-specific type `FieldElement51` should not be used\n/// outside of the `curve25519_dalek::field` module.\n#[derive(Copy, Clone)]\npub struct FieldElement51(pub(crate) [u64; 5]);\n\nimpl Debug for FieldElement51 {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.0[..])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for FieldElement51 {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}\n\nimpl<'a> AddAssign<&'a FieldElement51> for FieldElement51 {\n    fn add_assign(&mut self, _rhs: &'a FieldElement51) {\n        for i in 0..5 {\n            self.0[i] += _rhs.0[i];\n        }\n    }\n}\n\nimpl<'a> Add<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n    fn add(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }\n}\n\nimpl<'a> SubAssign<&'a FieldElement51> for FieldElement51 {\n    fn sub_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n    }\n}\n\nimpl<'a> Sub<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n    fn sub(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        FieldElement51::reduce([\n            (self.0[0] + 36028797018963664u64) - _rhs.0[0],\n            (self.0[1] + 36028797018963952u64) - _rhs.0[1],\n            (self.0[2] + 36028797018963952u64) - _rhs.0[2],\n            (self.0[3] + 36028797018963952u64) - _rhs.0[3],\n            (self.0[4] + 36028797018963952u64) - _rhs.0[4],\n        ])\n    }\n}\n\nimpl<'a> MulAssign<&'a FieldElement51> for FieldElement51 {\n    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) * _rhs;\n        self.0 = result.0;\n    }\n}\n\nimpl<'a> Mul<&'a FieldElement51> for &FieldElement51 {\n    type Output = FieldElement51;\n\n    #[rustfmt::skip] // keep alignment of c* calculations\n    fn mul(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.0;\n        let b: &[u64; 5] = &_rhs.0;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        // Multiply to get 128-bit coefficients of output\n        let     c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(a[1], b4_19);\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0],  b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(a[2], b4_19);\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1],  b[1]) + m(a[0],  b[2]) + m(a[4], b3_19) + m(a[3], b4_19);\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2],  b[1]) + m(a[1],  b[2]) + m(a[0],  b[3]) + m(a[4], b4_19);\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3],  b[1]) + m(a[2],  b[2]) + m(a[1],  b[3]) + m(a[0] , b[4]);\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));\n        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));\n        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));\n        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));\n        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n        let mut out = [0u64; 5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51(out)\n    }\n}\n\nimpl Neg for &FieldElement51 {\n    type Output = FieldElement51;\n    fn neg(self) -> FieldElement51 {\n        let mut output = *self;\n        output.negate();\n        output\n    }\n}\n\nimpl ConditionallySelectable for FieldElement51 {\n    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        FieldElement51([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }\n\n    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }\n\n    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice) {\n        self.0[0].conditional_assign(&other.0[0], choice);\n        self.0[1].conditional_assign(&other.0[1], choice);\n        self.0[2].conditional_assign(&other.0[2], choice);\n        self.0[3].conditional_assign(&other.0[3], choice);\n        self.0[4].conditional_assign(&other.0[4], choice);\n    }\n}\n\nimpl FieldElement51 {\n    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51(limbs)\n    }\n\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: FieldElement51 = FieldElement51::from_limbs([0, 0, 0, 0, 0]);\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: FieldElement51 = FieldElement51::from_limbs([1, 0, 0, 0, 0]);\n    /// The scalar \\\\( -1 \\\\).\n    pub const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n        2251799813685228,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n        2251799813685247,\n    ]);\n\n    /// Invert the sign of this field element\n    pub fn negate(&mut self) {\n        // See commentary in the Sub impl\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.0[0],\n            36028797018963952u64 - self.0[1],\n            36028797018963952u64 - self.0[2],\n            36028797018963952u64 - self.0[3],\n            36028797018963952u64 - self.0[4],\n        ]);\n        self.0 = neg.0;\n    }\n\n    /// Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).\n    #[inline(always)]\n    fn reduce(mut limbs: [u64; 5]) -> FieldElement51 {\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        FieldElement51(limbs)\n    }\n\n    /// Load a `FieldElement51` from the low 255 bits of a 256-bit\n    /// input.\n    ///\n    /// # Warning\n    ///\n    /// This function does not check that the input used the canonical\n    /// representative.  It masks the high bit, but it will happily\n    /// decode 2^255 - 18 to 1.  Applications that require a canonical\n    /// encoding of every field element should decode, re-encode to\n    /// the canonical encoding, and check that the input was\n    /// canonical.\n    ///\n    #[rustfmt::skip] // keep alignment of bit shifts\n    pub const fn from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }\n\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        FieldElement51(\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ])\n    }\n\n    /// Serialize this `FieldElement51` to a 32-byte array.  The\n    /// encoding is canonical.\n    #[rustfmt::skip] // keep alignment of s[*] calculations\n    pub fn to_bytes(self) -> [u8; 32] {\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.0).0;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }\n\n    /// Given `k > 0`, return `self^(2^k)`.\n    #[rustfmt::skip] // keep alignment of c* calculations\n    pub fn pow2k(&self, mut k: u32) -> FieldElement51 {\n\n        debug_assert!( k > 0 );\n\n        /// Multiply two 64-bit integers with 128 bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }\n\n        let mut a: [u64; 5] = self.0;\n\n        loop {\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n\n            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n\n            k -= 1;\n            if k == 0 {\n                break;\n            }\n        }\n\n        FieldElement51(a)\n    }\n\n    /// Returns the square of this field element.\n    pub fn square(&self) -> FieldElement51 {\n        self.pow2k(1)\n    }\n\n    /// Returns 2 times the square of this field element.\n    pub fn square2(&self) -> FieldElement51 {\n        let mut square = self.pow2k(1);\n        for i in 0..5 {\n            square.0[i] *= 2;\n        }\n\n        square\n    }\n}\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/field.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63638": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! This module contains backend-specific constant values, such as the 64-bit limbs of curve constants.\n\nuse super::field::FieldElement51;\nuse super::scalar::Scalar52;\nuse crate::edwards::EdwardsPoint;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::{\n    backend::serial::curve_models::AffineNielsPoint,\n    edwards::EdwardsBasepointTable,\n    window::{LookupTable, NafLookupTable8},\n};\n\nuse vstd::prelude::*;\n\n/// The value of minus one, equal to `-&FieldElement::ONE`\npub(crate) const MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n    2251799813685228,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n]);\n\n/// sqrt(-486664)\n#[cfg(feature = \"digest\")]\npub(crate) const ED25519_SQRTAM2: FieldElement51 = FieldElement51::from_limbs([\n    1693982333959686,\n    608509411481997,\n    2235573344831311,\n    947681270984193,\n    266558006233600,\n]);\n\n/// Edwards `d` value, equal to `-121665/121666 mod p`.\npub(crate) const EDWARDS_D: FieldElement51 = FieldElement51::from_limbs([\n    929955233495203,\n    466365720129213,\n    1662059464998953,\n    2033849074728123,\n    1442794654840575,\n]);\n\n/// Edwards `2*d` value, equal to `2*(-121665/121666) mod p`.\npub(crate) const EDWARDS_D2: FieldElement51 = FieldElement51::from_limbs([\n    1859910466990425,\n    932731440258426,\n    1072319116312658,\n    1815898335770999,\n    633789495995903,\n]);\n\n/// One minus edwards `d` value squared, equal to `(1 - (-121665/121666) mod p) pow 2`\npub(crate) const ONE_MINUS_EDWARDS_D_SQUARED: FieldElement51 = FieldElement51::from_limbs([\n    1136626929484150,\n    1998550399581263,\n    496427632559748,\n    118527312129759,\n    45110755273534,\n]);\n\n/// Edwards `d` value minus one squared, equal to `(((-121665/121666) mod p) - 1) pow 2`\npub(crate) const EDWARDS_D_MINUS_ONE_SQUARED: FieldElement51 = FieldElement51::from_limbs([\n    1507062230895904,\n    1572317787530805,\n    683053064812840,\n    317374165784489,\n    1572899562415810,\n]);\n\n/// `= sqrt(a*d - 1)`, where `a = -1 (mod p)`, `d` are the Edwards curve parameters.\npub(crate) const SQRT_AD_MINUS_ONE: FieldElement51 = FieldElement51::from_limbs([\n    2241493124984347,\n    425987919032274,\n    2207028919301688,\n    1220490630685848,\n    974799131293748,\n]);\n\n/// `= 1/sqrt(a-d)`, where `a = -1 (mod p)`, `d` are the Edwards curve parameters.\npub(crate) const INVSQRT_A_MINUS_D: FieldElement51 = FieldElement51::from_limbs([\n    278908739862762,\n    821645201101625,\n    8113234426968,\n    1777959178193151,\n    2118520810568447,\n]);\n\n/// Precomputed value of one of the square roots of -1 (mod p)\npub(crate) const SQRT_M1: FieldElement51 = FieldElement51::from_limbs([\n    1718705420411056,\n    234908883556509,\n    2233514472574048,\n    2117202627021982,\n    765476049583133,\n]);\n\n/// `APLUS2_OVER_FOUR` is (A+2)/4. (This is used internally within the Montgomery ladder.)\npub(crate) const APLUS2_OVER_FOUR: FieldElement51 =\n    FieldElement51::from_limbs([121666, 0, 0, 0, 0]);\n\n/// `MONTGOMERY_A` is equal to 486662, which is a constant of the curve equation\n/// for Curve25519 in its Montgomery form. (This is used internally within the\n/// Elligator map.)\npub(crate) const MONTGOMERY_A: FieldElement51 = FieldElement51::from_limbs([486662, 0, 0, 0, 0]);\n\n/// `MONTGOMERY_A_NEG` is equal to -486662. (This is used internally within the\n/// Elligator map.)\npub(crate) const MONTGOMERY_A_NEG: FieldElement51 = FieldElement51::from_limbs([\n    2251799813198567,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n    2251799813685247,\n]);\n\nverus! {\n/// `L` is the order of base point, i.e. 2^252 + 27742317777372353535851937790883648493\npub(crate) const L: Scalar52 = Scalar52 {\n    limbs: [\n        0x0002631a5cf5d3ed,\n        0x000dea2f79cd6581,\n        0x000000000014def9,\n        0x0000000000000000,\n        0x0000100000000000,\n    ],\n};\n\n/// `L` * `LFACTOR` = -1 (mod 2^52)\npub(crate) const LFACTOR: u64 = 0x51da312547e1b;\n\n/// `R` = R % L where R = 2^260\npub(crate) const R: Scalar52 = Scalar52 {\n    limbs: [\n        0x000f48bd6721e6ed,\n        0x0003bab5ac67e45a,\n        0x000fffffeb35e51b,\n        0x000fffffffffffff,\n        0x00000fffffffffff,\n    ],\n};\n\n/// `RR` = (R^2) % L where R = 2^260\npub(crate) const RR: Scalar52 = Scalar52 {\n    limbs: [\n        0x0009d265e952d13b,\n        0x000d63c715bea69f,\n        0x0005be65cb687604,\n        0x0003dceec73d217f,\n        0x000009411b7c309a,\n    ],\n};\n}\n\n/// The Ed25519 basepoint, as an `EdwardsPoint`.\n///\n/// This is called `_POINT` to distinguish it from\n/// `ED25519_BASEPOINT_TABLE`, which should be used for scalar\n/// multiplication (it's much faster).\npub const ED25519_BASEPOINT_POINT: EdwardsPoint = EdwardsPoint {\n    X: FieldElement51::from_limbs([\n        1738742601995546,\n        1146398526822698,\n        2070867633025821,\n        562264141797630,\n        587772402128613,\n    ]),\n    Y: FieldElement51::from_limbs([\n        1801439850948184,\n        1351079888211148,\n        450359962737049,\n        900719925474099,\n        1801439850948198,\n    ]),\n    Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n    T: FieldElement51::from_limbs([\n        1841354044333475,\n        16398895984059,\n        755974180946558,\n        900171276175154,\n        1821297809914039,\n    ]),\n};\n\n/// The 8-torsion subgroup \\\\(\\mathcal E \\[8\\]\\\\).\n///\n/// In the case of Curve25519, it is cyclic; the \\\\(i\\\\)-th element of\n/// the array is \\\\(\\[i\\]P\\\\), where \\\\(P\\\\) is a point of order \\\\(8\\\\)\n/// generating \\\\(\\mathcal E\\[8\\]\\\\).\n///\n/// Thus \\\\(\\mathcal E\\[4\\]\\\\) is the points indexed by `0,2,4,6`, and\n/// \\\\(\\mathcal E\\[2\\]\\\\) is the points indexed by `0,4`.\npub const EIGHT_TORSION: [EdwardsPoint; 8] = EIGHT_TORSION_INNER_DOC_HIDDEN;\n\n/// Inner item used to hide limb constants from cargo doc output.\n#[doc(hidden)]\npub const EIGHT_TORSION_INNER_DOC_HIDDEN: [EdwardsPoint; 8] = [\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Y: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            358744748052810,\n            1691584618240980,\n            977650209285361,\n            1429865912637724,\n            560044844278676,\n        ]),\n        Y: FieldElement51::from_limbs([\n            84926274344903,\n            473620666599931,\n            365590438845504,\n            1028470286882429,\n            2146499180330972,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            1448326834587521,\n            1857896831960481,\n            1093722731865333,\n            1677408490711241,\n            1915505153018406,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            533094393274173,\n            2016890930128738,\n            18285341111199,\n            134597186663265,\n            1486323764102114,\n        ]),\n        Y: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            358744748052810,\n            1691584618240980,\n            977650209285361,\n            1429865912637724,\n            560044844278676,\n        ]),\n        Y: FieldElement51::from_limbs([\n            2166873539340326,\n            1778179147085316,\n            1886209374839743,\n            1223329526802818,\n            105300633354275,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            803472979097708,\n            393902981724766,\n            1158077081819914,\n            574391322974006,\n            336294660666841,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Y: FieldElement51::from_limbs([\n            2251799813685228,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n            2251799813685247,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1893055065632419,\n            560215195444267,\n            1274149604399886,\n            821933901047523,\n            1691754969406571,\n        ]),\n        Y: FieldElement51::from_limbs([\n            2166873539340326,\n            1778179147085316,\n            1886209374839743,\n            1223329526802818,\n            105300633354275,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            1448326834587521,\n            1857896831960481,\n            1093722731865333,\n            1677408490711241,\n            1915505153018406,\n        ]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1718705420411056,\n            234908883556509,\n            2233514472574048,\n            2117202627021982,\n            765476049583133,\n        ]),\n        Y: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([0, 0, 0, 0, 0]),\n    },\n    EdwardsPoint {\n        X: FieldElement51::from_limbs([\n            1893055065632419,\n            560215195444267,\n            1274149604399886,\n            821933901047523,\n            1691754969406571,\n        ]),\n        Y: FieldElement51::from_limbs([\n            84926274344903,\n            473620666599931,\n            365590438845504,\n            1028470286882429,\n            2146499180330972,\n        ]),\n        Z: FieldElement51::from_limbs([1, 0, 0, 0, 0]),\n        T: FieldElement51::from_limbs([\n            803472979097708,\n            393902981724766,\n            1158077081819914,\n            574391322974006,\n            336294660666841,\n        ]),\n    },\n];\n\n/// Table containing precomputed multiples of the Ed25519 basepoint \\\\(B = (x, 4/5)\\\\).\n#[cfg(feature = \"precomputed-tables\")]\npub static ED25519_BASEPOINT_TABLE: &EdwardsBasepointTable =\n    &ED25519_BASEPOINT_TABLE_INNER_DOC_HIDDEN;\n\n/// Inner constant, used to avoid filling the docs with precomputed points.\n#[doc(hidden)]\n#[cfg(feature = \"precomputed-tables\")]\nstatic ED25519_BASEPOINT_TABLE_INNER_DOC_HIDDEN: EdwardsBasepointTable = EdwardsBasepointTable([\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3540182452943730,\n                2497478415033846,\n                2521227595762870,\n                1462984067271729,\n                2389212253076811,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                62697248952638,\n                204681361388450,\n                631292143396476,\n                338455783676468,\n                1213667448819585,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                301289933810280,\n                1259582250014073,\n                1422107436869536,\n                796239922652654,\n                1953934009299142,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3632771708514775,\n                790832306631235,\n                2067202295274102,\n                1995808275510000,\n                1566530869037010,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                463307831301544,\n                432984605774163,\n                1610641361907204,\n                750899048855000,\n                1894842303421586,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                748439484463711,\n                1033211726465151,\n                1396005112841647,\n                1611506220286469,\n                1972177495910992,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1601611775252272,\n                1720807796594148,\n                1132070835939856,\n                3512254832574799,\n                2147779492816910,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                316559037616741,\n                2177824224946892,\n                1459442586438991,\n                1461528397712656,\n                751590696113597,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1850748884277385,\n                1200145853858453,\n                1068094770532492,\n                672251375690438,\n                1586055907191707,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                934282339813791,\n                1846903124198670,\n                1172395437954843,\n                1007037127761661,\n                1830588347719256,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1694390458783935,\n                1735906047636159,\n                705069562067493,\n                648033061693059,\n                696214010414170,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1121406372216585,\n                192876649532226,\n                190294192191717,\n                1994165897297032,\n                2245000007398739,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                769950342298400,\n                2384754244604994,\n                3095885746880802,\n                3225892188161580,\n                2977876099231263,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                425251763115706,\n                608463272472562,\n                442562545713235,\n                837766094556764,\n                374555092627893,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1086255230780037,\n                274979815921559,\n                1960002765731872,\n                929474102396301,\n                1190409889297339,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1388594989461809,\n                316767091099457,\n                2646098655878230,\n                1230079486801004,\n                1440737038838979,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                7380825640100,\n                146210432690483,\n                304903576448906,\n                1198869323871120,\n                997689833219095,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1181317918772081,\n                114573476638901,\n                262805072233344,\n                265712217171332,\n                294181933805782,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2916800678241215,\n                2065379846933858,\n                2622030924071124,\n                2602788184473875,\n                1233371373142984,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2019367628972465,\n                676711900706637,\n                110710997811333,\n                1108646842542025,\n                517791959672113,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                965130719900578,\n                247011430587952,\n                526356006571389,\n                91986625355052,\n                2157223321444601,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4320419353804412,\n                4218074731744053,\n                957728544705548,\n                729906502578991,\n                2411634706750414,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2073601412052185,\n                31021124762708,\n                264500969797082,\n                248034690651703,\n                1030252227928288,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                551790716293402,\n                1989538725166328,\n                801169423371717,\n                2052451893578887,\n                678432056995012,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1368953770187805,\n                3042147450398169,\n                2689308289352409,\n                2142576377050579,\n                1932081720066286,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                953638594433374,\n                1092333936795051,\n                1419774766716690,\n                805677984380077,\n                859228993502513,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1200766035879111,\n                20142053207432,\n                1465634435977050,\n                1645256912097844,\n                295121984874596,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1735718747031538,\n                1248237894295956,\n                1204753118328107,\n                976066523550493,\n                2317743583219840,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1060098822528990,\n                1586825862073490,\n                212301317240126,\n                1975302711403555,\n                666724059764335,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1091990273418756,\n                1572899409348578,\n                80968014455247,\n                306009358661350,\n                1520450739132526,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3732317023121341,\n                1511153322193951,\n                3496143672676420,\n                2556587964178488,\n                2620936670181690,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2151330273626164,\n                762045184746182,\n                1688074332551515,\n                823046109005759,\n                907602769079491,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2047386910586836,\n                168470092900250,\n                1552838872594810,\n                340951180073789,\n                360819374702533,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1982622644432037,\n                2014393600336956,\n                2380709022489462,\n                3869592437614438,\n                2357094095599062,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                980234343912898,\n                1712256739246056,\n                588935272190264,\n                204298813091998,\n                841798321043288,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                197561292938973,\n                454817274782871,\n                1963754960082318,\n                2113372252160468,\n                971377527342673,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2416499262514576,\n                2254927265442919,\n                3451304785234000,\n                1766155447043651,\n                1899238924683527,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                732262946680281,\n                1674412764227063,\n                2182456405662809,\n                1350894754474250,\n                558458873295247,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2103305098582922,\n                1960809151316468,\n                715134605001343,\n                1454892949167181,\n                40827143824949,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1239289043050193,\n                1744654158124578,\n                758702410031698,\n                4048562808759936,\n                2253402870349013,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2232056027107988,\n                987343914584615,\n                2115594492994461,\n                1819598072792159,\n                1119305654014850,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                320153677847348,\n                939613871605645,\n                641883205761567,\n                1930009789398224,\n                329165806634126,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3232730304159378,\n                1242488692177892,\n                1251446316964684,\n                1086618677993530,\n                1961430968465772,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                276821765317453,\n                1536835591188030,\n                1305212741412361,\n                61473904210175,\n                2051377036983058,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                833449923882501,\n                1750270368490475,\n                1123347002068295,\n                185477424765687,\n                278090826653186,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                794524995833413,\n                1849907304548286,\n                2305148486158393,\n                1272368559505216,\n                1147304168324779,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1504846112759364,\n                1203096289004681,\n                562139421471418,\n                274333017451844,\n                1284344053775441,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                483048732424432,\n                2116063063343382,\n                30120189902313,\n                292451576741007,\n                1156379271702225,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3180171966714267,\n                2147692869914563,\n                1455665844462196,\n                1986737809425946,\n                2437006863943337,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                137732961814206,\n                706670923917341,\n                1387038086865771,\n                1965643813686352,\n                1384777115696347,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                481144981981577,\n                2053319313589856,\n                2065402289827512,\n                617954271490316,\n                1106602634668125,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2948097833334040,\n                3145099472726142,\n                1148636718636008,\n                2278533891034865,\n                2203955659340680,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                657390353372855,\n                998499966885562,\n                991893336905797,\n                810470207106761,\n                343139804608786,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                791736669492960,\n                934767652997115,\n                824656780392914,\n                1759463253018643,\n                361530362383518,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2022541353055578,\n                4346500076272714,\n                3802807888710933,\n                2494585331103411,\n                2947785218648809,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1287487199965223,\n                2215311941380308,\n                1552928390931986,\n                1664859529680196,\n                1125004975265243,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                677434665154918,\n                989582503122485,\n                1817429540898386,\n                1052904935475344,\n                1143826298169798,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2619066141993637,\n                2570231002607651,\n                2947429167440602,\n                2885885471266079,\n                2276381426249673,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                773360688841258,\n                1815381330538070,\n                363773437667376,\n                539629987070205,\n                783280434248437,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                180820816194166,\n                168937968377394,\n                748416242794470,\n                1227281252254508,\n                1567587861004268,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2730575372268893,\n                2062896624554806,\n                2951191072970647,\n                2609899222113120,\n                1277310261461760,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1984740906540026,\n                1079164179400229,\n                1056021349262661,\n                1659958556483663,\n                1088529069025527,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                580736401511151,\n                1842931091388998,\n                1177201471228238,\n                2075460256527244,\n                1301133425678027,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1515728832059163,\n                1575261009617579,\n                1510246567196186,\n                2442877836294952,\n                2368461529974388,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1295295738269652,\n                1714742313707026,\n                545583042462581,\n                2034411676262552,\n                1513248090013606,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                230710545179830,\n                30821514358353,\n                760704303452229,\n                390668103790604,\n                573437871383156,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3421179921230875,\n                2514967047430861,\n                4274701112739695,\n                3071700566936367,\n                4275698278559832,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2102254323485823,\n                1570832666216754,\n                34696906544624,\n                1993213739807337,\n                70638552271463,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                894132856735058,\n                548675863558441,\n                845349339503395,\n                1942269668326667,\n                1615682209874691,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3539470031223082,\n                1222355136884919,\n                1846481788678694,\n                1150426571265110,\n                1613523400722047,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                793388516527298,\n                1315457083650035,\n                1972286999342417,\n                1901825953052455,\n                338269477222410,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                550201530671806,\n                778605267108140,\n                2063911101902983,\n                115500557286349,\n                2041641272971022,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                717255318455100,\n                519313764361315,\n                2080406977303708,\n                541981206705521,\n                774328150311600,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                261715221532238,\n                1795354330069993,\n                1496878026850283,\n                499739720521052,\n                389031152673770,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1997217696294013,\n                1717306351628065,\n                1684313917746180,\n                1644426076011410,\n                1857378133465451,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3727234538477877,\n                2328731709971226,\n                3368528843456914,\n                2002544139318041,\n                2977347647489186,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2022306639183567,\n                726296063571875,\n                315345054448644,\n                1058733329149221,\n                1448201136060677,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1710065158525665,\n                1895094923036397,\n                123988286168546,\n                1145519900776355,\n                1607510767693874,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2813405189107769,\n                1071733543815036,\n                2383296312486238,\n                1946868434569998,\n                3079937947649451,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1548495173745801,\n                442310529226540,\n                998072547000384,\n                553054358385281,\n                644824326376171,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1445526537029440,\n                2225519789662536,\n                914628859347385,\n                1064754194555068,\n                1660295614401091,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3451490036797185,\n                2275827949507588,\n                2318438102929588,\n                2309425969971222,\n                2816893781664854,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                876926774220824,\n                554618976488214,\n                1012056309841565,\n                839961821554611,\n                1414499340307677,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                703047626104145,\n                1266841406201770,\n                165556500219173,\n                486991595001879,\n                1011325891650656,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1622861044480487,\n                1156394801573634,\n                4120932379100752,\n                2578903799462977,\n                2095342781472283,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                334886927423922,\n                489511099221528,\n                129160865966726,\n                1720809113143481,\n                619700195649254,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1646545795166119,\n                1758370782583567,\n                714746174550637,\n                1472693650165135,\n                898994790308209,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2585203586724508,\n                2547572356138185,\n                1693106465353609,\n                912330357530760,\n                2723035471635610,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1811196219982022,\n                1068969825533602,\n                289602974833439,\n                1988956043611592,\n                863562343398367,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                906282429780072,\n                2108672665779781,\n                432396390473936,\n                150625823801893,\n                1708930497638539,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                925664675702309,\n                2273216662253932,\n                4083236455546587,\n                601157008940112,\n                2623617868729744,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1479786007267725,\n                1738881859066675,\n                68646196476567,\n                2146507056100328,\n                1247662817535471,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                52035296774456,\n                939969390708103,\n                312023458773250,\n                59873523517659,\n                1231345905848899,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2895154920100990,\n                2541986621181021,\n                2013561737429022,\n                2571447883196794,\n                2645536492181409,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                129358342392716,\n                1932811617704777,\n                1176749390799681,\n                398040349861790,\n                1170779668090425,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2051980782668029,\n                121859921510665,\n                2048329875753063,\n                1235229850149665,\n                519062146124755,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3859970785658325,\n                2667608874045675,\n                1350468408164765,\n                2038620059057678,\n                3278704299674360,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1837656083115103,\n                1510134048812070,\n                906263674192061,\n                1821064197805734,\n                565375124676301,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                578027192365650,\n                2034800251375322,\n                2128954087207123,\n                478816193810521,\n                2196171989962750,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1633188840273120,\n                3104586986058956,\n                1548762607215795,\n                1266275218902681,\n                3359018017010381,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                462189358480054,\n                1784816734159228,\n                1611334301651368,\n                1303938263943540,\n                707589560319424,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1038829280972848,\n                38176604650029,\n                753193246598573,\n                1136076426528122,\n                595709990562434,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3660251634545082,\n                2194984964010832,\n                2198361797561729,\n                1061962440055713,\n                1645147963442934,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                4701053362120,\n                1647641066302348,\n                1047553002242085,\n                1923635013395977,\n                206970314902065,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1750479161778571,\n                1362553355169293,\n                1891721260220598,\n                966109370862782,\n                1024913988299801,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2464498862816952,\n                1117950018299774,\n                1873945661751056,\n                3655602735669306,\n                2382695896337945,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                636808533673210,\n                1262201711667560,\n                390951380330599,\n                1663420692697294,\n                561951321757406,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                520731594438141,\n                1446301499955692,\n                273753264629267,\n                1565101517999256,\n                1019411827004672,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3178327305714638,\n                3443653291096626,\n                734233225181170,\n                2435838701226518,\n                4042225960010590,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1464651961852572,\n                1483737295721717,\n                1519450561335517,\n                1161429831763785,\n                405914998179977,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                996126634382301,\n                796204125879525,\n                127517800546509,\n                344155944689303,\n                615279846169038,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2990523894660505,\n                2188666632415295,\n                1961313708559162,\n                1506545807547587,\n                3403101452654988,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                622917337413835,\n                1218989177089035,\n                1284857712846592,\n                970502061709359,\n                351025208117090,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2067814584765580,\n                1677855129927492,\n                2086109782475197,\n                235286517313238,\n                1416314046739645,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2838644076315587,\n                2559244195637442,\n                458399356043425,\n                2853867838192310,\n                3280348017100490,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                678489922928203,\n                2016657584724032,\n                90977383049628,\n                1026831907234582,\n                615271492942522,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                301225714012278,\n                1094837270268560,\n                1202288391010439,\n                644352775178361,\n                1647055902137983,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1210746697896459,\n                1416608304244708,\n                2938287290903104,\n                3496931005119382,\n                3303038150540984,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1135604073198207,\n                1683322080485474,\n                769147804376683,\n                2086688130589414,\n                900445683120379,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1971518477615628,\n                401909519527336,\n                448627091057375,\n                1409486868273821,\n                1214789035034363,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1364039144731711,\n                1897497433586190,\n                2203097701135459,\n                2397261210496499,\n                1349844460790698,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1045230323257973,\n                818206601145807,\n                630513189076103,\n                1672046528998132,\n                807204017562437,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                439961968385997,\n                386362664488986,\n                1382706320807688,\n                309894000125359,\n                2207801346498567,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3480804500082836,\n                3172443782216110,\n                2375775707596425,\n                2933223806901024,\n                1400559197080972,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2003766096898049,\n                170074059235165,\n                1141124258967971,\n                1485419893480973,\n                1573762821028725,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                729905708611432,\n                1270323270673202,\n                123353058984288,\n                426460209632942,\n                2195574535456672,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1271140255321216,\n                2044363183174497,\n                2303925201319937,\n                3696920060379952,\n                3194341800024331,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1761608437466135,\n                583360847526804,\n                1586706389685493,\n                2157056599579261,\n                1170692369685772,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                871476219910823,\n                1878769545097794,\n                2241832391238412,\n                548957640601001,\n                690047440233174,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2548994545820755,\n                1366347803776819,\n                3552985325930849,\n                561849853336293,\n                1533554921345731,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                999628998628371,\n                1132836708493400,\n                2084741674517453,\n                469343353015612,\n                678782988708035,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2189427607417022,\n                699801937082607,\n                412764402319267,\n                1478091893643349,\n                2244675696854460,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3964091869651792,\n                2456213404310121,\n                3657538451018088,\n                2660781114515010,\n                3112882032961968,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                508561155940631,\n                966928475686665,\n                2236717801150132,\n                424543858577297,\n                2089272956986143,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                221245220129925,\n                1156020201681217,\n                491145634799213,\n                542422431960839,\n                828100817819207,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2405556784925632,\n                1299874139923976,\n                2644898978945750,\n                1058234455773021,\n                996989038681183,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                559086812798481,\n                573177704212711,\n                1629737083816402,\n                1399819713462595,\n                1646954378266038,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1887963056288059,\n                228507035730124,\n                1468368348640282,\n                930557653420194,\n                613513962454686,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1224529808187534,\n                1577022856702685,\n                2206946542980843,\n                625883007765001,\n                2531730607197406,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1076287717051609,\n                1114455570543035,\n                187297059715481,\n                250446884292121,\n                1885187512550540,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                902497362940219,\n                76749815795675,\n                1657927525633846,\n                1420238379745202,\n                1340321636548352,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1129576631190765,\n                3533793823712575,\n                996844254743017,\n                2509676177174497,\n                3402650555740265,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                628740660038789,\n                1943038498527841,\n                467786347793886,\n                1093341428303375,\n                235413859513003,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                237425418909360,\n                469614029179605,\n                1512389769174935,\n                1241726368345357,\n                441602891065214,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3988217766743784,\n                726531315520507,\n                1833335034432527,\n                1629442561574747,\n                2876218732971333,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1960754663920689,\n                497040957888962,\n                1909832851283095,\n                1271432136996826,\n                2219780368020940,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1537037379417136,\n                1358865369268262,\n                2130838645654099,\n                828733687040705,\n                1999987652890901,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                629042105241795,\n                1098854999137608,\n                887281544569320,\n                3674901833560025,\n                2259711072636808,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1811562332665373,\n                1501882019007673,\n                2213763501088999,\n                359573079719636,\n                36370565049116,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                218907117361280,\n                1209298913016966,\n                1944312619096112,\n                1130690631451061,\n                1342327389191701,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1369976867854685,\n                1396479602419169,\n                4017456468084104,\n                2203659200586298,\n                3250127649802489,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2230701885562825,\n                1348173180338974,\n                2172856128624598,\n                1426538746123771,\n                444193481326151,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                784210426627951,\n                918204562375674,\n                1284546780452985,\n                1324534636134684,\n                1872449409642708,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2571438643225542,\n                2848082470493653,\n                2037902696412607,\n                1557219121643918,\n                341938082688094,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1901860206695915,\n                2004489122065736,\n                1625847061568236,\n                973529743399879,\n                2075287685312905,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1371853944110545,\n                1042332820512553,\n                1949855697918254,\n                1791195775521505,\n                37487364849293,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                687200189577836,\n                1082536651125675,\n                2896024754556794,\n                2592723009743198,\n                2595381160432643,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2082717129583892,\n                27829425539422,\n                145655066671970,\n                1690527209845512,\n                1865260509673478,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1059729620568824,\n                2163709103470266,\n                1440302280256872,\n                1769143160546397,\n                869830310425069,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3861316033464273,\n                777277757338816,\n                2101121130363987,\n                550762194946473,\n                1905542338659364,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2024821921041576,\n                426948675450149,\n                595133284085473,\n                471860860885970,\n                600321679413000,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                598474602406721,\n                1468128276358244,\n                1191923149557635,\n                1501376424093216,\n                1281662691293476,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1721138489890688,\n                1264336102277790,\n                2684864359106535,\n                1359988423149465,\n                3813671107094695,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                719520245587143,\n                393380711632345,\n                132350400863381,\n                1543271270810729,\n                1819543295798660,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                396397949784152,\n                1811354474471839,\n                1362679985304303,\n                2117033964846756,\n                498041172552279,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1812471844975748,\n                1856491995543149,\n                126579494584102,\n                3288044672967868,\n                1975108050082549,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                650623932407995,\n                1137551288410575,\n                2125223403615539,\n                1725658013221271,\n                2134892965117796,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                522584000310195,\n                1241762481390450,\n                1743702789495384,\n                2227404127826575,\n                1686746002148897,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                427904865186293,\n                1703211129693455,\n                1585368107547509,\n                3688784302429584,\n                3012988348299225,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                318101947455002,\n                248138407995851,\n                1481904195303927,\n                309278454311197,\n                1258516760217879,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1275068538599310,\n                513726919533379,\n                349926553492294,\n                688428871968420,\n                1702400196000666,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3313663849950481,\n                3213411074010628,\n                2573659446386085,\n                3297400443644764,\n                1985130202504037,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1558816436882417,\n                1962896332636523,\n                1337709822062152,\n                1501413830776938,\n                294436165831932,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                818359826554971,\n                1862173000996177,\n                626821592884859,\n                573655738872376,\n                1749691246745455,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1988022651432119,\n                3333911312271288,\n                1834020786104820,\n                3706626690108935,\n                692929915223121,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2146513703733331,\n                584788900394667,\n                464965657279958,\n                2183973639356127,\n                238371159456790,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1129007025494441,\n                2197883144413266,\n                265142755578169,\n                971864464758890,\n                1983715884903702,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1291366624493056,\n                2633256531874362,\n                1711482489312443,\n                1815233647702022,\n                3144079596677715,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                444548969917454,\n                1452286453853356,\n                2113731441506810,\n                645188273895859,\n                810317625309512,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2242724082797924,\n                1373354730327868,\n                1006520110883049,\n                2147330369940688,\n                1151816104883620,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3997520014069025,\n                4163522956860564,\n                2056329390702073,\n                2607026987995097,\n                3131032608056347,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                163723479936298,\n                115424889803150,\n                1156016391581227,\n                1894942220753364,\n                1970549419986329,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                681981452362484,\n                267208874112496,\n                1374683991933094,\n                638600984916117,\n                646178654558546,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2265178468539480,\n                2358037120714814,\n                1944412051589650,\n                4093776581610705,\n                2482502633520820,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                260683893467075,\n                854060306077237,\n                913639551980112,\n                4704576840123,\n                280254810808712,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                715374893080287,\n                1173334812210491,\n                1806524662079626,\n                1894596008000979,\n                398905715033393,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2751826223412909,\n                3848231101880618,\n                1420380351989369,\n                3237011375206737,\n                392444930785632,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2096421546958141,\n                1922523000950363,\n                789831022876840,\n                427295144688779,\n                320923973161730,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1927770723575450,\n                1485792977512719,\n                1850996108474547,\n                551696031508956,\n                2126047405475647,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2112099158080129,\n                2994370617594963,\n                2258284371762679,\n                1951119898618915,\n                2344890196388664,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                383905201636970,\n                859946997631870,\n                855623867637644,\n                1017125780577795,\n                794250831877809,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                77571826285752,\n                999304298101753,\n                487841111777762,\n                1038031143212339,\n                339066367948762,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2926794589205781,\n                2517835660016036,\n                826951213393477,\n                1405007746162285,\n                1781791018620876,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1001412661522686,\n                348196197067298,\n                1666614366723946,\n                888424995032760,\n                580747687801357,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1939560076207777,\n                1409892634407635,\n                552574736069277,\n                383854338280405,\n                190706709864139,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2177087163428741,\n                1439255351721944,\n                3459870654068041,\n                2230616362004768,\n                1396886392021913,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                676962063230039,\n                1880275537148808,\n                2046721011602706,\n                888463247083003,\n                1318301552024067,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1466980508178206,\n                617045217998949,\n                652303580573628,\n                757303753529064,\n                207583137376902,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3762856566592150,\n                2357202940576524,\n                2745234706458093,\n                1091943425335975,\n                1802717338077427,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1853982405405128,\n                1878664056251147,\n                1528011020803992,\n                1019626468153565,\n                1128438412189035,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1963939888391106,\n                293456433791664,\n                697897559513649,\n                985882796904380,\n                796244541237972,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2668570812315008,\n                2641455366112301,\n                1314476859406755,\n                1749382513022778,\n                3413705412424739,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1428358296490651,\n                1027115282420478,\n                304840698058337,\n                441410174026628,\n                1819358356278573,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                204943430200135,\n                1554861433819175,\n                216426658514651,\n                264149070665950,\n                2047097371738319,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1934415182909015,\n                1393285083565062,\n                2768209145458208,\n                3409490548679139,\n                2372839480279515,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                662035583584445,\n                286736105093098,\n                1131773000510616,\n                818494214211439,\n                472943792054479,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                665784778135882,\n                1893179629898606,\n                808313193813106,\n                276797254706413,\n                1563426179676396,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                945205108984213,\n                2778077376644543,\n                1324180513733565,\n                1666970227868664,\n                2405347422974421,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2031433403516252,\n                203996615228162,\n                170487168837083,\n                981513604791390,\n                843573964916831,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1476570093962618,\n                838514669399805,\n                1857930577281364,\n                2017007352225784,\n                317085545220047,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1461557121912823,\n                1600674043318359,\n                2157134900399597,\n                1670641601940616,\n                2379565397488531,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1293543509393474,\n                2143624609202546,\n                1058361566797508,\n                214097127393994,\n                946888515472729,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                357067959932916,\n                1290876214345711,\n                521245575443703,\n                1494975468601005,\n                800942377643885,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2817916472785262,\n                820247422481739,\n                994464017954148,\n                2578957425371613,\n                2344391131796991,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                617256647603209,\n                1652107761099439,\n                1857213046645471,\n                1085597175214970,\n                817432759830522,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                771808161440705,\n                1323510426395069,\n                680497615846440,\n                851580615547985,\n                1320806384849017,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1219260086131896,\n                2898968820282063,\n                2331400938444953,\n                2161724213426747,\n                2656661710745446,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1327968293887866,\n                1335500852943256,\n                1401587164534264,\n                558137311952440,\n                1551360549268902,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                417621685193956,\n                1429953819744454,\n                396157358457099,\n                1940470778873255,\n                214000046234152,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1268047918491954,\n                2172375426948536,\n                1533916099229249,\n                1761293575457130,\n                3842422480712013,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1627072914981959,\n                2211603081280073,\n                1912369601616504,\n                1191770436221309,\n                2187309757525860,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1149147819689533,\n                378692712667677,\n                828475842424202,\n                2218619146419342,\n                70688125792186,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3551539230764990,\n                3690416477138006,\n                3788528892189659,\n                2053896748919837,\n                3260220846276494,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2040723824657366,\n                399555637875075,\n                632543375452995,\n                872649937008051,\n                1235394727030233,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2211311599327900,\n                2139787259888175,\n                938706616835350,\n                12609661139114,\n                2081897930719789,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1324994503390431,\n                2588782144267879,\n                1183998925654176,\n                3343454479598522,\n                2300527487656566,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1845522914617879,\n                1222198248335542,\n                150841072760134,\n                1927029069940982,\n                1189913404498011,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1079559557592645,\n                2215338383666441,\n                1903569501302605,\n                49033973033940,\n                305703433934152,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2346453219102138,\n                3637921163538246,\n                3313930291577009,\n                2288353761164521,\n                3085469462634093,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1432015813136298,\n                440364795295369,\n                1395647062821501,\n                1976874522764578,\n                934452372723352,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1296625309219774,\n                2068273464883862,\n                1858621048097805,\n                1492281814208508,\n                2235868981918946,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1490330266465551,\n                1858795661361448,\n                3688040948655011,\n                2546373032584894,\n                3459939824714180,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1282462923712748,\n                741885683986255,\n                2027754642827561,\n                518989529541027,\n                1826610009555945,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1525827120027511,\n                723686461809551,\n                1597702369236987,\n                244802101764964,\n                1502833890372311,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2365421849929742,\n                3485539881431101,\n                2925909765963743,\n                2114345180342964,\n                2418564326541511,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2041668749310338,\n                2184405322203901,\n                1633400637611036,\n                2110682505536899,\n                2048144390084644,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                503058759232932,\n                760293024620937,\n                2027152777219493,\n                666858468148475,\n                1539184379870952,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1916168475367211,\n                3167426246226591,\n                883217071712574,\n                363427871374304,\n                1976029821251593,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                678039535434506,\n                570587290189340,\n                1605302676614120,\n                2147762562875701,\n                1706063797091704,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1439489648586438,\n                2194580753290951,\n                832380563557396,\n                561521973970522,\n                584497280718389,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2439789269177838,\n                681223515948274,\n                1933493571072456,\n                1872921007304880,\n                2739962177820919,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1413466089534451,\n                410844090765630,\n                1397263346404072,\n                408227143123410,\n                1594561803147811,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2102170800973153,\n                719462588665004,\n                1479649438510153,\n                1097529543970028,\n                1302363283777685,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3193865531532443,\n                3321113493038208,\n                2007341951411050,\n                2322773230131539,\n                1419433790163705,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1146565545556377,\n                1661971299445212,\n                406681704748893,\n                564452436406089,\n                1109109865829139,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2214421081775077,\n                1165671861210569,\n                1890453018796184,\n                3556249878661,\n                442116172656317,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3005630360306059,\n                1666955059895018,\n                1530775289309243,\n                3371786842789394,\n                2164156153857579,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                615171919212796,\n                1523849404854568,\n                854560460547503,\n                2067097370290715,\n                1765325848586042,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1094538949313667,\n                1796592198908825,\n                870221004284388,\n                2025558921863561,\n                1699010892802384,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1951351290725195,\n                1916457206844795,\n                2449824998123274,\n                1909076887557594,\n                1938542290318919,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1014323197538413,\n                869150639940606,\n                1756009942696599,\n                1334952557375672,\n                1544945379082874,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                764055910920305,\n                1603590757375439,\n                146805246592357,\n                1843313433854297,\n                954279890114939,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                80113526615731,\n                764536758732259,\n                3306939158785481,\n                2721052465444637,\n                2869697326116762,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                74497112547268,\n                740094153192149,\n                1745254631717581,\n                727713886503130,\n                1283034364416928,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                525892105991110,\n                1723776830270342,\n                1476444848991936,\n                573789489857760,\n                133864092632978,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2794411533877810,\n                1986812262899320,\n                1162535242465837,\n                2733298779828712,\n                2796400347268869,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                64123227344372,\n                1239927720647794,\n                1360722983445904,\n                222610813654661,\n                62429487187991,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1793193323953132,\n                91096687857833,\n                70945970938921,\n                2158587638946380,\n                1537042406482111,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1895854577604590,\n                3646695522634664,\n                1728548428495943,\n                3392664713925397,\n                2815445147288308,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                141358280486863,\n                91435889572504,\n                1087208572552643,\n                1829599652522921,\n                1193307020643647,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1611230858525381,\n                950720175540785,\n                499589887488610,\n                2001656988495019,\n                88977313255908,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3440880315164906,\n                2184348804772596,\n                3292618539427567,\n                2018318290311833,\n                1712060030915354,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                873966876953756,\n                1090638350350440,\n                1708559325189137,\n                672344594801910,\n                1320437969700239,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1508590048271766,\n                1131769479776094,\n                101550868699323,\n                428297785557897,\n                561791648661744,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3008217384184691,\n                2489682092917849,\n                2136263418594015,\n                1701968045454886,\n                2955512998822720,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1781187809325462,\n                1697624151492346,\n                1381393690939988,\n                175194132284669,\n                1483054666415238,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2175517777364616,\n                708781536456029,\n                955668231122942,\n                1967557500069555,\n                2021208005604118,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3366935780292116,\n                2476017186636029,\n                915967306279221,\n                593866251291540,\n                2813546907893254,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1443163092879439,\n                391875531646162,\n                2180847134654632,\n                464538543018753,\n                1594098196837178,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                850858855888869,\n                319436476624586,\n                327807784938441,\n                740785849558761,\n                17128415486016,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2132756334090048,\n                2788047633840893,\n                2300706964962114,\n                2860273011285942,\n                3513489358708031,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1525176236978354,\n                974205476721062,\n                293436255662638,\n                148269621098039,\n                137961998433963,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1121075518299410,\n                2071745529082111,\n                1265567917414828,\n                1648196578317805,\n                496232102750820,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2374121042985030,\n                3274721891178932,\n                2001275453369483,\n                2017441881607947,\n                3245005694463250,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                654925550560074,\n                1168810995576858,\n                575655959430926,\n                905758704861388,\n                496774564663534,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1954109525779738,\n                2117022646152485,\n                338102630417180,\n                1194140505732026,\n                107881734943492,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1714785840001267,\n                4288299832366837,\n                1876380234251965,\n                2056717182974196,\n                1645855254384642,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                106431476499341,\n                62482972120563,\n                1513446655109411,\n                807258751769522,\n                538491469114,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2002850762893643,\n                1243624520538135,\n                1486040410574605,\n                2184752338181213,\n                378495998083531,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                922510868424903,\n                1089502620807680,\n                402544072617374,\n                1131446598479839,\n                1290278588136533,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1867998812076769,\n                715425053580701,\n                39968586461416,\n                2173068014586163,\n                653822651801304,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                162892278589453,\n                182585796682149,\n                75093073137630,\n                497037941226502,\n                133871727117371,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4166396390264918,\n                1608999621851577,\n                1987629837704609,\n                1519655314857977,\n                1819193753409464,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1949315551096831,\n                1069003344994464,\n                1939165033499916,\n                1548227205730856,\n                1933767655861407,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1730519386931635,\n                1393284965610134,\n                1597143735726030,\n                416032382447158,\n                1429665248828629,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                360275475604546,\n                2799635544748326,\n                2467160717872776,\n                2848446553564254,\n                2584509464110332,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                47602113726801,\n                1522314509708010,\n                437706261372925,\n                814035330438027,\n                335930650933545,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1291597595523886,\n                1058020588994081,\n                402837842324045,\n                1363323695882781,\n                2105763393033193,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2361321796251793,\n                3967057562270386,\n                1112231216891515,\n                2046641005101484,\n                2386048970842261,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2156991030936798,\n                2227544497153325,\n                1869050094431622,\n                754875860479115,\n                1754242344267058,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1846089562873800,\n                98894784984326,\n                1412430299204844,\n                171351226625762,\n                1100604760929008,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2335972195815721,\n                2751510784385293,\n                425749630620777,\n                1762872794206857,\n                2864642415813208,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                868309334532756,\n                1703010512741873,\n                1952690008738057,\n                4325269926064,\n                2071083554962116,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                523094549451158,\n                401938899487815,\n                1407690589076010,\n                2022387426254453,\n                158660516411257,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                612867287630009,\n                2700012425789062,\n                2823428891104443,\n                1466796750919375,\n                1728478129663858,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1723848973783452,\n                2208822520534681,\n                1718748322776940,\n                1974268454121942,\n                1194212502258141,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1254114807944608,\n                977770684047110,\n                2010756238954993,\n                1783628927194099,\n                1525962994408256,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2484263871921055,\n                1948628555342433,\n                1835348780427694,\n                1031609499437291,\n                2316271920603621,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                767338676040683,\n                754089548318405,\n                1523192045639075,\n                435746025122062,\n                512692508440385,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1255955808701983,\n                1700487367990941,\n                1166401238800299,\n                1175121994891534,\n                1190934801395380,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2600943821853521,\n                1337012557669161,\n                1475912332999108,\n                3573418268585706,\n                2299411105589567,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                877519947135419,\n                2172838026132651,\n                272304391224129,\n                1655143327559984,\n                886229406429814,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                375806028254706,\n                214463229793940,\n                572906353144089,\n                572168269875638,\n                697556386112979,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1168827102357825,\n                823864273033637,\n                4323338565789945,\n                788062026895923,\n                2851378154428610,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1948116082078088,\n                2054898304487796,\n                2204939184983900,\n                210526805152138,\n                786593586607626,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1915320147894736,\n                156481169009469,\n                655050471180417,\n                592917090415421,\n                2165897438660879,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1726336468579724,\n                1119932070398949,\n                1929199510967666,\n                2285718602008207,\n                1836837863503149,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                829996854845988,\n                217061778005138,\n                1686565909803640,\n                1346948817219846,\n                1723823550730181,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                384301494966394,\n                687038900403062,\n                2211195391021739,\n                254684538421383,\n                1245698430589680,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1247567493562669,\n                4229981908141095,\n                2435671288478202,\n                806570235643434,\n                2540261331753164,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1449077384734201,\n                38285445457996,\n                2136537659177832,\n                2146493000841573,\n                725161151123125,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1201928866368855,\n                800415690605445,\n                1703146756828343,\n                997278587541744,\n                1858284414104014,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2608268623334125,\n                3034173730618399,\n                1718002439402869,\n                3644022065904502,\n                663171266061950,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                759628738230460,\n                1012693474275852,\n                353780233086498,\n                246080061387552,\n                2030378857679162,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2040672435071076,\n                888593182036908,\n                1298443657189359,\n                1804780278521327,\n                354070726137060,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1894938527423184,\n                3715012855162525,\n                2726210319182898,\n                2499094776718546,\n                877975941029127,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                207937160991127,\n                12966911039119,\n                820997788283092,\n                1010440472205286,\n                1701372890140810,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                218882774543183,\n                533427444716285,\n                1233243976733245,\n                435054256891319,\n                1509568989549904,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4140638349397055,\n                3303977572025869,\n                3465353617009382,\n                2420981822812579,\n                2715174081801119,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                299137589460312,\n                1594371588983567,\n                868058494039073,\n                257771590636681,\n                1805012993142921,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1806842755664364,\n                2098896946025095,\n                1356630998422878,\n                1458279806348064,\n                347755825962072,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1402334161391744,\n                3811883484731547,\n                1008585416617746,\n                1147797150908892,\n                1420416683642459,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                665506704253369,\n                273770475169863,\n                799236974202630,\n                848328990077558,\n                1811448782807931,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1468412523962641,\n                771866649897997,\n                1931766110147832,\n                799561180078482,\n                524837559150077,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2223212657821831,\n                2882216061048914,\n                2144451165500327,\n                3068710944633039,\n                3276150872095279,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1266603897524861,\n                156378408858100,\n                1275649024228779,\n                447738405888420,\n                253186462063095,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2022215964509735,\n                136144366993649,\n                1800716593296582,\n                1193970603800203,\n                871675847064218,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1862751661970309,\n                851596246739884,\n                1519315554814041,\n                3794598280232697,\n                3669775149586767,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1228168094547481,\n                334133883362894,\n                587567568420081,\n                433612590281181,\n                603390400373205,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                121893973206505,\n                1843345804916664,\n                1703118377384911,\n                497810164760654,\n                101150811654673,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2710146069631716,\n                2542709749304591,\n                1452768413850678,\n                2802722688939463,\n                1537286854336537,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                584322311184395,\n                380661238802118,\n                114839394528060,\n                655082270500073,\n                2111856026034852,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                996965581008991,\n                2148998626477022,\n                1012273164934654,\n                1073876063914522,\n                1688031788934939,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3175286832534829,\n                2085106799623354,\n                2779882615305384,\n                1606206360876187,\n                2987706905397772,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1697697887804317,\n                1335343703828273,\n                831288615207040,\n                949416685250051,\n                288760277392022,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1419122478109648,\n                1325574567803701,\n                602393874111094,\n                2107893372601700,\n                1314159682671307,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2201150872731785,\n                2180241023425241,\n                2349463270108411,\n                1633405770247823,\n                3100744856129234,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1173339555550611,\n                818605084277583,\n                47521504364289,\n                924108720564965,\n                735423405754506,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                830104860549448,\n                1886653193241086,\n                1600929509383773,\n                1475051275443631,\n                286679780900937,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3828911108518224,\n                3282698983453994,\n                2396700729978777,\n                4216472406664814,\n                2820189914640497,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                278388655910247,\n                487143369099838,\n                927762205508727,\n                181017540174210,\n                1616886700741287,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1191033906638969,\n                940823957346562,\n                1606870843663445,\n                861684761499847,\n                658674867251089,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1875032594195527,\n                1427106132796197,\n                2976536204647406,\n                3153660325729987,\n                2887068310954007,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                622869792298357,\n                1903919278950367,\n                1922588621661629,\n                1520574711600434,\n                1087100760174640,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                25465949416618,\n                1693639527318811,\n                1526153382657203,\n                125943137857169,\n                145276964043999,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2466539671654587,\n                920212862967914,\n                4191701364657517,\n                3463662605460468,\n                2336897329405367,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2006245852772938,\n                734762734836159,\n                254642929763427,\n                1406213292755966,\n                239303749517686,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1619678837192149,\n                1919424032779215,\n                1357391272956794,\n                1525634040073113,\n                1310226789796241,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3292563523447371,\n                1704449869235351,\n                2857062884141577,\n                1998838089036354,\n                1312142911487502,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1996723311435669,\n                1844342766567060,\n                985455700466044,\n                1165924681400960,\n                311508689870129,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                43173156290518,\n                2202883069785309,\n                1137787467085917,\n                1733636061944606,\n                1394992037553852,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                670078326344559,\n                2807454838744604,\n                2723759199967685,\n                2141455487356408,\n                849015953823125,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2197214573372804,\n                794254097241315,\n                1030190060513737,\n                267632515541902,\n                2040478049202624,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1812516004670529,\n                1609256702920783,\n                1706897079364493,\n                258549904773295,\n                996051247540686,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1540374301420565,\n                1764656898914615,\n                1810104162020396,\n                3175608592848336,\n                2916189887881826,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1323460699404750,\n                1262690757880991,\n                871777133477900,\n                1060078894988977,\n                1712236889662886,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1696163952057966,\n                1391710137550823,\n                608793846867416,\n                1034391509472039,\n                1780770894075012,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1367603834210822,\n                4383788460268472,\n                890353773628143,\n                1908908219165595,\n                2522636708938139,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                597536315471731,\n                40375058742586,\n                1942256403956049,\n                1185484645495932,\n                312666282024145,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1919411405316294,\n                1234508526402192,\n                1066863051997083,\n                1008444703737597,\n                1348810787701552,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2102881477513865,\n                3822074379630609,\n                1573617900503707,\n                2270462449417831,\n                2232324307922097,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1853931367696942,\n                8107973870707,\n                350214504129299,\n                775206934582587,\n                1752317649166792,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1417148368003523,\n                721357181628282,\n                505725498207811,\n                373232277872983,\n                261634707184480,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2186733281493248,\n                2250694917008620,\n                1014829812957440,\n                2731797975137637,\n                2335366007561721,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1268116367301224,\n                560157088142809,\n                802626839600444,\n                2210189936605713,\n                1129993785579988,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                615183387352312,\n                917611676109240,\n                878893615973325,\n                978940963313282,\n                938686890583575,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                522024729211672,\n                3296859129001056,\n                1892245413707789,\n                1907891107684253,\n                2059998109500714,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1799679152208884,\n                912132775900387,\n                25967768040979,\n                432130448590461,\n                274568990261996,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                98698809797682,\n                2144627600856209,\n                1907959298569602,\n                811491302610148,\n                1262481774981493,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1791451399743152,\n                1713538728337276,\n                2370149810942738,\n                1882306388849953,\n                158235232210248,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1217809823321928,\n                2173947284933160,\n                1986927836272325,\n                1388114931125539,\n                12686131160169,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1650875518872272,\n                1136263858253897,\n                1732115601395988,\n                734312880662190,\n                1252904681142109,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2624786269799113,\n                2777230729143418,\n                2116279931702134,\n                2753222527273063,\n                1907002872974924,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                803147181835288,\n                868941437997146,\n                316299302989663,\n                943495589630550,\n                571224287904572,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                227742695588364,\n                1776969298667369,\n                628602552821802,\n                457210915378118,\n                2041906378111140,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                815000523470260,\n                3164885502413555,\n                3303859931956420,\n                1345536665214222,\n                541623413135555,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1580216071604333,\n                1877997504342444,\n                857147161260913,\n                703522726778478,\n                2182763974211603,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1870080310923419,\n                71988220958492,\n                1783225432016732,\n                615915287105016,\n                1035570475990230,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2982787564515398,\n                857613889540279,\n                1083813157271766,\n                1002817255970169,\n                1719228484436074,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                377616581647602,\n                1581980403078513,\n                804044118130621,\n                2034382823044191,\n                643844048472185,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                176957326463017,\n                1573744060478586,\n                528642225008045,\n                1816109618372371,\n                1515140189765006,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1888911448245718,\n                3638910709296328,\n                4176303607751676,\n                1731539523700948,\n                2230378382645454,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                443392177002051,\n                233793396845137,\n                2199506622312416,\n                1011858706515937,\n                974676837063129,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1846351103143623,\n                1949984838808427,\n                671247021915253,\n                1946756846184401,\n                1929296930380217,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                849646212451983,\n                1410198775302919,\n                2325567699868943,\n                1641663456615811,\n                3014056086137659,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                692017667358279,\n                723305578826727,\n                1638042139863265,\n                748219305990306,\n                334589200523901,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                22893968530686,\n                2235758574399251,\n                1661465835630252,\n                925707319443452,\n                1203475116966621,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3053098849470395,\n                3985092410411378,\n                1664508947088595,\n                2719548934677170,\n                3899298398220870,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                903105258014366,\n                427141894933047,\n                561187017169777,\n                1884330244401954,\n                1914145708422219,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1344191060517578,\n                1960935031767890,\n                1518838929955259,\n                1781502350597190,\n                1564784025565682,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2925523165433334,\n                1979969272514922,\n                3427087126180756,\n                1187589090978665,\n                1881897672213940,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1917185587363432,\n                1098342571752737,\n                5935801044414,\n                2000527662351839,\n                1538640296181569,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2495540013192,\n                678856913479236,\n                224998292422872,\n                219635787698590,\n                1972465269000940,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                271413961212179,\n                3604851875156899,\n                2596511104968730,\n                2014925838520661,\n                2006221033113941,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                194583029968109,\n                514316781467765,\n                829677956235672,\n                1676415686873082,\n                810104584395840,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1980510813313589,\n                1948645276483975,\n                152063780665900,\n                129968026417582,\n                256984195613935,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1860190562533083,\n                1936576191345085,\n                2712900106391212,\n                1811043097042829,\n                3209286562992083,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                796664815624365,\n                1543160838872951,\n                1500897791837765,\n                1667315977988401,\n                599303877030711,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1151480509533204,\n                2136010406720455,\n                738796060240027,\n                319298003765044,\n                1150614464349587,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1731069268103131,\n                2987442261301335,\n                1364750481334267,\n                2669032653668119,\n                3178908082812908,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1017222050227968,\n                1987716148359,\n                2234319589635701,\n                621282683093392,\n                2132553131763026,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1567828528453324,\n                1017807205202360,\n                565295260895298,\n                829541698429100,\n                307243822276582,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                249079270936229,\n                1501514259790706,\n                3199709537890096,\n                944551802437486,\n                2804458577667728,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2089966982947227,\n                1854140343916181,\n                2151980759220007,\n                2139781292261749,\n                158070445864917,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1338766321464554,\n                1906702607371284,\n                1519569445519894,\n                115384726262267,\n                1393058953390992,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3616421371950629,\n                3764188048593604,\n                1926731583198685,\n                2041482526432505,\n                3172200936019022,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1884844597333588,\n                601480070269079,\n                620203503079537,\n                1079527400117915,\n                1202076693132015,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                840922919763324,\n                727955812569642,\n                1303406629750194,\n                522898432152867,\n                294161410441865,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2605560604520539,\n                1598361541848742,\n                3374705511887547,\n                4174333403844152,\n                2670907514351827,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                359856369838236,\n                180914355488683,\n                861726472646627,\n                218807937262986,\n                575626773232501,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                755467689082474,\n                909202735047934,\n                730078068932500,\n                936309075711518,\n                2007798262842972,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1609384177904054,\n                2614544999293875,\n                1335318541768200,\n                3052765584121496,\n                2799677792952659,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                984339177776787,\n                815727786505884,\n                1645154585713747,\n                1659074964378553,\n                1686601651984156,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1697863093781930,\n                599794399429786,\n                1104556219769607,\n                830560774794755,\n                12812858601017,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1168737550514982,\n                897832437380552,\n                463140296333799,\n                2554364413707795,\n                2008360505135500,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1856930662813910,\n                678090852002597,\n                1920179140755167,\n                1259527833759868,\n                55540971895511,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1158643631044921,\n                476554103621892,\n                178447851439725,\n                1305025542653569,\n                103433927680625,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2176793111709008,\n                3828525530035639,\n                2009350167273522,\n                2012390194631546,\n                2125297410909580,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                825403285195098,\n                2144208587560784,\n                1925552004644643,\n                1915177840006985,\n                1015952128947864,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1807108316634472,\n                1534392066433717,\n                347342975407218,\n                1153820745616376,\n                7375003497471,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3234860815484973,\n                2683011703586488,\n                2201903782961092,\n                3069193724749589,\n                2214616493042166,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                228567918409756,\n                865093958780220,\n                358083886450556,\n                159617889659320,\n                1360637926292598,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                234147501399755,\n                2229469128637390,\n                2175289352258889,\n                1397401514549353,\n                1885288963089922,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3363562226636810,\n                2504649386192636,\n                3300514047508588,\n                2397910909286693,\n                1237505378776769,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1113790697840279,\n                1051167139966244,\n                1045930658550944,\n                2011366241542643,\n                1686166824620755,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1054097349305049,\n                1872495070333352,\n                182121071220717,\n                1064378906787311,\n                100273572924182,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3558210666856834,\n                1627717417672446,\n                2302783034773665,\n                1109249951172249,\n                3122001602766640,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                104233794644221,\n                1548919791188248,\n                2224541913267306,\n                2054909377116478,\n                1043803389015153,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                216762189468802,\n                707284285441622,\n                190678557969733,\n                973969342604308,\n                1403009538434867,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3530824104723725,\n                2596576648903557,\n                2525521909702446,\n                4086000250496689,\n                634517197663803,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                343805853118335,\n                1302216857414201,\n                566872543223541,\n                2051138939539004,\n                321428858384280,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                470067171324852,\n                1618629234173951,\n                2000092177515639,\n                7307679772789,\n                1117521120249968,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2529951391976704,\n                1810282338562946,\n                1771599529530998,\n                3635459223356879,\n                2937173228157088,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                577009397403102,\n                1791440261786291,\n                2177643735971638,\n                174546149911960,\n                1412505077782326,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                893719721537457,\n                1201282458018197,\n                1522349501711173,\n                58011597740583,\n                1130406465887139,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                412607348255434,\n                1280455764199780,\n                2233277987330768,\n                2265979894086913,\n                2583384512102412,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                262483770854550,\n                990511055108216,\n                526885552771698,\n                571664396646158,\n                354086190278723,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1820352417585487,\n                24495617171480,\n                1547899057533253,\n                10041836186225,\n                480457105094042,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2023310314989233,\n                2889705151211129,\n                2106474638900686,\n                2809620524769320,\n                1687858215057825,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1144168702609745,\n                604444390410187,\n                1544541121756138,\n                1925315550126027,\n                626401428894002,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1922168257351784,\n                2018674099908659,\n                1776454117494445,\n                956539191509034,\n                36031129147635,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2796444352433270,\n                1039872944430373,\n                3128550222815858,\n                2962457525011798,\n                3468752501170219,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                58242421545916,\n                2035812695641843,\n                2118491866122923,\n                1191684463816273,\n                46921517454099,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                272268252444639,\n                1374166457774292,\n                2230115177009552,\n                1053149803909880,\n                1354288411641016,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1857910905368338,\n                1754729879288912,\n                3137745277795125,\n                1516096106802165,\n                1602902393369811,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1193437069800958,\n                901107149704790,\n                999672920611411,\n                477584824802207,\n                364239578697845,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                886299989548838,\n                1538292895758047,\n                1590564179491896,\n                1944527126709657,\n                837344427345298,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3006358179063534,\n                1712186480903617,\n                3955456640022779,\n                3002110732175033,\n                2770795853936147,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1309847803895382,\n                1462151862813074,\n                211370866671570,\n                1544595152703681,\n                1027691798954090,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                803217563745370,\n                1884799722343599,\n                1357706345069218,\n                2244955901722095,\n                730869460037413,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2941099284981214,\n                1831210565161070,\n                3626987155270686,\n                3358084791231418,\n                1893781834054268,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                696351368613042,\n                1494385251239250,\n                738037133616932,\n                636385507851544,\n                927483222611406,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1949114198209333,\n                1104419699537997,\n                783495707664463,\n                1747473107602770,\n                2002634765788641,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1607325776830197,\n                2782683755100581,\n                1451089452727894,\n                3833490970768671,\n                496100432831153,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1068900648804224,\n                2006891997072550,\n                1134049269345549,\n                1638760646180091,\n                2055396084625778,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2222475519314561,\n                1870703901472013,\n                1884051508440561,\n                1344072275216753,\n                1318025677799069,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                155711679280637,\n                681100400509288,\n                389811735211209,\n                2135723811340709,\n                2660533024889373,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                7813206966729,\n                194444201427550,\n                2071405409526507,\n                1065605076176312,\n                1645486789731291,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                16625790644959,\n                1647648827778410,\n                1579910185572704,\n                436452271048548,\n                121070048451050,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3289062842237779,\n                2820185594063076,\n                2549752917829677,\n                3810384325616458,\n                2238221839292470,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                190565267697443,\n                672855706028058,\n                338796554369226,\n                337687268493904,\n                853246848691734,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1763863028400139,\n                766498079432444,\n                1321118624818005,\n                69494294452268,\n                858786744165651,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3543856582248253,\n                1456632109855637,\n                3352431060735432,\n                1386133165675320,\n                3484698163879000,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                366253102478259,\n                525676242508811,\n                1449610995265438,\n                1183300845322183,\n                185960306491545,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                28315355815982,\n                460422265558930,\n                1799675876678724,\n                1969256312504498,\n                1051823843138725,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2408714813047231,\n                3857948219405196,\n                1665208410108429,\n                2569443092377519,\n                1383783705665319,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                54684536365732,\n                2210010038536222,\n                1194984798155308,\n                535239027773705,\n                1516355079301361,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1484387703771650,\n                198537510937949,\n                2186282186359116,\n                617687444857508,\n                647477376402122,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2147715541830533,\n                2751832352131065,\n                2898179830570073,\n                2604027669016369,\n                1488268620408051,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                159386186465542,\n                1877626593362941,\n                618737197060512,\n                1026674284330807,\n                1158121760792685,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1744544377739822,\n                1964054180355661,\n                1685781755873170,\n                2169740670377448,\n                1286112621104591,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2333777063470241,\n                3919742931398333,\n                3920783633320113,\n                1605016835177614,\n                1353960708075544,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1602253788689063,\n                439542044889886,\n                2220348297664483,\n                657877410752869,\n                157451572512238,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1029287186166717,\n                65860128430192,\n                525298368814832,\n                1491902500801986,\n                1461064796385400,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2660016802414475,\n                2121095722306988,\n                913562102267595,\n                1879708920318308,\n                2492861262121979,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1185483484383269,\n                1356339572588553,\n                584932367316448,\n                102132779946470,\n                1792922621116791,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1966196870701923,\n                2230044620318636,\n                1425982460745905,\n                261167817826569,\n                46517743394330,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2358877405280588,\n                3136759755857592,\n                2279106683482647,\n                2224911448949389,\n                3216151871930471,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1730194207717538,\n                431790042319772,\n                1831515233279467,\n                1372080552768581,\n                1074513929381760,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1450880638731607,\n                1019861580989005,\n                1229729455116861,\n                1174945729836143,\n                826083146840706,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1899935429242705,\n                1602068751520477,\n                940583196550370,\n                2334230882739107,\n                1540863155745695,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2136688454840028,\n                2099509000964294,\n                1690800495246475,\n                1217643678575476,\n                828720645084218,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                765548025667841,\n                462473984016099,\n                998061409979798,\n                546353034089527,\n                2212508972466858,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2298375097456408,\n                3144370785258318,\n                1281983193144089,\n                1491520128287375,\n                75847005908304,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1801436127943107,\n                1734436817907890,\n                1268728090345068,\n                167003097070711,\n                2233597765834956,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1997562060465113,\n                1048700225534011,\n                7615603985628,\n                1855310849546841,\n                2242557647635213,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1161017320376250,\n                2744424393854291,\n                2169815802355236,\n                3228296595417790,\n                1770879511019628,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1357044908364776,\n                729130645262438,\n                1762469072918979,\n                1365633616878458,\n                181282906404941,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1080413443139865,\n                1155205815510486,\n                1848782073549786,\n                622566975152580,\n                124965574467971,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1184526762066993,\n                247622751762817,\n                2943928830891604,\n                3071818503097743,\n                2188697339828084,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2020536369003019,\n                202261491735136,\n                1053169669150884,\n                2056531979272544,\n                778165514694311,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                237404399610207,\n                1308324858405118,\n                1229680749538400,\n                720131409105291,\n                1958958863624906,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2767383321724075,\n                2269456792542436,\n                1717918437373988,\n                1568052070792483,\n                2298775616809171,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                281527309158085,\n                36970532401524,\n                866906920877543,\n                2222282602952734,\n                1289598729589882,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1278207464902042,\n                494742455008756,\n                1262082121427081,\n                1577236621659884,\n                1888786707293291,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                353042527954210,\n                1830056151907359,\n                1111731275799225,\n                2426760769524072,\n                404312815582674,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2064251142068628,\n                1666421603389706,\n                1419271365315441,\n                468767774902855,\n                191535130366583,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1716987058588002,\n                1859366439773457,\n                1767194234188234,\n                64476199777924,\n                1117233614485261,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3236091949205521,\n                2386938060636506,\n                2220652137473166,\n                1722843421165029,\n                2442282371698157,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                298845952651262,\n                1166086588952562,\n                1179896526238434,\n                1347812759398693,\n                1412945390096208,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1143239552672925,\n                906436640714209,\n                2177000572812152,\n                2075299936108548,\n                325186347798433,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2972824668060020,\n                2936287674948563,\n                3625238557779406,\n                2193186935276994,\n                1387043709851261,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                418098668140962,\n                715065997721283,\n                1471916138376055,\n                2168570337288357,\n                937812682637044,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1043584187226485,\n                2143395746619356,\n                2209558562919611,\n                482427979307092,\n                847556718384018,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1248731221520740,\n                1465200936117687,\n                2792603306395388,\n                2304778448366139,\n                2513234303861356,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1057329623869501,\n                620334067429122,\n                461700859268034,\n                2012481616501857,\n                297268569108938,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1055352180870759,\n                1553151421852298,\n                1510903185371259,\n                1470458349428097,\n                1226259419062731,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3744788603986897,\n                3042126439258578,\n                3441906842094992,\n                3641194565844440,\n                3872208010289441,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                47000654413729,\n                1004754424173864,\n                1868044813557703,\n                173236934059409,\n                588771199737015,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                30498470091663,\n                1082245510489825,\n                576771653181956,\n                806509986132686,\n                1317634017056939,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2672107869436803,\n                3745154677001249,\n                2417006535213335,\n                4136645508605033,\n                2065456951573058,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1115636332012334,\n                1854340990964155,\n                83792697369514,\n                1972177451994021,\n                457455116057587,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1698968457310898,\n                1435137169051090,\n                1083661677032510,\n                938363267483709,\n                340103887207182,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1995325341336555,\n                911500251774648,\n                2415810569088940,\n                855378419194761,\n                3825401211214090,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                241719380661528,\n                310028521317150,\n                1215881323380194,\n                1408214976493624,\n                2141142156467363,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1315157046163473,\n                727368447885818,\n                1363466668108618,\n                1668921439990361,\n                1398483384337907,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2326829491984875,\n                3267188020145720,\n                1849729037055211,\n                4191614430138232,\n                2696204044080201,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2053597130993710,\n                2024431685856332,\n                2233550957004860,\n                2012407275509545,\n                872546993104440,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1217269667678610,\n                599909351968693,\n                1390077048548598,\n                1471879360694802,\n                739586172317596,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3970118453066023,\n                1560510726633957,\n                3156262694845170,\n                1418028351780051,\n                2346204163137185,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2132502667405250,\n                214379346175414,\n                1502748313768060,\n                1960071701057800,\n                1353971822643138,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                319394212043702,\n                2127459436033571,\n                717646691535162,\n                663366796076914,\n                318459064945314,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2657789238608841,\n                1960452633787082,\n                2919148848086913,\n                3744474074452359,\n                1451061489880786,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                947085906234007,\n                323284730494107,\n                1485778563977200,\n                728576821512394,\n                901584347702286,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1575783124125742,\n                2126210792434375,\n                1569430791264065,\n                1402582372904727,\n                1891780248341114,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3090232019245924,\n                4249503325136911,\n                3270591693593114,\n                1662001808174330,\n                2330127946643001,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                739152638255629,\n                2074935399403557,\n                505483666745895,\n                1611883356514088,\n                628654635394878,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1822054032121349,\n                643057948186973,\n                7306757352712,\n                577249257962099,\n                284735863382083,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3618358370049178,\n                1448606567552085,\n                3730680834630016,\n                2417602993041145,\n                1115718458123497,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                204146226972102,\n                1630511199034723,\n                2215235214174763,\n                174665910283542,\n                956127674017216,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1562934578796716,\n                1070893489712745,\n                11324610642270,\n                958989751581897,\n                2172552325473805,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1770564423056008,\n                2987323445349813,\n                1326060113795288,\n                1509650369341127,\n                2317692235267932,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                623682558650637,\n                1337866509471512,\n                990313350206649,\n                1314236615762469,\n                1164772974270275,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                223256821462517,\n                723690150104139,\n                1000261663630601,\n                933280913953265,\n                254872671543046,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1969087237026022,\n                2876595539132372,\n                1335555107635968,\n                2069986355593023,\n                3963899963027150,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1236103475266979,\n                1837885883267218,\n                1026072585230455,\n                1025865513954973,\n                1801964901432134,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1115241013365517,\n                1712251818829143,\n                2148864332502771,\n                2096001471438138,\n                2235017246626125,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3551068012286861,\n                2047148477845620,\n                2165648650132450,\n                1612539282026145,\n                2765997725314138,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                118352772338543,\n                1067608711804704,\n                1434796676193498,\n                1683240170548391,\n                230866769907437,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1850689576796636,\n                1601590730430274,\n                1139674615958142,\n                1954384401440257,\n                76039205311,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1723387471374172,\n                3249101280723658,\n                2785727448808904,\n                2272728458379212,\n                1756575222802512,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2146711623855116,\n                503278928021499,\n                625853062251406,\n                1109121378393107,\n                1033853809911861,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                571005965509422,\n                2005213373292546,\n                1016697270349626,\n                56607856974274,\n                914438579435146,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1346698876211176,\n                2076651707527589,\n                3336561384795453,\n                2517134292513653,\n                1068954492309670,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1769967932677654,\n                1695893319756416,\n                1151863389675920,\n                1781042784397689,\n                400287774418285,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1851867764003121,\n                403841933237558,\n                820549523771987,\n                761292590207581,\n                1743735048551143,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                410915148140008,\n                2107072311871739,\n                3256167275561751,\n                2351484709082008,\n                1180818713503223,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                285945406881439,\n                648174397347453,\n                1098403762631981,\n                1366547441102991,\n                1505876883139217,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                672095903120153,\n                1675918957959872,\n                636236529315028,\n                1569297300327696,\n                2164144194785875,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1902708175321798,\n                3287143344600686,\n                1178560808893262,\n                2552895497743394,\n                1280977479761117,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1615357281742403,\n                404257611616381,\n                2160201349780978,\n                1160947379188955,\n                1578038619549541,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2013087639791217,\n                822734930507457,\n                1785668418619014,\n                1668650702946164,\n                389450875221715,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2705718263383616,\n                2358206633614248,\n                2072540975937134,\n                308588860670238,\n                1304394580755385,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1295082798350326,\n                2091844511495996,\n                1851348972587817,\n                3375039684596,\n                789440738712837,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2083069137186154,\n                848523102004566,\n                993982213589257,\n                1405313299916317,\n                1532824818698468,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3747761112537659,\n                1397203457344778,\n                4026750030752190,\n                2391102557240943,\n                2318403398028034,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1782411379088302,\n                1096724939964781,\n                27593390721418,\n                542241850291353,\n                1540337798439873,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                693543956581437,\n                171507720360750,\n                1557908942697227,\n                1074697073443438,\n                1104093109037196,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                345288228393400,\n                3351443383432420,\n                2386681722088990,\n                1740551994106739,\n                2500011992985018,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                231429562203065,\n                1526290236421172,\n                2021375064026423,\n                1520954495658041,\n                806337791525116,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1079623667189886,\n                872403650198613,\n                766894200588288,\n                2163700860774109,\n                2023464507911816,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                854645372543796,\n                1936406001954827,\n                2403260476226501,\n                3077125552956802,\n                1554306377287555,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1497138821904622,\n                1044820250515590,\n                1742593886423484,\n                1237204112746837,\n                849047450816987,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                667962773375330,\n                1897271816877105,\n                1399712621683474,\n                1143302161683099,\n                2081798441209593,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2378947665252234,\n                1936114012888109,\n                1704424366552046,\n                3108474694401560,\n                2968403435020606,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1072409664800960,\n                2146937497077528,\n                1508780108920651,\n                935767602384853,\n                1112800433544068,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                333549023751292,\n                280219272863308,\n                2104176666454852,\n                1036466864875785,\n                536135186520207,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2625466093568366,\n                2398257055215356,\n                2555916080813104,\n                2667888562832962,\n                3510376944868638,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1186115062588401,\n                2251609796968486,\n                1098944457878953,\n                1153112761201374,\n                1791625503417267,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1870078460219737,\n                2129630962183380,\n                852283639691142,\n                292865602592851,\n                401904317342226,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1361070124828016,\n                815664541425524,\n                3278598711049919,\n                1951790935390646,\n                2807674705520038,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1546301003424277,\n                459094500062839,\n                1097668518375311,\n                1780297770129643,\n                720763293687608,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1212405311403990,\n                1536693382542438,\n                61028431067459,\n                1863929423417129,\n                1223219538638038,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1294303766540260,\n                3435357279640341,\n                3134071170918340,\n                2315654383110622,\n                2213283684565086,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                339050984211414,\n                601386726509773,\n                413735232134068,\n                966191255137228,\n                1839475899458159,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                235605972169408,\n                2174055643032978,\n                1538335001838863,\n                1281866796917192,\n                1815940222628465,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1632352921721536,\n                1833328609514701,\n                2092779091951987,\n                4175756015558474,\n                2210068022482918,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                35271216625062,\n                1712350667021807,\n                983664255668860,\n                98571260373038,\n                1232645608559836,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1998172393429622,\n                1798947921427073,\n                784387737563581,\n                1589352214827263,\n                1589861734168180,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1733739258725305,\n                2283515530744786,\n                2453769758904107,\n                3243892858242237,\n                1194308773174555,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                846415389605137,\n                746163495539180,\n                829658752826080,\n                592067705956946,\n                957242537821393,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1758148849754419,\n                619249044817679,\n                168089007997045,\n                1371497636330523,\n                1867101418880350,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2578433797894864,\n                2513559319756263,\n                1700682323676192,\n                1577907266349064,\n                3469447477068264,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1714182387328607,\n                1477856482074168,\n                574895689942184,\n                2159118410227270,\n                1555532449716575,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                853828206885131,\n                998498946036955,\n                1835887550391235,\n                207627336608048,\n                258363815956050,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2392941288336925,\n                3488528558590503,\n                2894901233585134,\n                1646615130509172,\n                1208239602291765,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1501663228068911,\n                1354879465566912,\n                1444432675498247,\n                897812463852601,\n                855062598754348,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                714380763546606,\n                1032824444965790,\n                1774073483745338,\n                1063840874947367,\n                1738680636537158,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1640635546696233,\n                2884968766877360,\n                2212651044092395,\n                2282390772269100,\n                2620315074574625,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1171650314802029,\n                1567085444565577,\n                1453660792008405,\n                757914533009261,\n                1619511342778196,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                420958967093237,\n                971103481109486,\n                2169549185607107,\n                1301191633558497,\n                1661514101014240,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3158923465503550,\n                1332556122804145,\n                4075855067109735,\n                3619414031128206,\n                1982558335973171,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1121533090144639,\n                1021251337022187,\n                110469995947421,\n                1511059774758394,\n                2110035908131662,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                303213233384524,\n                2061932261128138,\n                352862124777736,\n                40828818670255,\n                249879468482660,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                856559257852200,\n                2760317478634258,\n                3629993581580163,\n                3975258940632376,\n                1962275756614520,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1445691340537320,\n                40614383122127,\n                402104303144865,\n                485134269878232,\n                1659439323587426,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                20057458979482,\n                1183363722525800,\n                2140003847237215,\n                2053873950687614,\n                2112017736174909,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2228654250927986,\n                3735391177100515,\n                1368661293910955,\n                3328311098862539,\n                526650682059607,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                709481497028540,\n                531682216165724,\n                316963769431931,\n                1814315888453765,\n                258560242424104,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1053447823660455,\n                1955135194248683,\n                1010900954918985,\n                1182614026976701,\n                1240051576966610,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1957943897155478,\n                1788667368028035,\n                2389492723714354,\n                2252839333292309,\n                3078204576998275,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1848942433095597,\n                1582009882530495,\n                1849292741020143,\n                1068498323302788,\n                2001402229799484,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1528282417624269,\n                2142492439828191,\n                2179662545816034,\n                362568973150328,\n                1591374675250271,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2411826493119617,\n                2484141002903963,\n                2149181472355544,\n                598041771119831,\n                2435658815595421,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2013278155187349,\n                662660471354454,\n                793981225706267,\n                411706605985744,\n                804490933124791,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2051892037280204,\n                488391251096321,\n                2230187337030708,\n                930221970662692,\n                679002758255210,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1530723630438670,\n                875873929577927,\n                2593359947955236,\n                2701702933216000,\n                1055551308214178,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1461835919309432,\n                1955256480136428,\n                180866187813063,\n                1551979252664528,\n                557743861963950,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                359179641731115,\n                1324915145732949,\n                902828372691474,\n                294254275669987,\n                1887036027752957,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4295071423139571,\n                2038225437857463,\n                1317528426475850,\n                1398989128982787,\n                2027639881006861,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2072902725256516,\n                312132452743412,\n                309930885642209,\n                996244312618453,\n                1590501300352303,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1397254305160710,\n                695734355138021,\n                2233992044438756,\n                1776180593969996,\n                1085588199351115,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2692366865016258,\n                2506694600041928,\n                2745669038615469,\n                1556322069683365,\n                3819256354004466,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1950722461391320,\n                1907845598854797,\n                1822757481635527,\n                2121567704750244,\n                73811931471221,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                387139307395758,\n                2058036430315676,\n                1220915649965325,\n                1794832055328951,\n                1230009312169328,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1765973779329498,\n                2911143873132225,\n                2271621715291913,\n                3553728154996461,\n                3368065817761132,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1127572801181483,\n                1224743760571696,\n                1276219889847274,\n                1529738721702581,\n                1589819666871853,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2181229378964934,\n                2190885205260020,\n                1511536077659137,\n                1246504208580490,\n                668883326494241,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2689666469258543,\n                2920826224880015,\n                2333696811665585,\n                523874406393177,\n                2496851874620484,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1975438052228868,\n                1071801519999806,\n                594652299224319,\n                1877697652668809,\n                1489635366987285,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                958592545673770,\n                233048016518599,\n                851568750216589,\n                567703851596087,\n                1740300006094761,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2014540178270324,\n                192672779514432,\n                2465676996326778,\n                2194819933853410,\n                1716422829364835,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1540769606609725,\n                2148289943846077,\n                1597804156127445,\n                1230603716683868,\n                815423458809453,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1738560251245018,\n                1779576754536888,\n                1783765347671392,\n                1880170990446751,\n                1088225159617541,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2911103727614740,\n                1956447718227572,\n                1830568515922666,\n                3092868863429656,\n                1669607124206367,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1143465490433355,\n                1532194726196059,\n                1093276745494697,\n                481041706116088,\n                2121405433561163,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1686424298744462,\n                1451806974487153,\n                266296068846582,\n                1834686947542675,\n                1720762336132256,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3141016840074207,\n                3295090436969907,\n                3107924901237156,\n                1669272323124635,\n                1603340330827879,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1206396181488998,\n                333158148435054,\n                1402633492821422,\n                1120091191722026,\n                1945474114550509,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                766720088232571,\n                1512222781191002,\n                1189719893490790,\n                2091302129467914,\n                2141418006894941,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2671463460991841,\n                1998875112167986,\n                3678399683938955,\n                3406728169064757,\n                2738338345823434,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                938160078005954,\n                1421776319053174,\n                1941643234741774,\n                180002183320818,\n                1414380336750546,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                398001940109652,\n                1577721237663248,\n                1012748649830402,\n                1540516006905144,\n                1011684812884559,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1653276489969611,\n                2257881638852872,\n                1921777941170835,\n                1604139841794531,\n                3113010867325889,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                996661541407379,\n                1455877387952927,\n                744312806857277,\n                139213896196746,\n                1000282908547789,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1450817495603008,\n                1476865707053229,\n                1030490562252053,\n                620966950353376,\n                1744760161539058,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2811528223687828,\n                2288856475326432,\n                2038622963352005,\n                1637244893271723,\n                3278365165924196,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                962165956135846,\n                1116599660248791,\n                182090178006815,\n                1455605467021751,\n                196053588803284,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                796863823080135,\n                1897365583584155,\n                420466939481601,\n                2165972651724672,\n                932177357788289,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                877047233620613,\n                1375632631944375,\n                2895573425567369,\n                2911822552533124,\n                2271153746017078,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2216943882299338,\n                394841323190322,\n                2222656898319671,\n                558186553950529,\n                1077236877025190,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                801118384953213,\n                1914330175515892,\n                574541023311511,\n                1471123787903705,\n                1526158900256288,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3201417702772463,\n                2207116611267330,\n                3164719852826535,\n                2752958352884036,\n                2314162374456719,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1474518386765335,\n                1760793622169197,\n                1157399790472736,\n                1622864308058898,\n                165428294422792,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1961673048027128,\n                102619413083113,\n                1051982726768458,\n                1603657989805485,\n                1941613251499678,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1401939116319247,\n                2587106153588320,\n                2323846009771033,\n                862423201496005,\n                3102318568216632,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1234706593321979,\n                1083343891215917,\n                898273974314935,\n                1640859118399498,\n                157578398571149,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1143483057726416,\n                1992614991758919,\n                674268662140796,\n                1773370048077526,\n                674318359920189,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1835401379538542,\n                173900035308392,\n                818247630716732,\n                4013900225838034,\n                1021506399448290,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1506632088156630,\n                2127481795522179,\n                513812919490255,\n                140643715928370,\n                442476620300318,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2056683376856736,\n                219094741662735,\n                2193541883188309,\n                1841182310235800,\n                556477468664293,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3566819241596075,\n                1049075855992602,\n                4318372866671791,\n                2518704280870781,\n                2040482348591519,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                94096246544434,\n                922482381166992,\n                24517828745563,\n                2139430508542503,\n                2097139044231004,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                537697207950515,\n                1399352016347350,\n                1563663552106345,\n                2148749520888918,\n                549922092988516,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1747985413252415,\n                680511052635695,\n                1809559829982725,\n                2846074064615302,\n                2453472984431229,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                323583936109569,\n                1973572998577657,\n                1192219029966558,\n                79354804385273,\n                1374043025560347,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                213277331329947,\n                416202017849623,\n                1950535221091783,\n                1313441578103244,\n                2171386783823658,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2440888617915079,\n                993969372859109,\n                3147669935222235,\n                3799101348983503,\n                1477373024911349,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1620578418245010,\n                541035331188469,\n                2235785724453865,\n                2154865809088198,\n                1974627268751826,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1346805451740245,\n                1350981335690626,\n                942744349501813,\n                2155094562545502,\n                1012483751693409,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2107080134091762,\n                1132567062788208,\n                1824935377687210,\n                769194804343737,\n                1857941799971888,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1074666112436467,\n                249279386739593,\n                1174337926625354,\n                1559013532006480,\n                1472287775519121,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1872620123779532,\n                1892932666768992,\n                1921559078394978,\n                1270573311796160,\n                1438913646755037,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3089190001333428,\n                3264053113908846,\n                989780015893986,\n                1351393287739814,\n                2580427560230798,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1028328827183114,\n                1711043289969857,\n                1350832470374933,\n                1923164689604327,\n                1495656368846911,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1900828492104143,\n                430212361082163,\n                687437570852799,\n                832514536673512,\n                1685641495940794,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3094432661621646,\n                605670026766215,\n                290836444839585,\n                2415010588577604,\n                2213815011799644,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1176336383453996,\n                1725477294339771,\n                12700622672454,\n                678015708818208,\n                162724078519879,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1448049969043497,\n                1789411762943521,\n                385587766217753,\n                90201620913498,\n                832999441066823,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2767886146978542,\n                2240508292484615,\n                3603469341851756,\n                3475055379001735,\n                3002035638112385,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1263624896582495,\n                1102602401673328,\n                526302183714372,\n                2152015839128799,\n                1483839308490010,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                442991718646863,\n                1599275157036458,\n                1925389027579192,\n                899514691371390,\n                350263251085160,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1689713572022124,\n                2845654372939621,\n                3229894858477217,\n                1985127338729498,\n                3927868934032873,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1557207018622683,\n                340631692799603,\n                1477725909476187,\n                614735951619419,\n                2033237123746766,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                968764929340557,\n                1225534776710944,\n                662967304013036,\n                1155521416178595,\n                791142883466590,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1487081286167458,\n                3244839255500182,\n                1792378982844639,\n                2950452258685122,\n                2153908693179753,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1123181311102823,\n                685575944875442,\n                507605465509927,\n                1412590462117473,\n                568017325228626,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                560258797465417,\n                2193971151466401,\n                1824086900849026,\n                579056363542056,\n                1690063960036441,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1918407319222397,\n                2605567366745211,\n                1930426334528098,\n                1564816146005724,\n                4113142195393344,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2131325168777276,\n                1176636658428908,\n                1756922641512981,\n                1390243617176012,\n                1966325177038383,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2063958120364491,\n                2140267332393533,\n                699896251574968,\n                273268351312140,\n                375580724713232,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2024297515263178,\n                2668759143407935,\n                3330814048702549,\n                2423412039258430,\n                1031677520051052,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2033900009388450,\n                1744902869870788,\n                2190580087917640,\n                1949474984254121,\n                231049754293748,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                343868674606581,\n                550155864008088,\n                1450580864229630,\n                481603765195050,\n                896972360018042,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2151139328380127,\n                2566545695770176,\n                2311556639460451,\n                1676664391494650,\n                2048348075599360,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1528930066340597,\n                1605003907059576,\n                1055061081337675,\n                1458319101947665,\n                1234195845213142,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                830430507734812,\n                1780282976102377,\n                1425386760709037,\n                362399353095425,\n                2168861579799910,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3407562046415562,\n                980662895504005,\n                2053766700883521,\n                2742766027762854,\n                2762205690726604,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1683750316716132,\n                652278688286128,\n                1221798761193539,\n                1897360681476669,\n                319658166027343,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                618808732869972,\n                72755186759744,\n                2060379135624181,\n                1730731526741822,\n                48862757828238,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3714971784278753,\n                3394840525452699,\n                614590986558882,\n                1409210575145591,\n                1882816996436803,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2230133264691131,\n                563950955091024,\n                2042915975426398,\n                827314356293472,\n                672028980152815,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                264204366029760,\n                1654686424479449,\n                2185050199932931,\n                2207056159091748,\n                506015669043634,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1784446333136550,\n                1973746527984364,\n                334856327359575,\n                3408569589569858,\n                3275749938360725,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2065270940578383,\n                31477096270353,\n                306421879113491,\n                181958643936686,\n                1907105536686083,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1496516440779464,\n                1748485652986458,\n                872778352227340,\n                818358834654919,\n                97932669284220,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2723435829455580,\n                2924255216478824,\n                1804995246884102,\n                1842309243470804,\n                3753662318666930,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1013216974933691,\n                538921919682598,\n                1915776722521558,\n                1742822441583877,\n                1886550687916656,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2094270000643336,\n                303971879192276,\n                40801275554748,\n                649448917027930,\n                1818544418535447,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2241737709499146,\n                549397817447461,\n                838180519319392,\n                1725686958520781,\n                3957438894582995,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1216074541925116,\n                50120933933509,\n                1565829004133810,\n                721728156134580,\n                349206064666188,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                948617110470858,\n                346222547451945,\n                1126511960599975,\n                1759386906004538,\n                493053284802266,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1454933046815146,\n                3126495827951610,\n                1467170975468587,\n                1432316382418897,\n                2111710746366763,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2105387117364450,\n                1996463405126433,\n                1303008614294500,\n                851908115948209,\n                1353742049788635,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                750300956351719,\n                1487736556065813,\n                15158817002104,\n                1511998221598392,\n                971739901354129,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1874648163531674,\n                2124487685930551,\n                1810030029384882,\n                918400043048335,\n                2838148440985898,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1235084464747900,\n                1166111146432082,\n                1745394857881591,\n                1405516473883040,\n                4463504151617,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1663810156463827,\n                327797390285791,\n                1341846161759410,\n                1964121122800605,\n                1747470312055380,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                660005247548214,\n                2071860029952887,\n                3610548013635355,\n                911703252219106,\n                3266179736709079,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2206641276178231,\n                1690587809721504,\n                1600173622825126,\n                2156096097634421,\n                1106822408548216,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1344788193552206,\n                1949552134239140,\n                1735915881729557,\n                675891104100469,\n                1834220014427292,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1920949492387945,\n                2410685102072778,\n                2322108077349280,\n                2877838278583064,\n                3719881539786256,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                622221042073383,\n                1210146474039168,\n                1742246422343683,\n                1403839361379025,\n                417189490895736,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                22727256592983,\n                168471543384997,\n                1324340989803650,\n                1839310709638189,\n                504999476432775,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3565040332441556,\n                1721896294296941,\n                2304063388272514,\n                2065069734239231,\n                3056710287109878,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1337466662091884,\n                1287645354669772,\n                2018019646776184,\n                652181229374245,\n                898011753211715,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1969792547910734,\n                779969968247557,\n                2011350094423418,\n                1823964252907487,\n                1058949448296945,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2459143550747250,\n                1118176942430252,\n                3010694408233412,\n                806764629546265,\n                1157700123092949,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1273565321399022,\n                1638509681964574,\n                759235866488935,\n                666015124346707,\n                897983460943405,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1717263794012298,\n                1059601762860786,\n                1837819172257618,\n                1054130665797229,\n                680893204263559,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2237039662793603,\n                2249022333361206,\n                2058613546633703,\n                2401253908530527,\n                2215176649164581,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                79472182719605,\n                1851130257050174,\n                1825744808933107,\n                821667333481068,\n                781795293511946,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                755822026485370,\n                152464789723500,\n                1178207602290608,\n                410307889503239,\n                156581253571278,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3669985309815545,\n                2736319981413860,\n                3898537095128197,\n                3653287498355512,\n                1349185550126960,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1495380034400429,\n                325049476417173,\n                46346894893933,\n                1553408840354856,\n                828980101835683,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1280337889310282,\n                2070832742866672,\n                1640940617225222,\n                2098284908289951,\n                450929509534434,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2659503167684029,\n                2378371955168899,\n                2537839641198868,\n                1999255076709337,\n                2030511179441770,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1254958221100483,\n                1153235960999843,\n                942907704968834,\n                637105404087392,\n                1149293270147267,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                894249020470196,\n                400291701616810,\n                406878712230981,\n                1599128793487393,\n                1145868722604026,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3749755063888563,\n                2361916158338507,\n                1128535642171975,\n                1900106496009660,\n                2381592531146157,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                452487513298665,\n                1352120549024569,\n                1173495883910956,\n                1999111705922009,\n                367328130454226,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1717539401269642,\n                1475188995688487,\n                891921989653942,\n                836824441505699,\n                1885988485608364,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3493583935107776,\n                2439136865632830,\n                3370281625921440,\n                2680547565621609,\n                2282158712612572,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2022432361201842,\n                1088816090685051,\n                1977843398539868,\n                1854834215890724,\n                564238862029357,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                938868489100585,\n                1100285072929025,\n                1017806255688848,\n                1957262154788833,\n                152787950560442,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3119119231364171,\n                2872271776627789,\n                2477832016990963,\n                2593801257642876,\n                1761675818237335,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1295072362439987,\n                931227904689414,\n                1355731432641687,\n                922235735834035,\n                892227229410209,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1680989767906154,\n                535362787031440,\n                2136691276706570,\n                1942228485381244,\n                1267350086882274,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2617818047455756,\n                2684460443440843,\n                2378209521329782,\n                1973842949591661,\n                2897427157127624,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                535509430575217,\n                546885533737322,\n                1524675609547799,\n                2138095752851703,\n                1260738089896827,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1159906385590467,\n                2198530004321610,\n                714559485023225,\n                81880727882151,\n                1484020820037082,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1377485731340769,\n                2046328105512000,\n                1802058637158797,\n                2313945950453421,\n                1356993908853900,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2013612215646735,\n                1830770575920375,\n                536135310219832,\n                609272325580394,\n                270684344495013,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1237542585982777,\n                2228682050256790,\n                1385281931622824,\n                593183794882890,\n                493654978552689,\n            ]),\n        },\n    ]),\n    LookupTable([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2299141301692989,\n                1891414891220256,\n                983894663308928,\n                2427961581972066,\n                3378060928864955,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1694030170963455,\n                502038567066200,\n                1691160065225467,\n                949628319562187,\n                275110186693066,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1124515748676336,\n                1661673816593408,\n                1499640319059718,\n                1584929449166988,\n                558148594103306,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1784525599998356,\n                1619698033617383,\n                2097300287550715,\n                2510065271789004,\n                1905684794832757,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1288941072872766,\n                931787902039402,\n                190731008859042,\n                2006859954667190,\n                1005931482221702,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1465551264822703,\n                152905080555927,\n                680334307368453,\n                173227184634745,\n                666407097159852,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2111017076203943,\n                3630560299479595,\n                1248583954016455,\n                3604089008549670,\n                1895180776543895,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                171348223915638,\n                662766099800389,\n                462338943760497,\n                466917763340314,\n                656911292869115,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                488623681976577,\n                866497561541722,\n                1708105560937768,\n                1673781214218839,\n                1506146329818807,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2412225278142205,\n                950394373239688,\n                2682296937026182,\n                711676555398831,\n                320964687779005,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                988979367990485,\n                1359729327576302,\n                1301834257246029,\n                294141160829308,\n                29348272277475,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1434382743317910,\n                100082049942065,\n                221102347892623,\n                186982837860588,\n                1305765053501834,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2205916462268190,\n                2751663643476068,\n                961960554686615,\n                2409862576442233,\n                1841471168298304,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1191737341426592,\n                1847042034978363,\n                1382213545049056,\n                1039952395710448,\n                788812858896859,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1346965964571152,\n                1291881610839830,\n                2142916164336056,\n                786821641205979,\n                1571709146321039,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                787164375951248,\n                2454669019058437,\n                3608390234717387,\n                1431233331032509,\n                786341368775957,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                492448143532951,\n                304105152670757,\n                1761767168301056,\n                233782684697790,\n                1981295323106089,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                665807507761866,\n                1343384868355425,\n                895831046139653,\n                439338948736892,\n                1986828765695105,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3007896024559801,\n                1721699973539148,\n                2510565115413133,\n                1390588532210644,\n                1212530909934781,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                852891097972275,\n                1816988871354562,\n                1543772755726524,\n                1174710635522444,\n                202129090724628,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1205281565824323,\n                22430498399418,\n                992947814485516,\n                1392458699738672,\n                688441466734558,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3302427242100220,\n                1955849529137134,\n                2171162376368357,\n                2343545681983462,\n                447733118757825,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1287181461435438,\n                622722465530711,\n                880952150571872,\n                741035693459198,\n                311565274989772,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1003649078149734,\n                545233927396469,\n                1849786171789880,\n                1318943684880434,\n                280345687170552,\n            ]),\n        },\n    ]),\n]);\n\n/// Odd multiples of the basepoint `[B, 3B, 5B, 7B, 9B, 11B, 13B, 15B, ..., 127B]`.\n#[cfg(feature = \"precomputed-tables\")]\n#[allow(dead_code)]\npub(crate) const AFFINE_ODD_MULTIPLES_OF_BASEPOINT: NafLookupTable8<AffineNielsPoint> =\n    NafLookupTable8([\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3540182452943730,\n                2497478415033846,\n                2521227595762870,\n                1462984067271729,\n                2389212253076811,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                62697248952638,\n                204681361388450,\n                631292143396476,\n                338455783676468,\n                1213667448819585,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                301289933810280,\n                1259582250014073,\n                1422107436869536,\n                796239922652654,\n                1953934009299142,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1601611775252272,\n                1720807796594148,\n                1132070835939856,\n                3512254832574799,\n                2147779492816910,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                316559037616741,\n                2177824224946892,\n                1459442586438991,\n                1461528397712656,\n                751590696113597,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1850748884277385,\n                1200145853858453,\n                1068094770532492,\n                672251375690438,\n                1586055907191707,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                769950342298400,\n                2384754244604994,\n                3095885746880802,\n                3225892188161580,\n                2977876099231263,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                425251763115706,\n                608463272472562,\n                442562545713235,\n                837766094556764,\n                374555092627893,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1086255230780037,\n                274979815921559,\n                1960002765731872,\n                929474102396301,\n                1190409889297339,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2916800678241215,\n                2065379846933858,\n                2622030924071124,\n                2602788184473875,\n                1233371373142984,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2019367628972465,\n                676711900706637,\n                110710997811333,\n                1108646842542025,\n                517791959672113,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                965130719900578,\n                247011430587952,\n                526356006571389,\n                91986625355052,\n                2157223321444601,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1802695059464988,\n                1664899123557221,\n                2845359304426105,\n                2160434469266658,\n                3179370264440279,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1725674970513508,\n                1933645953859181,\n                1542344539275782,\n                1767788773573747,\n                1297447965928905,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1381809363726107,\n                1430341051343062,\n                2061843536018959,\n                1551778050872521,\n                2036394857967624,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4222693909998302,\n                2779866139518454,\n                1619374932191226,\n                2207306624415883,\n                1169170329061080,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2070390218572616,\n                1458919061857835,\n                624171843017421,\n                1055332792707765,\n                433987520732508,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                893653801273833,\n                1168026499324677,\n                1242553501121234,\n                1306366254304474,\n                1086752658510815,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2465253816303469,\n                3191571337672685,\n                1159882208056013,\n                2569188183312765,\n                621213314200686,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1971678598905747,\n                338026507889165,\n                762398079972271,\n                655096486107477,\n                42299032696322,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                177130678690680,\n                1754759263300204,\n                1864311296286618,\n                1180675631479880,\n                1292726903152791,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1913163449625248,\n                2712579013977241,\n                2193883288642313,\n                1008900146920800,\n                1721983679009502,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1070401523076875,\n                1272492007800961,\n                1910153608563310,\n                2075579521696771,\n                1191169788841221,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                692896803108118,\n                500174642072499,\n                2068223309439677,\n                1162190621851337,\n                1426986007309901,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1819621230288238,\n                2735700366193240,\n                1755134670739586,\n                3080648199451191,\n                4172807995775876,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                992069868904071,\n                799011518185730,\n                1777586403832768,\n                1134820506145684,\n                1999461475558530,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                425204543703124,\n                2040469794090382,\n                1651690622153809,\n                1500530168597569,\n                1253908377065966,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2105824306960939,\n                1387520302709358,\n                3633176580451016,\n                2211816663841753,\n                1629085891776489,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1485201376284999,\n                1022406647424656,\n                504181009209019,\n                962621520820995,\n                590876713147230,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                265873406365287,\n                1192742653492898,\n                88553098803050,\n                525037770869640,\n                1266933811251234,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3552316659826612,\n                1254279525791875,\n                1609927932077699,\n                3578654071679972,\n                3750681296069893,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                37186803519861,\n                1404297334376301,\n                578519728836650,\n                1740727951192592,\n                2095534282477028,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                833234263154399,\n                2023862470013762,\n                1854137933982069,\n                853924318090959,\n                1589812702805850,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3679150557957763,\n                1319179453661745,\n                497496853611112,\n                2665464286942351,\n                1208137952365560,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1654513078530905,\n                907489875842908,\n                126098711296368,\n                1726320004173677,\n                28269495058173,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                114436686957443,\n                532739313025996,\n                115428841215897,\n                2191499400074366,\n                370280402676434,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1111146849833253,\n                2016430049079759,\n                1860522747477948,\n                3537164738290194,\n                4137142824844184,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                429069864577128,\n                975327637149449,\n                237881983565075,\n                1654761232378630,\n                2122527599091807,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2093793463548278,\n                754827233241879,\n                1420389751719629,\n                1829952782588138,\n                2011865756773717,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                676293365438898,\n                2850296017886344,\n                1205350322490195,\n                2763699392265669,\n                2133931188538142,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                48340340349120,\n                1299261101494832,\n                1137329686775218,\n                1534848106674340,\n                1351662218216799,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1904520614137939,\n                1590301001714014,\n                215781420985270,\n                2043534301034629,\n                1970888949300424,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2365217962409710,\n                2061307169694064,\n                1887478590157603,\n                2169639621284316,\n                2373810867477200,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1020052624656948,\n                1260412094216707,\n                366721640607121,\n                585331442306596,\n                345876457758061,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                975390299880933,\n                1066555195234642,\n                12651997758352,\n                1184252205433068,\n                1058378155074223,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1431537716602643,\n                2024827957433813,\n                3746434518400495,\n                1087794891033550,\n                2156817571680455,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                929288033346881,\n                255179964546973,\n                711057989588035,\n                208899572612840,\n                185348357387383,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                823689746424808,\n                47266130989546,\n                209403309368097,\n                1100966895202707,\n                710792075292719,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2311213117823762,\n                3296668540922318,\n                2004276520649823,\n                1861500579441125,\n                3148029033359833,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1563693677475261,\n                1843782073741194,\n                1950700654453170,\n                911540858113949,\n                2085151496302359,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1427880892005482,\n                106216431121745,\n                42608394782284,\n                1217295886989793,\n                1514235272796882,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3544335535746750,\n                2367994491347456,\n                2567261456502612,\n                1854058085060971,\n                2263545563461076,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                787426011300053,\n                2105981035769060,\n                1130476291127206,\n                1748659348100075,\n                53470983013756,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                553548273865386,\n                5927805718390,\n                65184587381926,\n                633576679686953,\n                576048559439973,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                993787326657446,\n                3868807161609258,\n                1615796046728943,\n                2514644292681953,\n                2059021068660907,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                251010270518880,\n                1681684095763484,\n                1521949356387564,\n                431593457045116,\n                1855308922422910,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                618490909691959,\n                1257497595618257,\n                202952467594088,\n                35577762721238,\n                1494883566841973,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1673474571932262,\n                2409784519770613,\n                2636095316260487,\n                2761112584601925,\n                3333713288149876,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1600640202645197,\n                1019569075331823,\n                1041916487915822,\n                1680448171313267,\n                2126903137527901,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                894964745143659,\n                106116880092678,\n                1009869382959477,\n                317866368542032,\n                1986983122763912,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1765281781276487,\n                2863247187455184,\n                2589075472439062,\n                1386435905543054,\n                2182338478845320,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1144730936996693,\n                2213315231278180,\n                1489676672185125,\n                665039429138074,\n                1131283313040268,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2004734176670602,\n                1738311085075235,\n                418866995976618,\n                1050782508034394,\n                577747313404652,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2185209688340293,\n                1309276076461009,\n                2514740038571278,\n                3994889904012999,\n                3018098826231021,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1405936970888515,\n                1754621155316654,\n                1211862168554999,\n                1813045702919083,\n                997853418197172,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                82037622045021,\n                1646398333621944,\n                613095452763466,\n                1312329542583705,\n                81014679202721,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2389287991277873,\n                403851022333257,\n                1597473361477193,\n                2953351602509212,\n                2135174663049062,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1826548187201150,\n                302299893734126,\n                1475477168615781,\n                842617616347376,\n                1438600873676130,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                663049852468609,\n                1649295727846569,\n                1048009692742781,\n                628866177992421,\n                1914360327429204,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1795645928096646,\n                306878154408959,\n                2924901319092394,\n                2801261341654799,\n                1653782432983523,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2077597317438627,\n                212642017882064,\n                674844477518888,\n                875487498687554,\n                2060550250171182,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1420448018683809,\n                1032663994771382,\n                1341927003385267,\n                1340360916546159,\n                1988547473895228,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1082660122598844,\n                2545055705583789,\n                3888919679589007,\n                1670283344995811,\n                3403239134794618,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                90430593339788,\n                1838338032241275,\n                571293238480915,\n                1639938867416883,\n                257378872001111,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1528535658865034,\n                1516636853043960,\n                787000569996728,\n                1464531394704506,\n                1684822625133795,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                811329918113934,\n                2783463529007378,\n                1769095754634835,\n                2970819621866866,\n                881037178164325,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1784566501964517,\n                433890943689325,\n                1186055625589419,\n                1496077405487512,\n                1731807117886548,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                424909811816304,\n                1355993963741797,\n                409606483251841,\n                455665350637068,\n                1617009023642808,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2478728492077816,\n                2780289048655501,\n                2328687177473769,\n                4107341333582032,\n                1316147724308250,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1617420574301156,\n                1741273341070467,\n                667135503486508,\n                2100436564640123,\n                1032223920000865,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1753947659404033,\n                247279202390193,\n                1819288880178945,\n                737334285670249,\n                1037873664856104,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1762568490530034,\n                673742465299012,\n                2054571050635888,\n                2040165159255111,\n                3040123733327257,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1627187989987422,\n                1686331580821752,\n                1309895873498183,\n                719718719104086,\n                300063199808722,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                238176707016164,\n                1440454788877048,\n                203336037573144,\n                1437789888677072,\n                101522256664211,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1895216760098480,\n                1934324337975022,\n                3677350688973167,\n                2536415965456176,\n                714678003308640,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                508185358728815,\n                1691320535341855,\n                2168887448239256,\n                1035124393070661,\n                1936603999698584,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                390562831571647,\n                1390223890708972,\n                1383183990676371,\n                435998174196410,\n                1882086414390730,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3747620842612921,\n                2081794785291195,\n                3284594056262745,\n                2090090346797895,\n                2581692978935809,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                244144781251265,\n                1290834426417077,\n                1888701171101942,\n                1233922456644870,\n                241117402207491,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1266169390045455,\n                1148042013187970,\n                878921907853942,\n                1815738019658093,\n                908920199341621,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2521768507305118,\n                953557056811112,\n                2015863732865770,\n                1358382511861315,\n                2835421647899992,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2239837206240498,\n                330928973149665,\n                422268062913642,\n                1481280019493032,\n                619879520439841,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1360166735366017,\n                1770556573948510,\n                1395061284191031,\n                1814003148068126,\n                522781147076884,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2611794802645686,\n                707234844948070,\n                1314059396506491,\n                2919250341703934,\n                2161831667832785,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                934831784182383,\n                433734253968318,\n                1660867106725771,\n                1968393082772831,\n                873946300968490,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                26306827827554,\n                430884999378685,\n                1504310424376419,\n                1761358720837522,\n                542195685418530,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1762131062631725,\n                3123952634417535,\n                3619918390837537,\n                2909990877347294,\n                1411594230004385,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                538272372224622,\n                1425714779586199,\n                588313661410172,\n                1497062084392578,\n                1602174047128512,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                907490361939255,\n                1963620338391363,\n                626927432296975,\n                1250748516081414,\n                959901171882527,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1335066153744413,\n                2887804660779657,\n                2653073855954038,\n                2765226981667422,\n                938831784476763,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                296699434737224,\n                2047543711075683,\n                2076451038937139,\n                227783599906901,\n                1602062110967627,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1574834773194203,\n                1384279952062839,\n                393652417255803,\n                2166968242848859,\n                1552890441390820,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1619646774410947,\n                1576090644023562,\n                3035228391320965,\n                1735328519940543,\n                2355324535937066,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1024074573633446,\n                957088456885874,\n                1690425531356997,\n                2102187380180052,\n                1082544623222033,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1871906170635853,\n                1719383891167200,\n                1584032250247862,\n                823764804192117,\n                2244048510084261,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                642147846489775,\n                3334304977145699,\n                305205716788147,\n                2589176626729533,\n                2224680511484174,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1734162377166545,\n                260713621840346,\n                157174591942595,\n                952544272517991,\n                222818702471733,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1213115494182947,\n                286778704335711,\n                2130189536016490,\n                308349182281342,\n                1217623948685491,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3360052266973635,\n                1843486583624091,\n                1561693837124349,\n                1084041964025479,\n                1866270922024009,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                460705465481210,\n                1968151453817859,\n                497005926994844,\n                625618055866751,\n                2176893440866887,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1655800250476757,\n                2036588542300609,\n                666447448675243,\n                1615721995750683,\n                1508669225186765,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2245948203759141,\n                1058306669699396,\n                1452898014240582,\n                3961024141962768,\n                1633235287338608,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                986647273684279,\n                1507266907811370,\n                1260572633649005,\n                2071672342077446,\n                695976026010857,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1312356620823495,\n                1635278548098567,\n                901946076841033,\n                585120475533168,\n                1240667113237384,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2313723935779695,\n                1506054666773895,\n                996040223525031,\n                636592914999692,\n                1497801917020297,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                292042016419794,\n                1158932298133044,\n                2062611870323738,\n                1946058478962569,\n                1749165808126286,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                654683942212830,\n                1526897351349087,\n                2006818439922838,\n                2194919327350361,\n                1451960776874416,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3015041017808905,\n                2951823141773809,\n                2584865668253675,\n                2508192032998563,\n                2582137700042019,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1628123495344283,\n                2072923641214546,\n                1647225812023982,\n                855655925244679,\n                1758126430071140,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1615895096489599,\n                275295258643784,\n                937665541219916,\n                1313496726746346,\n                1186468946422626,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1603070202850694,\n                2072127623773242,\n                1692648737212158,\n                2493373404187852,\n                1248948672117105,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                11167836031898,\n                596565174397990,\n                2196351068723859,\n                314744641791907,\n                1102014997250781,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1409047922401191,\n                69960384467966,\n                688103515547600,\n                1309746102488044,\n                150292892873778,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1986083055103168,\n                691715819340300,\n                1361811659746933,\n                3459052030333434,\n                1063594696046061,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1201987338414749,\n                2198784582460616,\n                1203335513981498,\n                489243077045066,\n                2205278143582433,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2034744376624534,\n                2077387101466387,\n                148448542974969,\n                1502697574577258,\n                473186584705655,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                472016956315960,\n                720786972252993,\n                2840633661190043,\n                3150798753357827,\n                2816563335499153,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                253464247569755,\n                168314237403057,\n                511780806170295,\n                1058862316549135,\n                1646858476817137,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                595092995922219,\n                1491311840717691,\n                291581784452778,\n                1569186646367854,\n                1031385061400544,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3483137021572755,\n                1526955102024322,\n                2778006642704458,\n                457549634924205,\n                1097420237736736,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1246991699537710,\n                81367319519439,\n                530844036072196,\n                163656863755855,\n                1950742455979290,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                191532664076407,\n                539378506082089,\n                1021612562876554,\n                1026603384732632,\n                1773368780410653,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                4144620731387879,\n                590179521333342,\n                4034023318016108,\n                2255745030335426,\n                2699746851701250,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2206599697359952,\n                553895797384417,\n                181689161933786,\n                1153123447919104,\n                778568064152659,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1706307000059211,\n                1885601289314487,\n                889758608505788,\n                550131729999853,\n                1006862664714268,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3210197754285058,\n                2048500453422630,\n                3403309827888207,\n                927154428508963,\n                4199813798872019,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                992058915374933,\n                476120535358775,\n                1973648780784340,\n                2025282643598818,\n                2182318983793230,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1343440812005821,\n                1316045839091795,\n                1884951299078063,\n                1765919609219175,\n                2197567554627988,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3129247779382818,\n                4415026969054274,\n                1900265885969643,\n                1528796215447059,\n                2172730393748688,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1773355092297603,\n                64654329538271,\n                1332124041660957,\n                748492100858001,\n                895500006200535,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                2000840647851980,\n                546565968824914,\n                420633283457524,\n                195470736374507,\n                1958689297569520,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                743138980705446,\n                3411117504637167,\n                2591389959690621,\n                2380042066577202,\n                3022267940115114,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                165947002229363,\n                115186103724967,\n                1068573292121517,\n                1842565776920938,\n                1969395681111987,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                553322266190633,\n                234265665613185,\n                484544650202821,\n                1238773526575826,\n                2017991917953668,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2581954631514051,\n                1245093644265357,\n                3537016673825374,\n                1834216551713857,\n                923978372152807,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1855378315339552,\n                890045579230758,\n                1764718173975590,\n                197904186055854,\n                1718129022310327,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1278162928734862,\n                1894118254109862,\n                987503995465517,\n                177406744098996,\n                781538103127693,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1996603431230215,\n                1191888797552937,\n                1207440075928499,\n                2765853449051137,\n                2525314961343288,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                808903879370889,\n                990820108751280,\n                1084429472258867,\n                1078562781312589,\n                254514692695625,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                615855140068469,\n                586046731175395,\n                693470779212674,\n                1964537100203868,\n                1350330550265229,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3344544372023708,\n                720386671449874,\n                2480841360702110,\n                2036034126860286,\n                2015744690201389,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1337446193390478,\n                1984110761311871,\n                746489405020285,\n                407347127604128,\n                1740475330360596,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                140840424783613,\n                1063284623568331,\n                1136446106453878,\n                372042229029799,\n                442607248430694,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2330781679120937,\n                376801425148230,\n                2032603686676107,\n                1488926293635130,\n                1317278311532959,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1290116731380016,\n                2166899563471713,\n                831997001838078,\n                870954980505220,\n                2108537278055823,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1912719171026343,\n                846194720551034,\n                2043988124740726,\n                993234269653961,\n                421229796383281,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2651184584992902,\n                2775702557638963,\n                2539786009779572,\n                2575974880015305,\n                2122619079836732,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1154054290132562,\n                931753998725577,\n                1647742001778052,\n                865765466488226,\n                1083816107290025,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                986341121095108,\n                1522330369638573,\n                1990880546211047,\n                501525962272123,\n                198539304862139,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1496414019192687,\n                3991034436173951,\n                3380311659062196,\n                2854747485359158,\n                3346958036643152,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                805612068303425,\n                1891790027761335,\n                1587008567571549,\n                722120737390201,\n                378156757163816,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1588994517921951,\n                977362751042302,\n                1329302387067714,\n                2069348224564088,\n                1586007159625211,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2490539421551682,\n                1985699850375015,\n                2331762317128172,\n                4145097393776678,\n                2521049460190674,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                615817553313996,\n                2245962768078178,\n                482564324326173,\n                2101336843140780,\n                1240914880829407,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1438242482238189,\n                874267817785463,\n                1620810389770625,\n                866155221338671,\n                1040426546798301,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                2403083624110300,\n                2548561409802975,\n                2492699136535911,\n                2358289519456539,\n                3203964320363148,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1913986535403097,\n                1977163223054199,\n                1972905914623196,\n                1650122133472502,\n                1905849310819035,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                858174816360838,\n                614595356564037,\n                1099584959044836,\n                636998087084906,\n                1070393269058348,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3666695924830668,\n                3585640662737501,\n                2372994528684236,\n                2628565977288995,\n                3482812783469694,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1994161359147952,\n                2198039369802658,\n                62790022842537,\n                1522306785848169,\n                951223194802833,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                852296621440717,\n                431889737774209,\n                370755457746189,\n                437604073958073,\n                627857326892757,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1794955764684156,\n                2586904290013612,\n                1322647643615887,\n                856117964085888,\n                2652432778663153,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                933592377399646,\n                78031722952813,\n                926049890685253,\n                1471649501316246,\n                33789909190376,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1479319468832059,\n                203906207621608,\n                659828362330083,\n                44358398435755,\n                1273573524210803,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1592342143350813,\n                3227219208247713,\n                2345240352078765,\n                2577750109932929,\n                2933512841197243,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2184946892642995,\n                1517382324576002,\n                1557940277419806,\n                2170635134813213,\n                747314658627002,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1823193620577742,\n                1135817878516419,\n                1731253819308581,\n                1031652967267804,\n                2123506616999453,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1346190246005805,\n                2052692552023851,\n                1718128041785940,\n                2491557332978474,\n                3474370880388305,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                424776012994573,\n                281050757243423,\n                626466040846420,\n                990194703866532,\n                38571969885982,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                192408346595466,\n                1054889725292349,\n                584097975693004,\n                1447909807397749,\n                2134645004369136,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3169895788615063,\n                3503097743181446,\n                601598510029975,\n                1422812237223371,\n                2121009661378329,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1603348391996783,\n                2066143816131699,\n                1789627290363958,\n                2145705961178118,\n                1985578641438222,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                352633958653380,\n                856927627345554,\n                793925083122702,\n                93551575767286,\n                1222010153634215,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1756866499986349,\n                911731956999969,\n                2707505543214075,\n                4006920335263786,\n                822501008147910,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1094036422864347,\n                1897208881572508,\n                1503607738246960,\n                1901060196071406,\n                294068411105729,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                587776484399576,\n                1116861711228807,\n                343398777436088,\n                936544065763093,\n                1643746750211060,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                3477749685790410,\n                267997399528836,\n                2953780922004404,\n                3252368924080907,\n                3787792887348381,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                2042368155872443,\n                41662387210459,\n                1676313264498480,\n                1333968523426810,\n                1765708383352310,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1453394896690938,\n                1585795827439909,\n                1469309456804303,\n                1294645324464404,\n                2042954198665899,\n            ]),\n        },\n        AffineNielsPoint {\n            y_plus_x: FieldElement51::from_limbs([\n                1810069207599881,\n                1358344669503239,\n                1989371257548167,\n                2316270051121225,\n                3019675451276507,\n            ]),\n            y_minus_x: FieldElement51::from_limbs([\n                1866114438287676,\n                1663420339568364,\n                1437691317033088,\n                538298302628038,\n                1212711449614363,\n            ]),\n            xy2d: FieldElement51::from_limbs([\n                1769235035677897,\n                1562012115317882,\n                31277513664750,\n                536198657928416,\n                1976134212537183,\n            ]),\n        },\n    ]);\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/constants.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63639": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2018 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! The `u64` backend uses `u64`s and a `(u64, u64) -> u128` multiplier.\n//!\n//! On x86_64, the idiom `(x as u128) * (y as u128)` lowers to `MUL`\n//! instructions taking 64-bit inputs and producing 128-bit outputs.  On\n//! other platforms, this implementation is not recommended.\n//!\n//! On Haswell and newer, the BMI2 extension provides `MULX`, and on\n//! Broadwell and newer, the ADX extension provides `ADCX` and `ADOX`\n//! (allowing the CPU to compute two carry chains in parallel).  These\n//! will be used if available.\n\npub mod field;\n\npub mod scalar;\n\npub mod constants;\n\npub mod field_verus;\n\npub mod field_lemmas;\n\npub mod common_verus;\n\npub mod subtle_assumes;\n\npub mod scalar_lemmas;\n\npub mod scalar_specs;\n\n// Placeholder\npub mod vstd_u128;\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/mod.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63640": {
    "text": "#[allow(unused_imports)]\nuse super::scalar::Scalar52;\n#[allow(unused_imports)]\nuse vstd::arithmetic::power2::*;\nuse vstd::prelude::*;\n\nverus! {\npub open spec fn seq_to_nat(limbs: Seq<nat>) -> nat\ndecreases limbs.len()\n{\n    if limbs.len() == 0 {\n        0\n    } else {\n        limbs[0] + seq_to_nat(limbs.subrange(1, limbs.len() as int)) * pow2(52)\n    }\n}\n\npub open spec fn slice128_to_nat(limbs: &[u128]) -> nat\n{\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}\n\npub open spec fn to_nat(limbs: &[u64]) -> nat\n{\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}\n\npub open spec fn nine_limbs_to_nat_aux(limbs: &[u128; 9]) -> nat {\n    (limbs[0] as nat) +\n    (limbs[1] as nat) * pow2(52) +\n    (limbs[2] as nat) * pow2(104) +\n    (limbs[3] as nat) * pow2(156) +\n    (limbs[4] as nat) * pow2(208) +\n    (limbs[5] as nat) * pow2(260) +\n    (limbs[6] as nat) * pow2(312) +\n    (limbs[7] as nat) * pow2(364) +\n    (limbs[8] as nat) * pow2(416)\n}\n\npub open spec fn five_limbs_to_nat_aux(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(52) * (limbs[1] as nat) +\n    pow2(104) * (limbs[2] as nat) +\n    pow2(156) * (limbs[3] as nat) +\n    pow2(208) * (limbs[4] as nat)\n}\n\n// Modular reduction of to_nat mod L\nspec fn to_scalar(limbs: &[u64; 5]) -> nat {\n    to_nat(limbs) % group_order()\n}\n\n/// natural value of a 256 bit bitstring represented as array of 32 bytes\npub open spec fn bytes_to_nat(bytes: &[u8; 32]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_to_nat_rec(bytes, 0)\n}\n\npub open spec fn bytes_to_nat_rec(bytes: &[u8; 32], index: int) -> nat\ndecreases 32 - index\n{\n    if index >= 32 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_to_nat_rec(bytes, index + 1)\n    }\n}\n\n/// natural value of a 512 bit bitstring represented as array of 64 bytes\npub open spec fn bytes_wide_to_nat(bytes: &[u8; 64]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_wide_to_nat_rec(bytes, 0)\n}\n\npub open spec fn bytes_wide_to_nat_rec(bytes: &[u8; 64], index: int) -> nat\ndecreases 64 - index\n{\n    if index >= 64 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_wide_to_nat_rec(bytes, index + 1)\n    }\n}\n\n// Generic function to convert array of words to natural number\n// Takes: array of words, number of words, bits per word\n// Note: This is a specification function that works with concrete types\npub open spec fn words_to_nat_gen_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u64(words, num_words - 1, bits_per_word)\n    }\n}\n\npub open spec fn words_to_nat_gen_u32(words: &[u32], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u32(words, num_words - 1, bits_per_word)\n    }\n}\n\n// natural value of a 256 bit bitstring represented as an array of 4 words of 64 bits\n// Now implemented using the generic function\npub open spec fn words_to_nat(words: &[u64; 4]) -> nat {\n    words_to_nat_gen_u64(words, 4, 64)\n}\n\n// Group order: the value of L as a natural number\npub open spec fn group_order() -> nat {\n    pow2(252) + 27742317777372353535851937790883648493nat\n}\n\n// Montgomery radix R = 2^260\npub open spec fn montgomery_radix() -> nat {\n    pow2(260)\n}\n\n// Check that all limbs of a Scalar52 are properly bounded (< 2^52)\npub open spec fn limbs_bounded(s: &Scalar52) -> bool {\n    forall|i: int| 0 <= i < 5 ==> s.limbs[i] < (1u64 << 52)\n}\n\n} // verus!\n",
    "filename": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
    "filepath": null,
    "folder_id": 15840,
    "user_id": 460154
  },
  "63641": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Scalar multiplication on the Montgomery form of Curve25519.\n//!\n//! To avoid notational confusion with the Edwards code, we use\n//! variables \\\\( u, v \\\\) for the Montgomery curve, so that “Montgomery\n//! \\\\(u\\\\)” here corresponds to “Montgomery \\\\(x\\\\)” elsewhere.\n//!\n//! Montgomery arithmetic works not on the curve itself, but on the\n//! \\\\(u\\\\)-line, which discards sign information and unifies the curve\n//! and its quadratic twist.  See [_Montgomery curves and their\n//! arithmetic_][costello-smith] by Costello and Smith for more details.\n//!\n//! The `MontgomeryPoint` struct contains the affine \\\\(u\\\\)-coordinate\n//! \\\\(u\\_0(P)\\\\) of a point \\\\(P\\\\) on either the curve or the twist.\n//! Here the map \\\\(u\\_0 : \\mathcal M \\rightarrow \\mathbb F\\_p \\\\) is\n//! defined by \\\\(u\\_0((u,v)) = u\\\\); \\\\(u\\_0(\\mathcal O) = 0\\\\).  See\n//! section 5.4 of Costello-Smith for more details.\n//!\n//! # Scalar Multiplication\n//!\n//! Scalar multiplication on `MontgomeryPoint`s is provided by the `*`\n//! operator, which implements the Montgomery ladder.\n//!\n//! # Edwards Conversion\n//!\n//! The \\\\(2\\\\)-to-\\\\(1\\\\) map from the Edwards model to the Montgomery\n//! \\\\(u\\\\)-line is provided by `EdwardsPoint::to_montgomery()`.\n//!\n//! To lift a `MontgomeryPoint` to an `EdwardsPoint`, use\n//! `MontgomeryPoint::to_edwards()`, which takes a sign parameter.\n//! This function rejects `MontgomeryPoints` which correspond to points\n//! on the twist.\n//!\n//! [costello-smith]: https://eprint.iacr.org/2017/212.pdf\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nuse core::{\n    hash::{Hash, Hasher},\n    ops::{Mul, MulAssign},\n};\n\nuse crate::constants::{APLUS2_OVER_FOUR, MONTGOMERY_A, MONTGOMERY_A_NEG};\nuse crate::edwards::{CompressedEdwardsY, EdwardsPoint};\nuse crate::field::FieldElement;\nuse crate::scalar::{Scalar, clamp_integer};\n\nuse crate::traits::Identity;\n\nuse subtle::Choice;\nuse subtle::ConstantTimeEq;\nuse subtle::{ConditionallyNegatable, ConditionallySelectable};\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\n/// Holds the \\\\(u\\\\)-coordinate of a point on the Montgomery form of\n/// Curve25519 or its twist.\n#[derive(Copy, Clone, Debug, Default)]\n#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct MontgomeryPoint(pub [u8; 32]);\n\n/// Equality of `MontgomeryPoint`s is defined mod p.\nimpl ConstantTimeEq for MontgomeryPoint {\n    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }\n}\n\nimpl ConditionallySelectable for MontgomeryPoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(<[u8; 32]>::conditional_select(&a.0, &b.0, choice))\n    }\n}\n\nimpl PartialEq for MontgomeryPoint {\n    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for MontgomeryPoint {}\n\n// Equal MontgomeryPoints must hash to the same value. So we have to get them into a canonical\n// encoding first\nimpl Hash for MontgomeryPoint {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        // Do a round trip through a `FieldElement`. `as_bytes` is guaranteed to give a canonical\n        // 32-byte encoding\n        let canonical_bytes = FieldElement::from_bytes(&self.0).to_bytes();\n        canonical_bytes.hash(state);\n    }\n}\n\nimpl Identity for MontgomeryPoint {\n    /// Return the group identity element, which has order 4.\n    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for MontgomeryPoint {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}\n\nimpl MontgomeryPoint {\n    /// Fixed-base scalar multiplication (i.e. multiplication by the base point).\n    pub fn mul_base(scalar: &Scalar) -> Self {\n        EdwardsPoint::mul_base(scalar).to_montgomery()\n    }\n\n    /// Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }\n\n    /// Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }\n\n    /// Given `self` \\\\( = u\\_0(P) \\\\), and a big-endian bit representation of an integer\n    /// \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\). This is constant time in the length of `bits`.\n    ///\n    /// **NOTE:** You probably do not want to use this function. Almost every protocol built on\n    /// Curve25519 uses _clamped multiplication_, explained\n    /// [here](https://neilmadden.blog/2020/05/28/whats-the-curve25519-clamping-all-about/).\n    /// When in doubt, use [`Self::mul_clamped`].\n    pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2\n        let mut prev_bit = false;\n        for cur_bit in bits {\n            let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        #[cfg(feature = \"zeroize\")]\n        prev_bit.zeroize();\n\n        x0.as_affine()\n    }\n\n    /// View this `MontgomeryPoint` as an array of bytes.\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n\n    /// Convert this `MontgomeryPoint` to an array of bytes.\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// Attempt to convert to an `EdwardsPoint`, using the supplied\n    /// choice of sign for the `EdwardsPoint`.\n    ///\n    /// # Inputs\n    ///\n    /// * `sign`: a `u8` donating the desired sign of the resulting\n    ///   `EdwardsPoint`.  `0` denotes positive and `1` negative.\n    ///\n    /// # Return\n    ///\n    /// * `Some(EdwardsPoint)` if `self` is the \\\\(u\\\\)-coordinate of a\n    ///   point on (the Montgomery form of) Curve25519;\n    ///\n    /// * `None` if `self` is the \\\\(u\\\\)-coordinate of a point on the\n    ///   twist of (the Montgomery form of) Curve25519;\n    ///\n    pub fn to_edwards(&self, sign: u8) -> Option<EdwardsPoint> {\n        // To decompress the Montgomery u coordinate to an\n        // `EdwardsPoint`, we apply the birational map to obtain the\n        // Edwards y coordinate, then do Edwards decompression.\n        //\n        // The birational map is y = (u-1)/(u+1).\n        //\n        // The exceptional points are the zeros of the denominator,\n        // i.e., u = -1.\n        //\n        // But when u = -1, v^2 = u*(u^2+486662*u+1) = 486660.\n        //\n        // Since this is nonsquare mod p, u = -1 corresponds to a point\n        // on the twist, not the curve, so we can reject it early.\n\n        let u = FieldElement::from_bytes(&self.0);\n\n        if u == FieldElement::MINUS_ONE {\n            return None;\n        }\n\n        let one = FieldElement::ONE;\n\n        let y = &(&u - &one) * &(&u + &one).invert();\n\n        let mut y_bytes = y.to_bytes();\n        y_bytes[31] ^= sign << 7;\n\n        CompressedEdwardsY(y_bytes).decompress()\n    }\n}\n\n/// Perform the Elligator2 mapping to a Montgomery point. Returns a Montgomery point and a `Choice`\n/// determining whether eps is a square. This is required by the standard to determine the\n/// sign of the v coordinate.\n///\n/// See <https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method>\n//\n#[allow(unused)]\npub(crate) fn elligator_encode(r_0: &FieldElement) -> (MontgomeryPoint, Choice) {\n    let one = FieldElement::ONE;\n    let d_1 = &one + &r_0.square2(); /* 2r^2 */\n\n    let d = &MONTGOMERY_A_NEG * &(d_1.invert()); /* A/(1+2r^2) */\n\n    let d_sq = &d.square();\n    let au = &MONTGOMERY_A * &d;\n\n    let inner = &(d_sq + &au) + &one;\n    let eps = &d * &inner; /* eps = d^3 + Ad^2 + d */\n\n    let (eps_is_sq, _eps) = FieldElement::sqrt_ratio_i(&eps, &one);\n\n    let zero = FieldElement::ZERO;\n    let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/\n    let mut u = &d + &Atemp; /* d, or d+A if nonsquare */\n    u.conditional_negate(!eps_is_sq); /* d, or -d-A if nonsquare */\n\n    (MontgomeryPoint(u.to_bytes()), eps_is_sq)\n}\n\n/// A `ProjectivePoint` holds a point on the projective line\n/// \\\\( \\mathbb P(\\mathbb F\\_p) \\\\), which we identify with the Kummer\n/// line of the Montgomery curve.\n#[derive(Copy, Clone, Debug)]\nstruct ProjectivePoint {\n    pub U: FieldElement,\n    pub W: FieldElement,\n}\n\nimpl Identity for ProjectivePoint {\n    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for ProjectivePoint {\n    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }\n}\n\nimpl ConditionallySelectable for ProjectivePoint {\n    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }\n}\n\nimpl ProjectivePoint {\n    /// Dehomogenize this point to affine coordinates.\n    ///\n    /// # Return\n    ///\n    /// * \\\\( u = U / W \\\\) if \\\\( W \\neq 0 \\\\);\n    /// * \\\\( 0 \\\\) if \\\\( W \\eq 0 \\\\);\n    pub fn as_affine(&self) -> MontgomeryPoint {\n        let u = &self.U * &self.W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }\n}\n\n/// Perform the double-and-add step of the Montgomery ladder.\n///\n/// Given projective points\n/// \\\\( (U\\_P : W\\_P) = u(P) \\\\),\n/// \\\\( (U\\_Q : W\\_Q) = u(Q) \\\\),\n/// and the affine difference\n/// \\\\(      u\\_{P-Q} = u(P-Q) \\\\), set\n/// $$\n///     (U\\_P : W\\_P) \\gets u(\\[2\\]P)\n/// $$\n/// and\n/// $$\n///     (U\\_Q : W\\_Q) \\gets u(P + Q).\n/// $$\n#[rustfmt::skip] // keep alignment of explanatory comments\nfn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = &P.U + &P.W;\n    let t1 = &P.U - &P.W;\n    let t2 = &Q.U + &Q.W;\n    let t3 = &Q.U - &Q.W;\n\n    let t4 = t0.square();   // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square();   // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = &t4 - &t5;     // 4 U_P W_P\n\n    let t7 = &t0 * &t3;     // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = &t1 * &t2;     // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9  = &t7 + &t8;    // 2 (U_P U_Q - W_P W_Q)\n    let t10 = &t7 - &t8;    // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 =  t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n\n    let t13 = &APLUS2_OVER_FOUR * &t6; // (A + 2) U_P U_Q\n\n    let t14 = &t4 * &t5;    // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = &t13 + &t5;   // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = &t6 * &t15;   // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n\n    let t17 = affine_PmQ * &t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11;               // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14;  // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16;  // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18;  // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17;  // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}\n\ndefine_mul_assign_variants!(LHS = MontgomeryPoint, RHS = Scalar);\n\ndefine_mul_variants!(\n    LHS = MontgomeryPoint,\n    RHS = Scalar,\n    Output = MontgomeryPoint\n);\ndefine_mul_variants!(\n    LHS = Scalar,\n    RHS = MontgomeryPoint,\n    Output = MontgomeryPoint\n);\n\n/// Multiply this `MontgomeryPoint` by a `Scalar`.\nimpl Mul<&Scalar> for &MontgomeryPoint {\n    type Output = MontgomeryPoint;\n\n    /// Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)\n    fn mul(self, scalar: &Scalar) -> MontgomeryPoint {\n        // We multiply by the integer representation of the given Scalar. By scalar invariant #1,\n        // the MSB is 0, so we can skip it.\n        self.mul_bits_be(scalar.bits_le().rev().skip(1))\n    }\n}\n\nimpl MulAssign<&Scalar> for MontgomeryPoint {\n    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }\n}\n\nimpl Mul<&MontgomeryPoint> for &Scalar {\n    type Output = MontgomeryPoint;\n\n    fn mul(self, point: &MontgomeryPoint) -> MontgomeryPoint {\n        point * self\n    }\n}\n\n// ------------------------------------------------------------------------\n// Tests\n// ------------------------------------------------------------------------\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::constants;\n\n    #[cfg(feature = \"alloc\")]\n    use alloc::vec::Vec;\n\n    use rand_core::{CryptoRng, RngCore, TryRngCore};\n\n    #[test]\n    fn identity_in_different_coordinates() {\n        let id_projective = ProjectivePoint::identity();\n        let id_montgomery = id_projective.as_affine();\n\n        assert!(id_montgomery == MontgomeryPoint::identity());\n    }\n\n    #[test]\n    fn identity_in_different_models() {\n        assert!(EdwardsPoint::identity().to_montgomery() == MontgomeryPoint::identity());\n    }\n\n    #[test]\n    #[cfg(feature = \"serde\")]\n    fn serde_bincode_basepoint_roundtrip() {\n        use bincode;\n\n        let encoded = bincode::serialize(&constants::X25519_BASEPOINT).unwrap();\n        let decoded: MontgomeryPoint = bincode::deserialize(&encoded).unwrap();\n\n        assert_eq!(encoded.len(), 32);\n        assert_eq!(decoded, constants::X25519_BASEPOINT);\n\n        let raw_bytes = constants::X25519_BASEPOINT.as_bytes();\n        let bp: MontgomeryPoint = bincode::deserialize(raw_bytes).unwrap();\n        assert_eq!(bp, constants::X25519_BASEPOINT);\n    }\n\n    /// Test Montgomery -> Edwards on the X/Ed25519 basepoint\n    #[test]\n    fn basepoint_montgomery_to_edwards() {\n        // sign bit = 0 => basepoint\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT,\n            constants::X25519_BASEPOINT.to_edwards(0).unwrap()\n        );\n        // sign bit = 1 => minus basepoint\n        assert_eq!(\n            -constants::ED25519_BASEPOINT_POINT,\n            constants::X25519_BASEPOINT.to_edwards(1).unwrap()\n        );\n    }\n\n    /// Test Edwards -> Montgomery on the X/Ed25519 basepoint\n    #[test]\n    fn basepoint_edwards_to_montgomery() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT.to_montgomery(),\n            constants::X25519_BASEPOINT\n        );\n    }\n\n    /// Check that Montgomery -> Edwards fails for points on the twist.\n    #[test]\n    fn montgomery_to_edwards_rejects_twist() {\n        let one = FieldElement::ONE;\n\n        // u = 2 corresponds to a point on the twist.\n        let two = MontgomeryPoint((&one + &one).to_bytes());\n\n        assert!(two.to_edwards(0).is_none());\n\n        // u = -1 corresponds to a point on the twist, but should be\n        // checked explicitly because it's an exceptional point for the\n        // birational map.  For instance, libsignal will accept it.\n        let minus_one = MontgomeryPoint((-&one).to_bytes());\n\n        assert!(minus_one.to_edwards(0).is_none());\n    }\n\n    #[test]\n    fn eq_defined_mod_p() {\n        let mut u18_bytes = [0u8; 32];\n        u18_bytes[0] = 18;\n        let u18 = MontgomeryPoint(u18_bytes);\n        let u18_unred = MontgomeryPoint([255; 32]);\n\n        assert_eq!(u18, u18_unred);\n    }\n\n    /// Returns a random point on the prime-order subgroup\n    fn rand_prime_order_point<R: CryptoRng + ?Sized>(rng: &mut R) -> EdwardsPoint {\n        let s: Scalar = Scalar::random(rng);\n        EdwardsPoint::mul_base(&s)\n    }\n\n    /// Given a bytestring that's little-endian at the byte level, return an iterator over all the\n    /// bits, in little-endian order.\n    fn bytestring_bits_le(x: &[u8]) -> impl DoubleEndedIterator<Item = bool> + Clone + '_ {\n        let bitlen = x.len() * 8;\n        (0..bitlen).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((x[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }\n\n    #[test]\n    fn montgomery_ladder_matches_edwards_scalarmult() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            let p_edwards = rand_prime_order_point(&mut csprng);\n            let p_montgomery: MontgomeryPoint = p_edwards.to_montgomery();\n\n            let s: Scalar = Scalar::random(&mut csprng);\n            let expected = s * p_edwards;\n            let result = s * p_montgomery;\n\n            assert_eq!(result, expected.to_montgomery())\n        }\n    }\n\n    // Tests that, on the prime-order subgroup, MontgomeryPoint::mul_bits_be is the same as\n    // multiplying by the Scalar representation of the same bits\n    #[test]\n    fn montgomery_mul_bits_be() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            // Make a random prime-order point P\n            let p_edwards = rand_prime_order_point(&mut csprng);\n            let p_montgomery: MontgomeryPoint = p_edwards.to_montgomery();\n\n            // Make a random integer b\n            let mut bigint = [0u8; 64];\n            csprng.fill_bytes(&mut bigint[..]);\n            let bigint_bits_be = bytestring_bits_le(&bigint).rev();\n\n            // Check that bP is the same whether calculated as scalar-times-edwards or\n            // integer-times-montgomery.\n            let expected = Scalar::from_bytes_mod_order_wide(&bigint) * p_edwards;\n            let result = p_montgomery.mul_bits_be(bigint_bits_be);\n            assert_eq!(result, expected.to_montgomery())\n        }\n    }\n\n    // Tests that MontgomeryPoint::mul_bits_be is consistent on any point, even ones that might be\n    // on the curve's twist. Specifically, this tests that b₁(b₂P) == b₂(b₁P) for random\n    // integers b₁, b₂ and random (curve or twist) point P.\n    #[test]\n    fn montgomery_mul_bits_be_twist() {\n        let mut csprng = rand_core::OsRng.unwrap_err();\n\n        for _ in 0..100 {\n            // Make a random point P on the curve or its twist\n            let p_montgomery = {\n                let mut buf = [0u8; 32];\n                csprng.fill_bytes(&mut buf);\n                MontgomeryPoint(buf)\n            };\n\n            // Compute two big integers b₁ and b₂\n            let mut bigint1 = [0u8; 64];\n            let mut bigint2 = [0u8; 64];\n            csprng.fill_bytes(&mut bigint1[..]);\n            csprng.fill_bytes(&mut bigint2[..]);\n\n            // Compute b₁P and b₂P\n            let bigint1_bits_be = bytestring_bits_le(&bigint1).rev();\n            let bigint2_bits_be = bytestring_bits_le(&bigint2).rev();\n            let prod1 = p_montgomery.mul_bits_be(bigint1_bits_be.clone());\n            let prod2 = p_montgomery.mul_bits_be(bigint2_bits_be.clone());\n\n            // Check that b₁(b₂P) == b₂(b₁P)\n            assert_eq!(\n                prod1.mul_bits_be(bigint2_bits_be),\n                prod2.mul_bits_be(bigint1_bits_be)\n            );\n        }\n    }\n\n    /// Check that mul_base_clamped and mul_clamped agree\n    #[test]\n    fn mul_base_clamped() {\n        let mut csprng = rand_core::OsRng;\n\n        // Test agreement on a large integer. Even after clamping, this is not reduced mod l.\n        let a_bytes = [0xff; 32];\n        assert_eq!(\n            MontgomeryPoint::mul_base_clamped(a_bytes),\n            constants::X25519_BASEPOINT.mul_clamped(a_bytes)\n        );\n\n        // Test agreement on random integers\n        for _ in 0..100 {\n            // This will be reduced mod l with probability l / 2^256 ≈ 6.25%\n            let mut a_bytes = [0u8; 32];\n            csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n            assert_eq!(\n                MontgomeryPoint::mul_base_clamped(a_bytes),\n                constants::X25519_BASEPOINT.mul_clamped(a_bytes)\n            );\n        }\n    }\n\n    #[cfg(feature = \"alloc\")]\n    const ELLIGATOR_CORRECT_OUTPUT: [u8; 32] = [\n        0x5f, 0x35, 0x20, 0x00, 0x1c, 0x6c, 0x99, 0x36, 0xa3, 0x12, 0x06, 0xaf, 0xe7, 0xc7, 0xac,\n        0x22, 0x4e, 0x88, 0x61, 0x61, 0x9b, 0xf9, 0x88, 0x72, 0x44, 0x49, 0x15, 0x89, 0x9d, 0x95,\n        0xf4, 0x6e,\n    ];\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn montgomery_elligator_correct() {\n        let bytes: Vec<u8> = (0u8..32u8).collect();\n        let bits_in: [u8; 32] = (&bytes[..]).try_into().expect(\"Range invariant broken\");\n\n        let fe = FieldElement::from_bytes(&bits_in);\n        let (eg, _) = elligator_encode(&fe);\n        assert_eq!(eg.to_bytes(), ELLIGATOR_CORRECT_OUTPUT);\n    }\n\n    #[test]\n    fn montgomery_elligator_zero_zero() {\n        let zero = [0u8; 32];\n        let fe = FieldElement::from_bytes(&zero);\n        let (eg, _) = elligator_encode(&fe);\n        assert_eq!(eg.to_bytes(), zero);\n    }\n}\n",
    "filename": "curve25519-dalek/src/montgomery.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63642": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2020 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Group operations for Curve25519, in Edwards form.\n//!\n//! ## Encoding and Decoding\n//!\n//! Encoding is done by converting to and from a `CompressedEdwardsY`\n//! struct, which is a typed wrapper around `[u8; 32]`.\n//!\n//! ## Equality Testing\n//!\n//! The `EdwardsPoint` struct implements the [`subtle::ConstantTimeEq`]\n//! trait for constant-time equality checking, and also uses this to\n//! ensure `Eq` equality checking runs in constant time.\n//!\n//! ## Cofactor-related functions\n//!\n//! The order of the group of points on the curve \\\\(\\mathcal E\\\\)\n//! is \\\\(|\\mathcal E| = 8\\ell \\\\), so its structure is \\\\( \\mathcal\n//! E = \\mathcal E\\[8\\] \\times \\mathcal E[\\ell]\\\\).  The torsion\n//! subgroup \\\\( \\mathcal E\\[8\\] \\\\) consists of eight points of small\n//! order.  Technically, all of \\\\(\\mathcal E\\\\) is torsion, but we\n//! use the word only to refer to the small \\\\(\\mathcal E\\[8\\]\\\\) part, not\n//! the large prime-order \\\\(\\mathcal E[\\ell]\\\\) part.\n//!\n//! To test if a point is in \\\\( \\mathcal E\\[8\\] \\\\), use\n//! [`EdwardsPoint::is_small_order`].\n//!\n//! To test if a point is in \\\\( \\mathcal E[\\ell] \\\\), use\n//! [`EdwardsPoint::is_torsion_free`].\n//!\n//! To multiply by the cofactor, use [`EdwardsPoint::mul_by_cofactor`].\n//!\n//! To avoid dealing with cofactors entirely, consider using Ristretto.\n//!\n//! ## Scalars\n//!\n//! Scalars are represented by the [`Scalar`] struct. To construct a scalar, see\n//! [`Scalar::from_canonical_bytes`] or [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! ## Scalar Multiplication\n//!\n//! Scalar multiplication on Edwards points is provided by:\n//!\n//! * the `*` operator between a `Scalar` and a `EdwardsPoint`, which\n//!   performs constant-time variable-base scalar multiplication;\n//!\n//! * the `*` operator between a `Scalar` and a\n//!   `EdwardsBasepointTable`, which performs constant-time fixed-base\n//!   scalar multiplication;\n//!\n//! * an implementation of the\n//!   [`MultiscalarMul`](../traits/trait.MultiscalarMul.html) trait for\n//!   constant-time variable-base multiscalar multiplication;\n//!\n//! * an implementation of the\n//!   [`VartimeMultiscalarMul`](../traits/trait.VartimeMultiscalarMul.html)\n//!   trait for variable-time variable-base multiscalar multiplication;\n//!\n//! ## Implementation\n//!\n//! The Edwards arithmetic is implemented using the “extended twisted\n//! coordinates” of Hisil, Wong, Carter, and Dawson, and the\n//! corresponding complete formulas.  For more details,\n//! see the [`curve_models` submodule][curve_models]\n//! of the internal documentation.\n//!\n//! ## Validity Checking\n//!\n//! There is no function for checking whether a point is valid.\n//! Instead, the `EdwardsPoint` struct is guaranteed to hold a valid\n//! point on the curve.\n//!\n//! We use the Rust type system to make invalid points\n//! unrepresentable: `EdwardsPoint` objects can only be created via\n//! successful decompression of a compressed point, or else by\n//! operations on other (valid) `EdwardsPoint`s.\n//!\n//! [curve_models]: https://docs.rs/curve25519-dalek/latest/curve25519-dalek/backend/serial/curve_models/index.html\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\nmod affine;\n\nuse cfg_if::cfg_if;\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};\nuse core::ops::{Mul, MulAssign};\n\n#[cfg(feature = \"digest\")]\nuse digest::{\n    FixedOutput, HashMarker, array::typenum::U64, consts::True, crypto_common::BlockSizeUser,\n    typenum::IsGreater,\n};\n\n#[cfg(feature = \"group\")]\nuse {\n    group::{GroupEncoding, cofactor::CofactorGroup, prime::PrimeGroup},\n    rand_core::TryRngCore,\n    subtle::CtOption,\n};\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::RngCore;\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse crate::constants;\n\nuse crate::field::FieldElement;\nuse crate::scalar::{Scalar, clamp_integer};\n\nuse crate::montgomery::MontgomeryPoint;\n\nuse crate::backend::serial::curve_models::AffineNielsPoint;\nuse crate::backend::serial::curve_models::CompletedPoint;\nuse crate::backend::serial::curve_models::ProjectiveNielsPoint;\nuse crate::backend::serial::curve_models::ProjectivePoint;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::window::{\n    LookupTableRadix16, LookupTableRadix32, LookupTableRadix64, LookupTableRadix128,\n    LookupTableRadix256,\n};\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::traits::BasepointTable;\n\nuse crate::traits::ValidityCheck;\nuse crate::traits::{Identity, IsIdentity};\n\nuse affine::AffinePoint;\n\n#[cfg(feature = \"alloc\")]\nuse crate::traits::MultiscalarMul;\n#[cfg(feature = \"alloc\")]\nuse crate::traits::{VartimeMultiscalarMul, VartimePrecomputedMultiscalarMul};\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\n// ------------------------------------------------------------------------\n// Compressed points\n// ------------------------------------------------------------------------\n\n/// In \"Edwards y\" / \"Ed25519\" format, the curve point \\\\((x,y)\\\\) is\n/// determined by the \\\\(y\\\\)-coordinate and the sign of \\\\(x\\\\).\n///\n/// The first 255 bits of a `CompressedEdwardsY` represent the\n/// \\\\(y\\\\)-coordinate.  The high bit of the 32nd byte gives the sign of \\\\(x\\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct CompressedEdwardsY(pub [u8; 32]);\n\nimpl ConstantTimeEq for CompressedEdwardsY {\n    fn ct_eq(&self, other: &CompressedEdwardsY) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }\n}\n\nimpl Eq for CompressedEdwardsY {}\nimpl PartialEq for CompressedEdwardsY {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Debug for CompressedEdwardsY {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }\n}\n\nimpl CompressedEdwardsY {\n    /// View this `CompressedEdwardsY` as an array of bytes.\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n\n    /// Copy this `CompressedEdwardsY` to an array of bytes.\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// Attempt to decompress to an `EdwardsPoint`.\n    ///\n    /// Returns `None` if the input is not the \\\\(y\\\\)-coordinate of a\n    /// curve point.\n    pub fn decompress(&self) -> Option<EdwardsPoint> {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        if is_valid_y_coord.into() {\n            Some(decompress::step_2(self, X, Y, Z))\n        } else {\n            None\n        }\n    }\n}\n\nmod decompress {\n    use super::*;\n\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y²-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy²+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }\n\n    #[rustfmt::skip]\n    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> EdwardsPoint {\n         // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n         // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n        X.conditional_negate(compressed_sign_bit);\n\n        EdwardsPoint {\n            X,\n            Y,\n            Z,\n            T: &X * &Y,\n        }\n    }\n}\n\nimpl TryFrom<&[u8]> for CompressedEdwardsY {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Serde support\n// ------------------------------------------------------------------------\n// Serializes to and from `EdwardsPoint` directly, doing compression\n// and decompression internally.  This means that users can create\n// structs containing `EdwardsPoint`s and use Serde's derived\n// serializers to serialize those structures.\n\n#[cfg(feature = \"digest\")]\nuse constants::ED25519_SQRTAM2;\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for EdwardsPoint {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.compress().as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for CompressedEdwardsY {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for EdwardsPoint {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct EdwardsPointVisitor;\n\n        impl<'de> Visitor<'de> for EdwardsPointVisitor {\n            type Value = EdwardsPoint;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"a valid point in Edwards y + sign format\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<EdwardsPoint, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                CompressedEdwardsY(bytes)\n                    .decompress()\n                    .ok_or_else(|| serde::de::Error::custom(\"decompression failed\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, EdwardsPointVisitor)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for CompressedEdwardsY {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct CompressedEdwardsYVisitor;\n\n        impl<'de> Visitor<'de> for CompressedEdwardsYVisitor {\n            type Value = CompressedEdwardsY;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"32 bytes of data\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<CompressedEdwardsY, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Ok(CompressedEdwardsY(bytes))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, CompressedEdwardsYVisitor)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Internal point representations\n// ------------------------------------------------------------------------\n\n/// An `EdwardsPoint` represents a point on the Edwards form of Curve25519.\n#[derive(Copy, Clone)]\n#[allow(missing_docs)]\npub struct EdwardsPoint {\n    pub(crate) X: FieldElement,\n    pub(crate) Y: FieldElement,\n    pub(crate) Z: FieldElement,\n    pub(crate) T: FieldElement,\n}\n\n// ------------------------------------------------------------------------\n// Constructors\n// ------------------------------------------------------------------------\n\nimpl Identity for CompressedEdwardsY {\n    fn identity() -> CompressedEdwardsY {\n        CompressedEdwardsY([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ])\n    }\n}\n\nimpl Default for CompressedEdwardsY {\n    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }\n}\n\nimpl CompressedEdwardsY {\n    /// Construct a `CompressedEdwardsY` from a slice of bytes.\n    ///\n    /// # Errors\n    ///\n    /// Returns [`TryFromSliceError`] if the input `bytes` slice does not have\n    /// a length of 32.\n    pub fn from_slice(bytes: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        bytes.try_into().map(CompressedEdwardsY)\n    }\n}\n\nimpl Identity for EdwardsPoint {\n    fn identity() -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        }\n    }\n}\n\nimpl Default for EdwardsPoint {\n    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Zeroize implementations for wiping points from memory\n// ------------------------------------------------------------------------\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for CompressedEdwardsY {\n    /// Reset this `CompressedEdwardsY` to the compressed form of the identity element.\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n        self.0[0] = 1;\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for EdwardsPoint {\n    /// Reset this `EdwardsPoint` to the identity element.\n    fn zeroize(&mut self) {\n        self.X.zeroize();\n        self.Y = FieldElement::ONE;\n        self.Z = FieldElement::ONE;\n        self.T.zeroize();\n    }\n}\n\n// ------------------------------------------------------------------------\n// Validity checks (for debugging, not CT)\n// ------------------------------------------------------------------------\n\nimpl ValidityCheck for EdwardsPoint {\n    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }\n}\n\n// ------------------------------------------------------------------------\n// Constant-time assignment\n// ------------------------------------------------------------------------\n\nimpl ConditionallySelectable for EdwardsPoint {\n    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Equality\n// ------------------------------------------------------------------------\n\nimpl ConstantTimeEq for EdwardsPoint {\n    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }\n}\n\nimpl PartialEq for EdwardsPoint {\n    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for EdwardsPoint {}\n\n// ------------------------------------------------------------------------\n// Point conversions\n// ------------------------------------------------------------------------\n\nimpl EdwardsPoint {\n    /// Convert to a ProjectiveNielsPoint\n    pub(crate) fn as_projective_niels(&self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: &self.Y + &self.X,\n            Y_minus_X: &self.Y - &self.X,\n            Z: self.Z,\n            T2d: &self.T * &constants::EDWARDS_D2,\n        }\n    }\n\n    /// Convert the representation of this point from extended\n    /// coordinates to projective coordinates.\n    ///\n    /// Free.\n    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n        }\n    }\n\n    /// Dehomogenize to a `AffineNielsPoint`.\n    /// Mainly for testing.\n    pub(crate) fn as_affine_niels(&self) -> AffineNielsPoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let xy2d = &(&x * &y) * &constants::EDWARDS_D2;\n        AffineNielsPoint {\n            y_plus_x: &y + &x,\n            y_minus_x: &y - &x,\n            xy2d,\n        }\n    }\n\n    /// Dehomogenize to `AffinePoint`.\n    pub(crate) fn to_affine(self) -> AffinePoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        AffinePoint { x, y }\n    }\n\n    /// Convert this `EdwardsPoint` on the Edwards model to the\n    /// corresponding `MontgomeryPoint` on the Montgomery model.\n    ///\n    /// This function has one exceptional case; the identity point of\n    /// the Edwards curve is sent to the 2-torsion point \\\\((0,0)\\\\)\n    /// on the Montgomery curve.\n    ///\n    /// Note that this is a one-way conversion, since the Montgomery\n    /// model does not retain sign information.\n    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        let u = &U * &W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }\n\n    /// Converts a large batch of points to Edwards at once. This has the same\n    /// behavior on identity elements as [`Self::to_montgomery`].\n    #[cfg(feature = \"alloc\")]\n    pub fn to_montgomery_batch(eds: &[Self]) -> Vec<MontgomeryPoint> {\n        // Do the same thing as the above function. u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        // We will do this in a batch, ie compute (Z-Y) for all the input\n        // points, then invert them all at once\n\n        // Compute the denominators in a batch\n        let mut denominators = eds.iter().map(|p| &p.Z - &p.Y).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut denominators);\n\n        // Now compute the Montgomery u coordinate for every point\n        let mut ret = Vec::with_capacity(eds.len());\n        for (ed, d) in eds.iter().zip(denominators.iter()) {\n            let u = &(&ed.Z + &ed.Y) * d;\n            ret.push(MontgomeryPoint(u.to_bytes()));\n        }\n\n        ret\n    }\n\n    /// Compress this point to `CompressedEdwardsY` format.\n    pub fn compress(&self) -> CompressedEdwardsY {\n        self.to_affine().compress()\n    }\n\n    /// Compress several `EdwardsPoint`s into `CompressedEdwardsY` format, using a batch inversion\n    /// for a significant speedup.\n    #[cfg(feature = \"alloc\")]\n    pub fn compress_batch(inputs: &[EdwardsPoint]) -> Vec<CompressedEdwardsY> {\n        let mut zs = inputs.iter().map(|input| input.Z).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut zs);\n\n        inputs\n            .iter()\n            .zip(&zs)\n            .map(|(input, recip)| {\n                let x = &input.X * recip;\n                let y = &input.Y * recip;\n                AffinePoint { x, y }.compress()\n            })\n            .collect()\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Perform hashing to curve, with explicit hash function and domain separator, `domain_sep`,\n    /// using the suite `edwards25519_XMD:SHA-512_ELL2_NU_`. The input is the concatenation of the\n    /// elements of `bytes`. Likewise for the domain separator with `domain_sep`. At least one\n    /// element of `domain_sep`, MUST be nonempty, and the concatenation MUST NOT exceed\n    /// 255 bytes.\n    ///\n    /// # Panics\n    /// Panics if `domain_sep.collect().len() == 0` or `> 255`\n    pub fn hash_to_curve<D>(bytes: &[&[u8]], domain_sep: &[&[u8]]) -> EdwardsPoint\n    where\n        D: BlockSizeUser + Default + FixedOutput<OutputSize = U64> + HashMarker,\n        D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    {\n        // For reference see\n        // https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method-2\n\n        let fe = FieldElement::hash_to_field::<D>(bytes, domain_sep);\n        let (M1, is_sq) = crate::montgomery::elligator_encode(&fe);\n\n        // The `to_edwards` conversion we're performing takes as input the sign of the Edwards\n        // `y` coordinate. However, the specification uses `is_sq` to determine the sign of the\n        // Montgomery `v` coordinate. Our approach reconciles this mismatch as follows:\n        //\n        // * We arbitrarily fix the sign of the Edwards `y` coordinate (we choose 0).\n        // * Using the Montgomery `u` coordinate and the Edwards `X` coordinate, we recover `v`.\n        // * We verify that the sign of `v` matches the expected one, i.e., `is_sq == mont_v.is_negative()`.\n        // * If it does not match, we conditionally negate to correct the sign.\n        //\n        // Note: This logic aligns with the RFC draft specification:\n        //     https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method-2\n        // followed by the mapping\n        //     https://www.rfc-editor.org/rfc/rfc9380.html#name-mappings-for-twisted-edward\n        // The only difference is that our `elligator_encode` returns only the Montgomery `u` coordinate,\n        // so we apply this workaround to reconstruct and validate the sign.\n\n        let mut E1_opt = M1\n            .to_edwards(0)\n            .expect(\"Montgomery conversion to Edwards point in Elligator failed\");\n\n        // Now we recover v, to ensure that we got the sign right.\n        let mont_v =\n            &(&ED25519_SQRTAM2 * &FieldElement::from_bytes(&M1.to_bytes())) * &E1_opt.X.invert();\n        E1_opt.X.conditional_negate(is_sq ^ mont_v.is_negative());\n        E1_opt.mul_by_cofactor()\n    }\n\n    /// Return an `EdwardsPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `RngCore`\n    ///\n    /// # Returns\n    ///\n    /// A random `EdwardsPoint`.\n    ///\n    /// # Implementation\n    ///\n    /// Uses rejection sampling, generating a random `CompressedEdwardsY` and then attempting point\n    /// decompression, rejecting invalid points.\n    #[cfg(any(test, feature = \"rand_core\"))]\n    pub fn random<R: RngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.fill_bytes(&mut repr.0);\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break p;\n                }\n            }\n        }\n    }\n}\n\n// ------------------------------------------------------------------------\n// Doubling\n// ------------------------------------------------------------------------\n\nimpl EdwardsPoint {\n    /// Add this point to itself.\n    pub(crate) fn double(&self) -> EdwardsPoint {\n        self.as_projective().double().as_extended()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Addition and Subtraction\n// ------------------------------------------------------------------------\n\nimpl<'a> Add<&'a EdwardsPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }\n}\n\ndefine_add_variants!(\n    LHS = EdwardsPoint,\n    RHS = EdwardsPoint,\n    Output = EdwardsPoint\n);\n\nimpl<'a> AddAssign<&'a EdwardsPoint> for EdwardsPoint {\n    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = EdwardsPoint, RHS = EdwardsPoint);\n\nimpl<'a> Sub<&'a EdwardsPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }\n}\n\ndefine_sub_variants!(\n    LHS = EdwardsPoint,\n    RHS = EdwardsPoint,\n    Output = EdwardsPoint\n);\n\nimpl<'a> SubAssign<&'a EdwardsPoint> for EdwardsPoint {\n    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = EdwardsPoint, RHS = EdwardsPoint);\n\nimpl<T> Sum<T> for EdwardsPoint\nwhere\n    T: Borrow<EdwardsPoint>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }\n}\n\n// ------------------------------------------------------------------------\n// Negation\n// ------------------------------------------------------------------------\n\nimpl Neg for &EdwardsPoint {\n    type Output = EdwardsPoint;\n\n    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }\n}\n\nimpl Neg for EdwardsPoint {\n    type Output = EdwardsPoint;\n\n    fn neg(self) -> EdwardsPoint {\n        -&self\n    }\n}\n\n// ------------------------------------------------------------------------\n// Scalar multiplication\n// ------------------------------------------------------------------------\n\nimpl<'a> MulAssign<&'a Scalar> for EdwardsPoint {\n    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }\n}\n\ndefine_mul_assign_variants!(LHS = EdwardsPoint, RHS = Scalar);\n\ndefine_mul_variants!(LHS = EdwardsPoint, RHS = Scalar, Output = EdwardsPoint);\ndefine_mul_variants!(LHS = Scalar, RHS = EdwardsPoint, Output = EdwardsPoint);\n\nimpl<'a> Mul<&'a Scalar> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, scalar: &'a Scalar) -> EdwardsPoint {\n        crate::backend::variable_base_mul(self, scalar)\n    }\n}\n\nimpl<'a> Mul<&'a EdwardsPoint> for &Scalar {\n    type Output = EdwardsPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, point: &'a EdwardsPoint) -> EdwardsPoint {\n        point * self\n    }\n}\n\nimpl EdwardsPoint {\n    /// Fixed-base scalar multiplication by the Ed25519 base point.\n    ///\n    /// Uses precomputed basepoint tables when the `precomputed-tables` feature\n    /// is enabled, trading off increased code size for ~4x better performance.\n    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::ED25519_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::ED25519_BASEPOINT_TABLE\n        }\n    }\n\n    /// Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }\n\n    /// Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n    /// [`clamp_integer`].\n    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Multiscalar Multiplication impls\n// ------------------------------------------------------------------------\n\n// These use the iterator's size hint and the target settings to\n// forward to a specific backend implementation.\n\n#[cfg(feature = \"alloc\")]\nimpl MultiscalarMul for EdwardsPoint {\n    type Point = EdwardsPoint;\n\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.  When we do\n        // size-dependent algorithm dispatch, use this as the hint.\n        let _size = s_lo;\n\n        crate::backend::straus_multiscalar_mul(scalars, points)\n    }\n}\n\n#[cfg(feature = \"alloc\")]\nimpl VartimeMultiscalarMul for EdwardsPoint {\n    type Point = EdwardsPoint;\n\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.\n        // Use this as the hint to decide which algorithm to use.\n        let size = s_lo;\n\n        if size < 190 {\n            crate::backend::straus_optional_multiscalar_mul(scalars, points)\n        } else {\n            crate::backend::pippenger_optional_multiscalar_mul(scalars, points)\n        }\n    }\n}\n\n/// Precomputation for variable-time multiscalar multiplication with `EdwardsPoint`s.\n// This wraps the inner implementation in a facade type so that we can\n// decouple stability of the inner type from the stability of the\n// outer type.\n#[cfg(feature = \"alloc\")]\npub struct VartimeEdwardsPrecomputation(crate::backend::VartimePrecomputedStraus);\n\n#[cfg(feature = \"alloc\")]\nimpl VartimePrecomputedMultiscalarMul for VartimeEdwardsPrecomputation {\n    type Point = EdwardsPoint;\n\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(static_points))\n    }\n\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }\n\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }\n}\n\nimpl EdwardsPoint {\n    /// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.\n    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &EdwardsPoint,\n        b: &Scalar,\n    ) -> EdwardsPoint {\n        crate::backend::vartime_double_base_mul(a, A, b)\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nmacro_rules! impl_basepoint_table {\n    (Name = $name:ident, LookupTable = $table:ident, Point = $point:ty, Radix = $radix:expr, Additions = $adds:expr) => {\n        /// A precomputed table of multiples of a basepoint, for accelerating\n        /// fixed-base scalar multiplication.  One table, for the Ed25519\n        /// basepoint, is provided in the [`constants`] module.\n        ///\n        /// The basepoint tables are reasonably large, so they should probably be boxed.\n        ///\n        /// The sizes for the tables and the number of additions required for one scalar\n        /// multiplication are as follows:\n        ///\n        /// * [`EdwardsBasepointTableRadix16`]: 30KB, 64A\n        ///   (this is the default size, and is used for\n        ///   [`constants::ED25519_BASEPOINT_TABLE`])\n        /// * [`EdwardsBasepointTableRadix64`]: 120KB, 43A\n        /// * [`EdwardsBasepointTableRadix128`]: 240KB, 37A\n        /// * [`EdwardsBasepointTableRadix256`]: 480KB, 33A\n        ///\n        /// # Why 33 additions for radix-256?\n        ///\n        /// Normally, the radix-256 tables would allow for only 32 additions per scalar\n        /// multiplication.  However, due to the fact that standardised definitions of\n        /// legacy protocols—such as x25519—require allowing unreduced 255-bit scalars\n        /// invariants, when converting such an unreduced scalar's representation to\n        /// radix-\\\\(2^{8}\\\\), we cannot guarantee the carry bit will fit in the last\n        /// coefficient (the coefficients are `i8`s).  When, \\\\(w\\\\), the power-of-2 of\n        /// the radix, is \\\\(w < 8\\\\), we can fold the final carry onto the last\n        /// coefficient, \\\\(d\\\\), because \\\\(d < 2^{w/2}\\\\), so\n        /// $$\n        ///     d + carry \\cdot 2^{w} = d + 1 \\cdot 2^{w} < 2^{w+1} < 2^{8}\n        /// $$\n        /// When \\\\(w = 8\\\\), we can't fit \\\\(carry \\cdot 2^{w}\\\\) into an `i8`, so we\n        /// add the carry bit onto an additional coefficient.\n        #[derive(Clone)]\n        #[repr(transparent)]\n        pub struct $name(pub(crate) [$table<AffineNielsPoint>; 32]);\n\n        impl BasepointTable for $name {\n            type Point = $point;\n\n            /// Create a table of precomputed multiples of `basepoint`.\n            fn create(basepoint: &$point) -> $name {\n                // XXX use init_with\n                let mut table = $name([$table::default(); 32]);\n                let mut P = *basepoint;\n                for i in 0..32 {\n                    // P = (2w)^i * B\n                    table.0[i] = $table::from(&P);\n                    P = P.mul_by_pow_2($radix + $radix);\n                }\n                table\n            }\n\n            /// Get the basepoint for this table as an `EdwardsPoint`.\n            fn basepoint(&self) -> $point {\n                // self.0[0].select(1) = 1*(16^2)^0*B\n                // but as an `AffineNielsPoint`, so add identity to convert to extended.\n                (&<$point>::identity() + &self.0[0].select(1)).as_extended()\n            }\n\n            /// The computation uses Pippeneger's algorithm, as described for the\n            /// specific case of radix-16 on page 13 of the Ed25519 paper.\n            ///\n            /// # Piggenger's Algorithm Generalised\n            ///\n            /// Write the scalar \\\\(a\\\\) in radix-\\\\(w\\\\), where \\\\(w\\\\) is a power of\n            /// 2, with coefficients in \\\\([\\frac{-w}{2},\\frac{w}{2})\\\\), i.e.,\n            /// $$\n            ///     a = a\\_0 + a\\_1 w\\^1 + \\cdots + a\\_{x} w\\^{x},\n            /// $$\n            /// with\n            /// $$\n            /// \\begin{aligned}\n            ///     \\frac{-w}{2} \\leq a_i < \\frac{w}{2}\n            ///     &&\\cdots&&\n            ///     \\frac{-w}{2} \\leq a\\_{x} \\leq \\frac{w}{2}\n            /// \\end{aligned}\n            /// $$\n            /// and the number of additions, \\\\(x\\\\), is given by\n            /// \\\\(x = \\lceil \\frac{256}{w} \\rceil\\\\). Then\n            /// $$\n            ///     a B = a\\_0 B + a\\_1 w\\^1 B + \\cdots + a\\_{x-1} w\\^{x-1} B.\n            /// $$\n            /// Grouping even and odd coefficients gives\n            /// $$\n            /// \\begin{aligned}\n            ///     a B = \\quad a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B    \\\\\\\\\n            ///               + a\\_1 w\\^1 B +& a\\_3 w\\^3 B + \\cdots + a\\_{x-1} w\\^{x-1} B    \\\\\\\\\n            ///         = \\quad(a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B)   \\\\\\\\\n            ///             + w(a\\_1 w\\^0 B +& a\\_3 w\\^2 B + \\cdots + a\\_{x-1} w\\^{x-2} B).  \\\\\\\\\n            /// \\end{aligned}\n            /// $$\n            /// For each \\\\(i = 0 \\ldots 31\\\\), we create a lookup table of\n            /// $$\n            /// [w\\^{2i} B, \\ldots, \\frac{w}{2}\\cdot w\\^{2i} B],\n            /// $$\n            /// and use it to select \\\\( y \\cdot w\\^{2i} \\cdot B \\\\) in constant time.\n            ///\n            /// The radix-\\\\(w\\\\) representation requires that the scalar is bounded\n            /// by \\\\(2\\^{255}\\\\), which is always the case.\n            ///\n            /// The above algorithm is trivially generalised to other powers-of-2 radices.\n            fn mul_base(&self, scalar: &Scalar) -> $point {\n                let a = scalar.as_radix_2w($radix);\n\n                let tables = &self.0;\n                let mut P = <$point>::identity();\n\n                for i in (0..$adds).filter(|x| x % 2 == 1) {\n                    P = (&P + &tables[i / 2].select(a[i])).as_extended();\n                }\n\n                P = P.mul_by_pow_2($radix);\n\n                for i in (0..$adds).filter(|x| x % 2 == 0) {\n                    P = (&P + &tables[i / 2].select(a[i])).as_extended();\n                }\n\n                P\n            }\n        }\n\n        impl<'a, 'b> Mul<&'b Scalar> for &'a $name {\n            type Output = $point;\n\n            /// Construct an `EdwardsPoint` from a `Scalar` \\\\(a\\\\) by\n            /// computing the multiple \\\\(aB\\\\) of this basepoint \\\\(B\\\\).\n            fn mul(self, scalar: &'b Scalar) -> $point {\n                // delegate to a private function so that its documentation appears in internal docs\n                self.mul_base(scalar)\n            }\n        }\n\n        impl<'a, 'b> Mul<&'a $name> for &'b Scalar {\n            type Output = $point;\n\n            /// Construct an `EdwardsPoint` from a `Scalar` \\\\(a\\\\) by\n            /// computing the multiple \\\\(aB\\\\) of this basepoint \\\\(B\\\\).\n            fn mul(self, basepoint_table: &'a $name) -> $point {\n                basepoint_table * self\n            }\n        }\n\n        impl Debug for $name {\n            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(f, \"{:?}([\\n\", stringify!($name))?;\n                for i in 0..32 {\n                    write!(f, \"\\t{:?},\\n\", &self.0[i])?;\n                }\n                write!(f, \"])\")\n            }\n        }\n    };\n} // End macro_rules! impl_basepoint_table\n\n// The number of additions required is ceil(256/w) where w is the radix representation.\ncfg_if! {\n    if #[cfg(feature = \"precomputed-tables\")] {\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTable,\n            LookupTable = LookupTableRadix16,\n            Point = EdwardsPoint,\n            Radix = 4,\n            Additions = 64\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix32,\n            LookupTable = LookupTableRadix32,\n            Point = EdwardsPoint,\n            Radix = 5,\n            Additions = 52\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix64,\n            LookupTable = LookupTableRadix64,\n            Point = EdwardsPoint,\n            Radix = 6,\n            Additions = 43\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix128,\n            LookupTable = LookupTableRadix128,\n            Point = EdwardsPoint,\n            Radix = 7,\n            Additions = 37\n        }\n        impl_basepoint_table! {\n            Name = EdwardsBasepointTableRadix256,\n            LookupTable = LookupTableRadix256,\n            Point = EdwardsPoint,\n            Radix = 8,\n            Additions = 33\n        }\n\n        /// A type-alias for [`EdwardsBasepointTable`] because the latter is\n        /// used as a constructor in the [`constants`] module.\n        //\n        // Same as for `LookupTableRadix16`, we have to define `EdwardsBasepointTable`\n        // first, because it's used as a constructor, and then provide a type alias for\n        // it.\n        pub type EdwardsBasepointTableRadix16 = EdwardsBasepointTable;\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nmacro_rules! impl_basepoint_table_conversions {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl<'a> From<&'a $lhs> for $rhs {\n            fn from(table: &'a $lhs) -> $rhs {\n                <$rhs>::create(&table.basepoint())\n            }\n        }\n\n        impl<'a> From<&'a $rhs> for $lhs {\n            fn from(table: &'a $rhs) -> $lhs {\n                <$lhs>::create(&table.basepoint())\n            }\n        }\n    };\n}\n\ncfg_if! {\n    if #[cfg(feature = \"precomputed-tables\")] {\n        // Conversions from radix 16\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix32\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix64\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix16,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 32\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix64\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix32,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 64\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix64,\n            RHS = EdwardsBasepointTableRadix128\n        }\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix64,\n            RHS = EdwardsBasepointTableRadix256\n        }\n\n        // Conversions from radix 128\n        impl_basepoint_table_conversions! {\n            LHS = EdwardsBasepointTableRadix128,\n            RHS = EdwardsBasepointTableRadix256\n        }\n    }\n}\n\nimpl EdwardsPoint {\n    /// Multiply by the cofactor: return \\\\(\\[8\\]P\\\\).\n    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }\n\n    /// Compute \\\\([2\\^k] P \\\\) by successive doublings. Requires \\\\( k > 0 \\\\).\n    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        for _ in 0..(k - 1) {\n            r = s.double();\n            s = r.as_projective();\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        s.double().as_extended()\n    }\n\n    /// Determine if this point is of small order.\n    ///\n    /// # Return\n    ///\n    /// * `true` if `self` is in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\);\n    /// * `false` if `self` is not in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::constants;\n    ///\n    /// // Generator of the prime-order subgroup\n    /// let P = constants::ED25519_BASEPOINT_POINT;\n    /// // Generator of the torsion subgroup\n    /// let Q = constants::EIGHT_TORSION[1];\n    ///\n    /// // P has large order\n    /// assert_eq!(P.is_small_order(), false);\n    ///\n    /// // Q has small order\n    /// assert_eq!(Q.is_small_order(), true);\n    /// ```\n    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }\n\n    /// Determine if this point is “torsion-free”, i.e., is contained in\n    /// the prime-order subgroup.\n    ///\n    /// # Return\n    ///\n    /// * `true` if `self` has zero torsion component and is in the\n    ///   prime-order subgroup;\n    /// * `false` if `self` has a nonzero torsion component and is not\n    ///   in the prime-order subgroup.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::constants;\n    ///\n    /// // Generator of the prime-order subgroup\n    /// let P = constants::ED25519_BASEPOINT_POINT;\n    /// // Generator of the torsion subgroup\n    /// let Q = constants::EIGHT_TORSION[1];\n    ///\n    /// // P is torsion-free\n    /// assert_eq!(P.is_torsion_free(), true);\n    ///\n    /// // P + Q is not torsion-free\n    /// assert_eq!((P+Q).is_torsion_free(), false);\n    /// ```\n    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER).is_identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Debug traits\n// ------------------------------------------------------------------------\n\nimpl Debug for EdwardsPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }\n}\n\n// ------------------------------------------------------------------------\n// group traits\n// ------------------------------------------------------------------------\n\n// Use the full trait path to avoid Group::identity overlapping Identity::identity in the\n// rest of the module (e.g. tests).\n#[cfg(feature = \"group\")]\nimpl group::Group for EdwardsPoint {\n    type Scalar = Scalar;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.try_fill_bytes(&mut repr.0)?;\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break Ok(p);\n                }\n            }\n        }\n    }\n\n    fn identity() -> Self {\n        Identity::identity()\n    }\n\n    fn generator() -> Self {\n        constants::ED25519_BASEPOINT_POINT\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        self.double()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl GroupEncoding for EdwardsPoint {\n    type Repr = [u8; 32];\n\n    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        let repr = CompressedEdwardsY(*bytes);\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(&repr);\n        CtOption::new(decompress::step_2(&repr, X, Y, Z), is_valid_y_coord)\n    }\n\n    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // Just use the checked API; there are no checks we can skip.\n        Self::from_bytes(bytes)\n    }\n\n    fn to_bytes(&self) -> Self::Repr {\n        self.compress().to_bytes()\n    }\n}\n\n/// A `SubgroupPoint` represents a point on the Edwards form of Curve25519, that is\n/// guaranteed to be in the prime-order subgroup.\n#[cfg(feature = \"group\")]\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct SubgroupPoint(EdwardsPoint);\n\n#[cfg(feature = \"group\")]\nimpl From<SubgroupPoint> for EdwardsPoint {\n    fn from(p: SubgroupPoint) -> Self {\n        p.0\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Neg for SubgroupPoint {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        SubgroupPoint(-self.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Add<&SubgroupPoint> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n    fn add(self, other: &SubgroupPoint) -> SubgroupPoint {\n        SubgroupPoint(self.0 + other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_variants!(\n    LHS = SubgroupPoint,\n    RHS = SubgroupPoint,\n    Output = SubgroupPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl Add<&SubgroupPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn add(self, other: &SubgroupPoint) -> EdwardsPoint {\n        self + other.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_variants!(\n    LHS = EdwardsPoint,\n    RHS = SubgroupPoint,\n    Output = EdwardsPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl AddAssign<&SubgroupPoint> for SubgroupPoint {\n    fn add_assign(&mut self, rhs: &SubgroupPoint) {\n        self.0 += rhs.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_assign_variants!(LHS = SubgroupPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl AddAssign<&SubgroupPoint> for EdwardsPoint {\n    fn add_assign(&mut self, rhs: &SubgroupPoint) {\n        *self += rhs.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_add_assign_variants!(LHS = EdwardsPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl Sub<&SubgroupPoint> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n    fn sub(self, other: &SubgroupPoint) -> SubgroupPoint {\n        SubgroupPoint(self.0 - other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_variants!(\n    LHS = SubgroupPoint,\n    RHS = SubgroupPoint,\n    Output = SubgroupPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl Sub<&SubgroupPoint> for &EdwardsPoint {\n    type Output = EdwardsPoint;\n    fn sub(self, other: &SubgroupPoint) -> EdwardsPoint {\n        self - other.0\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_variants!(\n    LHS = EdwardsPoint,\n    RHS = SubgroupPoint,\n    Output = EdwardsPoint\n);\n\n#[cfg(feature = \"group\")]\nimpl SubAssign<&SubgroupPoint> for SubgroupPoint {\n    fn sub_assign(&mut self, rhs: &SubgroupPoint) {\n        self.0 -= rhs.0;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_assign_variants!(LHS = SubgroupPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl SubAssign<&SubgroupPoint> for EdwardsPoint {\n    fn sub_assign(&mut self, rhs: &SubgroupPoint) {\n        *self -= rhs.0;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_sub_assign_variants!(LHS = EdwardsPoint, RHS = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl<T> Sum<T> for SubgroupPoint\nwhere\n    T: Borrow<SubgroupPoint>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        use group::Group;\n        iter.fold(SubgroupPoint::identity(), |acc, item| acc + item.borrow())\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Mul<&Scalar> for &SubgroupPoint {\n    type Output = SubgroupPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, scalar: &Scalar) -> SubgroupPoint {\n        SubgroupPoint(self.0 * scalar)\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_variants!(LHS = Scalar, RHS = SubgroupPoint, Output = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl Mul<&SubgroupPoint> for &Scalar {\n    type Output = SubgroupPoint;\n\n    /// Scalar multiplication: compute `scalar * self`.\n    ///\n    /// For scalar multiplication of a basepoint,\n    /// `EdwardsBasepointTable` is approximately 4x faster.\n    fn mul(self, point: &SubgroupPoint) -> SubgroupPoint {\n        point * self\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_variants!(LHS = SubgroupPoint, RHS = Scalar, Output = SubgroupPoint);\n\n#[cfg(feature = \"group\")]\nimpl MulAssign<&Scalar> for SubgroupPoint {\n    fn mul_assign(&mut self, scalar: &Scalar) {\n        self.0 *= scalar;\n    }\n}\n\n#[cfg(feature = \"group\")]\ndefine_mul_assign_variants!(LHS = SubgroupPoint, RHS = Scalar);\n\n#[cfg(feature = \"group\")]\nimpl ConstantTimeEq for SubgroupPoint {\n    fn ct_eq(&self, other: &SubgroupPoint) -> Choice {\n        self.0.ct_eq(&other.0)\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl ConditionallySelectable for SubgroupPoint {\n    fn conditional_select(a: &SubgroupPoint, b: &SubgroupPoint, choice: Choice) -> SubgroupPoint {\n        SubgroupPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }\n}\n\n#[cfg(all(feature = \"group\", feature = \"zeroize\"))]\nimpl Zeroize for SubgroupPoint {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl group::Group for SubgroupPoint {\n    type Scalar = Scalar;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        use group::ff::Field;\n\n        // This will almost never loop, but `Group::random` is documented as returning a\n        // non-identity element.\n        let s = loop {\n            let s: Scalar = Field::try_from_rng(rng)?;\n            if !s.is_zero_vartime() {\n                break s;\n            }\n        };\n\n        // This gives an element of the prime-order subgroup.\n        Ok(Self::generator() * s)\n    }\n\n    fn identity() -> Self {\n        SubgroupPoint(Identity::identity())\n    }\n\n    fn generator() -> Self {\n        SubgroupPoint(EdwardsPoint::generator())\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.0.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        SubgroupPoint(self.0.double())\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl GroupEncoding for SubgroupPoint {\n    type Repr = <EdwardsPoint as GroupEncoding>::Repr;\n\n    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        EdwardsPoint::from_bytes(bytes).and_then(|p| p.into_subgroup())\n    }\n\n    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        EdwardsPoint::from_bytes_unchecked(bytes).and_then(|p| p.into_subgroup())\n    }\n\n    fn to_bytes(&self) -> Self::Repr {\n        self.0.compress().to_bytes()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl PrimeGroup for SubgroupPoint {}\n\n#[cfg(feature = \"group\")]\nimpl CofactorGroup for EdwardsPoint {\n    type Subgroup = SubgroupPoint;\n\n    fn clear_cofactor(&self) -> Self::Subgroup {\n        SubgroupPoint(self.mul_by_cofactor())\n    }\n\n    fn into_subgroup(self) -> CtOption<Self::Subgroup> {\n        CtOption::new(SubgroupPoint(self), CofactorGroup::is_torsion_free(&self))\n    }\n\n    fn is_torsion_free(&self) -> Choice {\n        (self * constants::BASEPOINT_ORDER).ct_eq(&Self::identity())\n    }\n}\n\n// ------------------------------------------------------------------------\n// Tests\n// ------------------------------------------------------------------------\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    use rand_core::TryRngCore;\n\n    #[cfg(feature = \"alloc\")]\n    use alloc::vec::Vec;\n\n    #[cfg(feature = \"precomputed-tables\")]\n    use crate::constants::ED25519_BASEPOINT_TABLE;\n\n    /// X coordinate of the basepoint.\n    /// = 15112221349535400772501151409588531511454012693041857206046113283949847762202\n    static BASE_X_COORD_BYTES: [u8; 32] = [\n        0x1a, 0xd5, 0x25, 0x8f, 0x60, 0x2d, 0x56, 0xc9, 0xb2, 0xa7, 0x25, 0x95, 0x60, 0xc7, 0x2c,\n        0x69, 0x5c, 0xdc, 0xd6, 0xfd, 0x31, 0xe2, 0xa4, 0xc0, 0xfe, 0x53, 0x6e, 0xcd, 0xd3, 0x36,\n        0x69, 0x21,\n    ];\n\n    /// Compressed Edwards Y form of 2*basepoint.\n    static BASE2_CMPRSSD: CompressedEdwardsY = CompressedEdwardsY([\n        0xc9, 0xa3, 0xf8, 0x6a, 0xae, 0x46, 0x5f, 0xe, 0x56, 0x51, 0x38, 0x64, 0x51, 0x0f, 0x39,\n        0x97, 0x56, 0x1f, 0xa2, 0xc9, 0xe8, 0x5e, 0xa2, 0x1d, 0xc2, 0x29, 0x23, 0x09, 0xf3, 0xcd,\n        0x60, 0x22,\n    ]);\n\n    /// Compressed Edwards Y form of 16*basepoint.\n    static BASE16_CMPRSSD: CompressedEdwardsY = CompressedEdwardsY([\n        0xeb, 0x27, 0x67, 0xc1, 0x37, 0xab, 0x7a, 0xd8, 0x27, 0x9c, 0x07, 0x8e, 0xff, 0x11, 0x6a,\n        0xb0, 0x78, 0x6e, 0xad, 0x3a, 0x2e, 0x0f, 0x98, 0x9f, 0x72, 0xc3, 0x7f, 0x82, 0xf2, 0x96,\n        0x96, 0x70,\n    ]);\n\n    /// 4493907448824000747700850167940867464579944529806937181821189941592931634714\n    pub static A_SCALAR: Scalar = Scalar {\n        bytes: [\n            0x1a, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n            0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n            0x23, 0x76, 0xef, 0x09,\n        ],\n    };\n\n    /// 2506056684125797857694181776241676200180934651973138769173342316833279714961\n    pub static B_SCALAR: Scalar = Scalar {\n        bytes: [\n            0x91, 0x26, 0x7a, 0xcf, 0x25, 0xc2, 0x09, 0x1b, 0xa2, 0x17, 0x74, 0x7b, 0x66, 0xf0,\n            0xb3, 0x2e, 0x9d, 0xf2, 0xa5, 0x67, 0x41, 0xcf, 0xda, 0xc4, 0x56, 0xa7, 0xd4, 0xaa,\n            0xb8, 0x60, 0x8a, 0x05,\n        ],\n    };\n\n    /// A_SCALAR * basepoint, computed with ed25519.py\n    pub static A_TIMES_BASEPOINT: CompressedEdwardsY = CompressedEdwardsY([\n        0xea, 0x27, 0xe2, 0x60, 0x53, 0xdf, 0x1b, 0x59, 0x56, 0xf1, 0x4d, 0x5d, 0xec, 0x3c, 0x34,\n        0xc3, 0x84, 0xa2, 0x69, 0xb7, 0x4c, 0xc3, 0x80, 0x3e, 0xa8, 0xe2, 0xe7, 0xc9, 0x42, 0x5e,\n        0x40, 0xa5,\n    ]);\n\n    /// A_SCALAR * (A_TIMES_BASEPOINT) + B_SCALAR * BASEPOINT\n    /// computed with ed25519.py\n    static DOUBLE_SCALAR_MULT_RESULT: CompressedEdwardsY = CompressedEdwardsY([\n        0x7d, 0xfd, 0x6c, 0x45, 0xaf, 0x6d, 0x6e, 0x0e, 0xba, 0x20, 0x37, 0x1a, 0x23, 0x64, 0x59,\n        0xc4, 0xc0, 0x46, 0x83, 0x43, 0xde, 0x70, 0x4b, 0x85, 0x09, 0x6f, 0xfe, 0x35, 0x4f, 0x13,\n        0x2b, 0x42,\n    ]);\n\n    /// Test round-trip decompression for the basepoint.\n    #[test]\n    fn basepoint_decompression_compression() {\n        let base_X = FieldElement::from_bytes(&BASE_X_COORD_BYTES);\n        let bp = constants::ED25519_BASEPOINT_COMPRESSED\n            .decompress()\n            .unwrap();\n        assert!(bp.is_valid());\n        // Check that decompression actually gives the correct X coordinate\n        assert_eq!(base_X, bp.X);\n        assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n    }\n\n    /// Test sign handling in decompression\n    #[test]\n    fn decompression_sign_handling() {\n        // Manually set the high bit of the last byte to flip the sign\n        let mut minus_basepoint_bytes = *constants::ED25519_BASEPOINT_COMPRESSED.as_bytes();\n        minus_basepoint_bytes[31] |= 1 << 7;\n        let minus_basepoint = CompressedEdwardsY(minus_basepoint_bytes)\n            .decompress()\n            .unwrap();\n        // Test projective coordinates exactly since we know they should\n        // only differ by a flipped sign.\n        assert_eq!(minus_basepoint.X, -(&constants::ED25519_BASEPOINT_POINT.X));\n        assert_eq!(minus_basepoint.Y, constants::ED25519_BASEPOINT_POINT.Y);\n        assert_eq!(minus_basepoint.Z, constants::ED25519_BASEPOINT_POINT.Z);\n        assert_eq!(minus_basepoint.T, -(&constants::ED25519_BASEPOINT_POINT.T));\n    }\n\n    /// Test that computing 1*basepoint gives the correct basepoint.\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn basepoint_mult_one_vs_basepoint() {\n        let bp = ED25519_BASEPOINT_TABLE * &Scalar::ONE;\n        let compressed = bp.compress();\n        assert_eq!(compressed, constants::ED25519_BASEPOINT_COMPRESSED);\n    }\n\n    /// Test that `EdwardsBasepointTable::basepoint()` gives the correct basepoint.\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn basepoint_table_basepoint_function_correct() {\n        let bp = ED25519_BASEPOINT_TABLE.basepoint();\n        assert_eq!(bp.compress(), constants::ED25519_BASEPOINT_COMPRESSED);\n    }\n\n    /// Test `impl Add<EdwardsPoint> for EdwardsPoint`\n    /// using basepoint + basepoint versus the 2*basepoint constant.\n    #[test]\n    fn basepoint_plus_basepoint_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_added = bp + bp;\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }\n\n    /// Test `impl Add<ProjectiveNielsPoint> for EdwardsPoint`\n    /// using the basepoint, basepoint2 constants\n    #[test]\n    fn basepoint_plus_basepoint_projective_niels_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_added = (&bp + &bp.as_projective_niels()).as_extended();\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }\n\n    /// Test `impl Add<AffineNielsPoint> for EdwardsPoint`\n    /// using the basepoint, basepoint2 constants\n    #[test]\n    fn basepoint_plus_basepoint_affine_niels_vs_basepoint2() {\n        let bp = constants::ED25519_BASEPOINT_POINT;\n        let bp_affine_niels = bp.as_affine_niels();\n        let bp_added = (&bp + &bp_affine_niels).as_extended();\n        assert_eq!(bp_added.compress(), BASE2_CMPRSSD);\n    }\n\n    /// Check that equality of `EdwardsPoints` handles projective\n    /// coordinates correctly.\n    #[test]\n    fn extended_point_equality_handles_scaling() {\n        let mut two_bytes = [0u8; 32];\n        two_bytes[0] = 2;\n        let id1 = EdwardsPoint::identity();\n        let id2 = EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::from_bytes(&two_bytes),\n            Z: FieldElement::from_bytes(&two_bytes),\n            T: FieldElement::ZERO,\n        };\n        assert!(bool::from(id1.ct_eq(&id2)));\n    }\n\n    /// Sanity check for conversion to precomputed points\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn to_affine_niels_clears_denominators() {\n        // construct a point as aB so it has denominators (ie. Z != 1)\n        let aB = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n        let aB_affine_niels = aB.as_affine_niels();\n        let also_aB = (&EdwardsPoint::identity() + &aB_affine_niels).as_extended();\n        assert_eq!(aB.compress(), also_aB.compress());\n    }\n\n    /// Test mul_base versus a known scalar multiple from ed25519.py\n    #[test]\n    fn basepoint_mult_vs_ed25519py() {\n        let aB = EdwardsPoint::mul_base(&A_SCALAR);\n        assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n    }\n\n    /// Test that multiplication by the basepoint order kills the basepoint\n    #[test]\n    fn basepoint_mult_by_basepoint_order() {\n        let should_be_id = EdwardsPoint::mul_base(&constants::BASEPOINT_ORDER);\n        assert!(should_be_id.is_identity());\n    }\n\n    /// Test precomputed basepoint mult\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn test_precomputed_basepoint_mult() {\n        let aB_1 = ED25519_BASEPOINT_TABLE * &A_SCALAR;\n        let aB_2 = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n        assert_eq!(aB_1.compress(), aB_2.compress());\n    }\n\n    /// Test scalar_mul versus a known scalar multiple from ed25519.py\n    #[test]\n    fn scalar_mul_vs_ed25519py() {\n        let aB = constants::ED25519_BASEPOINT_POINT * A_SCALAR;\n        assert_eq!(aB.compress(), A_TIMES_BASEPOINT);\n    }\n\n    /// Test basepoint.double() versus the 2*basepoint constant.\n    #[test]\n    fn basepoint_double_vs_basepoint2() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT.double().compress(),\n            BASE2_CMPRSSD\n        );\n    }\n\n    /// Test that computing 2*basepoint is the same as basepoint.double()\n    #[test]\n    fn basepoint_mult_two_vs_basepoint2() {\n        let two = Scalar::from(2u64);\n        let bp2 = EdwardsPoint::mul_base(&two);\n        assert_eq!(bp2.compress(), BASE2_CMPRSSD);\n    }\n\n    /// Test that all the basepoint table types compute the same results.\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn basepoint_tables() {\n        let P = &constants::ED25519_BASEPOINT_POINT;\n        let a = A_SCALAR;\n\n        let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n        let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n        let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n        let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n        let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n        let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n        let aP16 = (&table_radix16 * &a).compress();\n        let aP32 = (&table_radix32 * &a).compress();\n        let aP64 = (&table_radix64 * &a).compress();\n        let aP128 = (&table_radix128 * &a).compress();\n        let aP256 = (&table_radix256 * &a).compress();\n\n        assert_eq!(aP, aP16);\n        assert_eq!(aP16, aP32);\n        assert_eq!(aP32, aP64);\n        assert_eq!(aP64, aP128);\n        assert_eq!(aP128, aP256);\n    }\n\n    /// Check unreduced scalar multiplication by the basepoint tables is the same no matter what\n    /// radix the table is.\n    #[cfg(feature = \"precomputed-tables\")]\n    #[test]\n    fn basepoint_tables_unreduced_scalar() {\n        let P = &constants::ED25519_BASEPOINT_POINT;\n        let a = crate::scalar::test::LARGEST_UNREDUCED_SCALAR;\n\n        let table_radix16 = EdwardsBasepointTableRadix16::create(P);\n        let table_radix32 = EdwardsBasepointTableRadix32::create(P);\n        let table_radix64 = EdwardsBasepointTableRadix64::create(P);\n        let table_radix128 = EdwardsBasepointTableRadix128::create(P);\n        let table_radix256 = EdwardsBasepointTableRadix256::create(P);\n\n        let aP = (ED25519_BASEPOINT_TABLE * &a).compress();\n        let aP16 = (&table_radix16 * &a).compress();\n        let aP32 = (&table_radix32 * &a).compress();\n        let aP64 = (&table_radix64 * &a).compress();\n        let aP128 = (&table_radix128 * &a).compress();\n        let aP256 = (&table_radix256 * &a).compress();\n\n        assert_eq!(aP, aP16);\n        assert_eq!(aP16, aP32);\n        assert_eq!(aP32, aP64);\n        assert_eq!(aP64, aP128);\n        assert_eq!(aP128, aP256);\n    }\n\n    /// Check that converting to projective and then back to extended round-trips.\n    #[test]\n    fn basepoint_projective_extended_round_trip() {\n        assert_eq!(\n            constants::ED25519_BASEPOINT_POINT\n                .as_projective()\n                .as_extended()\n                .compress(),\n            constants::ED25519_BASEPOINT_COMPRESSED\n        );\n    }\n\n    /// Test computing 16*basepoint vs mul_by_pow_2(4)\n    #[test]\n    fn basepoint16_vs_mul_by_pow_2_4() {\n        let bp16 = constants::ED25519_BASEPOINT_POINT.mul_by_pow_2(4);\n        assert_eq!(bp16.compress(), BASE16_CMPRSSD);\n    }\n\n    /// Check that mul_base_clamped and mul_clamped agree\n    #[test]\n    fn mul_base_clamped() {\n        let mut csprng = rand_core::OsRng;\n\n        // Make a random curve point in the curve. Give it torsion to make things interesting.\n        #[cfg(feature = \"precomputed-tables\")]\n        let random_point = {\n            let mut b = [0u8; 32];\n            csprng.try_fill_bytes(&mut b).unwrap();\n            EdwardsPoint::mul_base_clamped(b) + constants::EIGHT_TORSION[1]\n        };\n        // Make a basepoint table from the random point. We'll use this with mul_base_clamped\n        #[cfg(feature = \"precomputed-tables\")]\n        let random_table = EdwardsBasepointTableRadix256::create(&random_point);\n\n        // Now test scalar mult. agreement on the default basepoint as well as random_point\n\n        // Test that mul_base_clamped and mul_clamped agree on a large integer. Even after\n        // clamping, this integer is not reduced mod l.\n        let a_bytes = [0xff; 32];\n        assert_eq!(\n            EdwardsPoint::mul_base_clamped(a_bytes),\n            constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n        );\n        #[cfg(feature = \"precomputed-tables\")]\n        assert_eq!(\n            random_table.mul_base_clamped(a_bytes),\n            random_point.mul_clamped(a_bytes)\n        );\n\n        // Test agreement on random integers\n        for _ in 0..100 {\n            // This will be reduced mod l with probability l / 2^256 ≈ 6.25%\n            let mut a_bytes = [0u8; 32];\n            csprng.try_fill_bytes(&mut a_bytes).unwrap();\n\n            assert_eq!(\n                EdwardsPoint::mul_base_clamped(a_bytes),\n                constants::ED25519_BASEPOINT_POINT.mul_clamped(a_bytes)\n            );\n            #[cfg(feature = \"precomputed-tables\")]\n            assert_eq!(\n                random_table.mul_base_clamped(a_bytes),\n                random_point.mul_clamped(a_bytes)\n            );\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let BASE = constants::ED25519_BASEPOINT_POINT;\n\n        let s1 = Scalar::from(999u64);\n        let P1 = BASE * s1;\n\n        let s2 = Scalar::from(333u64);\n        let P2 = BASE * s2;\n\n        let vec = vec![P1, P2];\n        let sum: EdwardsPoint = vec.iter().sum();\n\n        assert_eq!(sum, P1 + P2);\n\n        // Test that sum works for the empty iterator\n        let empty_vector: Vec<EdwardsPoint> = vec![];\n        let sum: EdwardsPoint = empty_vector.iter().sum();\n\n        assert_eq!(sum, EdwardsPoint::identity());\n\n        // Test that sum works on owning iterators\n        let s = Scalar::from(2u64);\n        let mapped = vec.iter().map(|x| x * s);\n        let sum: EdwardsPoint = mapped.sum();\n\n        assert_eq!(sum, P1 * s + P2 * s);\n    }\n\n    /// Test that the conditional assignment trait works for AffineNielsPoints.\n    #[test]\n    fn conditional_assign_for_affine_niels_point() {\n        let id = AffineNielsPoint::identity();\n        let mut p1 = AffineNielsPoint::identity();\n        let bp = constants::ED25519_BASEPOINT_POINT.as_affine_niels();\n\n        p1.conditional_assign(&bp, Choice::from(0));\n        assert_eq!(p1, id);\n        p1.conditional_assign(&bp, Choice::from(1));\n        assert_eq!(p1, bp);\n    }\n\n    #[test]\n    fn is_small_order() {\n        // The basepoint has large prime order\n        assert!(!constants::ED25519_BASEPOINT_POINT.is_small_order());\n        // constants::EIGHT_TORSION has all points of small order.\n        for torsion_point in &constants::EIGHT_TORSION {\n            assert!(torsion_point.is_small_order());\n        }\n    }\n\n    #[test]\n    fn compressed_identity() {\n        assert_eq!(\n            EdwardsPoint::identity().compress(),\n            CompressedEdwardsY::identity()\n        );\n\n        #[cfg(feature = \"alloc\")]\n        {\n            let compressed = EdwardsPoint::compress_batch(&[EdwardsPoint::identity()]);\n            assert_eq!(&compressed, &[CompressedEdwardsY::identity()]);\n        }\n    }\n\n    #[cfg(feature = \"alloc\")]\n    #[test]\n    fn compress_batch() {\n        let mut rng = rand::rng();\n\n        // TODO(tarcieri): proptests?\n        // Make some points deterministically then randomly\n        let mut points = (1u64..16)\n            .map(|n| constants::ED25519_BASEPOINT_POINT * Scalar::from(n))\n            .collect::<Vec<_>>();\n        points.extend(core::iter::repeat_with(|| EdwardsPoint::random(&mut rng)).take(100));\n        let compressed = EdwardsPoint::compress_batch(&points);\n\n        // Check that the batch-compressed points match the individually compressed ones\n        for (point, compressed) in points.iter().zip(&compressed) {\n            assert_eq!(&point.compress(), compressed);\n        }\n    }\n\n    #[test]\n    fn is_identity() {\n        assert!(EdwardsPoint::identity().is_identity());\n        assert!(!constants::ED25519_BASEPOINT_POINT.is_identity());\n    }\n\n    /// Rust's debug builds have overflow and underflow trapping,\n    /// and enable `debug_assert!()`.  This performs many scalar\n    /// multiplications to attempt to trigger possible overflows etc.\n    ///\n    /// For instance, the `u64` `Mul` implementation for\n    /// `FieldElements` requires the input `Limb`s to be bounded by\n    /// 2^54, but we cannot enforce this dynamically at runtime, or\n    /// statically at compile time (until Rust gets type-level\n    /// integers, at which point we can encode \"bits of headroom\" into\n    /// the type system and prove correctness).\n    #[test]\n    fn monte_carlo_overflow_underflow_debug_assert_test() {\n        let mut P = constants::ED25519_BASEPOINT_POINT;\n        // N.B. each scalar_mul does 1407 field mults, 1024 field squarings,\n        // so this does ~ 1M of each operation.\n        for _ in 0..1_000 {\n            P *= &A_SCALAR;\n        }\n    }\n\n    #[test]\n    fn scalarmult_extended_point_works_both_ways() {\n        let G: EdwardsPoint = constants::ED25519_BASEPOINT_POINT;\n        let s: Scalar = A_SCALAR;\n\n        let P1 = G * s;\n        let P2 = s * G;\n\n        assert!(P1.compress().to_bytes() == P2.compress().to_bytes());\n    }\n\n    // A single iteration of a consistency check for MSM.\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_iter(n: usize) {\n        let mut rng = rand::rng();\n\n        // Construct random coefficients x0, ..., x_{n-1},\n        // followed by some extra hardcoded ones.\n        let xs = (0..n).map(|_| Scalar::random(&mut rng)).collect::<Vec<_>>();\n        let check = xs.iter().map(|xi| xi * xi).sum::<Scalar>();\n\n        // Construct points G_i = x_i * B\n        let Gs = xs.iter().map(EdwardsPoint::mul_base).collect::<Vec<_>>();\n\n        // Compute H1 = <xs, Gs> (consttime)\n        let H1 = EdwardsPoint::multiscalar_mul(&xs, &Gs);\n        // Compute H2 = <xs, Gs> (vartime)\n        let H2 = EdwardsPoint::vartime_multiscalar_mul(&xs, &Gs);\n        // Compute H3 = <xs, Gs> = sum(xi^2) * B\n        let H3 = EdwardsPoint::mul_base(&check);\n\n        assert_eq!(H1, H3);\n        assert_eq!(H2, H3);\n    }\n\n    // Use different multiscalar sizes to hit different internal\n    // parameters.\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_n_100() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(100);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_n_250() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(250);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_n_500() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(500);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn multiscalar_consistency_n_1000() {\n        let iters = 50;\n        for _ in 0..iters {\n            multiscalar_consistency_iter(1000);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn batch_to_montgomery() {\n        let mut rng = rand::rng();\n\n        let scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let points = scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let single_monts = points\n            .iter()\n            .map(EdwardsPoint::to_montgomery)\n            .collect::<Vec<_>>();\n\n        for i in [0, 1, 2, 3, 10, 50, 128] {\n            let invs = EdwardsPoint::to_montgomery_batch(&points[..i]);\n            assert_eq!(&invs, &single_monts[..i]);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let static_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let check_scalar: Scalar = static_scalars\n            .iter()\n            .chain(dynamic_scalars.iter())\n            .map(|s| s * s)\n            .sum();\n\n        let static_points = static_scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n        let dynamic_points = dynamic_scalars\n            .iter()\n            .map(EdwardsPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let precomputation = VartimeEdwardsPrecomputation::new(static_points.iter());\n\n        assert_eq!(precomputation.len(), 128);\n        assert!(!precomputation.is_empty());\n\n        let P = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        use crate::traits::VartimeMultiscalarMul;\n        let Q = EdwardsPoint::vartime_multiscalar_mul(\n            static_scalars.iter().chain(dynamic_scalars.iter()),\n            static_points.iter().chain(dynamic_points.iter()),\n        );\n\n        let R = EdwardsPoint::mul_base(&check_scalar);\n\n        assert_eq!(P.compress(), R.compress());\n        assert_eq!(Q.compress(), R.compress());\n    }\n\n    mod vartime {\n        use super::super::*;\n        use super::{A_SCALAR, A_TIMES_BASEPOINT, B_SCALAR, DOUBLE_SCALAR_MULT_RESULT};\n\n        /// Test double_scalar_mul_vartime vs ed25519.py\n        #[test]\n        fn double_scalar_mul_basepoint_vs_ed25519py() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result =\n                EdwardsPoint::vartime_double_scalar_mul_basepoint(&A_SCALAR, &A, &B_SCALAR);\n            assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n        }\n\n        #[test]\n        #[cfg(feature = \"alloc\")]\n        fn multiscalar_mul_vs_ed25519py() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result = EdwardsPoint::vartime_multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n            assert_eq!(result.compress(), DOUBLE_SCALAR_MULT_RESULT);\n        }\n\n        #[test]\n        #[cfg(feature = \"alloc\")]\n        fn multiscalar_mul_vartime_vs_consttime() {\n            let A = A_TIMES_BASEPOINT.decompress().unwrap();\n            let result_vartime = EdwardsPoint::vartime_multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n            let result_consttime = EdwardsPoint::multiscalar_mul(\n                &[A_SCALAR, B_SCALAR],\n                &[A, constants::ED25519_BASEPOINT_POINT],\n            );\n\n            assert_eq!(result_vartime.compress(), result_consttime.compress());\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"serde\")]\n    fn serde_bincode_basepoint_roundtrip() {\n        use bincode;\n\n        let encoded = bincode::serialize(&constants::ED25519_BASEPOINT_POINT).unwrap();\n        let enc_compressed = bincode::serialize(&constants::ED25519_BASEPOINT_COMPRESSED).unwrap();\n        assert_eq!(encoded, enc_compressed);\n\n        // Check that the encoding is 32 bytes exactly\n        assert_eq!(encoded.len(), 32);\n\n        let dec_uncompressed: EdwardsPoint = bincode::deserialize(&encoded).unwrap();\n        let dec_compressed: CompressedEdwardsY = bincode::deserialize(&encoded).unwrap();\n\n        assert_eq!(dec_uncompressed, constants::ED25519_BASEPOINT_POINT);\n        assert_eq!(dec_compressed, constants::ED25519_BASEPOINT_COMPRESSED);\n\n        // Check that the encoding itself matches the usual one\n        let raw_bytes = constants::ED25519_BASEPOINT_COMPRESSED.as_bytes();\n        let bp: EdwardsPoint = bincode::deserialize(raw_bytes).unwrap();\n        assert_eq!(bp, constants::ED25519_BASEPOINT_POINT);\n    }\n\n    // Hash-to-curve test vectors from\n    // https://www.rfc-editor.org/rfc/rfc9380.html#name-edwards25519_xmdsha-512_ell2\n    // These are of the form (input_msg, output_x, output_y)\n    #[cfg(all(feature = \"alloc\", feature = \"digest\"))]\n    const RFC_HASH_TO_CURVE_KAT: &[(&[u8], &str, &str)] = &[\n        (\n            b\"\",\n            \"1ff2b70ecf862799e11b7ae744e3489aa058ce805dd323a936375a84695e76da\",\n            \"222e314d04a4d5725e9f2aff9fb2a6b69ef375a1214eb19021ceab2d687f0f9b\",\n        ),\n        (\n            b\"abc\",\n            \"5f13cc69c891d86927eb37bd4afc6672360007c63f68a33ab423a3aa040fd2a8\",\n            \"67732d50f9a26f73111dd1ed5dba225614e538599db58ba30aaea1f5c827fa42\",\n        ),\n        (\n            b\"abcdef0123456789\",\n            \"1dd2fefce934ecfd7aae6ec998de088d7dd03316aa1847198aecf699ba6613f1\",\n            \"2f8a6c24dd1adde73909cada6a4a137577b0f179d336685c4a955a0a8e1a86fb\",\n        ),\n        (\n            b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\\\n            qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\",\n            \"35fbdc5143e8a97afd3096f2b843e07df72e15bfca2eaf6879bf97c5d3362f73\",\n            \"2af6ff6ef5ebba128b0774f4296cb4c2279a074658b083b8dcca91f57a603450\",\n        ),\n        (\n            b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"6e5e1f37e99345887fc12111575fc1c3e36df4b289b8759d23af14d774b66bff\",\n            \"2c90c3d39eb18ff291d33441b35f3262cdd307162cc97c31bfcc7a4245891a37\"\n        )\n    ];\n\n    #[test]\n    #[cfg(all(feature = \"alloc\", feature = \"digest\"))]\n    fn elligator_hash_to_curve_test_vectors() {\n        let dst = b\"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n        for (index, vector) in RFC_HASH_TO_CURVE_KAT.iter().enumerate() {\n            let input = vector.0;\n\n            let expected_output = {\n                let mut x_bytes = hex::decode(vector.1).unwrap();\n                x_bytes.reverse();\n                let x = FieldElement::from_bytes(&x_bytes.try_into().unwrap());\n\n                let mut y_bytes = hex::decode(vector.2).unwrap();\n                y_bytes.reverse();\n                let y = FieldElement::from_bytes(&y_bytes.try_into().unwrap());\n\n                EdwardsPoint {\n                    X: x,\n                    Y: y,\n                    Z: FieldElement::ONE,\n                    T: &x * &y,\n                }\n            };\n\n            let computed = EdwardsPoint::hash_to_curve::<sha2::Sha512>(&[&input], &[dst]);\n            assert_eq!(computed, expected_output, \"Failed in test {}\", index);\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/edwards.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63643": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// Portions Copyright 2017 Brian Smith\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Isis Agora Lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n// - Brian Smith <brian@briansmith.org>\n\n//! Arithmetic on scalars (integers mod the group order).\n//!\n//! Both the Ristretto group and the Ed25519 basepoint have prime order\n//! \\\\( \\ell = 2\\^{252} + 27742317777372353535851937790883648493 \\\\).\n//!\n//! This code is intended to be useful with both the Ristretto group\n//! (where everything is done modulo \\\\( \\ell \\\\)), and the X/Ed25519\n//! setting, which mandates specific bit-twiddles that are not\n//! well-defined modulo \\\\( \\ell \\\\).\n//!\n//! All arithmetic on `Scalars` is done modulo \\\\( \\ell \\\\).\n//!\n//! # Constructing a scalar\n//!\n//! To create a [`Scalar`](struct.Scalar.html) from a supposedly canonical encoding, use\n//! [`Scalar::from_canonical_bytes`](struct.Scalar.html#method.from_canonical_bytes).\n//!\n//! This function does input validation, ensuring that the input bytes\n//! are the canonical encoding of a `Scalar`.\n//! If they are, we'll get\n//! `Some(Scalar)` in return:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let one_as_bytes: [u8; 32] = Scalar::ONE.to_bytes();\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(one_as_bytes).into();\n//!\n//! assert!(a.is_some());\n//! ```\n//!\n//! However, if we give it bytes representing a scalar larger than \\\\( \\ell \\\\)\n//! (in this case, \\\\( \\ell + 2 \\\\)), we'll get `None` back:\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Option<Scalar> = Scalar::from_canonical_bytes(l_plus_two_bytes).into();\n//!\n//! assert!(a.is_none());\n//! ```\n//!\n//! Another way to create a `Scalar` is by reducing a \\\\(256\\\\)-bit integer mod\n//! \\\\( \\ell \\\\), for which one may use the\n//! [`Scalar::from_bytes_mod_order`](struct.Scalar.html#method.from_bytes_mod_order)\n//! method.  In the case of the second example above, this would reduce the\n//! resultant scalar \\\\( \\mod \\ell \\\\), producing \\\\( 2 \\\\):\n//!\n//! ```\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! let l_plus_two_bytes: [u8; 32] = [\n//!    0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,\n//!    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n//!    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n//! ];\n//! let a: Scalar = Scalar::from_bytes_mod_order(l_plus_two_bytes);\n//!\n//! let two: Scalar = Scalar::ONE + Scalar::ONE;\n//!\n//! assert!(a == two);\n//! ```\n//!\n//! There is also a constructor that reduces a \\\\(512\\\\)-bit integer,\n//! [`Scalar::from_bytes_mod_order_wide`].\n//!\n//! To construct a `Scalar` as the hash of some input data, use\n//! [`Scalar::hash_from_bytes`], which takes a buffer, or\n//! [`Scalar::from_hash`], which allows an IUF API.\n//!\n#![cfg_attr(feature = \"digest\", doc = \"```\")]\n#![cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n//! # fn main() {\n//! use sha2::{Digest, Sha512};\n//! use curve25519_dalek::scalar::Scalar;\n//!\n//! // Hashing a single byte slice\n//! let a = Scalar::hash_from_bytes::<Sha512>(b\"Abolish ICE\");\n//!\n//! // Streaming data into a hash object\n//! let mut hasher = Sha512::default();\n//! hasher.update(b\"Abolish \");\n//! hasher.update(b\"ICE\");\n//! let a2 = Scalar::from_hash(hasher);\n//!\n//! assert_eq!(a, a2);\n//! # }\n//! ```\n//!\n//! See also `Scalar::hash_from_bytes` and `Scalar::from_hash` that\n//! reduces a \\\\(512\\\\)-bit integer, if the optional `digest` feature\n//! has been enabled.\n\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::{Product, Sum};\nuse core::ops::Index;\nuse core::ops::Neg;\nuse core::ops::{Add, AddAssign};\nuse core::ops::{Mul, MulAssign};\nuse core::ops::{Sub, SubAssign};\n\nuse cfg_if::cfg_if;\n\n#[cfg(feature = \"group\")]\nuse group::ff::{Field, FromUniformBytes, PrimeField};\n#[cfg(feature = \"group-bits\")]\nuse group::ff::{FieldBits, PrimeFieldBits};\n\n#[cfg(feature = \"group\")]\nuse rand_core::TryRngCore;\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::CryptoRng;\n\n#[cfg(feature = \"digest\")]\nuse digest::Digest;\n#[cfg(feature = \"digest\")]\nuse digest::array::typenum::U64;\n\nuse subtle::Choice;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\nuse subtle::CtOption;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nuse crate::backend;\nuse crate::constants;\n\ncfg_if! {\n    if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        #[cfg_attr(\n            docsrs,\n            doc(cfg(all(feature = \"fiat_backend\", curve25519_dalek_bits = \"32\")))\n        )]\n        type UnpackedScalar = backend::serial::fiat_u32::scalar::Scalar29;\n\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        #[cfg_attr(\n            docsrs,\n            doc(cfg(all(feature = \"fiat_backend\", curve25519_dalek_bits = \"64\")))\n        )]\n        type UnpackedScalar = backend::serial::fiat_u64::scalar::Scalar52;\n    } else if #[cfg(curve25519_dalek_bits = \"64\")] {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg_attr(docsrs, doc(cfg(curve25519_dalek_bits = \"64\")))]\n        type UnpackedScalar = backend::serial::u64::scalar::Scalar52;\n    } else {\n        /// An `UnpackedScalar` represents an element of the field GF(l), optimized for speed.\n        ///\n        /// This is a type alias for one of the scalar types in the `backend`\n        /// module.\n        #[cfg_attr(docsrs, doc(cfg(curve25519_dalek_bits = \"64\")))]\n        type UnpackedScalar = backend::serial::u32::scalar::Scalar29;\n    }\n}\n\n/// The `Scalar` struct holds an element of \\\\(\\mathbb Z / \\ell\\mathbb Z \\\\).\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct Scalar {\n    /// `bytes` is a little-endian byte encoding of an integer representing a scalar modulo the\n    /// group order.\n    ///\n    /// # Invariant #1\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255}\\\\). That is, the most\n    /// significant bit of `bytes[31]` is 0.\n    ///\n    /// This is required for `EdwardsPoint` variable- and fixed-base multiplication, because most\n    /// integers above 2^255 are unrepresentable in our radix-16 NAF (see [`Self::as_radix_16`]).\n    /// The invariant is also required because our `MontgomeryPoint` multiplication assumes the MSB\n    /// is 0 (see `MontgomeryPoint::mul`).\n    ///\n    /// # Invariant #2 (weak)\n    ///\n    /// The integer representing this scalar is less than \\\\(2\\^{255} - 19 \\\\), i.e., it represents\n    /// a canonical representative of an element of \\\\( \\mathbb Z / \\ell\\mathbb Z \\\\). This is\n    /// stronger than invariant #1. It also sometimes has to be broken.\n    ///\n    /// This invariant is deliberately broken in the implementation of `EdwardsPoint::{mul_clamped,\n    /// mul_base_clamped}`, `MontgomeryPoint::{mul_clamped, mul_base_clamped}`, and\n    /// `BasepointTable::mul_base_clamped`. This is not an issue though. As mentioned above,\n    /// scalar-point multiplication is defined for any choice of `bytes` that satisfies invariant\n    /// #1. Since clamping guarantees invariant #1 is satisfied, these operations are well defined.\n    ///\n    /// Note: Scalar-point mult is the _only_ thing you can do safely with an unreduced scalar.\n    /// Scalar-scalar addition and subtraction are NOT correct when using unreduced scalars.\n    /// Multiplication is correct, but this is only due to a quirk of our implementation, and not\n    /// guaranteed to hold in general in the future.\n    ///\n    /// Note: It is not possible to construct an unreduced `Scalar` from the public API unless the\n    /// `legacy_compatibility` is enabled (thus making `Scalar::from_bits` public). Thus, for all\n    /// public non-legacy uses, invariant #2\n    /// always holds.\n    ///\n    pub(crate) bytes: [u8; 32],\n}\n\nimpl Scalar {\n    /// Construct a `Scalar` by reducing a 256-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> Scalar {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }\n\n    /// Construct a `Scalar` by reducing a 512-bit little-endian integer\n    /// modulo the group order \\\\( \\ell \\\\).\n    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }\n\n    /// Attempt to construct a `Scalar` from a canonical byte representation.\n    ///\n    /// # Return\n    ///\n    /// - `Some(s)`, where `s` is the `Scalar` corresponding to `bytes`,\n    ///   if `bytes` is a canonical byte representation modulo the group order \\\\( \\ell \\\\);\n    /// - `None` if `bytes` is not a canonical byte representation.\n    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }\n\n    /// Construct a `Scalar` from the low 255 bits of a 256-bit integer. This breaks the invariant\n    /// that scalars are always reduced. Scalar-scalar arithmetic, i.e., addition, subtraction,\n    /// multiplication, **does not work** on scalars produced from this function. You may only use\n    /// the output of this function for `EdwardsPoint::mul`, `MontgomeryPoint::mul`, and\n    /// `EdwardsPoint::vartime_double_scalar_mul_basepoint`. **Do not use this function** unless\n    /// you absolutely have to.\n    #[cfg(feature = \"legacy_compatibility\")]\n    pub const fn from_bits(bytes: [u8; 32]) -> Scalar {\n        let mut s = Scalar { bytes };\n        // Ensure invariant #1 holds. That is, make s < 2^255 by masking the high bit.\n        s.bytes[31] &= 0b0111_1111;\n\n        s\n    }\n}\n\nimpl Debug for Scalar {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }\n}\n\nimpl Eq for Scalar {}\nimpl PartialEq for Scalar {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl ConstantTimeEq for Scalar {\n    fn ct_eq(&self, other: &Self) -> Choice {\n        self.bytes.ct_eq(&other.bytes)\n    }\n}\n\nimpl Index<usize> for Scalar {\n    type Output = u8;\n\n    /// Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.\n    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for Scalar {\n    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }\n}\n\ndefine_mul_assign_variants!(LHS = Scalar, RHS = Scalar);\n\nimpl<'a> Mul<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }\n}\n\ndefine_mul_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> AddAssign<&'a Scalar> for Scalar {\n    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = Scalar, RHS = Scalar);\n\nimpl<'a> Add<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }\n}\n\ndefine_add_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl<'a> SubAssign<&'a Scalar> for Scalar {\n    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = Scalar, RHS = Scalar);\n\nimpl<'a> Sub<&'a Scalar> for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }\n}\n\ndefine_sub_variants!(LHS = Scalar, RHS = Scalar, Output = Scalar);\n\nimpl Neg for &Scalar {\n    type Output = Scalar;\n    #[allow(non_snake_case)]\n    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }\n}\n\nimpl Neg for Scalar {\n    type Output = Scalar;\n    fn neg(self) -> Scalar {\n        -&self\n    }\n}\n\nimpl ConditionallySelectable for Scalar {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }\n}\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl Serialize for Scalar {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"serde\")))]\nimpl<'de> Deserialize<'de> for Scalar {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct ScalarVisitor;\n\n        impl<'de> Visitor<'de> for ScalarVisitor {\n            type Value = Scalar;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\n                    \"a sequence of 32 bytes whose little-endian interpretation is less than the \\\n                    basepoint order ℓ\",\n                )\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Scalar, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Option::from(Scalar::from_canonical_bytes(bytes))\n                    .ok_or_else(|| serde::de::Error::custom(\"scalar was not canonically encoded\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, ScalarVisitor)\n    }\n}\n\nimpl<T> Product<T> for Scalar\nwhere\n    T: Borrow<Scalar>,\n{\n    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }\n}\n\nimpl<T> Sum<T> for Scalar\nwhere\n    T: Borrow<Scalar>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }\n}\n\nimpl Default for Scalar {\n    fn default() -> Scalar {\n        Scalar::ZERO\n    }\n}\n\nimpl From<u8> for Scalar {\n    fn from(x: u8) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        s_bytes[0] = x;\n        Scalar { bytes: s_bytes }\n    }\n}\n\nimpl From<u16> for Scalar {\n    fn from(x: u16) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}\n\nimpl From<u32> for Scalar {\n    fn from(x: u32) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}\n\nimpl From<u64> for Scalar {\n    /// Construct a scalar from the given `u64`.\n    ///\n    /// # Inputs\n    ///\n    /// An `u64` to convert to a `Scalar`.\n    ///\n    /// # Returns\n    ///\n    /// A `Scalar` corresponding to the input `u64`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let fourtytwo = Scalar::from(42u64);\n    /// let six = Scalar::from(6u64);\n    /// let seven = Scalar::from(7u64);\n    ///\n    /// assert!(fourtytwo == six * seven);\n    /// ```\n    fn from(x: u64) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}\n\nimpl From<u128> for Scalar {\n    fn from(x: u128) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        let x_bytes = x.to_le_bytes();\n        s_bytes[0..x_bytes.len()].copy_from_slice(&x_bytes);\n        Scalar { bytes: s_bytes }\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for Scalar {\n    fn zeroize(&mut self) {\n        self.bytes.zeroize();\n    }\n}\n\nimpl Scalar {\n    /// The scalar \\\\( 0 \\\\).\n    pub const ZERO: Self = Self { bytes: [0u8; 32] };\n\n    /// The scalar \\\\( 1 \\\\).\n    pub const ONE: Self = Self {\n        bytes: [\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n    };\n\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `Scalar` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRng` interface.\n    ///\n    /// # Returns\n    ///\n    /// A random scalar within \\\\(\\mathbb{Z} / \\ell\\mathbb{Z}\\\\).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # fn main() {\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// use rand_core::{OsRng, TryRngCore};\n    ///\n    /// let mut csprng = OsRng.unwrap_err();\n    /// let a: Scalar = Scalar::random(&mut csprng);\n    /// # }\n    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        let mut scalar_bytes = [0u8; 64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a scalar.\n    ///\n    /// Takes a type parameter `D`, which is any `Digest` producing 64\n    /// bytes (512 bits) of output.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use sha2::Sha512;\n    ///\n    /// # // Need fn main() here in comment so the doctest compiles\n    /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let s = Scalar::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    pub fn hash_from_bytes<D>(input: &[u8]) -> Scalar\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        Scalar::from_hash(hash)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a scalar from an existing `Digest` instance.\n    ///\n    /// Use this instead of `hash_from_bytes` if it is more convenient\n    /// to stream data into the `Digest` than to pass a single byte\n    /// slice.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// use curve25519_dalek::digest::Update;\n    ///\n    /// use sha2::Digest;\n    /// use sha2::Sha512;\n    ///\n    /// # fn main() {\n    /// let mut h = Sha512::new()\n    ///     .chain(\"To really appreciate architecture, you may even need to commit a murder.\")\n    ///     .chain(\"While the programs used for The Manhattan Transcripts are of the most extreme\")\n    ///     .chain(\"nature, they also parallel the most common formula plot: the archetype of\")\n    ///     .chain(\"murder. Other phantasms were occasionally used to underline the fact that\")\n    ///     .chain(\"perhaps all architecture, rather than being about functional standards, is\")\n    ///     .chain(\"about love and death.\");\n    ///\n    /// let s = Scalar::from_hash(h);\n    ///\n    /// println!(\"{:?}\", s.to_bytes());\n    /// assert_eq!(\n    ///     s.to_bytes(),\n    ///     [  21,  88, 208, 252,  63, 122, 210, 152,\n    ///       154,  38,  15,  23,  16, 167,  80, 150,\n    ///       192, 221,  77, 226,  62,  25, 224, 148,\n    ///       239,  48, 176,  10, 185,  69, 168,  11, ],\n    /// );\n    /// # }\n    /// ```\n    pub fn from_hash<D>(hash: D) -> Scalar\n    where\n        D: Digest<OutputSize = U64>,\n    {\n        let mut output = [0u8; 64];\n        output.copy_from_slice(hash.finalize().as_slice());\n        Scalar::from_bytes_mod_order_wide(&output)\n    }\n\n    /// Convert this `Scalar` to its underlying sequence of bytes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.to_bytes() == [0u8; 32]);\n    /// ```\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.bytes\n    }\n\n    /// View the little-endian byte encoding of the integer representing this Scalar.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// let s: Scalar = Scalar::ZERO;\n    ///\n    /// assert!(s.as_bytes() == &[0u8; 32]);\n    /// ```\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.bytes\n    }\n\n    /// Given a nonzero `Scalar`, compute its multiplicative inverse.\n    ///\n    /// # Warning\n    ///\n    /// `self` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Returns\n    ///\n    /// The multiplicative inverse of the this `Scalar`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    /// let X: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n    ///         0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n    ///         0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n    ///         0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n    ///     ]);\n    /// // 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    /// let XINV: Scalar = Scalar::from_bytes_mod_order([\n    ///         0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n    ///         0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n    ///         0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n    ///         0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n    ///     ]);\n    ///\n    /// let inv_X: Scalar = X.invert();\n    /// assert!(XINV == inv_X);\n    /// let should_be_one: Scalar = &inv_X * &X;\n    /// assert!(should_be_one == Scalar::ONE);\n    /// ```\n    pub fn invert(&self) -> Scalar {\n        self.unpack().invert().pack()\n    }\n\n    /// Given a slice of nonzero (possibly secret) `Scalar`s,\n    /// compute their inverses in a batch.\n    ///\n    /// # Return\n    ///\n    /// Each element of `inputs` is replaced by its inverse.\n    ///\n    /// The product of all inverses is returned.\n    ///\n    /// # Warning\n    ///\n    /// All input `Scalars` **MUST** be nonzero.  If you cannot\n    /// *prove* that this is the case, you **SHOULD NOT USE THIS\n    /// FUNCTION**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use curve25519_dalek::scalar::Scalar;\n    /// # fn main() {\n    /// let mut scalars = [\n    ///     Scalar::from(3u64),\n    ///     Scalar::from(5u64),\n    ///     Scalar::from(7u64),\n    ///     Scalar::from(11u64),\n    /// ];\n    ///\n    /// let allinv = Scalar::batch_invert(&mut scalars);\n    ///\n    /// assert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\n    /// assert_eq!(scalars[0], Scalar::from(3u64).invert());\n    /// assert_eq!(scalars[1], Scalar::from(5u64).invert());\n    /// assert_eq!(scalars[2], Scalar::from(7u64).invert());\n    /// assert_eq!(scalars[3], Scalar::from(11u64).invert());\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    pub fn batch_invert(inputs: &mut [Scalar]) -> Scalar {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n\n        let n = inputs.len();\n        let one: UnpackedScalar = Scalar::ONE.unpack().as_montgomery();\n\n        let mut scratch = vec![one; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = Scalar::ONE.unpack().as_montgomery();\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n            *scratch = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        acc = acc.montgomery_invert().from_montgomery();\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n            acc = tmp;\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        Zeroize::zeroize(&mut scratch);\n\n        ret\n    }\n\n    /// Get the bits of the scalar, in little-endian order\n    pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n        (0..256).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }\n\n    /// Compute a width-\\\\(w\\\\) \"Non-Adjacent Form\" of this scalar.\n    ///\n    /// A width-\\\\(w\\\\) NAF of a positive integer \\\\(k\\\\) is an expression\n    /// $$\n    /// k = \\sum_{i=0}\\^m n\\_i 2\\^i,\n    /// $$\n    /// where each nonzero\n    /// coefficient \\\\(n\\_i\\\\) is odd and bounded by \\\\(|n\\_i| < 2\\^{w-1}\\\\),\n    /// \\\\(n\\_{m-1}\\\\) is nonzero, and at most one of any \\\\(w\\\\) consecutive\n    /// coefficients is nonzero.  (Hankerson, Menezes, Vanstone; def 3.32).\n    ///\n    /// The length of the NAF is at most one more than the length of\n    /// the binary representation of \\\\(k\\\\).  This is why the\n    /// `Scalar` type maintains an invariant (invariant #1) that the top bit is\n    /// \\\\(0\\\\), so that the NAF of a scalar has at most 256 digits.\n    ///\n    /// Intuitively, this is like a binary expansion, except that we\n    /// allow some coefficients to grow in magnitude up to\n    /// \\\\(2\\^{w-1}\\\\) so that the nonzero coefficients are as sparse\n    /// as possible.\n    ///\n    /// When doing scalar multiplication, we can then use a lookup\n    /// table of precomputed multiples of a point to add the nonzero\n    /// terms \\\\( k_i P \\\\).  Using signed digits cuts the table size\n    /// in half, and using odd digits cuts the table size in half\n    /// again.\n    ///\n    /// To compute a \\\\(w\\\\)-NAF, we use a modification of Algorithm 3.35 of HMV:\n    ///\n    /// 1. \\\\( i \\gets 0 \\\\)\n    /// 2. While \\\\( k \\ge 1 \\\\):\n    ///     1. If \\\\(k\\\\) is odd, \\\\( n_i \\gets k \\operatorname{mods} 2^w \\\\), \\\\( k \\gets k - n_i \\\\).\n    ///     2. If \\\\(k\\\\) is even, \\\\( n_i \\gets 0 \\\\).\n    ///     3. \\\\( k \\gets k / 2 \\\\), \\\\( i \\gets i + 1 \\\\).\n    /// 3. Return \\\\( n_0, n_1, ... , \\\\)\n    ///\n    /// Here \\\\( \\bar x = x \\operatorname{mods} 2^w \\\\) means the\n    /// \\\\( \\bar x \\\\) with \\\\( \\bar x \\equiv x \\pmod{2^w} \\\\) and\n    /// \\\\( -2^{w-1} \\leq \\bar x < 2^{w-1} \\\\).\n    ///\n    /// We implement this by scanning across the bits of \\\\(k\\\\) from\n    /// least-significant bit to most-significant-bit.\n    /// Write the bits of \\\\(k\\\\) as\n    /// $$\n    /// k = \\sum\\_{i=0}\\^m k\\_i 2^i,\n    /// $$\n    /// and split the sum as\n    /// $$\n    /// k = \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n    /// $$\n    /// where the first part is \\\\( k \\mod 2^w \\\\).\n    ///\n    /// If \\\\( k \\mod 2^w\\\\) is odd, and \\\\( k \\mod 2^w < 2^{w-1} \\\\), then we emit\n    /// \\\\( n_0 = k \\mod 2^w \\\\).  Instead of computing\n    /// \\\\( k - n_0 \\\\), we just advance \\\\(w\\\\) bits and reindex.\n    ///\n    /// If \\\\( k \\mod 2^w\\\\) is odd, and \\\\( k \\mod 2^w \\ge 2^{w-1} \\\\), then\n    /// \\\\( n_0 = k \\operatorname{mods} 2^w = k \\mod 2^w - 2^w \\\\).\n    /// The quantity \\\\( k - n_0 \\\\) is\n    /// $$\n    /// \\begin{aligned}\n    /// k - n_0 &= \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n    ///          - \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\\\\\\\\n    /// &= 2^w + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n    /// \\end{aligned}\n    /// $$\n    /// so instead of computing the subtraction, we can set a carry\n    /// bit, advance \\\\(w\\\\) bits, and reindex.\n    ///\n    /// If \\\\( k \\mod 2^w\\\\) is even, we emit \\\\(0\\\\), advance 1 bit\n    /// and reindex.  In fact, by setting all digits to \\\\(0\\\\)\n    /// initially, we don't need to emit anything.\n    pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {\n        // required by the NAF definition\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        debug_assert!(w <= 8);\n\n        let mut naf = [0i8; 256];\n\n        let mut x_u64 = [0u64; 5];\n        read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }\n\n        naf\n    }\n\n    /// Write this scalar in radix 16, with coefficients in \\\\([-8,8)\\\\),\n    /// i.e., compute \\\\(a\\_i\\\\) such that\n    /// $$\n    ///    a = a\\_0 + a\\_1 16\\^1 + \\cdots + a_{63} 16\\^{63},\n    /// $$\n    /// with \\\\(-8 \\leq a_i < 8\\\\) for \\\\(0 \\leq i < 63\\\\) and \\\\(-8 \\leq a_{63} \\leq 8\\\\).\n    ///\n    /// The largest value that can be decomposed like this is just over \\\\(2^{255}\\\\). Thus, in\n    /// order to not error, the top bit MUST NOT be set, i.e., `Self` MUST be less than\n    /// \\\\(2^{255}\\\\).\n    pub(crate) fn as_radix_16(&self) -> [i8; 64] {\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8; 64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[allow(clippy::identity_op)]\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        for i in 0..32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        output\n    }\n\n    /// Returns a size hint indicating how many entries of the return\n    /// value of `to_radix_2w` are nonzero.\n    #[cfg(any(feature = \"alloc\", all(test, feature = \"precomputed-tables\")))]\n    pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        let digits_count = match w {\n            4..=7 => 256_usize.div_ceil(w),\n            // See comment in to_radix_2w on handling the terminal carry.\n            8 => 256_usize.div_ceil(w) + 1_usize,\n            _ => panic!(\"invalid radix parameter\"),\n        };\n\n        debug_assert!(digits_count <= 64);\n        digits_count\n    }\n\n    /// Creates a representation of a Scalar in radix \\\\( 2^w \\\\) with \\\\(w = 4, 5, 6, 7, 8\\\\) for\n    /// use with the Pippenger algorithm. Higher radixes are not supported to save cache space.\n    /// Radix 256 is near-optimal even for very large inputs.\n    ///\n    /// Radix below 16 or above 256 is prohibited.\n    /// This method returns digits in a fixed-sized array, excess digits are zeroes.\n    ///\n    /// For radix 16, `Self` must be less than \\\\(2^{255}\\\\). This is because most integers larger\n    /// than \\\\(2^{255}\\\\) are unrepresentable in the form described below for \\\\(w = 4\\\\). This\n    /// would be true for \\\\(w = 8\\\\) as well, but it is compensated for by increasing the size\n    /// hint by 1.\n    ///\n    /// ## Scalar representation\n    ///\n    /// Radix \\\\(2\\^w\\\\), with \\\\(n = ceil(256/w)\\\\) coefficients in \\\\([-(2\\^w)/2,(2\\^w)/2)\\\\),\n    /// i.e., scalar is represented using digits \\\\(a\\_i\\\\) such that\n    /// $$\n    ///    a = a\\_0 + a\\_1 2\\^1w + \\cdots + a_{n-1} 2\\^{w*(n-1)},\n    /// $$\n    /// with \\\\(-2\\^w/2 \\leq a_i < 2\\^w/2\\\\) for \\\\(0 \\leq i < (n-1)\\\\) and \\\\(-2\\^w/2 \\leq a_{n-1} \\leq 2\\^w/2\\\\).\n    ///\n    #[cfg(any(feature = \"alloc\", feature = \"precomputed-tables\"))]\n    pub(crate) fn as_radix_2w(&self, w: usize) -> [i8; 64] {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        if w == 4 {\n            return self.as_radix_16();\n        }\n\n        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.\n        let mut scalar64x4 = [0u64; 4];\n        read_le_u64_into(&self.bytes, &mut scalar64x4[0..4]);\n\n        let radix: u64 = 1 << w;\n        let window_mask: u64 = radix - 1;\n\n        let mut carry = 0u64;\n        let mut digits = [0i8; 64];\n        let digits_count = 256_usize.div_ceil(w);\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }\n\n        // When 4 < w < 8, we can fold the final carry onto the last digit d,\n        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.\n        //\n        // When w = 8, we can't fit carry*2^w into an i8.  This should\n        // not happen anyways, because the final carry will be 0 for\n        // reduced scalars, but Scalar invariant #1 allows 255-bit scalars.\n        // To handle this, we expand the size_hint by 1 when w=8,\n        // and accumulate the final carry onto another digit.\n        match w {\n            8 => digits[digits_count] += carry as i8,\n            _ => digits[digits_count - 1] += (carry << w) as i8,\n        }\n\n        digits\n    }\n\n    /// Unpack this `Scalar` to an `UnpackedScalar` for faster arithmetic.\n    pub(crate) fn unpack(&self) -> UnpackedScalar {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }\n\n    /// Reduce this `Scalar` modulo \\\\(\\ell\\\\).\n    #[allow(non_snake_case)]\n    fn reduce(&self) -> Scalar {\n        let x = self.unpack();\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        x_mod_l.pack()\n    }\n\n    /// Check whether this `Scalar` is the canonical representative mod \\\\(\\ell\\\\). This is not\n    /// public because any `Scalar` that is publicly observed is reduced, by scalar invariant #2.\n    fn is_canonical(&self) -> Choice {\n        self.ct_eq(&self.reduce())\n    }\n}\n\nimpl UnpackedScalar {\n    /// Pack the limbs of this `UnpackedScalar` into a `Scalar`.\n    fn pack(&self) -> Scalar {\n        Scalar {\n            bytes: self.to_bytes(),\n        }\n    }\n\n    /// Inverts an UnpackedScalar in Montgomery form.\n    #[rustfmt::skip] // keep alignment of addition chain and squarings\n    #[allow(clippy::just_underscores_and_digits)]\n    pub fn montgomery_invert(&self) -> UnpackedScalar {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let    _1 = *self;\n        let   _10 = _1.montgomery_square();\n        let  _100 = _10.montgomery_square();\n        let   _11 = UnpackedScalar::montgomery_mul(&_10,     &_1);\n        let  _101 = UnpackedScalar::montgomery_mul(&_10,    &_11);\n        let  _111 = UnpackedScalar::montgomery_mul(&_10,   &_101);\n        let _1001 = UnpackedScalar::montgomery_mul(&_10,   &_111);\n        let _1011 = UnpackedScalar::montgomery_mul(&_10,  &_1001);\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n\n        #[inline]\n        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,       4, &_1001);\n        square_multiply(&mut y,       2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 3, &_101);\n        square_multiply(&mut y,   3 + 3, &_101);\n        square_multiply(&mut y,       3, &_111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   2 + 3, &_111);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,   2 + 4, &_1011);\n        square_multiply(&mut y,   6 + 4, &_1001);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1001);\n        square_multiply(&mut y,   1 + 3, &_111);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   1 + 2, &_11);\n\n        y\n    }\n\n    /// Inverts an UnpackedScalar not in Montgomery form.\n    pub fn invert(&self) -> UnpackedScalar {\n        self.as_montgomery().montgomery_invert().from_montgomery()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl Field for Scalar {\n    const ZERO: Self = Self::ZERO;\n    const ONE: Self = Self::ONE;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        // NOTE: this is duplicated due to different `rng` bounds\n        let mut scalar_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut scalar_bytes)?;\n        Ok(Self::from_bytes_mod_order_wide(&scalar_bytes))\n    }\n\n    fn square(&self) -> Self {\n        self * self\n    }\n\n    fn double(&self) -> Self {\n        self + self\n    }\n\n    fn invert(&self) -> CtOption<Self> {\n        CtOption::new(self.invert(), !self.is_zero())\n    }\n\n    fn sqrt_ratio(num: &Self, div: &Self) -> (Choice, Self) {\n        #[allow(unused_qualifications)]\n        group::ff::helpers::sqrt_ratio_generic(num, div)\n    }\n\n    fn sqrt(&self) -> CtOption<Self> {\n        #[allow(unused_qualifications)]\n        group::ff::helpers::sqrt_tonelli_shanks(\n            self,\n            [\n                0xcb02_4c63_4b9e_ba7d,\n                0x029b_df3b_d45e_f39a,\n                0x0000_0000_0000_0000,\n                0x0200_0000_0000_0000,\n            ],\n        )\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl PrimeField for Scalar {\n    type Repr = [u8; 32];\n\n    fn from_repr(repr: Self::Repr) -> CtOption<Self> {\n        Self::from_canonical_bytes(repr)\n    }\n\n    fn from_repr_vartime(repr: Self::Repr) -> Option<Self> {\n        // Check that the high bit is not set\n        if (repr[31] >> 7) != 0u8 {\n            return None;\n        }\n\n        let candidate = Scalar { bytes: repr };\n\n        if candidate == candidate.reduce() {\n            Some(candidate)\n        } else {\n            None\n        }\n    }\n\n    fn to_repr(&self) -> Self::Repr {\n        self.to_bytes()\n    }\n\n    fn is_odd(&self) -> Choice {\n        Choice::from(self.as_bytes()[0] & 1)\n    }\n\n    const MODULUS: &'static str =\n        \"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\";\n    const NUM_BITS: u32 = 253;\n    const CAPACITY: u32 = 252;\n\n    const TWO_INV: Self = Self {\n        bytes: [\n            0xf7, 0xe9, 0x7a, 0x2e, 0x8d, 0x31, 0x09, 0x2c, 0x6b, 0xce, 0x7b, 0x51, 0xef, 0x7c,\n            0x6f, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x08,\n        ],\n    };\n    const MULTIPLICATIVE_GENERATOR: Self = Self {\n        bytes: [\n            2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n    };\n    const S: u32 = 2;\n    const ROOT_OF_UNITY: Self = Self {\n        bytes: [\n            0xd4, 0x07, 0xbe, 0xeb, 0xdf, 0x75, 0x87, 0xbe, 0xfe, 0x83, 0xce, 0x42, 0x53, 0x56,\n            0xf0, 0x0e, 0x7a, 0xc2, 0xc1, 0xab, 0x60, 0x6d, 0x3d, 0x7d, 0xe7, 0x81, 0x79, 0xe0,\n            0x10, 0x73, 0x4a, 0x09,\n        ],\n    };\n    const ROOT_OF_UNITY_INV: Self = Self {\n        bytes: [\n            0x19, 0xcc, 0x37, 0x71, 0x3a, 0xed, 0x8a, 0x99, 0xd7, 0x18, 0x29, 0x60, 0x8b, 0xa3,\n            0xee, 0x05, 0x86, 0x3d, 0x3e, 0x54, 0x9f, 0x92, 0xc2, 0x82, 0x18, 0x7e, 0x86, 0x1f,\n            0xef, 0x8c, 0xb5, 0x06,\n        ],\n    };\n    const DELTA: Self = Self {\n        bytes: [\n            16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n    };\n}\n\n#[cfg(feature = \"group-bits\")]\nimpl PrimeFieldBits for Scalar {\n    type ReprBits = [u8; 32];\n\n    fn to_le_bits(&self) -> FieldBits<Self::ReprBits> {\n        self.to_repr().into()\n    }\n\n    fn char_le_bits() -> FieldBits<Self::ReprBits> {\n        constants::BASEPOINT_ORDER.to_bytes().into()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl FromUniformBytes<64> for Scalar {\n    fn from_uniform_bytes(bytes: &[u8; 64]) -> Self {\n        Scalar::from_bytes_mod_order_wide(bytes)\n    }\n}\n\n/// Read one or more u64s stored as little endian bytes.\n///\n/// ## Panics\n/// Panics if `src.len() != 8 * dst.len()`.\nfn read_le_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(\n        src.len() == 8 * dst.len(),\n        \"src.len() = {}, dst.len() = {}\",\n        src.len(),\n        dst.len()\n    );\n    for (bytes, val) in src.chunks(8).zip(dst.iter_mut()) {\n        *val = u64::from_le_bytes(\n            bytes\n                .try_into()\n                .expect(\"Incorrect src length, should be 8 * dst.len()\"),\n        );\n    }\n}\n\n/// _Clamps_ the given little-endian representation of a 32-byte integer. Clamping the value puts\n/// it in the range:\n///\n/// **n ∈ 2^254 + 8\\*{0, 1, 2, 3, . . ., 2^251 − 1}**\n///\n/// # Explanation of clamping\n///\n/// For Curve25519, h = 8, and multiplying by 8 is the same as a binary left-shift by 3 bits.\n/// If you take a secret scalar value between 2^251 and 2^252 – 1 and left-shift by 3 bits\n/// then you end up with a 255-bit number with the most significant bit set to 1 and\n/// the least-significant three bits set to 0.\n///\n/// The Curve25519 clamping operation takes **an arbitrary 256-bit random value** and\n/// clears the most-significant bit (making it a 255-bit number), sets the next bit, and then\n/// clears the 3 least-significant bits. In other words, it directly creates a scalar value that is\n/// in the right form and pre-multiplied by the cofactor.\n///\n/// See [here](https://neilmadden.blog/2020/05/28/whats-the-curve25519-clamping-all-about/) for\n/// more details.\n#[must_use]\npub const fn clamp_integer(mut bytes: [u8; 32]) -> [u8; 32] {\n    bytes[0] &= 0b1111_1000;\n    bytes[31] &= 0b0111_1111;\n    bytes[31] |= 0b0100_0000;\n    bytes\n}\n\n#[cfg(test)]\npub(crate) mod test {\n    use super::*;\n    use rand_core::RngCore;\n\n    #[cfg(feature = \"alloc\")]\n    use alloc::vec::Vec;\n\n    /// x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\n    pub static X: Scalar = Scalar {\n        bytes: [\n            0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84, 0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2,\n            0x7d, 0x52, 0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44, 0xd4, 0x49, 0xf4, 0xa8,\n            0x79, 0xd9, 0xf2, 0x04,\n        ],\n    };\n    /// 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\n    pub static XINV: Scalar = Scalar {\n        bytes: [\n            0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb, 0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01,\n            0x63, 0x47, 0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96, 0xd5, 0x0b, 0xcd, 0x7a,\n            0x3f, 0x96, 0x2a, 0x0f,\n        ],\n    };\n    /// y = 2592331292931086675770238855846338635550719849568364935475441891787804997264\n    pub static Y: Scalar = Scalar {\n        bytes: [\n            0x90, 0x76, 0x33, 0xfe, 0x1c, 0x4b, 0x66, 0xa4, 0xa2, 0x8d, 0x2d, 0xd7, 0x67, 0x83,\n            0x86, 0xc3, 0x53, 0xd0, 0xde, 0x54, 0x55, 0xd4, 0xfc, 0x9d, 0xe8, 0xef, 0x7a, 0xc3,\n            0x1f, 0x35, 0xbb, 0x05,\n        ],\n    };\n\n    /// The largest scalar that satisfies invariant #1, i.e., the largest scalar with the top bit\n    /// set to 0. Since this scalar violates invariant #2, i.e., it's greater than the modulus `l`,\n    /// addition and subtraction are broken. The only thing you can do with this is scalar-point\n    /// multiplication (and actually also scalar-scalar multiplication, but that's just a quirk of\n    /// our implementation).\n    pub(crate) static LARGEST_UNREDUCED_SCALAR: Scalar = Scalar {\n        bytes: [\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0x7f,\n        ],\n    };\n\n    /// x*y = 5690045403673944803228348699031245560686958845067437804563560795922180092780\n    static X_TIMES_Y: Scalar = Scalar {\n        bytes: [\n            0x6c, 0x33, 0x74, 0xa1, 0x89, 0x4f, 0x62, 0x21, 0x0a, 0xaa, 0x2f, 0xe1, 0x86, 0xa6,\n            0xf9, 0x2c, 0xe0, 0xaa, 0x75, 0xc2, 0x77, 0x95, 0x81, 0xc2, 0x95, 0xfc, 0x08, 0x17,\n            0x9a, 0x73, 0x94, 0x0c,\n        ],\n    };\n\n    /// sage: l = 2^252 + 27742317777372353535851937790883648493\n    /// sage: big = 2^256 - 1\n    /// sage: repr((big % l).digits(256))\n    static CANONICAL_2_256_MINUS_1: Scalar = Scalar {\n        bytes: [\n            28, 149, 152, 141, 116, 49, 236, 214, 112, 207, 125, 115, 244, 91, 239, 198, 254, 255,\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 15,\n        ],\n    };\n\n    static A_SCALAR: Scalar = Scalar {\n        bytes: [\n            0x1a, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n            0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n            0x23, 0x76, 0xef, 0x09,\n        ],\n    };\n\n    static A_NAF: [i8; 256] = [\n        0, 13, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, -9, 0, 0, 0, 0, -11, 0, 0, 0, 0, 3, 0, 0,\n        0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, -5, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 11, 0, 0, 0, 0,\n        11, 0, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,\n        0, -1, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, -15, 0, 0, 0, 0, -7, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 5,\n        0, 0, 0, 0, 13, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, -11, 0, 0, 0, 0, -7, 0, 0, 0, 0, -13, 0, 0,\n        0, 0, 11, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n        7, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 15,\n        0, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, -15, 0,\n        0, 0, 0, 0, 15, 0, 0, 0, 0, 15, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    ];\n\n    const BASEPOINT_ORDER_MINUS_ONE: Scalar = Scalar {\n        bytes: [\n            0xec, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9,\n            0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x10,\n        ],\n    };\n\n    /// The largest clamped integer\n    static LARGEST_CLAMPED_INTEGER: [u8; 32] = clamp_integer(LARGEST_UNREDUCED_SCALAR.bytes);\n\n    #[test]\n    fn fuzzer_testcase_reduction() {\n        // LE bytes of 24519928653854221733733552434404946937899825954937634815\n        let a_bytes = [\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n            255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        // LE bytes of 4975441334397345751130612518500927154628011511324180036903450236863266160640\n        let b_bytes = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 210, 210,\n            210, 255, 255, 255, 255, 10,\n        ];\n        // LE bytes of 6432735165214683820902750800207468552549813371247423777071615116673864412038\n        let c_bytes = [\n            134, 171, 119, 216, 180, 128, 178, 62, 171, 132, 32, 62, 34, 119, 104, 193, 47, 215,\n            181, 250, 14, 207, 172, 93, 75, 207, 211, 103, 144, 204, 56, 14,\n        ];\n\n        let a = Scalar::from_bytes_mod_order(a_bytes);\n        let b = Scalar::from_bytes_mod_order(b_bytes);\n        let c = Scalar::from_bytes_mod_order(c_bytes);\n\n        let mut tmp = [0u8; 64];\n\n        // also_a = (a mod l)\n        tmp[0..32].copy_from_slice(&a_bytes[..]);\n        let also_a = Scalar::from_bytes_mod_order_wide(&tmp);\n\n        // also_b = (b mod l)\n        tmp[0..32].copy_from_slice(&b_bytes[..]);\n        let also_b = Scalar::from_bytes_mod_order_wide(&tmp);\n\n        let expected_c = a * b;\n        let also_expected_c = also_a * also_b;\n\n        assert_eq!(c, expected_c);\n        assert_eq!(c, also_expected_c);\n    }\n\n    #[test]\n    fn non_adjacent_form_test_vector() {\n        let naf = A_SCALAR.non_adjacent_form(5);\n        for i in 0..256 {\n            assert_eq!(naf[i], A_NAF[i]);\n        }\n    }\n\n    fn non_adjacent_form_iter(w: usize, x: &Scalar) {\n        let naf = x.non_adjacent_form(w);\n\n        // Reconstruct the scalar from the computed NAF\n        let mut y = Scalar::ZERO;\n        for i in (0..256).rev() {\n            y += y;\n            let digit = if naf[i] < 0 {\n                -Scalar::from((-naf[i]) as u64)\n            } else {\n                Scalar::from(naf[i] as u64)\n            };\n            y += digit;\n        }\n\n        assert_eq!(*x, y);\n    }\n\n    #[test]\n    fn non_adjacent_form_random() {\n        let mut rng = rand::rng();\n        for _ in 0..1_000 {\n            let x = Scalar::random(&mut rng);\n            for w in &[5, 6, 7, 8] {\n                non_adjacent_form_iter(*w, &x);\n            }\n        }\n    }\n\n    #[test]\n    fn from_u64() {\n        let val: u64 = 0xdeadbeefdeadbeef;\n        let s = Scalar::from(val);\n        assert_eq!(s[7], 0xde);\n        assert_eq!(s[6], 0xad);\n        assert_eq!(s[5], 0xbe);\n        assert_eq!(s[4], 0xef);\n        assert_eq!(s[3], 0xde);\n        assert_eq!(s[2], 0xad);\n        assert_eq!(s[1], 0xbe);\n        assert_eq!(s[0], 0xef);\n    }\n\n    #[test]\n    fn scalar_mul_by_one() {\n        let test_scalar = X * Scalar::ONE;\n        for i in 0..32 {\n            assert!(test_scalar[i] == X[i]);\n        }\n    }\n\n    #[test]\n    fn add_reduces() {\n        // Check that addition wraps around the modulus\n        assert_eq!(BASEPOINT_ORDER_MINUS_ONE + Scalar::ONE, Scalar::ZERO);\n    }\n\n    #[test]\n    fn sub_reduces() {\n        // Check that subtraction wraps around the modulus\n        assert_eq!(Scalar::ZERO - Scalar::ONE, BASEPOINT_ORDER_MINUS_ONE);\n    }\n\n    #[test]\n    fn impl_add() {\n        let two = Scalar::from(2u64);\n        let one = Scalar::ONE;\n        let should_be_two = one + one;\n        assert_eq!(should_be_two, two);\n    }\n\n    #[allow(non_snake_case)]\n    #[test]\n    fn impl_mul() {\n        let should_be_X_times_Y = X * Y;\n        assert_eq!(should_be_X_times_Y, X_TIMES_Y);\n    }\n\n    #[allow(non_snake_case)]\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn impl_product() {\n        // Test that product works for non-empty iterators\n        let X_Y_vector = [X, Y];\n        let should_be_X_times_Y: Scalar = X_Y_vector.iter().product();\n        assert_eq!(should_be_X_times_Y, X_TIMES_Y);\n\n        // Test that product works for the empty iterator\n        let one = Scalar::ONE;\n        let empty_vector = [];\n        let should_be_one: Scalar = empty_vector.iter().product();\n        assert_eq!(should_be_one, one);\n\n        // Test that product works for iterators where Item = Scalar\n        let xs = [Scalar::from(2u64); 10];\n        let ys = [Scalar::from(3u64); 10];\n        // now zs is an iterator with Item = Scalar\n        let zs = xs.iter().zip(ys.iter()).map(|(x, y)| x * y);\n\n        let x_prod: Scalar = xs.iter().product();\n        let y_prod: Scalar = ys.iter().product();\n        let z_prod: Scalar = zs.product();\n\n        assert_eq!(x_prod, Scalar::from(1024u64));\n        assert_eq!(y_prod, Scalar::from(59049u64));\n        assert_eq!(z_prod, Scalar::from(60466176u64));\n        assert_eq!(x_prod * y_prod, z_prod);\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let two = Scalar::from(2u64);\n        let one_vector = [Scalar::ONE, Scalar::ONE];\n        let should_be_two: Scalar = one_vector.iter().sum();\n        assert_eq!(should_be_two, two);\n\n        // Test that sum works for the empty iterator\n        let zero = Scalar::ZERO;\n        let empty_vector = [];\n        let should_be_zero: Scalar = empty_vector.iter().sum();\n        assert_eq!(should_be_zero, zero);\n\n        // Test that sum works for owned types\n        let xs = [Scalar::from(1u64); 10];\n        let ys = [Scalar::from(2u64); 10];\n        // now zs is an iterator with Item = Scalar\n        let zs = xs.iter().zip(ys.iter()).map(|(x, y)| x + y);\n\n        let x_sum: Scalar = xs.iter().sum();\n        let y_sum: Scalar = ys.iter().sum();\n        let z_sum: Scalar = zs.sum();\n\n        assert_eq!(x_sum, Scalar::from(10u64));\n        assert_eq!(y_sum, Scalar::from(20u64));\n        assert_eq!(z_sum, Scalar::from(30u64));\n        assert_eq!(x_sum + y_sum, z_sum);\n    }\n\n    #[test]\n    fn square() {\n        let expected = X * X;\n        let actual = X.unpack().square().pack();\n        for i in 0..32 {\n            assert!(expected[i] == actual[i]);\n        }\n    }\n\n    #[test]\n    fn reduce() {\n        let biggest = Scalar::from_bytes_mod_order([0xff; 32]);\n        assert_eq!(biggest, CANONICAL_2_256_MINUS_1);\n    }\n\n    #[test]\n    fn from_bytes_mod_order_wide() {\n        let mut bignum = [0u8; 64];\n        // set bignum = x + 2^256x\n        for i in 0..32 {\n            bignum[i] = X[i];\n            bignum[32 + i] = X[i];\n        }\n        // 3958878930004874126169954872055634648693766179881526445624823978500314864344\n        // = x + 2^256x (mod l)\n        let reduced = Scalar {\n            bytes: [\n                216, 154, 179, 139, 210, 121, 2, 71, 69, 99, 158, 216, 23, 173, 63, 100, 204, 0,\n                91, 50, 219, 153, 57, 249, 28, 82, 31, 197, 100, 165, 192, 8,\n            ],\n        };\n        let test_red = Scalar::from_bytes_mod_order_wide(&bignum);\n        for i in 0..32 {\n            assert!(test_red[i] == reduced[i]);\n        }\n    }\n\n    #[allow(non_snake_case)]\n    #[test]\n    fn invert() {\n        let inv_X = X.invert();\n        assert_eq!(inv_X, XINV);\n        let should_be_one = inv_X * X;\n        assert_eq!(should_be_one, Scalar::ONE);\n    }\n\n    // Negating a scalar twice should result in the original scalar.\n    #[allow(non_snake_case)]\n    #[test]\n    fn neg_twice_is_identity() {\n        let negative_X = -&X;\n        let should_be_X = -&negative_X;\n\n        assert_eq!(should_be_X, X);\n    }\n\n    #[test]\n    fn to_bytes_from_bytes_roundtrips() {\n        let unpacked = X.unpack();\n        let bytes = unpacked.to_bytes();\n        let should_be_unpacked = UnpackedScalar::from_bytes(&bytes);\n\n        assert_eq!(should_be_unpacked.limbs, unpacked.limbs);\n    }\n\n    #[test]\n    fn montgomery_reduce_matches_from_bytes_mod_order_wide() {\n        let mut bignum = [0u8; 64];\n\n        // set bignum = x + 2^256x\n        for i in 0..32 {\n            bignum[i] = X[i];\n            bignum[32 + i] = X[i];\n        }\n        // x + 2^256x (mod l)\n        //         = 3958878930004874126169954872055634648693766179881526445624823978500314864344\n        let expected = Scalar {\n            bytes: [\n                216, 154, 179, 139, 210, 121, 2, 71, 69, 99, 158, 216, 23, 173, 63, 100, 204, 0,\n                91, 50, 219, 153, 57, 249, 28, 82, 31, 197, 100, 165, 192, 8,\n            ],\n        };\n        let reduced = Scalar::from_bytes_mod_order_wide(&bignum);\n\n        // The reduced scalar should match the expected\n        assert_eq!(reduced.bytes, expected.bytes);\n\n        //  (x + 2^256x) * R\n        let interim =\n            UnpackedScalar::mul_internal(&UnpackedScalar::from_bytes_wide(&bignum), &constants::R);\n        // ((x + 2^256x) * R) / R  (mod l)\n        let montgomery_reduced = UnpackedScalar::montgomery_reduce(&interim);\n\n        // The Montgomery reduced scalar should match the reduced one, as well as the expected\n        assert_eq!(montgomery_reduced.limbs, reduced.unpack().limbs);\n        assert_eq!(montgomery_reduced.limbs, expected.unpack().limbs)\n    }\n\n    #[test]\n    fn canonical_decoding() {\n        // canonical encoding of 1667457891\n        let canonical_bytes = [\n            99, 99, 99, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0,\n        ];\n\n        // encoding of\n        //   7265385991361016183439748078976496179028704920197054998554201349516117938192\n        // = 28380414028753969466561515933501938171588560817147392552250411230663687203 (mod l)\n        // non_canonical because unreduced mod l\n        let non_canonical_bytes_because_unreduced = [16; 32];\n\n        // encoding with high bit set, to check that the parser isn't pre-masking the high bit\n        let non_canonical_bytes_because_highbit = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 128,\n        ];\n\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(canonical_bytes).is_some()\n        ));\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(non_canonical_bytes_because_unreduced).is_none()\n        ));\n        assert!(bool::from(\n            Scalar::from_canonical_bytes(non_canonical_bytes_because_highbit).is_none()\n        ));\n    }\n\n    #[test]\n    #[cfg(feature = \"serde\")]\n    fn serde_bincode_scalar_roundtrip() {\n        use bincode;\n        let encoded = bincode::serialize(&X).unwrap();\n        let parsed: Scalar = bincode::deserialize(&encoded).unwrap();\n        assert_eq!(parsed, X);\n\n        // Check that the encoding is 32 bytes exactly\n        assert_eq!(encoded.len(), 32);\n\n        // Check that the encoding itself matches the usual one\n        assert_eq!(X, bincode::deserialize(X.as_bytes()).unwrap(),);\n    }\n\n    #[cfg(all(debug_assertions, feature = \"alloc\"))]\n    #[test]\n    #[should_panic]\n    fn batch_invert_with_a_zero_input_panics() {\n        let mut xs = vec![Scalar::ONE; 16];\n        xs[3] = Scalar::ZERO;\n        // This should panic in debug mode.\n        Scalar::batch_invert(&mut xs);\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn batch_invert_empty() {\n        assert_eq!(Scalar::ONE, Scalar::batch_invert(&mut []));\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn batch_invert_consistency() {\n        let mut x = Scalar::from(1u64);\n        let mut v1: Vec<_> = (0..16)\n            .map(|_| {\n                let tmp = x;\n                x = x + x;\n                tmp\n            })\n            .collect();\n        let v2 = v1.clone();\n\n        let expected: Scalar = v1.iter().product();\n        let expected = expected.invert();\n        let ret = Scalar::batch_invert(&mut v1);\n        assert_eq!(ret, expected);\n\n        for (a, b) in v1.iter().zip(v2.iter()) {\n            assert_eq!(a * b, Scalar::ONE);\n        }\n    }\n\n    #[cfg(feature = \"precomputed-tables\")]\n    fn test_pippenger_radix_iter(scalar: Scalar, w: usize) {\n        let digits_count = Scalar::to_radix_2w_size_hint(w);\n        let digits = scalar.as_radix_2w(w);\n\n        let radix = Scalar::from((1 << w) as u64);\n        let mut term = Scalar::ONE;\n        let mut recovered_scalar = Scalar::ZERO;\n        for digit in &digits[0..digits_count] {\n            let digit = *digit;\n            if digit != 0 {\n                let sdigit = if digit < 0 {\n                    -Scalar::from((-(digit as i64)) as u64)\n                } else {\n                    Scalar::from(digit as u64)\n                };\n                recovered_scalar += term * sdigit;\n            }\n            term *= radix;\n        }\n        // When the input is unreduced, we may only recover the scalar mod l.\n        assert_eq!(recovered_scalar, scalar.reduce());\n    }\n\n    #[test]\n    #[cfg(feature = \"precomputed-tables\")]\n    fn test_pippenger_radix() {\n        use core::iter;\n        // For each valid radix it tests that 1000 random-ish scalars can be restored\n        // from the produced representation precisely.\n        let cases = (2..100)\n            .map(|s| Scalar::from(s as u64).invert())\n            // The largest unreduced scalar, s = 2^255-1. This is not reduced mod l. Scalar mult\n            // still works though.\n            .chain(iter::once(LARGEST_UNREDUCED_SCALAR));\n\n        for scalar in cases {\n            test_pippenger_radix_iter(scalar, 6);\n            test_pippenger_radix_iter(scalar, 7);\n            test_pippenger_radix_iter(scalar, 8);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn test_read_le_u64_into() {\n        let cases: &[(&[u8], &[u64])] = &[\n            (\n                &[0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F, 0xF0],\n                &[0xF00F_F11F_0110_EFFE],\n            ),\n            (\n                &[\n                    0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A,\n                    0xBC, 0xDE, 0xF0,\n                ],\n                &[0xF00F_F11F_0110_EFFE, 0xF0DE_BC9A_7856_3412],\n            ),\n        ];\n\n        for (src, expected) in cases {\n            let mut dst = vec![0; expected.len()];\n            read_le_u64_into(src, &mut dst);\n\n            assert_eq!(&dst, expected, \"Expected {:x?} got {:x?}\", expected, dst);\n        }\n    }\n\n    // Tests consistency of From<{integer}> impls for Scalar\n    #[test]\n    fn test_scalar_from_int() {\n        let s1 = Scalar::ONE;\n\n        // For `x` in `u8`, `u16`, `u32`, `u64`, and `u128`, check that\n        // `Scalar::from(x + 1) == Scalar::from(x) + Scalar::from(1)`\n\n        let x = 0x23u8;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323u16;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323u32;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323_2323_2323u64;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n\n        let x = 0x2323_2323_2323_2323_2323_2323_2323_2323u128;\n        let sx = Scalar::from(x);\n        assert_eq!(sx + s1, Scalar::from(x + 1));\n    }\n\n    #[cfg(feature = \"group\")]\n    #[test]\n    fn ff_constants() {\n        assert_eq!(Scalar::from(2u64) * Scalar::TWO_INV, Scalar::ONE);\n\n        assert_eq!(\n            Scalar::ROOT_OF_UNITY * Scalar::ROOT_OF_UNITY_INV,\n            Scalar::ONE,\n        );\n\n        // ROOT_OF_UNITY^{2^s} mod m == 1\n        assert_eq!(\n            Scalar::ROOT_OF_UNITY.pow(&[1u64 << Scalar::S, 0, 0, 0]),\n            Scalar::ONE,\n        );\n\n        // DELTA^{t} mod m == 1\n        assert_eq!(\n            Scalar::DELTA.pow(&[\n                0x9604_98c6_973d_74fb,\n                0x0537_be77_a8bd_e735,\n                0x0000_0000_0000_0000,\n                0x0400_0000_0000_0000,\n            ]),\n            Scalar::ONE,\n        );\n    }\n\n    #[cfg(feature = \"group\")]\n    #[test]\n    fn ff_impls() {\n        assert!(bool::from(Scalar::ZERO.is_even()));\n        assert!(bool::from(Scalar::ONE.is_odd()));\n        assert!(bool::from(Scalar::from(2u64).is_even()));\n        assert!(bool::from(Scalar::DELTA.is_even()));\n\n        assert!(bool::from(Field::invert(&Scalar::ZERO).is_none()));\n        assert_eq!(Field::invert(&X).unwrap(), XINV);\n\n        let x_sq = X.square();\n        // We should get back either the positive or negative root.\n        assert!([X, -X].contains(&x_sq.sqrt().unwrap()));\n\n        assert_eq!(Scalar::from_repr_vartime(X.to_repr()), Some(X));\n        assert_eq!(Scalar::from_repr_vartime([0xff; 32]), None);\n\n        assert_eq!(Scalar::from_repr(X.to_repr()).unwrap(), X);\n        assert!(bool::from(Scalar::from_repr([0xff; 32]).is_none()));\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_read_le_u64_into_should_panic_on_bad_input() {\n        let mut dst = [0_u64; 1];\n        // One byte short\n        read_le_u64_into(&[0xFE, 0xEF, 0x10, 0x01, 0x1F, 0xF1, 0x0F], &mut dst);\n    }\n\n    #[test]\n    fn test_scalar_clamp() {\n        let input = A_SCALAR.bytes;\n        let expected = [\n            0x18, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d, 0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8,\n            0x26, 0x4d, 0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1, 0x58, 0x9e, 0x7b, 0x7f,\n            0x23, 0x76, 0xef, 0x49,\n        ];\n        let actual = clamp_integer(input);\n        assert_eq!(actual, expected);\n\n        let expected = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0x40,\n        ];\n        let actual = clamp_integer([0; 32]);\n        assert_eq!(expected, actual);\n        let expected = [\n            0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0x7f,\n        ];\n        let actual = clamp_integer([0xff; 32]);\n        assert_eq!(actual, expected);\n\n        assert_eq!(\n            LARGEST_CLAMPED_INTEGER,\n            clamp_integer(LARGEST_CLAMPED_INTEGER)\n        );\n    }\n\n    // Check that a * b == a.reduce() * a.reduce() for ANY scalars a,b, even ones that violate\n    // invariant #1, i.e., a,b > 2^255. Old versions of ed25519-dalek did multiplication where a\n    // was reduced and b was clamped and unreduced. This checks that was always well-defined.\n    #[test]\n    fn test_mul_reduction_invariance() {\n        let mut rng = rand::rng();\n\n        for _ in 0..10 {\n            // Also define c that's clamped. We'll make sure that clamping doesn't affect\n            // computation\n            let (a, b, c) = {\n                let mut a_bytes = [0u8; 32];\n                let mut b_bytes = [0u8; 32];\n                let mut c_bytes = [0u8; 32];\n                rng.fill_bytes(&mut a_bytes);\n                rng.fill_bytes(&mut b_bytes);\n                rng.fill_bytes(&mut c_bytes);\n                (\n                    Scalar { bytes: a_bytes },\n                    Scalar { bytes: b_bytes },\n                    Scalar {\n                        bytes: clamp_integer(c_bytes),\n                    },\n                )\n            };\n\n            // Make sure this is the same product no matter how you cut it\n            let reduced_mul_ab = a.reduce() * b.reduce();\n            let reduced_mul_ac = a.reduce() * c.reduce();\n            assert_eq!(a * b, reduced_mul_ab);\n            assert_eq!(a.reduce() * b, reduced_mul_ab);\n            assert_eq!(a * b.reduce(), reduced_mul_ab);\n            assert_eq!(a * c, reduced_mul_ac);\n            assert_eq!(a.reduce() * c, reduced_mul_ac);\n            assert_eq!(a * c.reduce(), reduced_mul_ac);\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/scalar.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63644": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis agora lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Internal macros.\n\n/// Define borrow and non-borrow variants of `Add`.\nmacro_rules! define_add_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty, Output = $out:ty) => {\n        impl<'b> Add<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: &'b $rhs) -> $out {\n                &self + rhs\n            }\n        }\n\n        impl<'a> Add<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                self + &rhs\n            }\n        }\n\n        impl Add<$rhs> for $lhs {\n            type Output = $out;\n            fn add(self, rhs: $rhs) -> $out {\n                &self + &rhs\n            }\n        }\n    };\n}\n\n/// Define non-borrow variants of `AddAssign`.\nmacro_rules! define_add_assign_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl AddAssign<$rhs> for $lhs {\n            fn add_assign(&mut self, rhs: $rhs) {\n                *self += &rhs;\n            }\n        }\n    };\n}\n\n/// Define borrow and non-borrow variants of `Sub`.\nmacro_rules! define_sub_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty, Output = $out:ty) => {\n        impl<'b> Sub<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: &'b $rhs) -> $out {\n                &self - rhs\n            }\n        }\n\n        impl<'a> Sub<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                self - &rhs\n            }\n        }\n\n        impl Sub<$rhs> for $lhs {\n            type Output = $out;\n            fn sub(self, rhs: $rhs) -> $out {\n                &self - &rhs\n            }\n        }\n    };\n}\n\n/// Define non-borrow variants of `SubAssign`.\nmacro_rules! define_sub_assign_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl SubAssign<$rhs> for $lhs {\n            fn sub_assign(&mut self, rhs: $rhs) {\n                *self -= &rhs;\n            }\n        }\n    };\n}\n\n/// Define borrow and non-borrow variants of `Mul`.\nmacro_rules! define_mul_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty, Output = $out:ty) => {\n        impl<'b> Mul<&'b $rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: &'b $rhs) -> $out {\n                &self * rhs\n            }\n        }\n\n        impl<'a> Mul<$rhs> for &'a $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                self * &rhs\n            }\n        }\n\n        impl Mul<$rhs> for $lhs {\n            type Output = $out;\n            fn mul(self, rhs: $rhs) -> $out {\n                &self * &rhs\n            }\n        }\n    };\n}\n\n/// Define non-borrow variants of `MulAssign`.\nmacro_rules! define_mul_assign_variants {\n    (LHS = $lhs:ty, RHS = $rhs:ty) => {\n        impl MulAssign<$rhs> for $lhs {\n            fn mul_assign(&mut self, rhs: $rhs) {\n                *self *= &rhs;\n            }\n        }\n    };\n}\n",
    "filename": "curve25519-dalek/src/macros.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63645": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis agora lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - Isis Agora Lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Field arithmetic modulo \\\\(p = 2\\^{255} - 19\\\\).\n//!\n//! The `curve25519_dalek::field` module provides a type alias\n//! `curve25519_dalek::field::FieldElement` to a field element type\n//! defined in the `backend` module; either `FieldElement51` or\n//! `FieldElement2625`.\n//!\n//! Field operations defined in terms of machine\n//! operations, such as field multiplication or squaring, are defined in\n//! the backend implementation.\n//!\n//! Field operations defined in terms of other field operations, such as\n//! field inversion or square roots, are defined here.\n\n#![allow(unused_qualifications)]\n\nuse cfg_if::cfg_if;\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\nuse crate::backend;\nuse crate::constants;\n\n#[cfg(feature = \"digest\")]\nuse digest::{\n    Digest, FixedOutput, HashMarker,\n    array::{Array, typenum::U64},\n    block_api::BlockSizeUser,\n    typenum::{IsGreater, True},\n};\n\ncfg_if! {\n    if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n        /// A `FieldElement` represents an element of the field\n        /// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n        ///\n        /// The `FieldElement` type is an alias for one of the platform-specific\n        /// implementations.\n        ///\n        /// Using formally-verified field arithmetic from fiat-crypto.\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        pub(crate) type FieldElement = backend::serial::fiat_u32::field::FieldElement2625;\n\n        /// A `FieldElement` represents an element of the field\n        /// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n        ///\n        /// The `FieldElement` type is an alias for one of the platform-specific\n        /// implementations.\n        ///\n        /// Using formally-verified field arithmetic from fiat-crypto.\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        pub(crate) type FieldElement = backend::serial::fiat_u64::field::FieldElement51;\n    } else if #[cfg(curve25519_dalek_bits = \"64\")] {\n        /// A `FieldElement` represents an element of the field\n        /// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n        ///\n        /// The `FieldElement` type is an alias for one of the platform-specific\n        /// implementations.\n        pub(crate) type FieldElement = backend::serial::u64::field::FieldElement51;\n    } else {\n        /// A `FieldElement` represents an element of the field\n        /// \\\\( \\mathbb Z / (2\\^{255} - 19)\\\\).\n        ///\n        /// The `FieldElement` type is an alias for one of the platform-specific\n        /// implementations.\n        pub(crate) type FieldElement = backend::serial::u32::field::FieldElement2625;\n    }\n}\n\nimpl Eq for FieldElement {}\n\nimpl PartialEq for FieldElement {\n    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl ConstantTimeEq for FieldElement {\n    /// Test equality between two `FieldElement`s.  Since the\n    /// internal representation is not canonical, the field elements\n    /// are normalized to wire format before comparison.\n    fn ct_eq(&self, other: &FieldElement) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }\n}\n\nimpl FieldElement {\n    /// Load a `FieldElement` from 64 bytes, by reducing modulo q.\n    #[cfg(feature = \"digest\")]\n    pub(crate) fn from_bytes_wide(bytes: &[u8; 64]) -> Self {\n        let mut fl = [0u8; 32];\n        let mut gl = [0u8; 32];\n        fl.copy_from_slice(&bytes[..32]);\n        gl.copy_from_slice(&bytes[32..]);\n        // Mask off the top bits of both halves, since from_bytes masks them off anyway. We'll add\n        // them back in later.\n        let fl_top_bit = (fl[31] >> 7) as u16;\n        let gl_top_bit = (gl[31] >> 7) as u16;\n        fl[31] &= 0x7f;\n        gl[31] &= 0x7f;\n\n        // Interpret both sides as field elements\n        let mut fe_f = Self::from_bytes(&fl);\n        let fe_g = Self::from_bytes(&gl);\n\n        // The full field elem is now fe_f + 2²⁵⁵ fl_top_bit + 2²⁵⁶ fe_g + 2⁵¹¹ gl_top_bit\n\n        // Add the masked off bits back to fe_f. fl_top_bit, if set, is 2^255 ≡ 19 (mod q).\n        // gl_top_bit, if set, is 2^511 ≡ 722 (mod q)\n        let top_bits_sum = {\n            // This only need to be a u16 because the max value is 741\n            let addend: u16 = fl_top_bit * 19 + gl_top_bit * 722;\n            let mut addend_bytes = [0u8; 32];\n            addend_bytes[..2].copy_from_slice(&addend.to_le_bytes());\n            Self::from_bytes(&addend_bytes)\n        };\n        fe_f += &top_bits_sum;\n\n        // Now add the high half into fe_f. The RHS is multiplied by 2^256 ≡ 38 (mod q)\n        const THIRTY_EIGHT: FieldElement = FieldElement::from_bytes(&[\n            38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        fe_f += &(&THIRTY_EIGHT * &fe_g);\n\n        fe_f\n    }\n\n    /// Determine if this `FieldElement` is negative, in the sense\n    /// used in the ed25519 paper: `x` is negative if the low bit is\n    /// set.\n    ///\n    /// # Return\n    ///\n    /// If negative, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_negative(&self) -> Choice {\n        let bytes = self.to_bytes();\n        (bytes[0] & 1).into()\n    }\n\n    /// Determine if this `FieldElement` is zero.\n    ///\n    /// # Return\n    ///\n    /// If zero, return `Choice(1)`.  Otherwise, return `Choice(0)`.\n    pub(crate) fn is_zero(&self) -> Choice {\n        let zero = [0u8; 32];\n        let bytes = self.to_bytes();\n\n        bytes.ct_eq(&zero)\n    }\n\n    /// Compute (self^(2^250-1), self^11), used as a helper function\n    /// within invert() and pow22523().\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    fn pow22501(&self) -> (FieldElement, FieldElement) {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        let t0  = self.square();           // 1         e_0 = 2^1\n        let t1  = t0.square().square();    // 3         e_1 = 2^3\n        let t2  = self * &t1;              // 3,0       e_2 = 2^3 + 2^0\n        let t3  = &t0 * &t2;               // 3,1,0\n        let t4  = t3.square();             // 4,2,1\n        let t5  = &t2 * &t4;               // 4,3,2,1,0\n        let t6  = t5.pow2k(5);             // 9,8,7,6,5\n        let t7  = &t6 * &t5;               // 9,8,7,6,5,4,3,2,1,0\n        let t8  = t7.pow2k(10);            // 19..10\n        let t9  = &t8 * &t7;               // 19..0\n        let t10 = t9.pow2k(20);            // 39..20\n        let t11 = &t10 * &t9;              // 39..0\n        let t12 = t11.pow2k(10);           // 49..10\n        let t13 = &t12 * &t7;              // 49..0\n        let t14 = t13.pow2k(50);           // 99..50\n        let t15 = &t14 * &t13;             // 99..0\n        let t16 = t15.pow2k(100);          // 199..100\n        let t17 = &t16 * &t15;             // 199..0\n        let t18 = t17.pow2k(50);           // 249..50\n        let t19 = &t18 * &t13;             // 249..0\n\n        (t19, t3)\n    }\n\n    /// Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n    ///\n    /// When an input `FieldElement` is zero, its value is unchanged.\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn batch_invert(inputs: &mut [FieldElement]) {\n        // Montgomery’s Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        let n = inputs.len();\n        let mut scratch = vec![FieldElement::ONE; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = FieldElement::ONE;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        assert!(bool::from(!acc.is_zero()));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n    }\n\n    /// Given a nonzero field element, compute its inverse.\n    ///\n    /// The inverse is computed as self^(p-2), since\n    /// x^(p-2)x = x^(p-1) = 1 (mod p).\n    ///\n    /// This function returns zero on input zero.\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    pub(crate) fn invert(&self) -> FieldElement {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);            // 254..5\n        let t21 = &t20 * &t3;              // 254..5,3,1,0\n\n        t21\n    }\n\n    /// Raise this field element to the power (p-5)/8 = 2^252 -3.\n    #[rustfmt::skip] // keep alignment of explanatory comments\n    #[allow(clippy::let_and_return)]\n    fn pow_p58(&self) -> FieldElement {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();    // 249..0\n        let t20 = t19.pow2k(2);            // 251..2\n        let t21 = self * &t20;             // 251..2,0\n\n        t21\n    }\n\n    /// Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`\n    /// or `sqrt(i*u/v)` in constant time.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(u/v))  ` if `v` is nonzero and `u/v` is square;\n    /// - `(Choice(1), zero)        ` if `u` is zero;\n    /// - `(Choice(0), zero)        ` if `v` is zero and `u` is nonzero;\n    /// - `(Choice(0), +sqrt(i*u/v))` if `u/v` is nonsquare (so `i*u/v` is square).\n    ///\n    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (Choice, FieldElement) {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n        let flipped_sign_sqrt = check.ct_eq(&(-u));\n        let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        r.conditional_negate(r_is_negative);\n\n        let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n\n        (was_nonzero_square, r)\n    }\n\n    /// Attempt to compute `sqrt(1/self)` in constant time.\n    ///\n    /// Convenience wrapper around `sqrt_ratio_i`.\n    ///\n    /// This function always returns the nonnegative square root.\n    ///\n    /// # Return\n    ///\n    /// - `(Choice(1), +sqrt(1/self))  ` if `self` is a nonzero square;\n    /// - `(Choice(0), zero)           ` if `self` is zero;\n    /// - `(Choice(0), +sqrt(i/self))  ` if `self` is a nonzero nonsquare;\n    ///\n    pub(crate) fn invsqrt(&self) -> (Choice, FieldElement) {\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Perform hashing to a [`FieldElement`], per the\n    /// [`hash_to_curve`](https://www.rfc-editor.org/rfc/rfc9380.html#section-5.2) specification.\n    /// Uses the suite `edwards25519_XMD:SHA-512_ELL2_NU_`. The input is the concatenation of the\n    /// elements of `bytes`. Likewise for the domain separator with `domain_sep`. At least one\n    /// element of `domain_sep`, MUST be nonempty, and the concatenation MUST NOT exceed 255 bytes.\n    ///\n    /// # Panics\n    /// Panics if `domain_sep.collect().len() == 0` or `> 255`\n    pub fn hash_to_field<D>(bytes: &[&[u8]], domain_sep: &[&[u8]]) -> Self\n    where\n        D: BlockSizeUser + Default + FixedOutput<OutputSize = U64> + HashMarker,\n        D::BlockSize: IsGreater<D::OutputSize, Output = True>,\n    {\n        let l_i_b_str = 48u16.to_be_bytes();\n        let z_pad = Array::<u8, D::BlockSize>::default();\n\n        let mut hasher = D::new().chain_update(z_pad);\n\n        for slice in bytes {\n            hasher = hasher.chain_update(slice);\n        }\n\n        hasher = hasher.chain_update(l_i_b_str).chain_update([0u8]);\n\n        let mut domain_sep_len = 0usize;\n        for slice in domain_sep {\n            hasher = hasher.chain_update(slice);\n            domain_sep_len += slice.len();\n        }\n\n        let domain_sep_len = u8::try_from(domain_sep_len)\n            .expect(\"Unexpected overflow from domain separator's size.\");\n        assert_ne!(\n            domain_sep_len, 0,\n            \"Domain separator MUST have nonzero length.\"\n        );\n\n        let b_0 = hasher.chain_update([domain_sep_len]).finalize();\n\n        let mut hasher = D::new().chain_update(b_0.as_slice()).chain_update([1u8]);\n\n        for slice in domain_sep {\n            hasher = hasher.chain_update(slice)\n        }\n\n        let b_1 = hasher.chain_update([domain_sep_len]).finalize();\n\n        // §5.2, we only generate count * m * L = 1 * 1 * (256 + 128)/8 = 48 bytes\n        let mut bytes_wide = [0u8; 64];\n        bytes_wide[..48].copy_from_slice(&b_1.as_slice()[..48]);\n        bytes_wide[..48].reverse();\n\n        FieldElement::from_bytes_wide(&bytes_wide)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::field::*;\n\n    /// Random element a of GF(2^255-19), from Sage\n    /// a = 1070314506888354081329385823235218444233221\\\n    ///     2228051251926706380353716438957572\n    static A_BYTES: [u8; 32] = [\n        0x04, 0xfe, 0xdf, 0x98, 0xa7, 0xfa, 0x0a, 0x68, 0x84, 0x92, 0xbd, 0x59, 0x08, 0x07, 0xa7,\n        0x03, 0x9e, 0xd1, 0xf6, 0xf2, 0xe1, 0xd9, 0xe2, 0xa4, 0xa4, 0x51, 0x47, 0x36, 0xf3, 0xc3,\n        0xa9, 0x17,\n    ];\n\n    /// Byte representation of a**2\n    static ASQ_BYTES: [u8; 32] = [\n        0x75, 0x97, 0x24, 0x9e, 0xe6, 0x06, 0xfe, 0xab, 0x24, 0x04, 0x56, 0x68, 0x07, 0x91, 0x2d,\n        0x5d, 0x0b, 0x0f, 0x3f, 0x1c, 0xb2, 0x6e, 0xf2, 0xe2, 0x63, 0x9c, 0x12, 0xba, 0x73, 0x0b,\n        0xe3, 0x62,\n    ];\n\n    /// Byte representation of 1/a\n    static AINV_BYTES: [u8; 32] = [\n        0x96, 0x1b, 0xcd, 0x8d, 0x4d, 0x5e, 0xa2, 0x3a, 0xe9, 0x36, 0x37, 0x93, 0xdb, 0x7b, 0x4d,\n        0x70, 0xb8, 0x0d, 0xc0, 0x55, 0xd0, 0x4c, 0x1d, 0x7b, 0x90, 0x71, 0xd8, 0xe9, 0xb6, 0x18,\n        0xe6, 0x30,\n    ];\n\n    /// Byte representation of a^((p-5)/8)\n    static AP58_BYTES: [u8; 32] = [\n        0x6a, 0x4f, 0x24, 0x89, 0x1f, 0x57, 0x60, 0x36, 0xd0, 0xbe, 0x12, 0x3c, 0x8f, 0xf5, 0xb1,\n        0x59, 0xe0, 0xf0, 0xb8, 0x1b, 0x20, 0xd2, 0xb5, 0x1f, 0x15, 0x21, 0xf9, 0xe3, 0xe1, 0x61,\n        0x21, 0x55,\n    ];\n\n    #[test]\n    fn a_mul_a_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(asq, &a * &a);\n    }\n\n    #[test]\n    fn a_square_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(asq, a.square());\n    }\n\n    #[test]\n    fn a_square2_vs_a_squared_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        assert_eq!(a.square2(), &asq + &asq);\n    }\n\n    #[test]\n    fn a_invert_vs_inverse_of_a_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        let should_be_inverse = a.invert();\n        assert_eq!(ainv, should_be_inverse);\n        assert_eq!(FieldElement::ONE, &a * &should_be_inverse);\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn batch_invert_a_matches_nonbatched() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ap58 = FieldElement::from_bytes(&AP58_BYTES);\n        let asq = FieldElement::from_bytes(&ASQ_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        let a0 = &a - &a;\n        let a2 = &a + &a;\n        let a_list = vec![a, ap58, asq, ainv, a0, a2];\n        let mut ainv_list = a_list.clone();\n        FieldElement::batch_invert(&mut ainv_list[..]);\n        for i in 0..6 {\n            assert_eq!(a_list[i].invert(), ainv_list[i]);\n        }\n    }\n\n    #[test]\n    fn sqrt_ratio_behavior() {\n        let zero = FieldElement::ZERO;\n        let one = FieldElement::ONE;\n        let i = constants::SQRT_M1;\n        let two = &one + &one; // 2 is nonsquare mod p.\n        let four = &two + &two; // 4 is square mod p.\n\n        // 0/0 should return (1, 0) since u is 0\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&zero, &zero);\n        assert!(bool::from(choice));\n        assert_eq!(sqrt, zero);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 1/0 should return (0, 0) since v is 0, u is nonzero\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&one, &zero);\n        assert!(bool::from(!choice));\n        assert_eq!(sqrt, zero);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 2/1 is nonsquare, so we expect (0, sqrt(i*2))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&two, &one);\n        assert!(bool::from(!choice));\n        assert_eq!(sqrt.square(), &two * &i);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 4/1 is square, so we expect (1, sqrt(4))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&four, &one);\n        assert!(bool::from(choice));\n        assert_eq!(sqrt.square(), four);\n        assert!(bool::from(!sqrt.is_negative()));\n\n        // 1/4 is square, so we expect (1, 1/sqrt(4))\n        let (choice, sqrt) = FieldElement::sqrt_ratio_i(&one, &four);\n        assert!(bool::from(choice));\n        assert_eq!(&sqrt.square() * &four, one);\n        assert!(bool::from(!sqrt.is_negative()));\n    }\n\n    #[test]\n    fn a_p58_vs_ap58_constant() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ap58 = FieldElement::from_bytes(&AP58_BYTES);\n        assert_eq!(ap58, a.pow_p58());\n    }\n\n    #[test]\n    fn equality() {\n        let a = FieldElement::from_bytes(&A_BYTES);\n        let ainv = FieldElement::from_bytes(&AINV_BYTES);\n        assert!(a == a);\n        assert!(a != ainv);\n    }\n\n    /// Notice that the last element has the high bit set, which\n    /// should be ignored\n    static B_BYTES: [u8; 32] = [\n        113, 191, 169, 143, 91, 234, 121, 15, 241, 131, 217, 36, 230, 101, 92, 234, 8, 208, 170,\n        251, 97, 127, 70, 210, 58, 23, 166, 87, 240, 169, 184, 178,\n    ];\n\n    #[test]\n    fn from_bytes_highbit_is_ignored() {\n        let mut cleared_bytes = B_BYTES;\n        cleared_bytes[31] &= 127u8;\n        let with_highbit_set = FieldElement::from_bytes(&B_BYTES);\n        let without_highbit_set = FieldElement::from_bytes(&cleared_bytes);\n        assert_eq!(without_highbit_set, with_highbit_set);\n    }\n\n    #[test]\n    fn conditional_negate() {\n        let one = FieldElement::ONE;\n        let minus_one = FieldElement::MINUS_ONE;\n        let mut x = one;\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(0));\n        assert_eq!(x, minus_one);\n        x.conditional_negate(Choice::from(1));\n        assert_eq!(x, one);\n    }\n\n    #[test]\n    fn encoding_is_canonical() {\n        // Encode 1 wrongly as 1 + (2^255 - 19) = 2^255 - 18\n        let one_encoded_wrongly_bytes: [u8; 32] = [\n            0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff, 0xff, 0x7f,\n        ];\n        // Decode to a field element\n        let one = FieldElement::from_bytes(&one_encoded_wrongly_bytes);\n        // .. then check that the encoding is correct\n        let one_bytes = one.to_bytes();\n        assert_eq!(one_bytes[0], 1);\n        for byte in &one_bytes[1..] {\n            assert_eq!(*byte, 0);\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn batch_invert_empty() {\n        FieldElement::batch_invert(&mut []);\n    }\n\n    // The following two consts were generated with the following sage script:\n    //\n    // import random\n    //\n    // F = GF(2**255 - 19)\n    // # Use a seed to make sure we produce the same test vectors every time\n    // random.seed(\"Ozamataz Buckshank\")\n    //\n    // # Generates test vectors, each of the form (input_bytes, reduced_field_elem_bytes),\n    // # where input_bytes is length input_bytes_len\n    // def gen_example(input_bytes_len):\n    //     # Generate random bytes\n    //     input_bytes = [random.randint(0, 255) for _ in range(input_bytes_len)]\n    //\n    //     # Now convert to a field element and get the reduced byte representation\n    //     elem = F(int.from_bytes(input_bytes, byteorder='little'))\n    //     reduced_bytes = list(int(elem).to_bytes(32, byteorder='little'))\n    //\n    //     # Format input and output as hex strings\n    //     input_bytes_hex = ''.join(f'{byte:02x}' for byte in input_bytes)\n    //     reduced_bytes_hex = ''.join(f'{byte:02x}' for byte in reduced_bytes)\n    //     return f\"(\\\"{input_bytes_hex}\\\", \\\"{reduced_bytes_hex}\\\")\"\n    //\n    // print(\"SET 1: Input bytes are length 64\")\n    // for _ in range(5):\n    //     print(gen_example(64))\n    //\n    // print(\"SET 2: Input bytes are length 48\")\n    // for _ in range(5):\n    //     print(gen_example(48))\n\n    /// Test vectors for FieldElement::from_bytes_wide. Elements are of the form (len-64 bytestring,\n    /// reduced field element)\n    #[cfg(feature = \"digest\")]\n    const FROM_BYTES_WIDE_KAT_BIG: &[(&str, &str)] = &[\n        (\n            \"77b663085cac0e916f40dbeea5116f201816406e68ccf01b32a97162ae1d5bf95d0d01c2c72fbeeb27a63\\\n            5b85b715d5ce6f74118a60a7aec53c798ad648a482f\",\n            \"62b38bd402c4498f5cead14643e54dd649e20a0810610e36a73f1f27a0a81f7e\",\n        ),\n        (\n            \"d437c75ec79886650243a79c62933bb307eb12ff16d05db4a6a8a877f4a91abb6eeb64d2e20519c021799\\\n            3a1dc5639283a06639985a2c892208171503335afb5\",\n            \"3d2ec29972783de9043e8b982278beaba9d7c5c3ebef257e7cd38168928f1c33\",\n        ),\n        (\n            \"6daa9e1abe6c604fb6e841c04bf90a6ef88aef6b1eab17dd44f7207ef472cd2d54bac849f703e64f36e56\\\n            77e7e86b82be7d26aa220daf1f208bb36dcc1a12338\",\n            \"28546a0e7303852bc6eead8312f06eeb48d9ca87f60bfeec98ba402ebb751703\",\n        ),\n        (\n            \"c3920e326dbf806a50105be78263c1dc9390fb4741587b250cd758c2bfa3ed70faedbbc5f9b1d024e00fe\\\n            7d7daf796866853f42e72d638e6533c5eb5b7caf3c6\",\n            \"40eaf38b802a7be1956ba7f3fe2d2ad717f23f40342deb5180cb55ae04bb1d79\",\n        ),\n        (\n            \"23f143c72ead6c0f336b4e746a06921f0eb180002e8ce916d196de16216788617c6aeb90a074a85196f03\\\n            81375011248927c1215e9ec65b382a6ec556fb3f504\",\n            \"b1bf354a04fd6d2e8321c24ecb3d3ed2c42e3f21c7b60ab8374effd7a709011e\",\n        ),\n    ];\n\n    /// Test vectors for FieldElement::from_bytes_wide. Elements are of the form (len-48 bytestring,\n    /// reduced field element)\n    #[cfg(feature = \"digest\")]\n    const FROM_BYTES_WIDE_KAT_MEDIUM: &[(&str, &str)] = &[\n        (\n            \"82e9cbe4928e3d0bbf1f91824a91acfb30d929f7a2fa5cbcc967c63ea0f3357c29c19f1bc9dcad69d85c1\\\n            c6265970685\",\n            \"989582fe6c540cbbdee7c612570aa7ba44d929f7a2fa5cbcc967c63ea0f3357c\",\n        ),\n        (\n            \"5480494df4fb3a3b19da17e1c8b9192ccb09ec76720321977079300c42c17b9e95b01eb37ffe7048fcd1c\\\n            9e6094da6c4\",\n            \"85b6d7e3e8c200fc8b050d234129c95ce809ec76720321977079300c42c17b1e\",\n        ),\n        (\n            \"93ec8a480dde098f74bcd341ef4f248f6440cc6e631d7000784f66975a4fd628438bb1350ba4c1421fec3\\\n            670decced06\",\n            \"8598e540b737c87718c9fae9f3b870966540cc6e631d7000784f66975a4fd628\",\n        ),\n        (\n            \"fd0154ff9a5c4c9ee4e8183c23db97018e0e6201a812f6d4faedda50652d51f65c110b9a1a100a3fc3ff1\\\n            c4ea3cf22e4\",\n            \"b895f8dc8dc0caf9dfdf66d460adc2deaf0e6201a812f6d4faedda50652d5176\",\n        ),\n        (\n            \"0e829dc955e0a1e0dbda9849cb2022b295275782348bd6308b3d0c5836f3ca0130911a17fd54054c3a0f8\\\n            b2486f8ce85\",\n            \"2e0f8f37e77d6c29831d3db6b404db8ea9275782348bd6308b3d0c5836f3ca01\",\n        ),\n    ];\n\n    #[cfg(feature = \"digest\")]\n    #[test]\n    fn from_bytes_wide() {\n        // Do the 64-byte input ones first\n        for (input_bytes, expected_reduced) in FROM_BYTES_WIDE_KAT_BIG {\n            let reduce_fe = FieldElement::from_bytes_wide(\n                &hex::decode(input_bytes)\n                    .unwrap()\n                    .as_slice()\n                    .try_into()\n                    .unwrap(),\n            );\n            assert_eq!(\n                &reduce_fe.to_bytes(),\n                hex::decode(expected_reduced).unwrap().as_slice()\n            );\n        }\n\n        // Now do the 48-byte inputs\n        for (input_bytes, expected_reduced) in FROM_BYTES_WIDE_KAT_MEDIUM {\n            let mut padded_input_bytes = [0u8; 64];\n            padded_input_bytes[..48].copy_from_slice(&hex::decode(input_bytes).unwrap());\n            let reduce_fe = FieldElement::from_bytes_wide(&padded_input_bytes);\n            assert_eq!(\n                &reduce_fe.to_bytes(),\n                hex::decode(expected_reduced).unwrap().as_slice()\n            );\n        }\n    }\n\n    /// Hash to field test vectors from\n    /// https://www.rfc-editor.org/rfc/rfc9380.html#name-edwards25519_xmdsha-512_ell2\n    /// These are of the form (input_msg, output_field_elem)\n    #[cfg(feature = \"digest\")]\n    const RFC_HASH_TO_FIELD_KAT: &[(&[u8], &str)] = &[\n        (\n            b\"\",\n            \"7f3e7fb9428103ad7f52db32f9df32505d7b427d894c5093f7a0f0374a30641d\"\n        ),\n        (\n            b\"abc\",\n            \"09cfa30ad79bd59456594a0f5d3a76f6b71c6787b04de98be5cd201a556e253b\"\n        ),\n        (\n            b\"abcdef0123456789\",\n            \"475ccff99225ef90d78cc9338e9f6a6bb7b17607c0c4428937de75d33edba941\",\n        ),\n        (\n            b\"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\\\n            qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\",\n            \"049a1c8bd51bcb2aec339f387d1ff51428b88d0763a91bcdf6929814ac95d03d\"\n        ),\n        (\n            b\"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\n            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"3cb0178a8137cefa5b79a3a57c858d7eeeaa787b2781be4a362a2f0750d24fa0\"\n        )\n    ];\n\n    #[test]\n    #[cfg(feature = \"digest\")]\n    fn hash_to_field() {\n        use sha2::Sha512;\n        let dst = \"QUUX-V01-CS02-with-edwards25519_XMD:SHA-512_ELL2_NU_\";\n\n        for (msg, expected_hash_hex) in RFC_HASH_TO_FIELD_KAT {\n            let fe = FieldElement::hash_to_field::<Sha512>(&[msg], &[dst.as_bytes()]);\n            let expected_fe = {\n                let mut expected_hash = hex::decode(expected_hash_hex).unwrap();\n                expected_hash.reverse();\n                FieldElement::from_bytes(&expected_hash.try_into().unwrap())\n            };\n\n            assert_eq!(fe, expected_fe);\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/src/field.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63646": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2020 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n// We allow non snake_case names because coordinates in projective space are\n// traditionally denoted by the capitalisation of their respective\n// counterparts in affine space.  Yeah, you heard me, rustc, I'm gonna have my\n// affine and projective cakes and eat both of them too.\n#![allow(non_snake_case)]\n\n//! An implementation of [Ristretto][ristretto_main], which provides a\n//! prime-order group.\n//!\n//! # The Ristretto Group\n//!\n//! Ristretto is a modification of Mike Hamburg's Decaf scheme to work\n//! with cofactor-\\\\(8\\\\) curves, such as Curve25519.\n//!\n//! The introduction of the Decaf paper, [_Decaf:\n//! Eliminating cofactors through point\n//! compression_](https://eprint.iacr.org/2015/673.pdf), notes that while\n//! most cryptographic systems require a group of prime order, most\n//! concrete implementations using elliptic curve groups fall short –\n//! they either provide a group of prime order, but with incomplete or\n//! variable-time addition formulae (for instance, most Weierstrass\n//! models), or else they provide a fast and safe implementation of a\n//! group whose order is not quite a prime \\\\(q\\\\), but \\\\(hq\\\\) for a\n//! small cofactor \\\\(h\\\\) (for instance, Edwards curves, which have\n//! cofactor at least \\\\(4\\\\)).\n//!\n//! This abstraction mismatch is commonly “handled” by pushing the\n//! complexity upwards, adding ad-hoc protocol modifications.  But\n//! these modifications require careful analysis and are a recurring\n//! source of [vulnerabilities][cryptonote] and [design\n//! complications][ed25519_hkd].\n//!\n//! Instead, Decaf (and Ristretto) use a quotient group to implement a\n//! prime-order group using a non-prime-order curve.  This provides\n//! the correct abstraction for cryptographic systems, while retaining\n//! the speed and safety benefits of an Edwards curve.\n//!\n//! Decaf is named “after the procedure which divides the effect of\n//! coffee by \\\\(4\\\\)”.  However, Curve25519 has a cofactor of\n//! \\\\(8\\\\).  To eliminate its cofactor, Ristretto restricts further;\n//! this [additional restriction][ristretto_coffee] gives the\n//! _Ristretto_ encoding.\n//!\n//! More details on why Ristretto is necessary can be found in the\n//! [Why Ristretto?][why_ristretto] section of the Ristretto website.\n//!\n//! Ristretto\n//! points are provided in `curve25519-dalek` by the `RistrettoPoint`\n//! struct.\n//!\n//! ## Encoding and Decoding\n//!\n//! Encoding is done by converting to and from a `CompressedRistretto`\n//! struct, which is a typed wrapper around `[u8; 32]`.\n//!\n//! The encoding is not batchable, but it is possible to\n//! double-and-encode in a batch using\n//! `RistrettoPoint::double_and_compress_batch`.\n//!\n//! ## Equality Testing\n//!\n//! Testing equality of points on an Edwards curve in projective\n//! coordinates requires an expensive inversion.  By contrast, equality\n//! checking in the Ristretto group can be done in projective\n//! coordinates without requiring an inversion, so it is much faster.\n//!\n//! The `RistrettoPoint` struct implements the\n//! [`subtle::ConstantTimeEq`] trait for constant-time equality\n//! checking, and also uses this to ensure `Eq` equality checking\n//! runs in constant time.\n//!\n//! ## Scalars\n//!\n//! Scalars are represented by the `Scalar` struct.  Each scalar has a\n//! canonical representative mod the group order.  To attempt to load\n//! a supposedly-canonical scalar, use\n//! `Scalar::from_canonical_bytes()`. To check whether a\n//! representative is canonical, use `Scalar::is_canonical()`.\n//!\n//! ## Scalar Multiplication\n//!\n//! Scalar multiplication on Ristretto points is provided by:\n//!\n//! * the `*` operator between a `Scalar` and a `RistrettoPoint`, which\n//!   performs constant-time variable-base scalar multiplication;\n//!\n//! * the `*` operator between a `Scalar` and a\n//!   `RistrettoBasepointTable`, which performs constant-time fixed-base\n//!   scalar multiplication;\n//!\n//! * an implementation of the\n//!   [`MultiscalarMul`](../traits/trait.MultiscalarMul.html) trait for\n//!   constant-time variable-base multiscalar multiplication;\n//!\n//! * an implementation of the\n//!   [`VartimeMultiscalarMul`](../traits/trait.VartimeMultiscalarMul.html)\n//!   trait for variable-time variable-base multiscalar multiplication;\n//!\n//! ## Random Points and Hashing to Ristretto\n//!\n//! The Ristretto group comes equipped with an Elligator map.  This is\n//! used to implement\n//!\n//! * `RistrettoPoint::random()`, which generates random points from an\n//!   RNG - enabled by `rand_core` feature;\n//!\n//! * `RistrettoPoint::from_hash()` and\n//!   `RistrettoPoint::hash_from_bytes()`, which perform hashing to the\n//!   group.\n//!\n//! The Elligator map itself is not currently exposed.\n//!\n//! ## Implementation\n//!\n//! The Decaf suggestion is to use a quotient group, such as \\\\(\\mathcal\n//! E / \\mathcal E\\[4\\]\\\\) or \\\\(2 \\mathcal E / \\mathcal E\\[2\\] \\\\), to\n//! implement a prime-order group using a non-prime-order curve.\n//!\n//! This requires only changing\n//!\n//! 1. the function for equality checking (so that two representatives\n//!    of the same coset are considered equal);\n//! 2. the function for encoding (so that two representatives of the\n//!    same coset are encoded as identical bitstrings);\n//! 3. the function for decoding (so that only the canonical encoding of\n//!    a coset is accepted).\n//!\n//! Internally, each coset is represented by a curve point; two points\n//! \\\\( P, Q \\\\) may represent the same coset in the same way that two\n//! points with different \\\\(X,Y,Z\\\\) coordinates may represent the\n//! same point.  The group operations are carried out with no overhead\n//! using Edwards formulas.\n//!\n//! Notes on the details of the encoding can be found in the\n//! [Details][ristretto_notes] section of the Ristretto website.\n//!\n//! [cryptonote]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000898.html\n//! [ed25519_hkd]:\n//! https://moderncrypto.org/mail-archive/curves/2017/000858.html\n//! [ristretto_coffee]:\n//! https://en.wikipedia.org/wiki/Ristretto\n//! [ristretto_notes]:\n//! https://ristretto.group/details/index.html\n//! [why_ristretto]:\n//! https://ristretto.group/why_ristretto.html\n//! [ristretto_main]:\n//! https://ristretto.group/\n\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\n\nuse core::array::TryFromSliceError;\nuse core::borrow::Borrow;\nuse core::fmt::Debug;\nuse core::iter::Sum;\nuse core::ops::{Add, Neg, Sub};\nuse core::ops::{AddAssign, SubAssign};\nuse core::ops::{Mul, MulAssign};\n\n#[cfg(feature = \"digest\")]\nuse digest::Digest;\n#[cfg(feature = \"digest\")]\nuse digest::array::typenum::U64;\n\nuse crate::constants;\nuse crate::field::FieldElement;\n\n#[cfg(feature = \"group\")]\nuse {\n    group::{GroupEncoding, cofactor::CofactorGroup, prime::PrimeGroup},\n    rand_core::TryRngCore,\n    subtle::CtOption,\n};\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse {\n    core::convert::Infallible,\n    rand_core::{CryptoRng, TryCryptoRng},\n};\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::edwards::EdwardsBasepointTable;\nuse crate::edwards::EdwardsPoint;\n\nuse crate::scalar::Scalar;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::traits::BasepointTable;\nuse crate::traits::Identity;\n#[cfg(feature = \"alloc\")]\nuse crate::traits::{MultiscalarMul, VartimeMultiscalarMul, VartimePrecomputedMultiscalarMul};\n\n// ------------------------------------------------------------------------\n// Compressed points\n// ------------------------------------------------------------------------\n\n/// A Ristretto point, in compressed wire format.\n///\n/// The Ristretto encoding is canonical, so two points are equal if and\n/// only if their encodings are equal.\n#[allow(clippy::derived_hash_with_manual_eq)]\n#[derive(Copy, Clone, Hash)]\npub struct CompressedRistretto(pub [u8; 32]);\n\nimpl Eq for CompressedRistretto {}\nimpl PartialEq for CompressedRistretto {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl ConstantTimeEq for CompressedRistretto {\n    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }\n}\n\nimpl CompressedRistretto {\n    /// Copy the bytes of this `CompressedRistretto`.\n    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }\n\n    /// View this `CompressedRistretto` as an array of bytes.\n    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }\n\n    /// Construct a `CompressedRistretto` from a slice of bytes.\n    ///\n    /// # Errors\n    ///\n    /// Returns [`TryFromSliceError`] if the input `bytes` slice does not have\n    /// a length of 32.\n    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }\n\n    /// Attempt to decompress to an `RistrettoPoint`.\n    ///\n    /// # Return\n    ///\n    /// - `Some(RistrettoPoint)` if `self` was the canonical encoding of a point;\n    ///\n    /// - `None` if `self` was not the canonical encoding of a point.\n    pub fn decompress(&self) -> Option<RistrettoPoint> {\n        let (s_encoding_is_canonical, s_is_negative, s) = decompress::step_1(self);\n\n        if (!s_encoding_is_canonical | s_is_negative).into() {\n            return None;\n        }\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        if (!ok | t_is_negative | y_is_zero).into() {\n            None\n        } else {\n            Some(res)\n        }\n    }\n}\n\nmod decompress {\n    use super::*;\n\n    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.to_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }\n\n    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as²\n        let u2 = &one + &ss; //  1 - as²    where a=-1\n        let u2_sqr = u2.square(); // (1 - as²)²\n\n        // v == ad(1+as²)² - (1-as²)²            where d=-121665/121666\n        let v = &(&(-&constants::EDWARDS_D) * &u1.square()) - &u2_sqr;\n\n        let (ok, I) = (&v * &u2_sqr).invsqrt(); // 1/sqrt(v*u_2²)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dy = &I * &(&Dx * &v); // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s²/(ad(1+as²)² - (1-as²)²))\n        let mut x = &(&s + &s) * &Dx;\n        let x_neg = x.is_negative();\n        x.conditional_negate(x_neg);\n\n        // y == (1-as²)/(1+as²)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as²) sqrt(4s²/(ad(1+as²)² - (1-as²)²)))/(1-as²)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }\n}\n\nimpl Identity for CompressedRistretto {\n    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }\n}\n\nimpl Default for CompressedRistretto {\n    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }\n}\n\nimpl TryFrom<&[u8]> for CompressedRistretto {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Serde support\n// ------------------------------------------------------------------------\n// Serializes to and from `RistrettoPoint` directly, doing compression\n// and decompression internally.  This means that users can create\n// structs containing `RistrettoPoint`s and use Serde's derived\n// serializers to serialize those structures.\n\n#[cfg(feature = \"serde\")]\nuse serde::de::Visitor;\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for RistrettoPoint {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.compress().as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for CompressedRistretto {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeTuple;\n        let mut tup = serializer.serialize_tuple(32)?;\n        for byte in self.as_bytes().iter() {\n            tup.serialize_element(byte)?;\n        }\n        tup.end()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for RistrettoPoint {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct RistrettoPointVisitor;\n\n        impl<'de> Visitor<'de> for RistrettoPointVisitor {\n            type Value = RistrettoPoint;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"a valid point in Ristretto format\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<RistrettoPoint, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                CompressedRistretto(bytes)\n                    .decompress()\n                    .ok_or_else(|| serde::de::Error::custom(\"decompression failed\"))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, RistrettoPointVisitor)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'de> Deserialize<'de> for CompressedRistretto {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct CompressedRistrettoVisitor;\n\n        impl<'de> Visitor<'de> for CompressedRistrettoVisitor {\n            type Value = CompressedRistretto;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                formatter.write_str(\"32 bytes of data\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<CompressedRistretto, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n                Ok(CompressedRistretto(bytes))\n            }\n        }\n\n        deserializer.deserialize_tuple(32, CompressedRistrettoVisitor)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Internal point representations\n// ------------------------------------------------------------------------\n\n/// A `RistrettoPoint` represents a point in the Ristretto group for\n/// Curve25519.  Ristretto, a variant of Decaf, constructs a\n/// prime-order group as a quotient group of a subgroup of (the\n/// Edwards form of) Curve25519.\n///\n/// Internally, a `RistrettoPoint` is implemented as a wrapper type\n/// around `EdwardsPoint`, with custom equality, compression, and\n/// decompression routines to account for the quotient.  This means that\n/// operations on `RistrettoPoint`s are exactly as fast as operations on\n/// `EdwardsPoint`s.\n///\n#[derive(Copy, Clone)]\npub struct RistrettoPoint(pub(crate) EdwardsPoint);\n\nimpl RistrettoPoint {\n    /// Compress this point using the Ristretto encoding.\n    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let u1 = &(Z + &Y) * &(Z - &Y);\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let (_, invsqrt) = (&u1 * &u2.square()).invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let z_inv = &i1 * &(&i2 * T);\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let rotate = (T * &z_inv).is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        Y.conditional_negate((&X * &z_inv).is_negative());\n\n        let mut s = &den_inv * &(Z - &Y);\n        let s_is_negative = s.is_negative();\n        s.conditional_negate(s_is_negative);\n\n        CompressedRistretto(s.to_bytes())\n    }\n\n    /// Double-and-compress a batch of points.  The Ristretto encoding\n    /// is not batchable, since it requires an inverse square root.\n    ///\n    /// However, given input points \\\\( P\\_1, \\ldots, P\\_n, \\\\)\n    /// it is possible to compute the encodings of their doubles \\\\(\n    /// \\mathrm{enc}( \\[2\\]P\\_1), \\ldots, \\mathrm{enc}( \\[2\\]P\\_n ) \\\\)\n    /// in a batch.\n    ///\n    #[cfg_attr(feature = \"rand_core\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use rand_core::{OsRng, TryRngCore};\n    ///\n    /// # // Need fn main() here in comment so the doctest compiles\n    /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    /// # fn main() {\n    /// let mut rng = OsRng.unwrap_err();\n    ///\n    /// let points: Vec<RistrettoPoint> =\n    ///     (0..32).map(|_| RistrettoPoint::random(&mut rng)).collect();\n    ///\n    /// let compressed = RistrettoPoint::double_and_compress_batch(&points);\n    ///\n    /// for (P, P2_compressed) in points.iter().zip(compressed.iter()) {\n    ///     assert_eq!(*P2_compressed, (P + P).compress());\n    /// }\n    /// # }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.to_bytes())\n            })\n            .collect()\n    }\n\n    /// Return the coset self + E\\[4\\], for debugging.\n    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }\n\n    /// Computes the Ristretto Elligator map. This is the\n    /// [`MAP`](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4)\n    /// function defined in the Ristretto spec.\n    ///\n    /// # Note\n    ///\n    /// This method is not public because it's just used for hashing\n    /// to a point -- proper elligator support is deferred for now.\n    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }\n\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `RistrettoPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `CryptoRng` interface.\n    ///\n    /// # Returns\n    ///\n    /// A random element of the Ristretto group.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self::try_from_rng(rng)\n            .map_err(|_: Infallible| {})\n            .expect(\"[bug] unfallible rng failed\")\n    }\n\n    #[cfg(any(test, feature = \"rand_core\"))]\n    /// Return a `RistrettoPoint` chosen uniformly at random using a user-provided RNG.\n    ///\n    /// # Inputs\n    ///\n    /// * `rng`: any RNG which implements `TryCryptoRng` interface.\n    ///\n    /// # Returns\n    ///\n    /// A random element of the Ristretto group.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    pub fn try_from_rng<R: TryCryptoRng + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut uniform_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n\n        Ok(RistrettoPoint::from_uniform_bytes(&uniform_bytes))\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Hash a slice of bytes into a `RistrettoPoint`.\n    ///\n    /// Takes a type parameter `D`, which is any `Digest` producing 64\n    /// bytes of output.\n    ///\n    /// Convenience wrapper around `from_hash`.\n    ///\n    /// # Implementation\n    ///\n    /// Uses the Ristretto-flavoured Elligator 2 map, so that the\n    /// discrete log of the output point with respect to any other\n    /// point should be unknown.  The map is applied twice and the\n    /// results are added, to ensure a uniform distribution.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"digest\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"digest\"), doc = \"```ignore\")]\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use sha2::Sha512;\n    ///\n    /// # // Need fn main() here in comment so the doctest compiles\n    /// # // See https://doc.rust-lang.org/book/documentation.html#documentation-as-tests\n    /// # fn main() {\n    /// let msg = \"To really appreciate architecture, you may even need to commit a murder\";\n    /// let P = RistrettoPoint::hash_from_bytes::<Sha512>(msg.as_bytes());\n    /// # }\n    /// ```\n    ///\n    pub fn hash_from_bytes<D>(input: &[u8]) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        let mut hash = D::default();\n        hash.update(input);\n        RistrettoPoint::from_hash(hash)\n    }\n\n    #[cfg(feature = \"digest\")]\n    /// Construct a `RistrettoPoint` from an existing `Digest` instance.\n    ///\n    /// Use this instead of `hash_from_bytes` if it is more convenient\n    /// to stream data into the `Digest` than to pass a single byte\n    /// slice.\n    pub fn from_hash<D>(hash: D) -> RistrettoPoint\n    where\n        D: Digest<OutputSize = U64> + Default,\n    {\n        // dealing with generic arrays is clumsy, until const generics land\n        let output = hash.finalize();\n        let mut output_bytes = [0u8; 64];\n        output_bytes.copy_from_slice(output.as_slice());\n\n        RistrettoPoint::from_uniform_bytes(&output_bytes)\n    }\n\n    /// Construct a `RistrettoPoint` from 64 bytes of data.\n    ///\n    /// If the input bytes are uniformly distributed, the resulting\n    /// point will be uniformly distributed over the group, and its\n    /// discrete log with respect to other points should be unknown.\n    ///\n    /// # Implementation\n    ///\n    /// This function splits the input array into two 32-byte halves,\n    /// takes the low 255 bits of each half mod p, applies the\n    /// Ristretto-flavored Elligator map to each, and adds the results.\n    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }\n}\n\nimpl Identity for RistrettoPoint {\n    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }\n}\n\nimpl Default for RistrettoPoint {\n    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }\n}\n\n// ------------------------------------------------------------------------\n// Equality\n// ------------------------------------------------------------------------\n\nimpl PartialEq for RistrettoPoint {\n    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl ConstantTimeEq for RistrettoPoint {\n    /// Test equality between two `RistrettoPoint`s.\n    ///\n    /// # Returns\n    ///\n    /// * `Choice(1)` if the two `RistrettoPoint`s are equal;\n    /// * `Choice(0)` otherwise.\n    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }\n}\n\nimpl Eq for RistrettoPoint {}\n\n// ------------------------------------------------------------------------\n// Arithmetic\n// ------------------------------------------------------------------------\n\nimpl<'a> Add<&'a RistrettoPoint> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn add(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }\n}\n\ndefine_add_variants!(\n    LHS = RistrettoPoint,\n    RHS = RistrettoPoint,\n    Output = RistrettoPoint\n);\n\nimpl AddAssign<&RistrettoPoint> for RistrettoPoint {\n    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }\n}\n\ndefine_add_assign_variants!(LHS = RistrettoPoint, RHS = RistrettoPoint);\n\nimpl<'a> Sub<&'a RistrettoPoint> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn sub(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }\n}\n\ndefine_sub_variants!(\n    LHS = RistrettoPoint,\n    RHS = RistrettoPoint,\n    Output = RistrettoPoint\n);\n\nimpl SubAssign<&RistrettoPoint> for RistrettoPoint {\n    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }\n}\n\ndefine_sub_assign_variants!(LHS = RistrettoPoint, RHS = RistrettoPoint);\n\nimpl<T> Sum<T> for RistrettoPoint\nwhere\n    T: Borrow<RistrettoPoint>,\n{\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }\n}\n\nimpl Neg for &RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }\n}\n\nimpl Neg for RistrettoPoint {\n    type Output = RistrettoPoint;\n\n    fn neg(self) -> RistrettoPoint {\n        -&self\n    }\n}\n\nimpl<'a> MulAssign<&'a Scalar> for RistrettoPoint {\n    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }\n}\n\nimpl<'a> Mul<&'a Scalar> for &RistrettoPoint {\n    type Output = RistrettoPoint;\n    /// Scalar multiplication: compute `scalar * self`.\n    fn mul(self, scalar: &'a Scalar) -> RistrettoPoint {\n        RistrettoPoint(self.0 * scalar)\n    }\n}\n\nimpl<'a> Mul<&'a RistrettoPoint> for &Scalar {\n    type Output = RistrettoPoint;\n\n    /// Scalar multiplication: compute `self * scalar`.\n    fn mul(self, point: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self * point.0)\n    }\n}\n\nimpl RistrettoPoint {\n    /// Fixed-base scalar multiplication by the Ristretto base point.\n    ///\n    /// Uses precomputed basepoint tables when the `precomputed-tables` feature\n    /// is enabled, trading off increased code size for ~4x better performance.\n    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }\n}\n\ndefine_mul_assign_variants!(LHS = RistrettoPoint, RHS = Scalar);\n\ndefine_mul_variants!(LHS = RistrettoPoint, RHS = Scalar, Output = RistrettoPoint);\ndefine_mul_variants!(LHS = Scalar, RHS = RistrettoPoint, Output = RistrettoPoint);\n\n// ------------------------------------------------------------------------\n// Multiscalar Multiplication impls\n// ------------------------------------------------------------------------\n\n// These use iterator combinators to unwrap the underlying points and\n// forward to the EdwardsPoint implementations.\n\n#[cfg(feature = \"alloc\")]\nimpl MultiscalarMul for RistrettoPoint {\n    type Point = RistrettoPoint;\n\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> RistrettoPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<RistrettoPoint>,\n    {\n        let extended_points = points.into_iter().map(|P| P.borrow().0);\n        RistrettoPoint(EdwardsPoint::multiscalar_mul(scalars, extended_points))\n    }\n}\n\n#[cfg(feature = \"alloc\")]\nimpl VartimeMultiscalarMul for RistrettoPoint {\n    type Point = RistrettoPoint;\n\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<RistrettoPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<RistrettoPoint>>,\n    {\n        let extended_points = points.into_iter().map(|opt_P| opt_P.map(|P| P.0));\n\n        EdwardsPoint::optional_multiscalar_mul(scalars, extended_points).map(RistrettoPoint)\n    }\n}\n\n/// Precomputation for variable-time multiscalar multiplication with `RistrettoPoint`s.\n///\n/// Note that for large numbers of `RistrettoPoint`s, this functionality may be less\n/// efficient than the corresponding `VartimeMultiscalarMul` implementation.\n// This wraps the inner implementation in a facade type so that we can\n// decouple stability of the inner type from the stability of the\n// outer type.\n#[cfg(feature = \"alloc\")]\npub struct VartimeRistrettoPrecomputation(crate::backend::VartimePrecomputedStraus);\n\n#[cfg(feature = \"alloc\")]\nimpl VartimePrecomputedMultiscalarMul for VartimeRistrettoPrecomputation {\n    type Point = RistrettoPoint;\n\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(\n            static_points.into_iter().map(|P| P.borrow().0),\n        ))\n    }\n\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }\n\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points.into_iter().map(|P_opt| P_opt.map(|P| P.0)),\n            )\n            .map(RistrettoPoint)\n    }\n}\n\nimpl RistrettoPoint {\n    /// Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the\n    /// Ristretto basepoint.\n    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &RistrettoPoint,\n        b: &Scalar,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::vartime_double_scalar_mul_basepoint(\n            a, &A.0, b,\n        ))\n    }\n}\n\n/// A precomputed table of multiples of a basepoint, used to accelerate\n/// scalar multiplication.\n///\n/// A precomputed table of multiples of the Ristretto basepoint is\n/// available in the `constants` module:\n/// ```\n/// use curve25519_dalek::constants::RISTRETTO_BASEPOINT_TABLE;\n/// use curve25519_dalek::scalar::Scalar;\n///\n/// let a = Scalar::from(87329482u64);\n/// let P = &a * RISTRETTO_BASEPOINT_TABLE;\n/// ```\n#[cfg(feature = \"precomputed-tables\")]\n#[derive(Clone)]\n#[repr(transparent)]\npub struct RistrettoBasepointTable(pub(crate) EdwardsBasepointTable);\n\n#[cfg(feature = \"precomputed-tables\")]\nimpl<'b> Mul<&'b Scalar> for &RistrettoBasepointTable {\n    type Output = RistrettoPoint;\n\n    fn mul(self, scalar: &'b Scalar) -> RistrettoPoint {\n        RistrettoPoint(&self.0 * scalar)\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nimpl<'a> Mul<&'a RistrettoBasepointTable> for &Scalar {\n    type Output = RistrettoPoint;\n\n    fn mul(self, basepoint_table: &'a RistrettoBasepointTable) -> RistrettoPoint {\n        RistrettoPoint(self * &basepoint_table.0)\n    }\n}\n\n#[cfg(feature = \"precomputed-tables\")]\nimpl RistrettoBasepointTable {\n    /// Create a precomputed table of multiples of the given `basepoint`.\n    pub fn create(basepoint: &RistrettoPoint) -> RistrettoBasepointTable {\n        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }\n\n    /// Get the basepoint for this table as a `RistrettoPoint`.\n    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }\n}\n\n// ------------------------------------------------------------------------\n// Constant-time conditional selection\n// ------------------------------------------------------------------------\n\nimpl ConditionallySelectable for RistrettoPoint {\n    /// Conditionally select between `self` and `other`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use subtle::ConditionallySelectable;\n    /// use subtle::Choice;\n    /// #\n    /// # use curve25519_dalek::traits::Identity;\n    /// # use curve25519_dalek::ristretto::RistrettoPoint;\n    /// # use curve25519_dalek::constants;\n    /// # fn main() {\n    ///\n    /// let A = RistrettoPoint::identity();\n    /// let B = constants::RISTRETTO_BASEPOINT_POINT;\n    ///\n    /// let mut P = A;\n    ///\n    /// P = RistrettoPoint::conditional_select(&A, &B, Choice::from(0));\n    /// assert_eq!(P, A);\n    /// P = RistrettoPoint::conditional_select(&A, &B, Choice::from(1));\n    /// assert_eq!(P, B);\n    /// # }\n    /// ```\n    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }\n}\n\n// ------------------------------------------------------------------------\n// Debug traits\n// ------------------------------------------------------------------------\n\nimpl Debug for CompressedRistretto {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedRistretto: {:?}\", self.as_bytes())\n    }\n}\n\nimpl Debug for RistrettoPoint {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let coset = self.coset4();\n        write!(\n            f,\n            \"RistrettoPoint: coset \\n{:?}\\n{:?}\\n{:?}\\n{:?}\",\n            coset[0], coset[1], coset[2], coset[3]\n        )\n    }\n}\n\n// ------------------------------------------------------------------------\n// group traits\n// ------------------------------------------------------------------------\n\n// Use the full trait path to avoid Group::identity overlapping Identity::identity in the\n// rest of the module (e.g. tests).\n#[cfg(feature = \"group\")]\nimpl group::Group for RistrettoPoint {\n    type Scalar = Scalar;\n\n    fn try_from_rng<R: TryRngCore + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        // NOTE: this is duplicated due to different `rng` bounds\n        let mut uniform_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n        Ok(RistrettoPoint::from_uniform_bytes(&uniform_bytes))\n    }\n\n    fn identity() -> Self {\n        Identity::identity()\n    }\n\n    fn generator() -> Self {\n        constants::RISTRETTO_BASEPOINT_POINT\n    }\n\n    fn is_identity(&self) -> Choice {\n        self.ct_eq(&Identity::identity())\n    }\n\n    fn double(&self) -> Self {\n        self + self\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl GroupEncoding for RistrettoPoint {\n    type Repr = [u8; 32];\n\n    fn from_bytes(bytes: &Self::Repr) -> CtOption<Self> {\n        let (s_encoding_is_canonical, s_is_negative, s) =\n            decompress::step_1(&CompressedRistretto(*bytes));\n\n        let s_is_valid = s_encoding_is_canonical & !s_is_negative;\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        CtOption::new(res, s_is_valid & ok & !t_is_negative & !y_is_zero)\n    }\n\n    fn from_bytes_unchecked(bytes: &Self::Repr) -> CtOption<Self> {\n        // Just use the checked API; the checks we could skip aren't expensive.\n        Self::from_bytes(bytes)\n    }\n\n    fn to_bytes(&self) -> Self::Repr {\n        self.compress().to_bytes()\n    }\n}\n\n#[cfg(feature = \"group\")]\nimpl PrimeGroup for RistrettoPoint {}\n\n/// Ristretto has a cofactor of 1.\n#[cfg(feature = \"group\")]\nimpl CofactorGroup for RistrettoPoint {\n    type Subgroup = Self;\n\n    fn clear_cofactor(&self) -> Self::Subgroup {\n        *self\n    }\n\n    fn into_subgroup(self) -> CtOption<Self::Subgroup> {\n        CtOption::new(self, Choice::from(1))\n    }\n\n    fn is_torsion_free(&self) -> Choice {\n        Choice::from(1)\n    }\n}\n\n// ------------------------------------------------------------------------\n// Zeroize traits\n// ------------------------------------------------------------------------\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for CompressedRistretto {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl Zeroize for RistrettoPoint {\n    fn zeroize(&mut self) {\n        self.0.zeroize();\n    }\n}\n\n// ------------------------------------------------------------------------\n// Tests\n// ------------------------------------------------------------------------\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::edwards::CompressedEdwardsY;\n\n    use rand_core::{OsRng, TryRngCore};\n\n    #[test]\n    #[cfg(feature = \"serde\")]\n    fn serde_bincode_basepoint_roundtrip() {\n        use bincode;\n\n        let encoded = bincode::serialize(&constants::RISTRETTO_BASEPOINT_POINT).unwrap();\n        let enc_compressed =\n            bincode::serialize(&constants::RISTRETTO_BASEPOINT_COMPRESSED).unwrap();\n        assert_eq!(encoded, enc_compressed);\n\n        // Check that the encoding is 32 bytes exactly\n        assert_eq!(encoded.len(), 32);\n\n        let dec_uncompressed: RistrettoPoint = bincode::deserialize(&encoded).unwrap();\n        let dec_compressed: CompressedRistretto = bincode::deserialize(&encoded).unwrap();\n\n        assert_eq!(dec_uncompressed, constants::RISTRETTO_BASEPOINT_POINT);\n        assert_eq!(dec_compressed, constants::RISTRETTO_BASEPOINT_COMPRESSED);\n\n        // Check that the encoding itself matches the usual one\n        let raw_bytes = constants::RISTRETTO_BASEPOINT_COMPRESSED.as_bytes();\n        let bp: RistrettoPoint = bincode::deserialize(raw_bytes).unwrap();\n        assert_eq!(bp, constants::RISTRETTO_BASEPOINT_POINT);\n    }\n\n    #[test]\n    fn scalarmult_ristrettopoint_works_both_ways() {\n        let P = constants::RISTRETTO_BASEPOINT_POINT;\n        let s = Scalar::from(999u64);\n\n        let P1 = P * s;\n        let P2 = s * P;\n\n        assert!(P1.compress().as_bytes() == P2.compress().as_bytes());\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn impl_sum() {\n        // Test that sum works for non-empty iterators\n        let BASE = constants::RISTRETTO_BASEPOINT_POINT;\n\n        let s1 = Scalar::from(999u64);\n        let P1 = BASE * s1;\n\n        let s2 = Scalar::from(333u64);\n        let P2 = BASE * s2;\n\n        let vec = vec![P1, P2];\n        let sum: RistrettoPoint = vec.iter().sum();\n\n        assert_eq!(sum, P1 + P2);\n\n        // Test that sum works for the empty iterator\n        let empty_vector: Vec<RistrettoPoint> = vec![];\n        let sum: RistrettoPoint = empty_vector.iter().sum();\n\n        assert_eq!(sum, RistrettoPoint::identity());\n\n        // Test that sum works on owning iterators\n        let s = Scalar::from(2u64);\n        let mapped = vec.iter().map(|x| x * s);\n        let sum: RistrettoPoint = mapped.sum();\n\n        assert_eq!(sum, P1 * s + P2 * s);\n    }\n\n    #[test]\n    fn decompress_negative_s_fails() {\n        // constants::d is neg, so decompression should fail as |d| != d.\n        let bad_compressed = CompressedRistretto(constants::EDWARDS_D.to_bytes());\n        assert!(bad_compressed.decompress().is_none());\n    }\n\n    #[test]\n    fn decompress_id() {\n        let compressed_id = CompressedRistretto::identity();\n        let id = compressed_id.decompress().unwrap();\n        let mut identity_in_coset = false;\n        for P in &id.coset4() {\n            if P.compress() == CompressedEdwardsY::identity() {\n                identity_in_coset = true;\n            }\n        }\n        assert!(identity_in_coset);\n    }\n\n    #[test]\n    fn compress_id() {\n        let id = RistrettoPoint::identity();\n        assert_eq!(id.compress(), CompressedRistretto::identity());\n    }\n\n    #[test]\n    fn basepoint_roundtrip() {\n        let bp_compressed_ristretto = constants::RISTRETTO_BASEPOINT_POINT.compress();\n        let bp_recaf = bp_compressed_ristretto.decompress().unwrap().0;\n        // Check that bp_recaf differs from bp by a point of order 4\n        let diff = constants::RISTRETTO_BASEPOINT_POINT.0 - bp_recaf;\n        let diff4 = diff.mul_by_pow_2(2);\n        assert_eq!(diff4.compress(), CompressedEdwardsY::identity());\n    }\n\n    #[test]\n    fn encodings_of_small_multiples_of_basepoint() {\n        // Table of encodings of i*basepoint\n        // Generated using ristretto.sage\n        let compressed = [\n            CompressedRistretto([\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0,\n            ]),\n            CompressedRistretto([\n                226, 242, 174, 10, 106, 188, 78, 113, 168, 132, 169, 97, 197, 0, 81, 95, 88, 227,\n                11, 106, 165, 130, 221, 141, 182, 166, 89, 69, 224, 141, 45, 118,\n            ]),\n            CompressedRistretto([\n                106, 73, 50, 16, 247, 73, 156, 209, 127, 236, 181, 16, 174, 12, 234, 35, 161, 16,\n                232, 213, 185, 1, 248, 172, 173, 211, 9, 92, 115, 163, 185, 25,\n            ]),\n            CompressedRistretto([\n                148, 116, 31, 93, 93, 82, 117, 94, 206, 79, 35, 240, 68, 238, 39, 213, 209, 234,\n                30, 43, 209, 150, 180, 98, 22, 107, 22, 21, 42, 157, 2, 89,\n            ]),\n            CompressedRistretto([\n                218, 128, 134, 39, 115, 53, 139, 70, 111, 250, 223, 224, 179, 41, 58, 179, 217,\n                253, 83, 197, 234, 108, 149, 83, 88, 245, 104, 50, 45, 175, 106, 87,\n            ]),\n            CompressedRistretto([\n                232, 130, 177, 49, 1, 107, 82, 193, 211, 51, 112, 128, 24, 124, 247, 104, 66, 62,\n                252, 203, 181, 23, 187, 73, 90, 184, 18, 196, 22, 15, 244, 78,\n            ]),\n            CompressedRistretto([\n                246, 71, 70, 211, 201, 43, 19, 5, 14, 216, 216, 2, 54, 167, 240, 0, 124, 59, 63,\n                150, 47, 91, 167, 147, 209, 154, 96, 30, 187, 29, 244, 3,\n            ]),\n            CompressedRistretto([\n                68, 245, 53, 32, 146, 110, 200, 31, 189, 90, 56, 120, 69, 190, 183, 223, 133, 169,\n                106, 36, 236, 225, 135, 56, 189, 207, 166, 167, 130, 42, 23, 109,\n            ]),\n            CompressedRistretto([\n                144, 50, 147, 216, 242, 40, 126, 190, 16, 226, 55, 77, 193, 165, 62, 11, 200, 135,\n                229, 146, 105, 159, 2, 208, 119, 213, 38, 60, 221, 85, 96, 28,\n            ]),\n            CompressedRistretto([\n                2, 98, 42, 206, 143, 115, 3, 163, 28, 175, 198, 63, 143, 196, 143, 220, 22, 225,\n                200, 200, 210, 52, 178, 240, 214, 104, 82, 130, 169, 7, 96, 49,\n            ]),\n            CompressedRistretto([\n                32, 112, 111, 215, 136, 178, 114, 10, 30, 210, 165, 218, 212, 149, 43, 1, 244, 19,\n                188, 240, 231, 86, 77, 232, 205, 200, 22, 104, 158, 45, 185, 95,\n            ]),\n            CompressedRistretto([\n                188, 232, 63, 139, 165, 221, 47, 165, 114, 134, 76, 36, 186, 24, 16, 249, 82, 43,\n                198, 0, 74, 254, 149, 135, 122, 199, 50, 65, 202, 253, 171, 66,\n            ]),\n            CompressedRistretto([\n                228, 84, 158, 225, 107, 154, 160, 48, 153, 202, 32, 140, 103, 173, 175, 202, 250,\n                76, 63, 62, 78, 83, 3, 222, 96, 38, 227, 202, 143, 248, 68, 96,\n            ]),\n            CompressedRistretto([\n                170, 82, 224, 0, 223, 46, 22, 245, 95, 177, 3, 47, 195, 59, 196, 39, 66, 218, 214,\n                189, 90, 143, 192, 190, 1, 103, 67, 108, 89, 72, 80, 31,\n            ]),\n            CompressedRistretto([\n                70, 55, 107, 128, 244, 9, 178, 157, 194, 181, 246, 240, 197, 37, 145, 153, 8, 150,\n                229, 113, 111, 65, 71, 124, 211, 0, 133, 171, 127, 16, 48, 30,\n            ]),\n            CompressedRistretto([\n                224, 196, 24, 247, 200, 217, 196, 205, 215, 57, 91, 147, 234, 18, 79, 58, 217, 144,\n                33, 187, 104, 29, 252, 51, 2, 169, 217, 154, 46, 83, 230, 78,\n            ]),\n        ];\n        let mut bp = RistrettoPoint::identity();\n        for point in compressed {\n            assert_eq!(bp.compress(), point);\n            bp += constants::RISTRETTO_BASEPOINT_POINT;\n        }\n    }\n\n    #[test]\n    fn four_torsion_basepoint() {\n        let bp = constants::RISTRETTO_BASEPOINT_POINT;\n        let bp_coset = bp.coset4();\n        for point in bp_coset {\n            assert_eq!(bp, RistrettoPoint(point));\n        }\n    }\n\n    #[test]\n    fn four_torsion_random() {\n        let mut rng = OsRng.unwrap_err();\n        let P = RistrettoPoint::mul_base(&Scalar::random(&mut rng));\n        let P_coset = P.coset4();\n        for point in P_coset {\n            assert_eq!(P, RistrettoPoint(point));\n        }\n    }\n\n    #[test]\n    fn elligator_vs_ristretto_sage() {\n        // Test vectors extracted from ristretto.sage.\n        //\n        // Notice that all of the byte sequences have bit 255 set to 0; this is because\n        // ristretto.sage does not mask the high bit of a field element.  When the high bit is set,\n        // the ristretto.sage elligator implementation gives different results, since it takes a\n        // different field element as input.\n        let bytes: [[u8; 32]; 16] = [\n            [\n                184, 249, 135, 49, 253, 123, 89, 113, 67, 160, 6, 239, 7, 105, 211, 41, 192, 249,\n                185, 57, 9, 102, 70, 198, 15, 127, 7, 26, 160, 102, 134, 71,\n            ],\n            [\n                229, 14, 241, 227, 75, 9, 118, 60, 128, 153, 226, 21, 183, 217, 91, 136, 98, 0,\n                231, 156, 124, 77, 82, 139, 142, 134, 164, 169, 169, 62, 250, 52,\n            ],\n            [\n                115, 109, 36, 220, 180, 223, 99, 6, 204, 169, 19, 29, 169, 68, 84, 23, 21, 109,\n                189, 149, 127, 205, 91, 102, 172, 35, 112, 35, 134, 69, 186, 34,\n            ],\n            [\n                16, 49, 96, 107, 171, 199, 164, 9, 129, 16, 64, 62, 241, 63, 132, 173, 209, 160,\n                112, 215, 105, 50, 157, 81, 253, 105, 1, 154, 229, 25, 120, 83,\n            ],\n            [\n                156, 131, 161, 162, 236, 251, 5, 187, 167, 171, 17, 178, 148, 210, 90, 207, 86, 21,\n                79, 161, 167, 215, 234, 1, 136, 242, 182, 248, 38, 85, 79, 86,\n            ],\n            [\n                251, 177, 124, 54, 18, 101, 75, 235, 245, 186, 19, 46, 133, 157, 229, 64, 10, 136,\n                181, 185, 78, 144, 254, 167, 137, 49, 107, 10, 61, 10, 21, 25,\n            ],\n            [\n                232, 193, 20, 68, 240, 77, 186, 77, 183, 40, 44, 86, 150, 31, 198, 212, 76, 81, 3,\n                217, 197, 8, 126, 128, 126, 152, 164, 208, 153, 44, 189, 77,\n            ],\n            [\n                173, 229, 149, 177, 37, 230, 30, 69, 61, 56, 172, 190, 219, 115, 167, 194, 71, 134,\n                59, 75, 28, 244, 118, 26, 162, 97, 64, 16, 15, 189, 30, 64,\n            ],\n            [\n                106, 71, 61, 107, 250, 117, 42, 151, 91, 202, 212, 100, 52, 188, 190, 21, 125, 218,\n                31, 18, 253, 241, 160, 133, 57, 242, 3, 164, 189, 68, 111, 75,\n            ],\n            [\n                112, 204, 182, 90, 220, 198, 120, 73, 173, 107, 193, 17, 227, 40, 162, 36, 150,\n                141, 235, 55, 172, 183, 12, 39, 194, 136, 43, 153, 244, 118, 91, 89,\n            ],\n            [\n                111, 24, 203, 123, 254, 189, 11, 162, 51, 196, 163, 136, 204, 143, 10, 222, 33,\n                112, 81, 205, 34, 35, 8, 66, 90, 6, 164, 58, 170, 177, 34, 25,\n            ],\n            [\n                225, 183, 30, 52, 236, 82, 6, 183, 109, 25, 227, 181, 25, 82, 41, 193, 80, 77, 161,\n                80, 242, 203, 79, 204, 136, 245, 131, 110, 237, 106, 3, 58,\n            ],\n            [\n                207, 246, 38, 56, 30, 86, 176, 90, 27, 200, 61, 42, 221, 27, 56, 210, 79, 178, 189,\n                120, 68, 193, 120, 167, 77, 185, 53, 197, 124, 128, 191, 126,\n            ],\n            [\n                1, 136, 215, 80, 240, 46, 63, 147, 16, 244, 230, 207, 82, 189, 74, 50, 106, 169,\n                138, 86, 30, 131, 214, 202, 166, 125, 251, 228, 98, 24, 36, 21,\n            ],\n            [\n                210, 207, 228, 56, 155, 116, 207, 54, 84, 195, 251, 215, 249, 199, 116, 75, 109,\n                239, 196, 251, 194, 246, 252, 228, 70, 146, 156, 35, 25, 39, 241, 4,\n            ],\n            [\n                34, 116, 123, 9, 8, 40, 93, 189, 9, 103, 57, 103, 66, 227, 3, 2, 157, 107, 134,\n                219, 202, 74, 230, 154, 78, 107, 219, 195, 214, 14, 84, 80,\n            ],\n        ];\n        let encoded_images: [CompressedRistretto; 16] = [\n            CompressedRistretto([\n                176, 157, 237, 97, 66, 29, 140, 166, 168, 94, 26, 157, 212, 216, 229, 160, 195,\n                246, 232, 239, 169, 112, 63, 193, 64, 32, 152, 69, 11, 190, 246, 86,\n            ]),\n            CompressedRistretto([\n                234, 141, 77, 203, 181, 225, 250, 74, 171, 62, 15, 118, 78, 212, 150, 19, 131, 14,\n                188, 238, 194, 244, 141, 138, 166, 162, 83, 122, 228, 201, 19, 26,\n            ]),\n            CompressedRistretto([\n                232, 231, 51, 92, 5, 168, 80, 36, 173, 179, 104, 68, 186, 149, 68, 40, 140, 170,\n                27, 103, 99, 140, 21, 242, 43, 62, 250, 134, 208, 255, 61, 89,\n            ]),\n            CompressedRistretto([\n                208, 120, 140, 129, 177, 179, 237, 159, 252, 160, 28, 13, 206, 5, 211, 241, 192,\n                218, 1, 97, 130, 241, 20, 169, 119, 46, 246, 29, 79, 80, 77, 84,\n            ]),\n            CompressedRistretto([\n                202, 11, 236, 145, 58, 12, 181, 157, 209, 6, 213, 88, 75, 147, 11, 119, 191, 139,\n                47, 142, 33, 36, 153, 193, 223, 183, 178, 8, 205, 120, 248, 110,\n            ]),\n            CompressedRistretto([\n                26, 66, 231, 67, 203, 175, 116, 130, 32, 136, 62, 253, 215, 46, 5, 214, 166, 248,\n                108, 237, 216, 71, 244, 173, 72, 133, 82, 6, 143, 240, 104, 41,\n            ]),\n            CompressedRistretto([\n                40, 157, 102, 96, 201, 223, 200, 197, 150, 181, 106, 83, 103, 126, 143, 33, 145,\n                230, 78, 6, 171, 146, 210, 143, 112, 5, 245, 23, 183, 138, 18, 120,\n            ]),\n            CompressedRistretto([\n                220, 37, 27, 203, 239, 196, 176, 131, 37, 66, 188, 243, 185, 250, 113, 23, 167,\n                211, 154, 243, 168, 215, 54, 171, 159, 36, 195, 81, 13, 150, 43, 43,\n            ]),\n            CompressedRistretto([\n                232, 121, 176, 222, 183, 196, 159, 90, 238, 193, 105, 52, 101, 167, 244, 170, 121,\n                114, 196, 6, 67, 152, 80, 185, 221, 7, 83, 105, 176, 208, 224, 121,\n            ]),\n            CompressedRistretto([\n                226, 181, 183, 52, 241, 163, 61, 179, 221, 207, 220, 73, 245, 242, 25, 236, 67, 84,\n                179, 222, 167, 62, 167, 182, 32, 9, 92, 30, 165, 127, 204, 68,\n            ]),\n            CompressedRistretto([\n                226, 119, 16, 242, 200, 139, 240, 87, 11, 222, 92, 146, 156, 243, 46, 119, 65, 59,\n                1, 248, 92, 183, 50, 175, 87, 40, 206, 53, 208, 220, 148, 13,\n            ]),\n            CompressedRistretto([\n                70, 240, 79, 112, 54, 157, 228, 146, 74, 122, 216, 88, 232, 62, 158, 13, 14, 146,\n                115, 117, 176, 222, 90, 225, 244, 23, 94, 190, 150, 7, 136, 96,\n            ]),\n            CompressedRistretto([\n                22, 71, 241, 103, 45, 193, 195, 144, 183, 101, 154, 50, 39, 68, 49, 110, 51, 44,\n                62, 0, 229, 113, 72, 81, 168, 29, 73, 106, 102, 40, 132, 24,\n            ]),\n            CompressedRistretto([\n                196, 133, 107, 11, 130, 105, 74, 33, 204, 171, 133, 221, 174, 193, 241, 36, 38,\n                179, 196, 107, 219, 185, 181, 253, 228, 47, 155, 42, 231, 73, 41, 78,\n            ]),\n            CompressedRistretto([\n                58, 255, 225, 197, 115, 208, 160, 143, 39, 197, 82, 69, 143, 235, 92, 170, 74, 40,\n                57, 11, 171, 227, 26, 185, 217, 207, 90, 185, 197, 190, 35, 60,\n            ]),\n            CompressedRistretto([\n                88, 43, 92, 118, 223, 136, 105, 145, 238, 186, 115, 8, 214, 112, 153, 253, 38, 108,\n                205, 230, 157, 130, 11, 66, 101, 85, 253, 110, 110, 14, 148, 112,\n            ]),\n        ];\n        for i in 0..16 {\n            let r_0 = FieldElement::from_bytes(&bytes[i]);\n            let Q = RistrettoPoint::elligator_ristretto_flavor(&r_0);\n            assert_eq!(Q.compress(), encoded_images[i]);\n        }\n    }\n\n    // Known answer tests for the one-way mapping function in the Ristretto RFC\n    #[test]\n    fn one_way_map() {\n        // These inputs are from\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#appendix-A.3\n        let test_vectors: &[([u8; 64], CompressedRistretto)] = &[\n            (\n                [\n                    0x5d, 0x1b, 0xe0, 0x9e, 0x3d, 0x0c, 0x82, 0xfc, 0x53, 0x81, 0x12, 0x49, 0x0e,\n                    0x35, 0x70, 0x19, 0x79, 0xd9, 0x9e, 0x06, 0xca, 0x3e, 0x2b, 0x5b, 0x54, 0xbf,\n                    0xfe, 0x8b, 0x4d, 0xc7, 0x72, 0xc1, 0x4d, 0x98, 0xb6, 0x96, 0xa1, 0xbb, 0xfb,\n                    0x5c, 0xa3, 0x2c, 0x43, 0x6c, 0xc6, 0x1c, 0x16, 0x56, 0x37, 0x90, 0x30, 0x6c,\n                    0x79, 0xea, 0xca, 0x77, 0x05, 0x66, 0x8b, 0x47, 0xdf, 0xfe, 0x5b, 0xb6,\n                ],\n                CompressedRistretto([\n                    0x30, 0x66, 0xf8, 0x2a, 0x1a, 0x74, 0x7d, 0x45, 0x12, 0x0d, 0x17, 0x40, 0xf1,\n                    0x43, 0x58, 0x53, 0x1a, 0x8f, 0x04, 0xbb, 0xff, 0xe6, 0xa8, 0x19, 0xf8, 0x6d,\n                    0xfe, 0x50, 0xf4, 0x4a, 0x0a, 0x46,\n                ]),\n            ),\n            (\n                [\n                    0xf1, 0x16, 0xb3, 0x4b, 0x8f, 0x17, 0xce, 0xb5, 0x6e, 0x87, 0x32, 0xa6, 0x0d,\n                    0x91, 0x3d, 0xd1, 0x0c, 0xce, 0x47, 0xa6, 0xd5, 0x3b, 0xee, 0x92, 0x04, 0xbe,\n                    0x8b, 0x44, 0xf6, 0x67, 0x8b, 0x27, 0x01, 0x02, 0xa5, 0x69, 0x02, 0xe2, 0x48,\n                    0x8c, 0x46, 0x12, 0x0e, 0x92, 0x76, 0xcf, 0xe5, 0x46, 0x38, 0x28, 0x6b, 0x9e,\n                    0x4b, 0x3c, 0xdb, 0x47, 0x0b, 0x54, 0x2d, 0x46, 0xc2, 0x06, 0x8d, 0x38,\n                ],\n                CompressedRistretto([\n                    0xf2, 0x6e, 0x5b, 0x6f, 0x7d, 0x36, 0x2d, 0x2d, 0x2a, 0x94, 0xc5, 0xd0, 0xe7,\n                    0x60, 0x2c, 0xb4, 0x77, 0x3c, 0x95, 0xa2, 0xe5, 0xc3, 0x1a, 0x64, 0xf1, 0x33,\n                    0x18, 0x9f, 0xa7, 0x6e, 0xd6, 0x1b,\n                ]),\n            ),\n            (\n                [\n                    0x84, 0x22, 0xe1, 0xbb, 0xda, 0xab, 0x52, 0x93, 0x8b, 0x81, 0xfd, 0x60, 0x2e,\n                    0xff, 0xb6, 0xf8, 0x91, 0x10, 0xe1, 0xe5, 0x72, 0x08, 0xad, 0x12, 0xd9, 0xad,\n                    0x76, 0x7e, 0x2e, 0x25, 0x51, 0x0c, 0x27, 0x14, 0x07, 0x75, 0xf9, 0x33, 0x70,\n                    0x88, 0xb9, 0x82, 0xd8, 0x3d, 0x7f, 0xcf, 0x0b, 0x2f, 0xa1, 0xed, 0xff, 0xe5,\n                    0x19, 0x52, 0xcb, 0xe7, 0x36, 0x5e, 0x95, 0xc8, 0x6e, 0xaf, 0x32, 0x5c,\n                ],\n                CompressedRistretto([\n                    0x00, 0x6c, 0xcd, 0x2a, 0x9e, 0x68, 0x67, 0xe6, 0xa2, 0xc5, 0xce, 0xa8, 0x3d,\n                    0x33, 0x02, 0xcc, 0x9d, 0xe1, 0x28, 0xdd, 0x2a, 0x9a, 0x57, 0xdd, 0x8e, 0xe7,\n                    0xb9, 0xd7, 0xff, 0xe0, 0x28, 0x26,\n                ]),\n            ),\n            (\n                [\n                    0xac, 0x22, 0x41, 0x51, 0x29, 0xb6, 0x14, 0x27, 0xbf, 0x46, 0x4e, 0x17, 0xba,\n                    0xee, 0x8d, 0xb6, 0x59, 0x40, 0xc2, 0x33, 0xb9, 0x8a, 0xfc, 0xe8, 0xd1, 0x7c,\n                    0x57, 0xbe, 0xeb, 0x78, 0x76, 0xc2, 0x15, 0x0d, 0x15, 0xaf, 0x1c, 0xb1, 0xfb,\n                    0x82, 0x4b, 0xbd, 0x14, 0x95, 0x5f, 0x2b, 0x57, 0xd0, 0x8d, 0x38, 0x8a, 0xab,\n                    0x43, 0x1a, 0x39, 0x1c, 0xfc, 0x33, 0xd5, 0xba, 0xfb, 0x5d, 0xbb, 0xaf,\n                ],\n                CompressedRistretto([\n                    0xf8, 0xf0, 0xc8, 0x7c, 0xf2, 0x37, 0x95, 0x3c, 0x58, 0x90, 0xae, 0xc3, 0x99,\n                    0x81, 0x69, 0x00, 0x5d, 0xae, 0x3e, 0xca, 0x1f, 0xbb, 0x04, 0x54, 0x8c, 0x63,\n                    0x59, 0x53, 0xc8, 0x17, 0xf9, 0x2a,\n                ]),\n            ),\n            (\n                [\n                    0x16, 0x5d, 0x69, 0x7a, 0x1e, 0xf3, 0xd5, 0xcf, 0x3c, 0x38, 0x56, 0x5b, 0xee,\n                    0xfc, 0xf8, 0x8c, 0x0f, 0x28, 0x2b, 0x8e, 0x7d, 0xbd, 0x28, 0x54, 0x4c, 0x48,\n                    0x34, 0x32, 0xf1, 0xce, 0xc7, 0x67, 0x5d, 0xeb, 0xea, 0x8e, 0xbb, 0x4e, 0x5f,\n                    0xe7, 0xd6, 0xf6, 0xe5, 0xdb, 0x15, 0xf1, 0x55, 0x87, 0xac, 0x4d, 0x4d, 0x4a,\n                    0x1d, 0xe7, 0x19, 0x1e, 0x0c, 0x1c, 0xa6, 0x66, 0x4a, 0xbc, 0xc4, 0x13,\n                ],\n                CompressedRistretto([\n                    0xae, 0x81, 0xe7, 0xde, 0xdf, 0x20, 0xa4, 0x97, 0xe1, 0x0c, 0x30, 0x4a, 0x76,\n                    0x5c, 0x17, 0x67, 0xa4, 0x2d, 0x6e, 0x06, 0x02, 0x97, 0x58, 0xd2, 0xd7, 0xe8,\n                    0xef, 0x7c, 0xc4, 0xc4, 0x11, 0x79,\n                ]),\n            ),\n            (\n                [\n                    0xa8, 0x36, 0xe6, 0xc9, 0xa9, 0xca, 0x9f, 0x1e, 0x8d, 0x48, 0x62, 0x73, 0xad,\n                    0x56, 0xa7, 0x8c, 0x70, 0xcf, 0x18, 0xf0, 0xce, 0x10, 0xab, 0xb1, 0xc7, 0x17,\n                    0x2d, 0xdd, 0x60, 0x5d, 0x7f, 0xd2, 0x97, 0x98, 0x54, 0xf4, 0x7a, 0xe1, 0xcc,\n                    0xf2, 0x04, 0xa3, 0x31, 0x02, 0x09, 0x5b, 0x42, 0x00, 0xe5, 0xbe, 0xfc, 0x04,\n                    0x65, 0xac, 0xcc, 0x26, 0x31, 0x75, 0x48, 0x5f, 0x0e, 0x17, 0xea, 0x5c,\n                ],\n                CompressedRistretto([\n                    0xe2, 0x70, 0x56, 0x52, 0xff, 0x9f, 0x5e, 0x44, 0xd3, 0xe8, 0x41, 0xbf, 0x1c,\n                    0x25, 0x1c, 0xf7, 0xdd, 0xdb, 0x77, 0xd1, 0x40, 0x87, 0x0d, 0x1a, 0xb2, 0xed,\n                    0x64, 0xf1, 0xa9, 0xce, 0x86, 0x28,\n                ]),\n            ),\n            (\n                [\n                    0x2c, 0xdc, 0x11, 0xea, 0xeb, 0x95, 0xda, 0xf0, 0x11, 0x89, 0x41, 0x7c, 0xdd,\n                    0xdb, 0xf9, 0x59, 0x52, 0x99, 0x3a, 0xa9, 0xcb, 0x9c, 0x64, 0x0e, 0xb5, 0x05,\n                    0x8d, 0x09, 0x70, 0x2c, 0x74, 0x62, 0x2c, 0x99, 0x65, 0xa6, 0x97, 0xa3, 0xb3,\n                    0x45, 0xec, 0x24, 0xee, 0x56, 0x33, 0x5b, 0x55, 0x6e, 0x67, 0x7b, 0x30, 0xe6,\n                    0xf9, 0x0a, 0xc7, 0x7d, 0x78, 0x10, 0x64, 0xf8, 0x66, 0xa3, 0xc9, 0x82,\n                ],\n                CompressedRistretto([\n                    0x80, 0xbd, 0x07, 0x26, 0x25, 0x11, 0xcd, 0xde, 0x48, 0x63, 0xf8, 0xa7, 0x43,\n                    0x4c, 0xef, 0x69, 0x67, 0x50, 0x68, 0x1c, 0xb9, 0x51, 0x0e, 0xea, 0x55, 0x70,\n                    0x88, 0xf7, 0x6d, 0x9e, 0x50, 0x65,\n                ]),\n            ),\n            (\n                [\n                    0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n            (\n                [\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n                ],\n                CompressedRistretto([\n                    0x30, 0x42, 0x82, 0x79, 0x10, 0x23, 0xb7, 0x31, 0x28, 0xd2, 0x77, 0xbd, 0xcb,\n                    0x5c, 0x77, 0x46, 0xef, 0x2e, 0xac, 0x08, 0xdd, 0xe9, 0xf2, 0x98, 0x33, 0x79,\n                    0xcb, 0x8e, 0x5e, 0xf0, 0x51, 0x7f,\n                ]),\n            ),\n        ];\n        // Check that onewaymap(input) == output for all the above vectors\n        for (input, output) in test_vectors {\n            let Q = RistrettoPoint::from_uniform_bytes(input);\n            assert_eq!(&Q.compress(), output);\n        }\n    }\n\n    #[test]\n    fn random_roundtrip() {\n        let mut rng = OsRng.unwrap_err();\n        for _ in 0..100 {\n            let P = RistrettoPoint::mul_base(&Scalar::random(&mut rng));\n            let compressed_P = P.compress();\n            let Q = compressed_P.decompress().unwrap();\n            assert_eq!(P, Q);\n        }\n    }\n\n    #[test]\n    #[cfg(all(feature = \"alloc\", feature = \"rand_core\", feature = \"group\"))]\n    fn double_and_compress_1024_random_points() {\n        use group::Group;\n        let mut rng = OsRng;\n\n        let mut points: Vec<RistrettoPoint> = (0..1024)\n            .map(|_| RistrettoPoint::try_from_rng(&mut rng).unwrap())\n            .collect();\n        points[500] = <RistrettoPoint as Group>::identity();\n\n        let compressed = RistrettoPoint::double_and_compress_batch(&points);\n\n        for (P, P2_compressed) in points.iter().zip(compressed.iter()) {\n            assert_eq!(*P2_compressed, (P + P).compress());\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn vartime_precomputed_vs_nonprecomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let static_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..128)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let check_scalar: Scalar = static_scalars\n            .iter()\n            .chain(dynamic_scalars.iter())\n            .map(|s| s * s)\n            .sum();\n\n        let static_points = static_scalars\n            .iter()\n            .map(RistrettoPoint::mul_base)\n            .collect::<Vec<_>>();\n        let dynamic_points = dynamic_scalars\n            .iter()\n            .map(RistrettoPoint::mul_base)\n            .collect::<Vec<_>>();\n\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n\n        assert_eq!(precomputation.len(), 128);\n        assert!(!precomputation.is_empty());\n\n        let P = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        use crate::traits::VartimeMultiscalarMul;\n        let Q = RistrettoPoint::vartime_multiscalar_mul(\n            static_scalars.iter().chain(dynamic_scalars.iter()),\n            static_points.iter().chain(dynamic_points.iter()),\n        );\n\n        let R = RistrettoPoint::mul_base(&check_scalar);\n\n        assert_eq!(P.compress(), R.compress());\n        assert_eq!(Q.compress(), R.compress());\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn partial_precomputed_mixed_multiscalar_empty() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n        let n_dynamic = 8;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use zero scalars\n        let static_scalars = Vec::new();\n\n        let dynamic_points = (0..n_dynamic)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..n_dynamic)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n        for i in 0..n_dynamic {\n            result_manual += dynamic_points[i] * dynamic_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn partial_precomputed_mixed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n        let n_dynamic = 8;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use one fewer scalars\n        let static_scalars = (0..n_static - 1)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_points = (0..n_dynamic)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        let dynamic_scalars = (0..n_dynamic)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_mixed_multiscalar_mul(\n            &static_scalars,\n            &dynamic_scalars,\n            &dynamic_points,\n        );\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n        for i in 0..n_dynamic {\n            result_manual += dynamic_points[i] * dynamic_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn partial_precomputed_multiscalar() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use one fewer scalars\n        let static_scalars = (0..n_static - 1)\n            .map(|_| Scalar::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_multiscalar_mul(&static_scalars);\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }\n\n    #[test]\n    #[cfg(feature = \"alloc\")]\n    fn partial_precomputed_multiscalar_empty() {\n        let mut rng = rand::rng();\n\n        let n_static = 16;\n\n        let static_points = (0..n_static)\n            .map(|_| RistrettoPoint::random(&mut rng))\n            .collect::<Vec<_>>();\n\n        // Use zero scalars\n        let static_scalars = Vec::new();\n\n        // Compute the linear combination using precomputed multiscalar multiplication\n        let precomputation = VartimeRistrettoPrecomputation::new(static_points.iter());\n        let result_multiscalar = precomputation.vartime_multiscalar_mul(&static_scalars);\n\n        // Compute the linear combination manually\n        let mut result_manual = RistrettoPoint::identity();\n        for i in 0..static_scalars.len() {\n            result_manual += static_points[i] * static_scalars[i];\n        }\n\n        assert_eq!(result_multiscalar, result_manual);\n    }\n}\n",
    "filename": "curve25519-dalek/src/ristretto.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63647": {
    "text": "//! Build time diagnostics\n\n// auto is assumed or selected\n#[cfg(curve25519_dalek_backend = \"auto\")]\ncompile_error!(\"curve25519_dalek_backend is 'auto'\");\n\n// fiat was overridden\n#[cfg(curve25519_dalek_backend = \"fiat\")]\ncompile_error!(\"curve25519_dalek_backend is 'fiat'\");\n\n// serial was assumed or overridden\n#[cfg(curve25519_dalek_backend = \"serial\")]\ncompile_error!(\"curve25519_dalek_backend is 'serial'\");\n\n// simd was assumed over overridden\n#[cfg(curve25519_dalek_backend = \"simd\")]\ncompile_error!(\"curve25519_dalek_backend is 'simd'\");\n\n// 32 bits target_pointer_width was assumed or overridden\n#[cfg(curve25519_dalek_bits = \"32\")]\ncompile_error!(\"curve25519_dalek_bits is '32'\");\n\n// 64 bits target_pointer_width was assumed or overridden\n#[cfg(curve25519_dalek_bits = \"64\")]\ncompile_error!(\"curve25519_dalek_bits is '64'\");\n",
    "filename": "curve25519-dalek/src/diagnostics.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63648": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n#![no_std]\n#![cfg_attr(docsrs, feature(doc_auto_cfg, doc_cfg, doc_cfg_hide))]\n#![cfg_attr(docsrs, doc(cfg_hide(docsrs)))]\n//------------------------------------------------------------------------\n// Documentation:\n//------------------------------------------------------------------------\n#![doc(\n    html_logo_url = \"https://cdn.jsdelivr.net/gh/dalek-cryptography/curve25519-dalek/docs/assets/dalek-logo-clear.png\"\n)]\n#![doc = include_str!(\"../README.md\")]\n//------------------------------------------------------------------------\n// Linting:\n//------------------------------------------------------------------------\n#![cfg_attr(allow_unused_unsafe, allow(unused_unsafe))]\n#![warn(clippy::unwrap_used, missing_docs, rust_2018_idioms, unused_lifetimes)]\n\n//------------------------------------------------------------------------\n// External dependencies:\n//------------------------------------------------------------------------\n\n#[cfg(feature = \"alloc\")]\n#[allow(unused_imports)]\n#[macro_use]\nextern crate alloc;\n\n// TODO: move std-dependent tests to `tests/`\n#[cfg(test)]\n#[macro_use]\nextern crate std;\n\n#[cfg(feature = \"digest\")]\npub use digest;\n\n// Internal macros. Must come first!\n#[macro_use]\npub(crate) mod macros;\n\n//------------------------------------------------------------------------\n// curve25519-dalek public modules\n//------------------------------------------------------------------------\n\n// Scalar arithmetic mod l = 2^252 + ..., the order of the Ristretto group\npub mod scalar;\n\n// Point operations on the Montgomery form of Curve25519\npub mod montgomery;\n\n// Point operations on the Edwards form of Curve25519\npub mod edwards;\n\n// Group operations on the Ristretto group\npub mod ristretto;\n\n// Useful constants, like the Ed25519 basepoint\npub mod constants;\n\n// External (and internal) traits.\npub mod traits;\n\n//------------------------------------------------------------------------\n// curve25519-dalek internal modules\n//------------------------------------------------------------------------\n\n// Finite field arithmetic mod p = 2^255 - 19\npub(crate) mod field;\n\n// Arithmetic backends (using u32, u64, etc) live here\n#[cfg(docsrs)]\npub mod backend;\n#[cfg(not(docsrs))]\npub(crate) mod backend;\n\n// Generic code for window lookups\npub(crate) mod window;\n\npub use crate::{\n    edwards::EdwardsPoint, montgomery::MontgomeryPoint, ristretto::RistrettoPoint, scalar::Scalar,\n};\n\n// Build time diagnostics for validation\n#[cfg(curve25519_dalek_diagnostics = \"build\")]\nmod diagnostics;\n",
    "filename": "curve25519-dalek/src/lib.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63649": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n//! Various constants, such as the Ristretto and Ed25519 basepoints.\n\n#![allow(non_snake_case)]\n\nuse cfg_if::cfg_if;\n\nuse crate::edwards::CompressedEdwardsY;\nuse crate::montgomery::MontgomeryPoint;\nuse crate::ristretto::{CompressedRistretto, RistrettoPoint};\nuse crate::scalar::Scalar;\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::edwards::EdwardsBasepointTable;\n\ncfg_if! {\n    if #[cfg(curve25519_dalek_backend = \"fiat\")] {\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        pub use crate::backend::serial::fiat_u32::constants::*;\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        pub use crate::backend::serial::fiat_u64::constants::*;\n    } else {\n        #[cfg(curve25519_dalek_bits = \"32\")]\n        pub use crate::backend::serial::u32::constants::*;\n        #[cfg(curve25519_dalek_bits = \"64\")]\n        pub use crate::backend::serial::u64::constants::*;\n    }\n}\n\n/// The Ed25519 basepoint, in `CompressedEdwardsY` format.\n///\n/// This is the little-endian byte encoding of \\\\( 4/5 \\pmod p \\\\),\n/// which is the \\\\(y\\\\)-coordinate of the Ed25519 basepoint.\n///\n/// The sign bit is 0 since the basepoint has \\\\(x\\\\) chosen to be positive.\npub const ED25519_BASEPOINT_COMPRESSED: CompressedEdwardsY = CompressedEdwardsY([\n    0x58, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,\n]);\n\n/// The X25519 basepoint, in `MontgomeryPoint` format.\npub const X25519_BASEPOINT: MontgomeryPoint = MontgomeryPoint([\n    0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n]);\n\n/// The Ristretto basepoint, in `CompressedRistretto` format.\npub const RISTRETTO_BASEPOINT_COMPRESSED: CompressedRistretto = CompressedRistretto([\n    0xe2, 0xf2, 0xae, 0x0a, 0x6a, 0xbc, 0x4e, 0x71, 0xa8, 0x84, 0xa9, 0x61, 0xc5, 0x00, 0x51, 0x5f,\n    0x58, 0xe3, 0x0b, 0x6a, 0xa5, 0x82, 0xdd, 0x8d, 0xb6, 0xa6, 0x59, 0x45, 0xe0, 0x8d, 0x2d, 0x76,\n]);\n\n/// The Ristretto basepoint, as a `RistrettoPoint`.\n///\n/// This is called `_POINT` to distinguish it from `_TABLE`, which\n/// provides fast scalar multiplication.\npub const RISTRETTO_BASEPOINT_POINT: RistrettoPoint = RistrettoPoint(ED25519_BASEPOINT_POINT);\n\n/// `BASEPOINT_ORDER` is the order of the Ristretto group and of the Ed25519 basepoint, i.e.,\n/// $$\n/// \\ell = 2^\\{252\\} + 27742317777372353535851937790883648493.\n/// $$\npub(crate) const BASEPOINT_ORDER: Scalar = Scalar {\n    bytes: [\n        0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde,\n        0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x10,\n    ],\n};\n\n#[cfg(feature = \"precomputed-tables\")]\nuse crate::ristretto::RistrettoBasepointTable;\n\n/// The Ristretto basepoint, as a `RistrettoBasepointTable` for scalar multiplication.\n#[cfg(feature = \"precomputed-tables\")]\npub static RISTRETTO_BASEPOINT_TABLE: &RistrettoBasepointTable = unsafe {\n    // SAFETY: `RistrettoBasepointTable` is a `#[repr(transparent)]` newtype of\n    // `EdwardsBasepointTable`\n    &*(ED25519_BASEPOINT_TABLE as *const EdwardsBasepointTable as *const RistrettoBasepointTable)\n};\n\n#[cfg(test)]\nmod test {\n    use crate::constants;\n    use crate::field::FieldElement;\n    use crate::traits::{IsIdentity, ValidityCheck};\n\n    #[test]\n    fn test_eight_torsion() {\n        for i in 0..8 {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(3);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }\n\n    #[test]\n    fn test_four_torsion() {\n        for i in (0..8).filter(|i| i % 2 == 0) {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(2);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }\n\n    #[test]\n    fn test_two_torsion() {\n        for i in (0..8).filter(|i| i % 4 == 0) {\n            let Q = constants::EIGHT_TORSION[i].mul_by_pow_2(1);\n            assert!(Q.is_valid());\n            assert!(Q.is_identity());\n        }\n    }\n\n    /// Test that SQRT_M1 is the positive square root of -1\n    #[test]\n    fn test_sqrt_minus_one() {\n        let minus_one = FieldElement::MINUS_ONE;\n        let sqrt_m1_sq = &constants::SQRT_M1 * &constants::SQRT_M1;\n        assert_eq!(minus_one, sqrt_m1_sq);\n        assert!(bool::from(!constants::SQRT_M1.is_negative()));\n    }\n\n    #[test]\n    fn test_sqrt_constants_sign() {\n        let minus_one = FieldElement::MINUS_ONE;\n        let (was_nonzero_square, invsqrt_m1) = minus_one.invsqrt();\n        assert!(bool::from(was_nonzero_square));\n        let sign_test_sqrt = &invsqrt_m1 * &constants::SQRT_M1;\n        assert_eq!(sign_test_sqrt, minus_one);\n    }\n\n    /// Test that d = -121665/121666\n    #[test]\n    #[cfg(all(curve25519_dalek_bits = \"32\", not(curve25519_dalek_backend = \"fiat\")))]\n    fn test_d_vs_ratio() {\n        use crate::backend::serial::u32::field::FieldElement2625;\n        let a = -&FieldElement2625([121665, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        let b = FieldElement2625([121666, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        let d = &a * &b.invert();\n        let d2 = &d + &d;\n        assert_eq!(d, constants::EDWARDS_D);\n        assert_eq!(d2, constants::EDWARDS_D2);\n    }\n\n    /// Test that d = -121665/121666\n    #[test]\n    #[cfg(all(curve25519_dalek_bits = \"64\", not(curve25519_dalek_backend = \"fiat\")))]\n    fn test_d_vs_ratio() {\n        use crate::backend::serial::u64::field::FieldElement51;\n        let a = -&FieldElement51([121665, 0, 0, 0, 0]);\n        let b = FieldElement51([121666, 0, 0, 0, 0]);\n        let d = &a * &b.invert();\n        let d2 = &d + &d;\n        assert_eq!(d, constants::EDWARDS_D);\n        assert_eq!(d2, constants::EDWARDS_D2);\n    }\n\n    #[test]\n    fn test_sqrt_ad_minus_one() {\n        let a = FieldElement::MINUS_ONE;\n        let ad_minus_one = &(&a * &constants::EDWARDS_D) + &a;\n        let should_be_ad_minus_one = constants::SQRT_AD_MINUS_ONE.square();\n        assert_eq!(should_be_ad_minus_one, ad_minus_one);\n    }\n\n    /// Test that ED25519_SQRTAM2 squared is MONTGOMERY_A_NEG - 2\n    #[test]\n    #[cfg(feature = \"digest\")]\n    fn test_sqrt_a_minus_2() {\n        let one = FieldElement::ONE;\n        let a_minus_two = &(&constants::MONTGOMERY_A_NEG - &one) - &one;\n\n        assert_eq!(constants::ED25519_SQRTAM2.square(), a_minus_two)\n    }\n}\n",
    "filename": "curve25519-dalek/src/constants.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63650": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Module for common traits.\n\n#![allow(non_snake_case)]\n\nuse core::borrow::Borrow;\n\nuse crate::scalar::{Scalar, clamp_integer};\nuse subtle::ConstantTimeEq;\n\n// ------------------------------------------------------------------------\n// Public Traits\n// ------------------------------------------------------------------------\n\n/// Trait for getting the identity element of a point type.\npub trait Identity {\n    /// Returns the identity element of the curve.\n    /// Can be used as a constructor.\n    fn identity() -> Self;\n}\n\n/// Trait for testing if a curve point is equivalent to the identity point.\npub trait IsIdentity {\n    /// Return true if this element is the identity element of the curve.\n    fn is_identity(&self) -> bool;\n}\n\n/// Implement generic identity equality testing for a point representations\n/// which have constant-time equality testing and a defined identity\n/// constructor.\nimpl<T> IsIdentity for T\nwhere\n    T: ConstantTimeEq + Identity,\n{\n    fn is_identity(&self) -> bool {\n        self.ct_eq(&T::identity()).into()\n    }\n}\n\n/// A precomputed table of basepoints, for optimising scalar multiplications.\npub trait BasepointTable {\n    /// The type of point contained within this table.\n    type Point;\n\n    /// Generate a new precomputed basepoint table from the given basepoint.\n    fn create(basepoint: &Self::Point) -> Self;\n\n    /// Retrieve the original basepoint from this table.\n    fn basepoint(&self) -> Self::Point;\n\n    /// Multiply a `scalar` by this precomputed basepoint table, in constant time.\n    fn mul_base(&self, scalar: &Scalar) -> Self::Point;\n\n    /// Multiply `clamp_integer(bytes)` by this precomputed basepoint table, in constant time. For\n    /// a description of clamping, see [`clamp_integer`].\n    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }\n}\n\n/// A trait for constant-time multiscalar multiplication without precomputation.\npub trait MultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of (possibly secret) scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n.\n    /// $$\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// # #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::MultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>;\n}\n\n/// A trait for variable-time multiscalar multiplication without precomputation.\npub trait VartimeMultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// `Option`s of points, compute either `Some(Q)`, where\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// if all points were `Some(P_i)`, or else return `None`.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    /// let abc = [a,b,c];\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    /// let PQR = [P, Q, R];\n    ///\n    /// let compressed = [P.compress(), Q.compress(), R.compress()];\n    ///\n    /// // Now we can compute A1 = a*P + b*Q + c*R using P, Q, R:\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &PQR);\n    ///\n    /// // Or using the compressed points:\n    /// let A2 = RistrettoPoint::optional_multiscalar_mul(\n    ///     &abc,\n    ///     compressed.iter().map(|pt| pt.decompress()),\n    /// );\n    ///\n    /// assert_eq!(A2, Some(A1));\n    ///\n    /// // It's also possible to mix compressed and uncompressed points:\n    /// let A3 = RistrettoPoint::optional_multiscalar_mul(\n    ///     abc.iter()\n    ///         .chain(abc.iter()),\n    ///     compressed.iter().map(|pt| pt.decompress())\n    ///         .chain(PQR.iter().map(|&pt| Some(pt))),\n    /// );\n    ///\n    /// assert_eq!(A3, Some(A1+A1));\n    /// # }\n    /// ```\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n}\n\n/// A trait for variable-time multiscalar multiplication with precomputation.\n///\n/// A general multiscalar multiplication with precomputation can be written as\n/// $$\n/// Q = a_1 A_1 + \\cdots + a_n A_n + b_1 B_1 + \\cdots + b_m B_m,\n/// $$\n/// where the \\\\(B_i\\\\) are *static* points, for which precomputation\n/// is possible, and the \\\\(A_j\\\\) are *dynamic* points, for which\n/// precomputation is not possible.\n///\n/// This trait has three methods for performing this computation:\n///\n/// * [`Self::vartime_multiscalar_mul`], which handles the special case where\n///   \\\\(n = 0\\\\) and there are no dynamic points;\n///\n/// * [`Self::vartime_mixed_multiscalar_mul`], which takes the dynamic points as\n///   already-validated `Point`s and is infallible;\n///\n/// * [`Self::optional_mixed_multiscalar_mul`], which takes the dynamic points\n///   as `Option<Point>`s and returns an `Option<Point>`, allowing decompression\n///   to be composed into the input iterators.\n///\n/// All methods require that the lengths of the input iterators be\n/// known, as if they were `ExactSizeIterator`s.  (It\n/// does not require `ExactSizeIterator` only because that trait is\n/// broken).\npub trait VartimePrecomputedMultiscalarMul: Sized {\n    /// The type of point to be multiplied, e.g., `RistrettoPoint`.\n    type Point: Clone;\n\n    /// Given the static points \\\\( B_i \\\\), perform precomputation\n    /// and return the precomputation data.\n    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Return the number of static points in the precomputation.\n    fn len(&self) -> usize;\n\n    /// Determine if the precomputation is empty.\n    fn is_empty(&self) -> bool;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\).\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), `dynamic_scalars`, an iterator of public scalars\n    /// \\\\(a_i\\\\), and `dynamic_points`, an iterator of points\n    /// \\\\(A_i\\\\), compute\n    /// $$\n    /// Q = a_1 A_1 + \\cdots + a_n A_n + b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\), or if \\\\(a_i\\\\) and \\\\(A_i\\\\) do not have\n    /// the same length.\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    fn vartime_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator,\n        K::Item: Borrow<Self::Point>,\n    {\n        Self::optional_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            dynamic_scalars,\n            dynamic_points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), `dynamic_scalars`, an iterator of public scalars\n    /// \\\\(a_i\\\\), and `dynamic_points`, an iterator of points\n    /// \\\\(A_i\\\\), compute\n    /// $$\n    /// Q = a_1 A_1 + \\cdots + a_n A_n + b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// If any of the dynamic points were `None`, return `None`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\), or if \\\\(a_i\\\\) and \\\\(A_i\\\\) do not have\n    /// the same length.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>;\n}\n\n// ------------------------------------------------------------------------\n// Private Traits\n// ------------------------------------------------------------------------\n\n/// Trait for checking whether a point is on the curve.\n///\n/// This trait is only for debugging/testing, since it should be\n/// impossible for a `curve25519-dalek` user to construct an invalid\n/// point.\n#[allow(dead_code)]\npub(crate) trait ValidityCheck {\n    /// Checks whether the point is on the curve. Not CT.\n    fn is_valid(&self) -> bool;\n}\n",
    "filename": "curve25519-dalek/src/traits.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63651": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of curve25519-dalek.\n// Copyright (c) 2016-2021 isis lovecruft\n// Copyright (c) 2016-2019 Henry de Valence\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n// - Henry de Valence <hdevalence@hdevalence.ca>\n\n//! Code for fixed- and sliding-window functionality\n\n#![allow(non_snake_case)]\n\nuse core::fmt::Debug;\n\nuse cfg_if::cfg_if;\n\nuse subtle::Choice;\nuse subtle::ConditionallyNegatable;\nuse subtle::ConditionallySelectable;\nuse subtle::ConstantTimeEq;\n\nuse crate::traits::Identity;\n\nuse crate::backend::serial::curve_models::AffineNielsPoint;\nuse crate::backend::serial::curve_models::ProjectiveNielsPoint;\nuse crate::edwards::EdwardsPoint;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\nmacro_rules! impl_lookup_table {\n    (Name = $name:ident, Size = $size:expr, SizeNeg = $neg:expr, SizeRange = $range:expr, ConversionRange = $conv_range:expr) => {\n        /// A lookup table of precomputed multiples of a point \\\\(P\\\\), used to\n        /// compute \\\\( xP \\\\) for \\\\( -8 \\leq x \\leq 8 \\\\).\n        ///\n        /// The computation of \\\\( xP \\\\) is done in constant time by the `select` function.\n        ///\n        /// Since `LookupTable` does not implement `Index`, it's more difficult\n        /// to accidentally use the table directly.  Unfortunately the table is\n        /// only `pub(crate)` so that we can write hardcoded constants, so it's\n        /// still technically possible.  It would be nice to prevent direct\n        /// access to the table.\n        #[derive(Copy, Clone)]\n        pub struct $name<T>(pub(crate) [T; $size]);\n\n        impl<T> $name<T>\n        where\n            T: Identity + ConditionallySelectable + ConditionallyNegatable,\n        {\n            /// Given \\\\(-8 \\leq x \\leq 8\\\\), return \\\\(xP\\\\) in constant time.\n            pub fn select(&self, x: i8) -> T {\n                debug_assert!(x >= $neg);\n                debug_assert!(x as i16 <= $size as i16); // XXX We have to convert to i16s here for the radix-256 case.. this is wrong.\n\n                // Compute xabs = |x|\n                let xmask = x as i16 >> 7;\n                let xabs = (x as i16 + xmask) ^ xmask;\n\n                // Set t = 0 * P = identity\n                let mut t = T::identity();\n                for j in $range {\n                    // Copy `points[j-1] == j*P` onto `t` in constant time if `|x| == j`.\n                    let c = (xabs as u16).ct_eq(&(j as u16));\n                    t.conditional_assign(&self.0[j - 1], c);\n                }\n                // Now t == |x| * P.\n\n                let neg_mask = Choice::from((xmask & 1) as u8);\n                t.conditional_negate(neg_mask);\n                // Now t == x * P.\n\n                t\n            }\n        }\n\n        impl<T: Copy + Default> Default for $name<T> {\n            fn default() -> $name<T> {\n                $name([T::default(); $size])\n            }\n        }\n\n        impl<T: Debug> Debug for $name<T> {\n            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(f, \"{:?}(\", stringify!($name))?;\n\n                for x in self.0.iter() {\n                    write!(f, \"{:?}\", x)?;\n                }\n\n                write!(f, \")\")\n            }\n        }\n\n        impl<'a> From<&'a EdwardsPoint> for $name<ProjectiveNielsPoint> {\n            fn from(P: &'a EdwardsPoint) -> Self {\n                let mut points = [P.as_projective_niels(); $size];\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_projective_niels();\n                }\n                $name(points)\n            }\n        }\n\n        impl<'a> From<&'a EdwardsPoint> for $name<AffineNielsPoint> {\n            fn from(P: &'a EdwardsPoint) -> Self {\n                let mut points = [P.as_affine_niels(); $size];\n                // XXX batch inversion would be good if perf mattered here\n                for j in $conv_range {\n                    points[j + 1] = (P + &points[j]).as_extended().as_affine_niels()\n                }\n                $name(points)\n            }\n        }\n\n        #[cfg(feature = \"zeroize\")]\n        impl<T> Zeroize for $name<T>\n        where\n            T: Copy + Default + Zeroize,\n        {\n            fn zeroize(&mut self) {\n                self.0.iter_mut().zeroize();\n            }\n        }\n    };\n} // End macro_rules! impl_lookup_table\n\n// The first one has to be named \"LookupTable\" because it's used as a constructor for consts.\n// This is radix-16\nimpl_lookup_table! {\n    Name = LookupTable,\n    Size = 8,\n    SizeNeg = -8,\n    SizeRange = 1..9,\n    ConversionRange = 0..7\n}\n\n// The rest only get used to make basepoint tables\ncfg_if! {\n    if #[cfg(feature = \"precomputed-tables\")] {\n        // radix-32\n        impl_lookup_table! {\n            Name = LookupTableRadix32,\n            Size = 16,\n            SizeNeg = -16,\n            SizeRange = 1..17,\n            ConversionRange = 0..15\n        }\n        // radix-64\n        impl_lookup_table! {\n            Name = LookupTableRadix64,\n            Size = 32,\n            SizeNeg = -32,\n            SizeRange = 1..33,\n            ConversionRange = 0..31\n        }\n        // radix-128\n        impl_lookup_table! {\n            Name = LookupTableRadix128,\n            Size = 64,\n            SizeNeg = -64,\n            SizeRange = 1..65,\n            ConversionRange = 0..63\n        }\n        // radix-256\n        impl_lookup_table! {\n            Name = LookupTableRadix256,\n            Size = 128,\n            SizeNeg = -128,\n            SizeRange = 1..129,\n            ConversionRange = 0..127\n        }\n\n        // For homogeneity we then alias it to \"LookupTableRadix16\".\n        pub(crate) type LookupTableRadix16<T> = LookupTable<T>;\n    }\n}\n\n/// Holds odd multiples 1A, 3A, ..., 15A of a point A.\n#[derive(Copy, Clone)]\npub(crate) struct NafLookupTable5<T>(pub(crate) [T; 8]);\n\nimpl<T: Copy> NafLookupTable5<T> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 16);\n\n        self.0[x / 2]\n    }\n}\n\nimpl<T: Debug> Debug for NafLookupTable5<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"NafLookupTable5({:?})\", self.0)\n    }\n}\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<ProjectiveNielsPoint> {\n    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }\n}\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<AffineNielsPoint> {\n    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }\n}\n\n/// Holds stuff up to 8. The only time we use tables this big is for precomputed basepoint tables\n/// and multiscalar multiplication (which requires alloc).\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n#[derive(Copy, Clone)]\npub(crate) struct NafLookupTable8<T>(pub(crate) [T; 64]);\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> NafLookupTable8<T> {\n    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 128);\n\n        self.0[x / 2]\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        writeln!(f, \"NafLookupTable8([\")?;\n        for i in 0..64 {\n            writeln!(f, \"\\t{:?},\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_affine_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }\n}\n",
    "filename": "curve25519-dalek/src/window.rs",
    "filepath": null,
    "folder_id": 15828,
    "user_id": 460154
  },
  "63652": {
    "text": "use super::{CompressedEdwardsY, EdwardsPoint};\nuse crate::traits::Identity;\nuse crate::{Scalar, field::FieldElement};\nuse core::ops::Mul;\nuse subtle::{Choice, ConditionallySelectable, ConstantTimeEq};\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::DefaultIsZeroes;\n\n/// Affine Edwards point on untwisted curve.\n#[derive(Copy, Clone, Debug)]\npub struct AffinePoint {\n    pub(super) x: FieldElement,\n    pub(super) y: FieldElement,\n}\n\nimpl ConstantTimeEq for AffinePoint {\n    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }\n}\n\nimpl ConditionallySelectable for AffinePoint {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }\n}\n\nimpl Default for AffinePoint {\n    fn default() -> AffinePoint {\n        AffinePoint::identity()\n    }\n}\n\nimpl Identity for AffinePoint {\n    fn identity() -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::ZERO,\n            y: FieldElement::ONE,\n        }\n    }\n}\n\nimpl PartialEq for AffinePoint {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for AffinePoint {}\n\n#[cfg(feature = \"zeroize\")]\nimpl DefaultIsZeroes for AffinePoint {}\n\nimpl AffinePoint {\n    /// Convert to extended coordinates.\n    pub fn to_edwards(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T: &self.x * &self.y,\n        }\n    }\n\n    /// Compress affine Edwards coordinates into `CompressedEdwardsY` format.\n    #[inline]\n    pub fn compress(self) -> CompressedEdwardsY {\n        let mut s = self.y.to_bytes();\n        s[31] ^= self.x.is_negative().unwrap_u8() << 7;\n        CompressedEdwardsY(s)\n    }\n}\n\nimpl Mul<AffinePoint> for Scalar {\n    type Output = EdwardsPoint;\n\n    #[inline]\n    fn mul(self, rhs: AffinePoint) -> EdwardsPoint {\n        self * &rhs\n    }\n}\n\nimpl Mul<&AffinePoint> for Scalar {\n    type Output = EdwardsPoint;\n\n    #[inline]\n    fn mul(self, rhs: &AffinePoint) -> EdwardsPoint {\n        rhs.to_edwards() * self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{AffinePoint, EdwardsPoint, Identity};\n    use crate::constants;\n\n    #[test]\n    fn identity_conversion() {\n        assert_eq!(\n            AffinePoint::identity().to_edwards(),\n            EdwardsPoint::identity()\n        );\n    }\n\n    #[test]\n    fn generator_round_trip() {\n        let basepoint = constants::ED25519_BASEPOINT_POINT;\n        assert_eq!(basepoint.to_affine().to_edwards(), basepoint);\n    }\n}\n",
    "filename": "curve25519-dalek/src/edwards/affine.rs",
    "filepath": null,
    "folder_id": 15841,
    "user_id": 460154
  },
  "63653": {
    "text": "//! This selects the curve25519_dalek_bits either by default from target_pointer_width or explicitly set\n\n#![deny(clippy::unwrap_used, dead_code)]\n\n#[allow(non_camel_case_types)]\n#[derive(PartialEq, Debug)]\nenum DalekBits {\n    Dalek32,\n    Dalek64,\n}\n\nuse std::fmt::Formatter;\n\nimpl std::fmt::Display for DalekBits {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let w_bits = match self {\n            DalekBits::Dalek32 => \"32\",\n            DalekBits::Dalek64 => \"64\",\n        };\n        write!(f, \"{}\", w_bits)\n    }\n}\n\nfn main() {\n    let target_arch = match std::env::var(\"CARGO_CFG_TARGET_ARCH\") {\n        Ok(arch) => arch,\n        _ => \"\".to_string(),\n    };\n\n    let curve25519_dalek_bits = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BITS\").as_deref() {\n        Ok(\"32\") => DalekBits::Dalek32,\n        Ok(\"64\") => DalekBits::Dalek64,\n        _ => deterministic::determine_curve25519_dalek_bits(&target_arch),\n    };\n\n    println!(\"cargo:rustc-cfg=curve25519_dalek_bits=\\\"{curve25519_dalek_bits}\\\"\");\n\n    let nightly = if rustc_version::version_meta()\n        .expect(\"failed to detect rustc version\")\n        .channel\n        == rustc_version::Channel::Nightly\n    {\n        println!(\"cargo:rustc-cfg=nightly\");\n        true\n    } else {\n        false\n    };\n\n    let rustc_version = rustc_version::version().expect(\"failed to detect rustc version\");\n    if rustc_version.major == 1 && rustc_version.minor <= 64 {\n        // Old versions of Rust complain when you have an `unsafe fn` and you use `unsafe {}` inside,\n        // so for those we want to apply the `#[allow(unused_unsafe)]` attribute to get rid of that warning.\n        println!(\"cargo:rustc-cfg=allow_unused_unsafe\");\n    }\n\n    // Backend overrides / defaults\n    let curve25519_dalek_backend = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BACKEND\")\n        .as_deref()\n    {\n        Ok(\"fiat\") => \"fiat\",\n        Ok(\"serial\") => \"serial\",\n        Ok(\"simd\") => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => \"simd\",\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to simd\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if nightly => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => {\n                    // In addition enable Avx2 fallback through simd stable backend\n                    // NOTE: Compiler permits duplicate / multi value on the same key\n                    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"simd\\\"\");\n\n                    \"unstable_avx512\"\n                }\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to unstable_avx512\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if !nightly => {\n            panic!(\n                \"Could not override curve25519_dalek_backend to unstable_avx512, as this is nightly only\"\n            );\n        }\n        // default between serial / simd (if potentially capable)\n        _ => match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n            true => \"simd\",\n            false => \"serial\",\n        },\n    };\n    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"{curve25519_dalek_backend}\\\"\");\n}\n\n// Is the target arch & curve25519_dalek_bits potentially simd capable ?\nfn is_capable_simd(arch: &str, bits: DalekBits) -> bool {\n    arch == \"x86_64\" && bits == DalekBits::Dalek64\n}\n\n// Deterministic cfg(curve25519_dalek_bits) when this is not explicitly set.\nmod deterministic {\n\n    use super::*;\n\n    // Custom Rust non-cargo build tooling needs to set CARGO_CFG_TARGET_POINTER_WIDTH\n    static ERR_MSG_NO_POINTER_WIDTH: &str =\n        \"Standard Cargo TARGET_POINTER_WIDTH environment variable is not set.\";\n\n    // When either non-32 or 64 TARGET_POINTER_WIDTH detected\n    static ERR_MSG_UNKNOWN_POINTER_WIDTH: &str = \"Unknown TARGET_POINTER_WIDTH detected.\";\n\n    // Warning when the curve25519_dalek_bits cannot be determined\n    fn determine_curve25519_dalek_bits_warning(cause: &str) {\n        println!(\"cargo:warning=\\\"Defaulting to curve25519_dalek_bits=32: {cause}\\\"\");\n    }\n\n    // Determine the curve25519_dalek_bits based on Rust standard TARGET triplet\n    pub(super) fn determine_curve25519_dalek_bits(target_arch: &String) -> DalekBits {\n        let target_pointer_width = match std::env::var(\"CARGO_CFG_TARGET_POINTER_WIDTH\") {\n            Ok(pw) => pw,\n            Err(_) => {\n                determine_curve25519_dalek_bits_warning(ERR_MSG_NO_POINTER_WIDTH);\n                return DalekBits::Dalek32;\n            }\n        };\n\n        #[allow(clippy::match_single_binding)]\n        match &target_arch {\n            //Issues: 449 and 456\n            //TODO: When adding arch defaults use proper types not String match\n            //TODO(Arm): Needs tests + benchmarks to back this up\n            //TODO(Wasm32): Needs tests + benchmarks to back this up\n            _ => match target_pointer_width.as_ref() {\n                \"64\" => DalekBits::Dalek64,\n                \"32\" => DalekBits::Dalek32,\n                // Intended default solely for non-32/64 target pointer widths\n                // Otherwise known target platforms only.\n                _ => {\n                    determine_curve25519_dalek_bits_warning(ERR_MSG_UNKNOWN_POINTER_WIDTH);\n                    DalekBits::Dalek32\n                }\n            },\n        }\n    }\n}\n",
    "filename": "curve25519-dalek/build.rs",
    "filepath": null,
    "folder_id": 15822,
    "user_id": 460154
  },
  "63668": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2017-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\n//! Integration tests for ed25519-dalek.\n\n#![allow(clippy::items_after_test_module)]\n\nuse ed25519_dalek::*;\n\nuse hex::FromHex;\n#[cfg(feature = \"digest\")]\nuse hex_literal::hex;\n\n#[cfg(test)]\nmod vectors {\n    use super::*;\n\n    use curve25519_dalek::{\n        constants::ED25519_BASEPOINT_POINT,\n        edwards::{CompressedEdwardsY, EdwardsPoint},\n        scalar::Scalar,\n        traits::IsIdentity,\n    };\n    use rand_core::TryRngCore;\n\n    #[cfg(not(feature = \"digest\"))]\n    use sha2::{Sha512, digest::Digest};\n\n    use std::{\n        fs::File,\n        io::{BufRead, BufReader},\n        ops::Neg,\n    };\n\n    // TESTVECTORS is taken from sign.input.gz in agl's ed25519 Golang\n    // package. It is a selection of test cases from\n    // http://ed25519.cr.yp.to/python/sign.input\n    #[test]\n    fn against_reference_implementation() {\n        // TestGolden\n        let mut line: String;\n        let mut lineno: usize = 0;\n\n        let f = File::open(\"TESTVECTORS\");\n        if f.is_err() {\n            println!(\n                \"This test is only available when the code has been cloned \\\n                 from the git repository, since the TESTVECTORS file is large \\\n                 and is therefore not included within the distributed crate.\"\n            );\n            panic!();\n        }\n        let file = BufReader::new(f.unwrap());\n\n        for l in file.lines() {\n            lineno += 1;\n            line = l.unwrap();\n\n            let parts: Vec<&str> = line.split(':').collect();\n            assert_eq!(parts.len(), 5, \"wrong number of fields in line {}\", lineno);\n\n            let sec_bytes: Vec<u8> = FromHex::from_hex(parts[0]).unwrap();\n            let pub_bytes: Vec<u8> = FromHex::from_hex(parts[1]).unwrap();\n            let msg_bytes: Vec<u8> = FromHex::from_hex(parts[2]).unwrap();\n            let sig_bytes: Vec<u8> = FromHex::from_hex(parts[3]).unwrap();\n\n            let sec_bytes = &sec_bytes[..SECRET_KEY_LENGTH].try_into().unwrap();\n            let pub_bytes = &pub_bytes[..PUBLIC_KEY_LENGTH].try_into().unwrap();\n\n            let signing_key = SigningKey::from_bytes(sec_bytes);\n            let expected_verifying_key = VerifyingKey::from_bytes(pub_bytes).unwrap();\n            assert_eq!(expected_verifying_key, signing_key.verifying_key());\n\n            // The signatures in the test vectors also include the message\n            // at the end, but we just want R and S.\n            let sig1: Signature = Signature::try_from(&sig_bytes[..64]).unwrap();\n            let sig2: Signature = signing_key.sign(&msg_bytes);\n\n            assert!(sig1 == sig2, \"Signature bytes not equal on line {}\", lineno);\n            assert!(\n                signing_key.verify(&msg_bytes, &sig2).is_ok(),\n                \"Signature verification failed on line {}\",\n                lineno\n            );\n            assert!(\n                expected_verifying_key\n                    .verify_strict(&msg_bytes, &sig2)\n                    .is_ok(),\n                \"Signature strict verification failed on line {}\",\n                lineno\n            );\n        }\n    }\n\n    // From https://tools.ietf.org/html/rfc8032#section-7.3\n    #[cfg(feature = \"digest\")]\n    #[test]\n    fn ed25519ph_rf8032_test_vector_prehash() {\n        let sec_bytes = hex!(\"833fe62409237b9d62ec77587520911e9a759cec1d19755b7da901b96dca3d42\");\n        let pub_bytes = hex!(\"ec172b93ad5e563bf4932c70e1245034c35467ef2efd4d64ebf819683467e2bf\");\n        let msg_bytes = hex!(\"616263\");\n        let sig_bytes = hex!(\n            \"98a70222f0b8121aa9d30f813d683f809e462b469c7ff87639499bb94e6dae4131f85042463c2a355a2003d062adf5aaa10b8c61e636062aaad11c2a26083406\"\n        );\n\n        let signing_key = SigningKey::from_bytes(&sec_bytes);\n        let expected_verifying_key = VerifyingKey::from_bytes(&pub_bytes).unwrap();\n        assert_eq!(expected_verifying_key, signing_key.verifying_key());\n        let sig1 = Signature::try_from(&sig_bytes[..]).unwrap();\n\n        let mut prehash_for_signing = Sha512::default();\n        let mut prehash_for_verifying = Sha512::default();\n\n        prehash_for_signing.update(&msg_bytes[..]);\n        prehash_for_verifying.update(&msg_bytes[..]);\n\n        let sig2: Signature = signing_key\n            .sign_prehashed(prehash_for_signing, None)\n            .unwrap();\n\n        assert!(\n            sig1 == sig2,\n            \"Original signature from test vectors doesn't equal signature produced:\\\n             \\noriginal:\\n{:?}\\nproduced:\\n{:?}\",\n            sig1,\n            sig2\n        );\n        assert!(\n            signing_key\n                .verify_prehashed(prehash_for_verifying.clone(), None, &sig2)\n                .is_ok(),\n            \"Could not verify ed25519ph signature!\"\n        );\n        assert!(\n            expected_verifying_key\n                .verify_prehashed_strict(prehash_for_verifying, None, &sig2)\n                .is_ok(),\n            \"Could not strict-verify ed25519ph signature!\"\n        );\n    }\n\n    //\n    // The remaining items in this mod are for the repudiation tests\n    //\n\n    // Taken from curve25519_dalek::constants::EIGHT_TORSION[4]\n    const EIGHT_TORSION_4: [u8; 32] = [\n        236, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 127,\n    ];\n\n    // Computes the prehashed or non-prehashed challenge, depending on whether context is given\n    fn compute_challenge(\n        message: &[u8],\n        pub_key: &EdwardsPoint,\n        signature_r: &EdwardsPoint,\n        context: Option<&[u8]>,\n    ) -> Scalar {\n        let mut h = Sha512::default();\n        if let Some(c) = context {\n            h.update(b\"SigEd25519 no Ed25519 collisions\");\n            h.update([1]);\n            h.update([c.len() as u8]);\n            h.update(c);\n        }\n        h.update(signature_r.compress().as_bytes());\n        h.update(&pub_key.compress().as_bytes()[..]);\n        h.update(message);\n        Scalar::from_hash(h)\n    }\n\n    fn serialize_signature(r: &EdwardsPoint, s: &Scalar) -> Vec<u8> {\n        [&r.compress().as_bytes()[..], &s.as_bytes()[..]].concat()\n    }\n\n    const WEAK_PUBKEY: CompressedEdwardsY = CompressedEdwardsY(EIGHT_TORSION_4);\n\n    // Pick a random Scalar\n    fn non_null_scalar() -> Scalar {\n        let mut rng = rand::rngs::OsRng.unwrap_err();\n        let mut s_candidate = Scalar::random(&mut rng);\n        while s_candidate == Scalar::ZERO {\n            s_candidate = Scalar::random(&mut rng);\n        }\n        s_candidate\n    }\n\n    fn pick_r(s: Scalar) -> EdwardsPoint {\n        let r0 = s * ED25519_BASEPOINT_POINT;\n        // Pick a torsion point of order 2\n        r0 + WEAK_PUBKEY.decompress().unwrap().neg()\n    }\n\n    // Tests that verify_strict() rejects small-order pubkeys. We test this by explicitly\n    // constructing a pubkey-signature pair that verifies with respect to two distinct messages.\n    // This should be accepted by verify(), but rejected by verify_strict().\n    #[test]\n    fn repudiation() {\n        let message1 = b\"Send 100 USD to Alice\";\n        let message2 = b\"Send 100000 USD to Alice\";\n\n        let mut s: Scalar = non_null_scalar();\n        let pubkey = WEAK_PUBKEY.decompress().unwrap();\n        let mut r = pick_r(s);\n\n        // Find an R such that\n        //     H(R || A || M₁) · A == A == H(R || A || M₂) · A\n        // This happens with high probability when A is low order.\n        while !(pubkey.neg() + compute_challenge(message1, &pubkey, &r, None) * pubkey)\n            .is_identity()\n            || !(pubkey.neg() + compute_challenge(message2, &pubkey, &r, None) * pubkey)\n                .is_identity()\n        {\n            // We pick an s and let R = sB - A where B is the basepoint\n            s = non_null_scalar();\n            r = pick_r(s);\n        }\n\n        // At this point, both verification equations hold:\n        //     sB = R + H(R || A || M₁) · A\n        //        = R + H(R || A || M₂) · A\n        // Check that this is true\n        let signature = serialize_signature(&r, &s);\n        let vk = VerifyingKey::from_bytes(pubkey.compress().as_bytes()).unwrap();\n        let sig = Signature::try_from(&signature[..]).unwrap();\n        assert!(vk.verify(message1, &sig).is_ok());\n        assert!(vk.verify(message2, &sig).is_ok());\n\n        // Check that this public key appears as weak\n        assert!(vk.is_weak());\n\n        // Now check that the sigs fail under verify_strict. This is because verify_strict rejects\n        // small order pubkeys.\n        assert!(vk.verify_strict(message1, &sig).is_err());\n        assert!(vk.verify_strict(message2, &sig).is_err());\n    }\n\n    // Identical to repudiation() above, but testing verify_prehashed against\n    // verify_prehashed_strict. See comments above for a description of what's happening.\n    #[cfg(feature = \"digest\")]\n    #[test]\n    fn repudiation_prehash() {\n        let message1 = Sha512::new().chain_update(b\"Send 100 USD to Alice\");\n        let message2 = Sha512::new().chain_update(b\"Send 100000 USD to Alice\");\n        let message1_bytes = message1.clone().finalize();\n        let message2_bytes = message2.clone().finalize();\n\n        let mut s: Scalar = non_null_scalar();\n        let pubkey = WEAK_PUBKEY.decompress().unwrap();\n        let mut r = pick_r(s);\n        let context_str = Some(&b\"edtest\"[..]);\n\n        while !(pubkey.neg()\n            + compute_challenge(&message1_bytes, &pubkey, &r, context_str) * pubkey)\n            .is_identity()\n            || !(pubkey.neg()\n                + compute_challenge(&message2_bytes, &pubkey, &r, context_str) * pubkey)\n                .is_identity()\n        {\n            s = non_null_scalar();\n            r = pick_r(s);\n        }\n\n        // Check that verify_prehashed succeeds on both sigs\n        let signature = serialize_signature(&r, &s);\n        let vk = VerifyingKey::from_bytes(pubkey.compress().as_bytes()).unwrap();\n        let sig = Signature::try_from(&signature[..]).unwrap();\n        assert!(\n            vk.verify_prehashed(message1.clone(), context_str, &sig)\n                .is_ok()\n        );\n        assert!(\n            vk.verify_prehashed(message2.clone(), context_str, &sig)\n                .is_ok()\n        );\n\n        // Check that verify_prehashed_strict fails on both sigs\n        assert!(\n            vk.verify_prehashed_strict(message1.clone(), context_str, &sig)\n                .is_err()\n        );\n        assert!(\n            vk.verify_prehashed_strict(message2.clone(), context_str, &sig)\n                .is_err()\n        );\n    }\n}\n\n#[cfg(feature = \"rand_core\")]\nmod integrations {\n    use super::*;\n    use rand::{TryRngCore, rngs::OsRng};\n    use std::collections::HashMap;\n\n    #[test]\n    fn sign_verify() {\n        // TestSignVerify\n\n        let good: &[u8] = \"test message\".as_bytes();\n        let bad: &[u8] = \"wrong message\".as_bytes();\n\n        let mut csprng = OsRng.unwrap_err();\n\n        let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n        let verifying_key = signing_key.verifying_key();\n        let good_sig: Signature = signing_key.sign(good);\n        let bad_sig: Signature = signing_key.sign(bad);\n\n        // Check that an honestly generated public key is not weak\n        assert!(!verifying_key.is_weak());\n\n        assert!(\n            signing_key.verify(good, &good_sig).is_ok(),\n            \"Verification of a valid signature failed!\"\n        );\n        assert!(\n            verifying_key.verify_strict(good, &good_sig).is_ok(),\n            \"Strict verification of a valid signature failed!\"\n        );\n        assert!(\n            signing_key.verify(good, &bad_sig).is_err(),\n            \"Verification of a signature on a different message passed!\"\n        );\n        assert!(\n            verifying_key.verify_strict(good, &bad_sig).is_err(),\n            \"Strict verification of a signature on a different message passed!\"\n        );\n        assert!(\n            signing_key.verify(bad, &good_sig).is_err(),\n            \"Verification of a signature on a different message passed!\"\n        );\n        assert!(\n            verifying_key.verify_strict(bad, &good_sig).is_err(),\n            \"Strict verification of a signature on a different message passed!\"\n        );\n    }\n\n    #[cfg(feature = \"digest\")]\n    #[test]\n    fn sign_verify_digest_equivalence() {\n        // TestSignVerify\n\n        let mut csprng = OsRng.unwrap_err();\n\n        let good: &[u8] = \"test message\".as_bytes();\n        let bad: &[u8] = \"wrong message\".as_bytes();\n\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let good_sig: Signature = keypair.sign(good);\n        let bad_sig: Signature = keypair.sign(bad);\n\n        let mut verifier = keypair.verify_stream(&good_sig).unwrap();\n        verifier.update(good);\n        assert!(\n            verifier.finalize_and_verify().is_ok(),\n            \"Verification of a valid signature failed!\"\n        );\n\n        let mut verifier = keypair.verify_stream(&bad_sig).unwrap();\n        verifier.update(good);\n        assert!(\n            verifier.finalize_and_verify().is_err(),\n            \"Verification of a signature on a different message passed!\"\n        );\n\n        let mut verifier = keypair.verify_stream(&good_sig).unwrap();\n        verifier.update(\"test \");\n        verifier.update(\"message\");\n        assert!(\n            verifier.finalize_and_verify().is_ok(),\n            \"Verification of a valid signature failed!\"\n        );\n\n        let mut verifier = keypair.verify_stream(&good_sig).unwrap();\n        verifier.update(bad);\n        assert!(\n            verifier.finalize_and_verify().is_err(),\n            \"Verification of a signature on a different message passed!\"\n        );\n    }\n\n    #[cfg(feature = \"digest\")]\n    #[test]\n    fn ed25519ph_sign_verify() {\n        let good: &[u8] = b\"test message\";\n        let bad: &[u8] = b\"wrong message\";\n\n        let mut csprng = OsRng.unwrap_err();\n\n        // ugh… there's no `impl Copy for Sha512`… i hope we can all agree these are the same hashes\n        let mut prehashed_good1: Sha512 = Sha512::default();\n        prehashed_good1.update(good);\n        let mut prehashed_good2: Sha512 = Sha512::default();\n        prehashed_good2.update(good);\n        let mut prehashed_good3: Sha512 = Sha512::default();\n        prehashed_good3.update(good);\n\n        let mut prehashed_bad1: Sha512 = Sha512::default();\n        prehashed_bad1.update(bad);\n        let mut prehashed_bad2: Sha512 = Sha512::default();\n        prehashed_bad2.update(bad);\n\n        let context: &[u8] = b\"testing testing 1 2 3\";\n\n        let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n        let verifying_key = signing_key.verifying_key();\n        let good_sig: Signature = signing_key\n            .sign_prehashed(prehashed_good1, Some(context))\n            .unwrap();\n        let bad_sig: Signature = signing_key\n            .sign_prehashed(prehashed_bad1, Some(context))\n            .unwrap();\n\n        assert!(\n            signing_key\n                .verify_prehashed(prehashed_good2.clone(), Some(context), &good_sig)\n                .is_ok(),\n            \"Verification of a valid signature failed!\"\n        );\n        assert!(\n            verifying_key\n                .verify_prehashed_strict(prehashed_good2, Some(context), &good_sig)\n                .is_ok(),\n            \"Strict verification of a valid signature failed!\"\n        );\n        assert!(\n            signing_key\n                .verify_prehashed(prehashed_good3.clone(), Some(context), &bad_sig)\n                .is_err(),\n            \"Verification of a signature on a different message passed!\"\n        );\n        assert!(\n            verifying_key\n                .verify_prehashed_strict(prehashed_good3, Some(context), &bad_sig)\n                .is_err(),\n            \"Strict verification of a signature on a different message passed!\"\n        );\n        assert!(\n            signing_key\n                .verify_prehashed(prehashed_bad2.clone(), Some(context), &good_sig)\n                .is_err(),\n            \"Verification of a signature on a different message passed!\"\n        );\n        assert!(\n            verifying_key\n                .verify_prehashed_strict(prehashed_bad2, Some(context), &good_sig)\n                .is_err(),\n            \"Strict verification of a signature on a different message passed!\"\n        );\n    }\n\n    #[cfg(feature = \"batch\")]\n    #[test]\n    fn verify_batch_seven_signatures() {\n        let messages: [&[u8]; 7] = [\n            b\"Watch closely everyone, I'm going to show you how to kill a god.\",\n            b\"I'm not a cryptographer I just encrypt a lot.\",\n            b\"Still not a cryptographer.\",\n            b\"This is a test of the tsunami alert system. This is only a test.\",\n            b\"Fuck dumbin' it down, spit ice, skip jewellery: Molotov cocktails on me like accessories.\",\n            b\"Hey, I never cared about your bucks, so if I run up with a mask on, probably got a gas can too.\",\n            b\"And I'm not here to fill 'er up. Nope, we came to riot, here to incite, we don't want any of your stuff.\", ];\n        let mut csprng = OsRng.unwrap_err();\n        let mut signing_keys: Vec<SigningKey> = Vec::new();\n        let mut signatures: Vec<Signature> = Vec::new();\n\n        for msg in messages {\n            let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n            signatures.push(signing_key.sign(msg));\n            signing_keys.push(signing_key);\n        }\n        let verifying_keys: Vec<VerifyingKey> =\n            signing_keys.iter().map(|key| key.verifying_key()).collect();\n\n        let result = verify_batch(&messages, &signatures, &verifying_keys);\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn public_key_hash_trait_check() {\n        let mut csprng = OsRng.unwrap_err();\n        let secret: SigningKey = SigningKey::generate(&mut csprng);\n        let public_from_secret: VerifyingKey = (&secret).into();\n\n        let mut m = HashMap::new();\n        m.insert(public_from_secret, \"Example_Public_Key\");\n\n        m.insert(public_from_secret, \"Updated Value\");\n\n        let (k, &v) = m.get_key_value(&public_from_secret).unwrap();\n        assert_eq!(k, &public_from_secret);\n        assert_eq!(v, \"Updated Value\");\n        assert_eq!(m.len(), 1usize);\n\n        let second_secret: SigningKey = SigningKey::generate(&mut csprng);\n        let public_from_second_secret: VerifyingKey = (&second_secret).into();\n        assert_ne!(public_from_secret, public_from_second_secret);\n        m.insert(public_from_second_secret, \"Second public key\");\n\n        let (k, &v) = m.get_key_value(&public_from_second_secret).unwrap();\n        assert_eq!(k, &public_from_second_secret);\n        assert_eq!(v, \"Second public key\");\n        assert_eq!(m.len(), 2usize);\n    }\n\n    #[test]\n    fn montgomery_and_edwards_conversion() {\n        let mut rng = rand::rngs::OsRng.unwrap_err();\n        let signing_key = SigningKey::generate(&mut rng);\n        let verifying_key = signing_key.verifying_key();\n\n        let ed = verifying_key.to_edwards();\n\n        // Check that to_edwards and From return same result:\n        assert_eq!(ed, curve25519_dalek::EdwardsPoint::from(verifying_key));\n\n        // The verifying key serialization is simply the compressed Edwards point\n        assert_eq!(verifying_key.to_bytes(), ed.compress().0);\n\n        // Check that modulo sign, to_montgomery().to_edwards() returns the original point\n        let monty = verifying_key.to_montgomery();\n        let via_monty0 = monty.to_edwards(0).unwrap();\n        let via_monty1 = monty.to_edwards(1).unwrap();\n\n        assert!(via_monty0 != via_monty1);\n        assert!(ed == via_monty0 || ed == via_monty1);\n    }\n}\n\n#[cfg(all(test, feature = \"serde\"))]\n#[derive(Debug, serde::Serialize, serde::Deserialize)]\n#[serde(crate = \"serde\")]\nstruct Demo {\n    signing_key: SigningKey,\n}\n\n#[cfg(all(test, feature = \"serde\"))]\nmod serialisation {\n    #![allow(clippy::zero_prefixed_literal)]\n\n    use super::*;\n\n    // The size for bincode to serialize the length of a byte array.\n    static BINCODE_INT_LENGTH: usize = 8;\n\n    static PUBLIC_KEY_BYTES: [u8; PUBLIC_KEY_LENGTH] = [\n        130, 039, 155, 015, 062, 076, 188, 063, 124, 122, 026, 251, 233, 253, 225, 220, 014, 041,\n        166, 120, 108, 035, 254, 077, 160, 083, 172, 058, 219, 042, 086, 120,\n    ];\n\n    static SECRET_KEY_BYTES: [u8; SECRET_KEY_LENGTH] = [\n        062, 070, 027, 163, 092, 182, 011, 003, 077, 234, 098, 004, 011, 127, 079, 228, 243, 187,\n        150, 073, 201, 137, 076, 022, 085, 251, 152, 002, 241, 042, 072, 054,\n    ];\n\n    /// Signature with the above signing_key of a blank message.\n    static SIGNATURE_BYTES: [u8; SIGNATURE_LENGTH] = [\n        010, 126, 151, 143, 157, 064, 047, 001, 196, 140, 179, 058, 226, 152, 018, 102, 160, 123,\n        080, 016, 210, 086, 196, 028, 053, 231, 012, 157, 169, 019, 158, 063, 045, 154, 238, 007,\n        053, 185, 227, 229, 079, 108, 213, 080, 124, 252, 084, 167, 216, 085, 134, 144, 129, 149,\n        041, 081, 063, 120, 126, 100, 092, 059, 050, 011,\n    ];\n\n    #[test]\n    fn serialize_deserialize_signature_bincode() {\n        let signature: Signature = Signature::from_bytes(&SIGNATURE_BYTES);\n        let encoded_signature: Vec<u8> = bincode::serialize(&signature).unwrap();\n        let decoded_signature: Signature = bincode::deserialize(&encoded_signature).unwrap();\n\n        assert_eq!(signature, decoded_signature);\n    }\n\n    #[test]\n    fn serialize_deserialize_signature_json() {\n        let signature: Signature = Signature::from_bytes(&SIGNATURE_BYTES);\n        let encoded_signature = serde_json::to_string(&signature).unwrap();\n        let decoded_signature: Signature = serde_json::from_str(&encoded_signature).unwrap();\n\n        assert_eq!(signature, decoded_signature);\n    }\n\n    #[test]\n    fn serialize_deserialize_verifying_key_bincode() {\n        let verifying_key: VerifyingKey = VerifyingKey::from_bytes(&PUBLIC_KEY_BYTES).unwrap();\n        let encoded_verifying_key: Vec<u8> = bincode::serialize(&verifying_key).unwrap();\n        let decoded_verifying_key: VerifyingKey =\n            bincode::deserialize(&encoded_verifying_key).unwrap();\n\n        assert_eq!(\n            &PUBLIC_KEY_BYTES[..],\n            &encoded_verifying_key[encoded_verifying_key.len() - PUBLIC_KEY_LENGTH..]\n        );\n        assert_eq!(verifying_key, decoded_verifying_key);\n    }\n\n    #[test]\n    fn serialize_deserialize_verifying_key_json() {\n        let verifying_key: VerifyingKey = VerifyingKey::from_bytes(&PUBLIC_KEY_BYTES).unwrap();\n        let encoded_verifying_key = serde_json::to_string(&verifying_key).unwrap();\n        let decoded_verifying_key: VerifyingKey =\n            serde_json::from_str(&encoded_verifying_key).unwrap();\n\n        assert_eq!(verifying_key, decoded_verifying_key);\n    }\n\n    #[test]\n    fn serialize_deserialize_verifying_key_json_too_long() {\n        // derived from `serialize_deserialize_verifying_key_json` test\n        // trailing zero elements makes key too long (34 bytes)\n        let encoded_verifying_key_too_long = \"[130,39,155,15,62,76,188,63,124,122,26,251,233,253,225,220,14,41,166,120,108,35,254,77,160,83,172,58,219,42,86,120,0,0]\";\n        let de_err = serde_json::from_str::<VerifyingKey>(encoded_verifying_key_too_long)\n            .unwrap_err()\n            .to_string();\n        assert!(\n            de_err.contains(\"invalid length 34\"),\n            \"expected invalid length error, got: {de_err}\",\n        );\n    }\n\n    #[test]\n    fn serialize_deserialize_verifying_key_json_too_short() {\n        // derived from `serialize_deserialize_verifying_key_json` test\n        let encoded_verifying_key_too_long = \"[130,39,155,15]\";\n        let de_err = serde_json::from_str::<VerifyingKey>(encoded_verifying_key_too_long)\n            .unwrap_err()\n            .to_string();\n        assert!(\n            de_err.contains(\"invalid length 4\"),\n            \"expected invalid length error, got: {de_err}\"\n        );\n    }\n\n    #[test]\n    fn serialize_deserialize_signing_key_bincode() {\n        let signing_key = SigningKey::from_bytes(&SECRET_KEY_BYTES);\n        let encoded_signing_key: Vec<u8> = bincode::serialize(&signing_key).unwrap();\n        let decoded_signing_key: SigningKey = bincode::deserialize(&encoded_signing_key).unwrap();\n\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..SECRET_KEY_LENGTH {\n            assert_eq!(SECRET_KEY_BYTES[i], decoded_signing_key.to_bytes()[i]);\n        }\n    }\n\n    #[test]\n    fn serialize_deserialize_signing_key_json() {\n        let signing_key = SigningKey::from_bytes(&SECRET_KEY_BYTES);\n        let encoded_signing_key = serde_json::to_string(&signing_key).unwrap();\n        let decoded_signing_key: SigningKey = serde_json::from_str(&encoded_signing_key).unwrap();\n\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..SECRET_KEY_LENGTH {\n            assert_eq!(SECRET_KEY_BYTES[i], decoded_signing_key.to_bytes()[i]);\n        }\n    }\n\n    #[test]\n    fn serialize_deserialize_signing_key_json_too_long() {\n        // derived from `serialize_deserialize_signing_key_json` test\n        // trailing zero elements makes key too long (34 bytes)\n        let encoded_signing_key_too_long = \"[62,70,27,163,92,182,11,3,77,234,98,4,11,127,79,228,243,187,150,73,201,137,76,22,85,251,152,2,241,42,72,54,0,0]\";\n        let de_err = serde_json::from_str::<SigningKey>(encoded_signing_key_too_long)\n            .unwrap_err()\n            .to_string();\n        assert!(\n            de_err.contains(\"invalid length 34\"),\n            \"expected invalid length error, got: {de_err}\",\n        );\n    }\n\n    #[test]\n    fn serialize_deserialize_signing_key_json_too_short() {\n        // derived from `serialize_deserialize_signing_key_json` test\n        let encoded_signing_key_too_long = \"[62,70,27,163]\";\n        let de_err = serde_json::from_str::<SigningKey>(encoded_signing_key_too_long)\n            .unwrap_err()\n            .to_string();\n        assert!(\n            de_err.contains(\"invalid length 4\"),\n            \"expected invalid length error, got: {de_err}\"\n        );\n    }\n\n    #[test]\n    fn serialize_deserialize_signing_key_toml() {\n        let demo = Demo {\n            signing_key: SigningKey::from_bytes(&SECRET_KEY_BYTES),\n        };\n\n        println!(\"\\n\\nWrite to toml\");\n        let demo_toml = toml::to_string(&demo).unwrap();\n        println!(\"{}\", demo_toml);\n        let demo_toml_rebuild: Result<Demo, _> = toml::from_str(&demo_toml);\n        println!(\"{:?}\", demo_toml_rebuild);\n    }\n\n    #[test]\n    fn serialize_verifying_key_size() {\n        let verifying_key: VerifyingKey = VerifyingKey::from_bytes(&PUBLIC_KEY_BYTES).unwrap();\n        assert_eq!(\n            bincode::serialized_size(&verifying_key).unwrap() as usize,\n            BINCODE_INT_LENGTH + PUBLIC_KEY_LENGTH\n        );\n    }\n\n    #[test]\n    fn serialize_signature_size() {\n        let signature: Signature = Signature::from_bytes(&SIGNATURE_BYTES);\n        assert_eq!(\n            bincode::serialized_size(&signature).unwrap() as usize,\n            SIGNATURE_LENGTH\n        );\n    }\n\n    #[test]\n    fn serialize_signing_key_size() {\n        let signing_key = SigningKey::from_bytes(&SECRET_KEY_BYTES);\n        assert_eq!(\n            bincode::serialized_size(&signing_key).unwrap() as usize,\n            BINCODE_INT_LENGTH + SECRET_KEY_LENGTH\n        );\n    }\n}\n",
    "filename": "ed25519-dalek/tests/ed25519.rs",
    "filepath": null,
    "folder_id": 15846,
    "user_id": 460154
  },
  "63669": {
    "text": "use ed25519::signature::Verifier;\nuse ed25519_dalek::{Signature, VerifyingKey};\n\nuse serde::{Deserialize, Deserializer, de::Error as SError};\nuse std::{collections::BTreeSet as Set, fs::File};\n\n/// The set of edge cases that [`VerifyingKey::verify()`] permits.\nconst VERIFY_ALLOWED_EDGECASES: &[Flag] = &[\n    Flag::LowOrderA,\n    Flag::LowOrderR,\n    Flag::NonCanonicalA,\n    Flag::LowOrderComponentA,\n    Flag::LowOrderComponentR,\n    // `ReencodedK` is not actually permitted by `verify()`, but it looks that way in the tests\n    // because it sometimes occurs with a low-order A. 1/8 of the time, the resulting signature\n    // will be identical the one made with a normal k. find_validation_criteria shows that indeed\n    // this occurs 10/58 of the time\n    Flag::ReencodedK,\n];\n\n/// The set of edge cases that [`VerifyingKey::verify_strict()`] permits\nconst VERIFY_STRICT_ALLOWED_EDGECASES: &[Flag] =\n    &[Flag::LowOrderComponentA, Flag::LowOrderComponentR];\n\n/// Each variant describes a specific edge case that can occur in an Ed25519 signature. Refer to\n/// the test vector [README][] for more info.\n///\n/// [README]: https://github.com/C2SP/CCTV/blob/5ea85644bd035c555900a2f707f7e4c31ea65ced/ed25519vectors/README.md\n#[derive(Deserialize, Debug, Copy, Clone, PartialOrd, Ord, Eq, PartialEq)]\nenum Flag {\n    #[serde(rename = \"low_order\")]\n    LowOrder,\n    #[serde(rename = \"low_order_A\")]\n    LowOrderA,\n    #[serde(rename = \"low_order_R\")]\n    LowOrderR,\n    #[serde(rename = \"non_canonical_A\")]\n    NonCanonicalA,\n    #[serde(rename = \"non_canonical_R\")]\n    NonCanonicalR,\n    #[serde(rename = \"low_order_component_A\")]\n    LowOrderComponentA,\n    #[serde(rename = \"low_order_component_R\")]\n    LowOrderComponentR,\n    #[serde(rename = \"low_order_residue\")]\n    LowOrderResidue,\n    #[serde(rename = \"reencoded_k\")]\n    ReencodedK,\n}\n\n/// This is an intermediate representation between JSON and TestVector\n#[derive(Deserialize)]\nstruct IntermediateTestVector {\n    number: usize,\n    #[serde(deserialize_with = \"bytes_from_hex\", rename = \"key\")]\n    pubkey: Vec<u8>,\n    #[serde(deserialize_with = \"bytes_from_hex\")]\n    sig: Vec<u8>,\n    msg: String,\n    flags: Option<Set<Flag>>,\n}\n\n/// The test vector struct from [CCTV][]. `sig` may or may not be a valid signature of `msg` with\n/// respect to `pubkey`, depending on the verification function's validation criteria. `flags`\n/// describes all the edge cases which this test vector falls into.\n///\n/// [CCTV]: https://github.com/C2SP/CCTV/tree/5ea85644bd035c555900a2f707f7e4c31ea65ced/ed25519vectors\nstruct TestVector {\n    number: usize,\n    pubkey: VerifyingKey,\n    sig: Signature,\n    msg: Vec<u8>,\n    flags: Set<Flag>,\n}\n\nimpl From<IntermediateTestVector> for TestVector {\n    fn from(tv: IntermediateTestVector) -> Self {\n        let number = tv.number;\n        let pubkey = {\n            let mut buf = [0u8; 32];\n            buf.copy_from_slice(&tv.pubkey);\n            VerifyingKey::from_bytes(&buf).unwrap()\n        };\n        let sig = {\n            let mut buf = [0u8; 64];\n            buf.copy_from_slice(&tv.sig);\n            Signature::from_bytes(&buf)\n        };\n        let msg = tv.msg.as_bytes().to_vec();\n\n        // Unwrap the Option<Set<Flag>>\n        let flags = tv.flags.unwrap_or_default();\n\n        Self {\n            number,\n            pubkey,\n            sig,\n            msg,\n            flags,\n        }\n    }\n}\n\n// Tells serde how to deserialize bytes from hex\nfn bytes_from_hex<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    let mut hex_str = String::deserialize(deserializer)?;\n    // Prepend a 0 if it's not even length\n    if hex_str.len() % 2 == 1 {\n        hex_str.insert(0, '0');\n    }\n    hex::decode(hex_str).map_err(|e| SError::custom(format!(\"{:?}\", e)))\n}\n\nfn get_test_vectors() -> impl Iterator<Item = TestVector> {\n    let f = File::open(\"VALIDATIONVECTORS\").expect(\n        \"This test is only available when the code has been cloned from the git repository, since\n        the VALIDATIONVECTORS file is large and is therefore not included within the distributed \\\n        crate.\",\n    );\n\n    serde_json::from_reader::<_, Vec<IntermediateTestVector>>(f)\n        .unwrap()\n        .into_iter()\n        .map(TestVector::from)\n}\n\n/// Tests that the verify() and verify_strict() functions succeed only on test cases whose flags\n/// (i.e., edge cases it falls into) are a subset of VERIFY_ALLOWED_EDGECASES and\n/// VERIFY_STRICT_ALLOWED_EDGECASES, respectively\n#[test]\nfn check_validation_criteria() {\n    let verify_allowed_edgecases = Set::from_iter(VERIFY_ALLOWED_EDGECASES.to_vec());\n    let verify_strict_allowed_edgecases = Set::from_iter(VERIFY_STRICT_ALLOWED_EDGECASES.to_vec());\n\n    for TestVector {\n        number,\n        pubkey,\n        msg,\n        sig,\n        flags,\n    } in get_test_vectors()\n    {\n        // If all the verify-permitted flags here are ones we permit, then verify() should succeed.\n        // Otherwise, it should not.\n        let success = pubkey.verify(&msg, &sig).is_ok();\n        if flags.is_subset(&verify_allowed_edgecases) {\n            assert!(success, \"verify() expected success in testcase #{number}\",);\n        } else {\n            assert!(!success, \"verify() expected failure in testcase #{number}\",);\n        }\n\n        // If all the verify_strict-permitted flags here are ones we permit, then verify_strict()\n        // should succeed. Otherwise, it should not.\n        let success = pubkey.verify_strict(&msg, &sig).is_ok();\n        if flags.is_subset(&verify_strict_allowed_edgecases) {\n            assert!(\n                success,\n                \"verify_strict() expected success in testcase #{number}\",\n            );\n        } else {\n            assert!(\n                !success,\n                \"verify_strict() expected failure in testcase #{number}\",\n            );\n        }\n    }\n}\n\n/// Prints the flags that are consistently permitted by verify() and verify_strict()\n#[test]\nfn find_validation_criteria() {\n    let mut verify_allowed_edgecases = Set::new();\n    let mut verify_strict_allowed_edgecases = Set::new();\n\n    // Counts the number of times a signature with a re-encoded k and a low-order A verified. This\n    // happens with 1/8 probability, assuming the usual verification equation(s).\n    let mut num_lucky_reencoded_k = 0;\n    let mut num_reencoded_k = 0;\n\n    for TestVector {\n        number: _,\n        pubkey,\n        msg,\n        sig,\n        flags,\n    } in get_test_vectors()\n    {\n        // If verify() was a success, add all the associated flags to verify-permitted set\n        let success = pubkey.verify(&msg, &sig).is_ok();\n\n        // If this is ReencodedK && LowOrderA, log some statistics\n        if flags.contains(&Flag::ReencodedK) && flags.contains(&Flag::LowOrderA) {\n            num_reencoded_k += 1;\n            num_lucky_reencoded_k += success as u8;\n        }\n\n        if success {\n            for flag in &flags {\n                // Don't count re-encoded k when A is low-order. This is because the\n                // re-encoded k might be a multiple of 8 by accident\n                if *flag == Flag::ReencodedK && flags.contains(&Flag::LowOrderA) {\n                    continue;\n                } else {\n                    verify_allowed_edgecases.insert(*flag);\n                }\n            }\n        }\n\n        // If verify_strict() was a success, add all the associated flags to\n        // verify_strict-permitted set\n        let success = pubkey.verify_strict(&msg, &sig).is_ok();\n        if success {\n            for flag in &flags {\n                verify_strict_allowed_edgecases.insert(*flag);\n            }\n        }\n    }\n\n    println!(\"VERIFY_ALLOWED_EDGECASES: {:?}\", verify_allowed_edgecases);\n    println!(\n        \"VERIFY_STRICT_ALLOWED_EDGECASES: {:?}\",\n        verify_strict_allowed_edgecases\n    );\n    println!(\n        \"re-encoded k && low-order A yielded a valid signature {}/{} of the time\",\n        num_lucky_reencoded_k, num_reencoded_k\n    );\n}\n",
    "filename": "ed25519-dalek/tests/validation_criteria.rs",
    "filepath": null,
    "folder_id": 15846,
    "user_id": 460154
  },
  "63670": {
    "text": "//! PKCS#8 private key and SPKI public key tests.\n//!\n//! These are standard formats for storing public and private keys, defined in\n//! RFC5958 (PKCS#8) and RFC5280 (SPKI).\n\n#![cfg(feature = \"pkcs8\")]\nuse ed25519_dalek::pkcs8::{DecodePrivateKey, DecodePublicKey};\nuse ed25519_dalek::{SigningKey, VerifyingKey};\nuse hex_literal::hex;\n\n#[cfg(feature = \"alloc\")]\nuse ed25519_dalek::pkcs8::{EncodePrivateKey, EncodePublicKey};\n\n#[cfg(all(feature = \"alloc\", feature = \"pkcs8\"))]\nuse ed25519_dalek::pkcs8::spki::DynSignatureAlgorithmIdentifier;\n\n/// Ed25519 PKCS#8 v1 private key encoded as ASN.1 DER.\nconst PKCS8_V1_DER: &[u8] = include_bytes!(\"examples/pkcs8-v1.der\");\n\n/// Ed25519 PKCS#8 v2 private key + public key encoded as ASN.1 DER.\nconst PKCS8_V2_DER: &[u8] = include_bytes!(\"examples/pkcs8-v2.der\");\n\n/// Ed25519 SubjectVerifyingKeyInfo encoded as ASN.1 DER.\nconst PUBLIC_KEY_DER: &[u8] = include_bytes!(\"examples/pubkey.der\");\n\n/// Secret key bytes.\n///\n/// Extracted with:\n/// $ openssl asn1parse -inform der -in tests/examples/pkcs8-v1.der\nconst SK_BYTES: [u8; 32] = hex!(\"D4EE72DBF913584AD5B6D8F1F769F8AD3AFE7C28CBF1D4FBE097A88F44755842\");\n\n/// Public key bytes.\nconst PK_BYTES: [u8; 32] = hex!(\"19BF44096984CDFE8541BAC167DC3B96C85086AA30B6B6CB0C5C38AD703166E1\");\n\n#[test]\nfn decode_pkcs8_v1() {\n    let keypair = SigningKey::from_pkcs8_der(PKCS8_V1_DER).unwrap();\n    assert_eq!(SK_BYTES, keypair.to_bytes());\n    assert_eq!(PK_BYTES, keypair.verifying_key().to_bytes());\n}\n\n#[test]\nfn decode_pkcs8_v2() {\n    let keypair = SigningKey::from_pkcs8_der(PKCS8_V2_DER).unwrap();\n    assert_eq!(SK_BYTES, keypair.to_bytes());\n    assert_eq!(PK_BYTES, keypair.verifying_key().to_bytes());\n}\n\n#[test]\nfn decode_verifying_key() {\n    let verifying_key = VerifyingKey::from_public_key_der(PUBLIC_KEY_DER).unwrap();\n    assert_eq!(PK_BYTES, verifying_key.to_bytes());\n}\n\n#[test]\n#[cfg(feature = \"alloc\")]\nfn encode_pkcs8() {\n    let keypair = SigningKey::from_bytes(&SK_BYTES);\n    let pkcs8_key = keypair.to_pkcs8_der().unwrap();\n\n    let keypair2 = SigningKey::from_pkcs8_der(pkcs8_key.as_bytes()).unwrap();\n    assert_eq!(keypair.to_bytes(), keypair2.to_bytes());\n}\n\n#[test]\n#[cfg(feature = \"alloc\")]\nfn encode_verifying_key() {\n    let verifying_key = VerifyingKey::from_bytes(&PK_BYTES).unwrap();\n    let verifying_key_der = verifying_key.to_public_key_der().unwrap();\n\n    let verifying_key2 = VerifyingKey::from_public_key_der(verifying_key_der.as_bytes()).unwrap();\n    assert_eq!(verifying_key, verifying_key2);\n}\n\n#[test]\n#[cfg(feature = \"alloc\")]\nfn get_algo_identifier() {\n    let verifying_key = VerifyingKey::from_public_key_der(PUBLIC_KEY_DER).unwrap();\n    let identifier = verifying_key.signature_algorithm_identifier().unwrap();\n    assert!(identifier.parameters.is_none()); // According to rfc8410 this must be None\n    assert_eq!(identifier.oid, ed25519::pkcs8::ALGORITHM_OID);\n\n    let signing_key = SigningKey::from_bytes(&SK_BYTES);\n    let identifier = signing_key.signature_algorithm_identifier().unwrap();\n    assert!(identifier.parameters.is_none()); // According to rfc8410 this must be None\n    assert_eq!(identifier.oid, ed25519::pkcs8::ALGORITHM_OID);\n}\n",
    "filename": "ed25519-dalek/tests/pkcs8.rs",
    "filepath": null,
    "folder_id": 15846,
    "user_id": 460154
  },
  "63674": {
    "text": "//! Tests for converting Ed25519 keys into X25519 (Montgomery form) keys.\n\nuse curve25519_dalek::scalar::{Scalar, clamp_integer};\nuse ed25519_dalek::SigningKey;\nuse hex_literal::hex;\nuse sha2::{Digest, Sha512};\nuse x25519_dalek::{PublicKey as XPublicKey, StaticSecret as XStaticSecret};\n\n/// Tests that X25519 Diffie-Hellman works when using keys converted from Ed25519.\n// TODO: generate test vectors using another implementation of Ed25519->X25519\n#[test]\nfn ed25519_to_x25519_dh() {\n    // Keys from RFC8032 test vectors (from section 7.1)\n    let ed_secret_key_a = hex!(\"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60\");\n    let ed_secret_key_b = hex!(\"4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb\");\n\n    let ed_signing_key_a = SigningKey::from_bytes(&ed_secret_key_a);\n    let ed_signing_key_b = SigningKey::from_bytes(&ed_secret_key_b);\n\n    // Create an x25519 static secret from the ed25519 signing key\n    let scalar_bytes_a = ed_signing_key_a.to_scalar_bytes();\n    let scalar_bytes_b = ed_signing_key_b.to_scalar_bytes();\n    let x_static_secret_a = XStaticSecret::from(scalar_bytes_a);\n    let x_static_secret_b = XStaticSecret::from(scalar_bytes_b);\n\n    // Compute the secret scalars too\n    let scalar_a = ed_signing_key_a.to_scalar();\n    let scalar_b = ed_signing_key_b.to_scalar();\n\n    // Compare the scalar bytes to the first 32 bytes of SHA-512(secret_key). We have to clamp and\n    // reduce the SHA-512 output because that's what the spec does before using the scalars for\n    // anything.\n    assert_eq!(scalar_bytes_a, &Sha512::digest(ed_secret_key_a)[..32]);\n    assert_eq!(scalar_bytes_b, &Sha512::digest(ed_secret_key_b)[..32]);\n\n    // Compare the scalar with the clamped and reduced scalar bytes\n    assert_eq!(\n        scalar_a,\n        Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes_a))\n    );\n    assert_eq!(\n        scalar_b,\n        Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes_b))\n    );\n\n    let x_public_key_a = XPublicKey::from(&x_static_secret_a);\n    let x_public_key_b = XPublicKey::from(&x_static_secret_b);\n    assert_eq!(\n        x_public_key_a.to_bytes(),\n        hex!(\"d85e07ec22b0ad881537c2f44d662d1a143cf830c57aca4305d85c7a90f6b62e\")\n    );\n    assert_eq!(\n        x_public_key_b.to_bytes(),\n        hex!(\"25c704c594b88afc00a76b69d1ed2b984d7e22550f3ed0802d04fbcd07d38d47\")\n    );\n\n    // Test the claim made in the comments of SigningKey::to_scalar_bytes, i.e., that the resulting\n    // scalar is a valid private key for the x25519 pubkey represented by\n    // `sk.verifying_key().to_montgomery()`\n    assert_eq!(\n        ed_signing_key_a.verifying_key().to_montgomery().as_bytes(),\n        x_public_key_a.as_bytes()\n    );\n    assert_eq!(\n        ed_signing_key_b.verifying_key().to_montgomery().as_bytes(),\n        x_public_key_b.as_bytes()\n    );\n\n    // Check that Diffie-Hellman works\n    let expected_shared_secret =\n        hex!(\"5166f24a6918368e2af831a4affadd97af0ac326bdf143596c045967cc00230e\");\n    assert_eq!(\n        x_static_secret_a.diffie_hellman(&x_public_key_b).to_bytes(),\n        expected_shared_secret,\n    );\n    assert_eq!(\n        x_static_secret_b.diffie_hellman(&x_public_key_a).to_bytes(),\n        expected_shared_secret,\n    );\n}\n",
    "filename": "ed25519-dalek/tests/x25519.rs",
    "filepath": null,
    "folder_id": 15846,
    "user_id": 460154
  },
  "63675": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2018-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\nuse criterion::{Criterion, criterion_group};\n\nmod ed25519_benches {\n    use super::*;\n    use ed25519_dalek::Signature;\n    use ed25519_dalek::Signer;\n    use ed25519_dalek::SigningKey;\n    use rand::prelude::ThreadRng;\n    use rand::rng;\n\n    fn sign(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n\n        c.bench_function(\"Ed25519 signing\", move |b| b.iter(|| keypair.sign(msg)));\n    }\n\n    fn verify(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n        let sig: Signature = keypair.sign(msg);\n\n        c.bench_function(\"Ed25519 signature verification\", move |b| {\n            b.iter(|| keypair.verify(msg, &sig))\n        });\n    }\n\n    fn verify_strict(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n        let keypair: SigningKey = SigningKey::generate(&mut csprng);\n        let msg: &[u8] = b\"\";\n        let sig: Signature = keypair.sign(msg);\n\n        c.bench_function(\"Ed25519 strict signature verification\", move |b| {\n            b.iter(|| keypair.verify_strict(msg, &sig))\n        });\n    }\n\n    #[cfg(feature = \"batch\")]\n    fn verify_batch_signatures(c: &mut Criterion) {\n        use ed25519_dalek::verify_batch;\n\n        static BATCH_SIZES: [usize; 8] = [4, 8, 16, 32, 64, 96, 128, 256];\n\n        // Benchmark batch verification for all the above batch sizes\n        let mut group = c.benchmark_group(\"Ed25519 batch signature verification\");\n        for size in BATCH_SIZES {\n            let name = format!(\"size={size}\");\n            group.bench_function(name, |b| {\n                let mut csprng: ThreadRng = rng();\n                let keypairs: Vec<SigningKey> = (0..size)\n                    .map(|_| SigningKey::generate(&mut csprng))\n                    .collect();\n                let msg: &[u8] = b\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n                let messages: Vec<&[u8]> = (0..size).map(|_| msg).collect();\n                let signatures: Vec<Signature> = keypairs.iter().map(|key| key.sign(msg)).collect();\n                let verifying_keys: Vec<_> =\n                    keypairs.iter().map(|key| key.verifying_key()).collect();\n\n                b.iter(|| verify_batch(&messages[..], &signatures[..], &verifying_keys[..]));\n            });\n        }\n    }\n\n    // If the above function isn't defined, make a placeholder function\n    #[cfg(not(feature = \"batch\"))]\n    fn verify_batch_signatures(_: &mut Criterion) {}\n\n    fn key_generation(c: &mut Criterion) {\n        let mut csprng: ThreadRng = rng();\n\n        c.bench_function(\"Ed25519 keypair generation\", move |b| {\n            b.iter(|| SigningKey::generate(&mut csprng))\n        });\n    }\n\n    criterion_group! {\n        name = ed25519_benches;\n        config = Criterion::default();\n        targets =\n            sign,\n            verify,\n            verify_strict,\n            verify_batch_signatures,\n            key_generation,\n    }\n}\n\ncriterion::criterion_main!(ed25519_benches::ed25519_benches);\n",
    "filename": "ed25519-dalek/benches/ed25519_benchmarks.rs",
    "filepath": null,
    "folder_id": 15848,
    "user_id": 460154
  },
  "63679": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2017-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\n//! ed25519 public keys.\n\nuse core::fmt::Debug;\nuse core::hash::{Hash, Hasher};\n\nuse curve25519_dalek::{\n    digest::{Digest, array::typenum::U64},\n    edwards::{CompressedEdwardsY, EdwardsPoint},\n    montgomery::MontgomeryPoint,\n    scalar::Scalar,\n};\n\nuse ed25519::signature::{MultipartVerifier, Verifier};\n\nuse sha2::Sha512;\n\n#[cfg(feature = \"pkcs8\")]\nuse ed25519::pkcs8;\n\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[cfg(feature = \"digest\")]\nuse crate::context::Context;\n#[cfg(feature = \"digest\")]\nuse signature::DigestVerifier;\n\nuse crate::{\n    constants::PUBLIC_KEY_LENGTH,\n    errors::{InternalError, SignatureError},\n    hazmat::ExpandedSecretKey,\n    signature::InternalSignature,\n    signing::SigningKey,\n};\n\n#[cfg(feature = \"hazmat\")]\nmod stream;\n#[cfg(feature = \"hazmat\")]\npub use self::stream::StreamVerifier;\n\n/// An ed25519 public key.\n///\n/// # Note\n///\n/// The `Eq` and `Hash` impls here use the compressed Edwards y encoding, _not_ the algebraic\n/// representation. This means if this `VerifyingKey` is non-canonically encoded, it will be\n/// considered unequal to the other equivalent encoding, despite the two representing the same\n/// point. More encoding details can be found\n/// [here](https://hdevalence.ca/blog/2020-10-04-its-25519am).\n/// If you want to make sure that signatures produced with respect to those sorts of public keys\n/// are rejected, use [`VerifyingKey::verify_strict`].\n// Invariant: VerifyingKey.1 is always the decompression of VerifyingKey.0\n#[derive(Copy, Clone, Default, Eq)]\npub struct VerifyingKey {\n    /// Serialized compressed Edwards-y point.\n    pub(crate) compressed: CompressedEdwardsY,\n\n    /// Decompressed Edwards point used for curve arithmetic operations.\n    pub(crate) point: EdwardsPoint,\n}\n\nimpl Debug for VerifyingKey {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"VerifyingKey({:?}), {:?})\", self.compressed, self.point)\n    }\n}\n\nimpl AsRef<[u8]> for VerifyingKey {\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}\n\nimpl Hash for VerifyingKey {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.as_bytes().hash(state);\n    }\n}\n\nimpl PartialEq<VerifyingKey> for VerifyingKey {\n    fn eq(&self, other: &VerifyingKey) -> bool {\n        self.as_bytes() == other.as_bytes()\n    }\n}\n\nimpl From<&ExpandedSecretKey> for VerifyingKey {\n    /// Derive this public key from its corresponding `ExpandedSecretKey`.\n    fn from(expanded_secret_key: &ExpandedSecretKey) -> VerifyingKey {\n        VerifyingKey::from(EdwardsPoint::mul_base(&expanded_secret_key.scalar))\n    }\n}\n\nimpl From<&SigningKey> for VerifyingKey {\n    fn from(signing_key: &SigningKey) -> VerifyingKey {\n        signing_key.verifying_key()\n    }\n}\n\nimpl From<EdwardsPoint> for VerifyingKey {\n    fn from(point: EdwardsPoint) -> VerifyingKey {\n        VerifyingKey {\n            point,\n            compressed: point.compress(),\n        }\n    }\n}\n\nimpl VerifyingKey {\n    /// Convert this public key to a byte array.\n    #[inline]\n    pub fn to_bytes(&self) -> [u8; PUBLIC_KEY_LENGTH] {\n        self.compressed.to_bytes()\n    }\n\n    /// View this public key as a byte array.\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8; PUBLIC_KEY_LENGTH] {\n        &(self.compressed).0\n    }\n\n    /// Construct a `VerifyingKey` from a slice of bytes.\n    ///\n    /// Verifies the point is valid under [ZIP-215] rules. RFC 8032 / NIST point validation criteria\n    /// are currently unsupported (see [dalek-cryptography/curve25519-dalek#626]).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use ed25519_dalek::VerifyingKey;\n    /// use ed25519_dalek::PUBLIC_KEY_LENGTH;\n    /// use ed25519_dalek::SignatureError;\n    ///\n    /// # fn doctest() -> Result<VerifyingKey, SignatureError> {\n    /// let public_key_bytes: [u8; PUBLIC_KEY_LENGTH] = [\n    ///    215,  90, 152,   1, 130, 177,  10, 183, 213,  75, 254, 211, 201, 100,   7,  58,\n    ///     14, 225, 114, 243, 218, 166,  35,  37, 175,   2,  26, 104, 247,   7,   81, 26];\n    ///\n    /// let public_key = VerifyingKey::from_bytes(&public_key_bytes)?;\n    /// #\n    /// # Ok(public_key)\n    /// # }\n    /// #\n    /// # fn main() {\n    /// #     doctest();\n    /// # }\n    /// ```\n    ///\n    /// # Returns\n    ///\n    /// A `Result` whose okay value is an EdDSA `VerifyingKey` or whose error value\n    /// is a `SignatureError` describing the error that occurred.\n    ///\n    /// [ZIP-215]: https://zips.z.cash/zip-0215\n    /// [dalek-cryptography/curve25519-dalek#626]: https://github.com/dalek-cryptography/curve25519-dalek/issues/626\n    #[inline]\n    pub fn from_bytes(bytes: &[u8; PUBLIC_KEY_LENGTH]) -> Result<VerifyingKey, SignatureError> {\n        let compressed = CompressedEdwardsY(*bytes);\n        let point = compressed\n            .decompress()\n            .ok_or(InternalError::PointDecompression)?;\n\n        // Invariant: VerifyingKey.1 is always the decompression of VerifyingKey.0\n        Ok(VerifyingKey { compressed, point })\n    }\n\n    /// Create a verifying context that can be used for Ed25519ph with\n    /// [`DigestVerifier`].\n    #[cfg(feature = \"digest\")]\n    pub fn with_context<'k, 'v>(\n        &'k self,\n        context_value: &'v [u8],\n    ) -> Result<Context<'k, 'v, Self>, SignatureError> {\n        Context::new(self, context_value)\n    }\n\n    /// Returns whether this is a _weak_ public key, i.e., if this public key has low order.\n    ///\n    /// A weak public key can be used to generate a signature that's valid for almost every\n    /// message. [`Self::verify_strict`] denies weak keys, but if you want to check for this\n    /// property before verification, then use this method.\n    pub fn is_weak(&self) -> bool {\n        self.point.is_small_order()\n    }\n\n    /// The ordinary non-batched Ed25519 verification check, rejecting non-canonical R values. (see\n    /// [`Self::RCompute`]). `CtxDigest` is the digest used to calculate the pseudorandomness\n    /// needed for signing. According to the spec, `CtxDigest = Sha512`.\n    ///\n    /// This definition is loose in its parameters so that end-users of the `hazmat` module can\n    /// change how the `ExpandedSecretKey` is calculated and which hash function to use.\n    #[allow(non_snake_case)]\n    pub(crate) fn raw_verify<CtxDigest>(\n        &self,\n        message: &[&[u8]],\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError>\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n    {\n        let signature = InternalSignature::try_from(signature)?;\n\n        let expected_R = RCompute::<CtxDigest>::compute(self, signature, None, message);\n        if expected_R == signature.R {\n            Ok(())\n        } else {\n            Err(InternalError::Verify.into())\n        }\n    }\n\n    /// The prehashed non-batched Ed25519 verification check, rejecting non-canonical R values.\n    /// (see [`Self::recompute_R`]). `CtxDigest` is the digest used to calculate the\n    /// pseudorandomness needed for signing. `MsgDigest` is the digest used to hash the signed\n    /// message. According to the spec, `MsgDigest = CtxDigest = Sha512`.\n    ///\n    /// This definition is loose in its parameters so that end-users of the `hazmat` module can\n    /// change how the `ExpandedSecretKey` is calculated and which hash function to use.\n    #[cfg(feature = \"digest\")]\n    #[allow(non_snake_case)]\n    pub(crate) fn raw_verify_prehashed<CtxDigest, MsgDigest>(\n        &self,\n        prehashed_message: MsgDigest,\n        context: Option<&[u8]>,\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError>\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n        MsgDigest: Digest<OutputSize = U64>,\n    {\n        let signature = InternalSignature::try_from(signature)?;\n\n        let ctx: &[u8] = context.unwrap_or(b\"\");\n        debug_assert!(\n            ctx.len() <= 255,\n            \"The context must not be longer than 255 octets.\"\n        );\n\n        let message = prehashed_message.finalize();\n\n        let expected_R = RCompute::<CtxDigest>::compute(self, signature, Some(ctx), &[&message]);\n\n        if expected_R == signature.R {\n            Ok(())\n        } else {\n            Err(InternalError::Verify.into())\n        }\n    }\n\n    /// Verify a `signature` on a `prehashed_message` using the Ed25519ph algorithm.\n    ///\n    /// # Inputs\n    ///\n    /// * `prehashed_message` is an instantiated hash digest with 512-bits of\n    ///   output which has had the message to be signed previously fed into its\n    ///   state.\n    /// * `context` is an optional context string, up to 255 bytes inclusive,\n    ///   which may be used to provide additional domain separation.  If not\n    ///   set, this will default to an empty string.\n    /// * `signature` is a purported Ed25519ph signature on the `prehashed_message`.\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the `signature` was a valid signature created by this\n    /// [`SigningKey`] on the `prehashed_message`.\n    ///\n    /// # Note\n    ///\n    /// The RFC only permits SHA-512 to be used for prehashing, i.e., `MsgDigest = Sha512`. This\n    /// function technically works, and is probably safe to use, with any secure hash function with\n    /// 512-bit digests, but anything outside of SHA-512 is NOT specification-compliant. We expose\n    /// [`crate::Sha512`] for user convenience.\n    #[cfg(feature = \"digest\")]\n    #[allow(non_snake_case)]\n    pub fn verify_prehashed<MsgDigest>(\n        &self,\n        prehashed_message: MsgDigest,\n        context: Option<&[u8]>,\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError>\n    where\n        MsgDigest: Digest<OutputSize = U64>,\n    {\n        self.raw_verify_prehashed::<Sha512, MsgDigest>(prehashed_message, context, signature)\n    }\n\n    /// Strictly verify a signature on a message with this keypair's public key.\n    ///\n    /// # On The (Multiple) Sources of Malleability in Ed25519 Signatures\n    ///\n    /// This version of verification is technically non-RFC8032 compliant.  The\n    /// following explains why.\n    ///\n    /// 1. Scalar Malleability\n    ///\n    /// The authors of the RFC explicitly stated that verification of an ed25519\n    /// signature must fail if the scalar `s` is not properly reduced mod $\\ell$:\n    ///\n    /// > To verify a signature on a message M using public key A, with F\n    /// > being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx or\n    /// > Ed25519ph is being used, C being the context, first split the\n    /// > signature into two 32-octet halves.  Decode the first half as a\n    /// > point R, and the second half as an integer S, in the range\n    /// > 0 <= s < L.  Decode the public key A as point A'.  If any of the\n    /// > decodings fail (including S being out of range), the signature is\n    /// > invalid.)\n    ///\n    /// All `verify_*()` functions within ed25519-dalek perform this check.\n    ///\n    /// 2. Point malleability\n    ///\n    /// The authors of the RFC added in a malleability check to step #3 in\n    /// §5.1.7, for small torsion components in the `R` value of the signature,\n    /// *which is not strictly required*, as they state:\n    ///\n    /// > Check the group equation \\[8\\]\\[S\\]B = \\[8\\]R + \\[8\\]\\[k\\]A'.  It's\n    /// > sufficient, but not required, to instead check \\[S\\]B = R + \\[k\\]A'.\n    ///\n    /// # History of Malleability Checks\n    ///\n    /// As originally defined (cf. the \"Malleability\" section in the README of\n    /// this repo), ed25519 signatures didn't consider *any* form of\n    /// malleability to be an issue.  Later the scalar malleability was\n    /// considered important.  Still later, particularly with interests in\n    /// cryptocurrency design and in unique identities (e.g. for Signal users,\n    /// Tor onion services, etc.), the group element malleability became a\n    /// concern.\n    ///\n    /// However, libraries had already been created to conform to the original\n    /// definition.  One well-used library in particular even implemented the\n    /// group element malleability check, *but only for batch verification*!\n    /// Which meant that even using the same library, a single signature could\n    /// verify fine individually, but suddenly, when verifying it with a bunch\n    /// of other signatures, the whole batch would fail!\n    ///\n    /// # \"Strict\" Verification\n    ///\n    /// This method performs *both* of the above signature malleability checks.\n    ///\n    /// It must be done as a separate method because one doesn't simply get to\n    /// change the definition of a cryptographic primitive ten years\n    /// after-the-fact with zero consideration for backwards compatibility in\n    /// hardware and protocols which have it already have the older definition\n    /// baked in.\n    ///\n    /// # Return\n    ///\n    /// Returns `Ok(())` if the signature is valid, and `Err` otherwise.\n    #[allow(non_snake_case)]\n    pub fn verify_strict(\n        &self,\n        message: &[u8],\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError> {\n        let signature = InternalSignature::try_from(signature)?;\n\n        let signature_R = signature\n            .R\n            .decompress()\n            .ok_or_else(|| SignatureError::from(InternalError::Verify))?;\n\n        // Logical OR is fine here as we're not trying to be constant time.\n        if signature_R.is_small_order() || self.point.is_small_order() {\n            return Err(InternalError::Verify.into());\n        }\n\n        let expected_R = RCompute::<Sha512>::compute(self, signature, None, &[message]);\n        if expected_R == signature.R {\n            Ok(())\n        } else {\n            Err(InternalError::Verify.into())\n        }\n    }\n\n    /// Constructs stream verifier with candidate `signature`.\n    ///\n    /// Useful for cases where the whole message is not available all at once, allowing the\n    /// internal signature state to be updated incrementally and verified at the end. In some cases,\n    /// this will reduce the need for additional allocations.\n    #[cfg(feature = \"hazmat\")]\n    pub fn verify_stream(\n        &self,\n        signature: &ed25519::Signature,\n    ) -> Result<StreamVerifier, SignatureError> {\n        let signature = InternalSignature::try_from(signature)?;\n        Ok(StreamVerifier::new(*self, signature))\n    }\n\n    /// Verify a `signature` on a `prehashed_message` using the Ed25519ph algorithm,\n    /// using strict signature checking as defined by [`Self::verify_strict`].\n    ///\n    /// # Inputs\n    ///\n    /// * `prehashed_message` is an instantiated hash digest with 512-bits of\n    ///   output which has had the message to be signed previously fed into its\n    ///   state.\n    /// * `context` is an optional context string, up to 255 bytes inclusive,\n    ///   which may be used to provide additional domain separation.  If not\n    ///   set, this will default to an empty string.\n    /// * `signature` is a purported Ed25519ph signature on the `prehashed_message`.\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the `signature` was a valid signature created by this\n    /// [`SigningKey`] on the `prehashed_message`.\n    ///\n    /// # Note\n    ///\n    /// The RFC only permits SHA-512 to be used for prehashing, i.e., `MsgDigest = Sha512`. This\n    /// function technically works, and is probably safe to use, with any secure hash function with\n    /// 512-bit digests, but anything outside of SHA-512 is NOT specification-compliant. We expose\n    /// [`crate::Sha512`] for user convenience.\n    #[cfg(feature = \"digest\")]\n    #[allow(non_snake_case)]\n    pub fn verify_prehashed_strict<MsgDigest>(\n        &self,\n        prehashed_message: MsgDigest,\n        context: Option<&[u8]>,\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError>\n    where\n        MsgDigest: Digest<OutputSize = U64>,\n    {\n        let signature = InternalSignature::try_from(signature)?;\n\n        let ctx: &[u8] = context.unwrap_or(b\"\");\n        debug_assert!(\n            ctx.len() <= 255,\n            \"The context must not be longer than 255 octets.\"\n        );\n\n        let signature_R = signature\n            .R\n            .decompress()\n            .ok_or_else(|| SignatureError::from(InternalError::Verify))?;\n\n        // Logical OR is fine here as we're not trying to be constant time.\n        if signature_R.is_small_order() || self.point.is_small_order() {\n            return Err(InternalError::Verify.into());\n        }\n\n        let message = prehashed_message.finalize();\n        let expected_R = RCompute::<Sha512>::compute(self, signature, Some(ctx), &[&message]);\n\n        if expected_R == signature.R {\n            Ok(())\n        } else {\n            Err(InternalError::Verify.into())\n        }\n    }\n\n    /// Convert this verifying key into Montgomery form.\n    ///\n    /// This can be used for performing X25519 Diffie-Hellman using Ed25519 keys. The output of\n    /// this function is a valid X25519 public key whose secret key is `sk.to_scalar_bytes()`,\n    /// where `sk` is a valid signing key for this `VerifyingKey`.\n    ///\n    /// # Note\n    ///\n    /// We do NOT recommend this usage of a signing/verifying key. Signing keys are usually\n    /// long-term keys, while keys used for key exchange should rather be ephemeral. If you can\n    /// help it, use a separate key for encryption.\n    ///\n    /// For more information on the security of systems which use the same keys for both signing\n    /// and Diffie-Hellman, see the paper\n    /// [On using the same key pair for Ed25519 and an X25519 based KEM](https://eprint.iacr.org/2021/509).\n    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        self.point.to_montgomery()\n    }\n\n    /// Return this verifying key in Edwards form.\n    pub fn to_edwards(&self) -> EdwardsPoint {\n        self.point\n    }\n}\n\n/// Helper for verification. Computes the _expected_ R component of the signature. The\n/// caller compares this to the real R component.\n/// This computes `H(R || A || M)` where `H` is the 512-bit hash function\n/// given by `CtxDigest` (this is SHA-512 in spec-compliant Ed25519).\n///\n/// For pre-hashed variants a `h` with the context already included can be provided.\n/// Note that this returns the compressed form of R and the caller does a byte comparison. This\n/// means that all our verification functions do not accept non-canonically encoded R values.\n/// See the validation criteria blog post for more details:\n///     https://hdevalence.ca/blog/2020-10-04-its-25519am\npub(crate) struct RCompute<CtxDigest> {\n    key: VerifyingKey,\n    signature: InternalSignature,\n    h: CtxDigest,\n}\n\n#[allow(non_snake_case)]\nimpl<CtxDigest> RCompute<CtxDigest>\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    /// If `prehash_ctx.is_some()`, this does the prehashed variant of the computation using its\n    /// contents.\n    pub(crate) fn compute(\n        key: &VerifyingKey,\n        signature: InternalSignature,\n        prehash_ctx: Option<&[u8]>,\n        message: &[&[u8]],\n    ) -> CompressedEdwardsY {\n        let mut c = Self::new(key, signature, prehash_ctx);\n        message.iter().for_each(|slice| c.update(slice));\n        c.finish()\n    }\n\n    pub(crate) fn new(\n        key: &VerifyingKey,\n        signature: InternalSignature,\n        prehash_ctx: Option<&[u8]>,\n    ) -> Self {\n        let R = &signature.R;\n        let A = &key.compressed;\n\n        let mut h = CtxDigest::new();\n        if let Some(c) = prehash_ctx {\n            h.update(b\"SigEd25519 no Ed25519 collisions\");\n            h.update([1]); // Ed25519ph\n            h.update([c.len() as u8]);\n            h.update(c);\n        }\n\n        h.update(R.as_bytes());\n        h.update(A.as_bytes());\n        Self {\n            key: *key,\n            signature,\n            h,\n        }\n    }\n\n    pub(crate) fn update(&mut self, m: &[u8]) {\n        self.h.update(m)\n    }\n\n    pub(crate) fn finish(self) -> CompressedEdwardsY {\n        let k = Scalar::from_hash(self.h);\n\n        let minus_A: EdwardsPoint = -self.key.point;\n        // Recall the (non-batched) verification equation: -[k]A + [s]B = R\n        EdwardsPoint::vartime_double_scalar_mul_basepoint(&k, &(minus_A), &self.signature.s)\n            .compress()\n    }\n}\n\nimpl Verifier<ed25519::Signature> for VerifyingKey {\n    /// Verify a signature on a message with this keypair's public key.\n    ///\n    /// # Return\n    ///\n    /// Returns `Ok(())` if the signature is valid, and `Err` otherwise.\n    fn verify(&self, message: &[u8], signature: &ed25519::Signature) -> Result<(), SignatureError> {\n        self.multipart_verify(&[message], signature)\n    }\n}\n\nimpl MultipartVerifier<ed25519::Signature> for VerifyingKey {\n    fn multipart_verify(\n        &self,\n        message: &[&[u8]],\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError> {\n        self.raw_verify::<Sha512>(message, signature)\n    }\n}\n\n/// Equivalent to [`VerifyingKey::verify_prehashed`] with `context` set to [`None`].\n#[cfg(feature = \"digest\")]\nimpl<MsgDigest> DigestVerifier<MsgDigest, ed25519::Signature> for VerifyingKey\nwhere\n    MsgDigest: Digest<OutputSize = U64>,\n{\n    fn verify_digest(\n        &self,\n        msg_digest: MsgDigest,\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError> {\n        self.verify_prehashed(msg_digest, None, signature)\n    }\n}\n\n/// Equivalent to [`VerifyingKey::verify_prehashed`] with `context` set to [`Some`]\n/// containing `self.value()`.\n#[cfg(feature = \"digest\")]\nimpl<MsgDigest> DigestVerifier<MsgDigest, ed25519::Signature> for Context<'_, '_, VerifyingKey>\nwhere\n    MsgDigest: Digest<OutputSize = U64>,\n{\n    fn verify_digest(\n        &self,\n        msg_digest: MsgDigest,\n        signature: &ed25519::Signature,\n    ) -> Result<(), SignatureError> {\n        self.key()\n            .verify_prehashed(msg_digest, Some(self.value()), signature)\n    }\n}\n\nimpl TryFrom<&[u8]> for VerifyingKey {\n    type Error = SignatureError;\n\n    #[inline]\n    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {\n        let bytes = bytes.try_into().map_err(|_| InternalError::BytesLength {\n            name: \"VerifyingKey\",\n            length: PUBLIC_KEY_LENGTH,\n        })?;\n        Self::from_bytes(bytes)\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl pkcs8::spki::SignatureAlgorithmIdentifier for VerifyingKey {\n    type Params = pkcs8::spki::der::AnyRef<'static>;\n\n    const SIGNATURE_ALGORITHM_IDENTIFIER: pkcs8::spki::AlgorithmIdentifier<Self::Params> =\n        <ed25519::Signature as pkcs8::spki::AssociatedAlgorithmIdentifier>::ALGORITHM_IDENTIFIER;\n}\n\nimpl From<VerifyingKey> for EdwardsPoint {\n    fn from(vk: VerifyingKey) -> EdwardsPoint {\n        vk.point\n    }\n}\n\n#[cfg(all(feature = \"alloc\", feature = \"pkcs8\"))]\nimpl pkcs8::EncodePublicKey for VerifyingKey {\n    fn to_public_key_der(&self) -> pkcs8::spki::Result<pkcs8::Document> {\n        pkcs8::PublicKeyBytes::from(self).to_public_key_der()\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl TryFrom<pkcs8::PublicKeyBytes> for VerifyingKey {\n    type Error = pkcs8::spki::Error;\n\n    fn try_from(pkcs8_key: pkcs8::PublicKeyBytes) -> pkcs8::spki::Result<Self> {\n        VerifyingKey::try_from(&pkcs8_key)\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl TryFrom<&pkcs8::PublicKeyBytes> for VerifyingKey {\n    type Error = pkcs8::spki::Error;\n\n    fn try_from(pkcs8_key: &pkcs8::PublicKeyBytes) -> pkcs8::spki::Result<Self> {\n        VerifyingKey::from_bytes(pkcs8_key.as_ref()).map_err(|_| pkcs8::spki::Error::KeyMalformed)\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl From<VerifyingKey> for pkcs8::PublicKeyBytes {\n    fn from(verifying_key: VerifyingKey) -> pkcs8::PublicKeyBytes {\n        pkcs8::PublicKeyBytes::from(&verifying_key)\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl From<&VerifyingKey> for pkcs8::PublicKeyBytes {\n    fn from(verifying_key: &VerifyingKey) -> pkcs8::PublicKeyBytes {\n        pkcs8::PublicKeyBytes(verifying_key.to_bytes())\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl TryFrom<pkcs8::spki::SubjectPublicKeyInfoRef<'_>> for VerifyingKey {\n    type Error = pkcs8::spki::Error;\n\n    fn try_from(public_key: pkcs8::spki::SubjectPublicKeyInfoRef<'_>) -> pkcs8::spki::Result<Self> {\n        pkcs8::PublicKeyBytes::try_from(public_key)?.try_into()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for VerifyingKey {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_bytes(&self.as_bytes()[..])\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'d> Deserialize<'d> for VerifyingKey {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'d>,\n    {\n        struct VerifyingKeyVisitor;\n\n        impl<'de> serde::de::Visitor<'de> for VerifyingKeyVisitor {\n            type Value = VerifyingKey;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(formatter, concat!(\"An ed25519 verifying (public) key\"))\n            }\n\n            fn visit_bytes<E: serde::de::Error>(self, bytes: &[u8]) -> Result<Self::Value, E> {\n                VerifyingKey::try_from(bytes).map_err(E::custom)\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n\n                let remaining = (0..)\n                    .map(|_| seq.next_element::<u8>())\n                    .take_while(|el| matches!(el, Ok(Some(_))))\n                    .count();\n\n                if remaining > 0 {\n                    return Err(serde::de::Error::invalid_length(\n                        32 + remaining,\n                        &\"expected 32 bytes\",\n                    ));\n                }\n\n                VerifyingKey::try_from(&bytes[..]).map_err(serde::de::Error::custom)\n            }\n        }\n\n        deserializer.deserialize_bytes(VerifyingKeyVisitor)\n    }\n}\n",
    "filename": "ed25519-dalek/src/verifying.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  },
  "63680": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2017-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\n//! Batch signature verification.\n\nmod strobe;\nmod transcript;\n\nuse alloc::vec::Vec;\n\nuse core::iter::once;\n\nuse curve25519_dalek::constants;\nuse curve25519_dalek::edwards::EdwardsPoint;\nuse curve25519_dalek::scalar::Scalar;\nuse curve25519_dalek::traits::IsIdentity;\nuse curve25519_dalek::traits::VartimeMultiscalarMul;\n\npub use curve25519_dalek::digest::Digest;\n\nuse transcript::Transcript;\n\nuse rand_core::RngCore;\n\nuse sha2::Sha512;\n\nuse crate::VerifyingKey;\nuse crate::errors::InternalError;\nuse crate::errors::SignatureError;\nuse crate::signature::InternalSignature;\n\n/// Domain separation label to initialize the STROBE context.\n///\n/// This is not to be confused with the crate's semver string:\n/// the latter applies to the API, while this label defines the protocol.\n/// E.g. it is possible that crate 2.0 will have an incompatible API,\n/// but implement the same 1.0 protocol.\nconst MERLIN_PROTOCOL_LABEL: &[u8] = b\"Merlin v1.0\";\n\n/// An implementation of `rand_core::RngCore` which does nothing. This is necessary because merlin\n/// demands an `Rng` as input to `TranscriptRngBuilder::finalize()`. Using this with `finalize()`\n/// yields a PRG whose input is the hashed transcript.\nstruct ZeroRng;\n\nimpl rand_core::RngCore for ZeroRng {\n    fn next_u32(&mut self) -> u32 {\n        rand_core::impls::next_u32_via_fill(self)\n    }\n\n    fn next_u64(&mut self) -> u64 {\n        rand_core::impls::next_u64_via_fill(self)\n    }\n\n    /// A no-op function which leaves the destination bytes for randomness unchanged.\n    ///\n    /// In this case, the internal merlin code is initialising the destination\n    /// by doing `[0u8; …]`, which means that when we call\n    /// `merlin::TranscriptRngBuilder.finalize()`, rather than rekeying the\n    /// STROBE state based on external randomness, we're doing an\n    /// `ENC_{state}(00000000000000000000000000000000)` operation, which is\n    /// identical to the STROBE `MAC` operation.\n    fn fill_bytes(&mut self, _dest: &mut [u8]) {}\n}\n\n// `TranscriptRngBuilder::finalize()` requires a `CryptoRng`\nimpl rand_core::CryptoRng for ZeroRng {}\n\n// We write our own gen() function so we don't need to pull in the rand crate\nfn gen_u128<R: RngCore>(rng: &mut R) -> u128 {\n    let mut buf = [0u8; 16];\n    rng.fill_bytes(&mut buf);\n    u128::from_le_bytes(buf)\n}\n\n/// Verify a batch of `signatures` on `messages` with their respective `verifying_keys`.\n///\n/// # Inputs\n///\n/// * `messages` is a slice of byte slices, one per signed message.\n/// * `signatures` is a slice of `Signature`s.\n/// * `verifying_keys` is a slice of `VerifyingKey`s.\n///\n/// # Returns\n///\n/// * A `Result` whose `Ok` value is an empty tuple and whose `Err` value is a\n///   `SignatureError` containing a description of the internal error which\n///   occurred.\n///\n/// ## On Deterministic Nonces\n///\n/// The nonces for batch signature verification are derived purely from the inputs to this function\n/// themselves.\n///\n/// In any sigma protocol it is wise to include as much context pertaining\n/// to the public state in the protocol as possible, to avoid malleability\n/// attacks where an adversary alters publics in an algebraic manner that\n/// manages to satisfy the equations for the protocol in question.\n///\n/// For ed25519 batch verification we include the following as scalars in the protocol transcript:\n///\n/// * All of the computed `H(R||A||M)`s to the protocol transcript, and\n/// * All of the `s` components of each signature.\n///\n/// The former, while not quite as elegant as adding the `R`s, `A`s, and\n/// `M`s separately, saves us a bit of context hashing since the\n/// `H(R||A||M)`s need to be computed for the verification equation anyway.\n///\n/// The latter prevents a malleability attack wherein an adversary, without access\n/// to the signing key(s), can take any valid signature, `(s,R)`, and swap\n/// `s` with `s' = -z1`.  This doesn't constitute a signature forgery, merely\n/// a vulnerability, as the resulting signature will not pass single\n/// signature verification.  (Thanks to Github users @real_or_random and\n/// @jonasnick for pointing out this malleability issue.)\n///\n/// # Examples\n///\n/// ```\n/// use ed25519_dalek::{\n///     verify_batch, SigningKey, VerifyingKey, Signer, Signature,\n/// };\n/// use rand::rngs::OsRng;\n/// use rand_core::TryRngCore;\n///\n/// # fn main() {\n/// let mut csprng = OsRng.unwrap_err();\n/// let signing_keys: Vec<_> = (0..64).map(|_| SigningKey::generate(&mut csprng)).collect();\n/// let msg: &[u8] = b\"They're good dogs Brant\";\n/// let messages: Vec<_> = (0..64).map(|_| msg).collect();\n/// let signatures:  Vec<_> = signing_keys.iter().map(|key| key.sign(&msg)).collect();\n/// let verifying_keys: Vec<_> = signing_keys.iter().map(|key| key.verifying_key()).collect();\n///\n/// let result = verify_batch(&messages, &signatures, &verifying_keys);\n/// assert!(result.is_ok());\n/// # }\n/// ```\n#[allow(non_snake_case)]\npub fn verify_batch(\n    messages: &[&[u8]],\n    signatures: &[ed25519::Signature],\n    verifying_keys: &[VerifyingKey],\n) -> Result<(), SignatureError> {\n    // Return an Error if any of the vectors were not the same size as the others.\n    if signatures.len() != messages.len()\n        || signatures.len() != verifying_keys.len()\n        || verifying_keys.len() != messages.len()\n    {\n        return Err(InternalError::ArrayLength {\n            name_a: \"signatures\",\n            length_a: signatures.len(),\n            name_b: \"messages\",\n            length_b: messages.len(),\n            name_c: \"verifying_keys\",\n            length_c: verifying_keys.len(),\n        }\n        .into());\n    }\n\n    // Make a transcript which logs all inputs to this function\n    let mut transcript: Transcript = Transcript::new(b\"ed25519 batch verification\");\n\n    // We make one optimization in the transcript: since we will end up computing H(R || A || M)\n    // for each (R, A, M) triplet, we will feed _that_ into our transcript rather than each R, A, M\n    // individually. Since R and A are fixed-length, this modification is secure so long as SHA-512\n    // is collision-resistant.\n    // It suffices to take `verifying_keys[i].as_bytes()` even though a `VerifyingKey` has two\n    // fields, and `as_bytes()` only returns the bytes of the first. This is because of an\n    // invariant guaranteed by `VerifyingKey`: the second field is always the (unique)\n    // decompression of the first. Thus, the serialized first field is a unique representation of\n    // the entire `VerifyingKey`.\n    let hrams: Vec<[u8; 64]> = (0..signatures.len())\n        .map(|i| {\n            // Compute H(R || A || M), where\n            // R = sig.R\n            // A = verifying key\n            // M = msg\n            let mut h: Sha512 = Sha512::default();\n            h.update(signatures[i].r_bytes());\n            h.update(verifying_keys[i].as_bytes());\n            h.update(messages[i]);\n            *h.finalize().as_ref()\n        })\n        .collect();\n\n    // Update transcript with the hashes above. This covers verifying_keys, messages, and the R\n    // half of signatures\n    for hram in hrams.iter() {\n        transcript.append_message(b\"hram\", hram);\n    }\n    // Update transcript with the rest of the data. This covers the s half of the signatures\n    for sig in signatures {\n        transcript.append_message(b\"sig.s\", sig.s_bytes());\n    }\n\n    // All function inputs have now been hashed into the transcript. Finalize it and use it as\n    // randomness for the batch verification.\n    let mut rng = transcript.build_rng().finalize(&mut ZeroRng);\n\n    // Convert all signatures to `InternalSignature`\n    let signatures = signatures\n        .iter()\n        .map(InternalSignature::try_from)\n        .collect::<Result<Vec<_>, _>>()?;\n    // Convert the H(R || A || M) values into scalars\n    let hrams: Vec<Scalar> = hrams\n        .iter()\n        .map(Scalar::from_bytes_mod_order_wide)\n        .collect();\n\n    // Select a random 128-bit scalar for each signature.\n    let zs: Vec<Scalar> = signatures\n        .iter()\n        .map(|_| Scalar::from(gen_u128(&mut rng)))\n        .collect();\n\n    // Compute the basepoint coefficient, ∑ s[i]z[i] (mod l)\n    let B_coefficient: Scalar = signatures\n        .iter()\n        .map(|sig| sig.s)\n        .zip(zs.iter())\n        .map(|(s, z)| z * s)\n        .sum();\n\n    // Multiply each H(R || A || M) by the random value\n    let zhrams = hrams.iter().zip(zs.iter()).map(|(hram, z)| hram * z);\n\n    let Rs = signatures.iter().map(|sig| sig.R.decompress());\n    let As = verifying_keys.iter().map(|pk| Some(pk.point));\n    let B = once(Some(constants::ED25519_BASEPOINT_POINT));\n\n    // Compute (-∑ z[i]s[i] (mod l)) B + ∑ z[i]R[i] + ∑ (z[i]H(R||A||M)[i] (mod l)) A[i] = 0\n    let id = EdwardsPoint::optional_multiscalar_mul(\n        once(-B_coefficient).chain(zs.iter().cloned()).chain(zhrams),\n        B.chain(Rs).chain(As),\n    )\n    .ok_or(InternalError::Verify)?;\n\n    if id.is_identity() {\n        Ok(())\n    } else {\n        Err(InternalError::Verify.into())\n    }\n}\n",
    "filename": "ed25519-dalek/src/batch.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  },
  "63681": {
    "text": "//! Low-level interfaces to ed25519 functions\n//!\n//! # ⚠️ Warning: Hazmat\n//!\n//! These primitives are easy-to-misuse low-level interfaces.\n//!\n//! If you are an end user / non-expert in cryptography, **do not use any of these functions**.\n//! Failure to use them correctly can lead to catastrophic failures including **full private key\n//! recovery.**\n\n// Permit dead code because 1) this module is only public when the `hazmat` feature is set, and 2)\n// even without `hazmat` we still need this module because this is where `ExpandedSecretKey` is\n// defined.\n#![allow(dead_code)]\n\nuse core::fmt::Debug;\n\nuse crate::{InternalError, SignatureError};\n\nuse curve25519_dalek::scalar::{Scalar, clamp_integer};\n\nuse subtle::{Choice, ConstantTimeEq};\n#[cfg(feature = \"zeroize\")]\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n\n// These are used in the functions that are made public when the hazmat feature is set\nuse crate::{Signature, VerifyingKey};\nuse curve25519_dalek::digest::{Digest, array::typenum::U64};\n\n/// Contains the secret scalar and domain separator used for generating signatures.\n///\n/// This is used internally for signing.\n///\n/// In the usual Ed25519 signing algorithm, `scalar` and `hash_prefix` are defined such that\n/// `scalar || hash_prefix = H(sk)` where `sk` is the signing key and `H` is SHA-512.\n/// **WARNING:** Deriving the values for these fields in any other way can lead to full key\n/// recovery, as documented in [`raw_sign`] and [`raw_sign_prehashed`].\n///\n/// Instances of this secret are automatically overwritten with zeroes when they fall out of scope.\npub struct ExpandedSecretKey {\n    /// The secret scalar used for signing\n    pub scalar: Scalar,\n    /// The domain separator used when hashing the message to generate the pseudorandom `r` value\n    pub hash_prefix: [u8; 32],\n}\n\nimpl Debug for ExpandedSecretKey {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"ExpandedSecretKey\").finish_non_exhaustive() // avoids printing secrets\n    }\n}\n\nimpl ConstantTimeEq for ExpandedSecretKey {\n    fn ct_eq(&self, other: &Self) -> Choice {\n        self.scalar.ct_eq(&other.scalar) & self.hash_prefix.ct_eq(&other.hash_prefix)\n    }\n}\n\nimpl PartialEq for ExpandedSecretKey {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for ExpandedSecretKey {}\n\n#[cfg(feature = \"zeroize\")]\nimpl Drop for ExpandedSecretKey {\n    fn drop(&mut self) {\n        self.scalar.zeroize();\n        self.hash_prefix.zeroize()\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl ZeroizeOnDrop for ExpandedSecretKey {}\n\n// Some conversion methods for `ExpandedSecretKey`. The signing methods are defined in\n// `signing.rs`, since we need them even when `not(feature = \"hazmat\")`\nimpl ExpandedSecretKey {\n    /// Construct an `ExpandedSecretKey` from an array of 64 bytes. In the spec, the bytes are the\n    /// output of a SHA-512 hash. This clamps the first 32 bytes and uses it as a scalar, and uses\n    /// the second 32 bytes as a domain separator for hashing.\n    pub fn from_bytes(bytes: &[u8; 64]) -> Self {\n        // TODO: Use bytes.split_array_ref once it’s in MSRV.\n        let mut scalar_bytes: [u8; 32] = [0u8; 32];\n        let mut hash_prefix: [u8; 32] = [0u8; 32];\n        scalar_bytes.copy_from_slice(&bytes[00..32]);\n        hash_prefix.copy_from_slice(&bytes[32..64]);\n\n        // For signing, we'll need the integer, clamped, and converted to a Scalar. See\n        // PureEdDSA.keygen in RFC 8032 Appendix A.\n        let scalar = Scalar::from_bytes_mod_order(clamp_integer(scalar_bytes));\n\n        ExpandedSecretKey {\n            scalar,\n            hash_prefix,\n        }\n    }\n\n    /// Construct an `ExpandedSecretKey` from a slice of 64 bytes.\n    ///\n    /// # Returns\n    ///\n    /// A `Result` whose okay value is an EdDSA `ExpandedSecretKey` or whose error value is an\n    /// `SignatureError` describing the error that occurred, namely that the given slice's length\n    /// is not 64.\n    pub fn from_slice(bytes: &[u8]) -> Result<Self, SignatureError> {\n        // Try to coerce bytes to a [u8; 64]\n        bytes.try_into().map(Self::from_bytes).map_err(|_| {\n            InternalError::BytesLength {\n                name: \"ExpandedSecretKey\",\n                length: 64,\n            }\n            .into()\n        })\n    }\n}\n\nimpl TryFrom<&[u8]> for ExpandedSecretKey {\n    type Error = SignatureError;\n\n    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {\n        Self::from_slice(bytes)\n    }\n}\n\n/// Compute an ordinary Ed25519 signature over the given message. `CtxDigest` is the digest used to\n/// calculate the pseudorandomness needed for signing. According to the Ed25519 spec, `CtxDigest =\n/// Sha512`.\n///\n/// # ⚠️  Cryptographically Unsafe\n///\n/// Do NOT use this function unless you absolutely must. Using the wrong values in\n/// `ExpandedSecretKey` can leak your signing key. See\n/// [here](https://github.com/MystenLabs/ed25519-unsafe-libs) for more details on this attack.\npub fn raw_sign<CtxDigest>(\n    esk: &ExpandedSecretKey,\n    message: &[u8],\n    verifying_key: &VerifyingKey,\n) -> Signature\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    esk.raw_sign::<CtxDigest>(&[message], verifying_key)\n}\n\n/// Compute a signature over the given prehashed message, the Ed25519ph algorithm defined in\n/// [RFC8032 §5.1][rfc8032]. `MsgDigest` is the digest function used to hash the signed message.\n/// `CtxDigest` is the digest function used to calculate the pseudorandomness needed for signing.\n/// According to the Ed25519 spec, `MsgDigest = CtxDigest = Sha512`.\n///\n/// # ⚠️  Cryptographically Unsafe\n//\n/// Do NOT use this function unless you absolutely must. Using the wrong values in\n/// `ExpandedSecretKey` can leak your signing key. See\n/// [here](https://github.com/MystenLabs/ed25519-unsafe-libs) for more details on this attack.\n///\n/// # Inputs\n///\n/// * `esk` is the [`ExpandedSecretKey`] being used for signing\n/// * `prehashed_message` is an instantiated hash digest with 512-bits of\n///   output which has had the message to be signed previously fed into its\n///   state.\n/// * `verifying_key` is a [`VerifyingKey`] which corresponds to this secret key.\n/// * `context` is an optional context string, up to 255 bytes inclusive,\n///   which may be used to provide additional domain separation.  If not\n///   set, this will default to an empty string.\n///\n/// `scalar` and `hash_prefix` are usually selected such that `scalar || hash_prefix = H(sk)` where\n/// `sk` is the signing key\n///\n/// # Returns\n///\n/// A `Result` whose `Ok` value is an Ed25519ph [`Signature`] on the\n/// `prehashed_message` if the context was 255 bytes or less, otherwise\n/// a `SignatureError`.\n///\n/// [rfc8032]: https://tools.ietf.org/html/rfc8032#section-5.1\n#[cfg(feature = \"digest\")]\n#[allow(non_snake_case)]\npub fn raw_sign_prehashed<CtxDigest, MsgDigest>(\n    esk: &ExpandedSecretKey,\n    prehashed_message: MsgDigest,\n    verifying_key: &VerifyingKey,\n    context: Option<&[u8]>,\n) -> Result<Signature, SignatureError>\nwhere\n    MsgDigest: Digest<OutputSize = U64>,\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    esk.raw_sign_prehashed::<CtxDigest, MsgDigest>(prehashed_message, verifying_key, context)\n}\n\n/// Compute an ordinary Ed25519 signature, with the message contents provided incrementally by\n/// updating a digest instance.\n///\n/// The `msg_update` closure provides the message content, updating a hasher argument. It will be\n/// called twice. This closure MUST leave its hasher in the same state (i.e., must hash the same\n/// values) after both calls. Otherwise it will produce an invalid signature.\n///\n/// `CtxDigest` is the digest used to calculate the pseudorandomness needed for signing. According\n/// to the Ed25519 spec, `CtxDigest = Sha512`.\n///\n/// # ⚠️  Cryptographically Unsafe\n///\n/// Do NOT use this function unless you absolutely must. Using the wrong values in\n/// `ExpandedSecretKey` can leak your signing key. See\n/// [here](https://github.com/MystenLabs/ed25519-unsafe-libs) for more details on this attack.\npub fn raw_sign_byupdate<CtxDigest, F>(\n    esk: &ExpandedSecretKey,\n    msg_update: F,\n    verifying_key: &VerifyingKey,\n) -> Result<Signature, SignatureError>\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n    F: Fn(&mut CtxDigest) -> Result<(), SignatureError>,\n{\n    esk.raw_sign_byupdate::<CtxDigest, F>(msg_update, verifying_key)\n}\n\n/// The ordinary non-batched Ed25519 verification check, rejecting non-canonical R\n/// values.`CtxDigest` is the digest used to calculate the pseudorandomness needed for signing.\n/// According to the Ed25519 spec, `CtxDigest = Sha512`.\npub fn raw_verify<CtxDigest>(\n    vk: &VerifyingKey,\n    message: &[u8],\n    signature: &ed25519::Signature,\n) -> Result<(), SignatureError>\nwhere\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    vk.raw_verify::<CtxDigest>(&[message], signature)\n}\n\n/// The batched Ed25519 verification check, rejecting non-canonical R values. `MsgDigest` is the\n/// digest used to hash the signed message. `CtxDigest` is the digest used to calculate the\n/// pseudorandomness needed for signing. According to the Ed25519 spec, `MsgDigest = CtxDigest =\n/// Sha512`.\n#[cfg(feature = \"digest\")]\n#[allow(non_snake_case)]\npub fn raw_verify_prehashed<CtxDigest, MsgDigest>(\n    vk: &VerifyingKey,\n    prehashed_message: MsgDigest,\n    context: Option<&[u8]>,\n    signature: &ed25519::Signature,\n) -> Result<(), SignatureError>\nwhere\n    MsgDigest: Digest<OutputSize = U64>,\n    CtxDigest: Digest<OutputSize = U64>,\n{\n    vk.raw_verify_prehashed::<CtxDigest, MsgDigest>(prehashed_message, context, signature)\n}\n\n#[cfg(test)]\nmod test {\n    #![allow(clippy::unwrap_used)]\n\n    use super::*;\n\n    use rand::{CryptoRng, TryRngCore, rngs::OsRng};\n\n    // Pick distinct, non-spec 512-bit hash functions for message and sig-context hashing\n    type CtxDigest = blake2::Blake2b512;\n    type MsgDigest = sha3::Sha3_512;\n\n    impl ExpandedSecretKey {\n        // Make a random expanded secret key for testing purposes. This is NOT how you generate\n        // expanded secret keys IRL. They're the hash of a seed.\n        fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n            let mut bytes = [0u8; 64];\n            rng.fill_bytes(&mut bytes);\n            ExpandedSecretKey::from_bytes(&bytes)\n        }\n    }\n\n    // Check that raw_sign and raw_verify work when a non-spec CtxDigest is used\n    #[test]\n    fn sign_verify_nonspec() {\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        let msg = b\"Then one day, a piano fell on my head\";\n\n        // Sign and verify\n        let sig = raw_sign::<CtxDigest>(&esk, msg, &vk);\n        raw_verify::<CtxDigest>(&vk, msg, &sig).unwrap();\n    }\n\n    // Check that raw_sign_prehashed and raw_verify_prehashed work when distinct, non-spec\n    // MsgDigest and CtxDigest are used\n    #[cfg(feature = \"digest\")]\n    #[test]\n    fn sign_verify_prehashed_nonspec() {\n        use curve25519_dalek::digest::Digest;\n\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        // Hash the message\n        let msg = b\"And then I got trampled by a herd of buffalo\";\n        let mut h = MsgDigest::new();\n        h.update(msg);\n\n        let ctx_str = &b\"consequences\"[..];\n\n        // Sign and verify prehashed\n        let sig = raw_sign_prehashed::<CtxDigest, MsgDigest>(&esk, h.clone(), &vk, Some(ctx_str))\n            .unwrap();\n        raw_verify_prehashed::<CtxDigest, MsgDigest>(&vk, h, Some(ctx_str), &sig).unwrap();\n    }\n\n    #[test]\n    fn sign_byupdate() {\n        // Generate the keypair\n        let mut rng = OsRng.unwrap_err();\n        let esk = ExpandedSecretKey::random(&mut rng);\n        let vk = VerifyingKey::from(&esk);\n\n        let msg = b\"realistic\";\n        // signatures are deterministic so we can compare with a good one\n        let good_sig = raw_sign::<CtxDigest>(&esk, msg, &vk);\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(msg);\n                Ok(())\n            },\n            &vk,\n        );\n        assert!(sig.unwrap() == good_sig, \"sign byupdate matches\");\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(msg);\n                Err(SignatureError::new())\n            },\n            &vk,\n        );\n        assert!(sig.is_err(), \"sign byupdate failure propagates\");\n\n        let sig = raw_sign_byupdate::<CtxDigest, _>(\n            &esk,\n            |h| {\n                h.update(&msg[..1]);\n                h.update(&msg[1..]);\n                Ok(())\n            },\n            &vk,\n        );\n        assert!(sig.unwrap() == good_sig, \"sign byupdate two part\");\n    }\n}\n",
    "filename": "ed25519-dalek/src/hazmat.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  },
  "63682": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2017-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\n//! An ed25519 signature.\n\nuse core::fmt::Debug;\n\nuse curve25519_dalek::edwards::CompressedEdwardsY;\nuse curve25519_dalek::scalar::Scalar;\n\nuse crate::constants::*;\nuse crate::errors::*;\n\n/// An ed25519 signature.\n///\n/// # Note\n///\n/// These signatures, unlike the ed25519 signature reference implementation, are\n/// \"detached\"—that is, they do **not** include a copy of the message which has\n/// been signed.\n#[allow(non_snake_case)]\n#[derive(Copy, Eq, PartialEq)]\npub(crate) struct InternalSignature {\n    /// `R` is an `EdwardsPoint`, formed by using an hash function with\n    /// 512-bits output to produce the digest of:\n    ///\n    /// - the nonce half of the `ExpandedSecretKey`, and\n    /// - the message to be signed.\n    ///\n    /// This digest is then interpreted as a `Scalar` and reduced into an\n    /// element in ℤ/lℤ.  The scalar is then multiplied by the distinguished\n    /// basepoint to produce `R`, and `EdwardsPoint`.\n    pub(crate) R: CompressedEdwardsY,\n\n    /// `s` is a `Scalar`, formed by using an hash function with 512-bits output\n    /// to produce the digest of:\n    ///\n    /// - the `r` portion of this `Signature`,\n    /// - the `PublicKey` which should be used to verify this `Signature`, and\n    /// - the message to be signed.\n    ///\n    /// This digest is then interpreted as a `Scalar` and reduced into an\n    /// element in ℤ/lℤ.\n    pub(crate) s: Scalar,\n}\n\nimpl Clone for InternalSignature {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\nimpl Debug for InternalSignature {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Signature( R: {:?}, s: {:?} )\", &self.R, &self.s)\n    }\n}\n\n/// Ensures that the scalar `s` of a signature is within the bounds [0, 2^253).\n///\n/// **Unsafe**: This version of `check_scalar` permits signature malleability. See README.\n#[cfg(feature = \"legacy_compatibility\")]\n#[inline(always)]\nfn check_scalar(bytes: [u8; 32]) -> Result<Scalar, SignatureError> {\n    // The highest 3 bits must not be set.  No other checking for the\n    // remaining 2^253 - 2^252 + 27742317777372353535851937790883648493\n    // potential non-reduced scalars is performed.\n    //\n    // This is compatible with ed25519-donna and libsodium when\n    // `-D ED25519_COMPAT` is NOT specified.\n    if bytes[31] & 224 != 0 {\n        return Err(InternalError::ScalarFormat.into());\n    }\n\n    // You cannot do arithmetic with scalars construct with Scalar::from_bits. We only use this\n    // scalar for EdwardsPoint::vartime_double_scalar_mul_basepoint, which is an accepted usecase.\n    Ok(Scalar::from_bits(bytes))\n}\n\n/// Ensures that the scalar `s` of a signature is within the bounds [0, ℓ)\n#[cfg(not(feature = \"legacy_compatibility\"))]\n#[inline(always)]\nfn check_scalar(bytes: [u8; 32]) -> Result<Scalar, SignatureError> {\n    match Scalar::from_canonical_bytes(bytes).into() {\n        None => Err(InternalError::ScalarFormat.into()),\n        Some(x) => Ok(x),\n    }\n}\n\nimpl InternalSignature {\n    /// Construct a `Signature` from a slice of bytes.\n    ///\n    /// # Scalar Malleability Checking\n    ///\n    /// As originally specified in the ed25519 paper (cf. the \"Malleability\"\n    /// section of the README in this repo), no checks whatsoever were performed\n    /// for signature malleability.\n    ///\n    /// Later, a semi-functional, hacky check was added to most libraries to\n    /// \"ensure\" that the scalar portion, `s`, of the signature was reduced `mod\n    /// \\ell`, the order of the basepoint:\n    ///\n    /// ```ignore\n    /// if signature.s[31] & 224 != 0 {\n    ///     return Err();\n    /// }\n    /// ```\n    ///\n    /// This bit-twiddling ensures that the most significant three bits of the\n    /// scalar are not set:\n    ///\n    /// ```python,ignore\n    /// >>> 0b00010000 & 224\n    /// 0\n    /// >>> 0b00100000 & 224\n    /// 32\n    /// >>> 0b01000000 & 224\n    /// 64\n    /// >>> 0b10000000 & 224\n    /// 128\n    /// ```\n    ///\n    /// However, this check is hacky and insufficient to check that the scalar is\n    /// fully reduced `mod \\ell = 2^252 + 27742317777372353535851937790883648493` as\n    /// it leaves us with a guanteed bound of 253 bits.  This means that there are\n    /// `2^253 - 2^252 + 2774231777737235353585193779088364849311` remaining scalars\n    /// which could cause malleabilllity.\n    ///\n    /// RFC8032 [states](https://tools.ietf.org/html/rfc8032#section-5.1.7):\n    ///\n    /// > To verify a signature on a message M using public key A, [...]\n    /// > first split the signature into two 32-octet halves.  Decode the first\n    /// > half as a point R, and the second half as an integer S, in the range\n    /// > 0 <= s < L.  Decode the public key A as point A'.  If any of the\n    /// > decodings fail (including S being out of range), the signature is\n    /// > invalid.\n    ///\n    /// However, by the time this was standardised, most libraries in use were\n    /// only checking the most significant three bits.  (See also the\n    /// documentation for [`crate::VerifyingKey::verify_strict`].)\n    #[inline]\n    #[allow(non_snake_case)]\n    pub fn from_bytes(bytes: &[u8; SIGNATURE_LENGTH]) -> Result<InternalSignature, SignatureError> {\n        // TODO: Use bytes.split_array_ref once it’s in MSRV.\n        let mut R_bytes: [u8; 32] = [0u8; 32];\n        let mut s_bytes: [u8; 32] = [0u8; 32];\n        R_bytes.copy_from_slice(&bytes[00..32]);\n        s_bytes.copy_from_slice(&bytes[32..64]);\n\n        Ok(InternalSignature {\n            R: CompressedEdwardsY(R_bytes),\n            s: check_scalar(s_bytes)?,\n        })\n    }\n}\n\nimpl TryFrom<&ed25519::Signature> for InternalSignature {\n    type Error = SignatureError;\n\n    fn try_from(sig: &ed25519::Signature) -> Result<InternalSignature, SignatureError> {\n        InternalSignature::from_bytes(&sig.to_bytes())\n    }\n}\n\nimpl From<InternalSignature> for ed25519::Signature {\n    fn from(sig: InternalSignature) -> ed25519::Signature {\n        ed25519::Signature::from_components(*sig.R.as_bytes(), *sig.s.as_bytes())\n    }\n}\n",
    "filename": "ed25519-dalek/src/signature.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  },
  "63683": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2017-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\n//! Errors which may occur when parsing keys and/or signatures to or from wire formats.\n\n// rustc seems to think the typenames in match statements (e.g. in\n// Display) should be snake cased, for some reason.\n#![allow(non_snake_case)]\n\nuse core::error::Error;\nuse core::fmt;\nuse core::fmt::Display;\n\n/// Internal errors.  Most application-level developers will likely not\n/// need to pay any attention to these.\n#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\npub(crate) enum InternalError {\n    PointDecompression,\n    ScalarFormat,\n    /// An error in the length of bytes handed to a constructor.\n    ///\n    /// To use this, pass a string specifying the `name` of the type which is\n    /// returning the error, and the `length` in bytes which its constructor\n    /// expects.\n    BytesLength {\n        name: &'static str,\n        length: usize,\n    },\n    /// The verification equation wasn't satisfied\n    Verify,\n    /// Two arrays did not match in size, making the called signature\n    /// verification method impossible.\n    #[cfg(feature = \"batch\")]\n    ArrayLength {\n        name_a: &'static str,\n        length_a: usize,\n        name_b: &'static str,\n        length_b: usize,\n        name_c: &'static str,\n        length_c: usize,\n    },\n    /// An ed25519ph signature can only take up to 255 octets of context.\n    #[cfg(feature = \"digest\")]\n    PrehashedContextLength,\n    /// A mismatched (public, secret) key pair.\n    MismatchedKeypair,\n}\n\nimpl Display for InternalError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            InternalError::PointDecompression => write!(f, \"Cannot decompress Edwards point\"),\n            InternalError::ScalarFormat => write!(f, \"Cannot use scalar with high-bit set\"),\n            InternalError::BytesLength { name: n, length: l } => {\n                write!(f, \"{} must be {} bytes in length\", n, l)\n            }\n            InternalError::Verify => write!(f, \"Verification equation was not satisfied\"),\n            #[cfg(feature = \"batch\")]\n            InternalError::ArrayLength {\n                name_a: na,\n                length_a: la,\n                name_b: nb,\n                length_b: lb,\n                name_c: nc,\n                length_c: lc,\n            } => write!(\n                f,\n                \"Arrays must be the same length: {} has length {},\n                              {} has length {}, {} has length {}.\",\n                na, la, nb, lb, nc, lc\n            ),\n            #[cfg(feature = \"digest\")]\n            InternalError::PrehashedContextLength => write!(\n                f,\n                \"An ed25519ph signature can only take up to 255 octets of context\"\n            ),\n            InternalError::MismatchedKeypair => write!(f, \"Mismatched Keypair detected\"),\n        }\n    }\n}\n\nimpl Error for InternalError {}\n\n/// Errors which may occur while processing signatures and keypairs.\n///\n/// This error may arise due to:\n///\n/// * Being given bytes with a length different to what was expected.\n///\n/// * A problem decompressing `r`, a curve point, in the `Signature`, or the\n///   curve point for a `PublicKey`.\n///\n/// * A problem with the format of `s`, a scalar, in the `Signature`.  This\n///   is only raised if the high-bit of the scalar was set.  (Scalars must\n///   only be constructed from 255-bit integers.)\n///\n/// * Failure of a signature to satisfy the verification equation.\npub type SignatureError = ed25519::signature::Error;\n\nimpl From<InternalError> for SignatureError {\n    #[cfg(not(feature = \"alloc\"))]\n    fn from(_err: InternalError) -> SignatureError {\n        SignatureError::new()\n    }\n\n    #[cfg(feature = \"alloc\")]\n    fn from(err: InternalError) -> SignatureError {\n        SignatureError::from_source(err)\n    }\n}\n",
    "filename": "ed25519-dalek/src/errors.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  },
  "63684": {
    "text": "//! Minimal implementation of (parts of) Strobe.\n\nuse core::ops::{Deref, DerefMut};\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::Zeroize;\n\n/// Strobe R value; security level 128 is hardcoded\nconst STROBE_R: u8 = 166;\n\nconst FLAG_I: u8 = 1;\nconst FLAG_A: u8 = 1 << 1;\nconst FLAG_C: u8 = 1 << 2;\nconst FLAG_T: u8 = 1 << 3;\nconst FLAG_M: u8 = 1 << 4;\nconst FLAG_K: u8 = 1 << 5;\n\nfn transmute_state(st: &mut AlignedKeccakState) -> &mut [u64; 25] {\n    unsafe { &mut *(st as *mut AlignedKeccakState as *mut [u64; 25]) }\n}\n\n/// This is a wrapper around 200-byte buffer that's always 8-byte aligned\n/// to make pointers to it safely convertible to pointers to [u64; 25]\n/// (since u64 words must be 8-byte aligned)\n#[derive(Clone)]\n#[repr(align(8))]\nstruct AlignedKeccakState([u8; 200]);\n\n#[cfg(feature = \"zeroize\")]\nimpl Drop for AlignedKeccakState {\n    fn drop(&mut self) {\n        self.0.zeroize();\n    }\n}\n\n/// A Strobe context for the 128-bit security level.\n///\n/// Only `meta-AD`, `AD`, `KEY`, and `PRF` operations are supported.\n#[derive(Clone)]\npub struct Strobe128 {\n    state: AlignedKeccakState,\n    pos: u8,\n    pos_begin: u8,\n    cur_flags: u8,\n}\n\nimpl ::core::fmt::Debug for Strobe128 {\n    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {\n        // Ensure that the Strobe state isn't accidentally logged\n        write!(f, \"Strobe128: STATE OMITTED\")\n    }\n}\n\nimpl Strobe128 {\n    pub fn new(protocol_label: &[u8]) -> Strobe128 {\n        let initial_state = {\n            let mut st = AlignedKeccakState([0u8; 200]);\n            st[0..6].copy_from_slice(&[1, STROBE_R + 2, 1, 0, 1, 96]);\n            st[6..18].copy_from_slice(b\"STROBEv1.0.2\");\n            keccak::f1600(transmute_state(&mut st));\n\n            st\n        };\n\n        let mut strobe = Strobe128 {\n            state: initial_state,\n            pos: 0,\n            pos_begin: 0,\n            cur_flags: 0,\n        };\n\n        strobe.meta_ad(protocol_label, false);\n\n        strobe\n    }\n\n    pub fn meta_ad(&mut self, data: &[u8], more: bool) {\n        self.begin_op(FLAG_M | FLAG_A, more);\n        self.absorb(data);\n    }\n\n    pub fn ad(&mut self, data: &[u8], more: bool) {\n        self.begin_op(FLAG_A, more);\n        self.absorb(data);\n    }\n\n    pub fn prf(&mut self, data: &mut [u8], more: bool) {\n        self.begin_op(FLAG_I | FLAG_A | FLAG_C, more);\n        self.squeeze(data);\n    }\n\n    pub fn key(&mut self, data: &[u8], more: bool) {\n        self.begin_op(FLAG_A | FLAG_C, more);\n        self.overwrite(data);\n    }\n}\n\nimpl Strobe128 {\n    fn run_f(&mut self) {\n        self.state[self.pos as usize] ^= self.pos_begin;\n        self.state[(self.pos + 1) as usize] ^= 0x04;\n        self.state[(STROBE_R + 1) as usize] ^= 0x80;\n        keccak::f1600(transmute_state(&mut self.state));\n        self.pos = 0;\n        self.pos_begin = 0;\n    }\n\n    fn absorb(&mut self, data: &[u8]) {\n        for byte in data {\n            self.state[self.pos as usize] ^= byte;\n            self.pos += 1;\n            if self.pos == STROBE_R {\n                self.run_f();\n            }\n        }\n    }\n\n    fn overwrite(&mut self, data: &[u8]) {\n        for byte in data {\n            self.state[self.pos as usize] = *byte;\n            self.pos += 1;\n            if self.pos == STROBE_R {\n                self.run_f();\n            }\n        }\n    }\n\n    fn squeeze(&mut self, data: &mut [u8]) {\n        for byte in data {\n            *byte = self.state[self.pos as usize];\n            self.state[self.pos as usize] = 0;\n            self.pos += 1;\n            if self.pos == STROBE_R {\n                self.run_f();\n            }\n        }\n    }\n\n    fn begin_op(&mut self, flags: u8, more: bool) {\n        // Check if we're continuing an operation\n        if more {\n            assert_eq!(\n                self.cur_flags, flags,\n                \"You tried to continue op {:#b} but changed flags to {:#b}\",\n                self.cur_flags, flags,\n            );\n            return;\n        }\n\n        // Skip adjusting direction information (we just use AD, PRF)\n        assert_eq!(\n            flags & FLAG_T,\n            0u8,\n            \"You used the T flag, which this implementation doesn't support\"\n        );\n\n        let old_begin = self.pos_begin;\n        self.pos_begin = self.pos + 1;\n        self.cur_flags = flags;\n\n        self.absorb(&[old_begin, flags]);\n\n        // Force running F if C or K is set\n        let force_f = 0 != (flags & (FLAG_C | FLAG_K));\n\n        if force_f && self.pos != 0 {\n            self.run_f();\n        }\n    }\n}\n\nimpl Deref for AlignedKeccakState {\n    type Target = [u8; 200];\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl DerefMut for AlignedKeccakState {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use strobe_rs::{self, SecParam};\n\n    #[test]\n    fn test_conformance() {\n        let mut s1 = super::Strobe128::new(b\"Conformance Test Protocol\");\n        let mut s2 = strobe_rs::Strobe::new(b\"Conformance Test Protocol\", SecParam::B128);\n\n        // meta-AD(b\"msg\"); AD(msg)\n\n        let msg = [99u8; 1024];\n\n        s1.meta_ad(b\"ms\", false);\n        s1.meta_ad(b\"g\", true);\n        s1.ad(&msg, false);\n\n        s2.meta_ad(b\"ms\", false);\n        s2.meta_ad(b\"g\", true);\n        s2.ad(&msg, false);\n\n        // meta-AD(b\"prf\"); PRF()\n\n        let mut prf1 = [0u8; 32];\n        s1.meta_ad(b\"prf\", false);\n        s1.prf(&mut prf1, false);\n\n        let mut prf2 = [0u8; 32];\n        s2.meta_ad(b\"prf\", false);\n        s2.prf(&mut prf2, false);\n\n        assert_eq!(prf1, prf2);\n\n        // meta-AD(b\"key\"); KEY(prf output)\n\n        s1.meta_ad(b\"key\", false);\n        s1.key(&prf1, false);\n\n        s2.meta_ad(b\"key\", false);\n        s2.key(&prf2, false);\n\n        // meta-AD(b\"prf\"); PRF()\n\n        let mut prf1 = [0u8; 32];\n        s1.meta_ad(b\"prf\", false);\n        s1.prf(&mut prf1, false);\n\n        let mut prf2 = [0u8; 32];\n        s2.meta_ad(b\"prf\", false);\n        s2.prf(&mut prf2, false);\n\n        assert_eq!(prf1, prf2);\n    }\n}\n",
    "filename": "ed25519-dalek/src/batch/strobe.rs",
    "filepath": null,
    "folder_id": 15850,
    "user_id": 460154
  },
  "63685": {
    "text": "use super::MERLIN_PROTOCOL_LABEL;\nuse super::strobe::Strobe128;\n\nfn encode_usize_as_u32(x: usize) -> [u8; 4] {\n    u32::try_from(x).expect(\"usize too large\").to_le_bytes()\n}\n\n/// A transcript of a public-coin argument.\n///\n/// The prover's messages are added to the transcript using\n/// [`append_message`](Transcript::append_message), and the verifier's\n/// challenges can be computed using\n/// [`challenge_bytes`](Transcript::challenge_bytes).\n///\n/// # Creating and using a Merlin transcript\n///\n/// To create a Merlin transcript, use [`Transcript::new()`].  This\n/// function takes a domain separation label which should be unique to\n/// the application.\n///\n/// To use the transcript with a Merlin-based proof implementation,\n/// the prover's side creates a Merlin transcript with an\n/// application-specific domain separation label, and passes a `&mut`\n/// reference to the transcript to the proving function(s).\n///\n/// To verify the resulting proof, the verifier creates their own\n/// Merlin transcript using the same domain separation label, then\n/// passes a `&mut` reference to the verifier's transcript to the\n/// verification function.\n///\n/// # Implementing proofs using Merlin\n///\n/// For information on the design of Merlin and how to use it to\n/// implement a proof system, see the documentation at\n/// [merlin.cool](https://merlin.cool), particularly the [Using\n/// Merlin](https://merlin.cool/use/index.html) section.\n#[derive(Clone)]\npub struct Transcript {\n    strobe: Strobe128,\n}\n\nimpl Transcript {\n    /// Initialize a new transcript with the supplied `label`, which\n    /// is used as a domain separator.\n    ///\n    /// # Note\n    ///\n    /// This function should be called by a proof library's API\n    /// consumer (i.e., the application using the proof library), and\n    /// **not by the proof implementation**.  See the [Passing\n    /// Transcripts](https://merlin.cool/use/passing.html) section of\n    /// the Merlin website for more details on why.\n    pub fn new(label: &'static [u8]) -> Transcript {\n        let mut transcript = Transcript {\n            strobe: Strobe128::new(MERLIN_PROTOCOL_LABEL),\n        };\n        transcript.append_message(b\"dom-sep\", label);\n\n        transcript\n    }\n\n    /// Append a prover's `message` to the transcript.\n    ///\n    /// The `label` parameter is metadata about the message, and is\n    /// also appended to the transcript.  See the [Transcript\n    /// Protocols](https://merlin.cool/use/protocol.html) section of\n    /// the Merlin website for details on labels.\n    pub fn append_message(&mut self, label: &'static [u8], message: &[u8]) {\n        let data_len = encode_usize_as_u32(message.len());\n        self.strobe.meta_ad(label, false);\n        self.strobe.meta_ad(&data_len, true);\n        self.strobe.ad(message, false);\n    }\n\n    /// Fill the supplied buffer with the verifier's challenge bytes.\n    ///\n    /// The `label` parameter is metadata about the challenge, and is\n    /// also appended to the transcript.  See the [Transcript\n    /// Protocols](https://merlin.cool/use/protocol.html) section of\n    /// the Merlin website for details on labels.\n    #[cfg(test)]\n    pub fn challenge_bytes(&mut self, label: &'static [u8], dest: &mut [u8]) {\n        let data_len = encode_usize_as_u32(dest.len());\n        self.strobe.meta_ad(label, false);\n        self.strobe.meta_ad(&data_len, true);\n        self.strobe.prf(dest, false);\n    }\n\n    /// Fork the current [`Transcript`] to construct an RNG whose output is bound\n    /// to the current transcript state as well as prover's secrets.\n    ///\n    /// See the [`TranscriptRngBuilder`] documentation for more details.\n    pub fn build_rng(&self) -> TranscriptRngBuilder {\n        TranscriptRngBuilder {\n            strobe: self.strobe.clone(),\n        }\n    }\n}\n\n/// Constructs a [`TranscriptRng`] by rekeying the [`Transcript`] with\n/// prover secrets and an external RNG.\n///\n/// The prover uses a [`TranscriptRngBuilder`] to rekey with its\n/// witness data, before using an external RNG to finalize to a\n/// [`TranscriptRng`].  The resulting [`TranscriptRng`] will be a PRF\n/// of all of the entire public transcript, the prover's secret\n/// witness data, and randomness from the external RNG.\n///\n/// # Note\n///\n/// Protocols that require randomness in multiple places (e.g., to\n/// choose blinding factors for a multi-round protocol) should create\n/// a fresh [`TranscriptRng`] **each time they need randomness**,\n/// rather than reusing a single instance.  This ensures that the\n/// randomness in each round is bound to the latest transcript state,\n/// rather than just the state of the transcript when randomness was\n/// first required.\n///\n/// # Typed Witness Data\n///\n/// Like the [`Transcript`], the [`TranscriptRngBuilder`] provides a\n/// minimal, byte-oriented API, and like the [`Transcript`], this API\n/// can be extended to allow rekeying with protocol-specific types\n/// using an extension trait.  See the [Transcript\n/// Protocols](https://merlin.cool/use/protocol.html) section of the\n/// Merlin website for more details.\n///\n/// [rekey_with_witness_bytes]: TranscriptRngBuilder::rekey_with_witness_bytes\n/// [finalize]: TranscriptRngBuilder::finalize\npub struct TranscriptRngBuilder {\n    strobe: Strobe128,\n}\n\nimpl TranscriptRngBuilder {\n    /// Rekey the transcript using the provided witness data.\n    ///\n    /// The `label` parameter is metadata about `witness`.\n    #[cfg(test)]\n    pub fn rekey_with_witness_bytes(\n        mut self,\n        label: &'static [u8],\n        witness: &[u8],\n    ) -> TranscriptRngBuilder {\n        let witness_len = encode_usize_as_u32(witness.len());\n        self.strobe.meta_ad(label, false);\n        self.strobe.meta_ad(&witness_len, true);\n        self.strobe.key(witness, false);\n\n        self\n    }\n\n    /// Use the supplied external `rng` to rekey the transcript, so\n    /// that the finalized [`TranscriptRng`] is a PRF bound to\n    /// randomness from the external RNG, as well as all other\n    /// transcript data.\n    pub fn finalize<R>(mut self, rng: &mut R) -> TranscriptRng\n    where\n        R: rand_core::RngCore + rand_core::CryptoRng,\n    {\n        let random_bytes = {\n            let mut bytes = [0u8; 32];\n            rng.fill_bytes(&mut bytes);\n            bytes\n        };\n\n        self.strobe.meta_ad(b\"rng\", false);\n        self.strobe.key(&random_bytes, false);\n\n        TranscriptRng {\n            strobe: self.strobe,\n        }\n    }\n}\n\n/// An RNG providing synthetic randomness to the prover.\n///\n/// A [`TranscriptRng`] is constructed from a [`Transcript`] using a\n/// [`TranscriptRngBuilder`]; see its documentation for details on\n/// how to construct one.\n///\n/// The transcript RNG construction is described in the [Generating\n/// Randomness](https://merlin.cool/transcript/rng.html) section of\n/// the Merlin website.\npub struct TranscriptRng {\n    strobe: Strobe128,\n}\n\nimpl rand_core::RngCore for TranscriptRng {\n    fn next_u32(&mut self) -> u32 {\n        rand_core::impls::next_u32_via_fill(self)\n    }\n\n    fn next_u64(&mut self) -> u64 {\n        rand_core::impls::next_u64_via_fill(self)\n    }\n\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        let dest_len = encode_usize_as_u32(dest.len());\n        self.strobe.meta_ad(&dest_len, false);\n        self.strobe.prf(dest, false);\n    }\n}\n\nimpl rand_core::CryptoRng for TranscriptRng {}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec::Vec;\n    use strobe_rs::SecParam;\n    use strobe_rs::Strobe;\n\n    use super::*;\n\n    /// Test against a full strobe implementation to ensure we match the few\n    /// operations we're interested in.\n    struct TestTranscript {\n        state: Strobe,\n    }\n\n    impl TestTranscript {\n        /// Strobe init; meta-AD(label)\n        pub fn new(label: &[u8]) -> TestTranscript {\n            let mut tt = TestTranscript {\n                state: Strobe::new(MERLIN_PROTOCOL_LABEL, SecParam::B128),\n            };\n            tt.append_message(b\"dom-sep\", label);\n\n            tt\n        }\n\n        /// Strobe op: meta-AD(label || len(message)); AD(message)\n        pub fn append_message(&mut self, label: &[u8], message: &[u8]) {\n            // metadata = label || len(message);\n            let mut metadata: Vec<u8> = Vec::with_capacity(label.len() + 4);\n            metadata.extend_from_slice(label);\n            metadata.extend_from_slice(&encode_usize_as_u32(message.len()));\n\n            self.state.meta_ad(&metadata, false);\n            self.state.ad(&message, false);\n        }\n\n        /// Strobe op: meta-AD(label || len(dest)); PRF into challenge_bytes\n        #[cfg(test)]\n        pub fn challenge_bytes(&mut self, label: &[u8], dest: &mut [u8]) {\n            let prf_len = dest.len();\n\n            // metadata = label || len(challenge_bytes);\n            let mut metadata: Vec<u8> = Vec::with_capacity(label.len() + 4);\n            metadata.extend_from_slice(label);\n            metadata.extend_from_slice(&encode_usize_as_u32(prf_len));\n\n            self.state.meta_ad(&metadata, false);\n            self.state.prf(dest, false);\n        }\n    }\n\n    /// Test a simple protocol with one message and one challenge\n    #[test]\n    fn equivalence_simple() {\n        let mut real_transcript = Transcript::new(b\"test protocol\");\n        let mut test_transcript = TestTranscript::new(b\"test protocol\");\n\n        real_transcript.append_message(b\"some label\", b\"some data\");\n        test_transcript.append_message(b\"some label\", b\"some data\");\n\n        let mut real_challenge = [0u8; 32];\n        let mut test_challenge = [0u8; 32];\n\n        real_transcript.challenge_bytes(b\"challenge\", &mut real_challenge);\n        test_transcript.challenge_bytes(b\"challenge\", &mut test_challenge);\n\n        assert_eq!(real_challenge, test_challenge);\n    }\n\n    /// Test a complex protocol with multiple messages and challenges,\n    /// with messages long enough to wrap around the sponge state, and\n    /// with multiple rounds of messages and challenges.\n    #[test]\n    fn equivalence_complex() {\n        let mut real_transcript = Transcript::new(b\"test protocol\");\n        let mut test_transcript = TestTranscript::new(b\"test protocol\");\n\n        let data = vec![99; 1024];\n\n        real_transcript.append_message(b\"step1\", b\"some data\");\n        test_transcript.append_message(b\"step1\", b\"some data\");\n\n        let mut real_challenge = [0u8; 32];\n        let mut test_challenge = [0u8; 32];\n\n        for _ in 0..32 {\n            real_transcript.challenge_bytes(b\"challenge\", &mut real_challenge);\n            test_transcript.challenge_bytes(b\"challenge\", &mut test_challenge);\n\n            assert_eq!(real_challenge, test_challenge);\n\n            real_transcript.append_message(b\"bigdata\", &data);\n            test_transcript.append_message(b\"bigdata\", &data);\n\n            real_transcript.append_message(b\"challengedata\", &real_challenge);\n            test_transcript.append_message(b\"challengedata\", &test_challenge);\n        }\n    }\n\n    #[test]\n    fn transcript_rng_is_bound_to_transcript_and_witnesses() {\n        use curve25519_dalek::scalar::Scalar;\n        use rand_chacha::ChaChaRng;\n        use rand_core::SeedableRng;\n\n        // Check that the TranscriptRng is bound to the transcript and\n        // the witnesses.  This is done by producing a sequence of\n        // transcripts that diverge at different points and checking\n        // that they produce different challenges.\n\n        let protocol_label = b\"test TranscriptRng collisions\";\n        let commitment1 = b\"commitment data 1\";\n        let commitment2 = b\"commitment data 2\";\n        let witness1 = b\"witness data 1\";\n        let witness2 = b\"witness data 2\";\n\n        let mut t1 = Transcript::new(protocol_label);\n        let mut t2 = Transcript::new(protocol_label);\n        let mut t3 = Transcript::new(protocol_label);\n        let mut t4 = Transcript::new(protocol_label);\n\n        t1.append_message(b\"com\", commitment1);\n        t2.append_message(b\"com\", commitment2);\n        t3.append_message(b\"com\", commitment2);\n        t4.append_message(b\"com\", commitment2);\n\n        let mut r1 = t1\n            .build_rng()\n            .rekey_with_witness_bytes(b\"witness\", witness1)\n            .finalize(&mut ChaChaRng::from_seed([0; 32]));\n\n        let mut r2 = t2\n            .build_rng()\n            .rekey_with_witness_bytes(b\"witness\", witness1)\n            .finalize(&mut ChaChaRng::from_seed([0; 32]));\n\n        let mut r3 = t3\n            .build_rng()\n            .rekey_with_witness_bytes(b\"witness\", witness2)\n            .finalize(&mut ChaChaRng::from_seed([0; 32]));\n\n        let mut r4 = t4\n            .build_rng()\n            .rekey_with_witness_bytes(b\"witness\", witness2)\n            .finalize(&mut ChaChaRng::from_seed([0; 32]));\n\n        let s1 = Scalar::random(&mut r1);\n        let s2 = Scalar::random(&mut r2);\n        let s3 = Scalar::random(&mut r3);\n        let s4 = Scalar::random(&mut r4);\n\n        // Transcript t1 has different commitments than t2, t3, t4, so\n        // it should produce distinct challenges from all of them.\n        assert_ne!(s1, s2);\n        assert_ne!(s1, s3);\n        assert_ne!(s1, s4);\n\n        // Transcript t2 has different witness variables from t3, t4,\n        // so it should produce distinct challenges from all of them.\n        assert_ne!(s2, s3);\n        assert_ne!(s2, s4);\n\n        // Transcripts t3 and t4 have the same commitments and\n        // witnesses, so they should give different challenges only\n        // based on the RNG. Checking that they're equal in the\n        // presence of a bad RNG checks that the different challenges\n        // above aren't because the RNG is accidentally different.\n        assert_eq!(s3, s4);\n    }\n}\n",
    "filename": "ed25519-dalek/src/batch/transcript.rs",
    "filepath": null,
    "folder_id": 15850,
    "user_id": 460154
  },
  "63686": {
    "text": "use curve25519_dalek::edwards::CompressedEdwardsY;\nuse sha2::Sha512;\n\nuse crate::verifying::RCompute;\nuse crate::{InternalError, SignatureError, VerifyingKey, signature::InternalSignature};\n\n/// An IUF verifier for ed25519.\n///\n/// Created with [`VerifyingKey::verify_stream()`] or [`SigningKey::verify_stream()`].\n///\n/// [`SigningKey::verify_stream()`]: super::SigningKey::verify_stream()\n#[allow(non_snake_case)]\npub struct StreamVerifier {\n    cr: RCompute<Sha512>,\n    sig_R: CompressedEdwardsY,\n}\n\nimpl StreamVerifier {\n    /// Constructs new stream verifier.\n    ///\n    /// Seeds hash state with public key and signature components.\n    pub(crate) fn new(public_key: VerifyingKey, signature: InternalSignature) -> Self {\n        Self {\n            cr: RCompute::new(&public_key, signature, None),\n            sig_R: signature.R,\n        }\n    }\n\n    /// Digest message chunk.\n    pub fn update(&mut self, chunk: impl AsRef<[u8]>) {\n        self.cr.update(chunk.as_ref());\n    }\n\n    /// Finalize verifier and check against candidate signature.\n    #[allow(non_snake_case)]\n    pub fn finalize_and_verify(self) -> Result<(), SignatureError> {\n        let expected_R = self.cr.finish();\n\n        if expected_R == self.sig_R {\n            Ok(())\n        } else {\n            Err(InternalError::Verify.into())\n        }\n    }\n}\n",
    "filename": "ed25519-dalek/src/verifying/stream.rs",
    "filepath": null,
    "folder_id": 15851,
    "user_id": 460154
  },
  "63687": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2017-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\n//! ed25519 signing keys.\n\nuse core::fmt::Debug;\n\n#[cfg(feature = \"pkcs8\")]\nuse ed25519::pkcs8;\n\n#[cfg(any(test, feature = \"rand_core\"))]\nuse rand_core::CryptoRng;\n\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\nuse sha2::Sha512;\nuse subtle::{Choice, ConstantTimeEq};\n\nuse curve25519_dalek::{\n    digest::{Digest, array::typenum::U64},\n    edwards::{CompressedEdwardsY, EdwardsPoint},\n    scalar::Scalar,\n};\n\nuse ed25519::signature::{KeypairRef, MultipartSigner, MultipartVerifier, Signer, Verifier};\n\n#[cfg(feature = \"digest\")]\nuse crate::context::Context;\n#[cfg(feature = \"digest\")]\nuse signature::DigestSigner;\n\n#[cfg(feature = \"zeroize\")]\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n\n#[cfg(feature = \"hazmat\")]\nuse crate::verifying::StreamVerifier;\nuse crate::{\n    Signature,\n    constants::{KEYPAIR_LENGTH, SECRET_KEY_LENGTH},\n    errors::{InternalError, SignatureError},\n    hazmat::ExpandedSecretKey,\n    signature::InternalSignature,\n    verifying::VerifyingKey,\n};\n\n/// ed25519 secret key as defined in [RFC8032 § 5.1.5]:\n///\n/// > The private key is 32 octets (256 bits, corresponding to b) of\n/// > cryptographically secure random data.\n///\n/// [RFC8032 § 5.1.5]: https://www.rfc-editor.org/rfc/rfc8032#section-5.1.5\npub type SecretKey = [u8; SECRET_KEY_LENGTH];\n\n/// ed25519 signing key which can be used to produce signatures.\n// Invariant: `verifying_key` is always the public key of\n// `secret_key`. This prevents the signing function oracle attack\n// described in https://github.com/MystenLabs/ed25519-unsafe-libs\n#[derive(Clone)]\npub struct SigningKey {\n    /// The secret half of this signing key.\n    pub(crate) secret_key: SecretKey,\n    /// The public half of this signing key.\n    pub(crate) verifying_key: VerifyingKey,\n}\n\n/// # Example\n///\n/// ```\n/// # extern crate ed25519_dalek;\n/// #\n/// use ed25519_dalek::SigningKey;\n/// use ed25519_dalek::SECRET_KEY_LENGTH;\n/// use ed25519_dalek::SignatureError;\n///\n/// # fn doctest() -> Result<SigningKey, SignatureError> {\n/// let secret_key_bytes: [u8; SECRET_KEY_LENGTH] = [\n///    157, 097, 177, 157, 239, 253, 090, 096,\n///    186, 132, 074, 244, 146, 236, 044, 196,\n///    068, 073, 197, 105, 123, 050, 105, 025,\n///    112, 059, 172, 003, 028, 174, 127, 096, ];\n///\n/// let signing_key: SigningKey = SigningKey::from_bytes(&secret_key_bytes);\n/// assert_eq!(signing_key.to_bytes(), secret_key_bytes);\n///\n/// # Ok(signing_key)\n/// # }\n/// #\n/// # fn main() {\n/// #     let result = doctest();\n/// #     assert!(result.is_ok());\n/// # }\n/// ```\nimpl SigningKey {\n    /// Construct a [`SigningKey`] from a [`SecretKey`]\n    ///\n    #[inline]\n    pub fn from_bytes(secret_key: &SecretKey) -> Self {\n        let verifying_key = VerifyingKey::from(&ExpandedSecretKey::from(secret_key));\n        Self {\n            secret_key: *secret_key,\n            verifying_key,\n        }\n    }\n\n    /// Convert this [`SigningKey`] into a [`SecretKey`]\n    #[inline]\n    pub fn to_bytes(&self) -> SecretKey {\n        self.secret_key\n    }\n\n    /// Convert this [`SigningKey`] into a [`SecretKey`] reference\n    #[inline]\n    pub fn as_bytes(&self) -> &SecretKey {\n        &self.secret_key\n    }\n\n    /// Construct a [`SigningKey`] from the bytes of a `VerifyingKey` and `SecretKey`.\n    ///\n    /// # Inputs\n    ///\n    /// * `bytes`: an `&[u8]` of length [`KEYPAIR_LENGTH`], representing the\n    ///   scalar for the secret key, and a compressed Edwards-Y coordinate of a\n    ///   point on curve25519, both as bytes. (As obtained from\n    ///   [`SigningKey::to_bytes`].)\n    ///\n    /// # Returns\n    ///\n    /// A `Result` whose okay value is an EdDSA [`SigningKey`] or whose error value\n    /// is a `SignatureError` describing the error that occurred.\n    #[inline]\n    pub fn from_keypair_bytes(bytes: &[u8; 64]) -> Result<SigningKey, SignatureError> {\n        let (secret_key, verifying_key) = bytes.split_at(SECRET_KEY_LENGTH);\n        let signing_key = SigningKey::try_from(secret_key)?;\n        let verifying_key = VerifyingKey::try_from(verifying_key)?;\n\n        if signing_key.verifying_key() != verifying_key {\n            return Err(InternalError::MismatchedKeypair.into());\n        }\n\n        Ok(signing_key)\n    }\n\n    /// Convert this signing key to a 64-byte keypair.\n    ///\n    /// # Returns\n    ///\n    /// An array of bytes, `[u8; KEYPAIR_LENGTH]`.  The first\n    /// `SECRET_KEY_LENGTH` of bytes is the `SecretKey`, and the next\n    /// `PUBLIC_KEY_LENGTH` bytes is the `VerifyingKey` (the same as other\n    /// libraries, such as [Adam Langley's ed25519 Golang\n    /// implementation](https://github.com/agl/ed25519/)). It is guaranteed that\n    /// the encoded public key is the one derived from the encoded secret key.\n    pub fn to_keypair_bytes(&self) -> [u8; KEYPAIR_LENGTH] {\n        let mut bytes: [u8; KEYPAIR_LENGTH] = [0u8; KEYPAIR_LENGTH];\n\n        bytes[..SECRET_KEY_LENGTH].copy_from_slice(&self.secret_key);\n        bytes[SECRET_KEY_LENGTH..].copy_from_slice(self.verifying_key.as_bytes());\n        bytes\n    }\n\n    /// Get the [`VerifyingKey`] for this [`SigningKey`].\n    pub fn verifying_key(&self) -> VerifyingKey {\n        self.verifying_key\n    }\n\n    /// Create a signing context that can be used for Ed25519ph with\n    /// [`DigestSigner`].\n    #[cfg(feature = \"digest\")]\n    pub fn with_context<'k, 'v>(\n        &'k self,\n        context_value: &'v [u8],\n    ) -> Result<Context<'k, 'v, Self>, SignatureError> {\n        Context::new(self, context_value)\n    }\n\n    /// Generate an ed25519 signing key.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(feature = \"rand_core\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n    /// # fn main() {\n    /// use rand::rngs::OsRng;\n    /// use rand_core::TryRngCore;\n    /// use ed25519_dalek::{Signature, SigningKey};\n    ///\n    /// let mut csprng = OsRng.unwrap_err();\n    /// let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n    /// # }\n    /// ```\n    ///\n    /// # Input\n    ///\n    /// A CSPRNG with a `fill_bytes()` method, e.g. `rand_os::OsRng`.\n    #[cfg(any(test, feature = \"rand_core\"))]\n    pub fn generate<R: CryptoRng + ?Sized>(csprng: &mut R) -> SigningKey {\n        let mut secret = SecretKey::default();\n        csprng.fill_bytes(&mut secret);\n        Self::from_bytes(&secret)\n    }\n\n    /// Sign a `prehashed_message` with this [`SigningKey`] using the\n    /// Ed25519ph algorithm defined in [RFC8032 §5.1][rfc8032].\n    ///\n    /// # Inputs\n    ///\n    /// * `prehashed_message` is an instantiated hash digest with 512-bits of\n    ///   output which has had the message to be signed previously fed into its\n    ///   state.\n    /// * `context` is an optional context string, up to 255 bytes inclusive,\n    ///   which may be used to provide additional domain separation.  If not\n    ///   set, this will default to an empty string.\n    ///\n    /// # Returns\n    ///\n    /// An Ed25519ph [`Signature`] on the `prehashed_message`.\n    ///\n    /// # Note\n    ///\n    /// The RFC only permits SHA-512 to be used for prehashing, i.e., `MsgDigest = Sha512`. This\n    /// function technically works, and is probably safe to use, with any secure hash function with\n    /// 512-bit digests, but anything outside of SHA-512 is NOT specification-compliant. We expose\n    /// [`crate::Sha512`] for user convenience.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(all(feature = \"rand_core\", feature = \"digest\"), doc = \"```\")]\n    #[cfg_attr(\n        any(not(feature = \"rand_core\"), not(feature = \"digest\")),\n        doc = \"```ignore\"\n    )]\n    /// use ed25519_dalek::Digest;\n    /// use ed25519_dalek::SigningKey;\n    /// use ed25519_dalek::Signature;\n    /// use sha2::Sha512;\n    /// use rand::rngs::OsRng;\n    /// use rand_core::TryRngCore;\n    ///\n    /// # fn main() {\n    /// let mut csprng = OsRng.unwrap_err();\n    /// let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n    /// let message: &[u8] = b\"All I want is to pet all of the dogs.\";\n    ///\n    /// // Create a hash digest object which we'll feed the message into:\n    /// let mut prehashed: Sha512 = Sha512::new();\n    ///\n    /// prehashed.update(message);\n    /// # }\n    /// ```\n    ///\n    /// If you want, you can optionally pass a \"context\".  It is generally a\n    /// good idea to choose a context and try to make it unique to your project\n    /// and this specific usage of signatures.\n    ///\n    /// For example, without this, if you were to [convert your OpenPGP key\n    /// to a Bitcoin key][terrible_idea] (just as an example, and also Don't\n    /// Ever Do That) and someone tricked you into signing an \"email\" which was\n    /// actually a Bitcoin transaction moving all your magic internet money to\n    /// their address, it'd be a valid transaction.\n    ///\n    /// By adding a context, this trick becomes impossible, because the context\n    /// is concatenated into the hash, which is then signed.  So, going with the\n    /// previous example, if your bitcoin wallet used a context of\n    /// \"BitcoinWalletAppTxnSigning\" and OpenPGP used a context (this is likely\n    /// the least of their safety problems) of \"GPGsCryptoIsntConstantTimeLol\",\n    /// then the signatures produced by both could never match the other, even\n    /// if they signed the exact same message with the same key.\n    ///\n    /// Let's add a context for good measure (remember, you'll want to choose\n    /// your own!):\n    ///\n    #[cfg_attr(all(feature = \"rand_core\", feature = \"digest\"), doc = \"```\")]\n    #[cfg_attr(\n        any(not(feature = \"rand_core\"), not(feature = \"digest\")),\n        doc = \"```ignore\"\n    )]\n    /// # use ed25519_dalek::Digest;\n    /// # use ed25519_dalek::SigningKey;\n    /// # use ed25519_dalek::Signature;\n    /// # use ed25519_dalek::SignatureError;\n    /// # use sha2::Sha512;\n    /// # use rand::rngs::OsRng;\n    /// # use rand_core::TryRngCore;\n    /// #\n    /// # fn do_test() -> Result<Signature, SignatureError> {\n    /// # let mut csprng = OsRng.unwrap_err();\n    /// # let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n    /// # let message: &[u8] = b\"All I want is to pet all of the dogs.\";\n    /// # let mut prehashed: Sha512 = Sha512::new();\n    /// # prehashed.update(message);\n    /// #\n    /// let context: &[u8] = b\"Ed25519DalekSignPrehashedDoctest\";\n    ///\n    /// let sig: Signature = signing_key.sign_prehashed(prehashed, Some(context))?;\n    /// #\n    /// # Ok(sig)\n    /// # }\n    /// # fn main() {\n    /// #     do_test();\n    /// # }\n    /// ```\n    ///\n    /// [rfc8032]: https://tools.ietf.org/html/rfc8032#section-5.1\n    /// [terrible_idea]: https://github.com/isislovecruft/scripts/blob/master/gpgkey2bc.py\n    #[cfg(feature = \"digest\")]\n    pub fn sign_prehashed<MsgDigest>(\n        &self,\n        prehashed_message: MsgDigest,\n        context: Option<&[u8]>,\n    ) -> Result<Signature, SignatureError>\n    where\n        MsgDigest: Digest<OutputSize = U64>,\n    {\n        ExpandedSecretKey::from(&self.secret_key).raw_sign_prehashed::<Sha512, MsgDigest>(\n            prehashed_message,\n            &self.verifying_key,\n            context,\n        )\n    }\n\n    /// Verify a signature on a message with this signing key's public key.\n    pub fn verify(&self, message: &[u8], signature: &Signature) -> Result<(), SignatureError> {\n        self.verifying_key.verify(message, signature)\n    }\n\n    /// Verify a `signature` on a `prehashed_message` using the Ed25519ph algorithm.\n    ///\n    /// # Inputs\n    ///\n    /// * `prehashed_message` is an instantiated hash digest with 512-bits of\n    ///   output which has had the message to be signed previously fed into its\n    ///   state.\n    /// * `context` is an optional context string, up to 255 bytes inclusive,\n    ///   which may be used to provide additional domain separation.  If not\n    ///   set, this will default to an empty string.\n    /// * `signature` is a purported Ed25519ph [`Signature`] on the `prehashed_message`.\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the `signature` was a valid signature created by this\n    /// [`SigningKey`] on the `prehashed_message`.\n    ///\n    /// # Note\n    ///\n    /// The RFC only permits SHA-512 to be used for prehashing, i.e., `MsgDigest = Sha512`. This\n    /// function technically works, and is probably safe to use, with any secure hash function with\n    /// 512-bit digests, but anything outside of SHA-512 is NOT specification-compliant. We expose\n    /// [`crate::Sha512`] for user convenience.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(all(feature = \"rand_core\", feature = \"digest\"), doc = \"```\")]\n    #[cfg_attr(\n        any(not(feature = \"rand_core\"), not(feature = \"digest\")),\n        doc = \"```ignore\"\n    )]\n    /// use ed25519_dalek::Digest;\n    /// use ed25519_dalek::SigningKey;\n    /// use ed25519_dalek::Signature;\n    /// use ed25519_dalek::SignatureError;\n    /// use sha2::Sha512;\n    /// use rand::rngs::OsRng;\n    /// use rand_core::TryRngCore;\n    ///\n    /// # fn do_test() -> Result<(), SignatureError> {\n    /// let mut csprng = OsRng.unwrap_err();\n    /// let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n    /// let message: &[u8] = b\"All I want is to pet all of the dogs.\";\n    ///\n    /// let mut prehashed: Sha512 = Sha512::new();\n    /// prehashed.update(message);\n    ///\n    /// let context: &[u8] = b\"Ed25519DalekSignPrehashedDoctest\";\n    ///\n    /// let sig: Signature = signing_key.sign_prehashed(prehashed, Some(context))?;\n    ///\n    /// // The sha2::Sha512 struct doesn't implement Copy, so we'll have to create a new one:\n    /// let mut prehashed_again: Sha512 = Sha512::default();\n    /// prehashed_again.update(message);\n    ///\n    /// let verified = signing_key.verifying_key().verify_prehashed(prehashed_again, Some(context), &sig);\n    ///\n    /// assert!(verified.is_ok());\n    ///\n    /// # verified\n    /// # }\n    /// #\n    /// # fn main() {\n    /// #     do_test();\n    /// # }\n    /// ```\n    ///\n    /// [rfc8032]: https://tools.ietf.org/html/rfc8032#section-5.1\n    #[cfg(feature = \"digest\")]\n    pub fn verify_prehashed<MsgDigest>(\n        &self,\n        prehashed_message: MsgDigest,\n        context: Option<&[u8]>,\n        signature: &Signature,\n    ) -> Result<(), SignatureError>\n    where\n        MsgDigest: Digest<OutputSize = U64>,\n    {\n        self.verifying_key\n            .verify_prehashed(prehashed_message, context, signature)\n    }\n\n    /// Strictly verify a signature on a message with this signing key's public key.\n    ///\n    /// # On The (Multiple) Sources of Malleability in Ed25519 Signatures\n    ///\n    /// This version of verification is technically non-RFC8032 compliant.  The\n    /// following explains why.\n    ///\n    /// 1. Scalar Malleability\n    ///\n    /// The authors of the RFC explicitly stated that verification of an ed25519\n    /// signature must fail if the scalar `s` is not properly reduced mod \\ell:\n    ///\n    /// > To verify a signature on a message M using public key A, with F\n    /// > being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx or\n    /// > Ed25519ph is being used, C being the context, first split the\n    /// > signature into two 32-octet halves.  Decode the first half as a\n    /// > point R, and the second half as an integer S, in the range\n    /// > 0 <= s < L.  Decode the public key A as point A'.  If any of the\n    /// > decodings fail (including S being out of range), the signature is\n    /// > invalid.)\n    ///\n    /// All `verify_*()` functions within ed25519-dalek perform this check.\n    ///\n    /// 2. Point malleability\n    ///\n    /// The authors of the RFC added in a malleability check to step #3 in\n    /// §5.1.7, for small torsion components in the `R` value of the signature,\n    /// *which is not strictly required*, as they state:\n    ///\n    /// > Check the group equation \\[8\\]\\[S\\]B = \\[8\\]R + \\[8\\]\\[k\\]A'.  It's\n    /// > sufficient, but not required, to instead check \\[S\\]B = R + \\[k\\]A'.\n    ///\n    /// # History of Malleability Checks\n    ///\n    /// As originally defined (cf. the \"Malleability\" section in the README of\n    /// this repo), ed25519 signatures didn't consider *any* form of\n    /// malleability to be an issue.  Later the scalar malleability was\n    /// considered important.  Still later, particularly with interests in\n    /// cryptocurrency design and in unique identities (e.g. for Signal users,\n    /// Tor onion services, etc.), the group element malleability became a\n    /// concern.\n    ///\n    /// However, libraries had already been created to conform to the original\n    /// definition.  One well-used library in particular even implemented the\n    /// group element malleability check, *but only for batch verification*!\n    /// Which meant that even using the same library, a single signature could\n    /// verify fine individually, but suddenly, when verifying it with a bunch\n    /// of other signatures, the whole batch would fail!\n    ///\n    /// # \"Strict\" Verification\n    ///\n    /// This method performs *both* of the above signature malleability checks.\n    ///\n    /// It must be done as a separate method because one doesn't simply get to\n    /// change the definition of a cryptographic primitive ten years\n    /// after-the-fact with zero consideration for backwards compatibility in\n    /// hardware and protocols which have it already have the older definition\n    /// baked in.\n    ///\n    /// # Return\n    ///\n    /// Returns `Ok(())` if the signature is valid, and `Err` otherwise.\n    #[allow(non_snake_case)]\n    pub fn verify_strict(\n        &self,\n        message: &[u8],\n        signature: &Signature,\n    ) -> Result<(), SignatureError> {\n        self.verifying_key.verify_strict(message, signature)\n    }\n\n    /// Constructs stream verifier with candidate `signature`.\n    ///\n    /// See [`VerifyingKey::verify_stream()`] for more details.\n    #[cfg(feature = \"hazmat\")]\n    pub fn verify_stream(\n        &self,\n        signature: &ed25519::Signature,\n    ) -> Result<StreamVerifier, SignatureError> {\n        self.verifying_key.verify_stream(signature)\n    }\n\n    /// Convert this signing key into a byte representation of an unreduced, unclamped Curve25519\n    /// scalar. This is NOT the same thing as `self.to_scalar().to_bytes()`, since `to_scalar()`\n    /// performs a clamping step, which changes the value of the resulting scalar.\n    ///\n    /// This can be used for performing X25519 Diffie-Hellman using Ed25519 keys. The bytes output\n    /// by this function are a valid corresponding [`StaticSecret`](https://docs.rs/x25519-dalek/2.0.0/x25519_dalek/struct.StaticSecret.html#impl-From%3C%5Bu8;+32%5D%3E-for-StaticSecret)\n    /// for the X25519 public key given by `self.verifying_key().to_montgomery()`.\n    ///\n    /// # Note\n    ///\n    /// We do NOT recommend using a signing/verifying key for encryption. Signing keys are usually\n    /// long-term keys, while keys used for key exchange should rather be ephemeral. If you can\n    /// help it, use a separate key for encryption.\n    ///\n    /// For more information on the security of systems which use the same keys for both signing\n    /// and Diffie-Hellman, see the paper\n    /// [On using the same key pair for Ed25519 and an X25519 based KEM](https://eprint.iacr.org/2021/509).\n    pub fn to_scalar_bytes(&self) -> [u8; 32] {\n        // Per the spec, the ed25519 secret key sk is expanded to\n        //     (scalar_bytes, hash_prefix) = SHA-512(sk)\n        // where the two outputs are both 32 bytes. scalar_bytes is what we return. Its clamped and\n        // reduced form is what we use for signing (see impl ExpandedSecretKey)\n        let mut buf = [0u8; 32];\n        let scalar_and_hash_prefix = Sha512::default().chain_update(self.secret_key).finalize();\n        buf.copy_from_slice(&scalar_and_hash_prefix[..32]);\n        buf\n    }\n\n    /// Convert this signing key into a Curve25519 scalar. This is computed by clamping and\n    /// reducing the output of [`Self::to_scalar_bytes`].\n    ///\n    /// This can be used anywhere where a Curve25519 scalar is used as a private key, e.g., in\n    /// [`crypto_box`](https://docs.rs/crypto_box/0.9.1/crypto_box/struct.SecretKey.html#impl-From%3CScalar%3E-for-SecretKey).\n    ///\n    /// # Note\n    ///\n    /// We do NOT recommend using a signing/verifying key for encryption. Signing keys are usually\n    /// long-term keys, while keys used for key exchange should rather be ephemeral. If you can\n    /// help it, use a separate key for encryption.\n    ///\n    /// For more information on the security of systems which use the same keys for both signing\n    /// and Diffie-Hellman, see the paper\n    /// [On using the same key pair for Ed25519 and an X25519 based KEM](https://eprint.iacr.org/2021/509).\n    pub fn to_scalar(&self) -> Scalar {\n        // Per the spec, the ed25519 secret key sk is expanded to\n        //     (scalar_bytes, hash_prefix) = SHA-512(sk)\n        // where the two outputs are both 32 bytes. To use for signing, scalar_bytes must be\n        // clamped and reduced (see ExpandedSecretKey::from_bytes). We return the clamped and\n        // reduced form.\n        ExpandedSecretKey::from(&self.secret_key).scalar\n    }\n}\n\nimpl AsRef<VerifyingKey> for SigningKey {\n    fn as_ref(&self) -> &VerifyingKey {\n        &self.verifying_key\n    }\n}\n\nimpl Debug for SigningKey {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"SigningKey\")\n            .field(\"verifying_key\", &self.verifying_key)\n            .finish_non_exhaustive() // avoids printing `secret_key`\n    }\n}\n\nimpl KeypairRef for SigningKey {\n    type VerifyingKey = VerifyingKey;\n}\n\nimpl Signer<Signature> for SigningKey {\n    /// Sign a message with this signing key's secret key.\n    fn try_sign(&self, message: &[u8]) -> Result<Signature, SignatureError> {\n        self.try_multipart_sign(&[message])\n    }\n}\n\nimpl MultipartSigner<Signature> for SigningKey {\n    fn try_multipart_sign(&self, message: &[&[u8]]) -> Result<Signature, SignatureError> {\n        let expanded: ExpandedSecretKey = (&self.secret_key).into();\n        Ok(expanded.raw_sign::<Sha512>(message, &self.verifying_key))\n    }\n}\n\n/// Equivalent to [`SigningKey::sign_prehashed`] with `context` set to [`None`].\n///\n/// # Note\n///\n/// The RFC only permits SHA-512 to be used for prehashing. This function technically works, and is\n/// probably safe to use, with any secure hash function with 512-bit digests, but anything outside\n/// of SHA-512 is NOT specification-compliant. We expose [`crate::Sha512`] for user convenience.\n#[cfg(feature = \"digest\")]\nimpl<D> DigestSigner<D, Signature> for SigningKey\nwhere\n    D: Digest<OutputSize = U64>,\n{\n    fn try_sign_digest(&self, msg_digest: D) -> Result<Signature, SignatureError> {\n        self.sign_prehashed(msg_digest, None)\n    }\n}\n\n/// Equivalent to [`SigningKey::sign_prehashed`] with `context` set to [`Some`]\n/// containing `self.value()`.\n///\n/// # Note\n///\n/// The RFC only permits SHA-512 to be used for prehashing. This function technically works, and is\n/// probably safe to use, with any secure hash function with 512-bit digests, but anything outside\n/// of SHA-512 is NOT specification-compliant. We expose [`crate::Sha512`] for user convenience.\n#[cfg(feature = \"digest\")]\nimpl<D> DigestSigner<D, Signature> for Context<'_, '_, SigningKey>\nwhere\n    D: Digest<OutputSize = U64>,\n{\n    fn try_sign_digest(&self, msg_digest: D) -> Result<Signature, SignatureError> {\n        self.key().sign_prehashed(msg_digest, Some(self.value()))\n    }\n}\n\nimpl Verifier<Signature> for SigningKey {\n    /// Verify a signature on a message with this signing key's public key.\n    fn verify(&self, message: &[u8], signature: &Signature) -> Result<(), SignatureError> {\n        self.verifying_key.verify(message, signature)\n    }\n}\n\nimpl MultipartVerifier<Signature> for SigningKey {\n    fn multipart_verify(\n        &self,\n        message: &[&[u8]],\n        signature: &Signature,\n    ) -> Result<(), SignatureError> {\n        self.verifying_key.multipart_verify(message, signature)\n    }\n}\n\nimpl From<SecretKey> for SigningKey {\n    #[inline]\n    fn from(secret: SecretKey) -> Self {\n        Self::from_bytes(&secret)\n    }\n}\n\nimpl From<&SecretKey> for SigningKey {\n    #[inline]\n    fn from(secret: &SecretKey) -> Self {\n        Self::from_bytes(secret)\n    }\n}\n\nimpl TryFrom<&[u8]> for SigningKey {\n    type Error = SignatureError;\n\n    fn try_from(bytes: &[u8]) -> Result<SigningKey, SignatureError> {\n        SecretKey::try_from(bytes)\n            .map(|bytes| Self::from_bytes(&bytes))\n            .map_err(|_| {\n                InternalError::BytesLength {\n                    name: \"SecretKey\",\n                    length: SECRET_KEY_LENGTH,\n                }\n                .into()\n            })\n    }\n}\n\nimpl ConstantTimeEq for SigningKey {\n    fn ct_eq(&self, other: &Self) -> Choice {\n        self.secret_key.ct_eq(&other.secret_key)\n    }\n}\n\nimpl PartialEq for SigningKey {\n    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }\n}\n\nimpl Eq for SigningKey {}\n\n#[cfg(feature = \"zeroize\")]\nimpl Drop for SigningKey {\n    fn drop(&mut self) {\n        self.secret_key.zeroize();\n    }\n}\n\n#[cfg(feature = \"zeroize\")]\nimpl ZeroizeOnDrop for SigningKey {}\n\n#[cfg(all(feature = \"alloc\", feature = \"pkcs8\"))]\nimpl pkcs8::EncodePrivateKey for SigningKey {\n    fn to_pkcs8_der(&self) -> pkcs8::Result<pkcs8::SecretDocument> {\n        pkcs8::KeypairBytes::from(self).to_pkcs8_der()\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl TryFrom<pkcs8::KeypairBytes> for SigningKey {\n    type Error = pkcs8::Error;\n\n    fn try_from(pkcs8_key: pkcs8::KeypairBytes) -> pkcs8::Result<Self> {\n        SigningKey::try_from(&pkcs8_key)\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl TryFrom<&pkcs8::KeypairBytes> for SigningKey {\n    type Error = pkcs8::Error;\n\n    fn try_from(pkcs8_key: &pkcs8::KeypairBytes) -> pkcs8::Result<Self> {\n        let signing_key = SigningKey::from_bytes(&pkcs8_key.secret_key);\n\n        // Validate the public key in the PKCS#8 document if present\n        if let Some(public_bytes) = &pkcs8_key.public_key {\n            let expected_verifying_key = VerifyingKey::from_bytes(public_bytes.as_ref())\n                .map_err(|_| pkcs8::Error::KeyMalformed)?;\n\n            if signing_key.verifying_key() != expected_verifying_key {\n                return Err(pkcs8::Error::KeyMalformed);\n            }\n        }\n\n        Ok(signing_key)\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl pkcs8::spki::SignatureAlgorithmIdentifier for SigningKey {\n    type Params = pkcs8::spki::der::AnyRef<'static>;\n\n    const SIGNATURE_ALGORITHM_IDENTIFIER: pkcs8::spki::AlgorithmIdentifier<Self::Params> =\n        <Signature as pkcs8::spki::AssociatedAlgorithmIdentifier>::ALGORITHM_IDENTIFIER;\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl From<SigningKey> for pkcs8::KeypairBytes {\n    fn from(signing_key: SigningKey) -> pkcs8::KeypairBytes {\n        pkcs8::KeypairBytes::from(&signing_key)\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl From<&SigningKey> for pkcs8::KeypairBytes {\n    fn from(signing_key: &SigningKey) -> pkcs8::KeypairBytes {\n        pkcs8::KeypairBytes {\n            secret_key: signing_key.to_bytes(),\n            public_key: Some(pkcs8::PublicKeyBytes(signing_key.verifying_key.to_bytes())),\n        }\n    }\n}\n\n#[cfg(feature = \"pkcs8\")]\nimpl TryFrom<pkcs8::PrivateKeyInfoRef<'_>> for SigningKey {\n    type Error = pkcs8::Error;\n\n    fn try_from(private_key: pkcs8::PrivateKeyInfoRef<'_>) -> pkcs8::Result<Self> {\n        pkcs8::KeypairBytes::try_from(private_key)?.try_into()\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl Serialize for SigningKey {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_bytes(&self.secret_key)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl<'d> Deserialize<'d> for SigningKey {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'d>,\n    {\n        struct SigningKeyVisitor;\n\n        impl<'de> serde::de::Visitor<'de> for SigningKeyVisitor {\n            type Value = SigningKey;\n\n            fn expecting(&self, formatter: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(formatter, concat!(\"An ed25519 signing (private) key\"))\n            }\n\n            fn visit_bytes<E: serde::de::Error>(self, bytes: &[u8]) -> Result<Self::Value, E> {\n                SigningKey::try_from(bytes).map_err(E::custom)\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: serde::de::SeqAccess<'de>,\n            {\n                let mut bytes = [0u8; 32];\n                #[allow(clippy::needless_range_loop)]\n                for i in 0..32 {\n                    bytes[i] = seq\n                        .next_element()?\n                        .ok_or_else(|| serde::de::Error::invalid_length(i, &\"expected 32 bytes\"))?;\n                }\n\n                let remaining = (0..)\n                    .map(|_| seq.next_element::<u8>())\n                    .take_while(|el| matches!(el, Ok(Some(_))))\n                    .count();\n\n                if remaining > 0 {\n                    return Err(serde::de::Error::invalid_length(\n                        32 + remaining,\n                        &\"expected 32 bytes\",\n                    ));\n                }\n\n                Ok(SigningKey::from(bytes))\n            }\n        }\n\n        deserializer.deserialize_bytes(SigningKeyVisitor)\n    }\n}\n\n/// The spec-compliant way to define an expanded secret key. This computes `SHA512(sk)`, clamps the\n/// first 32 bytes and uses it as a scalar, and uses the second 32 bytes as a domain separator for\n/// hashing.\nimpl From<&SecretKey> for ExpandedSecretKey {\n    #[allow(clippy::unwrap_used)]\n    fn from(secret_key: &SecretKey) -> ExpandedSecretKey {\n        let hash = Sha512::default().chain_update(secret_key).finalize();\n        ExpandedSecretKey::from_bytes(hash.as_ref())\n    }\n}\n\n//\n// Signing functions. These are pub(crate) so that the `hazmat` module can use them\n//\n\nimpl ExpandedSecretKey {\n    /// The plain, non-prehashed, signing function for Ed25519. `CtxDigest` is the digest used to\n    /// calculate the pseudorandomness needed for signing. According to the spec, `CtxDigest =\n    /// Sha512`, and `self` is derived via the method defined in `impl From<&SigningKey> for\n    /// ExpandedSecretKey`.\n    ///\n    /// This definition is loose in its parameters so that end-users of the `hazmat` module can\n    /// change how the `ExpandedSecretKey` is calculated and which hash function to use.\n    #[allow(non_snake_case)]\n    #[allow(clippy::unwrap_used)]\n    #[inline(always)]\n    pub(crate) fn raw_sign<CtxDigest>(\n        &self,\n        message: &[&[u8]],\n        verifying_key: &VerifyingKey,\n    ) -> Signature\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n    {\n        // OK unwrap, update can't fail.\n        self.raw_sign_byupdate(\n            |h: &mut CtxDigest| {\n                message.iter().for_each(|slice| h.update(slice));\n                Ok(())\n            },\n            verifying_key,\n        )\n        .unwrap()\n    }\n\n    /// Sign a message provided in parts. The `msg_update` closure will be called twice to hash the\n    /// message parts. This closure MUST leave its hasher in the same state (i.e., must hash the\n    /// same values) after both calls. Otherwise it will produce an invalid signature.\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    pub(crate) fn raw_sign_byupdate<CtxDigest, F>(\n        &self,\n        msg_update: F,\n        verifying_key: &VerifyingKey,\n    ) -> Result<Signature, SignatureError>\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n        F: Fn(&mut CtxDigest) -> Result<(), SignatureError>,\n    {\n        let mut h = CtxDigest::new();\n\n        h.update(self.hash_prefix);\n        msg_update(&mut h)?;\n\n        let r = Scalar::from_hash(h);\n        let R: CompressedEdwardsY = EdwardsPoint::mul_base(&r).compress();\n\n        h = CtxDigest::new();\n        h.update(R.as_bytes());\n        h.update(verifying_key.as_bytes());\n        msg_update(&mut h)?;\n\n        let k = Scalar::from_hash(h);\n        let s: Scalar = (k * self.scalar) + r;\n\n        Ok(InternalSignature { R, s }.into())\n    }\n\n    /// The prehashed signing function for Ed25519 (i.e., Ed25519ph). `CtxDigest` is the digest\n    /// function used to calculate the pseudorandomness needed for signing. `MsgDigest` is the\n    /// digest function used to hash the signed message. According to the spec, `MsgDigest =\n    /// CtxDigest = Sha512`, and `self` is derived via the method defined in `impl\n    /// From<&SigningKey> for ExpandedSecretKey`.\n    ///\n    /// This definition is loose in its parameters so that end-users of the `hazmat` module can\n    /// change how the `ExpandedSecretKey` is calculated and which `CtxDigest` function to use.\n    #[cfg(feature = \"digest\")]\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    pub(crate) fn raw_sign_prehashed<CtxDigest, MsgDigest>(\n        &self,\n        prehashed_message: MsgDigest,\n        verifying_key: &VerifyingKey,\n        context: Option<&[u8]>,\n    ) -> Result<Signature, SignatureError>\n    where\n        CtxDigest: Digest<OutputSize = U64>,\n        MsgDigest: Digest<OutputSize = U64>,\n    {\n        let mut prehash: [u8; 64] = [0u8; 64];\n\n        let ctx: &[u8] = context.unwrap_or(b\"\"); // By default, the context is an empty string.\n\n        if ctx.len() > 255 {\n            return Err(SignatureError::from(InternalError::PrehashedContextLength));\n        }\n\n        let ctx_len: u8 = ctx.len() as u8;\n\n        // Get the result of the pre-hashed message.\n        prehash.copy_from_slice(prehashed_message.finalize().as_slice());\n\n        // This is the dumbest, ten-years-late, non-admission of fucking up the\n        // domain separation I have ever seen.  Why am I still required to put\n        // the upper half \"prefix\" of the hashed \"secret key\" in here?  Why\n        // can't the user just supply their own nonce and decide for themselves\n        // whether or not they want a deterministic signature scheme?  Why does\n        // the message go into what's ostensibly the signature domain separation\n        // hash?  Why wasn't there always a way to provide a context string?\n        //\n        // ...\n        //\n        // This is a really fucking stupid bandaid, and the damned scheme is\n        // still bleeding from malleability, for fuck's sake.\n        let mut h = CtxDigest::new()\n            .chain_update(b\"SigEd25519 no Ed25519 collisions\")\n            .chain_update([1]) // Ed25519ph\n            .chain_update([ctx_len])\n            .chain_update(ctx)\n            .chain_update(self.hash_prefix)\n            .chain_update(&prehash[..]);\n\n        let r = Scalar::from_hash(h);\n        let R: CompressedEdwardsY = EdwardsPoint::mul_base(&r).compress();\n\n        h = CtxDigest::new()\n            .chain_update(b\"SigEd25519 no Ed25519 collisions\")\n            .chain_update([1]) // Ed25519ph\n            .chain_update([ctx_len])\n            .chain_update(ctx)\n            .chain_update(R.as_bytes())\n            .chain_update(verifying_key.as_bytes())\n            .chain_update(&prehash[..]);\n\n        let k = Scalar::from_hash(h);\n        let s: Scalar = (k * self.scalar) + r;\n\n        Ok(InternalSignature { R, s }.into())\n    }\n}\n",
    "filename": "ed25519-dalek/src/signing.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  },
  "63688": {
    "text": "use crate::{InternalError, SignatureError};\n\n/// Ed25519 contexts as used by Ed25519ph.\n///\n/// Contexts are domain separator strings that can be used to isolate uses of\n/// the algorithm between different protocols (which is very hard to reliably do\n/// otherwise) and between different uses within the same protocol.\n///\n/// To create a context, call either of the following:\n///\n/// - [`SigningKey::with_context`](crate::SigningKey::with_context)\n/// - [`VerifyingKey::with_context`](crate::VerifyingKey::with_context)\n///\n/// For more information, see [RFC8032 § 8.3](https://www.rfc-editor.org/rfc/rfc8032#section-8.3).\n///\n/// # Example\n///\n#[cfg_attr(all(feature = \"digest\", feature = \"rand_core\"), doc = \"```\")]\n#[cfg_attr(\n    any(not(feature = \"digest\"), not(feature = \"rand_core\")),\n    doc = \"```ignore\"\n)]\n/// # fn main() {\n/// use ed25519_dalek::{Signature, SigningKey, VerifyingKey, Sha512};\n/// # use curve25519_dalek::digest::Digest;\n/// # use rand::rngs::OsRng;\n/// # use rand_core::TryRngCore;\n/// use ed25519_dalek::{DigestSigner, DigestVerifier};\n///\n/// # let mut csprng = OsRng.unwrap_err();\n/// # let signing_key = SigningKey::generate(&mut csprng);\n/// # let verifying_key = signing_key.verifying_key();\n/// let context_str = b\"Local Channel 3\";\n/// let prehashed_message = Sha512::default().chain_update(b\"Stay tuned for more news at 7\");\n///\n/// // Signer\n/// let signing_context = signing_key.with_context(context_str).unwrap();\n/// let signature = signing_context.sign_digest(prehashed_message.clone());\n///\n/// // Verifier\n/// let verifying_context = verifying_key.with_context(context_str).unwrap();\n/// let verified: bool = verifying_context\n///     .verify_digest(prehashed_message, &signature)\n///     .is_ok();\n///\n/// # assert!(verified);\n/// # }\n/// ```\n#[derive(Clone, Debug)]\npub struct Context<'k, 'v, K> {\n    /// Key this context is being used with.\n    key: &'k K,\n\n    /// Context value: a bytestring no longer than 255 octets.\n    value: &'v [u8],\n}\n\nimpl<'k, 'v, K> Context<'k, 'v, K> {\n    /// Maximum length of the context value in octets.\n    pub const MAX_LENGTH: usize = 255;\n\n    /// Create a new Ed25519ph context.\n    pub(crate) fn new(key: &'k K, value: &'v [u8]) -> Result<Self, SignatureError> {\n        if value.len() <= Self::MAX_LENGTH {\n            Ok(Self { key, value })\n        } else {\n            Err(SignatureError::from(InternalError::PrehashedContextLength))\n        }\n    }\n\n    /// Borrow the key.\n    pub fn key(&self) -> &'k K {\n        self.key\n    }\n\n    /// Borrow the context string value.\n    pub fn value(&self) -> &'v [u8] {\n        self.value\n    }\n}\n\n#[cfg(all(test, feature = \"digest\"))]\nmod test {\n    #![allow(clippy::unwrap_used)]\n\n    use crate::{Signature, SigningKey, VerifyingKey};\n    use curve25519_dalek::digest::Digest;\n    use rand::{TryRngCore, rngs::OsRng};\n    use sha2::Sha512;\n    use signature::{DigestSigner, DigestVerifier};\n\n    #[test]\n    fn context_correctness() {\n        let mut csprng = OsRng.unwrap_err();\n        let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n        let verifying_key: VerifyingKey = signing_key.verifying_key();\n\n        let context_str = b\"Local Channel 3\";\n        let prehashed_message = Sha512::default().chain_update(b\"Stay tuned for more news at 7\");\n\n        // Signer\n        let signing_context = signing_key.with_context(context_str).unwrap();\n        let signature: Signature = signing_context.sign_digest(prehashed_message.clone());\n\n        // Verifier\n        let verifying_context = verifying_key.with_context(context_str).unwrap();\n        let verified: bool = verifying_context\n            .verify_digest(prehashed_message, &signature)\n            .is_ok();\n\n        assert!(verified);\n    }\n}\n",
    "filename": "ed25519-dalek/src/context.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  },
  "63689": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2017-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\n//! A Rust implementation of ed25519 key generation, signing, and verification.\n//!\n//! # Example\n//!\n//! Creating an ed25519 signature on a message is simple.\n//!\n//! First, we need to generate a `SigningKey`, which includes both public and\n//! secret halves of an asymmetric key.  To do so, we need a cryptographically\n//! secure pseudorandom number generator (CSPRNG). For this example, we'll use\n//! the operating system's builtin PRNG:\n//!\n#![cfg_attr(feature = \"rand_core\", doc = \"```\")]\n#![cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n//! # fn main() {\n//! // $ cargo add ed25519_dalek --features rand_core\n//! use rand::rngs::OsRng;\n//! use rand_core::TryRngCore;\n//! use ed25519_dalek::SigningKey;\n//! use ed25519_dalek::Signature;\n//!\n//! let mut csprng = OsRng.unwrap_err();\n//! let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n//! # }\n//! ```\n//!\n//! We can now use this `signing_key` to sign a message:\n//!\n#![cfg_attr(feature = \"rand_core\", doc = \"```\")]\n#![cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n//! # fn main() {\n//! # use rand::rngs::OsRng;\n//! # use rand_core::TryRngCore;\n//! # use ed25519_dalek::SigningKey;\n//! # let mut csprng = OsRng.unwrap_err();\n//! # let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n//! use ed25519_dalek::{Signature, Signer};\n//! let message: &[u8] = b\"This is a test of the tsunami alert system.\";\n//! let signature: Signature = signing_key.sign(message);\n//! # }\n//! ```\n//!\n//! As well as to verify that this is, indeed, a valid signature on\n//! that `message`:\n//!\n#![cfg_attr(feature = \"rand_core\", doc = \"```\")]\n#![cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n//! # fn main() {\n//! # use rand::rngs::OsRng;\n//! # use rand_core::TryRngCore;\n//! # use ed25519_dalek::{SigningKey, Signature, Signer};\n//! # let mut csprng = OsRng.unwrap_err();\n//! # let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n//! # let message: &[u8] = b\"This is a test of the tsunami alert system.\";\n//! # let signature: Signature = signing_key.sign(message);\n//! use ed25519_dalek::Verifier;\n//! assert!(signing_key.verify(message, &signature).is_ok());\n//! # }\n//! ```\n//!\n//! Anyone else, given the `public` half of the `signing_key` can also easily\n//! verify this signature:\n//!\n#![cfg_attr(feature = \"rand_core\", doc = \"```\")]\n#![cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n//! # fn main() {\n//! # use rand::rngs::OsRng;\n//! # use rand_core::TryRngCore;\n//! # use ed25519_dalek::SigningKey;\n//! # use ed25519_dalek::Signature;\n//! # use ed25519_dalek::Signer;\n//! use ed25519_dalek::{VerifyingKey, Verifier};\n//! # let mut csprng = OsRng.unwrap_err();\n//! # let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n//! # let message: &[u8] = b\"This is a test of the tsunami alert system.\";\n//! # let signature: Signature = signing_key.sign(message);\n//!\n//! let verifying_key: VerifyingKey = signing_key.verifying_key();\n//! assert!(verifying_key.verify(message, &signature).is_ok());\n//! # }\n//! ```\n//!\n//! ## Serialisation\n//!\n//! `VerifyingKey`s, `SecretKey`s, `SigningKey`s, and `Signature`s can be serialised\n//! into byte-arrays by calling `.to_bytes()`.  It's perfectly acceptable and\n//! safe to transfer and/or store those bytes.  (Of course, never transfer your\n//! secret key to anyone else, since they will only need the public key to\n//! verify your signatures!)\n//!\n#![cfg_attr(feature = \"rand_core\", doc = \"```\")]\n#![cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n//! # fn main() {\n//! # use rand::rngs::OsRng;\n//! # use rand_core::TryRngCore;\n//! # use ed25519_dalek::{SigningKey, Signature, Signer, VerifyingKey};\n//! use ed25519_dalek::{PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH, KEYPAIR_LENGTH, SIGNATURE_LENGTH};\n//! # let mut csprng = OsRng.unwrap_err();\n//! # let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n//! # let message: &[u8] = b\"This is a test of the tsunami alert system.\";\n//! # let signature: Signature = signing_key.sign(message);\n//!\n//! let verifying_key_bytes: [u8; PUBLIC_KEY_LENGTH] = signing_key.verifying_key().to_bytes();\n//! let secret_key_bytes: [u8; SECRET_KEY_LENGTH] = signing_key.to_bytes();\n//! let signing_key_bytes:    [u8; KEYPAIR_LENGTH]    = signing_key.to_keypair_bytes();\n//! let signature_bytes:  [u8; SIGNATURE_LENGTH]  = signature.to_bytes();\n//! # }\n//! ```\n//!\n//! And similarly, decoded from bytes with `::from_bytes()`:\n//!\n#![cfg_attr(feature = \"rand_core\", doc = \"```\")]\n#![cfg_attr(not(feature = \"rand_core\"), doc = \"```ignore\")]\n//! # use core::convert::{TryFrom, TryInto};\n//! # use rand::rngs::OsRng;\n//! # use rand_core::TryRngCore;\n//! # use ed25519_dalek::{SigningKey, Signature, Signer, VerifyingKey, SecretKey, SignatureError};\n//! # use ed25519_dalek::{PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH, KEYPAIR_LENGTH, SIGNATURE_LENGTH};\n//! # fn do_test() -> Result<(SigningKey, VerifyingKey, Signature), SignatureError> {\n//! # let mut csprng = OsRng.unwrap_err();\n//! # let signing_key_orig: SigningKey = SigningKey::generate(&mut csprng);\n//! # let message: &[u8] = b\"This is a test of the tsunami alert system.\";\n//! # let signature_orig: Signature = signing_key_orig.sign(message);\n//! # let verifying_key_bytes: [u8; PUBLIC_KEY_LENGTH] = signing_key_orig.verifying_key().to_bytes();\n//! # let signing_key_bytes: [u8; SECRET_KEY_LENGTH] = signing_key_orig.to_bytes();\n//! # let signature_bytes:  [u8; SIGNATURE_LENGTH]  = signature_orig.to_bytes();\n//! #\n//! let verifying_key: VerifyingKey = VerifyingKey::from_bytes(&verifying_key_bytes)?;\n//! let signing_key: SigningKey = SigningKey::from_bytes(&signing_key_bytes);\n//! let signature: Signature = Signature::try_from(&signature_bytes[..])?;\n//! #\n//! # Ok((signing_key, verifying_key, signature))\n//! # }\n//! # fn main() {\n//! #     do_test();\n//! # }\n//! ```\n//!\n//! ### PKCS#8 Key Encoding\n//!\n//! PKCS#8 is a private key format with support for multiple algorithms.\n//! It can be encoded as binary (DER) or text (PEM).\n//!\n//! You can recognize PEM-encoded PKCS#8 keys by the following:\n//!\n//! ```text\n//! -----BEGIN PRIVATE KEY-----\n//! ```\n//!\n//! To use PKCS#8, you need to enable the `pkcs8` crate feature.\n//!\n//! The following traits can be used to decode/encode [`SigningKey`] and\n//! [`VerifyingKey`] as PKCS#8. Note that [`pkcs8`] is re-exported from the\n//! toplevel of the crate:\n//!\n//! - [`pkcs8::DecodePrivateKey`]: decode private keys from PKCS#8\n//! - [`pkcs8::EncodePrivateKey`]: encode private keys to PKCS#8\n//! - [`pkcs8::DecodePublicKey`]: decode public keys from PKCS#8\n//! - [`pkcs8::EncodePublicKey`]: encode public keys to PKCS#8\n//!\n//! #### Example\n//!\n//! NOTE: this requires the `pem` crate feature.\n//!\n#![cfg_attr(feature = \"pem\", doc = \"```\")]\n#![cfg_attr(not(feature = \"pem\"), doc = \"```ignore\")]\n//! use ed25519_dalek::{VerifyingKey, pkcs8::DecodePublicKey};\n//!\n//! let pem = \"-----BEGIN PUBLIC KEY-----\n//! MCowBQYDK2VwAyEAGb9ECWmEzf6FQbrBZ9w7lshQhqowtrbLDFw4rXAxZuE=\n//! -----END PUBLIC KEY-----\";\n//!\n//! let verifying_key = VerifyingKey::from_public_key_pem(pem)\n//!     .expect(\"invalid public key PEM\");\n//! ```\n//!\n//! ### Using Serde\n//!\n//! If you prefer the bytes to be wrapped in another serialisation format, all\n//! types additionally come with built-in [serde](https://serde.rs) support by\n//! building `ed25519-dalek` via:\n//!\n//! ```bash\n//! $ cargo build --features=\"serde\"\n//! ```\n//!\n//! They can be then serialised into any of the wire formats which serde supports.\n//! For example, using [bincode](https://github.com/TyOverby/bincode):\n//!\n#![cfg_attr(all(feature = \"rand_core\", feature = \"serde\"), doc = \"```\")]\n#![cfg_attr(not(all(feature = \"rand_core\", feature = \"serde\")), doc = \"```ignore\")]\n//! # fn main() {\n//! # use rand::rngs::OsRng;\n//! # use rand_core::TryRngCore;\n//! # use ed25519_dalek::{SigningKey, Signature, Signer, Verifier, VerifyingKey};\n//! use bincode::serialize;\n//! # let mut csprng = OsRng.unwrap_err();\n//! # let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n//! # let message: &[u8] = b\"This is a test of the tsunami alert system.\";\n//! # let signature: Signature = signing_key.sign(message);\n//! # let verifying_key: VerifyingKey = signing_key.verifying_key();\n//! # let verified: bool = verifying_key.verify(message, &signature).is_ok();\n//!\n//! let encoded_verifying_key: Vec<u8> = serialize(&verifying_key).unwrap();\n//! let encoded_signature: Vec<u8> = serialize(&signature).unwrap();\n//! # }\n//! ```\n//!\n//! After sending the `encoded_verifying_key` and `encoded_signature`, the\n//! recipient may deserialise them and verify:\n//!\n#![cfg_attr(all(feature = \"rand_core\", feature = \"serde\"), doc = \"```\")]\n#![cfg_attr(not(all(feature = \"rand_core\", feature = \"serde\")), doc = \"```ignore\")]\n//! # fn main() {\n//! # use rand::rngs::OsRng;\n//! # use rand_core::TryRngCore;\n//! # use ed25519_dalek::{SigningKey, Signature, Signer, Verifier, VerifyingKey};\n//! # use bincode::serialize;\n//! use bincode::deserialize;\n//!\n//! # let mut csprng = OsRng.unwrap_err();\n//! # let signing_key: SigningKey = SigningKey::generate(&mut csprng);\n//! let message: &[u8] = b\"This is a test of the tsunami alert system.\";\n//! # let signature: Signature = signing_key.sign(message);\n//! # let verifying_key: VerifyingKey = signing_key.verifying_key();\n//! # let verified: bool = verifying_key.verify(message, &signature).is_ok();\n//! # let encoded_verifying_key: Vec<u8> = serialize(&verifying_key).unwrap();\n//! # let encoded_signature: Vec<u8> = serialize(&signature).unwrap();\n//! let decoded_verifying_key: VerifyingKey = deserialize(&encoded_verifying_key).unwrap();\n//! let decoded_signature: Signature = deserialize(&encoded_signature).unwrap();\n//!\n//! # assert_eq!(verifying_key, decoded_verifying_key);\n//! # assert_eq!(signature, decoded_signature);\n//! #\n//! let verified: bool = decoded_verifying_key.verify(&message, &decoded_signature).is_ok();\n//!\n//! assert!(verified);\n//! # }\n//! ```\n\n#![no_std]\n#![warn(future_incompatible, rust_2018_idioms)]\n#![deny(missing_docs)] // refuse to compile if documentation is missing\n#![deny(clippy::unwrap_used)] // don't allow unwrap\n#![cfg_attr(not(any(test, feature = \"batch\")), forbid(unsafe_code))]\n#![cfg_attr(docsrs, feature(doc_auto_cfg, doc_cfg, doc_cfg_hide))]\n#![cfg_attr(docsrs, doc(cfg_hide(docsrs)))]\n\n#[cfg(feature = \"batch\")]\nextern crate alloc;\n\n#[cfg(test)]\n#[macro_use]\nextern crate std;\n\npub use ed25519;\n\n#[cfg(feature = \"batch\")]\nmod batch;\nmod constants;\n#[cfg(feature = \"digest\")]\nmod context;\nmod errors;\nmod signature;\nmod signing;\nmod verifying;\n\n#[cfg(feature = \"hazmat\")]\npub mod hazmat;\n#[cfg(not(feature = \"hazmat\"))]\nmod hazmat;\n\n#[cfg(feature = \"digest\")]\npub use curve25519_dalek::digest::Digest;\n#[cfg(feature = \"digest\")]\npub use sha2::Sha512;\n\n#[cfg(feature = \"batch\")]\npub use crate::batch::*;\npub use crate::constants::*;\n#[cfg(feature = \"digest\")]\npub use crate::context::Context;\npub use crate::errors::*;\npub use crate::signing::*;\npub use crate::verifying::*;\n\n// Re-export the `Signer` and `Verifier` traits from the `signature` crate\n#[cfg(feature = \"digest\")]\npub use ::signature::{DigestSigner, DigestVerifier};\npub use ed25519::Signature;\npub use ed25519::signature::{Signer, Verifier};\n\n#[cfg(feature = \"pkcs8\")]\npub use ed25519::pkcs8;\n",
    "filename": "ed25519-dalek/src/lib.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  },
  "63690": {
    "text": "// -*- mode: rust; -*-\n//\n// This file is part of ed25519-dalek.\n// Copyright (c) 2017-2019 isis lovecruft\n// See LICENSE for licensing information.\n//\n// Authors:\n// - isis agora lovecruft <isis@patternsinthevoid.net>\n\n//! Common constants such as buffer sizes for keypairs and signatures.\n\n/// The length of a ed25519 `Signature`, in bytes.\npub const SIGNATURE_LENGTH: usize = 64;\n\n/// The length of a ed25519 `SecretKey`, in bytes.\npub const SECRET_KEY_LENGTH: usize = 32;\n\n/// The length of an ed25519 `PublicKey`, in bytes.\npub const PUBLIC_KEY_LENGTH: usize = 32;\n\n/// The length of an ed25519 `Keypair`, in bytes.\npub const KEYPAIR_LENGTH: usize = SECRET_KEY_LENGTH + PUBLIC_KEY_LENGTH;\n\n/// The length of the \"key\" portion of an \"expanded\" ed25519 secret key, in bytes.\nconst EXPANDED_SECRET_KEY_KEY_LENGTH: usize = 32;\n\n/// The length of the \"nonce\" portion of an \"expanded\" ed25519 secret key, in bytes.\nconst EXPANDED_SECRET_KEY_NONCE_LENGTH: usize = 32;\n\n/// The length of an \"expanded\" ed25519 key, `ExpandedSecretKey`, in bytes.\npub const EXPANDED_SECRET_KEY_LENGTH: usize =\n    EXPANDED_SECRET_KEY_KEY_LENGTH + EXPANDED_SECRET_KEY_NONCE_LENGTH;\n",
    "filename": "ed25519-dalek/src/constants.rs",
    "filepath": null,
    "folder_id": 15849,
    "user_id": 460154
  }
}