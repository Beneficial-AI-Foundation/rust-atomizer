{
  "test.rs": [
    {
      "identifier": "from_uuid_bytes",
      "statement_type": "function",
      "deps": [
        "device_id",
        "name"
      ],
      "body": "        Self(uuid)    }    pub fn service_id_binary(&self) -> Vec<u8> {        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub const fn from_uuid_bytes(bytes: [u8; 16]) -> Self {\n        Self::from_uuid(uuid::Uuid::from_bytes(bytes))    }    fn accepts_ios_system_story_aci() {        state.write(self.0.as_bytes());    }    fn ordering_consistency() {",
      "display_name": "from_uuid_bytes",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "to_protocol_address",
      "statement_type": "function",
      "deps": [],
      "body": "        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub fn new(name: String, device_id: DeviceId) -> Self {        write!(f, \"<{}:{}>\", self.kind(), self.raw_uuid())    }    pub fn to_protocol_address(&self, device_id: DeviceId) -> ProtocolAddress {\n        ProtocolAddress::new(self.service_id_string(), device_id)    }    pub fn parse_from_service_id_string(input: &str) -> Option<Self> {        fn try_parse_hyphenated(input: &str) -> Option<Uuid> {\n            // uuid::Uuid supports multiple UUID formats; we only want to support the \"hyphenated\"\n            // form.\n            if input.len() != uuid::fmt::Hyphenated::LENGTH {\n                return None;\n            }\n            Uuid::try_parse(input).ok()\n        }        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub fn new(name: String, device_id: DeviceId) -> Self {",
      "display_name": "to_protocol_address",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "accepts_ios_system_story_aci",
      "statement_type": "function",
      "deps": [],
      "body": "        Self::from_uuid(uuid::Uuid::from_bytes(bytes))    }    fn accepts_ios_system_story_aci() {        state.write(self.0.as_bytes());    }    fn ordering_consistency() {\n        proptest!(|(    }    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {        assert!(ServiceId::parse_from_service_id_string(\"\").is_none());    }    fn rejects_invalid_types() {",
      "display_name": "accepts_ios_system_story_aci",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "eq",
      "statement_type": "function",
      "deps": [],
      "body": "        &self.name        }    }    fn eq(&self, other: &ServiceId) -> bool {\n        ServiceId::from(*self) == *other    }    pub fn parse_from_service_id_fixed_width_binary(        }    }    fn rejects_invalid_binary_lengths() {",
      "display_name": "eq",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "device_id",
      "statement_type": "function",
      "deps": [],
      "body": "        Self::from_uuid(value)    }    pub fn device_id(&self) -> DeviceId {        }    }    fn conversions() {\n        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    fn try_from(value: ServiceId) -> Result<Self, Self::Error> {    }    fn round_trip_service_id_fixed_width_binary() {",
      "display_name": "device_id",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "round_trip_test",
      "statement_type": "function",
      "deps": [],
      "body": "        });    }    fn rejects_invalid_uuid_strings() {    }    fn round_trip_test<SerializedOwned, SerializedBorrowed>(\n        uuid: Uuid,",
      "display_name": "round_trip_test",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "parse_from_service_id_fixed_width_binary",
      "statement_type": "function",
      "deps": [],
      "body": "        let mut result = [0; 17];    }    fn logging() {        ServiceId::from(*self) == *other    }    pub fn parse_from_service_id_fixed_width_binary(\n        bytes: &ServiceIdFixedWidthBinaryBytes,",
      "display_name": "parse_from_service_id_fixed_width_binary",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "new",
      "statement_type": "function",
      "deps": [],
      "body": "        }        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub fn new(name: String, device_id: DeviceId) -> Self {\n        ProtocolAddress { name, device_id }    }    fn ordering() {    }    }    pub fn service_id_string(&self) -> String {",
      "display_name": "new",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "ordering_consistency",
      "statement_type": "function",
      "deps": [],
      "body": "        Self::from_uuid(uuid::Uuid::from_bytes(bytes))    }    fn accepts_ios_system_story_aci() {        state.write(self.0.as_bytes());    }    fn ordering_consistency() {\n        proptest!(|(    }    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {        assert!(ServiceId::parse_from_service_id_string(\"\").is_none());    }    fn rejects_invalid_types() {",
      "display_name": "ordering_consistency",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "service_id_string",
      "statement_type": "function",
      "deps": [],
      "body": "        ProtocolAddress { name, device_id }    }    fn ordering() {    }    }    pub fn service_id_string(&self) -> String {\n        if let Self::Aci(aci) = self {\n            aci.0.to_string()\n        } else {\n            format!(\"{}:{}\", self.kind(), self.raw_uuid())\n        }    }    fn conversions() {",
      "display_name": "service_id_string",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "round_trip_service_id_fixed_width_binary",
      "statement_type": "function",
      "deps": [],
      "body": "        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    fn try_from(value: ServiceId) -> Result<Self, Self::Error> {    }    fn round_trip_service_id_fixed_width_binary() {\n        proptest!(|(uuid_bytes: [u8; 16])| {\n            let uuid = Uuid::from_bytes(uuid_bytes);\n            round_trip_test(\n                uuid,\n                ServiceId::service_id_fixed_width_binary,\n                Aci::service_id_fixed_width_binary,\n                Pni::service_id_fixed_width_binary,\n                ServiceId::parse_from_service_id_fixed_width_binary,\n                Aci::parse_from_service_id_fixed_width_binary,\n                Pni::parse_from_service_id_fixed_width_binary,\n                &array_prepend(0x00, uuid.as_bytes()),\n                &array_prepend(0x01, uuid.as_bytes()),\n            );\n        });        }    }    pub fn service_id_fixed_width_binary(&self) -> ServiceIdFixedWidthBinaryBytes {",
      "display_name": "round_trip_service_id_fixed_width_binary",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "try_from",
      "statement_type": "function",
      "deps": [],
      "body": "        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    fn try_from(value: ServiceId) -> Result<Self, Self::Error> {    }    fn round_trip_service_id_fixed_width_binary() {\n        proptest!(|(uuid_bytes: [u8; 16])| {\n            let uuid = Uuid::from_bytes(uuid_bytes);\n            round_trip_test(\n                uuid,\n                ServiceId::service_id_fixed_width_binary,\n                Aci::service_id_fixed_width_binary,\n                Pni::service_id_fixed_width_binary,\n                ServiceId::parse_from_service_id_fixed_width_binary,\n                Aci::parse_from_service_id_fixed_width_binary,\n                Pni::parse_from_service_id_fixed_width_binary,\n                &array_prepend(0x00, uuid.as_bytes()),\n                &array_prepend(0x01, uuid.as_bytes()),\n            );\n        });        }    }    pub fn service_id_fixed_width_binary(&self) -> ServiceIdFixedWidthBinaryBytes {",
      "display_name": "try_from",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "raw_uuid",
      "statement_type": "function",
      "deps": [],
      "body": "        }    }    fn rejects_invalid_binary_lengths() {        });    }    pub fn raw_uuid(self) -> Uuid {\n        match self {\n            ServiceId::Aci(aci) => aci.into(),\n            ServiceId::Pni(pni) => pni.into(),\n        }    }    pub fn service_id_fixed_width_binary(&self) -> ServiceIdFixedWidthBinaryBytes {        &self.name    }    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
      "display_name": "raw_uuid",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "parse_from_service_id_string",
      "statement_type": "function",
      "deps": [],
      "body": "        ProtocolAddress::new(self.service_id_string(), device_id)    }    pub fn parse_from_service_id_string(input: &str) -> Option<Self> {        fn try_parse_hyphenated(input: &str) -> Option<Uuid> {\n            // uuid::Uuid supports multiple UUID formats; we only want to support the \"hyphenated\"\n            // form.\n            if input.len() != uuid::fmt::Hyphenated::LENGTH {\n                return None;\n            }\n            Uuid::try_parse(input).ok()\n        }        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub fn new(name: String, device_id: DeviceId) -> Self {",
      "display_name": "parse_from_service_id_string",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "fmt",
      "statement_type": "function",
      "deps": [],
      "body": "        proptest!(|(    }    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {        assert!(ServiceId::parse_from_service_id_string(\"\").is_none());    }    fn rejects_invalid_types() {\n        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub fn new(name: String, device_id: DeviceId) -> Self {        write!(f, \"<{}:{}>\", self.kind(), self.raw_uuid())    }    pub fn to_protocol_address(&self, device_id: DeviceId) -> ProtocolAddress {",
      "display_name": "fmt",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "parse_from_service_id_binary",
      "statement_type": "function",
      "deps": [],
      "body": "        }        self.device_id    }    pub fn parse_from_service_id_binary(bytes: &[u8]) -> Option<Self> {\n        match bytes.len() {\n            16 => Some(Self::Aci(Uuid::from_slice(bytes).ok()?.into())),\n            17 => {\n                let result = Self::parse_from_service_id_fixed_width_binary(\n                    bytes.try_into().expect(\"already measured\"),\n                )?;\n                if result.kind() == ServiceIdKind::Aci {\n                    // The ACI is unmarked in the standard binary format, so this is an error.\n                    None\n                } else {\n                    Some(result)\n                }\n            }\n            _ => None,\n        }    }    fn array_prepend(tag: u8, uuid_bytes: &[u8; 16]) -> [u8; 17] {        });    }    fn rejects_invalid_uuid_strings() {",
      "display_name": "parse_from_service_id_binary",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "rejects_invalid_binary_lengths",
      "statement_type": "function",
      "deps": [],
      "body": "        }    }    fn rejects_invalid_binary_lengths() {        });    }    pub fn raw_uuid(self) -> Uuid {\n        match self {\n            ServiceId::Aci(aci) => aci.into(),\n            ServiceId::Pni(pni) => pni.into(),\n        }    }    pub fn service_id_fixed_width_binary(&self) -> ServiceIdFixedWidthBinaryBytes {        &self.name    }    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
      "display_name": "rejects_invalid_binary_lengths",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "rejects_invalid_uuid_strings",
      "statement_type": "function",
      "deps": [],
      "body": "        }    }    fn array_prepend(tag: u8, uuid_bytes: &[u8; 16]) -> [u8; 17] {        });    }    fn rejects_invalid_uuid_strings() {\n        assert!(ServiceId::parse_from_service_id_string(\"\").is_none());    }    fn rejects_invalid_types() {        }    }    fn from(value: Uuid) -> Self {",
      "display_name": "rejects_invalid_uuid_strings",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "round_trip_service_id_binary",
      "statement_type": "function",
      "deps": [],
      "body": "    }    fn round_trip_service_id_binary() {\n        proptest!(|(uuid_bytes: [u8; 16])| {\n            let uuid = Uuid::from_bytes(uuid_bytes);\n            round_trip_test(\n                uuid,\n                ServiceId::service_id_binary,\n                Aci::service_id_binary,\n                Pni::service_id_binary,\n                ServiceId::parse_from_service_id_binary,\n                Aci::parse_from_service_id_binary,\n                Pni::parse_from_service_id_binary,\n                uuid.as_bytes(),\n                &array_prepend(0x01, uuid.as_bytes()),\n            );\n        });",
      "display_name": "round_trip_service_id_binary",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "rejects_invalid_types",
      "statement_type": "function",
      "deps": [],
      "body": "        proptest!(|(    }    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {        assert!(ServiceId::parse_from_service_id_string(\"\").is_none());    }    fn rejects_invalid_types() {\n        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub fn new(name: String, device_id: DeviceId) -> Self {        write!(f, \"<{}:{}>\", self.kind(), self.raw_uuid())    }    pub fn to_protocol_address(&self, device_id: DeviceId) -> ProtocolAddress {",
      "display_name": "rejects_invalid_types",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "ordering",
      "statement_type": "function",
      "deps": [],
      "body": "        ProtocolAddress { name, device_id }    }    fn ordering() {    }    }    pub fn service_id_string(&self) -> String {\n        if let Self::Aci(aci) = self {\n            aci.0.to_string()\n        } else {\n            format!(\"{}:{}\", self.kind(), self.raw_uuid())\n        }    }    fn conversions() {",
      "display_name": "ordering",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "service_id_fixed_width_binary",
      "statement_type": "function",
      "deps": [],
      "body": "        });        }    }    pub fn service_id_fixed_width_binary(&self) -> ServiceIdFixedWidthBinaryBytes {\n        let mut result = [0; 17];    }    fn logging() {        ServiceId::from(*self) == *other    }    pub fn parse_from_service_id_fixed_width_binary(",
      "display_name": "service_id_fixed_width_binary",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "hash",
      "statement_type": "function",
      "deps": [],
      "body": "        }    }    pub fn service_id_fixed_width_binary(&self) -> ServiceIdFixedWidthBinaryBytes {        &self.name    }    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n        state.write(self.0.as_bytes());    }    fn ordering_consistency() {    }    pub fn parse_from_service_id_fixed_width_binary(    }    fn round_trip_service_id_string() {",
      "display_name": "hash",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "conversions",
      "statement_type": "function",
      "deps": [],
      "body": "        }    }    fn conversions() {",
      "display_name": "conversions",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "logging",
      "statement_type": "function",
      "deps": [],
      "body": "        let mut result = [0; 17];    }    fn logging() {        ServiceId::from(*self) == *other    }    pub fn parse_from_service_id_fixed_width_binary(\n        bytes: &ServiceIdFixedWidthBinaryBytes,",
      "display_name": "logging",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "kind",
      "statement_type": "function",
      "deps": [],
      "body": "    }    pub fn kind(&self) -> ServiceIdKind {\n        match self {\n            ServiceId::Aci(_) => ServiceIdKind::Aci,\n            ServiceId::Pni(_) => ServiceIdKind::Pni,\n        }",
      "display_name": "kind",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "case_insensitive",
      "statement_type": "function",
      "deps": [],
      "body": "        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    fn case_insensitive() {        Self(uuid)    }    pub fn service_id_binary(&self) -> Vec<u8> {\n        if let Self::Aci(aci) = self {\n            aci.0.as_bytes().to_vec()\n        } else {\n            self.service_id_fixed_width_binary().to_vec()\n        }    }    fn rejects_invalid_binary_lengths() {        });    }    pub fn raw_uuid(self) -> Uuid {",
      "display_name": "case_insensitive",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "from_uuid",
      "statement_type": "function",
      "deps": [],
      "body": "    }    }    pub fn service_id_string(&self) -> String {        let mut result = [tag; 17];    }    const fn from_uuid(uuid: Uuid) -> Self {\n        Self(uuid)    }    pub fn service_id_binary(&self) -> Vec<u8> {        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub const fn from_uuid_bytes(bytes: [u8; 16]) -> Self {",
      "display_name": "from_uuid",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "service_id_binary",
      "statement_type": "function",
      "deps": [],
      "body": "        Self(uuid)    }    pub fn service_id_binary(&self) -> Vec<u8> {        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub const fn from_uuid_bytes(bytes: [u8; 16]) -> Self {\n        Self::from_uuid(uuid::Uuid::from_bytes(bytes))    }    fn accepts_ios_system_story_aci() {        state.write(self.0.as_bytes());    }    fn ordering_consistency() {",
      "display_name": "service_id_binary",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "try_parse_hyphenated",
      "statement_type": "function",
      "deps": [],
      "body": "        ProtocolAddress::new(self.service_id_string(), device_id)    }    pub fn parse_from_service_id_string(input: &str) -> Option<Self> {        fn try_parse_hyphenated(input: &str) -> Option<Uuid> {\n            // uuid::Uuid supports multiple UUID formats; we only want to support the \"hyphenated\"\n            // form.\n            if input.len() != uuid::fmt::Hyphenated::LENGTH {\n                return None;\n            }\n            Uuid::try_parse(input).ok()\n        }        let uuid = uuid::uuid!(\"8c78cd2a-16ff-427d-83dc-1a5e36ce713d\");    }    pub fn new(name: String, device_id: DeviceId) -> Self {",
      "display_name": "try_parse_hyphenated",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "name",
      "statement_type": "function",
      "deps": [],
      "body": "    }    pub fn name(&self) -> &str {\n        &self.name",
      "display_name": "name",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "array_prepend",
      "statement_type": "function",
      "deps": [],
      "body": "        }    }    fn array_prepend(tag: u8, uuid_bytes: &[u8; 16]) -> [u8; 17] {        });    }    fn rejects_invalid_uuid_strings() {\n        assert!(ServiceId::parse_from_service_id_string(\"\").is_none());    }    fn rejects_invalid_types() {        }    }    fn from(value: Uuid) -> Self {",
      "display_name": "array_prepend",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "round_trip_service_id_string",
      "statement_type": "function",
      "deps": [],
      "body": "    }    pub fn parse_from_service_id_fixed_width_binary(    }    fn round_trip_service_id_string() {        }    }    fn array_prepend(tag: u8, uuid_bytes: &[u8; 16]) -> [u8; 17] {\n        let mut result = [tag; 17];    }    const fn from_uuid(uuid: Uuid) -> Self {    }    pub fn kind(&self) -> ServiceIdKind {",
      "display_name": "round_trip_service_id_string",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    },
    {
      "identifier": "from",
      "statement_type": "function",
      "deps": [],
      "body": "    }    fn from(value: Uuid) -> Self {\n        Self::from_uuid(value)",
      "display_name": "from",
      "full_path": "file:///work/2972/test.rs",
      "relative_path": "test.rs",
      "file_name": "test.rs",
      "parent_folder": "2972"
    }
  ]
}